Int. J. Inf. Secur. (2012) 11:349–363
DOI 10.1007/s10207-012-0169-2

REGULAR CONTRIBUTION

Strong accumulators from collision-resistant hashing
Philippe Camacho · Alejandro Hevia · Marcos Kiwi ·
Roberto Opazo

Published online: 17 July 2012
© Springer-Verlag 2012

Abstract Accumulator schemes were introduced in order
to represent a large set of values as one short value called the
accumulator. These schemes allow one to generate membership 
proofs, that is, short witnesses that a certain value
belongs to the set. In universal accumulator schemes, efﬁcient
proofs of non-membership can also be created. Li et al. (Proceedings 
of applied cryptography and network security—
ACNS ’07, LNCS, vol 4521, 2007), building on the work
of Camenisch and Lysyanskaya (Advances in cryptology—
proceedings of Crypto ’02, LNCS, vol 2442. Springer, Berlin,
pp 61–76, 2002), proposed an efﬁcient accumulator scheme,
which relies on a trusted accumulator manager. Specifically,
a manager that correctly performs accumulator updates.

A preliminary version of this work appeared in proceedings of the 11th
Information Security Conference, ISC’08, Lecture Notes in Computer
Science 5222, pages 471–486, Springer-Verlag, 2008. Mr. Camacho
gratefully acknowledges the support of CONICYT via FONDAP en
Matemáticas Aplicadas. Mr. Hevia gratefully acknowledges the support
of CONICYT via FONDECYT No. 1070332. Mr. Kiwi is supported
by CONICYT via FONDECYT No. 1010689 and FONDAP-Basal in
Applied Mathematics, and Millenium Nucleus Information and Coordination 
in Networks ICM/FIC P10-024F.

P. Camacho · A. Hevia (B)

Department of Computer Science, University of Chile,
Blanco Encalada 2120, 3er piso, Santiago, Chile
e-mail: ahevia@dcc.uchile.cl

P. Camacho
e-mail: pcamacho@dcc.uchile.cl

M. Kiwi
Depto. Ing. Matemática and Ctr. Modelamiento Matemático UMI
2807, U. Chile, Santiago, Chile
URL: www.dim.uchile.cl/∼mkiwi

R. Opazo
CEO khipu.com, Santiago, Chile
e-mail: roberto@opazo.cl

In this work, we introduce the notion of strong universal
accumulator schemes, which are similar in functionality to
universal accumulator schemes, but do not assume the accumulator 
manager is trusted. We also formalize the security
requirements for such schemes. We then give a simple construction 
of a strong universal accumulator scheme, which is
provably secure under the assumption that collision-resistant
hash functions exist. The weaker requirement on the accumulator 
manager comes at a price; our scheme is less efﬁcient 
than known universal accumulator schemes—the size
of (non)membership witnesses is logarithmic in the size of
the accumulated set in contrast to constant in the scheme of
Camenisch and Lysyanskaya. Finally, we show how to use
strong universal accumulators to solve a problem of practical
relevance, the so-called e-Invoice Factoring Problem.
Strong accumulators · Collision-resistant

Keywords
hashing · e-invoice

1 Introduction

Accumulator schemes were introduced by Benaloh and De
Mare [4]. These primitives allow to represent a potentially
very large set by a short value called accumulator. Moreover,
the accumulator together with a so-called witness provides
an efﬁciently veriﬁable proof that a given element belongs to
the accumulated set.

Bari´c and Pﬁtzmann [2] reﬁned the security definition of
accumulator schemes and introduced the concept of colli-
sion-free accumulators. This notion was further extended by
Camenisch and Lysyanskaya [7] to a dynamic setting where
updates (additions and deletions) to the accumulator are possible.
 They proposed a new construction and showed how

123

350

P. Camacho et al.

to use it to efﬁciently implement membership revocation in
group signatures and anonymous credential systems. In particular,
 they show how to keep track of valid identities using
an accumulator, so proving membership is done by arguing
in zero knowledge that a certain secret value was accumulated.
 For a thorough discussion of accumulators, we refer the
interested reader to the survey of Fazio and Nicolosi [10].

Li, Li, and Xue [15] recently introduced the notion of
universal accumulators, which not only allow efﬁcient generation 
of membership, but also of non-membership proofs.
Building on [7], Li et al. construct universal accumulator
schemes and point out useful applications, for example proving 
that a certificate has not been revoked or that a patient
does not have a disease. Unfortunately, their construction
inherits an undesirable property from Camenisch and Lys-
yanskaya’s scheme; updates of the set (in particular, deletion
of elements) require the accumulator manager to be trusted.
This falls short of Benaloh and De Mare’s initial goal: to provide 
membership proofs even if the accumulator manager is
corrupted. In both [7] and [15], a malicious manager can
compute witnesses for any element regardless of whether it
was accumulated or not.

We propose a new accumulator scheme based on hash trees
similar to those used in the design of digital timestamping
systems [3,4]. Recall that in hash trees, values are associated
with leaves of a binary tree. The values of sibling nodes are
hashed in order to compute the value associated with their
parent node, and so on and so forth, until a value for the root
of the tree is obtained. The tree’s root value is deﬁned as the
accumulator of the set of values associated with the leaves of
the tree. We cannot directly use hash trees to obtain the functionality 
of universal and dynamic accumulators. Indeed, we
need to add and delete elements from the accumulated set
(tree node values if using hash trees) while at the same time
be able to produce non-membership proofs. We solve this last
issue using a trick due to Kocher [14]; instead of associating
values to the tree’s leaves, we associated a pair of consecutive
accumulated set elements. To prove that an element x is not
in the accumulated set now amounts to showing that a pair
(xα, xβ ), where xα ≺ x ≺ xβ, belongs to the tree but the
pairs (xα, x) and (x, xβ ) do not.

The drawbacks of using a hash tree-based scheme are twofold.
 First, the size of witnesses and the update time are logarithmic 
in the number of values accumulated. In contrast,
witnesses and updates can be computed in constant time in
RSA modular exponentiation-based schemes like the ones
of [2,4,7,15]. We believe, nonetheless, that this problem may
in fact not exist for reasonable set sizes—a claim that we
will later support. The second drawback is the accumula-
tor’s manager storage space requirements, which is linear in
the number of elements. However, this is not an issue for the
accumulator’s users, since they only need logarithmic in the
accumulated set size storage space.

123

Overall, the main advantages of our scheme in comparison 
with Li et al. [15] are (1) the accumulator manager need
not be trusted, and (2) since we only assume the existence of
cryptographic hash functions as opposed to the strong RSA
assumption, the underlying security assumption is (argu-
ably) weaker. (Indeed, collision resistance can be based on
the intractability of factoring or computing discrete logarithms 
[9] while strong RSA is likely to be a stronger assumption 
than factoring [5].)

1.1 Our contributions

Our contribution is threefold. First, we strengthen the basic
definition of universal accumulators by allowing an adversary 
to corrupt the accumulator manager. This gives rise to the
notion of strong universal accumulators. Second, we show
how to construct strong universal accumulators using only
collision-resistant hash functions. Our construction has interesting 
properties of its own. As in [7,15], we use auxiliary
information to compute the (non)membership witness, but
this information (called memory) need not be kept private,
and does not allow an adversary to prove inconsistent statements 
about the accumulated set. Indeed, the construction
provides almost the same functionality as the (dynamic) universal 
accumulators described in [15], namely:

– All the elements of the set are accumulated in one short

value.

– It is possible to add and remove elements from the accumulated 
set.

– For every element of the input space there exists a witness
that proves whether the element has been accumulated or
not.

Our last contribution is showing how to apply strong universal 
accumulators to solve a multi-party computational
problem of practical relevance, which we name the e-Invoice
Factoring Problem. Solving this problem was indeed the
original motivation that gave rise to this work.

1.2 Organization of the paper

In Sect. 2, we give some background definitions and formally 
introduce the notion of strong universal accumulator
schemes. In Sect. 3, we describe our basic strong universal 
accumulator scheme and rigorously establish its security.
In Sect. 4, we discuss the efﬁciency of the scheme in practice.
 The e-Invoice Factoring Problem is described in Sect. 5
where it is also shown how to solved it using strong universal 
accumulator schemes. In Sect. 6, we conclude with some
comments.

Strong accumulators from collision-resistant hashing

351

(cid:2)

x1

R← R1(), . . . , x(cid:4)

2 Definitions and notations
Let neg : N → R denotes a negligible function, that is,
for every polynomial p(·) and any large enough integer n,
neg(n) < 1/ p(n). Let also|| denotes the operation of concatenation 
between binary strings. If R() is a randomized algorithm,
 we write a R← R() to denote the process of choosing
a according to the probability distribution induced by R. Let
denotes the probabilPr

R← R(cid:4)()
ity of event E after the processes x1
are performed in order. We also denote by (cid:6)R()(cid:7) the set of all
possible values a returned by randomized algorithm R with
positive probability. We distinguish between an accumulator
scheme (the protocol, see below), its short representation or
accumulator value, and its corresponding accumulated set
X. For simplicity, however, we may use these terms indistinguishably 
when it is clear from the context.

R← R1(), . . . , x(cid:4)

(cid:3)

R← R(cid:4)() : E

Syntax. We formally deﬁne the syntax of a strong universal
accumulator scheme (with memory). Our definition differs
from that of Li et al. [15] as we consider an algorithm to verify 
whether the accumulator value has been updated correctly
(by adding or deleting a certain value), and we are not interested 
in hiding the order in which the elements are inserted
into the accumulated set.

Deﬁnition 1 (Strong universal accumulators with memory)
Let M be a set of values. A strong universal accumulator 
scheme (with memory) for M is a tuple A =
(Setup,Witness,CheckWitness, Update,CheckUpdate)
where

– Setup(κ) is a randomized algorithm which on input some
initialization parameter κ, outputs a public data structure 
m0 (also called the memory), a creation witness w,
and an initial accumulator value Acc0 which is in the
set Y = {0, 1}k. Value κ is assumed to include at least
a security parameter k ∈ N in unary, but it may also
include some optional system-wide parameters possibly
generated by a trusted initialization process. An empty set
X ⊆ M is associated to the execution of the scheme, and
in particular, to Acc0. Both the accumulator value Acc0
and the memory m0 will be typically held and updated by
the accumulator manager.
– Witness(κ, x, m) is a randomized algorithm that takes
as input x ∈ M and memory m, and outputs a witness of
membership w if x ∈ X (x has been accumulated) or a
witness of nonmembership w(cid:10)
– CheckWitness(κ, x, w, Acc) is a randomized algorithm
which on input a value x ∈ M, a witness w and the accumulator 
value Acc ∈ Y outputs a bit 1 if w is deemed a
valid witness that x ∈ X, outputs 0 if w is deemed a valid

if x (cid:11)∈ X.

witness that x (cid:11)∈ X, or outputs the special symbol ⊥ if w
is not a valid witness of either statement.

– Updateop(κ, x, Accbefore, mbefore) is a randomized algorithm 
that updates the accumulator value by either adding 
an element (op = add) to or removing an element
(op = del) from the accumulated set. The algorithm
takes an element x ∈ M, an accumulator and memory
pair (Accbefore, mbefore), and outputs an updated accumulator 
and memory pair (Accafter, mafter ), and an update
witness wop = (w, op).

– CheckUpdate(κ, x, Accbefore, Accafter, wop) is a randomized 
algorithm that takes as input a a pair of accumulator 
values (Accbefore, Accafter), a value x ∈ M ∪ {⊥},
and an update witness wop = (w, op) where op ∈
{add, del, crt}, and returns a bit b. Typically, this algorithm 
will be executed by parties other than the accumulator 
manager in order to verify correct update of the
accumulator by the manager. If x = ⊥, op = crt, and
b = 1, then wop is deemed a valid creation witness of the
accumulated set X = ∅. If b = 1, wop is deemed a valid
witness that the update operation (for op ∈ {add, del})
which replaced Accbefore with Accafter as the accumulator
value, was valid. Otherwise, wop is deemed invalid for
the given accumulator pair.

All the above algorithms are supposed to have complexity
polynomial in the security parameter k.

In the above definition, memory m is a public data
structure that is computed from set X. Although public,
this structure only needs to be maintained (stored) by the
accumulator manager who requires it to update the accumulator 
and to generate membership and non-membership witnesses.
 In particular, this memory is not used to verify correct
accumulator updates nor to check the validity of (non)membership 
witnesses.

Strong universal accumulators with memory as deﬁned
above are intended for use in a multi-party protocol setting
where procedures Setup, Witness, and Updateop are executed 
by a manager and CheckWitness and CheckUpdate
by the other participants of the multi-party protocol.

Security. Universal accumulators as deﬁned in [15] satisfy a
basic consistency property: it must be unfeasible to ﬁnd both
a valid membership witness and a valid non-membership witness 
for the same value x ∈ M. As mentioned there, this is
equivalent to saying that given X ⊆ M, it is impossible to
ﬁnd x ∈ X that has a valid non-membership witness or to
ﬁnd x ∈ M\X that has a valid membership witness.

In order to be able to cope with malicious accumulator
managers, we ﬁrst need to guarantee that the accumulator
value is consistent with the elements supposedly added and
removed by the manager. We therefore deﬁne what it means
for an accumulator to represent a set, and then the security

123

352

P. Camacho et al.

conditions that guarantee that such representation is sound
even under the presence of malicious (but computationally
bounded) managers. Our presentation uses a formalism based
on initialization procedures to accommodate protocols whose
security may require some setup assumptions (e.g., an initial
round of generation of trusted system-wide parameters1).

Deﬁnition 2 An accumulator value Acc represents the set
X ⊆ M under initialization parameters κ, denoted by Acc κ⇒
X, if and only if there exists a sequence {(Acci , xi , mi ,
opi )}1≤i≤n, where n = |X|, xi ∈ M for 1 ≤ i ≤ n,
opi ∈ {add, del}, and Acc0 ∈ Y and m0 are values such
that
– X = {xi}1≤i≤n ,
– (Acc0, m0) ∈ (cid:6)Setup(κ)(cid:7) ,
– (Acci , mi , wi ) ∈ (cid:6)Updateopi

(κ, xi , Acci−1, mi−1)(cid:7) for

all 1 ≤ i ≤ n.

If no such sequence exists, Acc does not represents set X,
denoted by Acc κ

(cid:2) X.

Note that, regardless of the choice of κ, there could be two
different sequences that make Acc κ⇒ X. More importantly,
even for ﬁxed κ, the above definition does not imply that the
represented set X is unique for a given accumulated value
Acc. Our definition of security, however, will ensure that
as long as each accumulator update operation is veriﬁed by
a honest observer (running CheckUpdate), such collisions
will not happen except with negligible probability. Before
proving this, we need to introduce our main security notion
for accumulators.

We adapt the security definition in [15] as follows. First,
we let the adversary select not only the value x and the witness 
w but also the accumulated set X ⊆ M, the accumulator
value Acc ∈ Y and whether x belongs or not to X. We restrict
the adversary so he must choose a pair (Acc, X ) for which
there exists a sequence of valid addition operations (namely,
Updateadd with values in X) that can produce an accumulated 
value Acc. This last restriction can be justiﬁed by noticing 
that, in the scenario we consider, parties other than the
accumulator manager can externally verify the correctness of
each update operation by using the CheckUpdate algorithm.
Finally, to capture most setup assumptions, we parameterize
the security notion with the following notion:

Deﬁnition 3 An oracle  is an initialization procedure if
given a security parameter k ∈ N in unary, it generates a
parameter κ = (κ0, 1k ) where κ0 is of length polynomial in
k. Invoking  will be assumed to take a single time step.

1 In fact, our main construction does require trusted selection of a random 
hash function.

123

The initialization procedure will be used to model a setup
process that is not under adversarial control. Clearly, the case
of no setup assumptions corresponds to the special case when
(1k ) = 1k.

Deﬁnition 4 (Security of strong universal accumulators
with memory)
Let A be a strong universal accumulator scheme (with
memory) for universe M, k ∈ N be a security parameter and
 be an initialization procedure. Then, A is secure under  if
for every probabilistic polynomial-time adversary A(atk,·)
with atk ∈ {cons, crt, add, del}, the following conditions 
hold:

– (Consistency)

⎡
⎢⎣

Pr

κ = (κ0, 1k ) R← (1k ),

(x, w1, w2, X, Acc) ← A(cons, κ) : Acc κ⇒ X,

CheckWitness(κ, x, w1, Acc) = 1,
CheckWitness(κ, x, w2, Acc) = 0

κ = (κ0, 1k ) R← (1k ),

(w, Accafter ) ← A(crt, κ) : Accafter
(cid:2) ∅,
CheckUpdate(κ,⊥,⊥, Accafter , (w, crt)) = 1

κ

κ = (κ0, 1k ) R← (1k ),

(Accbefore, X, Accafter , x, w) ← A(add, κ) :

κ⇒ X, Accafter

κ

(cid:2) X ∪ {x},

Accbefore

CheckUpdate(κ, x, Accbefore, Accafter , (w, add)) = 1

⎤
⎥⎦

⎤
⎦

⎤
⎥⎦

⎤
⎥⎦

is neg(k).

– (Secure creation)

is neg(k).

– (Secure addition)

is neg(k).

– (Secure deletion)

⎡
⎣

Pr

⎡
⎢⎣

Pr

⎡
⎢⎣

Pr

κ = (κ0, 1k ) R← (1k ),

(Accbefore, X, Accafter , x, w) ← A(del, κ) :

κ⇒ X, Accafter

κ

(cid:2) X\{x},

Accbefore

CheckUpdate(κ, x, Accbefore, Accafter , (w, del)) = 1

is neg(k).

The type of accumulators we consider in this work is not
necessarily quasi-commutative [7,15] as they may not hide
the order in which the elements were added to the set. More
precisely, our definition tolerates that the value of the accumulator 
may depend on a particular sequence of Updateadd
and Updatedel operations that produced a particular accumulator 
value Acc.

At this point, we need to justify our claim that the accumulated 
set X represented by an accumulator value is unique

Strong accumulators from collision-resistant hashing

353

with overwhelming probability as long as honest parties verify 
all accumulator updates.

Deﬁnition 5 Let A be a strong universal accumulator scheme
for some universe M and initialization , and k ∈ N a security 
parameter. Given an adversary A with oracle access,
consider the following two phase experiment E x pV U Acc
A,,A :
First, on input the security parameter k, the experiment generates 
a system-wide parameter κ by invoking (1k ). Second,
on input κ, the adversary outputs a tuple (w, Acc), which
is taken to represent the creation witness, and the accumulated 
value (respectively) corresponding to the accumulated
set X = ∅. If CheckUpdate(κ,⊥,⊥, Acc, w) (cid:11)= 1, then
the experiment aborts. In the second phase, the adversary is
allowed to submit as many queries to an oracleO() as it wants
and then stops. The oracle O() is stateful with initial state
(κ, Acc, m, w). For each query of the form (op, x, Acc(cid:10), w)
where op ∈ {add, del}, the oracle proceeds as follows: it
ﬁrst computes a bit b ← CheckUpdate(κ, x, Acc, Acc(cid:10), w).
, and X ← X ∪ {x} if
Then, if b = 1, it sets Acc ← Acc(cid:10)
op = add (similarly if op = del, it sets X ← X\{x}).
In the case b = 0, the oracle does not modify Acc or X.
In both cases, the oracle returns bit b as the answer to the
adversary. We say that an A is veriﬁably updatable under
 if for each probabilistic polynomial-time adversary A,
after A stops (without the experiment ever aborting), it holds
κ⇒ X except with negligible probability in k. If
that Acc
Acc κ

(cid:2) X, we say adversary A wins the experiment.
The following proposition shows that the accumulated set
represented by any accumulator value is well deﬁned (with
overwhelming probability) if we use a secure strong universal
accumulator scheme.

Proposition 1 If a strong universal accumulator scheme A
is secure under initialization procedure , then A is veriﬁably 
updatable under .
Proof Let A∗
be a probabilistic polynomial-time adversary
that wins E x pV U Acc
A,,A with non-negligible probability in k
making at most μ = μ(k) queries for some polynomial μ.
First of all, the initial accumulator value Acc must represent 
the empty set, since otherwise adversary A∗
would contradict 
the secure creation property. Then, for some index
1 ≤ i ≤ μ, there must exist queries (opi−1, xi−1, Acci−1,
wi−1) and (opi , xi , Acci , wi ) such that Acci−1 does repre-
∗∪{xi} nor
sents some set X
∗\{xi}. Clearly, the polynomial-time adversary that runs
X
A∗
—while simulating the oracle—up to the ith query and
then outputs Acci−1, X
, Acci , xi , wi breaks the secure addition 
or secure deletion property of A.

while Acci represents neither X

∗

∗

Our security definition (Definition 4) for the dynamic scenario 
(where addition and deletion of elements are allowed)
differs from the one in [7] where the adversary is only able to

add and delete elements by querying the accumulator manager,
 who is incorruptible. In contrast, in our definition, the
adversary is allowed to control the accumulator. However,
we require that during each update, at least an uncorrupted
participant veriﬁes the update with CheckUpdate to guarantee 
the consistency between the accumulated value and the
history of additions and deletions.

Dynamic accumulators. The standard definition of dynamic
accumulators (see for example the one in [7]) adds two
requirements, which so far we have not considered. First,
it requires the existence of an additional efﬁcient algorithm
that allows to publicly and efﬁciently update membership
witnesses after a change in the accumulator value, so witnesses 
can be proven valid under the new accumulator value.
And secondly, it requires that both the accumulator updating
algorithm as well as the witness updating algorithm to run in
time independent from the size n of the accumulated set. In
our construction, we only achieve logarithmic dependency on
n for the accumulator updates. In practice, such dependency
may be appropriate for many applications.

3 Our scheme

We assume that there exists a public broadcast channel with
memory. Depending on the required security level, this can
be a simple trusted web server, or a bulletin board that guarantees 
that every participant can see the published information
and that nobody can delete a posted message. For a discussion 
on bulletin boards and an example of their use in another
cryptographic protocol, the interested reader is referred to [8].
We rely on broadcast channels in order to ensure that the publication 
of the successive accumulator values that correspond
to the updates of the set cannot be forged. In particular, an
adversary who controls the manager of the accumulator cannot 
publish different accumulator values to different groups
of participants.

3.1 Preliminaries

Our scheme is inspired by time stamping systems like those
described in [3,4]. In these systems, a document needs to
be associated with a certain moment in time. The solution
proposed there is to divide the time in periods (e.g., hours,
days) and place each document as a leaf at the bottom of a
binary tree (say, T ) with other documents that belong to the
same period of time, say t. Then, the values associated with
each pair of leaves with the same parent node are hashed in
order to derive the value of the parent node. This process
is repeated until the value v of the root node of the tree is
computed. This value v is then published as a representative
of the tree T for period t. Later, a given document m can be

123

354

P. Camacho et al.

Labeled trees. Our proposal relies on labeled binary trees.
The root node of a tree T will be denoted root(T ). The
left subtree (respectively right subtree) rooted at the left
(respectively right) child node of T will be denoted Left(T )
(respectively Right(T )). The node root(T ) is said to be the
parent of Left(T ) and Right(T ). Each node N of T will
be labeled by a string henceforth denoted Label(N ). Sometimes 
we identify the tree T with its root N = root(T ) and
we write Label(T ) to denote Label(root(T )). As usual, a leaf
of T corresponds to a node of T that has no children. If T
consists of only one node, then we say that T has depth 0
and denote it as depth(T ) = 0. Otherwise, let depth(T ) =
1+ max{depth(Left(T )), depth(Right(T ))}. A tree T is balanced 
if |depth(Left(T )) − depth(Right(T ))| ≤ 1. It is a
well-known fact that a balanced tree with n nodes has maximum 
depth O(log(n)).
Model of X = {x1, . . . , xn} under H. Informally, a model
of X under H is a labeled balanced binary tree such that for
every node N of T , the label of N is of the form H (xi||xi+1)
plus some additional information linking H (xi||xi+1) and
the labels of the roots of the left and right tree whose parent
is N . Formally, the set {H (xi||xi+1) : 0 ≤ i ≤ n} will be
called the base of X under H. A balanced binary tree T is
called a model of X under H if:
– For every node N in T there are strings ValN and Proof N ,
called node value and node proof respectively, such that

Label(N ) = (ValN; Proof N ).

– The base of X is {ValN : N is a node of T}.
– T has n + 1 nodes.
– Proof N = H (ValN||Proof Left(N )||Proof Right(N )) for
every node N of T (where Proof Nil corresponds to the
empty string).

If N is the root node of tree T , we abuse the notation
and write Proof T instead of Proof N . The collection of node
values of T will be denoted by V(T ).

Figure 1 depicts a toy example of a model of a set.

Minimal subtrees generated by a set. Let T be a labeled
binary tree. We say that V ⊆ V(T ) generates a minimal subtree 
U of T if U is a subtree of T obtained by: (1) taking all

proven to belong to a certain period of time t by presenting
a valid subtree of tree T corresponding to time period t that
includes the document m.

We use the above approach to build an accumulator
scheme that works for dynamic sets and also allows proofs
of non-membership. In this case, building a proof of nonmembership 
is somehow similar to the trick of Kocher (in
[14])—instead of storing elements of the set, we store pairs
of consecutive elements of the set. Then, proving that an element 
x is not in the accumulated set X amounts to simply
proving that there exists elements xα and xβ, xα < x < xβ,
such that a pair (xα, xβ ) is stored in the tree.

Basic tools. Our solution uses collision-resistant hash functions,
 which we formalize as families of functions. In practice,
 we can use a well-known hash function like SHA-256,
for example. We start recalling the standard notion of colli-
sion-resistant hash functions.

(cid:10)

(cid:11)

= neg(k)

Deﬁnition 6 A hash function family is a collection of functions 
{Hτ : M → Y}τ∈K where M and Y are sets of strings,
and K and Y are non-empty sets.
Deﬁnition 7 Let H = {Hτ : M → Y}τ∈K be a hash function 
family and k a security parameter, where |K| = |Y| =
2k, Then, H is collision-resistant if and only if for every
polynomial-time probabilistic algorithm A, we have:

τ R← K; (m, m
m (cid:11)= m

(cid:10)) ← A(τ, k) :
(cid:10), Hτ (m) = Hτ (m
(cid:10))

Pr
where τ R← K means that τ is selected uniformly at random
in the set of keys K .
Often, we will view a mapping H : K × M → Y as
the hash function family {Hτ : M → Y}τ∈K where Hτ (·) =
H(τ,·). Henceforth, M will be the set of all binary strings,
and K and Y will be the set{0, 1}k, for a large enough security
parameter k ∈ N.
Notation for Sets. We assume the set X we want to accumulate 
is ordered and denote by xi the ith element of X =
{x1, x2, . . . , xn}, n ∈ N. Let x0 = −∞ and xn+1 = +∞ two
special elements such that −∞ ≺ x j ≺ +∞ for all x j ∈ X,
where (cid:19) is the order relation on X (for example, the lexicographic 
order on bit strings) and a ≺ b if and only if a (cid:19) b
and a (cid:11)= b.
Observe that showing x ∈ X is equivalent to proving that:
(xα, xβ ) ∈ {(xi , xi+1) : 0 ≤ i ≤ n} ∧ (x = xα ∨ x = xβ ).
On the other hand, showing that x /∈ X corresponds to

proving:
xα ≺ x ≺ xβ ∧ (xα, xβ ) ∈ {(xi , xi+1) : 0 ≤ i ≤ n}.
by A(cid:22)B.

For sets A and B, we denote their symmetric difference

123

Fig. 1 A tree model T of the set X = {x1, . . . , x8}. Only node values
are shown. Note that the place of the values in the tree is irrelevant

Strong accumulators from collision-resistant hashing

355

Fig. 2 A tree and its minimal
subtree (nodes with values in
boldface) generated by the node
of value j. Children of the nodes
that are on the path from j to a
are underlined

b

i

c

f

j

m

d e

g h

k l

n o

nodes in T that belong to all paths from T ’s root to a node
whose value is in V (the paths include both the root of T and
the nodes of value in V), and (2) all the (direct) children of
the nodes taken in the previous step. Figure 2 illustrates the
concept of minimal subtree. If U is generated by a singleton
{S}, then we say that U is generated by S.
Forging binary trees. We claim that for a set X and H, a uniformly 
chosen hash function from a collision-resistant hash
function family, given a model T of X under H, it is compuwith 
the same
tationally hard to distill a new labeled tree T
root value but different values elsewhere. Formally, we claim
the following result.
Proposition 2 Let H: K × M → Y be a collision-resistant 
hash function family and H a uniformly chosen function
in H. Let X ⊆ M be an adversarially chosen polynomial
size set (on the security parameter k), and T be a model
of X under H. Then, given T , no adversary can efﬁciently
and a value V such that
compute a labeled binary tree T
V ∈ V(T
ligible probability.

(cid:10))(cid:22)V(T ) and Proof T (cid:10) = Proof T , except with neg-

(cid:10)

(cid:10)

3.2 A strong universal accumulator with memory using

hash trees

In this section, we use hash trees to build our proposed universal 
accumulator with memory. At a high level, our accumulator 
scheme relies on an accumulator manager that creates
and updates a tree T , which is a model of the accumulated set
X = {x1, x2, . . . , xn} under H. The model T of X will satisfy
two conditions: (1) the accumulator manager can guarantee
that x ∈ X by proving that there is a node N of T such that
VN = (xα, xβ ) where x = xα or x = xβ, and (2) to demonstrate 
that x (cid:11)∈ X, the accumulator proves that there is a
node N of T such that VN = (xα, xβ ) where xα ≺ x ≺ xβ.
When adding or deleting elements from X, the accumulator
manager needs to update T and guarantee that both of the
stated conditions are satisﬁed.

In terms of setup assumptions, our scheme can be instantiated 
with any trusted initialization algorithm (1k ), which
includes picking a hash function H uniformly at random
from the family H (say by computing a random index i ∈ K
where |K| = k and then setting H = Hi ). Of course, such
assumption can also be instantiated with an ephemeral trusted
third-party running , or alternative using standard multiparty 
computation techniques among all participants, including 
the accumulator manager. Moreover, a common heuristic
to avoid interaction is to simply pick H =SHA-256 [16], for
example.

A detailed description of the proposed scheme follows.
The construction. Let k = 2t ∈ N be the security parameter
and let X = {x1, x2, . . . , xn} be a subset of M = {0, 1}t . We
deﬁne the accumulator scheme HashAcc below.

(cid:10)

Proof Let A be a polynomial-time stateful adversary which
works in two phases. First, on input the security parameter
and a hash function H ∈ H, A outputs a set X ⊆ M of
size polynomial on k. Then, given a model T for X under
and a value V satH,
 it outputs a labeled binary tree T
isfying the conditions of the proposition. Since Proof T (cid:10) =
(cid:10)) but not in V(T ), there
Proof T and value V are in V(T
and a node N in T such
must exist a node N
that Proof N(cid:10) = H (ValN(cid:10)||Proof Left(N(cid:10))|| Proof Right(N(cid:10))) and
Proof N = H (ValN ||Proof Left(N )|| Proof Right(N )) are equal
but ValN||Proof Left(N )|| Proof Right(N ) (cid:11)= ValN(cid:10)||Proof Left(N(cid:10))
||Proof Right(N(cid:10)). Nodes N and N

can be found efﬁciently by

in T

(cid:10)

(cid:10)

(cid:10)

simple traversal of both trees in some ﬁxed order.
Now, let B be an adversary that is given a uniformly
selected at random collision-resistant hash function H ∈ H.
Adversary B ﬁrst queries A to obtain a set X which it uses to
build a model T for X under H. Then, B runs A as a subrou-
(cid:10)
and a value V
tine to obtain another labeled binary tree T
(cid:10))(cid:22)V(T ). Finally,
using the procedure mentioned above, B ﬁnds a collision
for H.

such that Proof T = Proof T (cid:10) and V ∈ V(T

– Setup(κ): The algorithm starts by setting X equal to
the empty set. Then, it extracts the security parameter
k and the description (index) of the hash function H ∈ H
from κ. The algorithm then sets m to be the following
model of X: a tree with a single root node N with value
V alN = H (−∞||+∞) and the accumulator is initialized
to Proof N = H (V alN||||) where  is the empty string.
Finally, the algorithm sets the creation witness wcrt to
(m, crt), where crt is a ﬁxed label.
– Witness(κ, x, m): On input x ∈ M and memory m, it
computes the witness w = (w1, w2) as follows. First, the
algorithm sets w1 = (xα, xβ ) where x = xα or x = xβ
if x ∈ X. Otherwise, if x /∈ X the algorithm sets w1 =
(xα, xβ ) where xα ≺ x ≺ xβ. Finally, it sets w2 as the
minimal subtree of m generated by the value H (xα||xβ ).
– CheckWitness(κ, x, w, Acc): On input x ∈ M and witness 
w = ((x
(cid:10)(cid:10)), U ) where U is purportedly a minimal 
subtree of the memory value m associated to the
accumulator value Acc, it ﬁrst checks if the following
conditions hold: (1) Proof U = Acc, (2) H (x
(cid:10)(cid:10)) ∈
V(U ), (3) (x = x
(cid:10)(cid:10)).

(cid:10)||x
(cid:10) ≺ x ≺ x

(cid:10)(cid:10)), and (3’) (x

or x = x

(cid:10), x

(cid:10)

123

356

Fig. 3 Inserting x into the tree of Fig. 1 where x2 ≺ x ≺ x3

The algorithm outputs 1 if conditions (1), (2), and (3)
hold; it outputs 0 if (1), (2), and (3’) hold. Otherwise, it
outputs ⊥.

– Updateop(κ, x, Accbefore, mbefore): On input element x ∈
M, accumulator value Accbefore, and memory mbefore, it
proceeds as follows. Consider two cases depending on
whether the update is an addition (op = add) or a deletion 
(op = del).
If op = add and x (cid:11)∈ X, the algorithm adds x into X by
modifying mbefore as follows:

1.

2.

It replaces the value H (xα||xβ ) from the appropriate
node in mbefore (where xα ≺ x ≺ xβ) by the value
H (xα||x).
It augments the tree mbefore adding a new leaf N of
value H (x||xβ ) so the resulting tree mafter is a balanced 
tree. Let VPar (N ) be the (parent) node where
N is attached as a leaf.

P. Camacho et al.

accumulator Accafter = Proofmafter . The witness wdel =
(del, Udel,1, wdel,2, Udel,3) is then computed as follows:
– Udel,1 corresponds to the minimal subtree of mbefore
generated by the set {H (xα||x), H (x||xβ ), V alL},
– wdel,2 is the pair (xα||xβ ) such that xα ≺ x ≺ xβ, and
– Udel,3 is the minimal subtree of mafter generated by

H (xα||xβ ).

The algorithm Updateop outputs the new accumulator 
value Accafter, the modiﬁed memory mafter, and the
update witness wop.
– CheckUpdate(κ, x, Accbefore, Accafter, wop): On input
an element x ∈ M, two accumulator values Accbefore,
Accafter, and an update witness wop = (w, op) for op ∈
{add, del, crt}, it proceeds as follows. If op = crt,
then the algorithm outputs 1 if Accafter = H (H (−∞||
+∞), , ) and w is a model of the empty set under H.
If w = (add, U1, U2), then the algorithm returns 1 provided 
that:

– U2 is a tree obtained by adding a leaf to U1,
– Except for the node of value H (xα||xβ ) (for xα ≺ x ≺
xβ) all nodes which are common to U1 and U2 have
the same value in either one of the trees,

= Accbefore and Proof U2

– Proof U1
– H (xα||x), H (x||xβ ) ∈ V(U2).
Otherwise, it outputs 0. We omit the case w = (del,
U1, w2, U3) which is similar.

= Accafter, and

The resulting tree is denoted mafter. Figure 3 illustrates
the process of inserting an element into mbefore.
Once tree mafter is built, the new accumulator is simply 
the value of the root of the tree, namely Accafter =
Proof mafter . The witness wadd = (add, Uadd,1, Uadd,2)

that the update (addition) has been done correctly is computed 
as follows:

}, and,

– Uadd,1 corresponds to the minimal subtree of mbefore

generated by {H (xα||xβ ), V alVPar (N )
generated by {H (xα||x), H (x||xβ )}.

– Uadd,2 corresponds to the minimal subtree of mafter
If op = del, deleting x from X is done in a similar way
as follows. First, the update algorithm locates the two
nodes of mbefore that contain x. Let Vα and Vβ be those
nodes, and let H (xα||x) and H (x||xβ ) be their respective 
values, for some xα ≺ x ≺ xβ. The goal is to
remove these nodes and replace them with a new node
with value H (xα||xβ ) in a way that the derived tree is
still balanced. This is done by ﬁrst replacing Vα with
the single node with value H (xα||xβ ), and then replacing
Vβ with a leaf node L (for example, the rightmost leaf
on the last level of the tree). These replacements yield a
new tree mafter whose root label is set to the value of the

Security. We now prove that the scheme HashAcc of the
previous section is secure under Definition 4.

First, note that if memory m is a model of X, then the
memory obtained after executing Update in order to add a
new element x /∈ X, is a model of X ∪ x. Indeed, suppose
xα ≺ x ≺ xβ and let H (xα||xβ ) be the value of a node N in
m. By replacing node N with the node of value H (xα||x) and
adding the node of value H (x||xβ ), we clearly obtain a set
of values {H (xi||xi+1), 0 ≤ i ≤ n + 1} that corresponds to
the successive intervals of the set X ∪ {x} (where n = |X|).
Intuitively, CheckUpdate must guarantee that the updated
memory (tree) used to compute the new accumulated value
still has the property of having all the successive intervals of
the accumulated set as node values, that each interval appears
once and only once in the tree, and that no other node value
can belong to the tree.
Deﬁnition 8 Let H: K × M → Y be a collision-resistant
hash function family. Let H be the initialization procedure
that on input k in unary returns κ = (H, 1k ) where H is
chosen uniformly at random from the family H.
Theorem 1 The accumulator scheme HashAcc is a secure
strong universal accumulator scheme (with memory) under
H.

123

Strong accumulators from collision-resistant hashing

357

Proof We need to prove the properties Consistency, Secure
creation, Secure addition, and Secure deletion.
– (Consistency) First, we note that Acc κ⇒ X implies that
there exists a memory m which is a model of X under H.
Let us now suppose that there is an adversary A that can
compute a value x and two witnesses w1, w2 such that
CheckWitness(κ, x, w1, Acc) = 1 and CheckWitness
(κ, x, w2, Acc) = 0. We assume without lost of generality 
that x ∈ X. Any such adversary A is in fact able to ﬁnd
xα and xβ, xα ≺ x ≺ xβ, such that H (xα||xβ ) belongs
to V(m). Since m is a model for X, by Proposition 2, this
adversary will only succeed with negligible probability.
The argument for x /∈ X is analogous.
– (Secure creation) Let A be a probabilistic polynomialtime 
adversary (playing the role of an accumulator man-
(cid:2) ∅ but
ager) that outputs (w0, Acc0) where Acc0
CheckUpdate (κ,⊥,⊥, Acc0, (w0, crt)) = 1. By definition 
of Setup, one has that w0 has the structure of a
model (i.e. must be a labeled balanced binary tree plus
some additional information). Following the same line of
argument as that of Proposition 2 one reaches a contradiction 
to the collision resistant assumption on H.
– (Secure addition) Consider the case where the update is
the addition of a value x such that xα ≺ x ≺ xβ and
κ⇒
H (xα, xβ ) belongs to the base of X, where Accbefore
X. Assume that CheckUpdate(κ, x, Accbefore, Accafter ,
w) = 1 where both w = (add, Ubefore, Uafter ) and x
are arbitrarily chosen by the adversary, and Accafter
X ∪ {x}. Then, for two elements u, v ∈ M the adver-
∗ = Uafter containing
sary can effectively build a tree S
a value H (u||v) that does not belong to (V(mbefore) ∪
{H (xα||x), H (x||xβ )})\{H (xα||xβ )} = V(mafter) and
such that in addition Proo fS∗ = ProofUafter
= Accafter =
Proofmafter . This contradicts Proposition 2.

– (Secure deletion) This case is similar to the addition of

κ

κ
(cid:2)

an element.

Efﬁciency. We analyze the computational efﬁciency of the
proposed scheme.

Theorem 2 Let n be the size of X. The witnesses of (non)
membership and of updates have size O(log(n)). The update
process Update, the veriﬁcation processes Belongs, and
CheckUpdate can be done in time O(log(n)).

Proof Assuming the accumulator manager uses a pointerbased 
data structure representation for labeled binary trees,
it is enough to show that a minimal subtree U of T generated 
by a constant number of node values has size O(log(n)).
Indeed, ﬁrst note that a minimal subtree of a tree generated
by a constant number of node values is the union of the minimal 
subtrees generated by each of the values. It is easy to
see that the size of a minimal subtree generated by a node

value is proportional to the depth of the node. This, and the
fact that T is balanced, implies the desired conclusion.

4 Efﬁciency of our scheme and comparison

with previous proposals

Our solution is theoretically less efﬁcient than the scheme
proposed in [15]. Nonetheless, if one considers practical
instances of these schemes, the difference effectively vanishes 
as in most implementations hash function evaluation is
significantly faster than RSA exponentiation—which is the
core operation used by the schemes in [7,15]. Table 1 shows
the time taken by one single RSA exponentiation versus the
time taken by our scheme for update operations as a function 
of the number of the accumulated elements. For the time
measurements, we used the openssl benchmarking command
(see [17]) on a personal computer. Notice that RSA timings
were obtained using signing operations, as in the scheme proposed 
in [15] where exponents may not be small. Timings for
SHA operations were measured using an input block of 1024
bits. The comparison is based on the fact that our scheme
requires at most 4 × 2 log(n) hash computations, where n
is the number of accumulated elements, given that at most
four branches of the Merkle tree used in our construction
(three for wdel,1 and one for wdel,3, see Sect. 3.2) will have
to be recomputed in the case of deletions. We now explain
the relevance of Table 1. For clarity’s sake, we focus on the
efﬁciency of witness generation. In [2,4,7,15] schemes, the
time to generate a witness is at least a single RSA signing
operation, independently of the number of accumulated values.
 Hence, for both the aforementioned schemes, the time
required to generate a witness is at least the one given by the
columns of Table 1 with headers RSA-512, RSA-1024, and
RSA-2048, depending on the size of the modulus used. In
contrast, if we instantiate the hash function of our proposed
scheme by one of the SHA family of hash functions, the time
required to generate the nth witness is given by the columns
of Table 1 with headers SHA-256 and SHA-512, depending
on which version of SHA is used. A similar situation holds
for operations such as addition or deletion of accumulated
values. In conclusion, using our hash-based scheme is still

Table 1 Comparison of performance between simple RSA exponentiation 
and logarithmic number of computations of SHA where n is the
number of accumulated elements

n

23
210
220
230

RSA-512

RSA-1024

RSA-2048

SHA-256

SHA-512

0.85
0.85
0.85
0.85

4.23
4.23
4.23
4.23

25.00
25.00
25.00
25.00

0.37
1.22
2.44
3.66

1.42
4.75
9.50
14.24

Time is represented in milliseconds

123

358

Table 2 Comparison of properties of previous and our scheme, where
n is again the number of accumulated elements and k is the security
parameter

Scheme

Strong

Dynamic

Benaloh et al. [4]
Bari´c et al. [2]
Camenish et al. [7]
Li et al. [15]
This work

Yes
Yes
No
No
Yes

No
No
Yes
Yes
Partiallya

Witness size
O(k)
O(k)
O(k)
O(k)
O(k log n)

In all scheme’s, the accumulator size is O(k)
a Our solution allows dynamic addition and deletion of elements but no
witness update

very efﬁcient, even for large values of n, in comparison with
previous proposals.

Table 2 compares the functionality provided and sizes of
parameters appearing in aforementioned schemes and our
solution.

On the setup assumptions: We prove the security of our
scheme under the assumption that there is a trusted procedure 
that chooses hash functions uniformly at random from
a given family. We model such assumption using an initialization 
procedure , which cannot be corrupted. Notice that
once  ﬁnishes execution, no other trusted process or entity
is required. In contrast, both previous solutions for dynamic
accumulators [7,15] not only require a trusted party—the
accumulator manager herself—but also that such trust entity
be available for as long as the accumulator is active. This
seems unavoidable since managers require a trapdoor for the
pseudo-collision-free function in order to (efﬁciently) delete
elements from the accumulator.

In practice, trusted initialization can efﬁciently be implemented 
using standard secure multiparty computation techniques.
 For our protocol, we only need to generate a hash
function index, that is, a k-bit uniformly distributed random
string. This can be done using standard coin tossing algorithms 
[18] (or more practical variants [13]) if a majority of
participants during the initialization is honest. Alternatively,
we could cast our results in the human ignorance setting proposed 
by Rogaway [19]. In that case, it would sufﬁce to take
 as the identity function and make the reductions behind the
proof of Theorem 1 more explicit (that is, detailing how new
collision-ﬁnding adversaries are built from the given protocol 
adversaries). Note that all reductions in this paper are in
fact constructive.

Nontriviality of the strong property: Both in the construction
of Camenish et al. [7] as well as the one by Li et al. [15], a corrupted 
manager can compute witnesses for arbitrary elements
(regardless of whether the elements belong to the accumulated 
set or not). For example, in both schemes, the manager 
is able to generate a valid membership witness w for

123

P. Camacho et al.

an arbitrary element x ∈ ZN by simply computing w =
−1 mod ( p−1)(q−1), where N = pq is the RSA modulus and
ux
u ∈ ZN is the current accumulator value.

Note that both these schemes [7,15] are veriﬁably updatable.
 Moreover, witness computation is deterministic in the
aforementioned schemes, depending only on the previous
and current value of the accumulator at witness generation
time. However, these conditions are not enough for these
schemes to be strong. In Camenish et al. scheme [7], a malicious 
manager can add an element x = ab (for some a, b)
and then prove either a or b belong to the accumulated set.
Similarly, in the scheme by Li et al. [15], a malicious manager
can easily compute non-membership witnesses for elements
even if they are in the accumulated set. In this case, though,
a witness veriﬁcation algorithm could detect the forgery if
the list of all elements currently in the accumulated set is
available. Yet, this is not a requirement of the protocol and
would likely make such variant inefﬁcient.

In contrast, our solution achieves the strong property as
long as, at any given time, the party verifying a correct accumulator 
update is able to remember the current and previous
accumulated values.

5 The e-invoice factoring problem

In this section, we describe an application of strong universal
accumulators that yields an electronic analog of a mechanism 
called factoring through which a company, henceforth
referred to as the Provider (P), sells a right to collect future
payment from a company client (C). The ensuing discussion
is particularly concerned with the transfer of payment rights
associated with the turn over of invoices, that is, invoice factoring.
 The way invoice factoring is usually performed in
a country like Chile is that P turns over a purchase order
from C to a third party, henceforth referred to as factor entity
(F E). The latter gives P a cash advance equal to the amount
of C’s purchase order minus a fee. Later, F E collects payment 
from C.

There are several beneﬁts to all the parties involved in a
factoring operation. The provider obtains liquidity and avoids
paying interests on credits that he/she would otherwise need
(it is a common practice for some clients as well as several
trading sectors in Chile to pay up to 6 months after purchase).
The client gets a credit at no cost and is able to perform a
purchase for which he might not have found a willing provider.


According to the Chilean Association of Factoring (Asociación 
Chilena de Factoring - ACHEF) during 2010, its 19
members accumulated almost 2 million documents worth
more than 18 billion dollars [1]. Factoring’s origins lie in the
ﬁnancing of trade, particularly international trade. Factoring
as a fact of business life was underway in England prior to

Strong accumulators from collision-resistant hashing

359

(a)

(b)

Fig. 4 a The minimal subtree of the tree shown in Fig. 1 and generated
by {H (x2||x3), H (x4, x5)}. b The minimal subtree of the tree shown in
Fig. 3 and generated by {H (x2||x), H (x||x3)}

Factoring Entity

(3)

(4)

(6)

(5)

Provider

(2)

(1)

Client

Fig. 5 Steps of a factoring operation

1400 [11]. The reader is referred to the Web site of the International 
Factors Group [12] for information on current trends
and practices concerning factoring worldwide. Although factoring 
is performed in many contexts, as the reader will see,
our proposed solution exploits peculiarities of the way it is
locally implemented in Chile—thus, its applicability in other
scenarios, if at all possible, would require adaptations.

The main phases of an invoice factoring operation are summarized 
below and illustrated in Fig. 5:

1. C requests from P either goods or services,
2.
3.
4. F E either rejects or accepts P’s request—in the latter

P delivers the goods/services to C,
P makes a factoring request to F E,

5.

case F E gives P a cash advance on C’s purchase,
later, F E asks C to settle the outstanding payment, and
ﬁnally,

6. C pays F E.

A risk for F E is that P can generate fake invoices and
obtain cash advances over them. This danger is somewhat
diminished by the fact that such dishonest behavior has serious 
legal consequences. More worrisome for F E is that
P may duplicate real invoices and request cash advances

from several F Es simultaneously. But, Chile’s local practice
makes this behavior hard to carry forth. Indeed, invoices are
printed in blocks, serially numbered and pressure sealed by
the local IRS agency (known as Servicio de Impuestos Internos 
(SII)). A F E will request the physical original copy of an
invoice when advancing cash to P. It is illegal, and severely
punished, to make fake copies or issue unsealed invoices.

Less than a decade ago, an electronic invoicing system
began operating in Chile. Background and technical information 
concerning this initiative can be downloaded from
the Web site of the SII, specifically from [20]. The deployed
electronic invoicing system has been widely successful. It has
been hailed as a major step in the government modernization.
Furthermore, it has created strong incentives for medium-
to-small size companies to enter the so-called information
age. Nevertheless, the system somewhat disrupts the local
practice concerning factoring. Specifically, a F E will not be
able to request the original copy of an invoice, since in a
digital world, there is no difference between an original and
a copy. This creates the possibility of short-term large-scale
fraud being committed by unscrupulous providers. Indeed, a
provider can “sell” the same invoice to many distinct F Es.
We refer to the aforementioned situation created by the introduction 
of electronic invoicing as the e-Invoice Factoring
Problem.

We show below how to address this problem using strong
universal accumulator schemes, but ﬁrst it is important to
note that there are other issues of concern for participants of
an e-invoice factoring system, among the most relevant are:

– Privacy of the commercially sensitive information contained 
by invoices (e.g. private customer’s information
like for example tax identiﬁcation numbers, volume of
transactions, etc.)

– Robustness of the e-invoice factoring system—no small
size colluding party should be able to disrupt the system’s
operation and/or break its security.

– Conﬁdentiality of the F E’s commercially sensitive information 
(customer pool, number of transactions, volume
of transactions, etc.)

The latter of these issues arises because the F Es are in
competition among themselves. They have an incentive to
collaborate in order to avoid fraud. But, they do not wish to
disclose information about their customer base and transaction 
volumes to competitors. Moreover, a widespread sharing 
of invoices would not be welcomed by the providers who
issue them, given that they probably want to maintain conﬁdential 
the proﬁle of their clients.

In order to describe our proposed strong accumulatorbased 
solution for the e-Invoice Factoring Problem, it is
convenient to introduce additional terminology. A factoring 
protocol F = (F E1, . . . , F En; F A) involves n ≥ 2

123

360

P. Camacho et al.

participants F E1, . . . , F En called factor entities and a special 
participant F A called the factoring authority. The factoring 
protocol F is deﬁned by the concurrent execution of
several instances of a decision protocol consisting of:

1. The transmission from F Ei to F A of a digest x of an

invoice I nv that F Ei wants to buy.

2. The computation by F A, based on x and the identity of
F Ei , of a value V and its publication through a public
broadcast channel.

3. The decision on whether or not to buy the invoice associated 
to x made by F Ei based on V and other possible
information previously collected. If F Ei concludes that
I nv has not been previously sold, then it decides to buy
and outputs I nv||0||i, otherwise it outputs I nv||1||i.

The previous description of a factoring protocol captures
the fact that the F Ei ’s interact concurrently with F A in order
to decide whether or not to buy invoices.
In order to formalize the security requirements involved
in a factoring protocol, we proceed as follows. Let k ∈ N
be a security parameter,  an initialization procedure, and
let F = (F E1, . . . , F En; F A) be a factoring protocol
for n = p(k) ≥ 2 where p is a polynomial. Consider
an experiment, denoted E x pfacF ,,A(k), where A is a poly-
nomial-time-bounded adversary that can corrupt F A and
choose the elements for which the F Ei ’s want to make a purchase 
decision. The adversary can run a polynomial number
of decision protocol instances. Also, F A can invoke the initialization 
procedure , which is not under the control of the
adversary. We say that the experiment outputs 1 if the adversary 
wins, that is,
if either one of the following situations
occur; (1) for i (cid:11)= j, the adversary obtains a signature from
honest factor entities F Ei and F E j for the same message
I nv||0, or (2) the adversary obtains a signature from honest
factor entity F Ei for a message I nv||1 such that no honest
factor entity has previously generated a signature of I nv||0.
Deﬁnition 9 (Security of a factoring protocol)
Let k ∈ N be a security parameter and n = p(k) ≥ 2
for some polynomial p. We say that a factoring protocol F is
(cid:3)
E x pfacF ,,A(k)
secure under initialization procedure  if Pr
= neg(k) for every probabilistic polynomial-time adversary
A.

(cid:2)

5.1 A factoring protocol based on a secure strong universal

accumulator scheme

We now describe how any secure strong universal accumulator 
scheme can serve as the basis on which a secure factoring
protocol can be built.

For the sake of clarity of exposition, we ﬁrst describe a
general protocol, called Base Protocol, that involves all the

123

Fig. 6 Base protocol (trustworthy F A)

participants of a factoring transaction: the client C, the provider 
P, the factor entities F E1, . . . , F En, and the factoring
authority F A.

In this Base Protocol, we assume moreover that F A is
trustworthy. Afterward, we shall show how to remove this
assumption. Also, assume that F A has access to a hash
function H uniformly chosen from a collision-resistant hash
function family. In our trustworthy factoring authority-based
solution, F A stores the hash values of all acquired invoices
and replies to queries from the factor entities concerning the
status (either acquired or available) of an invoice with a given
digest value. Henceforth, we assume that all messages are
digitally signed by the entity that sends them. Moreover, we
assume the factoring authority F A and factor entities interact 
through a bulletin board (as implemented in other cryptographic 
protocols, e.g., [8]).

The Base Protocol is illustrated in Fig. 6 and its phases

are described next:

Base Protocol

of his choice.

1. P sends an e-invoice I nv to C.
2. C sends a signed acknowledgment of receipt of the
e-invoice Ack = SignC (I nv).
3. P sends the signed message I nv||Ack to the F Ei
4. F Ei sends the signed message x = H (I nv) to F A.
5. F A checks whether x is in its database. If not, F A
sets Stat to 0 and adds x to its database. Otherwise,
Stat is set to 1. Then, F A broadcasts through the
public channel the signed message x||Stat||i. Upon
receiving x||Stat||i, the factor entity F Ei agrees to
purchase I nv if Stat = 0, and declines if Stat = 1.

6. F Ei sends the signed message I nv||Stat to P.

Discussion. Note that during Step 2, a receipt is signed by C
and then transmitted to F Ei during Step 3. This is to prevent
client C from being framed by P as having made a purchase

Strong accumulators from collision-resistant hashing

361

whose payment F Ei could try to collect later on. Also, note
that I nv is not transmitted to F A during Step 4. This is done
to allow protocol extensions to support conﬁdentiality of P’s
and F Ei ’s commercially sensitive information.2 The reason
for including the identiﬁer i in F A’s reply in Step 5 is to
guarantee that nobody besides F Ei can exhibit a valid proof,
purportedly sent by F A, claiming that x was not in F A’s
database at a given instant (otherwise, anyone capturing F A’s
replies could obtain a certificate that purchase of an invoice
with digest x is warranted).
In the protocol, F A’s signature on x||Stat||i certiﬁes that
an invoice with digest x either is or is not present in F A’s
database. Note also that F Ei ’s signature on I nv||0 is a proof
of commitment that F Ei has agreed to acquire I nv from P.

Attacks outside of the model. Observe that collusion between
C and P is possible. Indeed, it is easy to see that together they
can produce e-invoices not tied to a real commercial transaction.
 To avoid this risk, a factor entity should check the
validity of every e-invoice it is offered, before even contacting 
F A. The current e-factoring system deployed by the Chilean 
internal revenue service provides online functionality to
check the validity of e-invoices (every issuer of e-invoices
must submit to the tax collecting agency an electronic copy
of every e-invoice it creates within 12 h of having issued it).

Reﬁned protocol. Now, let us consider a more realistic
scenario where the factoring authority is not trustworthy.
We now describe a solution for the e-Invoice Factoring
Problem that is based on ﬁve algorithms that rely on a
secure strong universal accumulator under initialization procedure 
, denoted ACC. To avoid confusion, each algorithm 
related to the accumulator will be referred to by
ACC.(cid:6)algorithm name(cid:7).

– Setup(1k): the factoring authority acts as the accumulator 
manager. First it invokes  on input 1k and obtains κ.
Then, it runs accumulator setup algorithm ACC.Setup
on κ, and stores the accumulator value Acc and the memory 
m.
– Belongs(κ, x, m): the factoring authority sets w =
ACC.Witness (κ, x, m). Then, it sets Stat = 1 if x has
been accumulated, and Stat = 0 otherwise. Finally, it
returns (Stat, w).

– Checkbelongs (κ, x, Stat, w, Acc): the factor entity that
wants to check whether or not the element x belongs to
the accumulated set veriﬁes that ACC.CheckWitness
(κ, x, w, Acc) equals Stat.

– Add(κ, x, Accbe f ore, mbe f ore):

the factoring authority
runs ACC.Updateadd(κ, x, Accbe f ore, mbe f ore), returns

(Acca f ter , ma f ter ) and wadd. Then, it publishes in the
bulletin board (Accbe f ore, Acca f ter , wadd ).
– Checkadd (κ, x, Accbe f ore, Acca f ter , wadd ):

the factor
entity that wants to check whether the element x was correctly 
added to the accumulated set decides (non)membership 
of x based on the result returned by ACC.
CheckUpdate (κ, x, Accbe f ore, Acca f ter , wadd ).

Below, we describe the reﬁnement of Step 5 of the Base
Protocol which corresponds to a factoring protocol. As in
Sect. 3, we assume the availability of a public broadcast channel.
 We also assume that when Base Protocol starts, the procedure 
Setup(1k) is invoked, where k is the security parameter,
 thus generating the system-wide parameter κ.

Reﬁnement of Step 5

5.0 Assume the current accumulator value is Accbe f ore

and the memory state is mbe f ore.

receiving

x

from factoring

5.1 Upon
entity
F Ei ,
the factoring authority F A determines
(Stat, w) = Belongs(κ, x, mbe f ore) and then
broadcasts x||(Stat, w)||i. If Stat = 0, then F A
executes Add(κ, x, Accbe f ore, mbe f ore),
obtains
(Acca f ter , ma f ter )
and broadcasts
x||(Stat, Acca f ter , ma f ter , wadd )||i.

and wadd,

5.2 The following veriﬁcations are performed:

(a) F Ei runs Checkbelongs with input (κ, x, Stat,
(b) If Stat = 0, then every factor entity executes

w, Accbefore).

Checkadd(κ, x, Accbe f ore, Acca f ter , wadd ).

5.3 If no factor entity objects by exhibiting a valid proof
that it has previously purchased an invoice with
digest value x, Stat = 0 in Step 5.1, and no message
x||(Stat, Acca f ter , ma f ter , wadd )|| j with j
(cid:11)= i is
published before F A updates the accumulator value
to Acca f ter (and the memory state to ma f ter ),3 then
F Ei agrees to the purchase of an e-invoice with
digest x. Otherwise (Stat = 1 or one of the veriﬁcation 
fails), F Ei rejects the invoice with digest
x.

It is important to point out that every F Ei has to check
each change on the memory m using the values published in
the broadcast channel. Theses checks guarantee continuity in
the evolution of the history of the F Ei ’s decisions (buy or
reject an invoice).

2 This is straightforward by using perfectly one-way hash functions [6]
for H in Step 4.

3 In practice, this can be implemented by a round during which each
factor entity that disagrees with F A’s broadcast values has to publish
its complaint.

123

362

P. Camacho et al.

For clarity of exposition, in our proposed solution to the
e-Invoice Factoring Protocol, we have omitted explanations
of how to deal with e-invoice digest removals from F A’s
database. However, it should be obvious how to implement
this feature relying on the secure deletion functionality provided 
by secure strong universal accumulators with memory.
Implementation of this functionality is essential for maintaining 
efﬁciency. Specifically, to upper bound the size of
the intermediate outputs and per operation processing time
by a logarithm in the number of accumulated invoices.
We henceforth denote by FACC the protocol described
above (the Base Protocol together with its reﬁnement) when
instantiated with a universal accumulator scheme ACC.

Proposition 3 Let ACC be a secure strong universal accumulator 
scheme (with memory) under initialization procedure 
. Then, FACC is a secure factoring protocol under
.

Proof Assume an adversary can make either one of the
(cid:11)= j, the adverfollowing 
situations to occur: (1) for i
sary obtains a signature from honest factor entities F Ei
and F E j for the same message I nv||0, or (2) the adversary 
obtains a signature from honest factor entity F Ei
for a message I nv||1 such that no honest factor entity
has previously generated a signature of I nv||0. If situation 
(1) occurs, the veriﬁcation in Step 5.2 of the factoring 
protocol guarantees that only one message of the type
H (I nv)||(Stat, Acca f ter , ma f ter , wadd )||l can be published
between two consecutive changes of the accumulated value,
the attacker needs to be able to ﬁnd a witness of non-membership 
for H (I nv), although H (I nv) has already been
accumulated. Since FACC is secure, this can only happen
with a negligible probability. If situation (2) occurs, then for
the veriﬁcation in Step 5.2 to succeed with non-negligible
probability the attacker needs to be able to ﬁnd a witness
of membership for H (I nv), although H (I nv) has not been
previously accumulated. Since FACC is secure, this can not
happen.

Theorem 1 and Proposition 3 immediately yield,

Corollary 1 The factoring protocol FHashAcc is a secure
factoring protocol under H.

6 Conclusion

We introduced the notion of strong universal accumulator
scheme, which provides almost the same functionality as do
the universal accumulator schemes deﬁned in [15], namely
(1) a set is represented by a short value called accumulator,
(2) it is possible to add and remove elements dynamically
from the (accumulated) set, and (3) proofs of membership

123

and non-membership can be generated using a witness and
the accumulated value. In this notion, however, the accumulator 
manager does not need to be trustworthy and might be
compromised by an adversary.

We also give a construction of a strong universal accumulator 
scheme based on cryptographic hash functions, which
relies on a public data structure to compute accumulated values 
and witnesses (of membership and non-membership in
the accumulated set). We argue that the proposed scheme is
practical and efﬁcient for most applications. In particular, we
discuss an application to a concrete and relevant problem—
the e-Invoice Factoring Problem

References

1. Asociación Chilena de Factoring (ACHEF). Estadísticas. (http://

www.achef.cl/ [June 28, 2011])

2. Bari´c, N., Pﬁtzmann, B.: Collision-free accumulators and failstop 
signed scheme without trees. In: Advances in Cryptology—
Proceedings of Eurocrypt ’97, vol. 1233 of LNCS, pp. 480–494,
Springer (1997)

3. Bayer, D., Haber, S., Stornetta W.S.: Improving the efﬁciency and
reliability of digital time-stamping. In: Sequences II: Methods in
Communication, Security, and Computer Science, pp. 329–334.
Springer (1993)

4. Benaloh, J., De Mare M.: One-way accumulators: a decentralized
alternative to digital signatures. In: Advances in Cryptology—
Proceedings of Eurocrypt ’93, vol. 765 of LNCS, pp. 274–285.
Springer (1993)

5. Boneh, D., Venkatesan R.: Breaking RSA may not be equivalent to
factoring. In: Advances in Cryptology—Proceedings of Eurocrypt
’98, vol. 1233 of LNCS, pp. 59–71. Springer (1998)

6. Canetti, R., Micciancio, D., Reingold O.: Perfectly one-way probabilistic 
hash functions. In: 30th Annual Symposium on the Theory
of Computing, pp. 131–140, ACM Press (1998)

7. Camenisch, J., Lysyanskaya A.: Dynamic accumulators and application 
to efﬁcient revocation of anonymous credentials. In:
Advances in Cryptology—Proceedings of Crypto ’02, volume 2442
of LNCS, pp. 61–76, Springer (2002)

8. Cramer R., Gennaro R., Schoenmakers B.: A secure and optimally
efﬁcient multi-authority election scheme. In: Advances in Cryptol-
ogy—Proceedings of Eurocrypt ’97, vol. 1233 of LNCS, pp. 103–
118. Springer (1997)

9. Damgård, I.: Collision free hash functions and public key signature
schemes. In: Advances in Cryptology, Proceedings of Eurocrypt
’87, vol. 308 of LNCS, pp. 203–216. Springer (1988)

10. Fazio, N., Nicolisi, A.: Cryptographic accumulators: Definitions,
 constructions and applications, 2003. (http://www.cs.nyu.
edu/~nicolosi/papers/accumulators.ps [June 19, 2008])

11. Hurd, W.H.: Four centuries of factoring. Q. J. Econ. 53(2), 305–

311 (1939)

12. International Factors Group (IFG).

(http://www.ifgroup.com/

[June 28, 2011])

13. Kate, A., Goldberg I.: Distributed key generation for the internet.
In: 29th IEEE International Conference on Distributed Computing
Systems, June, pp. 119–128, IEEE Press (2009)

14. Kocher, P.C.: On certificate revocation and validation. In: Financial
Cryptography, vol. 1465 of LNCS, pp. 172–177. Springer (1998)
15. Li, J., Li, N., Xue R.: Universal accumulators with efﬁcient nonmembership 
proofs. In: Proceedings of Applied Cryptography and
Network Security—ACNS ’07, vol. 4521 of LNCS (2007)

Strong accumulators from collision-resistant hashing

363

16. National Institute of Standards and Technology (NIST). FIPS Publication 
180: Secure Hash Standard (SHS), (May 1993)

17. OpenSSL Project. OpenSSL Package, June 2008. (http://www.

openssl.org [June 19, 2008])

18. Rabin, T., Ben-Or, M.: Veriﬁable secret sharing and multiparty
protocols with honest majority. In: 21st Annual Symposium on the
Theory of Computing, pp. 73–85, ACM Press (1989)

19. Rogaway, P.: Formalizing Human Ignorance. In: Progress in Cryp-
tology—Proceedings of Vietcrypt ’06, vol. 4341 of LNCS, pp. 211–
228. Springer (2006)

20. Servicio de Impuestos Internos. Información sobre factura electrónica.
 (https://palena.sii.cl/dte/menu.html [June 24, 2011])

123

