Strong Accumulators from Collision-Resistant Hashing

Philippe Camacho1,(cid:2), Alejandro Hevia1,(cid:2)(cid:2), Marcos Kiwi2,(cid:2)(cid:2)(cid:2),

and Roberto Opazo3

1 Dept. of Computer Science, University of Chile,
Blanco Encalada 2120, 3er piso, Santiago, Chile

{pcamacho,ahevia}@dcc.uchile.cl

2 Dept. Ing. Matem´atica & Ctr. de Modelamiento Matem´atico,

UMI 2807 U. Chile–CNRS

mkiwi@dim.uchile.cl

3 CEO Acepta.com

roberto.opazo@acepta.com

Abstract. Accumulator schemes were introduced in order to represent a large
set of values as one short value called the accumulator. These schemes allow one
to generate membership proofs, i.e. short witnesses that a certain value belongs
to the set. In universal accumulator schemes, efﬁcient proofs of non-membership
can also be created. Li, Li and Xue [11], building on the work of Camenisch
and Lysyanskaya [5], proposed an efﬁcient accumulator scheme which relies on
a trusted accumulator manager. Speciﬁcally, a manager that correctly performs
accumulator updates.

In this work we introduce the notion of strong universal accumulator schemes
which are similar in functionality to universal accumulator schemes, but do not
assume the accumulator manager is trusted. We also formalize the security requirements 
for such schemes. We then give a simple construction of a strong universal 
accumulator scheme which is provably secure under the assumption that
collision-resistant hash functions exist. The weaker requirement on the accumulator 
manager comes at a price; our scheme is less efﬁcient than known universal
accumulator schemes — the size of (non)membership witnesses is logarithmic in
the size of the accumulated set in contrast to constant in the scheme of Camenisch
and Lysyanskaya.

Finally, we show how to use strong universal accumulators to solve a practical

concern, the so called e-Invoice Factoring Problem.

Keywords: Accumulators, Collision-resistant Hashing, e-Invoice.

1 Introduction

Accumulator schemes were introduced by Benaloh and De Mare [3]. These primitives
allow to represent a potentially very large set by a short value called accumulator. Moreover,
 the accumulator together with a so called witness provides an efﬁciently veriﬁable
proof that a given element belongs to the accumulated set.

(cid:2) Gratefully acknowledges the support of CONICYT via FONDAP en Matem´aticas Aplicadas.
(cid:2)(cid:2) Gratefully acknowledges the support of CONICYT via FONDECYT No. 1070332.
(cid:2)(cid:2)(cid:2) Supported by CONICYT via FONDECYT No. 1010689 and FONDAP en Matem´aticas Aplicadas.


T.-C. Wu et al. (Eds.): ISC 2008, LNCS 5222, pp. 471–486, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008

472

P. Camacho et al.

Bari´c and Pﬁtzmann [1] reﬁned the security deﬁnition of accumulator schemes, and
introduced the concept of collision-free accumulators. This notion was further extended
by Camenisch and Lysyanskaya [5] to a dynamic setting where updates (additions
and deletions) to the accumulator are possible. They proposed a new construction and
showed how to use it to efﬁciently implement membership revocation in group signatures,
 and anonymous credential systems. In particular, they show how to keep track
of valid identities using an accumulator, so proving membership is done by arguing in
zero-knowledge that a certain secret value was accumulated. For a thorough discussion
of accumulators we refer the interested reader to the survey of Fazio and Nicolosi [9].
Li, Li and Xue [11] recently introduced the notion of universal accumulators, which
not only allow efﬁcient generation of membership, but also of non-membership proofs.
Building on [5], Li et al. construct universal accumulator schemes and point out useful
applications, e.g. proving that a certiﬁcate has not been revoked, or that a patient does
not have a disease. However, their construction inherits an undesirable property from
Camenisch and Lysyanskaya’s scheme; updates of the set (addition and deletion of
elements) require the accumulator manager to be trusted. This falls short of Benaloh and
De Mare’s initial goal: to provide membership proofs even if the accumulator manager
is corrupted.

We propose a new accumulator scheme based on hash trees similar to those used in
the design of digital timestamping systems [3,2]. Recall that in hash trees values are
associated to leaves of a binary tree. The values of sibling nodes are hashed in order to
compute the value associated to their parent node, and so on and so forth, until a value
for the root of the tree is obtained. The tree’s root value is deﬁned as the accumulator of
the set of values associated to the leaves of the tree. We cannot directly use hash trees
to obtain the functionality of universal and dynamic accumulators. Indeed, we need
to add and delete elements from the accumulated set (tree node values if using hash
trees) while at the same time be able to produce non–membership proofs. We solve this
last issue using Kocher [10] trick; instead of associating values to the tree’s leaves, we
associated a pair of consecutive accumulated set elements. To prove that an element
x is not in the accumulated set now amounts to showing that a pair (xα,xβ), where
xα ≺ x ≺ xβ, belongs to the tree but the pairs (xα,x) and (x,xβ) do not.

The drawbacks of using a hash tree based scheme are twofold. First, the size of witnesses 
and the update time is logarithmic in the number of values accumulated. In contrast,
 witnesses and updates can be computed in constant time in RSA modular exponentiation 
based schemes like the ones of [5,3,1,11]. We believe, nonetheless, that this
problem may in fact not exist for reasonable set sizes — a claim that we will later support.
The second drawback is the accumulator’s manager storage space requirements which
is linear in the number of elements. However, this is not an issue for the accumulator’s
users, since they only need logarithmic in the accumulated set size storage space.

Overall, the main advantages of our scheme in comparison to Li et al.’s [11] are:
(1) the accumulator manager need not to be trusted, and (2) since we only assume the
existence of cryptographic hash functions as opposed to the Strong RSA Assumption,
the underlying security assumption is (arguably) weaker. (Indeed, collision-resistance
can be based on the intractability of factoring or computing discrete logarithms [7]
while Strong-RSA is likely to be a stronger assumption than factoring [4].)

Strong Accumulators from Collision-Resistant Hashing

473

1.1 Our Contributions
Our contribution is threefold. First, we strengthen the basic deﬁnition of universal accumulators 
by allowing an adversary to corrupt the accumulator manager. This gives
rise to the notion of strong universal accumulators. Second, we show how to construct
strong universal accumulators using only collision-resistant hash functions. Our construction 
has interesting properties of its own. As in [5,11], we use auxiliary information 
to compute the (non)membership witness, but this information (called memory)
need not to be kept private, and does not allow an adversary to prove inconsistent statements 
about the accumulated set. Indeed, the construction provides almost the same
functionality as the (dynamic) universal accumulators described in [11], namely:

• All the elements of the set are accumulated in one short value.
• It is possible to add and remove elements from the accumulated set.
• For every element of the input space there exists a witness that proves whether

the element has been accumulated or not.

Under stronger assumptions (concretely, Strong RSA) we show how to enhance our
basic scheme in order to allow dynamic updates of witnesses.

Our last contribution is showing how to apply strong universal accumulators to
solve a multi-party computational problem of practical relevance which we name the
e-Invoice Factoring Problem. Solving this problem was indeed the original motivation
that gave rise to this work.

In Section 2, we give some background deﬁnitions and formally introduce the notion
of strong universal accumulator schemes. In Section 3, we describe our basic strong
universal accumulator scheme and rigorously establish its security. In Section 4, we
discuss the efﬁciency of the scheme in practice, and outline a variant that allows witness 
updates. Section 5 brieﬂy motivates the e-Invoice Factoring Problem. In Section 6,
we conclude with some comments. Due to space restrictions the e-Invoice Factoring
Problem is described in the full version of this paper where it is also shown how it can
be solved using strong universal accumulator schemes.

2 Deﬁnitions and Notations
Let neg : N → N denote a negligible function, that is, for every polynomial p(·) and any
large enough integer n, neg(n) < 1/p(n). Let also || denote the operation of concatenation 
between binary strings. If R() is a randomized algorithm, we write a R← R() to denote
the process of choosing a according to the probability distribution induced by R. We also
denote by (cid:6)R()(cid:7) the set of all possible values a returned by R with positive probability.
We distinguish between an accumulator scheme (the protocol, see below), its short representation 
or accumulator value, and its corresponding accumulated set X. For simplicity,
however, we may use these terms indistinguishably when it’s clear from the context.

SYNTAX. We formally deﬁne the syntax of a strong universal accumulator scheme (with
memory). Our deﬁnition differs from that of Li et al. [11] as we consider an algorithm
to verify if the accumulator value has been updated correctly (by adding or deleting a
certain value), and we are not interested in hiding the order in which the elements are
inserted into the accumulated set.

474

P. Camacho et al.

Deﬁnition 1 (Strong Universal Accumulators with Memory). Let M be a set of values.
 A strong universal accumulator scheme (with memory) for the input set X ⊆ M is
a tuple A = (Setup, Witness, Belongs, Update, CheckUpdate) where

if x (cid:11)∈ X.

• Setup is a randomized algorithm which on input a security parameter k ∈ N,
outputs a public data structure m0 (also called the memory), and returns an initial 
accumulator value Acc0 in the set Y = {0,1}k. Both the accumulator value
Acc and the memory m will be typically held and updated by the accumulator
manager.
• Witness is a randomized algorithm which takes as input x ∈ M and memory m,
and outputs a witness of membership w if x ∈ X (x has been accumulated) or a
(cid:10)
witness of nonmembership w
• Belongs is a randomized algorithm which on input a value x ∈ M, a witness w
and the accumulator value Acc ∈ Y outputs a bit 1 if w is deemed a valid witness
that x ∈ X, outputs 0 if w is deemed a valid witness that x (cid:11)∈ X, or outputs the
special symbol ⊥ if w is not a valid witness of either statement.
• Updateop is a randomized algorithm that updates the accumulator value by either 
adding an element (op = add) to or removing an element (op = del) from
the accumulated set. The algorithm takes an element x ∈ M, an accumulator and
memory pair (Accbefore, mbefore), and outputs an updated accumulator and memory 
pair (Accafter, mafter), and an update witness wop.
• CheckUpdate is a randomized algorithm that takes as input a value x ∈ M, a
pair of accumulator values (Accbefore, Accafter), and an update witness w, and
returns a bit b. Typically, this algorithm will be executed by parties other than
the accumulator manager in order to verify correct update of the accumulator
by the manager. If b = 1, w is deemed a valid witness that an update operation
(for op ∈ {add, del}) which replaced Accbefore with Accafter as the accumulator
value, was valid. Otherwise, w is deemed invalid for the given accumulator pair.

All the above algorithms are supposed to have complexity polynomial in the security
parameter k.

In the above deﬁnition the memory m is a public data structure which is computed
from the set. Although public, this structure only needs to be maintained (stored) by
the accumulator manager who updates the accumulator and generates membership and
non-membership witnesses. In particular, the memory is not used to verify correct accumulator 
updates nor to check the validity of (non)membership witnesses.
Deﬁnition 2. An accumulator value Acc represents the set X ⊆ M, denoted by Acc ⇒ X,
if and only if there exists a sequence {(Acci,xi, mi)}1≤i≤n, where n = |X|, and values
Acc0, m0 where xi ∈ M for 1 ≤ i ≤ n and

• X = {xi}1≤i≤n ,
• (Acc0, m0) ∈ (cid:6)Setup()(cid:7) ,
• (Acci, mi,wi) = Updateadd(xi, Acci−1, mi−1) for all 1 ≤ i ≤ n.

If no such sequence exists Acc does not represents set X, denoted by Acc (cid:2) X.

Strong Accumulators from Collision-Resistant Hashing

475

Note that this deﬁnition also considers sets that have been formed by successive addition
and deletions of elements as there is always a sequence of only addition operations that
leads to the same set.

SECURITY. Universal accumulators as deﬁned in [11] satisfy a basic consistency prop-
erty: it must be unfeasible to ﬁnd both a valid membership witness and a valid nonmembership 
witness for the same value x ∈ M. As mentioned there, this is equivalent to
saying that given X ⊆ M it is impossible to ﬁnd x ∈ X that has a valid nonmembership
witness or to ﬁnd x ∈ M\X that has a valid membership witness.

In order to be able to cope with malicious accumulator managers, we adapt the security 
notion in [11] as follows. First, we let the adversary select not only the value x
and the witness w but also the accumulated set X ⊂ Y , the accumulator value Acc ∈ Y
and whether x belongs or not to X. We restrict the adversary so he must choose a
pair (Acc,X) for which there exists a sequence of valid addition operations (namely,
Updateadd with values in X) that can produce an accumulated value Acc. This last restriction 
can be justiﬁed by noticing that, in the scenario we consider, parties other than
the accumulator manager can externally verify the correctness of each update operation
by using the CheckUpdate algorithm. Thus, security holds as long as it is unfeasible for
the adversary to fool the CheckUpdate veriﬁcation, namely given an accumulator value
Accbefore, the adversary is unable to efﬁciently generate an accumulator value Accafter, a
set X, an input value x, and a valid update witness w for which Accbefore actually represents 
set X and CheckUpdate(x, Accbefore, Accafter,w) = 1, but Accafter (cid:11)⇒ X ∪{x} if w
is an addition witness or Accafter (cid:11)⇒ X \{x} if w is an deletion witness.
Deﬁnition 3 (Security of Strong Universal Accumulators with Memory). A strong
universal accumulator with memory is secure if for every probabilistic polynomial-time
adversary A the following conditions hold:

• (Consistency)

(cid:2)

Pr

Acc ⇒ X, Belongs(x,w1, Acc) = 1, Belongs(x,w2, Acc) = 0

(x,w1,w2,X, Acc) ← A(k);

(cid:3)

= neg(k) .

• (Secure addition)
⎡
⎣ (Accbefore,X, Accafter,x,w) ← A(k) :
Accbefore ⇒ X, Accafter (cid:2) X ∪{x},
CheckUpdate(x, Accbefore, Accafter,w) = 1

Pr

• (Secure deletion)
⎡
⎣ (Accbefore,X, Accafter,x,w) ← A(k) :
Accbefore ⇒ X, Accafter (cid:2) X\{x},
CheckUpdate(x, Accbefore, Accafter,w) = 1

Pr

⎤
⎦ = neg(k) .

⎤
⎦ = neg(k) .

The type of accumulators we consider in this work is not necessarily quasi-commutative
[5,11] as they may not hide the order in which the elements were added to the set. More
precisely, our deﬁnition tolerates that the value of the accumulator may depend on a
particular sequence of Updateadd and Updatedel operations that produced a particular

476

P. Camacho et al.

accumulator value Acc. Our only requirement is that the accumulated set X represented
by any accumulator value is well deﬁned. The following proposition shows this is so if
we use a secure strong universal accumulator scheme. The proof is omitted due to space
constraints.
Proposition 1. Let A a secure strong universal accumulator scheme, and k ∈ N a security 
parameter. Given any adversary A, consider the experiment ExpSUAcc
in which
the adversary is allowed to submit as many queries to oracle O() as it wants and then
stops. Oracle O() is stateful and operates as follows: on any ﬁrst query, the oracle cre-
, runs Setup(k) to obtain (Acc(cid:10), m(cid:10)) which it returns as the query
ates an empty set X
answer. Then, for each subsequent query of the form (x, Acc,w) the oracle computes
b ← CheckUpdate(x, Acc(cid:10), Acc,w), and if b = 1, it sets Acc(cid:10) ← Acc, X
(cid:10) ∪ {x},
and returns bit b as the answer to the oracle query. If b = 0 it does not modify Acc
if after A stops,
or X
(cid:8)
(cid:9)
it holds that Acc (cid:11)⇒ X
. Then, for every probabilistic polynomial time adversary A,
A wins in ExpSUAcc
Pr
A,A

and it simply returns ⊥. We say adversary A wins ExpSUAcc

is negligible in k.

(cid:10)

(cid:10)

(cid:10)

A,A

(cid:10) ← X

A,A

Our security deﬁnition (Deﬁnition 3) for the dynamic scenario (where addition and
deletion of elements are allowed) differs from the one in [5] where the adversary is
only able to add and delete elements by querying the accumulator manager, who is
uncorruptible. In contrast, in our deﬁnition the adversary is allowed to control the accumulator.
 However, we require that during each update at least an uncorrupted participant 
veriﬁes the update with CheckUpdate to guarantee the consistency between the
accumulated value and the history of additions and deletions.

DYNAMIC ACCUMULATORS. The standard deﬁnition of dynamic accumulators (see for
example the one in [5]) adds two requirements which so far we have not considered.
First, it requires the existence of an additional efﬁcient algorithm that allows to publicly
and efﬁciently update membership witnesses after a change in the accumulator value
so witnesses can be proven valid under the new accumulator value. And secondly, it
requires that both the accumulator updating algorithm as well as the witness updating
algorithm to run in time independent from the size n of the accumulated set.

Our construction can be extended to achieve efﬁcient witness update while still
tolerating corrupted accumulator managers although under stronger assumptions (see
Section 4). Regarding the efﬁciency of accumulator updates, we only achieve logarithmic 
dependency on n. In practice, such dependency may be appropriate for many
applications.

3 Our Scheme

We assume that there exist a public broadcast channel with memory. Depending on
the level of security required, this can be a simple trusted web server, or a bulletin
board that guarantees that every participant can see the published information and that
nobody can delete posted message. For a discussion on bulletin boards and an example
of their use in another cryptographic protocol, the interested reader is referred to [6].
We rely on broadcast channels in order to ensure that the publication of the successive

Strong Accumulators from Collision-Resistant Hashing

477

accumulator values that correspond to updates of the set cannot be forged. In particular,
an adversary who controls the manager of the accumulator cannot publish different
accumulator values to different groups of participants.

3.1 Preliminaries

Our scheme is inspired by time stamping systems like those described in [3,2]. In these
systems a document needs to be associated to a certain moment in time. The solution
proposed there is to divide the time in periods (e.g. hours, days), and place each document 
as a leaf at the bottom of a binary tree (say, T ) with other documents that belong
to the same period of time, say t. Then the values associated to each pair of leaves with
the same parent node are hashed in order to derive the value of the parent node. This
process is repeated until the value v of the root node of the tree is computed. This value
v is then published as a representative of the tree T for period t. Later, a given document
m can be proven to belong to a certain period of time t by presenting a valid subtree of
tree T corresponding to time period t that includes the document m.

We use the above approach to build an accumulator scheme that works for dynamic
sets and also allows proofs of nonmembership. In this case, building a proof of nonmembership 
is somehow similar to the trick of Kocher (in [10]) — instead of storing
elements of the set, we store pairs of consecutive elements of the set. Then, proving that
an element x is not in the accumulated set X amounts to simply proving that there exists
elements xα and xβ, xα < x < xβ, such that a pair (xα,xβ) is stored in the tree.

Our solution uses collision-resistant hash functions, which we formalize as families
of functions. In practice we can use a well known hash function like SHA-256, for
example. We start recalling the standard notion of collision-resistant hash functions.
Deﬁnition 4. A hash-function family is a function H : K × M → Y where K and Y are
non-empty sets and M and Y are sets of strings.
Deﬁnition 5. (Collision-Resistance) Let H : K × M → Y be a hash-function family.
Let k be a security parameter, where k = |K| = |Y|. Then H is collision-resistant if and
only if for every polynomial time probabilistic algorithm A we have:

Pr[κ R← K;(m,m

(cid:10)) ← A(k) : m (cid:11)= m

(cid:10), Hκ(m) = Hκ(m

(cid:10))] = neg(k)

where κ R← K means that κ is selected uniformly at random in the set of keys K.
In the following H will denote a randomly selected function of a collision-resistant
hash-family function H : K × M → Y , where M is the set of all binary strings and Y is
the set {0,1}k, for a large enough security parameter k ∈ N.
We assume the set X we want to accumulate is ordered and denote by xi the ith
element of X = {x1,x2, ...,xn}, n ∈ N. Let x0 = −∞ and xn+1 = +∞ two special elements
such that −∞ ≺ x j ≺ +∞ for all x j ∈ X, where ≺ is the order relation on X (for example,
the lexicographic order on bit strings).

Observe that showing x ∈ X is equivalent to proving that:

(xα,xβ) ∈ {(xi,xi+1) : 0 ≤ i ≤ n} ∧ (x = xα ∨ x = xβ).

478

P. Camacho et al.

On the other hand, showing that x /∈ X corresponds to proving:

xα ≺ x ≺ xβ ∧ (xα,xβ) ∈ {(xi,xi+1) : 0 ≤ i ≤ n}.

Consider now the following recursive deﬁnition of labeled binary tree T :
• T equals the empty tree Nil, or
• T = (S;left,right) where S is a label (string) and Left(T ) = le f t and Right(T ) =

right are trees.

(cid:10)

Here left and right are the left and right child of T respectively. Each tree T has associated 
a node N = node(T ) which is called the root of T as well as the parent
of Left(T ) and Right(T ). Each node N = node(S;left,right) has associated a string
Label(N) = S. Sometimes we identify the tree with its root and we write Label(T )
to denote Label(node(T )). We say that N
is a
node of Left(T ) or Right(T ). A leaf is a node of the form (S;Nil,Nil). If T = Nil, then
we say that T has depth 0 and denote it as depth(T ) = 0. Otherwise, let depth(T ) =
1 + max{depth(Left(T )),depth(Right(T))}. A tree T is balanced if |depth(Left(T ))−
depth(Right(T ))| ≤ 1. It is a well known fact that a balanced tree with n nodes has
maximum depth O(log(n)).
The set {H(xi||xi+1) : 0 ≤ i ≤ n} will be called the base of X under H. Since H is a
collision-resistant hash function and no two xi are identical, H(xi||xi+1) (cid:11)= H(x j||x j+1)
for i (cid:11)= j, except with negligible probability.

(cid:10) = node(T ) or N

is a node of T if N

(cid:10)

node proof respectively, such that Label(N) = (ValN;Proof N

A balanced binary tree T is called a model of X under H if:
• For every node N in T there are strings ValN and Proof N, called node value and
• The base of X is {ValN : N is a node of T}.
• T has n + 1 nodes.
• Proof N = H(ValN||Proof Left(N)||Proof Right(N)) for every node N of T (where

).

Proof Nil corresponds to the empty string).

A subtree T

(cid:10)

Figure 1 depicts a toy example of a model of a set.

(cid:10)) = Label(T ),
(cid:10)) is a subtree of

(cid:10)) = Nil.

of a labeled binary tree T is a tree such that: (a) Label(T
(cid:10)) = Nil, and (c) Right(T

(cid:10)) is a subtree of Left(T ) or Left(T

(b) Left(T
Right(T ) or Right(T
Let T be a labeled binary tree. We denote its collection of node values by V (T ). We
say that V ⊆ V (T ) generates a minimal subtree U of T if U is a subtree of T obtained
by taking all nodes in T that belong to all paths from T ’s root to a node whose value is in
V (the paths include both the root of T and the nodes of value in V ) and all the children
of these nodes. Figure 2 illustrates the concept of minimal subtree. If U is generated by
a singleton {S}, then we say that U is generated by S.
Proposition 2. Let H :K × M → Y be a collision-resistant hash function family and H
a uniformly chosen function in H . Let X ⊂ M be an adversarially-chosen polynomial
size set (on the security parameter k), and T be a model of X under H. Then, given T ,
and a value V such that
no adversary can efﬁciently compute a labeled binary tree T
V ∈ V (T

(cid:10))\ V (T ) and Proof T(cid:10) = Proof T , except with negligible probability.

(cid:10)

Strong Accumulators from Collision-Resistant Hashing

479

H(−∞||x1)

H(x1||x2)

H(x2||x3)

H(x3||x4)

H(x4||x5)

H(x5||x6) H(x8|| + ∞)

H(x6||x7) H(x7||x8)

Fig. 1. A tree model T of the set X = {x1, . . . ,x8}. Only node values are shown. Note that the
place of the values in the tree is irrelevant.

a

b

i

c

f

j

m

d e

g h

k

l

n o

Fig. 2. A tree and its minimal subtree (nodes with values in boldface) generated by the node of
value j. Children of the nodes that are on the path from j to a are underlined.

(cid:10)

(cid:10)) but not in V (T ) there must exist a node N

(cid:10)

(cid:10)

Proof. Let A be a polynomial time stateful adversary which works in two phases. First,
on input the security parameter and a hash function H ∈ H , A outputs a set X ⊂ M of
size polynomial on k. Then, given a model T for X under H, it outputs a labeled biand 
a value V satisfying the conditions of the proposition. Since Proof T(cid:10) =
nary tree T
Proof T and value V is in V (T
and a
node N in T such that Proof N(cid:10) = H(ValN(cid:10)||Proof Left(N(cid:10))||Proof Right(N(cid:10))) and Proof N =
H(ValN||Proof Left(N)||Proof Right(N)) are equal but ValN||Proof Left(N)||Proof Right(N) (cid:11)=
ValN(cid:10)||Proof Left(N(cid:10))||Proof Right(N(cid:10)). Nodes N and N
can be found efﬁciently by simply
traversing both trees in some ﬁxed order.
Now, let B be an adversary that is given a uniformly selected at random collisionresistant 
hash function H ∈ H . B ﬁrst queries A to obtain a set X which it uses to build a
model T for X under H. Then, B runs A as a subroutine to obtain another labeled binary
(cid:10)) \ V (T ). Finally,
tree T
following the procedure mentioned above, B will be able to ﬁnd a collision for H.

and a value V such that Proof T = Proof T(cid:10) and V ∈ V (T

in T

(cid:10)

(cid:10)

3.2 A Strong Universal Accumulator with Memory Using Hash Trees

In this section we use hash trees to build a universal accumulator with memory.
THE CONSTRUCTION. Let k ∈ N be the security parameter and let X = {x1,x2, ...,xn}
be a subset of M = {0,1}k. We deﬁne the accumulator scheme HashAcc below.

480

P. Camacho et al.

• Belongs: On input x ∈ M, witness w = ((x

• The memory m is a model of X.
• Setup: The algorithm ﬁrst sets X equal to the empty set. Then, it picks a hash
function H uniformly at random from the family H by ﬁrst computing a random
index i ∈ K (say using standard multiparty computation techniques among all
participants, including the accumulator manager) and then setting H = Hi.1 The
algorithm then initializes m to a single root node Nm with value H(−∞|| + ∞).
Finally, the accumulator manager publishes Accinit = Proo fNm .
• Witness: On input x ∈ M and memory m, it computes the witness w = (w1,w2)
as follows. First, the algorithm sets w1 = (xα,xβ) where x = xα or x = xβ if x ∈ X.
Otherwise, if x /∈ X the algorithm sets w1 = (xα,xβ) where xα ≺ x ≺ xβ. Finally,
it sets w2 as the minimal subtree of m generated by the value H(xα||xβ).
(cid:10)(cid:10)),u), and accumulator value Acc,
(cid:10)(cid:10)) ∈
it ﬁrst checks if the following conditions hold: (a) Proof u = Acc, (b) H(x
(cid:10)(cid:10)). The algorithm outputs 1 if
Vu, (c) (x = x
conditions (a), (b), and (c) hold; it outputs 0 if (a), (b), and (c’) hold. Otherwise,
it outputs ⊥.
• Updateop: On input an element x ∈ M, an accumulator value Accbefore, and a
memory mbefore, it proceeds as follows. Consider two cases depending on whether
the update is an addition (op = add) or a deletion (op = del).
If op = add and x (cid:11)∈ X, the algorithm adds x into X by modifying mbefore as
It replaces the value H(xα||xβ) from the appropriate node in mbefore (where
xα ≺ x ≺ xβ) by the value H(xα||x).
It augments the tree mbefore with a new leaf N of value H(x||xβ) so the resulting 
tree mafter is a balanced tree. Let VPar(N) be the (parent) node where N is
attached as a leaf.

follows:
1.

(cid:10)||x

(cid:10),x

(cid:10)

or x = x

(cid:10)(cid:10)), and (c’) (x

(cid:10) ≺ x ≺ x

2.

The resulting tree is denoted mafter. Figure 3 illustrates the process of inserting
an element into mbefore.
Once tree mafter is built, the new accumulator is simply the value of the root of
the tree, namely Accafter = Proof mafter . The witness wadd = (add,wadd,1,wadd,2)
that the update (addition) has been done correctly is computed as follows:
• wadd,1 corresponds to the minimal subtree of mbefore generated by the set
• wadd,2 corresponds to the minimal subtree of mafter generated by the set

{H(xα||xβ),ValVPar(N)}, and,
{H(xα||x),H(x||xβ)}.

If op = del, deleting x from X is done in a similar way as follows. First,
the update algorithm locates the two nodes of mbefore that contain x. Let Vα and
Vβ be those nodes, and let H(xα||x) and H(x||xβ) be their respective values, for
some xα ≺ x ≺ xβ. The goal is to remove these nodes and replace them with a
new node with value H(xα||xβ) in a way that the derived tree is still balanced.
This is done by ﬁrst replacing Vα with the single node with value H(xα||xβ),
and then replacing Vβ with a leaf node L (for example, the rightmost leaf on

1 A common heuristic to avoid interaction is to simply pick H =SHA-256 [12], for example.

Strong Accumulators from Collision-Resistant Hashing

481

H(−∞||x1)

H(x1||x2)

H(x3||x4)

H(x2||x)

H(x5||x6) H(x8|| + ∞)

H(x6||x7) H(x7||x8)
Fig. 3. Inserting x into the tree of Figure 1 where x2 ≺ x ≺ x3

H(x4||x5)
H(x||x3)

the last level of the tree). These replacements yield a new tree mafter whose root
label is set to the value of the accumulator Accafter = Proo fmafter. The witness
wdel = (del,wdel,1,wdel,2,wdel,3) is then computed as follows:
• wdel,1 corresponds to the minimal subtree of mbefore generated by the set
• wdel,2 is the pair (xα||xβ) such that xα ≺ x ≺ xβ, and
• wdel,3 is the minimal subtree of mafter generated by H(xα||xβ).

{H(xα||x),H(x||xβ),ValL},

The algorithm Updateop outputs the new accumulator value Accafter, the modiﬁed
memory mafter, and the update witness wop.
• CheckUpdate: On input an element x ∈ M, two accumulator values Accbefore,
Accafter, and an update witness w, it proceeds as follows. If w = (add,w1,w2)
then, the algorithm outputs 1 provided that:

• w1 is a tree obtained by adding a leaf to w2,
• Except for the node of value H(xα||xβ) (for xα ≺ x ≺ xβ) all nodes which
are common to w1 and w2 have the same value in either one of the trees,
• Proof w1
• H(xα||x),H(x||xβ) ∈ V (w2).

= Accbefore and Proof w2

= Accafter, and

Otherwise, it outputs 0. We omit the case w = (del,w1,w2,w3) which is similar.

SECURITY. We now prove that the scheme HashAcc of the previous section is secure
under Deﬁnition 3.
First, note that if memory m is a model of X, then the memory obtained after executing 
Update in order to add a new element x /∈ X, is a model of X ∪ x. Indeed, suppose
xα ≺ x ≺ xβ and let H(xα||xβ) be the value of a node V in m. By replacing node V with
the node of value H(xα||x) and adding the node of value H(x||xβ), we clearly obtain a
set of values {H(xi||xi+1), 0 ≤ i ≤ n + 1} that corresponds to the successive intervals of
the set X ∪{x} (where n = |X|).

Intuitively, CheckUpdate must guarantee that the updated memory (tree) used to
compute the new accumulated value still has the property of having all the successive
intervals of the accumulated set as node values, that each interval appears once and only
once in the tree, and that no other node value can belong to the tree.

482

P. Camacho et al.

H(−∞||x1)

H(−∞||x1)

H(x1||x2)

H(x2||x3)

H(x1||x2)

H(x2||x)

H(x3||x4) H(x4||x5)

H(x5||x6) H(x8||+∞)

H(x3||x4)

H(x5||x6) H(x8||+∞)

H(x4||x5)
H(x||x3)

(a)

(b)

Fig. 4. (a) The minimal subtree of the tree shown in ﬁgure 1 and generated by {H(x2||x3),
H(x4, x5)}. (b) The minimal subtree of the tree shown in Figure 3 and generated by {H(x2||x),
H(x||x3)}.
Theorem 1. Let H :K × M → Y be a collision-resistant hash function family. Then, the
accumulator scheme HashAcc is a secure strong universal accumulator scheme (with
memory).

Proof. We need to prove the properties Consistency, Addition, and Deletion.

• (Consistency) First, we note that Acc ⇒ X implies that there exists a memory m
which is a model of X. Let us now suppose that there is an adversary A that can
compute a value x and two witnesses w1,w2 such that Belongs(x,w1, Acc) = 1
and Belongs(x,w2, Acc) = 0. We assume without lost of generality that x ∈ X.
Any such adversary A is in fact able to ﬁnd xα and xβ, xα ≺ x ≺ xβ, such that
H(xα||xβ) belongs to V (m). Since m is a model for X, by Proposition 2 this
adversary will only succeed with negligible probability. The argument for x /∈ X
is analogous.
• (Secure Addition) Consider the case where the update is the addition of a value x
such that xα ≺ x ≺ xβ and H(xα,xβ) belongs to the base of X, where Accbefore ⇒
X. Assume that CheckUpdate(x, Accbefore, Accafter,w) = 1 where both x and w =
(add,Ubefore,Uafter) are arbitrarily chosen by the adversary, and Accafter (cid:2) X ∪
{x}. Then, for some two elements u,v ∈ M the adversary is effectively able
∗ = Uafter containing a value H(u||v) that does not belong to
to build a tree S
(V (mbefore)∪ {H(xα||x),H(x||xβ)})\{H(xα||xβ)} = V (mafter) and such that in
= Accafter = Proo fmafter. This contradicts Propoaddition 
Proo fS∗ = Proo fUafter
sition 2.

• (Secure Deletion) This case is similar to the addition of an element.

EFFICIENCY. We analyze the computational efﬁciency of the proposed scheme.

Theorem 2. Let n be the size of X. The witnesses of (non)membership and of updates
have size O(log(n)). The update process Update, the veriﬁcation processes Belongs
and CheckUpdate can be done in time O(log(n)).

Proof. It is enough to show that a minimal subtree U of T generated by a constant
number of node values has a size O(log(n)). Indeed, ﬁrst note that a minimal subtree
of a tree generated by a constant number of node values is the union of the minimal
subtrees generated by each of the values. It is easy to see that the size of a minimal

Strong Accumulators from Collision-Resistant Hashing

483

subtree generated by a node value is proportional to the depth of the node. This, and the
fact that T is balanced, implies the desired conclusion.

4 Other Considerations and Further Extensions

EFFICIENCY. Our solution is theorically less efﬁcient than the scheme proposed in [11].
Nonetheless, if one considers practical instances of these schemes the difference effectively 
vanishes as in most implementations hash functions operations are signiﬁcantly
faster than RSA exponentiations – which is the core operation used by the schemes
in [11,5]. Table 2 shows the time taken by one single RSA exponentiation versus the
time taken by our scheme for update operations as a function of the number of the accumulated 
elements. For the time measurements, we used the openssl benchmarking
command (see [13]) on a personal computer. Notice that RSA timings were obtained
using signing operations, as in the scheme proposed in [11] where exponents may not
be small. Timings for SHA operations were measured using an input block of 1024 bits.
The comparison is based on the fact that our scheme requires at most 4× 2 log(N) hash
computations, where N is the number of accumulated elements, given that at most four
branches of the Merkle tree used in our construction (three for wdel,1 and one for wdel,3,
see Section 3.2) will have to be recomputed in the case of deletions.

Our results show that even for large values of N using a hash-based scheme is still
very efﬁcient. Moreover, our scheme is faster than using a single RSA operation with a
2048-bit key.

DYNAMIC ACCUMULATORS AND WITNESS UPDATE. Our construction as described
in Section 3.2 does not allow to update witnesses ([5]). This feature allows a user to
recompute her witness after a new value is added or removed from the set X of accumulated 
values so the new witness can be veriﬁed against the new accumulator value. A

Table 1. Running time for RSA and SHA operations

Note

Algorithm
SHA-256 input block of 1024 bits
SHA-512 input block of 1024 bits
RSA-512
RSA-1024
RSA-2048

signing operation
signing operation
signing operation

Operations per second

65507
16856
1179
236
40

Table 2. Comparison of performance between simple RSA exponentiation and logarithmic number 
of computations of SHA. N is the number of elements that are accumulated. Time is represented 
in milliseconds.

N RSA-512 RSA-1024 RSA-2048 SHA-256 SHA-512
23
210
220
230

0,845
0,845
0,845
0,845

4,23
4,23
4,23
4,23

25
25
25
25

0,37
1,22
2,44
3,66

1,42
4,75
9,5
14,24

484

P. Camacho et al.

simple way to achieve this is to keep track of each accumulator value Acc using the construction 
of Camenisch and Lysyanskaya [5]. Concretely, let AccCL be the accumulator
scheme proposed in [5]. Under our modiﬁed scheme, a witness that x ∈ X is now composed 
by two parts: a witness as computed by our construction and a witness that Acc
has been accumulated into the accumulator AccCL. Since the construction in [5] allows
both public updates to the accumulator as well as public computation of membership
witnesses, we can update the two-part witness now by simply updating the witness that
Acc was at some moment a value for the accumulator in our original scheme. Notice
that this combined scheme allows the efﬁcient update of witnesses while still preserving 
the main security property of our scheme (security against a malicious accumulator
manager). Obviously, the new feature comes at a cost: lower efﬁciency and new security
assumptions (strong RSA). How to avoid these costs is an open problem.

5 The e-Invoice Factoring Problem

In this section we describe an application of strong universal accumulators that yields an
electronic analog of a mechanism called factoring through which a company, henceforth
referred to as the Provider (P), sells a right to collect future payment from a company
Client (C). The ensuing discussion is particularly concerned with the transfer of payment 
rights associated to the turn over of invoices, that is, invoice factoring. The way
invoice factoring is usually performed in a country like Chile is that P turns a purchase
order from C to a third party, henceforth referred to as Factoring Entity (FE). The latter
gives P a cash advance equal to the amount of C’s purchase order minus a fee. Later,
FE collects payment from C.

There are several beneﬁts to all the parties involved in a factoring operation. The
provider obtains liquidity and avoids paying interests on credits that he/she would otherwise 
need (it is a common practice for some clients as well as several trading sectors
in Chile to pay up to 6 months after purchase). The client gets a credit at no cost and is
able to perform a purchase for which he might not have found a willing provider.

The main phases of a factoring operation are summarized below: (a) C requests from
P either goods or services, (b) P delivers the goods/services to C, (c) P makes a factoring
request to FE, (d) FE either rejects or accepts P’s request — in the latter case FE gives
P a cash advance on C’s purchase, (e) later, FE asks C to settle the outstanding payment,
and ﬁnally (f) C pays FE.

A risk for FE is that P can generate fake invoices and obtain cash advances over
them. This danger is somewhat diminished by the fact that such dishonest behavior
has serious legal consequences. More worrisome for FE is that P may duplicate real
invoices and request cash advances from several FEs simultaneously. But, Chile’s local
practice makes this behavior hard to carry forth. Indeed, invoices are printed in blocks,
serially numbered and pressure sealed by the local IRS agency (known as Servicio de
Impuestos Internos (SII)). A FE will request the physical original copy of an invoice
when advancing cash to P. It is illegal, and severely punished, to make fake copies or
issue unsealed invoices.

Strong Accumulators from Collision-Resistant Hashing

485

Approximately half a decade ago, an electronic invoicing system began operating in
Chile. Background and technical information concerning this initiative can be downloaded 
from the website of the SII, speciﬁcally from [8].

The newly deployed electronic invoicing system has been widely successful. It has
been hailed as a major step in the government modernization. Furthermore, it has created 
strong incentives for medium to small size companies to enter the so called “information 
age”. Nevertheless, the system somewhat disrupts the local practice concerning
factoring. Speciﬁcally, a FE will not be able to request the original copy of an invoice,
since in a digital world, there is no difference between an original and a copy. This
creates the possibility of short term large scale fraud being committed by unscrupulous
providers. Indeed, a provider can “sell” the same invoice to many distinct FEs. We refer 
to the aforementioned situation created by the introduction of electronic invoicing
as the e-Invoice Factoring Problem. In the full version of this paper we show how to
address this problem using strong universal accumulator schemes.

6 Conclusion

We introduced the notion of strong universal accumulator scheme, which provide almost 
the same functionality as do the universal accumulator schemes deﬁned in [11],
namely (a) a set is represented by a short value called accumulator, (b) it is possible
to add and remove elements dynamically from the (accumulated) set, and (c) proofs of
membership and nonmembership can be generated using a witness and the accumulated
value. In this notion, however, the accumulator manager does not need to be trustworthy
and might be compromised by an adversary.

We also give a construction of a strong universal accumulator scheme based on cryptographic 
hash functions which relies on a public data structure to compute accumulated
values and witnesses (of membership and nonmembership in the accumulated set). We
argue that the proposed scheme is practical and efﬁcient for most applications. In particular,
 we discuss an application to a concrete and relevant problem — the e-invoice
factoring problem.

References

1. Bari´c, N., Pﬁtzmann, B.: Collision-free accumulators and fail-stop signed scheme without
trees. In: Fumy, W. (ed.) EUROCRYPT 1997. LNCS, vol. 1233, pp. 480–494. Springer,
Heidelberg (1997)

2. Bayer, D., Haber, S., Stornetta, W.S.: Improving the efﬁciency and reliability of digital timestamping.
 In: Capocelli, R.M., DeSantis, A., Vaccaro, U. (eds.) Sequences II: Methods in
Communication, Security, and Computer Science, pp. 329–334. Springer, Heidelberg (1993)
3. Benaloh, J., De Mare, M.: One-way accumulators: A decentralised alternative to digital signatures.
 In: Helleseth, T. (ed.) EUROCRYPT 1993. LNCS, vol. 765, pp. 274–285. Springer,
Heidelberg (1994)

4. Boneh, D., Venkatesan, R.: Breaking RSA not be equivalent to factoring. In: Nyberg, K. (ed.)

EUROCRYPT 1998. LNCS, vol. 1403, pp. 59–71. Springer, Heidelberg (1998)

5. Camenisch, J., Lysyanskaya, A.: Dynamic accumulators and application to efﬁcient revocation 
of anonymous credentials. In: Yung, M. (ed.) CRYPTO 2002. LNCS, vol. 2442, pp.
61–76. Springer, Heidelberg (2002)

486

P. Camacho et al.

6. Cramer, R., Gennaro, R., Schoenmakers, B.: A secure and optimally efﬁcient multi-authority
election scheme. In: Fumy, W. (ed.) EUROCRYPT 1997. LNCS, vol. 1233, pp. 103–118.
Springer, Heidelberg (1997)

7. Damg˚ard, I.: Collision free hash functions and public key signature schemes. In: Price, W.L.,
Chaum, D. (eds.) EUROCRYPT 1987. LNCS, vol. 304, pp. 203–216. Springer, Heidelberg
(1988)

8. Servicio de Impuestos Internos. Informaci´on sobre factura electr´onica [June 19, 2008],

https://palena.sii.cl/dte/mn info.html

9. Fazio, N., Nicolisi, A.: Cryptographic accumulators: Deﬁnitions, constructions and applications 
(2003) [June 19, 2008],
http://www.cs.nyu.edu/∼nicolosi/papers/accumulators.ps

10. Kocher, P.C.: On certiﬁcate revocation and validation. In: Hirschfeld, R. (ed.) FC 1998.

LNCS, vol. 1465, pp. 172–177. Springer, Heidelberg (1998)

11. Li, J., Li, N., Xue, R.: Universal accumulators with efﬁcient nonmembership proofs. In: Katz,

J., Yung, M. (eds.) ACNS 2007. LNCS, vol. 4521. Springer, Heidelberg (2007)

12. National Institute of Standards and Technology (NIST). FIPS Publication 180: Secure Hash

Standard (SHS) (May 1993)

13. OpenSSL Project. OpenSSL Package (June 2008) [June 19, 2008],

http://www.openssl.org

