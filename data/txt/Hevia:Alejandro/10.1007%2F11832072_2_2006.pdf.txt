Universally Composable Simultaneous Broadcast

Alejandro Hevia(cid:2)

Department of Computer Science, Universidad de Chile

Blanco Encalada 2120, Santiago, Chile

ahevia@dcc.uchile.cl

Abstract. Simultaneous Broadcast protocols allow diﬀerent parties to
broadcast values in parallel while guaranteeing mutual independence of
the broadcast values. The problem of simultaneous broadcast was suggested 
by Chor et al. (FOCS 1985) who proposed a linear-round solution,
and later improved by Chor and Rabin (PODC 1987) and Gennaro (IEEE
Trans. on Parallel and Distributed Systems 2000). The most eﬃcient solution,
 in terms of round complexity, is the one due to Gennaro, which is in
the common random string model. This construction has constant round
complexity but is not very practical, as it requires generic zero-knowledge
proofs, non-interactive zero-knowledge proofs of knowledge, and commitment 
schemes. All the mentioned solutions were proven secure under security 
deﬁnitions with weak or no composition guarantees – only sequential
composition for the initial construction by Chor et al.

In this work, we explore the problem of Simultaneous Broadcast under 
Universally Composable (UC) security (Canetti 2001). We give a
deﬁnition of Simultaneous Broadcast in this framework, which is shown
to imply all past deﬁnitions. We also show this notion can be achieved
by a computationally eﬃcient, constant-round construction (building on
the veriﬁable secret sharing scheme of Cramer et al. at Eurocrypt 1999),
which is secure under an honest majority. Our results rely on (and beneﬁt 
from) capturing synchronous communication as a functionality within
the UC model, as suggested by Canetti (IACR eprint 2005). Indeed, we
show that this approach of modeling synchronous communication can
lead to better understanding of where synchronicity is needed, and also
simpler constructions and proofs.

1 Introduction

Broadcast channels allow one or more senders to eﬃciently transmit messages
to be received by all parties connected to a (physical or virtual) communication
network. As a communication primitive, broadcast is fundamental both in the
design of network communication protocols, and in the area of secure multiparty
computation. The main security property characterizing broadcast communication 
is consistency: the messages received by all players as a result of a broadcast

(cid:2) Work done while the author was at the Computer Sc. Dept., U.C. San Diego, USA.
Supported in part by NSF grant 0313241. Any opinions, ﬁndings, and conclusions
or recommendations expressed in this material are those of the author(s) and do not
necessarily reﬂect the views of the National Science Foundation.

R. De Prisco and M. Yung (Eds.): SCN 2006, LNCS 4116, pp. 18–33, 2006.
c(cid:2) Springer-Verlag Berlin Heidelberg 2006

Universally Composable Simultaneous Broadcast

19

transmission operation are guaranteed to be the same. The problem of achieving
consistency when implementing broadcast on top of a point-to-point network
(commonly known as Byzantine agreement) is central not only in cryptography,
but also to the area of fault-tolerant distributed computation. It has received
enormous attention (e.g., [25,18,11,7] among many others).

In secure multiparty computation, it is often desirable that the broadcast
channel satisﬁes some additional properties, besides consistency. For example,
in applications where multiple senders must broadcast messages at the same
time1 (e.g., when running in parallel many copies of a broadcast protocol with
diﬀerent senders), it is often important to enforce the simultaneous transmission
of the messages. The goal is that no sender can decide its broadcast message
based on the values broadcast by the other players. Achieving this property,
also called independence, is not as straightforward as it may seem. In general,
naive parallel execution of broadcast protocols does not suﬃce, nor the more
sophisticated round eﬃcient approaches presented in [4,27]. Indeed, a common
conservative assumption in settings where (multisender) broadcast channels are
provided is to assume rushing adversaries – adversaries that, at each round,
may see the messages sent by the honest parties before sending out the messages 
for the corrupted parties for the same round [5]. Nonetheless, this independence 
property does play a fundamental role in the secure multiparty
computation protocol of [12] as well as in many important applications (like
contract bidding, coin ﬂipping, and electronic voting schemes, as exempliﬁed
in [13,17,19]) where this type of broadcast enormously simpliﬁes the design of
protocols.

The concept of simultaneous broadcast was introduced by Chor et al. in [12],
along with a simulated-based deﬁnition. In [12], Chor et al. presented protocols
that securely implement simultaneous broadcast on top of a network which allows 
regular broadcast transmission operations, not necessarily satisfying the simultaneity 
property. For each simultaneous broadcast operation, their protocols
require a number of rounds that is linear in the number of parties. Subsequent
works [13,19] focused on reducing the round complexity, obtaining simultaneous 
broadcast protocols with logarithmic [13] or even constant [19] number of
rounds (the latter result achieved in the common random string model.) Even
as the round-eﬃciency of the solutions increased, the deﬁnitions of security did
not remain the same, and they actually became increasingly restricted, as it was
pointed out by Hevia and Micciancio [22]. In particular, there it was shown that
the protocol of [19], the most round eﬃcient protocol so far, is secure under a
deﬁnition of security strictly weaker than the original simulation-based deﬁnition
[12].2 Nonetheless, the round eﬃciency of Gennaro’s protocol made attractive

1 Also called interactive consistency in [31,4] and parallel broadcast in [22]. To avoid
confusions, we adopt the term multisender broadcast to refer to the operation of
multiple senders broadcasting messages at the same time.

2 Indeed, the deﬁnition of simultaneous broadcast proposed in [19] may not exclude
protocols that fail to achieve the intuitive notion of independence captured by the
simulation-based deﬁnition of [12].

20

A. Hevia

the search for either a proof that such protocol achieves a stronger notion of
simultaneous broadcast (e.g. [12]), or for a variant of that protocol that does it.
Concurrent Execution and Universal Composability: The development 
of increasingly complex computing environments brought the concern that
previously secure protocols (proven as stand-alone primitives) might not remain
secure under stronger adversarial conditions, like parallel or concurrent execution 
with many (possibly diﬀerent) other protocols [17], or if invoked by other
(possibly unknown) protocols. It was in such context that several security frameworks 
were developed (see [32,8] for a good survey). In [8], Canetti presented
the Universally Composable (UC) Security framework, which allows modular
description and analysis of protocols under concurrent execution and provides
strong composability guarantees. Indeed, the security of UC secure protocols is
maintained under general composition with an unbounded number of instances
of arbitrary protocols running concurrently. Thus, given the beneﬁts of the UC
framework, the security of many cryptographic primitives has been revisited to
explore whether these stronger UC guarantees can be achieved, and if so, at what
cost (in terms of eﬃciency or assumptions). As we will see in the next section,
simultaneous broadcast can be achieved under UC security not only at no cost,
but also with gains in terms of eﬃciency.

1.1 Our Contributions

In this work, we present an communication and round eﬃcient solution for
the simultaneous broadcast problem. Our solution is based on veriﬁable secret
sharing (VSS) [12] and does not uses zero-knowledge proofs, zero-knowledge
proofs of knowledge, not commitments schemes as previous constructions [13,19].
Moreover, our construction is provably secure in the Universally Composable
framework against computationally-unbounded adaptive adversaries assuming
an honest majority and private channels, with some negligible error probability.
3 To achieve this, we introduce a natural deﬁnition of Simultaneous Broadcast
in the UC framework which implies all previous deﬁnitions. Our simultaneous
broadcast construction is very eﬃcient: we run one VSS per party in parallel.
 While the construction is technically simple, proving UC security present
some subtleties, like dealing with rushing adversaries or parties simply “copy-
ing” someone else’s sharing. We overcome some of the problems by deﬁning a
synchronous variant of veriﬁable secret sharing, which we call Terminating VSS
(TVSS), and building our simultaneous broadcast protocol invoking such TVSS
functionality. We then show that, when formalized as UC functionality, TVSS
is intrinsically synchronous. A beneﬁt of this approach is that our simultaneous
broadcast protocol does not explicitly requires global synchronous communication 
since all the synchronicity is provided by the Terminating VSS functionality.
Our construction and proof exempliﬁes the approach, ﬁrst suggested by Canetti

3 Most of the properties of our solution – namely communication and round complexity,
 reliability and negligible error probability – are inherited from the VSS used as
building block [14].

Universally Composable Simultaneous Broadcast

21

in [8], of abstracting synchronous communication as a functionality rather than
embedding it in the execution model [30,24]. We believe this approach leads to
modular analysis, simple protocol design and simpler proofs.

1.2 Related Work

Simultaneous Broadcast: As mentioned above, the simultaneous broadcast
problem was put forward by Chor et al. [12] who proposed a simulation-based
deﬁnition and a linear-round protocol. This protocol essentially executed n sequential 
VSS protocols, where n is the number of communicating parties. The
sequential execution was needed to prevent corrupted parties from broadcasting
the same value as an honest party, for instance by reusing (copying) the VSS
data sent out by the honest party. Then, Chor and Rabin in [13] showed how
to reduce the round complexity to O(log(n)) rounds. Their protocol requires,
among other things, that each party ﬁrst broadcast a commitment of her input
and then proves knowledge of the broadcasted value. The reduction in rounds
comes from using a clever scheduling technique for doing the proofs – for any two
players, there is a step in the protocol where one player acts as prover and the
other one acts as veriﬁer of the proof of knowledge. Such a scheduling prevents
“copying” the proofs. Finally, Gennaro in [19], working in the common random
string model, put forward a protocol that greatly simpliﬁes the one in [13] by
showing how to run the proofs of knowledge in parallel, essentially employing
non-interactive proofs of knowledge [34].

In terms of the previous deﬁnitional work for simultaneous broadcast problem,
it turns out that each result in [12,13,19] presents a diﬀerent deﬁnition. Hevia
and Micciancio [22] show that these deﬁnitions form a strict hierarchy when
considered in terms of input distributions. They point out that the strongest
deﬁnition (in a well-deﬁned sense, see [22]) is the simulation-based notion of [12],
which preserves security under sequential composition. The notions in [13,19]
targeted stand-alone execution and thus provide no composition guarantees.
Verifiable Secret Sharing: The notion of Veriﬁable Secret Sharing (VSS)
was ﬁrst proposed by Chor et al. [12] inspired by the need of adding robustness
to standard secret sharing (eg. Shamir’s [35]) The problem has been extensively
studied both in the synchronous setting (e.g. [18,5,20,33,14,1]) and in the asynchronous 
setting [3,6,11,7]. In the information-theoretic model with adaptive
adversaries, Rabin and Ben-Or [33] proposed a VSS secure under an honest
majority, by allowing negligible failure probability. Subsequently, in the same
model, Cramer et al. [14] improved the information checking protocols of [33]
and presented a very eﬃcient constant-round VSS protocol. By instantiating
the Terminating VSS required in our construction with the scheme in [14] we
obtain our constant-round solution.
Related Protocols and Generic Solutions: The simultaneous broadcast
problem is related to the idea of common-coin protocols [18,29], where several
parties want to generate one or more unbiased coins in a distributed way. Indeed,
the constructions proposed in [18,29] involve executing VSS protocols in parallel,

22

A. Hevia

in a similar approach to ours. We remark, however, that the goals are diﬀerent:
while for common-coin generation it suﬃces that the broadcast value of a single
(uncorrupted) value is not correlated to the output of corrupted parties,4 in the
simultaneous broadcast problem we seek to guarantee that every single component 
of the output vector of the broadcast values remains “uninﬂuenced” by the
other values in the same vector. In addition, our construction must guarantee
security under general (UC) composition.

A related, although orthogonal issue, is the problem of simultaneous termination,
 which has been studied by Lindell et al. [27]. The problem arises in the
context of parallel composition of multiparty protocols in synchronous networks,
where certain protocols (including broadcast protocols) may not terminate in
the same round when composed in parallel, thus complicating their sequential
composition with other protocols. (We note that, in [27], the term simultaneous 
broadcast is used but with a diﬀerent meaning than ours, as they refer to
what we call multisender broadcast.) The methods in [27] do not attempt to
achieve independence (in fact, they do not) since their concern is not adding
new functional properties to the resulting parallel protocol, but ensuring that
it can be safely composed sequentially with other protocols while preserving
round eﬃciency. Also in the context of composition of broadcast protocols, Lindell 
et al. discussed some pitfalls in the composition of Authenticated Byzantine
Agreement [26]. They show that, unless session identiﬁers are available, no parallel 
or concurrent composition of Authenticated Byzantine Agreement is secure if
more than one third of the parties are faulty. In our work, we do assume the availability 
of broadcast channels (in the form of the broadcast functionality FBC)
but we put no restrictions on how they are implemented. For example, session
identiﬁers for the broadcast protocols could be initialized using the techniques
of Barak et al. [2], or by standard techniques under setup assumptions [10].

Lastly, there are powerful UC constructions for secure multiparty computation 
of generic protocols (e.g. [10,15]) which could certainly be used to provide
a solution to the simultaneous broadcast problem. Indeed, techniques of [10]
do provide such a solution tolerating any number of corrupted parties in the
common random string model. However, as done in many other examples of
multiparty secure computation (eg. threshold signatures, key-exchange, voting),
our goal is to look for more specialized, and therefore more eﬃcient, solutions
for the simultaneous broadcast problem.
Comparison with previous solutions: In terms of eﬃciency, the number
of rounds required in our construction is equal to the number of rounds of the
terminating VSS construction we use, which is the one proposed by Cramer
et al. [14]. Similarly, the computational complexity of our construction is n times
that of the terminating VSS in [14]. Concretely, our solution requires O((k +
log n)n4) bits of communication, and only 14 rounds (or 12 if no faults occur).
If the model is extended so parties can use digital signatures, the protocol takes
only 7 rounds, although security holds only against computationally-bounded

4 In all fairness, in general the mentioned protocols do achieve more than that.

Universally Composable Simultaneous Broadcast

23

adversaries. In comparison, the previous constant round solution [19] uses at
comparable number of rounds (seven for the VSS protocol [5], plus six for the
computational zero-knowledge proof [20], plus three rounds) but requires the
communication of a large number of bits (n copies of a non-interactive zeroknowledge 
proof of knowledge for a generic NP statement [34], plus n times
the communication complexity of the VSS protocol of [20], a total that in most
implementations is often orders of magnitude larger than O((k + log n)n4) ).

In terms of the adversary tolerated our solution is similar to Gennaro’s. The
construction of [19] works over public channels under computationally-bounded
static adversaries and can be made secure under adaptive adversaries using the
compiler of [9]. In comparison, assuming secure channels, our solution tolerates 
computationally unbounded adaptive adversaries, and security in the public 
channels (and computationally-bounded adversaries) setting can be obtained
by standard techniques, like non-committing encryption [9,16]. In terms of resilience,
 our construction tolerates at most t < n/2 corrupted parties as Gen-
naro’s solution. The constructions of Chor et al. [12] and Chor and Rabin [13]
tolerate t < n/4 and t < n/2 respectively.
Organization of the paper: In the next section, we brieﬂy describe the UC
framework. Then, in Sect. 3, we describe and justify our formalization of the
notion of Terminating VSS (denoted UC-TVSS), our synchronous variant of
VSS, and we mention how it can be eﬃciently implemented. Sect. 4.1 presents
our notion of security for simultaneous broadcast (denoted UC-SB), and shows
how to implement it from UC-TVSS. We conclude in Sect. 5 by discussing how to
extend our results to the public channel model, and how to model simultaneous
broadcast under purely asynchronous communication.

2 Preliminaries

Model: Our results are in the Universally Composable framework of Canetti as
described in [8]. We brieﬂy and informally outline it here. In the UC framework,
the desired properties of cryptographic protocols are deﬁned in terms of tasks
or functionalities. A functionality is a “trusted third party” that ﬁrst obtains
inputs directly from the parties, performs certain instructions on these inputs,
and provides the parties with the appropriate outputs. A protocol securely implements 
a given cryptographic task, if executing the protocol against a realistic
(i.e. real-life) adversary “emulates” the execution of an ideal process. In the ideal
process, the task is computed by the functionality directly interacting with the
parties against a very limited adversary (called the ideal-adversary). The notion
of “emulation” involves a distinguisher Z which, by providing the parties with
inputs and seeing their outputs, and by interacting with the adversary, attempts
to tell whether it is interacting with a real protocol and the real-life adversary, or
with the functionality and the ideal-adversary. Good emulation means no such
environment is successful. See details and proofs in [8].

In this paper, we consider a network of n parties, P1, . . . , Pn, connected by
perfectly private authenticated channels and a broadcast channel. In the UC

A. Hevia

24
terminology, this translates to working in the (FSMT ,FBC)-hybrid model, where
FSMT is the secure message transmission functionality [8] and FBC is the broadcast 
channel functionality, which does not satisfy any “fairness” property (i.e. it
allows rushing). There is a computationally unbounded adversary that can actively 
corrupt up to t < n/2 parties. We consider adaptive corruptions, where
the decision to corrupt a party is made during the execution of the protocol,
depending on the data gathered so far. Our protocols allow an error probability
negligible in the security parameter k. In terms of notation, we let [n] denote
the set {1, . . . , n} and P[n] denote the set of all parties {P1, . . . , Pn}.

3 Terminating VSS

Motivation: One inconvenience of the deﬁnition of standard VSS schemes (as in
[18] or even the UC variant of [1,8]) for our purposes is that it does not guarantee
the protocol terminates if the dealer is corrupted. Nonetheless, all synchronous
VSS protocols in the literature (e.g. [5,20,33,18,14,1]) seem to satisfy some form
of terminating condition: there is a round in the execution in which all parties
agree that the sharing phase has “time-out” and the secret is ﬁxed. To capture
this property while preserving the possibility that the VSS protocol being used
from higher-level asynchronous protocols, we deﬁne the notion of Terminating
VSS (TVSS).
TVSS protocols are guaranteed to conclude independently of the dealer’s actions.
 We characterize TVSS as a functionality in the UC framework, FT V SS,
which is shown in Fig. 1. Intuitively, FT V SS extends the VSS functionality so
that even if a corrupted dealer D fails to call the functionality, a ﬁxed value is
eventually associated to D. In fact, honest parties can “force” the functionality 
to ﬁx a value for D by sending EndSharing messages. Our formulation of
FT V SS, is inspired on the UC VSS variant of Abe and Fehr [1], which includes
the concept of “spooling” the secret, a syntactic technique that allows the dealer
to announce to the adversary – via a Spool message – that a new functionality is
being called. The adversary is thus able to adaptively corrupt the dealer before
the dealer commits to a value.5 We say a protocol π achieves UC-TVSS if π
UC-realizes functionality FT V SS.
The name Terminating VSS reﬂects that a protocol that UC-realizes FT V SS
concludes (terminates) as long as the adversary delivers all sent messages. The
adversary can still delay or block some messages forever – but nothing more. In
particular, the protocol does not stall even if the corrupted dealer is irresponsive.
This adversarial behavior is a concern in protocols that depend on the termination 
of a VSS subprotocol, even in the authenticated transmission model, as
the parties waiting for a successful completion of the VSS functionality may not

5 A similar technique appears in the formalization of VSS in [8], albeit implicitly in the
way the functionality reacts to the corruption messages from the adversary. Another
purely syntactic choice is allowing the adversary to trigger the end of the sharing
phase – alternative but equivalent formulations are possible (see [21]).

Universally Composable Simultaneous Broadcast

25

(cid:2)

, D, P), where P is a list of

Functionality FT V SS
FT V SS expects its SID to be of the form sid = (sid
parties among which sharing is to be performed. It proceeds as follows.
(1) At ﬁrst activation, initialize s as ⊥.
(2) Upon receiving input (Spool, sid, s) from party D ∈ P, set s ← s and send
(SpoolRcvd, sid, D) to adversary A. (Any subsequent input Spool is ignored.)
(cid:2) and send
(3) Upon receiving input (Share, sid, s
(ShareRcvd, sid, D) to adversary A. (Any subsequent input Share is ignored.)
(4) Upon receiving input (EndSharing, sid) from uncorrupted party P ∈ P,
record (EndSharing, P ) and send (EndSharingRcvd, sid, P ) to adversary A.
(5) Upon receiving message (Corrupt, sid, P ) from the adversary, do: If P = D
then send s to the adversary. Otherwise, delete record (EndSharing, P ), if
exists. In both cases, send (Corrupt, sid) message to P .

(cid:2)) from party D ∈ P, set s ← s

(6) Upon receiving message (DoEndSharing, sid) from the adversary do: If there

is at least one record of the form (EndSharing, sid, P ), and
– D is honest and a message (Share, sid, u) from D has been received, or
– D is corrupted,
then send (Shared, sid) to each party in P and A. (Any subsequent input
Share or message DoEndSharing is ignored.) Otherwise, ignore the message.
from uncorrupted party P , output

(Open, sid)

(7) Upon receiving input

(Opened, sid, s) to P and the adversary A.

Fig. 1. The Terminating VSS (with Spooling) functionality, FT V SS

have access to synchronous communication or any “time-out” mechanism.6 In
this context, termination means that, once honest parties are instructed to start
executing the TVSS protocol, then no matter the actions of the dealer, π concludes 
with some output (possibly empty) if the adversary delivers all messages.
Discussion: One may argue that termination issue seems to disappear if one
considers a synchronous version of the UC model (as done in [30,24]). While
synchronous communication among all parties certainly allows to implements
time-outs (and thus have default sharings if the dealer does not participate), we
believe that “encapsulating” synchronicity inside the primitive that requires it is
useful as higher-level protocols do not need to be aware of it. Concretely, TVSS
not only captures a form of synchronous VSS but also keeps the dependence on
synchronous communication modularized, as any reliance on it is explicitly and
independently handled inside the TVSS functionality. In particular, even though
it is possible to show that any implementation of TVSS requires synchronous
communication (at least twice) among the parties running it,7 a higher-level
protocol ρ using the TVSS functionality can run in an asynchronous way. In
practice, this means that ρ could be implemented in an asynchronous network

6 We remark that, in some applications, the parties “waiting” for the completion of a

VSS subprotocol may not be the same as the ones executing the VSS protocol.
7 This is implied by Claim 4.1 where TVSS is shown to be equivalent to functionality
FSYN , synchronous communication with guaranteed delivery [8].

26

A. Hevia

where only limited synchronicity is available (say only within certain subsets
of the parties, or when synchronous communication can only be provided very
infrequently) as long as the subprotocol that realizes the TVSS functionality has
“enough” access to the synchronization capability. For example, applications in
cluster networks [36] may exploit the advantage of implementing TVSS locally
in each cluster (where synchronization is easier) while the inter-cluster protocol 
ρ can run asynchronously. Even our concrete application of TVSS, building
simultaneous broadcast, where each TVSS involves all the parties, may beneﬁt 
from this modular approach: dealers in diﬀerent TVSS subprotocols could
start the execution at diﬀerent rounds (because of lack of network connectivity,
for example) and still be able to achieve simultaneous broadcast. Furthermore,
the simplicity of our construction for simultaneous broadcast shows that this
approach may also simplify protocol design and security proofs.

3.1 Instantiating TVSS

In this section, we revisit the very eﬃcient VSS protocol presented by Cramer
et al. in [14] in a synchronous model of computation with some negligible error
probability. The scheme is based on the bivariate solution of Feldman [18,5]
and builds on the information checking techniques of Rabin and Ben-Or [33].
The construction is very eﬃcient: the sharing phase takes fourteen rounds and
reconstruction takes two rounds, while the total communication cost is O((k +
log n)n3) bits for an error probability of 2−k+O(log n). This construction πT V SS
is detailed in [14,21].

In [14], Cramer et al. prove their construction information-theoretically secure
against adaptive corruptions under the classical deﬁnition of security [18]. The
next proposition shows that their protocol can be proven a secure Terminating
VSS in the UC hybrid model we consider here if the model includes the synchronous 
communication (with guaranteed delivery) functionality FSYN proposed in
[8]. Due to space constraints, the proof is omitted (see [21]).
Proposition 1. Protocol πT V SS UC-securely realizes functionality FT V SS in
the (FBC ,FSMT , FSYN )-hybrid model for n > 2t.

4 UC Simultaneous Broadcast (UC-SB)

In this section, we generalize the simulation-based deﬁnition of Simultaneous
Broadcast put forward by Chor et al. [12] to the UC framework. We achieve
this by providing a simultaneous broadcast functionality FSB (Fig. 2) which
is a variant of the synchronous communication functionality [8] that provides
“fairness”, in the sense that the adversary is not allowed rushing. We say a
protocol π achieves UC-SB if π UC-securely implements functionality FSB.
Intuitively, the deﬁnition of FSB guarantees independence as the adversary
cannot access any honest party’s input until the broadcast is authorized to proceed,
 when it is “too late”. Notice also that the functionality guarantees output
delivery. In some applications, it may be useful to relax this condition.

Universally Composable Simultaneous Broadcast

27

Functionality FSB
, P), where P is a list of parties
FSB expects its SID to be of the form sid = (sid
(cid:2)
among which broadcast is to be performed. It proceeds as follows.
(1) Upon receiving input (Broadcast, sid, m) from party P ∈ P, record (P, m)
and output (sid, P ) to the adversary. (If P later becomes corrupted then the
record (P, m) is deleted.)
(2) Upon receiving message (Proceed, sid, N) from the adversary, do: If there
exist uncorrupted parties P ∈ P for which no record (P, m) exists then
ignore the message. Else:
1.
Interpret N as the list of messages sent by corrupted parties. That is,
N = {(Si, mi)} where each Si ∈ P is corrupted, and mi is a message.
2. Prepare a vector m = (mi)i∈P of messages sent by all parties in P, both

corrupted and honest.

Send (Broadcast, sid, m) to the adversary.

(3)
(4) Upon receiving input (Receive, sid) from a party P ∈ P, output

(Received, sid, m) to P .

Fig. 2. The simultaneous broadcast functionality, FSB

UC-SB and previous simultaneous broadcast definitions: It is not hard
to see that UC-SB implies the (stand-alone) simulation-based deﬁnition of simultaneous 
broadcast in [12]. This is immediate since UC security implies standalone 
security [8]. Then, by the results of [22], it holds that UC-SB implies all
the other notions of Simultaneous Broadcast [13,19].

4.1 A Generic Construction of UC-SB from UC-TVSS

In this section, we present our main construction. We show how to implement
simultaneous broadcast (UC-SB) using Terminating VSS (UC-TVSS). The construction 
is simple: each party ﬁrst runs the share phase of the TVSS in parallel;
once all sharings have concluded (terminated), each party starts the reconstruction 
phase, gather all other parties’ secrets and output the vector of values. (see
Fig. 3). Moreover, the construction works for any t; the ﬁnal condition of honest
majority comes from instantiating FT V SS with πT V SS (Prop. 1).
Theorem 1. Protocol πSB UC-securely realizes FSB in the FT V SS-hybrid model.

Proof. Let A be a real-life adversary for πSB. Note that A expects to interact
with n parties running πSB with access to n copies of functionality FT V SS. Given
A, the ideal adversary S simulates the execution of protocol πSB for adversary
A by simulating the parties and functionalities as follows. Let P1, . . . , Pn denote
∗ be the session
the simulated parties, ˜P1, . . . , ˜Pn the ideal-world parties. Let sid
identiﬁer under which each (simulated) party is ﬁrst invoked (by the environment
T V SS be the (simulated) n copies of functionality FT V SS,
T V SS, . . . ,F n
Z), and F 1
where F k
T V SS denotes the functionality invoked by Pk with session identiﬁer

28

A. Hevia

Protocol πSB

∗

, Pj , P[n]).

Private Inputs: Each Pi holds xi ∈ X
∗
Public Input: session identiﬁer sid
Private Outputs: a vector yi ∈ (X ∪ {⊥})n for each Pi
Each party Pi ∈ P runs sequentially the following steps:
(1)
(2)
(3)
(4)
(5) Upon receiving (Shared, sidj) from FT V SS, record (Shared, sidj). Repeat this

For each j ∈ P[n], set sidj ← (sid
Send (Spool, sidi, xi) to FT V SS.
Send (Share, sidi, xi) to FT V SS.
For each j ∈ P[n], send (EndSharing, sidj) to FT V SS.
step until there is a record (Shared, sidj) for each j ∈ [n]
For each j ∈ P[n], send (Open, sidj) to FT V SS.
(6)
(7) Upon receiving (Opened, sidj, vj) from FT V SS, record (sidj, yj). Once a
record (sidj, yj) for each j ∈ [n] exists, output vector yi = (yj)j∈[n] and
halt.
Fig. 3. Simultaneous Broadcast protocol in the FT V SS-hybrid model

∗
, Pk, P[n]).8 Adversary S maintains a set N with the corrupted
sidk = (sid
parties and their inputs, initially N ← ∅, and proceeds as follows. If A corrupts
any party Pi before the party has submitted a Share message to F i
T V SS then
S corrupts ideal-world party ˜Pi, obtains its input xi, and pass it to A. If A
i) to F i
(cid:4)
instructs corrupted party Pi to submit (Share, x
T V SS, then S simulates
(cid:4)
the operation, and adds ( ˜Pi, x
i) to N. For all uncorrupted parties Pk, S sets
← ⊥) and simulates Pk’s interaction
(cid:4)
Pk’s input to an arbitrary value (eg. x
with F k
k
T V SS by simulating both, party and functionality. Notice that S can do
such simulation without the real Pk’s input because adversary A’s view of the
interaction between Pk and F k
T V SS during the share phase of TVSS (steps (1)-(6)
of Fig. 1) is independent of Pk’s input. Indeed, consider the event Ek deﬁned as
“F k
T V SS has at least one record (EndSharing, P ) and then it receives a message
DoEndSharing from A”. As long as Pk is corrupted anytime before Ek is true,
S can proceed as before, that is, S obtains xk from corrupting ˜Pk and pass it to
A. Notice, however, that adversary A must corrupt a party Pi before Pi sends
out message Share to F i
T V SS if A wants to change the value submitted by Pi.
At some point in the simulation, A may send a DoEndSharing message to
some TVSS functionality. Then, S partitions the simulated parties in four sets.
These sets are dynamic in the sense that S may move parties from one set to
another depending on the subsequent instructions of A. The corrupted parties
are partitioned into BSh and its complement, where BSh is the set of parties
which have submitted a message Share to FT V SS. (Notice that for all Pi ∈
(cid:4)
BSh, N contains an entry ( ˜Pi, x
i).) Similarly, any honest party Pi is either in
GSh or its complement, where GSh is the set of parties that have submitted
T V SS. Notice that if Pi ∈ GSh, then Pi has sent
a message Shared to its F i
8 Notice that, such functionality may also be invoked (and instantiated) by some other
party Pj on message EndSharing if Pk is not activated by Z.

Universally Composable Simultaneous Broadcast

29

(2)

(3)

(4)

T V SS has one or more EndSharing
T V SS, then S does

T V SS. Then,
T V SS has no EndSharing records, then S does

or is about to send a EndSharing message. Let Bend (resp. Gend) be the set of
corrupted (resp. uncorrupted) parties whose corresponding TVSS functionalities
have at least one record of the form (EndSharing, Pj). Assume A sends a message
DoEndSharing to functionality F k
If Pk (cid:6)∈ Bend∪Gend, that is, F k
(1)
nothing (since those messages are ignored by the TVSS functionality).
If Pk ∈ Gend but Pk (cid:6)∈ GSh, that is, F k
records but Pk has yet to submit a Share request to F k
nothing (since those messages are ignored by the TVSS functionality).
If Pk ∈ Bend ∩ BSh or if Pk ∈ Gend ∩ GSh, then S simulates F k
T V SS’s
execution by having the functionality send messages (Shared, sidk) to all
parties Pi and the adversary A. If Pk ∈ Bend ∩ BSh, then S does the same
but also adds (Pk,⊥) into set N.
If A instructs a corrupted party Pi to send a message Open to some F k
then S honestly simulates the functionality.

T V SS,
We also let J ⊆ (Gend ∩ GSh) ∪ Bend be the set of parties to whose functionality
A has sent a message DoEndSharing. S continues the simulation following the
above rules (possibly moving parties into GSh, BSh, Gend, Bend, and J as new
messages are delivered by A) until J = [n]. Assume this happens when A sends
a message DoEndSharing to F k
T V SS. Before applying rule 3 from above, S sends
∗
(Proceed, sid
, m).
S uses m to set the secret in each simulated (uncorrupted) F i
T V SS to si = mi,
where m = (m1, . . . , mn). Only then S applies rule 3 from above for party Pk.
¿From then on, S honestly simulates the execution of πSB for A.

, N) to ideal functionality FSB, and obtains (Broadcast, sid
∗

(ShareRcvd, sidi, Pi),

We claim that the simulation is perfect. Indeed, observe that adversary A’s
view before set J becomes equal to [n] is independent of the input of the simulated 
parties, as it consists of the corrupted parties’ inputs, and messages
(SpoolRcvd, sidi, Pi),
(EndSharingRcvd, sidi, Pi), and
(Shared, sidj, Pi) for one or more party Pi ∈ (Gend ∩ GSh) ∪ Bend. The crucial
observation is that no uncorrupted party Pk issues an Open message unless Pk has
received Shared messages for all parties. This only happens if DoEndSharing mesT 
V SS, Pj ∈ J, which only
sages have been received by each functionality F j
happens after J is set to [n]. At that point, the ideal adversary S has obtained 
the inputs for all parties, so the adversary’s view from then on is identical 
to the real-world experiment. Notice also that once adversary A sends
T V SS, Pj ∈ J = [n], A cannot
DoEndSharing messages to each functionality F j
issue a Share message for any (corrupted) party Pi. This is because Pi must also
be in J ⊆ (Gend∩GSh)∪Bend which implies Pi is either in Gend∪Bend, and therefore 
functionality F i
T V SS has successfully executed step (6) where (Shared, sidi)
was sent out to all parties; after this step, no new Share orDoEndSharinginput
is accepted by F i
On the Synchronicity of Simultaneous Broadcast and TVSS: We conclude 
this section showing that Simultaneous Broadcast is essentially as strong
as synchronous communication, namely FSYN . One direction is provided by the

T V SS. This concludes the proof.

30

A. Hevia

reduction to UC-TVSS described above, which says that any solution for UCTVSS 
can be used to achieve UC-SB. Notice also that FSYN implies UC-TVSS
by Prop. 1. The other direction holds because UC-SB can be used to implement
FSYN as follows: ﬁrst parties (non-simultaneously) broadcast their values, and
then use simultaneous broadcast to transmit the same values (i.e. those broadcasted 
non-simultaneously before). Thus, the following claim holds.
Claim. Let π be a protocol that UC-securely realizes FSB in the FSMT -hybrid
model. Then, there exists a protocol that UC-securely realizes FSYN in the
(FSB,FSMT )-hybrid model.

5 Extensions

Removing secure channels: Our protocol for simultaneous broadcast is only
secure in the secure channel model. To obtain a protocol secure in the public 
channel model (i.e. authenticated channels), we can use known techniques,
like those proposed by Lysyanskaya [28] which require secure erasures, or noncommitting 
encryption [9,16]. For the case of static corruption is much simpler,
as encrypting the messages with a semantic secure encryption scheme suﬃces.

Functionality FASB

(cid:2)

FSB expects its SID to be of the form sid = (sid
, P, t), where P is a list of parties
among which broadcast may potentially be performed, and t < n is an integer,
where n def= |P|. It proceeds as follows.
(1) Upon receiving input (Broadcast, sid, m) from party P ∈ P, record (P, m)
and output (sid, P ) to the adversary. (If P later becomes corrupted then the
record (P, m) is deleted.)
(2) Upon receiving a message (Proceed, sid, N, W ) from the adversary, do: If W
is a subset of parties in P of size at least n− t, and there exist honest parties
P ∈ W for which no record (P, m) exists then ignore the message. Else:
1.

Interpret N as the list of messages sent by corrupted parties. That is,
N = {(Si, mi)} where Si ∈ W and Si is corrupted, and mi is a message.
2. Prepare a vector m = (mi)i∈W of messages sent by all parties in W ,

both corrupted and honest.

Send (Broadcast, sid, m) to the adversary.

(3)
(4) Upon receiving input

(Receive, sid)

(Received, sid, m) as delayed output to P .

from a party P ∈ P,

send

Fig. 4. The asynchronous simultaneous broadcast functionality, FASB

Asynchronous Simultaneous Broadcast (UC-ASB): It is well known that
in an asynchronous network, no functionality that depends on all the inputs can
be computed [31]. This is because it is impossible to distinguish between failed
processes (those instructed to not send messages) and very slow processes. Therefore,
 no process can aﬀord to wait for messages coming from more than n − t

Universally Composable Simultaneous Broadcast

31

distinct other processes. In this section, we adapt the functionality of Simultaneous 
Broadcast to comply with this restriction, at the cost of weakening the
guarantee that all players can participate in the broadcast (which is unavoid-
able). We remark that, nonetheless, the modiﬁed functionality FASB (Fig. 4)
still preserves the intuitive notion of independence, as long as parties that do
not participate in the broadcast are not allowed to contribute later with their
inputs. We say a protocol π achieves UC-ASB if π UC-securely realizes FASB .
We claim (without proof) that there exists a simple construction that achieves
UC-ASB for the case n > 3t. It suﬃces to run ﬁrst the initial phase of the secure 
multiparty computation of Ben-Or et al. [6]. Spelled out, ﬁrst, parties run
n parallel copies of the ultimate secret sharing protocol; then the protocol for
agreement on a common subset is run. (Both protocols are described in [6].) In
this way, all parties agree on the set W of parties that have properly shared their
input. The reconstruction protocol is executed next, where the secrets of all parties 
in W is reconstructed. For computationally bounded adversaries, a similar
approach can be obtained using the initialization phase of the computationally
eﬃcient construction of [23]. It is an open problem whether more communication
eﬃcient solutions exist.

References

1. M. Abe and S. Fehr. Adaptively secure feldman VSS and applications to
In Advances in Cryptology –

universally-composable threshold cryptography.
CRYPTO, LNCS 3152, pages 317–334. Springer-Verlag, 2004.

2. B. Barak, Y. Lindell, and T. Rabin. Protocol initialization for the framework
of universal composability. Cryptology ePrint Archive, Report 2004/006, 2004.
http://eprint.iacr.org/.

3. M. Ben-Or, R. Canetti, and O. Goldreich. Asynchronous secure computation. In

ACM STOC’93, pages 52–61. ACM Press, 1993.

4. M. Ben-Or and R. El-Yaniv. Resilient-optimal interactive consistency in constant

time. Distributed Computing, 16(4):249–262, 2003.

5. M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness theorems for noncryptographic 
fault-tolerant distributed computations. In ACM STOC’88, pages
1–10. ACM Press, 1988.

6. M. Ben-Or, B. Kelmer, and T. Rabin. Asynchronous secure computations with
optimal resilience (extended abstract). In ACM PODC’94, pages 183–192, 1994.

7. C. Cachin, K. Kursawe, F. Petzold, and V. Shoup. Secure and eﬃcient asynchroIn 
Advances in Cryptology – CRYPTO, LNCS 2139,

nous broadcast protocols.
pages 524–541. Springer-Verlag, 2001.

8. R. Canetti. Universally composable security: A new paradigm for cryptographic
protocols. Report 2000/067, Cryptology ePrint Archive, January 2005. Full version
of that in IEEE Symposium on Foundations of Computer Science (FOCS’01).

9. R. Canetti, U. Feige, O. Goldreich, and M. Naor. Adaptively secure multi-party

computation. In ACM STOC’96. ACM Press, 1996.

10. R. Canetti, Y. Lindell, R. Ostrovsky, and A. Sahai. Universally composable twoparty 
and multi-party secure computation. In ACM STOC’02, 2002.

11. R. Canetti and T. Rabin. Fast asynchronous Byzantine agreement with optimal
resilience (extended abstract). In ACM STOC’93, pages 42–51. ACM Press, 1993.

32

A. Hevia

12. B. Chor, S. Goldwasser, S. Micali, and B. Awerbuch. Veriﬁable secret sharing and
achieving simultaneity in the presence of faults. In IEEE Symposium on Foundations 
of Computer Science (FOCS’85), pages 383–395. IEEE CS, 1985.

13. B. Chor and M. O. Rabin. Achieving independence in logarithmic number of
rounds. In ACM Symposium on Principles of Distributed Computing (PODC’87),
pages 260–268. ACM Press, 1987.

14. R. Cramer, I. Damg˚ard, S. Dziembowski, M. Hirt, and T. Rabin. Eﬃcient multiparty 
computations secure against an adaptive adversary. In Advances in Cryptology 
– EUROCRYPT’99, pages 311–326. Springer-Verlag, 1999.

15. I. Damg˚ard and J. B. Nielsen. Universally composable eﬃcient multiparty computation 
from threshold homomorphic encryption. In Advances in Cryptology –
CRYPTO, LNCS 2729, pages 247–264. Springer-Verlag, 2003.

16. I. Damg˚ard and J.B. Nielsen. Improved non-committing encryption schemes based
on a general complexity assumption. In Advances in Cryptology – CRYPTO, LNCS
1880, pages 432–450. Springer-Verlag, 2000.

17. D. Dolev, C. Dwork, and M. Naor. Nonmalleable cryptography. SIAM Journal on

Computing, 30(2):391–437, April 2001.

18. P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous byzantine 
agreement. SIAM Journal on Computing, 26(4):873–933, 1997.

19. R. Gennaro. A protocol to achieve independence in constant rounds. IEEE Transactions 
on Parallel and Distributed Systems, 11(7):636–647, July 2000.

20. O. Goldreich, S. Micali, and A. Wigderson. Proofs that yield nothing but their
validity or all languages in NP have zero-knowledge proof systems. Journal of the
ACM, 38(3):691–729, July 1991.
http://www.dcc.uchile.cl/∼ahevia/pubs/, 2006. Full version of this paper.

21. A. Hevia. Universally composable simultaneous broadcast. Available from

22. A. Hevia and D. Micciancio. Simultaneous broadcast revisited. In ACM PODC’05,

pages 324–333. ACM Press, 2005.

23. M. Hirt, J. B. Nielsen, and B. Przydatek. Cryptographic asynchronous multiIn 
Advances in
party computation with optimal resilience (extended abstract).
Cryptology - EUROCRYPT’05, LNCS 3494, pages 322–340. Springer-Verlag, 2005.
for multi-party
Available from

24. D. Hofheinz and J. Muller-quade.

computation and the incompleteness of oblivious transfer.
http://eprint.iacr.org/2004/016, 2004.

A synchronous model

25. L. Lamport, R. Shostak, and M. Pease. The Byzantine generals problem. ACM

Transactions on Programming Languages and Systems, 4(3):382–401, July 1982.

26. Y. Lindell, A. Lysyanskaya, and T. Rabin. On the composition of authenticated

byzantine agreement. In ACM STOC’02, pages 514–523. ACM Press, 2002.

27. Y. Lindell, A. Lysyanskaya, and T. Rabin. Sequential composition of protocols

without simultaneous termination. In ACM PODC’02, pages 203–212, 2002.

28. A. Lysyanskaya. Threshold cryptography secure against the adaptive adversary,

concurrently. Report 2000/019, Cryptology ePrint Archive, 2000.

29. S. Micali and T. Rabin. Collective coin tossing without assumptions nor broadcasting.
 In Advances in Cryptology – CRYPTO, LNCS 537, pages 253–266, 1990.
30. J. B. Nielsen. On Protocol Security in the Cryptographic Model. Ph.D. thesis,

Aarhus University, 2003.

31. M. Pease, R. Shostak, and L. Lamport. Reaching agreements in the presence of

faults. Journal of the ACM, 27(2):228–234, April 1980.

32. B. Pﬁtzmann and M. Waidner. A model for asynchronous reactive systems and its
application to secure message transmission. In IEEE Symposium on Security and
Privacy (S&P-01), pages 184–201. IEEE CS, 2001.

Universally Composable Simultaneous Broadcast

33

33. T. Rabin and M. Ben-Or. Veriﬁable secret sharing and multiparty protocols with

honest majority. In ACM STOC’89, pages 73–85. ACM Press, 1989.

34. A. De Santis and G. Persiano. Zero-knowledge proofs of knowledge without interaction 
(extended abstract). In IEEE Symposium on Foundations of Computer
Science (FOCS’92), pages 427–436. IEEE CS, 1992.

35. A. Shamir. How to share a secret. Communications of the ACM, 22(11), 1979.
36. L. von Ahn, A. Bortz, and N.J. Hopper. k-Anonymous message transmission.
In ACM Conference on Computer and Communication Security – CCS’03, pages
122–130. ACM Press, 2003.

