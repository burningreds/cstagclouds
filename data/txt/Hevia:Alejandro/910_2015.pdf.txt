QA-NIZK Arguments in Asymmetric Groups: New Tools and

New Constructions

Alonso Gonz´alez1(cid:63), Alejandro Hevia1, and Carla R`afols2(cid:63)(cid:63)

1 Departamento de Ciencias de la Computaci´on, Universidad de Chile, Chile

2 Horst G¨ortz Institut f¨ur IT Sicherheit, Ruhr-Universit¨at Bochum, Germany

alonso.gon@gmail.com,ahevia@dcc.uchile.cl

carla.rafols@rub.de

Abstract. A sequence of recent works have constructed constant-size quasi-adaptive (QA) NIZK arguments 
of membership in linear subspaces of ˆGm, where ˆG is a group equipped with a bilinear map
e : ˆG × ˇH → T. Although applicable to any bilinear group, these techniques are less useful in the
asymmetric case. For example, Jutla and Roy (Crypto 2014) show how to do QA aggregation of GrothSahai 
proofs, but the types of equations which can be aggregated are more restricted in the asymmetric
setting. Furthermore, there are natural statements which cannot be expressed as membership in linear
subspaces, for example the satisﬁability of quadratic equations.
In this paper we develop speciﬁc techniques for asymmetric groups. We introduce a new computational
assumption, under which we can recover all the aggregation results of Groth-Sahai proofs known in the
symmetric setting. We adapt the arguments of membership in linear spaces of ˆGm to linear subspaces
of ˆGm× ˇHn. In particular, we give a constant-size argument that two sets of Groth-Sahai commitments,
deﬁned over diﬀerent groups ˆG, ˇH, open to the same scalars in Zq, a useful tool to prove satisﬁability
of quadratic equations in Zq. We then use one of the arguments for subspaces in ˆGm × ˇHn and develop
new techniques to give constant-size QA-NIZK proofs that a commitment opens to a bit-string. To
the best of our knowledge, these are the ﬁrst constant-size proofs for quadratic equations in Zq under
standard and falsiﬁable assumptions. As a result, we obtain improved threshold Groth-Sahai proofs
for pairing product equations, ring signatures, proofs of membership in a list, and various types of
signature schemes.

1 Introduction

Ideally, a NIZK proof system should be both expressive and eﬃcient, meaning that it should allow
to prove statements which are general enough to be useful in practice using a small amount of
resources. Furthermore, it should be constructed under mild security assumptions. As it is usually
the case for most cryptographic primitives, there is a trade oﬀ between these three design goals.
For instance, there exist constant-size proofs for any language in NP (e.g. [15]) but based on very
strong and controversial assumptions, namely knowledge-of-exponent type of assumptions (which
are non-falsiﬁable, according to Naor’s classiﬁcation [31]) or the random oracle model.

The Groth-Sahai proof system (GS proofs) [19] is an outstanding example of how these three
goals (expressivity, eﬃciency, and mild assumptions) can be combined successfully. It provides a
proof system for satisﬁability of quadratic equations over bilinear groups. This language suﬃces to
capture almost all of the statements which appear in practice when designing public-key cryptographic 
schemes over bilinear groups. Although GS proofs are quite eﬃcient, proving satisﬁability
of m equations in n variables requires sending some commitments of size Θ(n) and some proofs of

(cid:63) Funded by CONICYT, CONICYT-PCHA/Doctorado Nacional/2013-21130937.
(cid:63)(cid:63) Part of this work was done while visiting Centro de Modelamiento Matem´atico, U. Chile. Gratefully acknowledges

the support of CONICYT via Basal in Applied Mathematics.

size Θ(m) and they easily get expensive unless the statement is very simple. For this reason, several
recent works have focused on further improving proof eﬃciency (e.g. [10,11,32])

Among those, a recent line of work [22,23,25,27] has succeeded in constructing constant-size
arguments for very speciﬁc statements, namely, for membership in subspaces of ˆGm, where ˆG is
some group equipped with a bilinear map where the discrete logarithm is hard. The soundness of
the schemes is based on standard, falsiﬁable assumptions and the proof size is independent of both
m and the witness size. These improvements are in a quasi-adaptive model (QA-NIZK, [22]). This
means that the common reference string of these proof systems is specialized to the linear space
where one wants to prove membership.

Interestingly, Jutla and Roy [23] also showed that their techniques to construct constant-size
NIZK in linear spaces can be used to aggregate the GS proofs of m equations in n variables, that is,
the total proof size can be reduced to Θ(n). Aggregation is also quasi-adaptive, which means that
the common reference string depends on the set of equations one wants to aggregate. Further, it
is only possible if the equations meet some restrictions. The ﬁrst one is that only linear equations
can be aggregated. The second one is that, in asymmetric bilinear groups, the equations must be
one-sided linear, i.e. linear equations which have variables in only one of the Zq modules ˆG, ˇH, or
Zq.3

Thus, it is worth to investigate if we can develop new techniques to aggregate other types of
equations, for example, quadratic equations in Zq and also recover all the aggregation results of [23]
(in particular, for two-sided linear equations) in asymmetric bilinear groups. The latter (Type III
bilinear groups, according to the classiﬁcation of [14]) are the most attractive from the perspective
of a performance and security trade oﬀ, specially since the recent attacks on discrete logarithms in
ﬁnite ﬁelds by Joux [21] and subsequent improvements. Considerable research eﬀort (e.g. [2,13]) has
been put into translating pairing-based cryptosystems from a setting with more structure in which
design is simpler (e.g. composite-order or symmetric bilinear groups) to a more eﬃcient setting (e.g.
prime order or asymmetric bilinear groups). In this line, we aim not only at obtaining new results
in the asymmetric setting but also to translate known results and develop new tools speciﬁcally
designed for it which might be of independent interest.

1.1 Our Results

In Sect. 3, we give constructions of constant-size QA-NIZK arguments of membership in linear
spaces of ˆGm × ˇHn. Denote the elements of ˆG (respectively of ˇH) with a hat (resp. with an inverted
hat), as ˆx ∈ ˆG (respectively, as ˇy ∈ ˇH). Given ˆM ∈ ˆGm×t and ˇN ∈ ˇHn×t, we construct QA-NIZK
arguments of membership in the language

L ˆM, ˇN := {(ˆx, ˇy) ∈ ˆGm × ˇHn : ∃w ∈ Zt
(cid:18) ˆM
(cid:19)

which is the subspace of ˆGm × ˇHn spanned by

q, ˆx = ˆMw, ˇy := ˇNw},

. This construction is based on the recent

ˇN

constructions of [25]. When m = n, we construct QA-NIZK arguments of membership in

L ˆM, ˇN,+ := {(ˆx, ˇy) ∈ ˆGm × ˇHm : ∃w ∈ Zt

q, x + y = (M + N)w},

3 Jutla and Roy show how to aggregate two-sided linear equations in symmetric bilinear groups. The asymmetric
case is not discussed, yet for one-sided linear equations it can be easily derived from their results. This is not the
case for two-sided ones, see Sect. 4.

2

which is the linear subspace of ˆGm × ˇHm of vectors (ˆx, ˇy) such that the sum of their discrete
logarithms is in the image of M + N (the sum of discrete logarithms of ˆM and ˇN).
From the argument for L ˆM, ˇN, we easily derive another constant-size QA-NIZK argument in the

space

(cid:110)

Lcom, ˆU, ˇV,ν :=

(ˆc, ˇd) ∈ ˆGm × ˇHn : ∃(w, r, s), ˆc = ˆU

, ˇd = ˇV

(cid:18)w

(cid:19)

r

(cid:18)w

(cid:19)(cid:111)

,

s

where ˆU ∈ ˆGm× ˜m, ˇV ∈ ˇHn×˜n and w ∈ Zν
q . Membership in this space captures the fact that
two commitments (or sets of commitments) in ˆG, ˇH open to the same vector w ∈ Zν
q . This is
signiﬁcant for the eﬃciency of quadratic GS proofs in asymmetric groups since, because of the
way the proofs are constructed, one can only prove satisﬁability of equations of degree one in
each variable. Therefore, to prove a quadratic statement one needs to add auxiliary variables with
commitments in the other group. For instance, to prove that ˆc opens to b ∈ {0, 1}, one proves that
some commitment ˇd opens to b such that {b(b− 1) = 0, b− b = 0}. Our result allows us to aggregate
the n proofs of the second statement.

To construct these arguments we introduce a new assumption, the Split Kernel Matrix DiﬃeHellman 
Assumption (SKerMDH). This assumption is derived from the recently introduced Kernel
Matrix Diﬃe-Hellman Assumption (KerMDH, [30]), which says that it is hard to ﬁnd a vector in
the co-kernel of ˆA ∈ ˆG(cid:96)×k when A is such that it is hard to decide membership in Im( ˆA) (i.e.
when A is an instance of a Matrix DH Assumption [11]). Our SKerMDH Assumption says that one
cannot ﬁnd a solution to the KerMDH problem which is “split” between the groups ˆG and ˇH. We
think this assumption can be useful in other protocols in asymmetric bilinear groups. A particular
case of Kernel MDH Assumption is the Simultaneous Double Pairing Assumption (SDP, [3]), which
is a well established assumption in symmetric bilinear maps, and its “split” variant is the SSDP
Assumption (see Sect. 2.1).

In Sect. 4 we use the SKerMDH Assumption to lift the known aggregation results in symmetric
groups to asymmetric ones. More speciﬁcally, we show how to extend the results of [23] to aggregate
proofs of two-sided linear equations in asymmetric groups. While the original aggregation results of
[23] were based on decisional assumptions, our proof shows that they are implied by computational
assumptions.

Next, in Sect. 5, we address the problem of aggregating the proof of quadratic equations in Zq.
For concreteness, we study the problem of proving that a commitment in ˆG opens to a bit-string
of length n. Such a construction was unknown even in symmetric bilinear groups (yet, it can be
easily generalized to this setting, see Appendix C). More speciﬁcally, we prove membership in

L ˆU,bits := {ˆc ∈ ˆGn+m : ˆc := ˆU1b + ˆU2w, (b, w) ∈ {0, 1}n × Zm
q },

where ( ˆU1, ˆU2) ∈ ˆG(n+m)×n × ˆG(n+m)×m are matrices which deﬁne a perfectly binding and computationally 
hiding commitment to b. Speciﬁcally, we give instantiations for m = 1 (when ˆc is a
single commitment to b), and m = n (when ˆc is the concatenation of n Groth-Sahai commitments
to a bit).

proving linear statements about the bit-string, for instance, that (cid:80)

We stress that although our proof is constant-size, we need the commitment to be perfectly
binding, thus the size of the commitment is linear in n. The common reference string which we
need for this construction is quadratic in the size of the bit-string. Our proof is compatible with
i∈[n] bi = t by adding a linear
number (in n) of elements to the CRS (see Sect. 5.5). We observe that in the special case where

3

t = 1 the common reference string can be linear in n. The costs of our constructions and the cost
of GS proofs are summarized in Table 1.

We stress that our results rely solely on falsiﬁable assumptions. More speciﬁcally, in the asymmetric 
case we need some assumptions which are weaker than the Symmetric External DH Assumption 
plus the SSDP Assumption. Interestingly, our construction in the symmetric setting relies on
assumptions which are all weaker than the 2-Lin Assumption (see Appendix C).

We think that our techniques for constructing QA-NIZK arguments for bit-strings might be of

independent interest. In the asymmetric case, we combine our QA-NIZK argument for L ˆM, ˇN,+ with
decisional assumptions in ˆG and ˇH. We do this with the purpose of using QA-NIZK arguments even
when M + N has full rank. In this case, strictly speaking “proving membership in the space” looses
all meaning, as every vector in ˆGm × ˇHm is in the space. However, using decisional assumptions,
we can argue that the generating matrix of the space is indistinguishable from a lower rank matrix
which spans a subspace in which it is meaningful to prove membership.

Finally, in Sect. 6 we discuss some applications of our results. In particular, our results provide
shorter signature size of several schemes, more eﬃcient ring signatures, more eﬃcient proofs of
membership in a list, and improved threshold GS proofs for pairing product equations.

Comms

Proof

CK

CRS(ρ)

#Pairings

2n(g + h)
4(g + h)
2n(g + h) (2n + 2)(g + h) 4(g + h)

4n(g + h)

(n + 1)g

10(g + h)

0

28n

20n + 8
(n + 1)g (6n2 + 11n + 34)(g + h) n + 55

(10n + 4)(g + h)

GS [18]
GS + ΨDk,com
Πbit m = 1

Πbit m = n (i)

Πbit m = n (ii)

2ng

2ng

10(g + h)

10(g + h)

4g

4g

Πbit weight 1, m = 1 (n + 1)g

10(g + h)

(n + 1)g

Πbit weight 1, m = n

2ng

10(g + h)

4g

(12n2 + 14n + 22)g+
(12n2 + 13n + 24)h
(6n2 + 16n + 32)g+
(6n2 + 12n + 32)h

(18n + 32)g+
(19n + 34)h
(20n + 32)g+
(18n + 32)h

2n + 52

4n + 52

n + 55

4n + 52

Table 1. Comparison for proofs of bi ∈ {0, 1}, for i ∈ [n], between GS proofs and our diﬀerent constructions. Our
NIZK construction for bit-strings is denoted by Πbit and the construction for proving that two sets of commitments
open to the same value ΨDk,com. Row “Πbit m = 1” is for our construction for a single commitment of size n + 1 to
a bit-string of size n. Rows “Πbit m = n (i)” and “Πbit m = n (ii)” are for our construction for n concatenated GS
commitments, using the two diﬀerent CRS distributions described in Sect. 5.5. Rows “Πbit weight 1, m = 1” and “Πbit
weight 1, m = n” are for our constructions for bit-strings of weight 1 with m = 1 and m = n, respectively. Column
“Comms” contains the size of the commitments, “CK” the size of the commitment keys in the CRS, and “CRS(ρ)”
the size of the language dependent part of the CRS. The size of elements in ˆG and ˇH is g and h, respectively. The
table is computed for Dk = L2, the 2-Linear matrix distribution.

2 Preliminaries

Let Gena be some probabilistic polynomial time algorithm which on input 1λ, where λ is the security
parameter, returns the description of an asymmetric bilinear group (q, ˆG, ˇH, T, e, ˆg, ˇh), where ˆG, ˇH
and T are groups of prime order q, the elements ˆg, ˇh are generators of ˆG, ˇH respectively, and
e : ˆG × ˇH → T is an eﬃciently computable, non-degenerate bilinear map.

4

We denote by g and h the bit-size of the elements of ˆG and ˇH, respectively. Elements ˆx ∈ ˆG (resp.
ˇy ∈ ˇH, zT ∈ T) are written with a hat (resp, with inverted hat, sub-index T) and ˆ0, ˇ0 and 0T denote
the neutral elements. Given ˆx ∈ ˆG, ˇy ∈ ˇH, ˆxˇy refers to the pairing operation, i.e. ˆxˇy = e(ˆx, ˇy).
Vectors and matrices are denoted in boldface and any product of vectors/matrices of elements in
ˆG and ˇH is deﬁned in the natural way via the pairing operation. That is, given ˆX ∈ ˆGn×m and
ˇY ∈ ˇHm×(cid:96), ˆX ˇY ∈ Tn×(cid:96). The product ˇX ˆY ∈ Tn×(cid:96) is deﬁned similarly by switching the arguments
of the pairing. Given a matrix T = (ti,j) ∈ Zm×n
, ˆT (resp. ˇT) is the natural embedding of T in
ˆG (resp. in ˇH), that is, the matrix whose (i, j)th entry is ti,j ˆg (resp. ti,jˇh). Conversely, given ˆT or
ˇT, we use T ∈ Zn×m
for the matrix of discrete logarithms of ˆT (resp. ˇT). We denote by In×n the
identity matrix in Zn×n
q (simply ei if n is clear
from the context). We make extensive use of the set [n + k] × [n + k] \ {(i, i) : i ∈ [n]} and for
brevity we denote it by In,k.

i the ith element of the canonical basis of Zn

and en

q

q

q

2.1 Computational Assumptions
Deﬁnition 1. Let (cid:96), k ∈ N with (cid:96) > k. We call D(cid:96),k a matrix distribution if it outputs (in poly time,
. We deﬁne Dk := Dk+1,k and Dk the distribution
with overwhelming probability) matrices in Z(cid:96)×k
of the ﬁrst k rows when A ← Dk.
Deﬁnition 2 (Matrix Diﬃe-Hellman Assumption [11]). Let D(cid:96),k be a matrix distribution and
Γ := (q, ˆG, ˇH, T, e, ˆg, ˇh) ← Gena(1λ). We say that the D(cid:96),k-Matrix Diﬃe-Hellman (D(cid:96),k-MDDH ˆG)
Assumption holds relative to Gena if for all PPT adversaries D,

q

(cid:12)(cid:12)(cid:12)Pr[D(Γ, ˆA, ˆAw) = 1] − Pr[D(Γ, ˆA, ˆu) = 1]

(cid:12)(cid:12)(cid:12) = negl(λ),

AdvD(cid:96),k,Gena(D) :=

where the probability is taken over Γ ← Gena(1λ), A ← D(cid:96),k, w ← Zk
of adversary D.

q , ˆu ← ˆG(cid:96) and the coin tosses

The D(cid:96),k-MDDH ˇH problem is deﬁned similarly. In this paper we will refer to the following matrix

(cid:17)

(cid:16) B

C

, U(cid:96),k : A =

(cid:32) a1,1 ... a1,k

(cid:33)

.
.
.

.

. .

a(cid:96),1 ... a(cid:96),k

.
.
.

,

distributions:

Lk : A =

 a1 0 ... 0

0 a2 ... 0
.
.
.
.
.
.
0 0 ... ak
1 1 ... 1

.
.
.

.

.

.

 ,L(cid:96),k : A =

q

.

where ai, ai,j ← Zq, for each i, j ∈ [k], B ← Lk, C ← Z(cid:96)−k,k
The Lk-MDDH Assumption is the k-linear family of Decisional Assumptions [20,33]. The L1MDDHX 
, X ∈ { ˆG, ˇH}, is the Decisional Diﬃe-Hellman (DDH) Assumption in X, and the assumption 
that it holds in both groups is the Symmetric External DH Assumption (SXDH). The
L(cid:96),k-MDDH Assumption is used in our construction to commit to multiple elements simultaneously.
It can be shown tightly equivalent to the Lk-MDDH Assumption. The U(cid:96),k Assumption is the Uniform 
Assumption and is weaker than the Lk-MDDH. Additionally, we will be using the following
family of computational assumptions:
Deﬁnition 3 (Kernel Diﬃe-Hellman Assumption [30]). Let Γ ← Gena(1λ). The Kernel
Diﬃe-Hellman Assumption in ˇH (D(cid:96),k-KerMDH ˇH) says that every PPT Algorithm has negligible
advantage in the following game: given ˇA, where A ← D(cid:96),k, ﬁnd ˆx ∈ ˆG(cid:96)\{ˆ0}, such that ˆx(cid:62) ˇA = 0T.

5

The Simultaneous Pairing Assumption in ˇH (SP ˇH) is the U1-KerMDH ˇH Assumption and the Simultaneous 
Double Pairing Assumption (SDP ˇH) is the L2,3KerMDH 
ˇH Assumption. The Kernel
Diﬃe-Hellman assumption is a generalization and abstraction of these two assumptions to other
matrix distributions. The D(cid:96),k-KerMDH ˇH Assumption is weaker than the D(cid:96),k-MDDH ˇH Assumption,
since a solution allows to decide membership in Im( ˇA).

For our construction, we need to introduce a new family of computational assumptions.

Deﬁnition 4 (Split Kernel Diﬃe-Hellman Assumption). Let Γ←Gena(1λ). The Split Kernel
Diﬃe-Hellman Assumption in ˆG, ˇH (D(cid:96),k-SKerMDH) says that every PPT Algorithm has negligible
advantage in the following game: given ( ˆA, ˇA), A ← D(cid:96),k, ﬁnd a pair of vectors (ˆr, ˇs) ∈ ˆG(cid:96) × ˇH(cid:96),
r (cid:54)= s, such that ˆr(cid:62) ˇA = ˇs(cid:62) ˆA.

As a particular case we consider the Split Simultaneous Double Pairing Assumption in ˆG, ˇH
(SSDP) which is the L2-SKerMDH Assumption. Intuitively, the Kernel Diﬃe-Hellman Assumption
says one cannot ﬁnd a non-zero vector in ˆG(cid:96) which is in the co-kernel of ˇA, while the new assumption
says one cannot ﬁnd a pair of vectors in ˆG(cid:96) × ˇH(cid:96) such that the diﬀerence of the vector of their
discrete logarithms is in the co-kernel of ˇA. The name “split” comes from the idea that the output
of a successful adversary would break the Kernel Diﬃe-Hellman Assumption, but this instance is
“split” between the groups ˆG and ˇH. When k = 1, the D(cid:96),k-SKerMDH Assumption does not hold.
The assumption is generically as least as hard as the standard,“non-split” assumption in symmetric
bilinear groups. This means, in particular, that in Type III bilinear groups, one can use the SSDP
Assumption with the same security guarantees as the SDP Assumption, which is a well established
assumption (used for instance in [29]).
Lemma 1. If D(cid:96),k-KerMDH holds in generic symmetric bilinear groups, then D(cid:96),k-SKerMDH holds
in generic asymmetric bilinear groups.
Suppose there is a generic algorithm which breaks the D(cid:96),k-SKerMDH Assumption. Intuitively,
given two diﬀerent encodings of A ← D(cid:96),k, ( ˆA, ˇA), this algorithm ﬁnds ˆr and ˇs, r (cid:54)= s such that
ˆr(cid:62) ˇA = ˇs(cid:62) ˆA. But since the algorithm is generic, it also works when ˆG = ˇH, and then ˆr − ˆs is a
solution to D(cid:96),k-KerMDH. For a formal proof, see Appendix F.

2.2 Groth-Sahai NIZK Proofs

The GS proof system allows to prove satisﬁability of a set of quadratic equations in a bilinear
group. The admissible equation types must be in the following form:

my(cid:88)

mx(cid:88)

mx(cid:88)

my(cid:88)

f (αj, yj) +

f (xi, βi) +

f (xi, γi,jyj) = t,

(1)

j=1

i=1

i=1

j=1

2 , Γ = (γi,j) ∈ Zmx×my

where A1, A2, AT are Zq-vector spaces equipped with some bilinear map f : A1 × A2 → AT , α ∈
1 , β ∈ Amx
, t ∈ AT . The modules and the map f can be deﬁned in diﬀerent
Amy
ways as: (a) in pairing-product equations (PPEs), A1 = ˆG, A2 = ˇH, AT = T, f (ˆx, ˇy) = ˆxˇy ∈ T, in
which case t = 0T, (b1) in multi-scalar multiplication equations in ˆG (MMEs), A1 = ˆG, A2 = Zq,
AT = ˆG, f (ˆx, y) = yˆx ∈ ˆG, (b2) MMEs in ˇH (MMEs), A1 = Zq, A2 = ˇH, AT = ˇH, f (x, ˇy) = xˇy ∈ ˇH,
and (c) in quadratic equations in Zq (QEs), A1 = A2 = AT = Zq, f (x, y) = xy ∈ Zq. An equation
is linear if Γ = 0, it is two-sided linear if both α (cid:54)= 0 and β (cid:54)= 0, and one-sided otherwise.

q

6

We brieﬂy recall some facts about GS proofs in the SXDH instantiation used in the rest of the
paper. Let Γ ← Gena(1λ), u2, v2 ← L1, u1 := e1 + µu2, v1 := e1 + v2, µ,  ← Zq. The common
reference string is crsGS := (Γ, ˆu1, ˆu2, ˇv1, ˇv2) and is known as the perfectly sound CRS. There is
also a perfectly witness-indistinguishable CRS, with the only diﬀerence being that u1 := µu2 and
v1 := v2 and the simulation trapdoor is (µ, ). These two CRS distributions are computationally
indistinguishable. Implicitly, crsGS deﬁnes the maps:

ι1 : ˆG ∪ Zq → ˆG2,
ι2 : ˇH ∪ Zq → ˇH2,

ι1(ˆx) := (ˆx, ˆ0)(cid:62),
ι2(ˇy) := (ˇy, ˇ0)(cid:62),

ι1(x) := xˆu1.
ι2(y) := yˇv1.

The maps ιX , X ∈ {1, 2} can be naturally extended to vectors of arbitrary length δ ∈ Am
write ιX (δ) for (ιX (δ1)|| . . .||ιX (δm)).
The perfectly sound CRS deﬁnes perfectly binding commitments for any variable in A1 or A2.
Speciﬁcally, the commitment to x ∈ A1 is ˆc := ι1(x) + r1(ˆu1 − ˆe1) + r2 ˆu2 ∈ ˆG2, and to y ∈ A2 is
ˇd := ι2(y) + s1(ˇv1 − ˇe1) + s2 ˇv2, where r1, r2, s1, s2 ← Zq, except if A1 = Zq (resp. A2 = Zq) in
which case r1 = 0 (resp. s1 = 0).

X and we

2.3 Quasi-Adaptive NIZK Arguments

We recall the deﬁnition of Quasi Adaptive NIZK (QA-NIZK) Arguments of Jutla et al. [22]. A
QA-NIZK proof system enables to prove membership in a language deﬁned by a relation Rρ, which
in turn is completely determined by some parameter ρ sampled from a distribution DΓ . We say
that DΓ is witness samplable if there exist an eﬃcient algorithm that samples (ρ, ω) such that ρ is
distributed according to DΓ , and membership of ρ in the parameter language Lpar can be eﬃciently
veriﬁed with ω. While the Common Reference String can be set based on ρ, the zero-knowledge
simulator is required to be a single probabilistic polynomial time algorithm that works for the whole
collection of relations RΓ .
A tuple of algorithms (K0, K1, P, V) is called a QA-NIZK proof system for witness-relations
RΓ = {Rρ}ρ∈sup(DΓ ) with parameters sampled from a distribution DΓ over associated parameter
language Lpar, if there exists a probabilistic polynomial time simulator (S1, S2), such that for all
non-uniform PPT adversaries A1, A2, A3 we have:

Quasi-Adaptive Completeness:

π ← P(ψ, x, w) : V(ψ, x, π) = 1 if Rρ(x, w)

(cid:20)Γ ← K0(1λ); ρ ← DΓ ; ψ ← K1(Γ, ρ); (x, w) ← A1(Γ, ψ);
(cid:21)
(cid:21)
(cid:20)Γ ← K0(1λ); ρ ← DΓ ; ψ ← K1(Γ, ρ);

(x, π) ← A2(Γ, ψ) : V(ψ, x, π) = 1 and ¬(∃w : Rρ(x, w))

Pr

Pr

= 1.

≈ 0.

Computational Quasi-Adaptive Soundness:

Perfect Quasi-Adaptive Zero-Knowledge:

Pr[Γ ← K0(1λ); ρ ← DΓ ; ψ ← K1(Γ, ρ) : AP(ψ,·,·)
Pr[Γ ← K0(1λ); ρ ← DΓ ; (ψ, τ ) ← S1(Γ, ρ) : AS(ψ,τ,·,·)

3

3

(Γ, ψ) = 1] =

(Γ, ψ) = 1]

where

7

– P(ψ,·,·) emulates the actual prover. It takes input (x, w) and outputs a proof π if (x, w) ∈
– S(ψ, τ,·,·) is an oracle that takes input (x, w). It outputs a simulated proof S2(ψ, τ, x) if

Rρ. Otherwise, it outputs ⊥.
(x, w) ∈ Rρ and ⊥ if (x, w) /∈ Rρ.

Note that ψ is the CRS in the above deﬁnitions. We assume that ψ contains an encoding of ρ,
which is thus available to V.

We will sometimes need that our arguments satisfy a stronger notion of soundness. This notion
is only meaningful for witness samplable distributions and it requires soundness to hold even when
the adversary receives a witness that ρ is in the parameter language.

Computational Quasi-Adaptive Strong Soundness:

(cid:20)Γ ← K0(1λ); (ρ, ω) ← Dpar

Γ ; ψ ← K1(Γ, ρ);

Pr

(x, π) ← A2(Γ, ω, ψ) : V(ψ, x, π) = 1 and ¬(∃w : Rρ(x, w))

(cid:21)

≈ 0.

2.4 QA-NIZK Argument for Linear Spaces

In this section we recall the two constructions of QA-NIZK arguments of membership in linear
spaces given by Kiltz and Wee [25], for the language:

L ˆM := {ˆx ∈ ˆGn : ∃w ∈ Zt

q, ˆx = ˆMw}.

Algorithm K0(1λ) just outputs Γ := (q, ˆG, ˇH, T, e, ˆg, ˇh) ← Gena(1λ), the rest of the algorithms are
described in Fig. 1.

(S1(Γ, ˆM, n))

K1(Γ, ˆM, n)

A ← (cid:102)Dk, ∆ ← Z˜k×n

q

ˇA∆ := ∆(cid:62) ˇA, ˆM∆ := ∆ ˆM
Return crs := ( ˆM∆, ˇA∆, ˇA)
(τsim := ∆)

P(crs, ˆx, w) \\ˆx = ˆMw
Return ˆσ := ˆM∆w.

S2(crs, ˆx, τsim)
Return ˆσ := ∆ˆx

V(crs, ˆx, ˆσ)
Return (ˆx(cid:62) ˇA∆ = ˆσ(cid:62) ˇA)

when (cid:102)Dk = Dk and ˜k = k. Both are QA-NIZK
Fig. 1. The ﬁgure describes ΨDk when (cid:102)Dk = Dk and ˜k = k +1 and ΨDk
arguments for L ˆM. ΨDk is the construction of [25, Sect. 3.1], which is a generalization of Libert et al ’s QA-NIZK [27]
to any Dk-KerMDHˇH Assumption. ΨDk

is the construction of [25, Sect. 3.2.].

Theorem 1 (Theorem 1 of [25]). If (cid:102)Dk = Dk and ˜k = k + 1, Fig. 1 describes a QA-NIZK proof
Theorem 2 (Theorem 2 of [25]). If (cid:102)Dk = Dk and ˜k = k, and DΓ is a witness samplable distrisystem 
with perfect completeness, computational adaptive soundness based on the Dk-KerMDH ˇH
Assumption, perfect zero-knowledge, and proof size k + 1.

bution, Fig. 1 describes a QA-NIZK proof system with perfect completeness, computational adaptive
soundness based on the Dk-KerMDH ˇH Assumption, perfect zero-knowledge, and proof size k.

8

3 New QA-NIZK Arguments in Asymmetric Groups

In this section we construct three QA-NIZK arguments of membership in diﬀerent subspaces of
ˆGm × ˇHn. Their soundness relies on the Split Kernel Assumption.

3.1 Argument of Membership in Subspace Concatenation

Figure 2 describes a QA-NIZK Argument of Membership in the language

L ˆM, ˇN := {(ˆx, ˇy) : ∃w ∈ Zt

q, ˆx = ˆMw, ˇy = ˇNw} ⊆ ˆGm × ˇHn.

We refer to this as the Concatenation Language, because if we deﬁne P as the concatenation of
ˆM, ˇN, that is P :=

, then (ˆx, ˇy) ∈ L ˆM, ˇN iﬀ(cid:0) ˆx

ˇy

(cid:1) is in the span of P.

(cid:17)

(cid:16) ˆM

ˇN

K1(Γ, ˆM, ˇN, m, n)

(S1(Γ, ˆM, ˇN, m, n))

A ← (cid:102)Dk

q

q

q

, Z ← Z˜k×t

, Ξ ← Z˜k×n

Λ ← Z˜k×m
ˇAΛ := Λ(cid:62) ˇA
ˆAΞ := Ξ(cid:62) ˆA
ˆMΛ := Λ ˆM + ˆZ
ˇNΞ := Ξ ˇN − ˇZ
Return crs := ( ˆMΛ, ˇAΛ, ˇA, ˇNΞ ,
ˆAΞ , ˆA).
(τsim := (Λ, Ξ).)

P(crs, ˆx, ˇy, w)
\\(ˆx = ˆMw, ˇy = ˇNw)
z ← Z˜k
ˆρ := ˆMΛw + ˆz
ˇσ := ˇNΞ w − ˇz
Return ( ˆρ, ˇσ).

q

q

S2(crs, (ˆx, ˇy), τsim)
z ← Z˜k
ˆρ := Λˆx + ˆz
ˇσ := Ξˇy − ˇz
Return ( ˆρ, ˇσ).

V(crs, (ˆx, ˇy), ( ˆρ, ˇσ))
Return (ˆx(cid:62) ˇAΛ − ˆρ(cid:62) ˇA
= ˇσ(cid:62) ˆA − ˇy(cid:62) ˆAΞ ).

Fig. 2. Two QA-NIZK Arguments for L ˆM, ˇN. ΨDk,spl is deﬁned for (cid:102)Dk = Dk and ˜k = k + 1, and is a generalization of
[25] Sect. 3.1 in two groups. The second construction ΨDk,spl corresponds to (cid:102)Dk = Dk and ˜k = k, and is a generalization

of [25] Sect. 3.2 in two groups. Computational soundness is based on the Dk-SKerMDH Assumption. The CRS size is
(˜kk + ˜kt+mk)g+(˜kk + ˜kt+nk)h and the proof size ˜k(g+h). Veriﬁcation requires 2˜kk +(m+n)k pairing computations.

q

q

1.

, Ξ ∈ Z˜k×n

Soundness Intuition. If we ignore for a moment that ˆG, ˇH are diﬀerent groups, ΨDk,spl (resp. ΨDk,spl)
) for the language L ˆP, and ∆ := (Λ||Ξ), where Λ ∈
is almost identical to ΨDk (resp. to ΨDk
Z˜k×m
(cid:19)(cid:111)
(cid:110)
about ∆ is:
(cid:18)Λ(cid:62)A
(cid:110)

. Further, the information that an unbounded adversary can extract from the CRS

P∆ = ΛM + ΞN, A∆ = ∆(cid:62)A =
MΛ = ΛM + Z, NΞ = ΞN − Z,

(cid:18)Λ(cid:62)A
(cid:19)
(cid:18)AΛ

Ξ(cid:62)A
Given that the matrix Z is uniformly random, crsΨDk
and crsΨDk ,spl reveal the same information
about ∆ to an unbounded adversary. Therefore, as the proof of soundness is essentially based on
the fact that parts of ∆ are information theoretically hidden to the adversary, the original proof of
[25] can be easily adapted for the new arguments. The proofs can be found in Appendix A.

from crsΨDk ,spl.

from crsΨDk

(cid:19)(cid:111)

Ξ(cid:62)A

AΞ

2.

=

,

9

Theorem 3. If (cid:102)Dk = Dk and ˜k = k + 1, Fig. 2 describes a QA-NIZK proof system with perTheorem 
4. If (cid:102)Dk = Dk and ˜k = k, and DΓ is a witness samplable distribution, Fig. 2 describes

fect completeness, computational adaptive soundness based on the Dk-SKerMDH Assumption, and
perfect zero-knowledge.

a QA-NIZK proof system with perfect completeness, computational adaptive strong soundness based
on the Dk-SKerMDH Assumption, and perfect zero-knowledge.

3.2 Argument of Sum in Subspace

We can adapt the previous construction to the Sum in Subspace Language,

L ˆM, ˇN,+ := {(ˆx, ˇy) ∈ ˆGm × ˇHm : ∃w ∈ Zt

q, x + y = (M + N)w}.

We deﬁne two proof systems ΨDk,+, ΨDk,+ as in Fig. 2, but now with Λ = Ξ. Intuitively, soundness
follows from the same argument because the information about Λ in the CRS is now Λ(cid:62)A, Λ(M +
N).

3.3 Argument of Equal Opening in Diﬀerent Groups

Given the results for Subspace Concatenation of Sect. 3.1, it is direct to construct constant-size
NIZK Arguments of membership in:

(cid:18)w

(cid:19)

r

(cid:18)w

(cid:19)(cid:111)

,

, ˇd = ˇV

s

(cid:110)

Lcom, ˆU, ˇV,ν :=

(ˆc, ˇd) ∈ ˆGm × ˇHn : ∃(w, r, s), ˆc = ˆU

q . The witness is (w, r, s) ∈ Zν

where ˆU ∈ ˆGm× ˜m, ˇV ∈ ˇHn×˜n and w ∈ Zν
. This
language is interesting because it can express the fact that (ˆc, ˇd) are commitments to the same
vector w ∈ Zν
The construction is an immediate consequence of the observation that Lcom, ˆU, ˇV,ν can be rewritten 
as some concatenation language L ˆM, ˇN. Denote by ˆU1 the ﬁrst ν columns of ˆU and ˆU2 the
remaining ones, and ˇV1 the ﬁrst ν columns of ˇV and ˇV2 the remaining ones. If we deﬁne:

q in diﬀerent groups.

q × Z ˜m−ν

q

× Z˜n−ν

q

ˆM := ( ˆU1|| ˆU2||ˆ0m×(˜n−ν))

ˇN := ( ˇV1||ˇ0n×( ˜m−ν)|| ˇV2).

then it is immediate to verify that Lcom, ˆU, ˇV,ν = L ˆM, ˇN.
In the rest of the paper, we denote as ΨDk,com the proof system for Lcom, ˆU, ˇV,ν which corresponds
to ΨDk,spl for L ˆM, ˇN, where ˆM, ˇN are the matrices deﬁned above. Note that for commitment schemes
we can generally assume ˆU, ˇV to be drawn from some witness samplable distribution. Therefore,
it follows from Theorem 4 that ΨDk,com satisﬁes the notion of strong soundness.

4 Aggregating Groth-Sahai Proofs in Asymmetric Groups

In this section we discuss two diﬀerent ways to aggregate GS equations. The ﬁrst is a direct
application of the proof of equal commitment opening and is only valid for two-sided linear equations
in Zq, the second is an extension of the results of Jutla and Roy for all other types of linear equations.

10

4.1 Aggregating Two-Sided Linear Equations in Zq

We note that proving that n pairs of GS commitments open (pairwise) to the same elements in
Zq is simply a special case of the proof of equal commmitment opening in Sect. 3.3. Indeed, the
concatenation of n GS commitments is just a commitment to a vector of scalars. In particular,
given crsGS = (Γ, ˆu1, ˆu2, ˇv1, ˇv2), it is easy to see that n commitments to xi ∈ Zq, which are of the
form: ˆci = xi ˆu1 + ri ˆu2 for some ri ∈ Zq (recall that ι1(xi) = xi ˆu1), can be written as

 =

ˆc1

...
ˆcn

ˆu1 . . . ˆ0

...
...
ˆ0 . . . ˆu1

. . .



x1

...
xn

 +

ˆu2 . . . ˆ0

...
...
ˆ0 . . . ˆu2

. . .



r1

...
rn

 ,

and similarly the concatenation of n commitments ˇdi, i ∈ [(cid:96)] can be written as ˇV1y + ˇV2s, where
ˆVi is the blockwise concatenation of n copies of ˇvi.
In particular, proving that n GS commitments open to the same value can be also seen as the
aggregation of the proof of n GS equations of the form x(cid:96) − y(cid:96) = 0. The aggregation of any other
set of two-sided linear equations in Zq easily reduces to this case using the homomorphic properties
of GS commitments. Indeed, given n equations of the form:

(cid:96) y + x(cid:62)β(cid:96) = t(cid:96), (cid:96) ∈ [n],
α(cid:62)

and the commitments to a satisfying assignment (where the commitments to every coordinate of x
(resp. y) are in ˆG (resp. ˇH), it is easy to derive a commitment to x(cid:62)β(cid:96) − t(cid:96) in ˆG and a commitment
(cid:96) y in ˇH for all (cid:96) ∈ [n]. Obviously, the equations are satisﬁed if for each (cid:96), these commitments
to α(cid:62)
open to the same value.
We insist that two-sided linear equations in Zq are essential to prove quadratic statements in
asymmetric bilinear groups. In particular, this result can be used to reduce the proof size that n
commitments open to a bit-string from 6n(g + h) to (4n + 2)(g + h).

4.2 QA Aggregation of Other Equation Types

Jutla and Roy [23] show how to aggregate GS proofs of two-sided linear equations in symmetric
bilinear groups. In the original construction of [23] soundness is based on a decisional assumption
(a weaker variant of the 2-Lin Assumption). Its natural generalization in asymmetric groups (where
soundness is based on the SXDH Assumption) only enables to aggregate the proofs of one-sided
linear equations.

In this section, we revisit their construction. We give an alternative, simpler, proof of soundness
under a computational assumption which avoids altogether the “Switching Lemma” of [23]. Further,
we extend it to two-sided equations in the asymmetric setting. For one-sided linear equations we
can prove soundness under any kernel assumption and for two-sided linear equations, under any
split kernel assumption.4
Let A1, A2, AT be Zq-vector spaces compatible with some Groth-Sahai equation as detailed in
Sect. 2.2. Let DΓ be a witness samplable distribution which outputs n pairs of vectors (α(cid:96), β(cid:96)) ∈

4 The results of [23] are based on what they call the “Switching Lemma”. As noted in [30], it is implicit in the proof

of this lemma that the same results can be obtained under computational assumptions.

11

2 , (cid:96) ∈ [n], for some mx, my ∈ N. Given some ﬁxed pairs (α(cid:96), β(cid:96)), we deﬁne, for each

1 × Amx
Amy
˜t ∈ An

T , the set of equations S˜t as:

S˜t =(cid:8)E(cid:96)(x, y) = ˜t(cid:96) : (cid:96) ∈ [n](cid:9) ,

(cid:88)

j∈[my]

(cid:88)

i∈[mx]

E(cid:96)(x, y) :=

f (α(cid:96),j, yj) +

f (xi, β(cid:96),i).

We note that, as in [23], we only achieve quasi-adaptive aggregation, that is, the common reference 
string is speciﬁc to a particular set of equations. More speciﬁcally, it depends on the constants
α(cid:96), β(cid:96) (but not on ˜t(cid:96), which can be chosen by the prover) and it can be used to aggregate the proofs
of S˜t, for any ˜t.
Given the equation types for which we can construct NIZK GS proofs, there always exists (1)
t(cid:96) ∈ A1, such that ˜t(cid:96) = f (t(cid:96), base2) or (2) ˜t(cid:96) ∈ A2, such that ˜t(cid:96) = f (base1, t(cid:96)), where basei = 1
if Ai = Zq, base1 = ˆg if A1 = ˆG and base2 = ˇh if A2 = ˇH. This is because ˜t(cid:96) = 0T for PPEs,
and AT = Ai, for some i ∈ [2], for other types of equations. For simplicity, in the construction we
assume that (1) is the case, otherwise change ι2(a(cid:96),i), ι1(t(cid:96)) for ι1(a(cid:96),i), ι2(t(cid:96)) in the construction
below.
K0(1λ): Return Γ := (q, ˆG, ˇH, T, e, ˆg, ˇh) ← Gena(1λ).
DΓ : DΓ is some distribution over n pairs of vectors (α(cid:96), β(cid:96)) ∈ Amx
K1(Γ,S˜t): Let A = (ai,j) ← Dn,k. Deﬁne

1 × Amy
2 .

crsGS,

(cid:88)

(cid:96)∈[n]

crs :=

ι1(a(cid:96),iα(cid:96)),

(cid:88)

(cid:96)∈[n]



ι2(a(cid:96),iβ(cid:96)),(cid:8)ι2(a(cid:96),i) : (cid:96) ∈ [n](cid:9) : i ∈ [k]
(cid:96)∈[n] a(cid:96),iE(cid:96)(x, y) =(cid:80)

P(Γ,S˜t, x, y): Given a solution x = x, y = y to S˜t, the prover proceeds as follows:

– For each i ∈ [k], run the GS prover for the equation(cid:80)

– Commit to all xj ∈ A1 as ˆcj ← CommGS(xj), and to all yj ∈ A2 as ˇdj ← CommGS(yj).

(cid:96)∈[n] f (t(cid:96), a(cid:96),i) to

obtain the proof, which is a pair ( ˆΘi, ˇΠi).

Output ({ˆcj : j ∈ [mx]},{ˇdj : j ∈ [my]},{( ˇΠi, ˆΘi) : i ∈ [k]}).

V(crs,S˜t,{ˆcj}j∈[mx],{ˇdj}j∈[my],{ ˆΘi, ˇΠi}i∈[k]): For each i ∈ [k], run the GS veriﬁer for equation

(cid:88)

(cid:96)∈[n]

(cid:88)

(cid:96)∈[n]

a(cid:96),iE(cid:96)(x, y) =

f (t(cid:96), a(cid:96),i).

Theorem 5. The above protocol is a QA-NIZK proof system for two-sided linear equations.

Proof. Completeness. Observe that

(cid:88)

(cid:96)∈[n]

a(cid:96),iE(cid:96)(x, y) =

(cid:88)

j∈[my]

f (a(cid:96),iα(cid:96),j, yj) +

(cid:88)

j∈[mx]

f (xj, a(cid:96),iβ(cid:96),j).

(2)

Completeness follows from the observation that to eﬃciently compute the proof, the GS Prover
[19] only needs, apart from a satisfying assignment to the equation, the randomness used in the
commitments plus a way to compute the inclusion map of all involved constants, in this case
ι1(a(cid:96),iα(cid:96),j), ι2(a(cid:96),iβ(cid:96),j) and the latter is part of the CRS.
Soundness. We change to a game Game1 where we know the discrete logarithm of the GS commitment 
key, as well as the discrete logarithms of (α(cid:96), β(cid:96)), (cid:96) ∈ [n]. This is possible because they are
both chosen from a witness samplable distribution.

12

We now prove that an adversary against the soundness in Game1 can be used to construct an
adversary B against the Dn,k-SKerMDH Assumption, where Dn,k is the matrix distribution used in
the CRS generation.
B receives a challenge ( ˆA, ˇA) ∈ ˆGn×k × ˇHn×k. Given all the discrete logarithms that B knows,
it can compute a properly distributed CRS even without knowledge of the discrete logarithm
of ˆA. The soundness adversary outputs commitments {ˆcj}j∈[mx],{ˇdj}j∈[my] together with proofs
{ ˆΘi, ˇΠi}i∈[k], which are accepted by the veriﬁer.
Let x (resp. ˆx) be the vector of openings of {ˆcj}j∈[mx] in A1 (resp. in the group ˆG) and y
(resp. ˇy) the vector of openings of {ˇdj}j∈[my] in A2 (resp. in the group ˇH). If A1 = ˆG (resp.
A2 = ˇH) then x = ˆx (resp. y = ˇy). The vectors ˆx and ˇy are eﬃciently computable by B who
knows the discrete logarithm of the commitment keys. We claim that the pair ( ˆρ, ˇσ) ∈ ˆGn × ˇHn,
ˆρ := (β(cid:62)
First, observe that if the adversary is successful in breaking the soundness property, then ρ (cid:54)= σ.
Indeed, if this is the case there is some index (cid:96) ∈ [n] such that E(cid:96)(x, y) (cid:54)= ˜t(cid:96), which means that
j∈[mx] f (xj, β(cid:96),j)− f (t(cid:96), base2). If we take discrete logarithms in each side of
the equation, this inequality is exactly equivalent to ρ (cid:54)= σ.

(cid:80)
j∈[my] f (α(cid:96),j, yj) (cid:54)=(cid:80)
Further, because GS proofs have perfect soundness, x and y satisfy the equation(cid:80)
(cid:80)
(cid:17)
(cid:96)∈[n] f (t(cid:96), a(cid:96),i), for all i ∈ [k], Thus, for all i ∈ [k],

n ˇy), solves the Dn,k-SKerMDH challenge.

n ˆx − ˆtn), ˇσ := (α(cid:62)

1 ˆx − ˆt1, . . . , β(cid:62)

1 ˇy, . . . , α(cid:62)

(cid:16)

(cid:17)

(cid:16)

(cid:88)

=

ˆa(cid:96),i

α(cid:62)
(cid:96) ˇy

,

ˇa(cid:96),i

(cid:96) ˆx − ˆt(cid:96)
β(cid:62)

(cid:96)∈[n]

(cid:88)

(cid:96)∈[n]

(cid:96)∈[n] a(cid:96),iE(cid:96)(x, y) =

(3)

which implies that ˆρ ˇA = ˇσ ˆA.
Zero-Knowledge. The same simulator of GS proofs can be used. Speciﬁcally the simulated proof
corresponds to k simulated GS proofs.
One-Sided Equations. In the case when α(cid:96) = 0 and ˜t(cid:96) = f (t(cid:96), base2) for some t(cid:96) ∈ A1, for all
(cid:96) ∈ [n], proofs can be aggregated under a standard Kernel Assumption (and thus, in asymmetric
bilinear groups we can choose k = 1). Indeed, in this case, in the soundness proof, the adversary
B receives ˇA ∈ ˇHn×k, an instance of the Dn,k − KerMDH ˇH problem. The adversary B outputs
n ˆx − ˆtn) as a solution to the challenge. To see why this works, note that,
ˆρ := (β(cid:62)

when α(cid:96) = 0 for all (cid:96) ∈ [n], equation (3) reads(cid:80)

(cid:1) = 0T and thus ˆρ ˇA = 0T. The

1 ˆx − ˆt1, . . . , β(cid:62)

(cid:0)β(cid:62)

case when β(cid:96) = 0 and ˜t(cid:96) = f (base1, t(cid:96)) for some t(cid:96) ∈ A2, for all (cid:96) ∈ [n], is analogous.

(cid:96) ˆx − ˆt(cid:96)

(cid:96)∈[n] ˇa(cid:96),i

Public Parameters. The size of the CRS of the construction above depends on the number of
elements needed to represent ˆA. In this sense, it is interesting to sample ˆA from some family of
matrix assumptions with good representation size. As we assume that n > k, it is interesting to
instantiate this scheme with the Circulant Matrix Distribution of [30], which has a representation
size of n — independent of k.

5 QA-NIZK Arguments for Bit-Strings

We construct a constant-size QA-NIZK for proving that a perfectly binding commitment opens to
a bit-string. That is, we prove membership in the language:

q },
L ˆU,bits := {ˆc ∈ ˆGn+m : ˆc := ˆU1b + ˆU2w, (b, w) ∈ {0, 1}n × Zm

13

where ˆU := ( ˆU1, ˆU2) ∈ ˆG(n+m)×n× ˆG(n+m)×m deﬁnes perfectly binding and computationally hiding
commitment keys. The witness for membership is (b, w) and ˆU ← DΓ , where DΓ is some witness
samplable distribution.
To prove that a commitment in ˆG opens to a vector of bits b, the usual strategy is to compute
another commitment ˇd ∈ ˇH¯n to a vector ¯b ∈ Zn
q and prove (1) bi(bi − 1) = 0, for all i ∈ [n],
and (2) bi − bi = 0, for all i ∈ [n]. For statement (2), since ˆU is witness samplable, we can use
our most eﬃcient QA-NIZK from Sect. 3.3 for equal opening in diﬀerent groups. Under the SSDP
Assumption, which is the SKerMDH Assumption of minimal size conjectured to hold in asymmetric
groups, the proof is of size 2(g + h). Thus, the challenge is to aggregate n equations of the form
bi(bi−1) = 0. We note that this is a particular case of the problem of aggregating proofs of quadratic
equations, which was left open in [23].

We ﬁnally remark that the proof must include ˇd and thus it may be not of size independent of

n. However, it turns out that ˇd needs not be perfectly binding, in fact ¯n = 2 suﬃces.

Intuition

5.1
A prover wanting to show satisﬁability of the equation x(y − 1) = 0 using GS proofs, will commit
to a solution x = b and y = b as ˆc = bˆu1 + rˆu2 and ˇd = bˇv1 + sˇv2, for r, s ← Zq, and then give a
pair ( ˆθ, ˇπ) ∈ ˆG2 × ˇH2 which satisﬁes the following veriﬁcation equation5:

(4)
The reason why this works is that, if we express both sides of the equation in the basis of T2×2
given by {ˆu1 ˇv(cid:62)
1 is b(b− 1) on the left side and 0 on the
right side (regardless of ( ˆθ, ˇπ)). Our observation is that the veriﬁcation equation can be abstracted
as saying:

2 }, the coeﬃcient of ˆu1 ˇv(cid:62)

2 , ˆu2 ˇv(cid:62)

1 , ˆu2 ˇv(cid:62)

1 , ˆu1 ˇv(cid:62)

= ˆu2 ˇπ(cid:62) + ˆθˇv(cid:62)
2 .

ˆc(cid:0)ˇd − ˇv1

(cid:1)(cid:62)

(cid:1)(cid:62) ∈ Span(ˆu2 ˇv(cid:62)

1 , ˆu1 ˇv(cid:62)

2 , ˆu2 ˇv(cid:62)

2 ) ⊂ T2×2.

ˆc(cid:0)ˇd − ˇv1
i∈[n] biˆgi + rˆgn+1, ˇd := (cid:80)
ˇd(cid:62) − (cid:88)

ˆc

j∈[n]

as ˆc := (cid:80)

Now consider commitments to (b1, . . . , bn) and (b1, . . . , bn) constructed with some commitment
key {(ˆgi, ˇhi) : i ∈ [n + 1]} ⊂ ˆGn × ˇHn, for some n ∈ N, to be determined later, and deﬁned
i∈[n] bi ˇhi + sˇhn+1, r, s ← Zq. Suppose for a moment that
{ˆgi ˇh(cid:62)

j : i, j ∈ [n + 1]} is a set of linearly independent vectors. Then,

 ∈ Span{ˆgi ˇh(cid:62)

ˇh(cid:62)

j

j : (i, j) ∈ In,1}

(5)

(6)

if and only if bi(bi − 1) = 0 for all i ∈ [n], because bi(bi − 1) is the coordinate of ˆgi ˇh(cid:62)
side of the equation.
Equation 6 suggests to use one of the constant-size QA-NIZK Arguments for linear spaces to
get a constant-size proof that bi(bi − 1) = 0 for all i ∈ [n]. Unfortunately, these arguments are
only deﬁned for membership in subspaces in ˆGm or ˇHm but not in Tm. Our solution is to include
information in the CRS to “bring back” this statement from T to ˆG, i.e. the matrices ˆCi,j := ˆgih(cid:62)
j ,
for each (i, j) ∈ In,1. Then, to prove that bi(bi − 1) = 0 for all i ∈ [n], the prover computes ˆΘb(b−1)
5 For readers familiar with the Groth-Sahai notation, equation (4) corresponds to c • (d − ι2(1)) = u2 • π + θ • v2.

in the left

i

14

as a linear combination of C := { ˆCi,j : (i, j) ∈ In,1} (with coeﬃcients which depend on b, b, r, s)
such that

ˇhj

= ˆΘb(b−1)

ˇIn×n,

(7)

ˇd − (cid:88)

ˆc

j∈[n]

(cid:62)

and gives a QA-NIZK proof of ˆΘb(b−1) ∈ Span(C).

This reasoning assumes that {ˆgih(cid:62)

j } (or equivalently, { ˆCi,j}) are linearly independent, which can
only happen if n ≥ n + 1. If that is the case, the proof cannot be constant because ˆΘb(¯b−1) ∈ ˆGn×n
and this matrix is part of the proof. Instead, we choose ˆg1, . . . , ˆgn+1 ∈ ˆG2 and ˇh1, . . . , ˇhn+1 ∈ ˇH2,
so that { ˆCi,j} ⊆ ˆG2×2. Intuitively, this should still work because the prover receives these vectors
as part of the CRS and he does not know their discrete logarithms, so to him, they behave as
linearly independent vectors.

With this change, the statement ˆΘb(b−1) ∈ Span(C) seems no longer meaningful, as Span(C) is
all of ˆG2×2 with overwhelming probability. But this is not the case, because by means of decisional
assumptions in ˆG2 and in ˇH2, we switch to a game where the matrices ˆCi,j span a non-trivial
space of ˆG2×2. Speciﬁcally, to a game where ˆCi∗,i∗ /∈ Span(C) and i∗ ← [n] remains hidden to the
adversary. Once we are in such a game, perfect soundness is guaranteed for equation bi∗(¯bi∗ − 1) = 0
and a cheating adversary is caught with probability at least 1/n. We think this technique might be
of independent interest.
The last obstacle is that, using decisional assumptions on the set of vectors {ˇhj}j∈[n+1] is
incompatible with using the discrete logarithms of ˇhj to compute the matrices ˆCi,j := ˆgih(cid:62)
j given
in the CRS. To account for the fact that, in some games, we only know gi ∈ Zq and, in some others,
only hj ∈ Zq, we replace each matrix ˆCi,j by a pair ( ˆCi,j, ˇDi,j) which is uniformly distributed
conditioned on Ci,j + Di,j = gih(cid:62)
j . This randomization completely hides the group in which we can
compute gih(cid:62)
j . Finally, we use our QA-NIZK Argument for sum in a subspace (Sect. 3.2) to prove
membership in this space.

5.2

Instantiations

We discuss in detail two particular cases of languages L ˆU,bits. First, in Sect. 5.3 we discuss the case

when
(a) ˆc is a vector in ˆGn+1, ˆun+1 ← Ln+1,1 and ˆU1 :=

∈ ˆG(n+1)×n, ˆU2 := ˆun+1 ∈ ˆGn+1,

(cid:18)ˆIn×n

(cid:19)

ˆ01×n

 ∈ ˆG2n×n, ˆU2 :=

ˆu2 . . . ˆ0

...
...
ˆ0 . . . ˆu2

. . .

 ∈ ˆG2n×n.

15

In this case, the vectors ˆgi in the intuition are deﬁned as ˆgi = ∆ˆui, where ∆ ← Z2×(n+1)

q

, and the
i∈[n] bi ˆui + wˆun+1. Then in Sect. 5.5 we discuss how to

(b) ˆc is the concatenation of n GS commitments. That is, given the GS CRS crsGS = (Γ, ˆu1, ˆu2, ˇv1, ˇv2),

ˆU = ( ˆU1|| ˆU2).

generalize the construction for a) to

commitment to b is computed as ˆc :=(cid:80)
ˆu1 . . . ˆ0

we deﬁne,

ˆU1 :=

. . .

...
...
ˆ0 . . . ˆu1

Although the proof size is constant, in both of our instantiations the commitment size is Θ(n).

Speciﬁcally, (n + 1)g for case a) and 2ng for case b).

iﬀ ˆc = ˆU(cid:0)b

5.3 The Scheme
K0(1λ): Return Γ := (q, ˆG, ˇH, T, e, ˆg, ˇh) ← Gena(1λ).
DΓ : The distribution DΓ over ˆG(n+1)×(n+1) is some witness samplable distribution which deﬁnes
the relation RΓ = {R ˆU} ⊆ ˆGn+1 × ({0, 1}n × Zq), where ˆU ← DΓ , such that (ˆc,(cid:104)b, w(cid:105)) ∈ R ˆU
:= ihn+1, where i ← Zq. Deﬁne ˇH :=
, deﬁne ˆG := ∆ ˆU and ˆgi := ∆ˆui ∈ ˆG2, for all i ∈ [n+1].
and set:

(ˇh1|| . . .||ˇhn+1). Choose ∆ ← Z2×(n+1)
Let a ← L1 and deﬁne ˇa∆ := ∆(cid:62)ˇa ∈ ˇHn+1. For any pair (i, j) ∈ In,1, let Ti,j ← Z2×2

(cid:1). The relation Rpar consists of pairs ( ˆU, U) where ˆU ← DΓ .

q and for all i ∈ [n], hi

K1(Γ, ˆU): Let hn+1 ← Z2

w

q

q

ˆCi,j := ˆgih(cid:62)

j − ˆTi,j ∈ ˆG2×2,

ˇDi,j := ˇTi,j ∈ ˇH2×2.

Note that ˆCi,j can be eﬃciently computed as hj ∈ Z2
q is the vector of discrete logarithms of ˇhj.
Let ΨDk,+ be the proof system for Sum in Subspace (Sect. 3.2) and ΨDk,com be an instance of
our proof system for Equal Opening (Sect. 3.3).
← K1(Γ, ˆG, ˇH, n). The common
Let crsΨDk ,+
reference string is given by:

← K1(Γ,{ ˆCi,j, ˇDi,j}(i,j)∈In,1) and 6 crsΨDk ,com

crsP :=

ˇa, ˇa∆, crsΨDk ,+
P(crsP , ˆc,(cid:104)b, wg(cid:105)): Pick wh ← Zq, R ← Z2×2

crsV :=

1. Deﬁne

(cid:17)

,

(cid:16) ˆU, ˆG, ˇH,{ ˆCi,j, ˇDi,j}(i,j)∈In,1, crsΨDk ,+
(cid:16)
(cid:18) b

(cid:18) b

, crsΨDk ,com

and then:

(cid:19)

(cid:17)

.

q

ˆc∆ := ˆG

,

wg

ˇd := ˇH

wh

, crsΨDk ,com

(cid:19)

.

2. Compute ( ˆΘb(b−1), ˇΠb(b−1)) :=

(cid:17)

(8)

(cid:16)
(cid:88)
(cid:88)

i∈[n]

+

(cid:88)

i∈[n]

j∈[n]
j(cid:54)=i

biwh( ˆCi,n+1, ˇDi,n+1) + wg(bi − 1)( ˆCn+1,i, ˇDn+1,i)

bi(bj − 1)( ˆCi,j, ˇDi,j)

+wgwh( ˆCn+1,n+1, ˇDn+1,n+1) + ( ˆR,− ˇR).

3. Compute a proof ( ˆρb(b−1), ˇσb(b−1)) that Θb(b−1) + ˇΠb(b−1) belongs to the space spanned by
{Ci,j + Di,j}(i,j)∈In,1, and a proof ( ˆρb−b, ˇσb−b) that (ˆc∆, ˇd) open to the same value, using
b, wg, and wh.

V(crsV , ˆc,(cid:104)ˆc∆, ˇd, ( ˆΘb(b−1), ˇΠb(b−1)),{( ˆρX , ˇσX )}X∈{b(b−1),b−b}(cid:105)):

1. Check if ˆc(cid:62)ˇa∆ = ˆc(cid:62)

∆ˇa.

6 We identify matrices in ˆG2×2 (resp. in ˇH2×2) with vectors in ˆG4 (resp. in ˇH4).

16

2. Check if

ˇd − (cid:88)

j∈[n]

(cid:62)

ˇhj

ˆc∆

= ˆΘb(b−1)

ˇI2×2 + ˆI2×2 ˇΠb(b−1).

(9)

3. Verify that ( ˆρb(b−1), ˇσb(b−1)), ( ˆρb−b, ˇσb−b) are valid proofs for ( ˆΘb(b−1), ˇΠb(b−1)) and (ˆc∆, ˇd)

using crsΨDk ,+

and crsΨDk ,com

respectively.

If any of these checks fails, the veriﬁer outputs 0, else it outputs 1.
S1(Γ, ˆU): The simulator receives as input a description of an asymmetric bilinear group Γ and a
matrix ˆU ∈ ˆG(n+1)×(n+1) sampled according to distribution DΓ . It generates and outputs the
CRS in the same way as K1, but additionally it also outputs the simulation trapdoor

(cid:16)

(cid:17)

τ =

H, ∆, τΨDk ,+

, τΨDk ,com

,

where τΨDk ,+

and τΨDk ,com

S2(crsP , ˆc, τ ): Compute ˆc∆ := ∆ˆc. Then pick random wh ← Zq, R ← Z2×2

q

are, respectively, ΨDk,+’s and ΨDk,com’s simulation trapdoors.

and deﬁne d :=

whhn+1. Then set:

ˆΘb(b−1) := ˆc∆

d −(cid:88)

hi

i∈[n]

(cid:62)

+ ˆR,

ˇΠb(b−1) := − ˇR.

Finally, simulate proofs ( ˆρX , ˇσX ) for X ∈ {b(b − 1), b − b} using τΨDk ,+

and τΨDk ,com

.

5.4 Proof of Security

Completeness is proven in Appendix B.1. The following theorem guarantees Soundness.

Theorem 6. Let AdvPS(A) be the advantage of an adversary A against the soundness of the proof
system described above. There exist PPT adversaries B1, B2, B3, P∗

2 such that

(cid:16)

AdvPS(A) ≤ n

6/q + AdvU1, ˆG(B1) + AdvU1, ˇH(B2) + AdvSPˇH(B3)

+ AdvΨDk ,+

(P∗

1) + AdvΨDk ,com

(P∗
2)

1, P∗
(cid:17)

.

The proof follows from the indistinguishability of the following games:

Real This is the real soundness game. The output is 1 if the adversary breaks the soundness, i.e. the

adversary submits some ˆc = ˆU(cid:0) b

wg

(cid:1), for some b /∈ {0, 1}n and w ∈ Zq, and the corresponding

proof which is accepted by the veriﬁer.
samples ( ˆU, U) ∈ Rpar itself according to DΓ .
to check if the output of the adversary A is such that bi∗ ∈ {0, 1}. It aborts if bi∗ ∈ {0, 1}.

Game0 This game is identical to Real except that algorithm K1 does not receive ˆU as a input but it
Game1 This game is identical to Game0 except that the simulator picks a random i∗ ∈ [n], and uses U
Game2 This game is identical to Game1 except that now the vectors ˆgi, i ∈ [n] and i (cid:54)= i∗, are uniform

vectors in the space spanned by ˆgn+1.

17

Game3 This game is identical to Game2 except that now the vector ˇhi∗ is a uniform vector in ˇH2,

sampled independently of ˇhn+1.

Pr [Game0(A) = 1] .

Let ˆE := (ˆs||ˆt). B picks i∗ ← [n], W0 ← Z2×(i∗−1)

It is obvious that the ﬁrst two games are indistinguishable. The rest of the argument goes as follows
(the remaining proofs are in Appendix B.2).
Lemma 2. Pr [Game1(A) = 1] ≥ 1
n
Lemma 3. There exists a U1-MDDH ˆG adversary B such that | Pr [Game1(A) = 1] − Pr [Game2(A) = 1]|
≤ AdvU1, ˆG(B) + 2/q.
Proof. The adversary B receives (ˆs, ˆt) an instance of the U1-MDDH ˆG problem. B deﬁnes all the
parameters honestly except that it embeds the U1-MDDH ˆG challenge in the matrix ˆG.
, ˆgi∗ ← ˆG2, and deﬁnes
ˆG := ( ˆEW0||ˆgi∗|| ˆEW1||ˆs). In the real algorithm K1, the generator picks the matrix ∆ ∈ Z2×(n+1)
.
Although B does not know ∆, it can compute ˆ∆ as ˆ∆ = ˆGU−1, given that U is full rank and was
sampled by B, so it can compute the rest of the elements of the common reference string using the
discrete logarithms of ˆU, ˇH and ˇa.
In case ˆt is uniform over ˆG2, by the Schwartz-Zippel lemma det( ˆE) = 0 with probability at
most 2/q. Thus, with probability at least 1 − 2/q, the matrix ˆE is full-rank and ˆG is uniform over
ˆG2×(n+1) as in Game1. On the other hand, in case ˆt = γˆs, all of ˆgi, i (cid:54)= i∗, are in the space spanned
by ˆgn+1 as in Game2.
Lemma 4. There exists a U1-MDDH ˇH adversary B such that | Pr [Game2(A) = 1] − Pr [Game3(A) = 1]|
≤ AdvU1, ˇH(B).
Lemma 5. There exists a SP ˇH adversary B, a soundness adversary P∗
soundness adversary P∗

, W1 ← Z2×(n−i∗)

1 for ΨDk,+ and a strong

q

q

q

2 for ΨDk,com such that

Pr [Game3(A) = 1] ≤ 4/q + AdvSPˇH(B) + AdvΨDk ,+

(P∗

1) + AdvΨDk ,com

(P∗
2).

j

Proof. Pr[det((gi∗||gn+1)) = 0] = Pr[det((hi∗||hn+1)) = 0] ≤ 2/q, by the Schwartz-Zippel lemma.
i∗ is linearly independent from {gih(cid:62)
Then, with probability at least 1 − 4/q, gi∗h(cid:62)
: (i, j) ∈
[n + 1]2 \ {(i∗, i∗)}} which implies that gi∗h(cid:62)
i∗ /∈ Span({Ci,j + Di,j : (i, j) ∈ In,1}). Additionally 
Game3(A) = 1 implies that bi∗ /∈ {0, 1} while the veriﬁer accepts the proof produced by A,
which is (ˆc∆, ˇd, ( ˆΘb(b−1), ˇΠb(b−1)),{( ˆρX , ˇσX )}X∈{b(b−1),b−b}). Since {ˇhi∗, ˇhn+1} is a basis of ˇH2, we
can deﬁne wh, bi∗ as the unique coeﬃcients in Zq such that ˇd = bi∗ ˇhi∗ + wh
ˇhn+1. We distinguish
three cases:
1) If ˆc∆ (cid:54)= ∆ˆc, we can construct an adversary B against the SP ˇH Assumption that outputs ˆc∆ −
2) If ˆc∆ = ∆ˆc but bi∗ (cid:54)= bi∗. Given that (bigi∗, ¯bi∗hi∗) is linearly independent from {(gi∗, hi∗), (gn+1, hn+1)}

∆ˆc ∈ ker(ˇa(cid:62)).
whenever bi∗ (cid:54)= ¯bi∗, an adversary P∗
2 against the strong soundness of ΨDk,com outputs the pair
( ˆρb−b, ˇσb−b) which is a fake proof for (ˆc∆, ˇd). Note that strong soundness is required since, in
order to compute { ˆCi,j, ˇDi,j : (i, j) ∈ In,1}, P∗

2 requires the discrete logs of either ˆG or ˇD.

18

3) If ˆc∆ = ∆ˆc and bi∗ = bi∗, then bi∗(bi∗ − 1) (cid:54)= 0. If we express Θb(b−1) + Πb(b−1) as a linear
i∗ is bi∗(bi∗ − 1) (cid:54)= 0 and thus Θb(b−1) + Πb(b−1) /∈
1 against ΨDk,+ outputs the pair ( ˆρb(b−1),

combination of gih(cid:62)
Span({Ci,j + Di,j : (i, j) ∈ In,1}). The adversary P∗
ˇσb(b−1)) which is a fake proof for ( ˆΘb(b−1), ˇΠb(b−1)). 7
This concludes the proof of soundness. Now we prove Zero-Knowledge.

j , the coordinate of gi∗h(cid:62)

that ˇd = ˇH(cid:0) b

Theorem 7. The proof system is perfect quasi-adaptive zero-knowledge.
Proof. First, note that the vector ˇd ∈ ˇH2 output by the prover and the vector output by S2 follow
exactly the same distribution. This is because the rank of ˇH is 1. In particular, although the
simulator S2 does not know the opening of ˆc, which is some b ∈ {0, 1}n, there exists wh ∈ Zq such
, the proof ( ˆΘb(b−1), ˇΠb(b−1)) is
uniformly distributed conditioned on satisfying check 2) of algorithm V. Therefore, these elements
of the simulated proof have the same distribution as in a real proof. This fact combined with the
perfect zero-knowledge property of ΨDk,+ and ΨDk,com concludes the proof.

(cid:1). Since R is chosen uniformly at random in Z2×2

wh

q

5.5 Extensions

q

wg

the matrix ˆG := ∆ ˆU has 2n columns instead of n + 1 and ˆc∆ := ˆG(cid:0) b

CRS Generation for Individual Commitments. A natural way to extend our construction
to individual commitments (distribution (b) from Sect. 5.2) is the following. The only change is
that the matrix ∆ is sampled uniformly from Z2×2n
(the distribution of ˇH is not changed). Thus,
q . In
the soundness proof, the only change is that in Game2, the extra columns are also changed to span
a one-dimensional space, i.e. in this game ˆgi, i ∈ [2n − 1] and i (cid:54)= i∗, are uniform vectors in the
space spanned by ˆg2n. With this approach, the proof size is still constant and the changes to the
original construction are minimal but the CRS is considerably larger. Further, we do not know how
to make the CRS linear for bit-strings of weight 1.
Therefore, we propose an alternative way to extend our result to individual commitments. In
this new construction, the matrix ˆG is independent from ˆU and for all i ∈ [n], ˆgi = µiˆgn+1, µi ← Zq
and ˆgn+1 ← Z2
q.

(cid:1) for some wg ∈ Zn

The proof is deﬁned in a slightly diﬀerent way. Now one computes ˆc∆ := ˆG

g ← Zq, and
one proves that the three commitments, ˆc, ˆc∆, ˇd open to the same value. Intuitively, this replaces
in the original construction the proofs that ∆ˆc = ˆc∆ and that ∆ˆc and ˇd open to the same value.

More speciﬁcally, this is proven by showing that ((cid:0) ˆc

(cid:16) b

, w(cid:48)

(cid:17)

w(cid:48)

g

(cid:1) , ˇd) ∈ L ˆM, ˇN, where.
and ˇN :=(cid:0) ˇH1 ˇ02×n ˇ02×1 ˇhn+1

ˆc∆

(cid:1) .

(cid:18) ˆU1 ˆU2 ˆ02n×1 ˆ02n×1

(cid:19)

ˆG1 ˆ02×n ˆgn+1 ˆ02×1

ˆM :=

The advantage of this alternative approach is that the matrix ˆG has now n + 1 columns as in the
original construction as opposed to 2n in the ﬁrst extension to individual commitments.
7 The proof system ΨDk,+ is constructed for matrices {(Ci,j, Di,j) : (i, j) ∈ In,1} sampled from some distribution
DΓ , which in this case depends on the distribution of G and H. We assume that the adversary P∗
2 against ΨDk,+
receives the common reference string of ΨDk,+ as described in Section 3.2 and additionally the matrices ˆG and ˇH
which deﬁnes the language, i.e. the distribution of Ci,j, Di,j (this is necessary so that P∗
2 can simulate the crs for
adversary A). We stress this additional information to describe the language does not aﬀect the soundness proof
for Theorem 3 (in particular, ˆG and ˇH are independent of (Λ, Ξ)).

19

ˆc∆

γ(cid:48)

γ2n+2

such that

ˆc∆
ˇd

=

ˇN

(cid:18) ˆc

(cid:19)

there is some γ ∈ Z2n+2

γ, and the fact that ˆc is perfectly binding together

q

(cid:1) = bi∗ ˇhi∗ + ˜wh

with the form of ˆM, ˇN implies that γ =

(cid:1) , ˇd) ∈ L ˆM, ˇN implies that
(cid:1) = bi∗ + ˜wg ˆgn+1 and

The proof of soundness must be modiﬁed in the following way. In the proof of Lemma 3 one
sets ˆgn+1 := ˆs and ˆgi∗ := ˆt, similarly as done in Lemma 4. This guarantees that, as in the original
construction, in the last game ˆgi∗ (resp. ˇhi∗) is linearly independent of the rest of columns of ˆG
(resp. ˇH). In the last game we need to show that ˆc∆ = bi∗ ˆgi∗ + ˜wg ˆgn+1 and ˇd = bi∗ ˇhi∗ + ˜wh
ˇhn+1,

ˇhn+1 for some unique bi∗. To conclude the proof of soundness we just
need to argue that bi∗ (cid:54)= {0, 1}, leads to a contradiction. This follows from the same argument as
the original proof.

for some ˜wg, ˜wh ∈ Zq and that bi∗ ∈ {0, 1}. Note that the fact that ((cid:0) ˆc
(cid:16) ˆM
(cid:17)
(cid:16) b
(cid:17)
. In particular, ˆc∆ = ˆG(cid:0) b
ˇd = ˇH(cid:0) b
picks a random ˆc∆ and simulates the proof that ((cid:0) ˆc
commitments, we can easily extend it to prove that the bit-string b satisﬁes (cid:80)
can also be done as follows. Deﬁne B :=(cid:0) β1 ... βn 0

Linear Equations Satisﬁed by Bit-Strings Because of the homomorphic properties of the
i∈[n] βibi = t, for
some β ∈ Zn
q , t ∈ Zq. If the commitment ˆc is a concatenation of GS commitments to bi, this can be
done in the usual way with GS proofs. But if ˆU is drawn from distribution (a) (see Sect. 5.2) this
i denote the i th vector

(cid:1) , ˇd) ∈ L ˆM, ˇN with the appropriate trapdoor.

For zero-knowledge, observe that ˆc∆ is just a uniform vector in Span(ˆgn+1). The simulator just

The rest of the proof is identical to the simulated proof in the original construction.

and let ˆe(cid:96)

γ2n+1

ˆc∆

of the canonical basis of ˆG(cid:96). We claim the following:

(cid:1) ∈ Z2×(n+1)
1 ∈ Span (Bˆun+1) ⇔ (cid:88)

0 ... 0 1

q

Bˆc − tˆe2

So to be able to prove that(cid:80)

i∈[n] biBˆui−tˆe2
This is justiﬁed because Bui = Ben+1
1.
i∈[n] βibi = t, we just need to add to the CRS the necessary elements
to prove membership in LB ˆun+1 := {ˆx ∈ ˆG2 : ∃w ∈ Zq, ˆx = Bˆun+1w} using one of the constructions
of Sect. 2.4.

i = (1, 0)(cid:62), and then Bˆc−tˆe2

βibi = t.

i∈[n]

1 = wBˆun+1 +(cid:80)

proof that(cid:80)

Bit-Strings of Weight 1 In the special case when the bit-string has only one 1 (this case is useful
in some applications, see Sect. 6), the size of the CRS can be made linear in n, instead of quadratic.
To prove this statement we would combine our proof system for bit-strings of section 5.3 and a
i∈[n] bi = 1 as described above when m = 1 or using GS-proofs when m = n. In the
deﬁnition of ( ˆΘb(b−1), ˇΠb(b−1)) in Eq. 8, one sees that for all pairs (i, j) ∈ [n] × [n], the coeﬃcient
of ( ˆCi,j, ˇDi,j) is bi(bj − 1). If i∗ is the only index such that bi∗ = 1, then we have:

(cid:88)

(cid:88)

i∈[n]

j∈[n]

(cid:88)

j(cid:54)=i∗

bi(bj − 1)( ˆCi,j, ˇDi,j) =

( ˆCi∗,j, ˇDi∗,j) =: ( ˆCi∗,(cid:54)=, ˇDi∗,(cid:54)=).

Therefore, one can replace in the CRS the pairs of matrices ( ˆCi,j, ˇDi,j) by ( ˆCi,(cid:54)=, ˇDi,(cid:54)=), i ∈ [n].
The resulting CRS is linear in n.

20

6 Applications

Many protocols use proofs that a commitment opens to a bit-string as a building block. Since our
commitments are still of size Θ(n), our results may not apply to some of these protocols (e.g. range
proofs). Yet, there are several applications where bits need to be used independently and our results
provide signiﬁcant improvements. Table 2 summarizes them.

6.1 Signatures

Some application examples are the signature schemes of [4,5,8,12]. For example, in the revocable
attribute-based signature scheme of Escala et. al [12], every signature includes a proof that a set
of GS commitments, whose size is the number of attributes, opens to a bit-string. Further, the
proof of membership in a list which is discussed below can also be used to reduce the size of Ring
Signature scheme of [9], which is the most eﬃcient ring signature in the standard model. To sign a
message m, among other things, the signer picks a one-time signature key and certiﬁes the one-time
veriﬁcation key by signing it with a Boneh-Boyen signature under vkα. Then, the signer commits
to vkα and shows that vkα belongs to the list of Boneh-Boyen veriﬁcation keys (vk1, . . . , vkn) of
the parties in the ring R.

Proof System

Threshold GS

Dynamic List
(Ring Signature)

Static List

Proof Size
Author
(mx + 3(n − t) + 2¯n)g
R`afols [32] (1)
2(n − t + 1)h + 2n(g + h)
R`afols [32] (2)
√
2(n + 1)g + 10(g + h)
This work
√
√
n + 4)(g + h)
(16
Chandran et al. [9]
√
√
nh
n + 6)g + 12
(8
R`afols [32]
√
√
n + 14)g + (8
n + 14)h
(4
This work
√
√
n + 22)h
n + 16)g + (2
(4
This work (ﬁrst scheme)
n + 60)h
n + 36)g+(6 3
This work (second scheme) (6 3

in ˆG in each set Si, and ¯n is the total number of two-sided and quadratic equations in some(cid:83)

Table 2. Comparison of the application of our techniques and results from the literature. In rows labeled as “Threshold
GS” we give the size of the proof of satisﬁability of t-out-of-n sets Si, where mx is the sum of the number of variables
i∈[n] Si. For all rows,
we must add to the proof size the cost of a GS proof of each equation in one of the sets Si. In the other rows n is the
size of the list.

6.2 Threshold GS Proofs for PPEs

There are two approaches to construct threshold GS proofs for PPEs, i.e. proofs of satisﬁability
of t-out-of-n equations. One is due to [16] and consists of compiling the n equations into a single
equation which is satisﬁed only if t of the original equations are satisﬁed. For the case of PPEs,
this method adds new variables and proves that each of them opens to a bit. Our result reduces
the cost of this approach, but we omit any further discussion as it is quite ineﬃcient because the
number of additional variables is Θ(mvar + n), where mvar is the total number of variables in the
original n equations.
The second approach is due to R`afols [32]. The basic idea behind [32], which extends [17],
follows from the observation that for each GS equation type tp, the CRS space K is partitioned
into a perfectly sound CRS space Kb

tp and a perfectly witness indistinguishable CRS space Kh
tp.

21

In particular, to prove satisﬁability of t-out-of-n sets of equations from {Si : i ∈ [n]} of type tp,
it suﬃces to construct an algorithm Kcorr which on input crsGS and some set of indexes A ⊂ [n],
|A| = t, generates n GS common reference strings {crsi, i ∈ [n]} and simulation trapdoors τi,sim,
i ∈ Ac, in a such a way that8:
a) it can be publicly veriﬁed the set of perfectly sound keys, {crsi : crsi ∈ Kb
tp} is of size at least t,
b) there exists a simulator Scorr who outputs (crsi, τi,sim) for all i ∈ [n], and the distribution of
{crsi : i ∈ [n]} is the same as the one of the keys output by Kcorr when crsGS is the perfectly
witness-indistinguishable CRS.

The prover of t-out-of-n satisﬁability can run Kcorr and, for all i ∈ [n], compute a real (resp.
simulated) proof for Si with respect to crsi when i ∈ A (resp. when i ∈ Ac).

R`afols gives two constructions for PPEs, the ﬁrst one can be found in [32], App. C and the

other follows from [32, Sect. 7]9. Our algorithm Kcorr for PPEs10 goes as follows:
– Deﬁne (b1, . . . , bn) as bi = 1 if i ∈ A and bi = 0 if i ∈ Ac. For all i ∈ [n], let ˆzi := Comm(bi) =

bi ˆu1 + ri ˆu2, ri ∈ Zq, and deﬁne τsim,i = ri, for all i ∈ Ac. Deﬁne crsi := (Γ, ˆzi, ˆu2, ˇv1, ˇv2).

– Prove that {ˆci} opens to b ∈ {0, 1}n and that(cid:80)

i∈[n] bi = t.

The simulator just deﬁnes b = 0. The reason why this works is that when bi = 1, (ˆzi − ˆu1) ∈
Span(ˆu2), therefore crsi ∈ Kb

P P E and when bi = 0, (ˆzi − ˆu1) /∈ Span(ˆu2) so crsi ∈ Kh

P P E.

6.3 More Eﬃcient Proof of Membership in a List
√

Chandran et al. construct a ring signature of size Θ(
n) [9], which is the most eﬃcient ring
signature in the standard model. Their construction uses as a subroutine a non-interactive proof
of membership in some list L = (ˆl1, . . . , ˆln) which is of size Θ(
n). The trick of Chandran et al. to
achieve this asymptotic complexity is to view L as a matrix ˆL ∈ ˆGm×m, for m =
n, where the
i, j th element of ˆL is ˆli,j := ˆl(i,j) and (i, j) := (i− 1)m + j. Given a commitment ˆc to some element
ˆlα, where α = (iα, jα), their construction in asymmetric bilinear groups works as follows :
1. Compute GS commitments in ˇH to b1 . . . , bm and b(cid:48)
2. Compute a GS proof that bi ∈ {0, 1} and b(cid:48)

j ∈ {0, 1} for all i, j ∈ [m], and that(cid:80)

m, where bi = 1 if i = iα and 0

j = 1 if j = jα, and 0 otherwise.

1, . . . , b(cid:48)

i∈[m] bi = 1,

√

√

j∈[m] b(cid:48)

otherwise, and b(cid:48)

and(cid:80)
4. Compute a GS proof that ˆxj =(cid:80)
5. Compute a GS proof that ˆlα =(cid:80)

j = 1.

3. Compute GS commitments to ˆx1 := ˆl(iα,1), . . . , ˆxm := ˆl(iα,m).

i∈[m] biˆl(i,j), for all j ∈ [m], is satisﬁed.
j∈[m] b(cid:48)

j ˆxj is satisﬁed.

With respect to the naive use of GS proofs, Step 2 was improved by R`afols [32]. Using our proofs
for bit-strings of weight 1 from Sect. 5.5, we can further reduce the size of the proof in step 2, see
table.

8 More technically, this is the notion of Simulatable Veriﬁable Correlated Key Generation in [32], which extends the

deﬁnition of Veriﬁable Correlated Key Generation of [17].

9 The construction in [32, Sect. 7] is for other equation types but can be used to prove that t-out-of-n of crs1, . . . , crsn

are perfectly binding for PPEs.

10 Properly speaking the construction is for PPEs which are left-simulatable in the terminology of [32].

22

We note that although in step 4 the equations are all two-sided linear equations, proofs can
only be aggregated if the list comes from a witness samplable distribution and the CRS is set to
depend on that speciﬁc list. This is not useful for the application to ring signatures, since the CRS
should be independent of the ring R (which deﬁnes the list). If aggregation is possible then the size
of the proof in step 4 is reduced from (2g + 4h)
n to 4g + 8h. A complete description of the proof
√
can be found in Appendix D, where we also show that when the CRS depends on the list and the
list is witness samplable, the proof can be further reduced to Θ( 3

√

n).

References

1. M. Abe, G. Fuchsbauer, J. Groth, K. Haralambiev, and M. Ohkubo. Structure-preserving signatures and commitments 
to group elements. In T. Rabin, editor, CRYPTO 2010, volume 6223 of LNCS, pages 209–236, Santa
Barbara, CA, USA, Aug. 15–19, 2010. Springer, Heidelberg, Germany. 35

2. M. Abe, J. Groth, M. Ohkubo, and T. Tango. Converting cryptographic schemes from symmetric to asymmetric
bilinear groups. In J. A. Garay and R. Gennaro, editors, CRYPTO 2014, Part I, volume 8616 of LNCS, pages
241–260, Santa Barbara, CA, USA, Aug. 17–21, 2014. Springer, Heidelberg, Germany. 2

3. M. Abe, K. Haralambiev, and M. Ohkubo. Signing on elements in bilinear groups for modular protocol design.

Cryptology ePrint Archive, Report 2010/133, 2010. http://eprint.iacr.org/2010/133. 3

4. O. Blazy, G. Fuchsbauer, D. Pointcheval, and D. Vergnaud. Signatures on randomizable ciphertexts. In D. Catalano,
 N. Fazio, R. Gennaro, and A. Nicolosi, editors, PKC 2011, volume 6571 of LNCS, pages 403–422, Taormina,
Italy, Mar. 6–9, 2011. Springer, Heidelberg, Germany. 21

5. O. Blazy, D. Pointcheval, and D. Vergnaud. Compact round-optimal partially-blind signatures. In I. Visconti
and R. D. Prisco, editors, Security and Cryptography for Networks - 8th International Conference, SCN 2012,
Amalﬁ, Italy, September 5-7, 2012. Proceedings, volume 7485 of Lecture Notes in Computer Science, pages 95–112.
Springer, 2012. 21

6. D. Boneh, X. Boyen, and E.-J. Goh. Hierarchical identity based encryption with constant size ciphertext. In
R. Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 440–456, Aarhus, Denmark, May 22–26,
2005. Springer, Heidelberg, Germany. 38

7. D. Boneh, D. Freeman, J. Katz, and B. Waters. Signing a linear subspace: Signature schemes for network coding.
In S. Jarecki and G. Tsudik, editors, PKC 2009, volume 5443 of LNCS, pages 68–87, Irvine, CA, USA, Mar. 18–20,
2009. Springer, Heidelberg, Germany. 35

8. P. Camacho. Fair exchange of short signatures without trusted third party. In E. Dawson, editor, CT-RSA 2013,
volume 7779 of LNCS, pages 34–49, San Francisco, CA, USA, Feb. 25 – Mar. 1, 2013. Springer, Heidelberg,
Germany. 21

9. N. Chandran, J. Groth, and A. Sahai. Ring signatures of sub-linear size without random oracles. In L. Arge,
C. Cachin, T. Jurdzinski, and A. Tarlecki, editors, ICALP 2007, volume 4596 of LNCS, pages 423–434, Wroclaw,
Poland, July 9–13, 2007. Springer, Heidelberg, Germany. 21, 22

10. A. Escala and J. Groth. Fine-tuning Groth-Sahai proofs. In H. Krawczyk, editor, PKC 2014, volume 8383 of

LNCS, pages 630–649, Buenos Aires, Argentina, Mar. 26–28, 2014. Springer, Heidelberg, Germany. 2

11. A. Escala, G. Herold, E. Kiltz, C. R`afols, and J. Villar. An algebraic framework for Diﬃe-Hellman assumptions.
In R. Canetti and J. A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages 129–147, Santa
Barbara, CA, USA, Aug. 18–22, 2013. Springer, Heidelberg, Germany. 2, 3, 5

12. A. Escala, J. Herranz, and P. Morillo. Revocable attribute-based signatures with adaptive security in the standard
model. In A. Nitaj and D. Pointcheval, editors, AFRICACRYPT 11, volume 6737 of LNCS, pages 224–241, Dakar,
Senegal, July 5–7, 2011. Springer, Heidelberg, Germany. 21

13. D. M. Freeman. Converting pairing-based cryptosystems from composite-order groups to prime-order groups. In
H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 44–61, French Riviera, May 30 – June 3,
2010. Springer, Heidelberg, Germany. 2

14. S. D. Galbraith, K. G. Paterson, and N. P. Smart. Pairings for cryptographers. Discrete Applied Mathematics,

156(16):31133121, 2008. 2

15. R. Gennaro, C. Gentry, B. Parno, and M. Raykova. Quadratic span programs and succinct NIZKs without PCPs.
In T. Johansson and P. Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645, Athens,
Greece, May 26–30, 2013. Springer, Heidelberg, Germany. 1

23

16. J. Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. In X. Lai
and K. Chen, editors, ASIACRYPT 2006, volume 4284 of LNCS, pages 444–459, Shanghai, China, Dec. 3–7,
2006. Springer, Heidelberg, Germany. 21

17. J. Groth, R. Ostrovsky, and A. Sahai. Non-interactive zaps and new techniques for NIZK. In C. Dwork, editor,
CRYPTO 2006, volume 4117 of LNCS, pages 97–111, Santa Barbara, CA, USA, Aug. 20–24, 2006. Springer,
Heidelberg, Germany. 21, 22

18. J. Groth and A. Sahai. Eﬃcient non-interactive proof systems for bilinear groups. In N. P. Smart, editor, EUROCRYPT 
2008, volume 4965 of LNCS, pages 415–432, Istanbul, Turkey, Apr. 13–17, 2008. Springer, Heidelberg,
Germany. 4

19. J. Groth and A. Sahai. Eﬃcient noninteractive proof systems for bilinear groups. SIAM J. Comput., 41(5):1193–

1232, 2012. 1, 12

20. D. Hofheinz and E. Kiltz. Secure hybrid encryption from weakened key encapsulation. In A. Menezes, editor,
CRYPTO 2007, volume 4622 of LNCS, pages 553–571, Santa Barbara, CA, USA, Aug. 19–23, 2007. Springer,
Heidelberg, Germany. 5

21. A. Joux. A new index calculus algorithm with complexity L(1/4 + o(1)) in small characteristic. In T. Lange,
K. Lauter, and P. Lisonek, editors, SAC 2013, volume 8282 of LNCS, pages 355–379, Burnaby, BC, Canada,
Aug. 14–16, 2014. Springer, Heidelberg, Germany. 2

22. C. S. Jutla and A. Roy. Shorter quasi-adaptive NIZK proofs for linear subspaces. In K. Sako and P. Sarkar,
editors, ASIACRYPT 2013, Part I, volume 8269 of LNCS, pages 1–20, Bengalore, India, Dec. 1–5, 2013. Springer,
Heidelberg, Germany. 2, 7

23. C. S. Jutla and A. Roy. Switching lemma for bilinear tests and constant-size NIZK proofs for linear subspaces.
In J. A. Garay and R. Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of LNCS, pages 295–312, Santa
Barbara, CA, USA, Aug. 17–21, 2014. Springer, Heidelberg, Germany. 2, 3, 11, 12, 14

24. E. Kiltz, J. Pan, and H. Wee. Structure-preserving signatures from standard assumptions, revisited. In R. Gennaro
and M. J. B. Robshaw, editors, CRYPTO 2015, Part II, volume 9216 of LNCS, pages 275–295, Santa Barbara,
CA, USA, Aug. 16–20, 2015. Springer, Heidelberg, Germany. 36

25. E. Kiltz and H. Wee. Quasi-adaptive NIZK for linear subspaces revisited. In E. Oswald and M. Fischlin, editors,
EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 101–128, Soﬁa, Bulgaria, Apr. 26–30, 2015. Springer,
Heidelberg, Germany. 2, 8, 9, 26

26. B. Libert, T. Peters, M. Joye, and M. Yung. Linearly homomorphic structure-preserving signatures and their
In R. Canetti and J. A. Garay, editors, CRYPTO 2013, Part II, volume 8043 of LNCS, pages

applications.
289–307, Santa Barbara, CA, USA, Aug. 18–22, 2013. Springer, Heidelberg, Germany. 35, 37, 38

27. B. Libert, T. Peters, M. Joye, and M. Yung. Non-malleability from malleability: Simulation-sound quasi-adaptive
NIZK proofs and CCA2-secure encryption from homomorphic signatures. In P. Q. Nguyen and E. Oswald, editors,
EUROCRYPT 2014, volume 8441 of LNCS, pages 514–532, Copenhagen, Denmark, May 11–15, 2014. Springer,
Heidelberg, Germany. 2, 8, 36

28. B. Libert, T. Peters, M. Joye, and M. Yung. Compactly hiding linear spans: Tightly secure constant-size
simulation-sound QA-NIZK proofs and applications. Cryptology ePrint Archive, Report 2015/242, 2015.
http://eprint.iacr.org/2015/242. 39

29. B. Libert, T. Peters, and M. Yung. Group signatures with almost-for-free revocation. In R. Safavi-Naini and
R. Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 571–589, Santa Barbara, CA, USA, Aug. 19–23,
2012. Springer, Heidelberg, Germany. 6

30. P. Morillo, C. R`afols, and J. L. Villar. Matrix computational assumptions in multilinear groups. Cryptology

ePrint Archive, Report 2015/353, 2015. http://eprint.iacr.org/2015/353. 3, 5, 11, 13, 28

31. M. Naor. On cryptographic assumptions and challenges (invited talk). In D. Boneh, editor, CRYPTO 2003,
volume 2729 of LNCS, pages 96–109, Santa Barbara, CA, USA, Aug. 17–21, 2003. Springer, Heidelberg, Germany.
1

32. C. R`afols. Stretching groth-sahai: NIZK proofs of partial satisﬁability.

In Y. Dodis and J. B. Nielsen, editors,
 TCC 2015, Part II, volume 9015 of LNCS, pages 247–276, Warsaw, Poland, Mar. 23–25, 2015. Springer,
Heidelberg, Germany. 2, 21, 22

33. H. Shacham. A cramer-shoup encryption scheme from the linear assumption and from progressively weaker linear

variants. Cryptology ePrint Archive, Report 2007/074, 2007. http://eprint.iacr.org/. 5

34. V. Shoup. Lower bounds for discrete logarithms and related problems. In W. Fumy, editor, EUROCRYPT’97,
volume 1233 of LNCS, pages 256–266, Konstanz, Germany, May 11–15, 1997. Springer, Heidelberg, Germany. 38

24

A Proofs of Theorems 3 and 4

Theorem 8 (Theorem 3 repeated). If (cid:102)Dk = Dk and ˜k = k + 1, Fig. 2 describes a QANIZK 
proof system with perfect completeness, computational adaptive soundness based on the DkSKerMDH 
Assumption, and perfect zero-knowledge.
Proof. (Soundness.) B receives a challenge ( ˆA, ˇA), A ← Dk, and then it chooses Λ ← Z(k+1)×m
, Ξ ←
Z(k+1)×n
, samples ( ˆM, ˇN) ← DΓ and computes crs := ( ˆMΛ, ˇAΛ, ˇA, ˇNΞ , ˆAΞ , ˆA) in the natural way.
An adversary F against the soundness property outputs a vector (ˆx∗, ˇy∗) /∈ L ˆM, ˇN and a valid proof
( ˆρ∗, ˇσ∗). At this point, B computes its own proof ( ˆρ†, ˇσ†) using Λ and Ξ. The adversary B will
output as a response to the Dk-SKerMDH challenge the pair (ˆr, ˇs) := ( ˆρ∗ − ˆρ†, ˇσ† − ˇσ∗). We now
see that with all but probability 1/q, this is a valid solution. Indeed, if r (cid:54)= s, we are done, because
since both are valid proofs, subtraction of the veriﬁcation equations yields

q

q

( ˆρ∗ − ˆρ†)(cid:62) ˇA = ( ˇσ† − ˇσ∗)(cid:62) ˆA.

y∗

(10)

(cid:19)

∆ := (Λ||Ξ), w :=

ρ† + σ† = Λx∗ + Ξy∗ = ∆w,

By deﬁnition r (cid:54)= s if and only if ρ∗ + σ∗ (cid:54)= ρ† + σ†. But

than columns, it follows by a standard argument that ∆w is undetermined from the adversary’s
point of view.

(cid:18)x∗
Since Z is a uniform random value, the CRS reveals (information theoretically) only(cid:8)∆(cid:0) M
(cid:1) , ∆(cid:62)A(cid:9)
about ∆. But since a) (ˆx∗, ˇy∗) /∈ L ˆM, ˇN, w is not in the image of (cid:0) M
(cid:1) and b) A has more rows
Theorem 9 (Theorem 4 repeated). If (cid:102)Dk = Dk and ˜k = k, and DΓ is a witness samplable
(cid:1). An adversary B against Dk-SKerMDH
Proof. (Soundness.) Deﬁne ˜m := m + n and P := (cid:0) M
and P(cid:62)P⊥ = 0, thus we can write P⊥ =(cid:0) E

Assumption receives a challenge ( ˆA, ˇA), A ← Dk. It samples ( ˆM, ˇN, M, N) ∈ Rpar and computes
P⊥ ∈ Z ˜m×( ˜m−r)
, where r = rank(P), a basis of the kernel of P(cid:62). By deﬁnition, P(cid:62) = (M(cid:62)||N(cid:62))

distribution, Fig. 2 describes a QA-NIZK proof system with perfect completeness, computational
adaptive strong soundness based on the Dk-SKerMDH Assumption, and perfect zero-knowledge.

(cid:1), for some matrices such that M(cid:62)E = −N(cid:62)F.

N

N

N

q

F

q

q

R ˆA

(cid:19)

(cid:19)

ˆA(cid:48) :=

and deﬁnes

∈ ˆG(k+ ˜m−r)×k,

Adversary B samples R ∈ Z( ˜m−r−1)×(k+1)

(cid:18) ˆA
0 . Then B implicitly sets (Λ||Ξ) := ((cid:101)Λ||(cid:101)Ξ) + T(cid:62)
1A−1
(cid:18) ˇAΛ
(cid:19)

Then B samples ((cid:101)Λ||(cid:101)Ξ) ← Zk× ˜m
(cid:18)Λ(cid:62) ˇA0

(cid:18) ˇA

(cid:32)
((cid:101)Λ(cid:62) + ETA(cid:48)) ˇA0
((cid:101)Ξ(cid:62) + FTA(cid:48)) ˆA0

Ξ(cid:62) ˆA0

ˇA(cid:48) :=

(cid:33)

(cid:19)

R ˇA

ˆAΞ

=

:=

rows, and TA(cid:48) = A(cid:48)

. Let A0 be the ﬁrst k rows of A(cid:48) (or A) and A(cid:48)

∈ ˇH(k+ ˜m−r)×k.

1 the rest of the
A(cid:48)(E(cid:62)||F(cid:62)), and computes:
(cid:32)
((cid:101)Λ(cid:62)||E) ˇA(cid:48)
((cid:101)Ξ(cid:62)||F) ˆA(cid:48)

(cid:33)

(11)

=

25

So far the argument is very similar to [25] Sect. 3.2, now comes an important diﬀerence. Adversary
B also needs to compute Λ ˆM + ˆZ and Ξ ˇN − ˇZ. Although the adversary B does not know how to
compute ΞN or ΛM, it can compute their sum in Zq as:

(cid:16)

((cid:101)Λ||(cid:101)Ξ) + T(cid:62)

A(cid:48)(E(cid:62)||F(cid:62))

(cid:17)(cid:18)M
(cid:19)

N

= (cid:101)ΛM +(cid:101)ΞN =: T.

ΞN + ΛM =

Thus, B picks Z ← Zk×t
proof for some (ˆx, ˇy) /∈ L ˆM, ˇN, it holds that:

q

and outputs ˇNΞ := ˇT − ˇZ and ˆMΞ := ˆZ. Now, when F outputs a valid

ˆx(cid:62)((cid:101)Λ(cid:62)||E) ˇA(cid:48) − ( ˆρ(cid:62)||ˆ01×( ˜m−r))(cid:62) ˇA(cid:48) = ( ˇσ(cid:62)||ˇ01×( ˜m−r)) ˆA(cid:48) − ˇy(cid:62)(Ξ(cid:62)||F) ˆA(cid:48) ⇐⇒

ˆx(cid:62) ˇAΛ − ˆρ(cid:62) ˇA0 = ˇσ(cid:62) ˆA0 − ˇy(cid:62) ˆAΞ ⇐⇒

where ˆc(cid:62) := (ˆx(cid:62)(cid:101)Λ − ˆρ(cid:62)||ˆx(cid:62)E) and ˇd(cid:62) := (ˇy(cid:62)(cid:101)Ξ − ˇσ(cid:62)|| − ˇy(cid:62)F).
1 + c(cid:62)

c − d ∈ ker((A(cid:48))(cid:62)) ⇐⇒ (c − d)(cid:62)A(cid:48) = 0 ⇐⇒ (c(cid:62)

Obviously

ˆc(cid:62) ˇA(cid:48) = ˇd(cid:62) ˆA(cid:48),

2 R) − (d(cid:62)

1 + d(cid:62)

2 R) ∈ ker(A(cid:62)).

while, by assumption, (ˆx, ˇy) /∈ L ˆM, ˇN and thus ˆx(cid:62)E (cid:54)= −ˇy(cid:62)F, so c − d (cid:54)= 0. We conclude with an
information-theoretic argument: because R is only revealed to B through RA the probability that
1 + c(cid:62)
(c(cid:62)
This proves standard soundness. Strong soundness follows from the fact that the argument is
essentially information theoretic. In particular, the knowledge of (M, N) does not reveal additional
information about R.

2 R) is 1 − 1/q, so w.h.p, (ˆc(cid:62)

2 R) solves Dk-SKerMDH.

2 R) (cid:54)= (d(cid:62)

2 R), (ˇd(cid:62)

1 + d(cid:62)

1 + ˇd(cid:62)

1 + ˆc(cid:62)

B Additional details for QA-NIZK for Bit-Strings

B.1 Completeness

It is obvious by deﬁnition that for any ˆc ∈ L ˆU,bits the vector ˆc∆ generated by an honest prover
Note that, by deﬁnition of ˆCi,j and ˇDi,j, ˆCi,jˇI2×2 + ˆI2×2 ˇDi,j = ˆgi ˇhj. Since bi(bi − 1) = 0 for

passes the veriﬁcation test described in 1).
each i ∈ [n],

ˇhi

i∈[n]

ˇd −(cid:88)
(cid:62)
biwhˆgi ˇh(cid:62)
(cid:88)
biwhˆgi ˇh(cid:62)

i∈[n]
+ wgwhˆgn+1 ˇh(cid:62)

i∈[n]
+ wgwhˆgn+1 ˇh(cid:62)

(cid:88)

ˆc∆

=

=

n+1

n+1 + wg(bi − 1)ˆgn+1 ˇh(cid:62)

i +

n+1 + wg(bi − 1)ˆgn+1 ˇh(cid:62)

i +

n+1 + ˆRˇI2×2 − ˆI2×2 ˇR

= ˆΘb(b−1)

ˇI2×2 + ˆI2×2 ˇΠb(b−1).

26




bi(bj − 1)ˆgi ˇh(cid:62)

j

bi(bj − 1)ˆgi ˇh(cid:62)

j

(cid:88)

j∈[n]

(cid:88)

j∈[n]
j(cid:54)=i

Finally, the rest of the proof follows from completeness of ΨDk,com and ΨDk,+.

Pr [Game0(A) = 1] .

B.2 Soundness Proof
Lemma 6 (Lemma 2 repeated). Pr [Game1(A) = 1] ≥ 1
n
Proof. The probability that Game1(A) = 1 is the probability that a) Game0(A) = 1 and b) bi∗ /∈
{0, 1}. The view of adversary A is independent of i∗, while, if Game0(A) = 1, then there is at least
one index (cid:96) ∈ [n] such that such that b(cid:96) /∈ {0, 1}. Thus, the probability that the event described in
b) occurs conditioned on Game0(A) = 1, is greater than or equal to 1/n and the lemma follows.
Lemma 7 (Lemma 4 repeated). There exists a U1-MDDH ˇH adversary B such that | Pr [Game2(A) = 1]−
Pr [Game3(A) = 1]| ≤ AdvU1, ˇH(B).
Proof. The adversary B receives an instance of the U1-MDDH ˇH problem, which is a pair (ˇs, ˇt),
where ˇs is a uniform vector of ˇH2 and ˇt is either a uniform vector in ˇH2 or ˇt = γˇs, for random
γ ∈ Zq.

Adversary B deﬁnes ˇhn+1 := ˇs and the rest of the columns of ˇH are honestly sampled with the
j − ˇTi,j and
Given that adversary B can only compute gi ˇh(cid:62)
and (i, j) ∈ In,1. Note that this does not change the distribution of

sole exception of ˇhi∗, which is set to ˇt.
ˆCi,j := ˆTi,j, for Ti,j ← Z2×2
( ˇDi,j, ˆCi,j), which is the uniform one conditioned on Ci,j + Di,j = gih(cid:62)
j .

j ∈ ˇH2×2, it deﬁnes ˇDi,j := gi ˇh(cid:62)

The rest of the parameters are computed using a ← L1, the matrix ∆ ∈ Z2×(n+1)

and the
discrete logarithms of ˆG. It is immediate to see that adversary B perfectly simulates Game2 when
ˇt = γˇs and Game3 when ˇt is uniform.

q

q

B.3 Eﬃciency

If we take Dk = L2, the proof is of size of 2(g + h) for ˆc∆, ˆd, 4(g + h) for ( ˆΘb(b−1), ˇΠb(b−1)), and
4(g + h) for ˆρb(b−1), ˆρb−b and ˇσb(b−1), ˇσb−b. The whole proof size is 10(g + h).
The CRS is of size 4(g + h) for each pair ( ˆCi,j, ˇDi,j), so it adds up to 4(g + h)((n + 1)2 − n). To
represent the matrix ˆU we need n + 1 elements of ˆG, 2(n + 1) elements of ˆG for ˆG and 2(n + 1)
is 2(g+h)((n+1)2−n)+12(g+h) and the size of crsΨDk ,com
elements of ˇH for ˇH. The size of crsΨDk ,+
is 2(g + h)(n + 2) + 8(g + h). To represent ˇa and ˇa∆ we need n + 2 elements of ˇH In total, the CRS
requires 6n2 + 11n + 33 elements of ˆG and 6n2 + 11n + 34 elements of ˇH.

The veriﬁer computes n + 3 pairings in the ﬁrst step of the veriﬁcation algorithm, 12 pairings
in the second step, and 24 + 16 pairings in the third step. The whole veriﬁcation algorithm requires
n + 55 pairing computations.

C QA-NIZK Arguments for Bit-Strings in Symmetric Bilinear Groups

C.1 Symmetric Bilinear Groups
Throughout this section, (q, ˆG, T, e, ˆg) ← Gens(1λ) is a description of a symmetric bilinear group,
where ˆG, T are groups of prime order q, the element ˆg is a generator of ˆG, and e : ˆG × ˆG → T is an
eﬃciently computable, non-degenerate bilinear map.

27

We retake the deﬁnition and the examples of Matrix Diﬃe-Hellman Assumptions given in section
2, except that we drop the sub-indexes ˆG, ˇH as here ˆG = ˇH. As a computational assumption, we
will use the Kernel Assumption in symmetric bilinear groups.
Deﬁnition 5 (Kernel Diﬃe-Hellman Assumption [30]). Let Γ←Gens(1λ). The Kernel DiﬃeHellman 
Assumption in ˆG (D(cid:96),k-KerMDH) says that every PPT Algorithm has negligible advantage
in the following game: given ˆA, A ← D(cid:96),k, ﬁnd a vector ˆr ∈ ˇH(cid:96), r (cid:54)= 0, such that ˆr(cid:62) ˇA = 0T.

A well-known instance of it is the Simultaneous Double Pairing (SDP) Assumption, which is

the L3,2-KerMDH Assumption, using the notation deﬁned in Sect. 2.1. Recall that:



a1 0

0 a2
a3 a4

L3,2 :

C.2 Intuition

a1, a2, a3, a4 ← Zq.

In the symmetric case, a GS Proof that a commitment opens to a bit consists of a proof that the
committed value b is such that b(b − 1) = 0. That is, compared to the asymmetric case, one does
not need to commit to another value b and prove that b(b − 1) = 0 and b − b = 0, which would be
less eﬃcient in terms of proof size. It is natural to ask if we can do the same when we extend our
construction to the symmetric setting, that is, if we can use the same key to commit to both groups,
set ˆc = ˆd (now, ˆG = ˇH) and only give a proof that bi(bi − 1) = 0 for all i ∈ [n]. Unfortunately, this
approach completely fails, as we use in several places in a crucial way that ˆgi and ˆhi are sampled
independently. For instance, this is essential to be able to use decisional assumptions in the image
of ˆG, or in the image of ˆH.

Therefore, the construction in the symmetric case follows the same lines as in the asymmetric
one. However, the construction is still a bit simpler in the symmetric case as there is no need to
“split” gih(cid:62)
j as the matrices Ci,j, Di,j. Recall that, following the intuition given in Sect. 5.1, this
was done to allow any simulator knowing one and only one of ˆgi and ˇhj discrete logarithms to
create a properly distributed CRS. In the symmetric case, this happens “for free”, as ˆgih(cid:62)
j can be
computed also as gi ˆh(cid:62)
j . As a consequence, we do not need to use our proof system from Sect. 3.2
and we can avoid the use of the Split Kernel Assumption.
In the construction below the matrix ˆU is such that its last two columns are sampled from
Ln+2,2 and the matrix B is sampled from L3,2, but they can easily be replaced by other matrix
assumptions. However, with this choice, if Dk is also weaker than the 2-Lin Assumption, then
security is based on assumptions which are all weaker than the 2-Lin Assumption. The construction
can also be extended to the case where ˆc is the concatenation of several GS commitments. We omit
any further details, as the extension is very similar as in the asymmetric case.

C.3 QA-NIZK Arguments For Bit-Strings
K0(1λ): Return Γ := (q, ˆG, T, e, ˆg) ← Gens(1λ).
DΓ : The distribution DΓ over ˆG(n+2)×(n+2) is the one induced by the following sampling procedure.
To sample ˆU ← DΓ , pick A ← Ln+2,2, for some given Ln+2,2 matrix distribution and let the last
two columns of U be equal to A, i.e. (un+1||un+2) = A. Set ui := ei, where ei is the i th vector

28

q

iﬀ ˆc = ˆU(cid:0) b

of the canonical basis of Zn+2
the relation RΓ = {R ˆU} ⊆ ˆGn+2 × ({0, 1}n × Z2

(cid:1). The relation Rpar consists of pairs ( ˆU, U) where ˆU ← DΓ .

. Finally, set ˆU := (ˆu1|| . . .||ˆun+2). The distribution DΓ deﬁnes
q), where ˆU ← DΓ , such that (ˆc,(cid:104)b, w(cid:105)) ∈ R ˆU
q and for all i ∈ [n], ˆhi := i,1 ˆhn+1 + i,2 ˆhi,2, where i,1, i,2 ← Zq.
, deﬁne ˆG := ∆ ˆU and deﬁne ˆgi := ∆ˆui ∈

Deﬁne ˆH := (ˆh1|| . . .||ˆhn+2). Choose ∆ ← Z3×(n+2)
ˆG3, for all i ∈ [n + 2]. For any pair (i, j) ∈ In,2, deﬁne:

K1(Γ, ˆU): Let ˆhn+1, ˆhn+2 ← Z3

w

q

ˆCi,j := ˆgih(cid:62)

j ∈ ˆG3×3,

where hj is the vector of discrete logarithms of ˆhj.
Let ΨDk
of ˆG9 (in symmetric groups), and let crsΨDk

be an instance of a QA-NIZK proof system for proving membership in linear subspaces

← K1(Γ,{ ˆCi,j}(i,j)∈In,2, 9). Let ΨDk,com be an

← K1(Γ, ˆG, ˆH, n).

instance of our QA-NIZK proof system from Sect. 3.3 adapted to the symmetric case and pick
crsΨDk ,com
Let B ← L3,2 and deﬁne B∆ := ∆(cid:62)B ∈ ˆG(n+2)×2.
The common reference string is given by

P(crsP , ˆc, (b, wg)): Pick wh ← Z2

q and then:

1. Deﬁne

2. Compute

crsP :=

, crsΨDk ,com

, crsV :=

, crsΨDk ,com

.

(cid:16) ˆU, ˆG, ˆH, crsΨDk

(cid:17)

(cid:19)

,

(cid:18) b

wg

(cid:16) ˆB∆, ˆB, crsΨDk
(cid:19)
(cid:18) b

.

wh

ˆc∆ := ˆG

ˆd := ˆH

(cid:17)

ˆΠb(b−1) :=

(cid:88)
(cid:88)

i∈[n]

(cid:88)
(cid:88)

j∈[n],
j(cid:54)=i

i∈[n]

j∈[2]

(cid:88)
(cid:88)
(cid:88)
(cid:88)

i∈[2]

j∈[n]

i∈[2]

j∈[2]

bi(bj − 1) ˆCi,j +

wg,i(bj − 1) ˆCn+i,j +

biwh,j

ˆCi,n+j +

wg,iwh,j

ˆCn+i,n+j,

3. Compute a proof ˆσb(b−1) that ˆΠb(b−1) belongs to the space spanned by { ˆCi,j}(i,j)∈In,2, and

a proof ˆσb−b that (ˆc∆, ˆd) open to the same value using b, wg, and wh.

V(crsV , ˆc,(cid:104)ˆc∆, ˆd, ˆΠb(b−1), ˆσb(b−1), ˆσb−b(cid:105)): 1. Check if ˆc(cid:62) ˆB∆ = ˆc(cid:62)

∆

ˆB.

2. Check if ˆc∆(ˆd −(cid:80)

i∈[n]

ˆhi)(cid:62) = ˆΠb(b−1)

ˆI3×3.

3. Verify proofs ˆσb(b−1), ˆσb−b for ˆΠb(b−1) and (ˆc∆, ˆd).
If any of these checks fails, the veriﬁer outputs 0, else it outputs 1.

29

Completeness. It is obvious by deﬁnition that any tuple (ˆc, ˆc∆) generated as described passes the
veriﬁcation test described in 1). On the other hand, given that bi(bi − 1) = 0 for each i ∈ [n]:

(cid:62)

ˆhi

ˆc∆

=

=

i∈[n]

ˆd −(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

j∈[n],
j(cid:54)=i

j∈[n]

j∈[2]

i∈[n]

i∈[n]

i∈[n]

i∈[n]

j∈[2]

bi(bj − 1)ˆgi ˆh(cid:62)

wg,i(bj − 1)ˆgn+i ˆh(cid:62)

j +

j +

(cid:88)

biwh,j ˆgi ˆh(cid:62)

j +

j∈[2]
bi(bj − 1) ˆCi,jˆI3×3 +

i∈[2]

j∈[n]
wg,iwh,j ˆgn+i ˆh(cid:62)

n+j

wg,i(bj − 1) ˆCn+i,jˆI3×3 +

biwh,j

ˆCi,n+jˆI3×3 +

wg,iwh,j

ˆCn+i,n+jˆI3×3.

i∈[2]

(cid:88)

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

i∈[2]

j∈[n]

i∈[2]

j∈[2]

Finally, the rest of the proof of completeness follows from completeness of ΨDk

and ΨDk,com.

Soundness. We prove the following theorem.

Theorem 10. Let AdvPS(A) be the advantage of an adversary A against the soundness of the proof
system described above. There exist PPT adversaries B1, B2, B3, P∗

2 such that

1, P∗
(P∗

(cid:17)

(P∗
2)

.

(cid:16)

AdvPS(A) ≤ n

9/q + 2AdvU2(B1) + AdvSDP(B3) + AdvΨDk

1) + AdvΨDk ,com

The proof follows from the indistinguishability of the following games:

adversary submits some ˆc = ˆU(cid:0) b

(cid:1), for some b /∈ {0, 1}n and w ∈ Z2

Real This is the real soundness game. The output is 1 if the adversary breaks the soundness, i.e. the
q, and the corresponding

wg

proof which is accepted by the veriﬁer.
it samples ( ˆU, U) ∈ Rpar itself according to DΓ .
to check if the output of the adversary A is such that bi∗ ∈ {0, 1}. It aborts if bi∗ ∈ {0, 1}.

Game0 This game is identical to game Real except that algorithm K1 does not receive ˆU as a input but
Game1 This game is identical to Game0 except that the simulator picks a random i∗ ∈ [n], and uses U
Game2 This game is identical to Game1 except that now the vectors ˆgi, i ∈ [n] and i (cid:54)= i∗, are uniform
Game3 This game is identical to Game2 except that now the vector ˆhi∗ is a uniform vector in ˆG3,

vectors in the space spanned by ˆgn+1, ˆgn+2.

sampled independently of ˆhn+1, ˆhn+2.

It is obvious that the ﬁrst two games are indistinguishable. The rest of the argument goes as

follows.
Lemma 8. Pr [Game1(A)] ≥ 1
n
Proof. The probability that Game1(A) = 1 is the probability that a) Game0(A) = 1 and b) bi∗ /∈
{0, 1}. The view of adversary A is independent of i∗, while, if Game0(A) = 1, then there is at least
one index (cid:96) such that b(cid:96) /∈ {0, 1}. The probability that the event described in b) occurs conditioned
on Game0(A) = 1, is greater than or equal to 1/n and the lemma follows.

Pr [Game0(A) = 1] .

30

q

q

, W1 ← Z3×(n−i∗)

Let ˆD := ( ˆA||ˆt). Adversary B picks i∗ ← [n], W0 ← Z3×(i∗−1)
In the real algorithm K1, the generator picks the matrix ∆ ∈ Z3×(n+2)

Lemma 9. There exists a U2-MDDH adversary B such that | Pr [Game1(A) = 1]−Pr [Game2(A) = 1]|
≤ AdvU2(B) + 3/q.
Proof. The adversary B receives an instance of the U2-MDDH problem, i.e. ( ˆA, ˆt), where ˆA is a
uniform matrix in ˆG3×2 and ˆt is either a uniform vector ˆt in ˆG3 or ˆt = ˆAγ, for γ ← Z2
q. The
simulator B deﬁnes all the parameters honestly, except that the U2-MDDH challenge is embedded
in the matrix ˆG.
, ˆgi∗ ← ˆG3,
and deﬁnes ˆG := ( ˆDW0||ˆgi∗|| ˆDW1|| ˆA).
. Although B but does
not know ∆, it can compute ˆ∆ = ˆGU−1, given that U is full rank and B sampled ( ˆU, U) itself.
It is easy to see that it can generate the rest of the elements of the common reference string using
ˆ∆, the discrete logarithms of ˆU, ˆH and ˆB.
In case ˆt is uniform over ˆG3, by the Schwartz-Zippel lemma det( ˆD) = 0 with probability at
most 3/q. Thus, with probability at least 1 − 3/q, ˆD is a full rank matrix and ˆG is uniform over
ˆG3×(n+2) as in Game1. On the other hand, in case ˆt = ˆAγ, {ˆgn+1, ˆgn+2} is a basis for Span( ˆD) and
each ˆgi, i ∈ [n], i (cid:54)= i∗, is in the space spanned by ˆgn+1, ˆgn+2 as in Game2.
Lemma 10. There exists a U2-MDDH adversary B such that | Pr [Game2(A) = 1]−Pr [Game3(A) = 1]|
≤ AdvU2(B).
Proof. The adversary B receives an instance of the U2-MDDH problem, i.e. ( ˆA, ˆt), where ˆA is a
uniform matrix of ˆG3×2 and ˆt is either a uniform vector ˆt in ˆG3 or ˆt = ˆAγ, γ ← Z2
q. The simulator
B deﬁnes (ˆhn+1||ˆhn+2) := ˆA and the rest of the columns of ˆH are honestly sampled with the sole
exception of ˆhi∗, which is set to ˆt. The rest of the parameters are computed by using B ← L3,2,
the matrix ∆ ∈ Z3×(n+2)

, and the matrix of discrete logarithms of ˆU.

q

q

It follows directly that adversary B perfectly simulates Game2 when ˆt = ˆAγ and Game3 when

ˆt is uniform the output of B.
1, P∗
Lemma 11. There exists a SDP adversary B, and soundness adversaries P∗
and
ΨDk,com, respectively, such that Pr [Game3(A) = 1] ≤ 6/q+AdvSDP(B)+AdvΨDk
(P∗
(P∗
2).
1)+AdvΨDk ,com
Proof. Let E be the event that {gi∗, gn+1, gn+2} is a basis of ˆG3 and {ˆhi∗, ˆhn+1, ˆhn+2} is a basis
of ˆG3 (when parameters are generated as in Game3). Clearly, Pr [E] = 1 − 6/q, and

2 for ΨDk

Pr [Game3(A) = 1] = Pr [Game3(A) = 1|Ec] Pr [Ec] + Pr [Game3(A) = 1|E] Pr [E]

≤ 6/q + Pr [Game3(A) = 1|E] .

1) + AdvΨDk ,com

Indeed, when E occurs, gi∗ ˆh(cid:62)

We next show that Pr [Game3(A) = 1|E] ≤ AdvSDP(B) + AdvΨDk
i∗ is linearly independent from {gi ˆh(cid:62)

(P∗
2), which
concludes the proof.
j : (i, j) ∈ [n + 2]2 \{(i∗, i∗)}}.
Additionally Game3(A) = 1 implies that bi∗ /∈ {0, 1}, while the veriﬁer accepts the proof produced
by A. Further, in this game, {ˆhi∗, ˆhn+1, ˆhn+2} is a basis of ˆG3, so we can deﬁne wv ∈ Z2
q, bi∗ ∈ Zq
as the unique coeﬃcients such that ˆd = bi∗ ˆhi∗ + wh,1
ˆhn+2. We distinguish three cases:
1) If ˆc∆ (cid:54)= ∆ˆc, we can construct an adversary B against the SDP Assumption. The SDP challenge
is the matrix ˆB included in the common reference string. The adversary computes ∆ˆc and
outputs ˆc∆ − ∆ˆc. This solves the SDP problem since both ˆc∆ and ∆ˆc pass the check 1) of the
veriﬁcation algorithm, so (∆ˆc − ˆc∆)(cid:62) ˆB = (0T 0T).

ˆhn+1 + wh,2

(P∗

31

2) If ˆc∆ = ∆ˆc but bi∗ (cid:54)= bi∗, this means that (ˆc∆, ˆd) is not in the space associated to crsΨDk ,com

. This
is because (bi∗ ˆgi∗, bi∗ ˆhi∗) is l.i. from {(ˆgi∗, ˆhi∗), (ˆgn+1, ˆhn+1), (ˆgn+2, ˆhn+2)} whenever bi∗ (cid:54)= bi∗.
Thus, we can construct an adversary P∗
2 against the soundness of ΨDk,com which outputs ˆσ as
a fake proof for (ˆc∆, ˆd).
3) If ˆc∆ = ∆ˆc, and bi∗ = bi∗, then bi∗(bi∗ − 1) (cid:54)= 0 (otherwise this would contradict the fact that
i /∈ {0, 1}). But in this case we can construct an adversary P∗
b∗
1 against the soundness of ΨDk
which outputs ˆσb(b−1) as a fake proof for ˆΠb(b−1). Indeed, Πb(b−1) /∈ Span({Ci,j : (i, j) ∈ In,2})
given that the coordinate of Πb(b−1) in gi∗ ˆh(cid:62)

i∗ is bi∗(bi∗ − 1) (cid:54)= 0.

This concludes the proof of soundness, we now prove zero-knowledge.

Zero-Knowledge.

– S1(Γ, ˆU): The simulator receives as input a description of a symmetric bilinear group Γ and
a matrix ˆU ∈ ˆG(n+2)×(n+2) sampled according to distribution DΓ . It generates and outputs
the common reference in the same way as K1, but additionally it also outputs the simulation
trapdoor

(cid:17)

τ =

H, ∆, τΨDk

, τΨDk ,com

.

– S2(crsP , ˆc, τ ): Compute ˆc∆ := ∆ˆc. Then pick random (wh,1, wh,2) and deﬁne

(cid:16)

0
...
0



ˆhn+1 + wh,2

ˆhn+2.

 = wh,1
d −(cid:88)

i∈[n]

(cid:62)

.

ˆhi

ˆΠb(b−1) := ˆc∆

d := H

Then set:

wh,1
wh,2

Finally, compute proofs ˆσb(b−1) and ˆσb−b for ˆΠb(b−1) and (ˆc∆, ˆd) using τΨDk

and τΨDk ,com

.

Lemma 12. The proof system is perfect quasi-adaptive zero-knowledge.
Proof. First, note that the vector ˆd ∈ ˆG3 output by the prover and the vector output by S2 follow
exactly the same distribution. This is because the rank of ˆH is 2. In particular, although the
simulator S2 does not know b ∈ {0, 1}n, there exist wh,1, wh,2 ∈ Zq such that ˆd = H

. On

 b

wh,1
wh,2

the other hand, it is obvious by construction that ˆΠb(b−1) is uniquely determined by ˆc, ˆd and the
rest of the argument follows from the perfect zero-knowledge property of ΨDk

and ΨDk,com.

32

C.4 Eﬃciency

When Dk = L2, our proofs consist of 6 group elements for ˆc∆ and ˆd, 9 group elements for ˆΠb(b−1),
and 4 group elements for ˆσb(b−1) and ˆσb−b. The whole proof consist of 19 elements of ˆG.

The CRS consists of 9 group elements for each ˆCi,j, which sums up to a total of 9((n + 2)2 − n).
To represent ˆU we need 2(n + 1) group elements, 3(n + 2) elements for matrix ˆG, 3(n + 2) elements
for ˆH, 2((n + 2)2 − n) + 33 elements for crsΨDk
, and 4 + 2(n + 2)
elements for ˆB, ˆB∆. The whole CRS needs a total of 11n2 + 45n + 135 elements of ˆG.

, 2n + 36 elements for crsΨDk ,com

The veriﬁer computes 2n + 10 pairings in the ﬁrst step of the veriﬁcation algorithm, 18 pairings
in the second step, 38 pairings in the last step. The whole veriﬁcation algorithm requires 2n + 66
pairing computations.

D Complete Description of Applications

D.1 More Eﬃcient Proof of Membership in a List of Vectors

√
For our proof of membership in a (witness samplable, static) list of size Θ( 3
n) which we describe
next, we use as a building block our improvement of the proof of membership in a list of Chandran
et al. extended to vectors, i.e. to the case where L = (ˆl1, . . . ,ˆln) is a list of vectors of length (cid:96). In
such a proof, we show that some commitment ˆc opens to a vector ˆlα, where α = (iα, jα) (recall
that (i, j) =
1. Compute GS commitments in ˇH to b1 . . . , bm and b(cid:48)
2. Compute a proof that bi ∈ {0, 1} and b(cid:48)

m, where bi = 1 if i = iα and 0
j ∈ {0, 1} for all i, j ∈ [m], using the proof system of

j = 1 if j = jα, and 0 otherwise.

otherwise, and b(cid:48)

n(i − 1) + j).

1, . . . , b(cid:48)

√

Sect. 5.3.

j = 1.

j∈[m] b(cid:48)

4. Compute GS commitments to each coordinate of ˆx1 := ˆl(iα,1), . . . , ˆxm := ˆl(iα,m).

i∈[m] bi = 1 and(cid:80)

3. Compute GS proofs that(cid:80)
5. Compute an aggregated GS proof that the equations ˆxj = (cid:80)
6. Compute a GS proof that ˆlα =(cid:80)
in Step 4. More speciﬁcally, to aggregate the proof of the equations ˆxj =(cid:80)

We emphasize that the CRS depends on the list L. This is necessary to aggregate the proofs as
i∈[m] biˆl(i,j) , j ∈ [m]
(that is, a total of (cid:96)k equations), we need to include in the CRS some information which depends
on the coordinates of ˆl(i,j) as explained in Sect. 5.3.

i∈[m] biˆl(i,j), for all j ∈ [m], are

satisﬁed, as detailed in Sect. 4.

j ˆxj is satisﬁed.

j∈[m] b(cid:48)

Theorem 11. If L is witness samplable, the above protocol is a perfectly complete, computationally 
sound, and computationally zero-knowledge proof system for the language of commitments to
elements from the list L.

Proof. Completeness follows directly from the completeness of the building blocks. Soundness follows 
directly from the perfect soundness of GS proofs together with the computational soundness of
aggregation of GS proofs. For computational zero-knowledge, if crsGS := (Γ, ˆu1, ˆu2, ˇv1, ˇv2) is the GS
common reference string in the soundness setting as deﬁned in Sect. 2.2, switch to a game where
ˇv1 = ˇv2. Under the DDH Assumption in ˇH, the new CRS is computationally indistinguishable

33

j = 0 for all i, j ∈ [m]. In step
from the original CRS. In a simulated proof, commit to bi = 0, b(cid:48)
2, simply compute a real proof. In step 3, use the GS simulation algorithm (with trapdoor ) to
simulate the proof. In Step 4, set ˆxj = ˆ0. Finally, in step 6, simulate a proof using . It is not hard
to see that such a proof can be simulated even without knowledge of an opening of ˆc.

D.2 A Θ( 3√

n) Proof of Membership in a Witness Samplable and Static List

We give a proof of membership in a list with improved asymptotic proof size when the list is drawn
from a witness samplable distribution and the CRS depends on the list.
The main idea is to combine the previous proof of membership in a list with a Split Kernel Assumption.
 Speciﬁcally, the CRS includes a matrix ˇA, A ← Dm,2, whose rows are denoted ˇa1, . . . , ˇam
and a list

 ∈ ˆG2×m2

,

√
where m := 3
commitment ˆc opens to some ˆlα ∈ L = (ˆl1, . . . , ˆln) and (iα, jα, kα) are such that α = (iα, jα, kα).

n, (i, j, k) = m2(i − 1) + m(j − 1) + k ∈ [n]. As before, the goal to prove is that a

aiˆl(i,m,m)

aiˆl(i,1,1),

i∈[m]

i∈[m]

L(cid:48) :=

(cid:88)

i∈[m]

(cid:88)

aiˆl(i,1,2), . . . ,

i∈[m] aiˆl(i,jα,kα) such that α = (iα, jα, kα).

(cid:88)
1. Commit to ˆy :=(cid:80)
4. Compute a GS proof for the equations ˆyˇh =(cid:80)
7. Compute GS proofs for the satisﬁability of equations(cid:80)
The ﬁrst step is to commit to ˆy :=(cid:80)
ˆy ∈ L(cid:48). The next step is to commit to ˆzi := ˆl(i,jα,kα) and prove that(cid:80)
GS commitments to bi, i ∈ [m], and prove that(cid:80)
i∈[m] bi ˆzi = ˆlα,(cid:80)

2. Using the proof described in Sect. D.1, show that ˆy is an element of L(cid:48).
3. Compute commitments to ˆzi := ˆl(i,jα,kα), for each i ∈ [m].
i∈[n] ˇai ˆzi.
5. Compute GS commitments in ˇH to b1 . . . , bm ∈ {0, 1}, where bi = 1 if i = iα and 0 otherwise.
6. Using our proof system from Sect. 5.3 prove that bi ∈ {0, 1} for all i ∈ [m].

i∈[m] bi = 1 and ˆlα =(cid:80)

i∈[m] bi ˆzi.

i∈[m] aiˆl(i,jα,kα) and use the previous proof system to prove
i∈[m] ˇai ˆzi = ˇhˆy holds. Finally,
steps 5 and 6 prove that ˆlα is an element of the list (ˆz1, . . . , ˆzm). For the last statement, compute
i∈[m] bi = 1 and bi ∈ {0, 1}.11

Theorem 12. If L is witness samplable, the above protocol is a perfectly complete, computationally 
sound, and computationally zero-knowledge proof system for the language of commitments to
elements from the list L.

Completeness follows directly from the completeness of the building blocks.

Proof. Completeness follows directly from the completeness of the building blocks. Soundness can
be argued as follows. If the list is witness samplable, the CRS can be generated given an instance
of the Dm,2 − SKerMDH Assumption, ( ˆA, ˇA). By the soundness of the extension of the proof
i∈[m] aiˆl(i,j,k) for some j, k ∈ [m]. Because
i∈[m] ˇaiˆl(i,j,k). It

of Chandran et al. of Sect.D.1, it holds that ˆy = (cid:80)
of the perfect soundness of GS proofs it must hold that (cid:80)

i∈[m] ˇai ˆzi = ˆyˇh = (cid:80)

√
11 Such statement can also be proven using again the proof of membership in a list, and the proof will be of size
Θ( 6
n). Note this is not exactly a proof of membership in a list, since only the commitments to the elements in
the list are public. However, it is not hard to construct a proof system for that statement using the same ideas as
Chandran et al.

34

Soundness of the last step implies that bi ∈ {0, 1}, for all i ∈ [m], and that(cid:80)
there exists a unique i ∈ [m] such that bi = 1. Finally, ˆlα = (cid:80)

must also be the case that ˆz1 = ˆl(1,j,k), . . . , ˆzm = ˆl(m,j,k), because otherwise the pair ( ˆρ, ˇ0), where
ˆρ := (ˆz1 − ˆl(1,j,k), . . . , ˆzm − ˆl(m,j,k)) is a solution to the Dm,2-SKerMDH challenge, as ˆρ ˇA = ˇ0 ˆA.
i∈[m] bi = 1. Therefore,
i∈[m] bi ˆzi implies that ˆc opens to

ˆlα = ˆzi = ˆl(i,j,k). Zero-knowledge follows from the same argument as in the proof of Theorem 11.

E Structure Preserving Linearly Homomorphic Signatures

Linearly-homomorphic structure preserving signatures [1,7] enable to sign group elements in G,
where G is a group and to publicly derive signatures of new elements which are a linear combination
of other signed messages. We take the deﬁnition from [26], except that we do not identify the
elements of G with vectors in ˆGn, for some group ˆG. The reason is that G might be some space of
the form ˆGm × ˇHn.

Deﬁnition 6 (SPLHS scheme). A linearly homomorphic structure-preserving signature scheme
over the group G consists of a tuple of eﬃcient algorithms Φ=(SignGen, Sign, SignDerive, Verify)
for which the message space is M := G, with the following speciﬁcations.
SignGen(1λ, n) : is a randomized algorithm that takes as input a security parameter λ ∈ N and an
integer n and outputs a key pair (pk , sk ). The public key pk speciﬁes a Zq vector space G of
dimension n.
Sign(sk , m): is a possibly probabilistic algorithm that takes as input a private key sk and m ∈ G.
It outputs a signature σ ∈ G.
SignDerive(pk ,{ωi, σi, mi}i∈[(cid:96)]): is a (possibly probabilistic) signature derivation algorithm. It takes
as input a public key pk as well as (cid:96) pairs (ωi, σi), each of which consists of a weight ωi ∈ Zq

and a signature σi ∈ G. The output is a signature σ ∈ G on the vector m =(cid:80)

i∈[(cid:96)] ωimi.

Verify(pk , m, σ): is a deterministic algorithm that takes in a public key pk , a signature σ, and a

vector m. It outputs 1 if σ is deemed valid and 0 otherwise.
Correctness is expressed by imposing that, for all security parameters λ ∈ N, all integers n ∈

poly(λ) and all pairs (pk , sk ) ← SignGen(1λ, n), the following holds:
1. For all m ∈ G, if σ = Sign(sk , m), then we have Verify(pk , m, σ) = 1.
2. For any (cid:96) > 0 and any set of triples {(ωi, σi, mi)}i∈[(cid:96)], if Verify(pk , mi, σi) = 1 for each i ∈ [(cid:96)],

then Verify(pk ,(cid:80)

i∈[(cid:96)] ωimi, SignDerive(pk ,{(ωi, σi)})) = 1

In order to get a uniform deﬁnition for diﬀerent types of forgery, we will say that a pair (m∗, σ∗)
is a forgery if P (m∗, Q) = 1, where P is a predicate on (m∗, Q) and Q is the set of reveal queries
made by the adversary. We stress that the predicate P is not always eﬃciently computable. For
instance, for the scheme of Libert et al. ([26]), this predicate is 1 iﬀ m∗ is in the linear span of
previous queries, and this is, in general, hard to decide in the group G (although it might be easy
for some set Q).

Deﬁnition 7. A SPLHS scheme Φ = (SignGen, Sign, Verify, SignDerive) is secure against Type P
adversaries if no PPT adversary has non-negligible advantage in the game below:
1. The adversary A chooses an integer n ∈ N and sends it to the challenger who runs SignGen(1λ, n)

and obtains (pk , sk ) before sending pk to A.

35

2. On polynomially-many occasions, A can interleave the following kinds of queries.

Signing queries: A chooses a vector m ∈ Gen. The challenger picks a handle h and computes

⊥ if one of these does not exist. Otherwise, it computes m = (cid:80)

σ ← Sign(sk , m). It stores (h, m, σ) in a table T and returns h.
Derivation queries: A chooses a vector of handles h = (h1, . . . , h(cid:96)) and a set of coeﬃcients 
{ωi}i∈[(cid:96)]. The challenger retrieves the tuples {(hi, mi, σi)}i∈[(cid:96)] from T and returns
i∈[(cid:96)] ωimi and runs σ ←
SignDerive(pk ,{(ωi, σi)}i∈[(cid:96)]). It also chooses a handle h, stores (h, m, σ) in T and returns
h to A.
challenger returns ⊥. Otherwise, it returns σ to A and adds (m, σ) to the set Q.
3. A outputs a signature σ∗ and a vector m∗. The adversary A wins if P (m∗, Q) = 1.

Reveal queries: A chooses a handle h. If no tuple of the form (h, m, σ) exists in T , the

As advantage is its probability of success taken over all coin tosses.

Libert et al. also used a set T of tags in order to add up many instances of their signature

scheme in only one. For simplicity, we omit this parameter.

E.1 One-Time LHSPS Signatures in Diﬀerent Groups

The one-time linearly homomorphic signature of Libert, Peters and Yung [27] implies a QA-NIZK
Argument for linear spaces. Similarly, our constructions of QA-NIZK proofs for membership in
concatenated subspace and for sum in subspace (in the case where the space is not from a witness
samplable distribution) also have an equivalent one-time structure preserving signature scheme
with diﬀerent security properties.

In particular, for subspace concatenation, “one-time” means that the adversary is unable to
sign vectors which are not in the span of previously signed vectors, namely, the adversary cannot
output a signature for a pair (ˆx∗, ˇy∗) ∈ ˆGm × ˇHn if ((x∗)(cid:62)||(y∗)(cid:62)) is linearly independent from the
i ), i ∈ [qs], (the concatenation of two vectors), where (ˆxi, ˇyi) are the signing queries
vectors (x(cid:62)
of the adversary. The discussion for the scheme which results from our Sum-in-Subspace QA-NIZK
proof, results in a diﬀerent notion of “one-time” — this is captured in the security deﬁnition by a
diﬀerent predicate P —, see discussion below.

i ||y(cid:62)

In either case, the size of the resulting signatures is (k + 1)(g + h) under the SKerMDH Assumption,
 but if security against random message attacks is suﬃcient (meaning that the signatures in
the set Q which are seen by the adversary are sampled uniformly at random), the signature size
can be reduced to k(g + h) (essentially, in this case one can sample A from Dk). This is inspired by
the one-time constructions of structure-preserving signatures of [24] secure against random message
attacks. We omit any further discussion of this case, as it is a straightforward generalization of our
QA-NIZK proofs in the witness samplable setting using the ideas of [24].
Our construction is based on the SKerMDH Assumption introduced in section 2. Following the
syntactic deﬁnition of section E, our scheme assumes G = ˆGm × ˇHn and the length of the messages
is n + m.
– SignGen(1λ, m, n): Let (q, ˆG, ˇH, T, e, ˆg, ˇh) ← Gena(1λ). Choose A ← Dk, Λ, Ξ ← Z(k+1)×m
AΛ := Λ(cid:62)A, AΞ := Ξ(cid:62)A The secret key is sk = (Λ, Ξ), while the public key is deﬁned to be

,

q

pk = ( ˆA, ˆAΞ , ˇA, ˇAΛ) ∈ ˆG(k+1)×k × ˆGm×k × ˇH(k+1)×k × ˇHm×k.

36

– Sign(sk, (ˆx, ˇy)): To sign a vector (ˆx, ˇy) ∈ ˆGm × ˇHm, pick z ← Z(k+1)

q

( ˆρ, ˇσ) ∈ ˆG(k+1) × ˇH(k+1), deﬁned as:

and output the pair

– SignDerive(pk,{(ωi, ˆρi, ˇσi)}(cid:96)

pair ((cid:80)(cid:96)

i=1 ωi ˆρi,(cid:80)(cid:96)

i=1 ωi ˇσi) ∈ ˆG(k+1) × ˇH(k+1).

ˆρ := Λˆx + ˆz,

ˇσ := Ξˇy − ˇz.

i=1): given the public key pk, and (cid:96) tuples (ωi, ˆρi, ˇσi), output the

– Verify(pk, (ˆx, ˇy), ( ˆρ, ˇσ)) is a deterministic algorithm, that takes as input a public key pk, a

signature ( ˆρ, ˇσ) and returns 1 if and only if ( ˆρ, ˇσ) satisﬁes

ˆρ(cid:62) ˇA + ˇσ(cid:62) ˆA = ˆx(cid:62) ˇAΛ + ˇy(cid:62) ˆAΞ .

Correctness. If a signature is correctly generated then

ˆρ(cid:62) ˇA − ˆx(cid:62) ˇAΛ = ˆz(cid:62) ˇA

ˇσ(cid:62) ˆA − ˇy(cid:62) ˆAΞ = −ˇz(cid:62) ˆA.

Therefore the veriﬁcation algorithm outputs 1 on a correctly generated signature. The proof of
correctness of the signature derivation algorithm follows a similar argument.
Let Q = {(ˆxi, ˇyi)}i∈[qs] be some set of elements of ˆGm × ˇHn. We deﬁne the predicate P as
i ||y(cid:62)
P ((ˆx, ˇy), Q) = 1 iﬀ (x(cid:62)||y(cid:62)) ∈ Z2m
Theorem 13. The signature scheme is Type P unforgeable if the SKerMDH Assumption holds in
ˆG, ˇH.

is not in the space spanned by {(x(cid:62)

i ) : i ∈ [qs]}.

q

The argument is almost identical to [26].
Proof. We show how to construct an algorithm B which takes as input an instance ( ˆA, ˇA) of the
SKerMDH Assumption and outputs a pair of vectors (ˆr, ˇs) ∈ ˆG3 × ˇH3, r (cid:54)= s, such that ˆr(cid:62) ˇA = ˇs(cid:62) ˆA
given oracle access to a forger F against the signature scheme (see Sect. E).

Algorithm B starts by honestly running the key generation algorithm using a randomly chosen
sk = (Λ, Ξ). Any signature query of F on a vector (ˆx, ˇy) is honestly answered by B, by running
the signing algorithm. The game ends with F outputting a vector (ˆx∗, ˇy∗) with a valid signature
( ˆρ∗, ˇσ∗). At this point, B computes its own signature ( ˆρ†, ˇσ†) using the secret key sk := (Λ, Ξ).
The adversary B will output as a response to the SKerMDH challenge the pair ( ˆρ∗ − ˆρ†, ˇσ† − ˇσ∗).
We now see that, with overwhelming probability, this is a valid answer to the SKerMDH challenge.
 Indeed, since both signatures satisfy the veriﬁcation equation, we can subtract the veriﬁcation
equation of each pair, obtaining:

( ˆρ∗ − ˆρ†)(cid:62) ˇA = ( ˇσ† − ˇσ∗)(cid:62) ˆA

Therefore, all we need to argue is that ρ∗ − ρ† (cid:54)= σ† − σ∗ with overwhelming probability. This is
equivalent to show that the probability that ρ∗ + σ∗ = ρ† + σ† is negligible. The key point of the
argument is that

ρ† + σ† = Λx∗ + Ξy∗ =(cid:0)Λ Ξ(cid:1)(cid:18)x∗

(cid:19)

y∗

(cid:18)x∗

(cid:19)

is information theoretically hidden to F.

is independent of all previous queries, then there is some information about(cid:0)Λ Ξ(cid:1) which is

The rest of the argument is identical to [26]. The argument goes as follows: since, by assumption,
y∗
information theoretically hidden. Thus, ρ† + σ† is information theoretically hidden and from the
adversary’s point of view it is equally likely that it has any out of q potential values.

37

Signing the Sum of Two Linear Spaces. When m = n, we can adapt the previous construction to
a diﬀerent forgery condition namely, we can prove security against a diﬀerent type of adversary.
Namely, in [26] the scheme is secure against an adversary whose goal is to output a forgery for a
message which is linearly independent from all of its signing queries. In our case, we require that the
adversary cannot output a signature for a pair (ˆx∗, ˇy∗) ∈ ˆGm× ˇHm if x∗ +y∗ is linearly independent
from the vectors xi + yi, i ∈ [qs], where (ˆxi, ˇyi) are the signing queries of the adversary.
learns Λx∗ + Ξy∗ = Λ(x∗ + y∗), and identically the same argument follows.

Our construction is like the previous one taking Ξ = Λ. Indeed, in this case the adversary only

F The Split Kernel Assumption

In this section we discuss in more detail the new computational assumption introduced in Sect. 2.1.

We ﬁrst note that it implies the Kernel MDH Assumption.

Lemma 13. D(cid:96),k-SKerMDH ⇒ D(cid:96),k-KerMDH ˇH.
Proof. Suppose there exists an adversary B against the D(cid:96),k-KerMDH ˇH assumption. We show how
to construct an adversary A against the D(cid:96),k-SKerMDH Assumption. Adversary A receives as a
challenge ( ˆA, ˇA) and forwards ˇA to B, who outputs with non-negligible probability a vector ˆr such
that ˆr(cid:62) ˇA = 0T. Then A simply outputs (ˆr, ˇ0) as a solution to the D(cid:96),k-SKerMDH challenge.

We prove that the reciprocal is true in the generic bilinear model. A rough idea of the proof

was given already in Sect. 2.1, here we give the formal argument.

We use the natural generalization of Shoup’s generic group model [34] to the (a)symmetric
bilinear setting, as it was used for instance in [6]. In such a model an adversary can only access
elements of ˆG, ˇH or T via a query to a group oracle, which gives him a randomized encoding of the
queried element. The group oracle must be consistent with the group operations (allowing to query
for the encoding of constants in either group, for the encoding of the sum of previously queried
elements in the same group and for the encoding of the product of pairs in ˆG × ˇH. More details,
can be found for instance in [6].
Lemma 14. If D(cid:96),k-KerMDH holds in generic symmetric bilinear groups, then D(cid:96),k-SKerMDH holds
in generic asymmetric bilinear groups.

Proof. Suppose there is an adversary A in the asymmetric generic bilinear group model against the
D(cid:96),k-SKerMDH assumption. We show how to construct an adversary B against the D(cid:96),k-KerMDH ˇH
Assumption in the symmetric generic group model.
Adversary B has oracle access to the randomized encodings σ : Zq → {0, 1}n, and σT : Zq →
{0, 1}n. It receives as a challenge {σ(aij)}1≤i≤(cid:96),1≤j≤k.
Adversary B simulates the generic hardness game for A as follows. It deﬁnes encodings ξ1 : Zq →
{0, 1}n, ξ2 : Zq → {0, 1}n and ξT : Zq → {0, 1}n as ξ1 = σ, ξT = σT and ξ2 a random encoding
function. B keeps a list LA with the values that have been queried by A to the group oracle. The
list is initialized as LA = {{(Ai,j, ξ1(aij), 1), (Ai,j, ξ2(aij), 2)}1≤i≤(cid:96),1≤j≤k}, where ξ2(aij) ∈ {0, 1}n
are chosen uniformly at random conditioned on being pairwise distinct. Adversary B also keeps
a list LB with the queries it makes to its own group oracle. The list LB is initialized as LB =
{{(Ai,j, σ(aij), 1)}1≤i≤(cid:96),1≤j≤k}

38

Each element in the list LA is a tuple (Pi, si, xi), where Pi ∈ Zq[A11, . . . , A(cid:96)k], xi ∈ {1, 2, T}
and si = ξxi(Pi(a11, . . . , a(cid:96)k)). The polynomial Pi is one of the following: a) Pi = Aij, i.e. it is one
of the initial values in the query list LA or b) a constant polynomial or c) Pi = Pc + Pd for some
(Pc, sc, x), (Pd, sd, x) ∈ LA or d) Pi = PcPd for some (Pc, sc, 1), (Pd, sd, 2) ∈ LA, xi = T . For LB
the same holds except that xi ∈ {1, T} and except that d) is changed to: d) Pi = PcPd for some
(Pc, sc, 1), (Pd, sd, 1) ∈ LB and xi = T .

restrictions described above. If (Pi, xi) was queried before, it replies with the same answer si.

Without loss of generality we can identify the queries of A with pairs (Pi, xi) meeting the
Else, when B receives a (valid) query (Pi, xi), if xi ∈ {1, T} it simply forwards the query to its
own group oracle, who replies with si. Then (Pi, si, xi) is appended to LB and to LA. If xi = 2, then
it forwards the query to its own group oracle as (Pi, 1). When it receives the answer si, B appends
(Pi, si, 1) to LB and it looks for the set S of all tuples (Pj, sj, 1) ∈ LB, Pj (cid:54)= Pi, such that sj = si.
For every tuple in S, B checks if there is some ˜s such that (Pj, ˜s, 2) is in LA (note that, because of
the way LA is constructed, if such ˜s exists it is the same for all Pj).

If such ˜s exists, it appends (Pi, ˜s, 2) in LA and it replies with ˜s. Else it chooses some ˜s uniformly
at random conditioned on being distinct from all other values s such that there exist some P such
that (P, s, 2) is in LA. Finally, it appends (Pi, ˜s, 2) in LA.
Finally, A will output as a solution to the challenge a pair sq, sr such that (Q, sq, 1), (R, sr, 2) ∈
LA. Because of the way LA and LB were constructed, there exists some s(cid:48)
LA. B queries its group oracle for (R − Q, 1) and obtains as a reply some string sR−Q. Finally, it
outputs sR−Q as a solution to its challenge. It easily follows that A and B have exactly the same
probability of success.

r such that (Q, sq, 1), (R, s(cid:48)

r, 1) ∈

q, is computationally indistinguishable from (ˆu, ˇu), u ← Z3

Finally, we note that the L2-SKerMDH Assumption is implied by a decisional assumption introduced 
in [28]. The assumption says that, given ( ˆA, ˇA), where A ← L2, the vector ( ˆAw, ˇAw),
w ← Z2
q. The proof is analogous to the
proof that D(cid:96),k-MDDH ⇒ D(cid:96),k-KerMDH. Suppose that (ˆr, ˇs) is a solution to the L2-SKerMDH Assumption,
 then ˆr(cid:62) ˇAw− ˇs(cid:62) ˆAw = (ˆr(cid:62) ˇA− ˇs(cid:62) ˆA)w = 0T, while ˆr(cid:62) ˇu− ˇs(cid:62) ˆu = 0T only with negligible
probability whenever r (cid:54)= s.

39

