The Provable Security

of Graph-Based One-Time Signatures

and Extensions to Algebraic Signature Schemes

Alejandro Hevia(cid:1) and Daniele Micciancio(cid:1)(cid:1)

Dept. of Computer Science & Engineering, University of California, San Diego,
{ahevia,daniele}@cs.ucsd.edu, www-cse.ucsd.edu/users/{ahevia,daniele}

9500 Gilman Drive, La Jolla, California 92093, USA,

Abstract. Essentially all known one-time signature schemes can be described 
as special instances of a general scheme suggested by Bleichenbacher 
and Maurer based on “graphs of one-way functions”. Bleichenbacher 
and Maurer thoroughly analyze graph based signatures from a
combinatorial point of view, studying the graphs that result in the most
eﬃcient schemes (with respect to various eﬃciency measures, but focusing 
mostly on key generation time). However, they do not give a proof of
security of their generic construction, and they leave open the problem
of determining under what assumption security can be formally proved.
In this paper we analyze graph based signatures from a security point of
view and give suﬃcient conditions that allow to prove the security of the
signature scheme in the standard complexity model (no random oracles).
The techniques used to prove the security of graph based one-time signatures 
are then applied to the construction of a new class of algebraic
signature schemes, i.e., schemes where signatures can be combined with
a restricted set of operations.

1 Introduction

One-time signatures [Lam79] are digital signature schemes where the signer is
restricted to sign a single document. They are interesting cryptographic primitives 
because they allow to solve many important cryptographic problems, and
at the same time oﬀer substantial eﬃciency advantages over regular digital signature 
schemes (cf. [RSA78,Sch90,GMR88,BM92]), especially with respect to
signing, veriﬁcation and key generation time. Applications of one time signatures
include the design of regular signature schemes [Mer87,Mer90,BM92,DN94], on-
line/oﬀ-line signatures [EGM96], digital signatures with forward security properties 
[BM99,AR00,MMM02], eﬃcient broadcast authentication protocols [Per01]
[Roh99], network routing protocols [HPT97], and more. The ﬁrst one-time signature 
scheme was proposed by Lamport [Lam79] and (in an interactive setting) by
Rabin [Rab78]. The idea of the basic scheme of Lamport is very simple: given a

(cid:1) Supported in part by NSF grant CCR-0093029 and Mideplan Scholarship.
(cid:1)(cid:1) Supported in part by NSF Career Award CCR-0093029.

Y. Zheng (Ed.): ASIACRYPT 2002, LNCS 2501, pp. 379–396, 2002.
c(cid:1) Springer-Verlag Berlin Heidelberg 2002

380

Alejandro Hevia and Daniele Micciancio

one-way function f, one selects two random strings x0, x1 (which constitute the
secret key), and publishes f(x0), f(x1). Then, a single bit message b ∈ {0, 1} can
be signed by revealing xb. Veriﬁcation is performed in the obvious way. Notice
how the signing process is almost instantaneous, while veriﬁcation only involves
a single application of a one-way function. Key generation is almost as eﬃcient,
requiring only two applications of the one-way function.

Since Lamport’s original proposal, many extensions and improvements have
been suggested [MM82, Mer82, Mer87, Vau92, BC93, EGM96, BM94, BM96b,
BM96a, Per01]. The improvements usually involve iterating the application of
the one-way function, or revealing multiple values as part of a signature. All these
schemes (with the exception of Perrig’s) can be described as special instances of a
general scheme suggested by Bleichenbacher and Maurer [BM94,BM96b,BM96a],
based on the use of “graphs of one-way functions”. These are directed acyclic
graphs or DAGs (see next section for a formal deﬁnition) with values associated 
to the vertices computed according to one-way functions associated to the
edges (see Figure 1). Messages are signed by revealing the values for some of
the vertices, and signatures veriﬁed using the publicly available one-way functions.
 As pointed out in [BM94,BM96b,BM96a] DAG-based one-time signatures
schemes generalize and have potential advantages over schemes simply based on
the iterated application of the one-way function (which correspond to graphs
consisting of a collection of disjoint chains). Unfortunately, one-wayness does
not seem a suﬃciently strong assumption to guarantee the security of the graph
based one time signature schemes. In fact, [BM94] and subsequent papers only
study the combinatorial properties of the graphs, e.g., trying to maximize the
size of the message space that can be signed using graphs with a predetermined
number of vertices. The issue of determining suﬃcient security assumptions on
the “one-way function” f, and proving the security of graph based signatures in
the standard complexity model is left open in [BM94,BM96b,BM96a].

Our Contributions: In this paper we analyze the security of graph based
signatures in order to put them on the ﬁrm grounds of the standard computational 
complexity security model. We show that under standard assumptions the
security of graph based signatures can be formally proved. In order to achieve
provable security, we adopt an approach in the deﬁnition of graph based signatures 
that is dual to the one used in [BM94]. Namely, instead of associating
values to the nodes of a graph and functions to the edges, we propose to associate 
values to the edges and functions to the nodes (Figure 2 shows an example).
Then, we prove that if the functions associated to the nodes are regular collision
resistant (or simply universal one-way) hash functions and one-to-one pseudorandom 
generators, then the resulting one-time digital signature scheme is provably
hard to break. These primitives can be built starting from any one-way permutation.
 The regularity and one-to-one properties can be relaxed assuming that
the hash functions and pseudo-random generator only satisfy pseudorandomness
and collision resistant properties.

An important byproduct of this work is the use of a hybrid argument in a
novel way in our proof. Indeed, in order to prove the security of the signature

The Provable Security of Graph-Based One-Time Signatures

381

v5

f4

v4

f3

v3

v5

f2

v2

f1

v1

v4

f2

v3

v5

v2

f1

v1

Fig. 1. DAG where values are associated 
to vertices and functions to edges
(e.g. v2=f1(v1), v6=f2(v2), v4=f3(v3,v2),
v5=f4(v4)).

Fig. 2. DAG where values are associated
to edges and functions to vertices (e.g.
(v2,v5)=f1(v1),v4=f2(v3,v2)).

scheme, our analysis involves telling two distributions apart. However, a direct
hybrid argument cannot be used because the number of hybrid distributions may
be exponential on the security parameter. We show that by carefully setting a
total order relation on the hybrids, we can combine them into a small (polyno-
mial) number and the proof goes through. To the best of our knowledge this is
a novel use of hybrid argument and may be of independent interest.

Extensions: Graph-based one-time signatures can be extended to instantiate
a new type of signature scheme referred as algebraic signatures, originally suggested 
by Rivest [MR02]. An algebraic signature scheme is a signature scheme
in which computing signatures of unseen messages is allowed in a restricted
way. Associated to each algebraic signature scheme there is a set of functions
O = {f1, . . . , ft} (where each function fi maps messages into messages). The
fundamental property of algebraic signature schemes is that given signatures
sig(m1), ..., sig(mr) anyone can compute signature sig(fi(m1, . . . , mr)). Clearly,
algebraic signatures require the deﬁnition of a new notion of unforgeability.
Namely, an algebraic signature scheme is secure if no adversary can eﬃciently
compute signatures of messages that cannot be computed from m1, . . . , mr by applying 
the functions in O. (See Section 6 for details). Micali and Rivest [MR02],
and, recently, Bellare and Neven [BN02], presented constructions of transitive
signatures which allow to sign edges in an undirected graph in such a way that
computing signatures of the transitive closure of the signed edges does not require 
knowledge of the secret key. Similarly, Johnson et al. [JMSW02] studied
several cases where the signing algorithm is homomorphic with respect to a
binary operation fi.

Building on graph-based one-time signature schemes we give explicit constructions 
for algebraic signatures on sets which support union and subset operations 
and also union and super-intersection operations1. We see graph-based
1 The super-intersection of sets A and B, denoted A (cid:3) B, is the collection of all sets
S such that A ∩ B ⊆ S ⊆ A ∪ B.

382

Alejandro Hevia and Daniele Micciancio

algebraic signatures as an area that deserves further research, since it may lead
to eﬃcient and useful constructions.

2 Notation and Basic Deﬁnitions

In this section we review some deﬁnitions used throughout the paper. We start by
recalling some standard deﬁnitions about cryptographic primitives and directed
graphs.

2.1 Cryptographic Primitives

We ﬁrst recall the standard deﬁnition of security of signature schemes under
chosen-message attacks (cf. [GMR88]) adapted to the case of one-time signature
schemes. Then, we recall the (also standard) deﬁnitions of security of collisionresistant 
one-way hash functions (cf. [BR97]) and pseudorandom generators
(cf. [BM84,Yao82]).

One-Time Signature Scheme: Formally, a signature scheme consists of three
algorithms Σ = (KG, Sig, Vf). Given a security parameter k ∈ N, the key generation 
algorithm KG(k) outputs a pair of public and private keys (pk, sk); Sig is
the signing algorithm taking as input a key sk and a message m, and returning a
signature σ; Vf is the veriﬁcation algorithm taking as input a key pk, a message
m and a signature σ, and returning a boolean decision. The signing algorithm
may be randomized but the veriﬁcation algorithm is usually deterministic. It is
required that valid signatures are always accepted. A one-time signature scheme
is secure against existential forgery in a one-chosen-message attack if no computationally 
bounded adversary (forger), after obtaining the signature of a single
message of his choice, can output a (diﬀerent) message and a corresponding valid
signature, except with negligible probability.
Collision-Resistant Hash Functions: Let H be a family of functions. An
individual element in H is function H: R2 → R, for some ﬁx set R. The family
H is said to be collision-resistant if, for H randomly chosen in H, any computationally 
bounded adversary (collision-ﬁnder) can not ﬁnd two diﬀerent messages
m and m(cid:2) that map by H to the same value, except with negligible probability.
Furthermore, we say H is regular if it satisﬁes Pr
=
for all y ∈ R, and all H ∈ H.
Pr
Pseudorandom Generators: Let G: R → R2 be a deterministic function.
G is a pseudorandom generator if it no computationally bounded adversary
(distinguisher) can tell apart the output of G(x) on a random input x from a
truly random value on R2 with non-negligible probability. Also, a pseudorandom
generator G is one-to-one if there is no pair of distinct inputs x, x(cid:2) ∈ R, that
produce the same output on G.

H(X) = y : X R← R2

(cid:1)

(cid:2)

(cid:1)

Y = y : Y R← R

(cid:2)

The Provable Security of Graph-Based One-Time Signatures

383

8

5

9

2

4

11

10

7

1

0

6

3

8

C2

5

9

2

4

11

10

7

1

0

6

3

C1

Fig. 3. Example of a DAG G.

Fig. 4. Two cuts C1 (cid:8) C2 in G.

2.2 Graphs
A directed graph is a pair (V, E) where V is a ﬁnite set of vertices and E ⊆ V ×V
is the set of edges. A path of length (cid:22) ≥ 0 from v0 to v(cid:6) in G is a sequence of
vertices p = (v0, . . . , v(cid:6)) such that (vi−1, vi) ∈ E for all i = 1, . . . , (cid:22). If such a
path exists, we say that v0 is a predecessor of v(cid:6) and v(cid:6) is a successor of v0.
The sets of predecessors and successors of v are denoted Pred(v) and Succ(v),
respectively. A set of vertices S is predecessor closed if Pred(v) ⊆ S for all v ∈ S.
Similarly, S is successor closed if Succ(v) ⊆ S for all v ∈ S. A cycle is a path
(v0, . . . , v(cid:6)) of length (cid:22) ≥ 1 such that v0 = v(cid:6). A directed acyclic graph (DAG) is
a directed graph with no cycles.
The indegree of a vertex v is the number of edges (v(cid:2), v) ∈ E pointing to v,
the outdegree is the number of edges (v, v(cid:2)) ∈ E departing from v, and the total
degree is the sum of the indegree and the outdegree. Vertices with indegree 0 are
called sources, and vertices with outdegree 0 are called sinks. Vertices that are
neither sources nor sinks are called internal vertices. For simplicity, in this paper
we only considers DAGs with a single source v⊥ with outdegree 1, a single sink v(cid:5)
with indegree 1, and n > 0 internal nodes with total degree 3. For such graphs,
there are only two kind of internal vertices: expansion vertices with indegree 1
and outdegree 2, and compression vertices with indegree 2 and outdegree 1. So,
the sets of vertices of our graphs can be partitioned as V = VG ∪ VH ∪{v⊥, v(cid:5)},
where VG are the expansion vertices and VH the compression vertices. We also
ﬁx a total order relation (VG,≤) that extends the partial order deﬁned over VG
by the predecessor relation.
An example of DAG is depicted in Figure 3. Vertex 0 is the source, vertex 11
the sink, VH = {1, 2, 3, 4, 5} are compression vertices, and VG = {6, 7, 8, 9, 10}
are expansion vertices.
A cut in a graph (V, E) is a nontrivial partition C = (S, ¯S) of the vertices
such that S is predecessor closed (or, equivalently, ¯S is successor closed). The
set of cuts in a graph (V, E) is denoted Cuts(V, E), and it forms a partial order

Alejandro Hevia and Daniele Micciancio

384
where (S, ¯S) (cid:13) (S(cid:2), ¯S(cid:2)) if and only if S ⊆ S(cid:2) (or, equivalently, ¯S ⊇ ¯S(cid:2)). Notice
that since (S, ¯S) is nontrivial (i.e., both S and ¯S are not empty), and S, ¯S are
predecessor and successor closed, it is always the case that v⊥ ∈ S and v(cid:5) ∈ ¯S.
Therefore, a cut can be implicitly represented by a single set of vertices S with
the convention that if v⊥ ∈ S then (S) represents (S, V \ S), while if v(cid:5) ∈ S
then (S) represents (V \ S, S). For any cut C, the component of C containing
v⊥ (resp. v(cid:5)) is denoted S(C) (resp. ¯S(C)).
An edge e = (u, v) crosses a cut C = (S, ¯S) if u ∈ S and v ∈ ¯S. The set of
edges crossing C is denoted Edges(C) = E ∩ (S × ¯S). We consider graphs where
each edge is labeled with an element from some set R. The labels associated
to the edges are not totally independent, but must satisfy certain constraints.
Let G: R → R2 and H: R2 → R be two arbitrary functions. (Later on, we will
instantiate G with a pseudorandom generator and H with a collision resistant
hash function.) A labeling is a partial function λ from E to R, i.e., a function
λ: T → R where T ⊆ E. The domain T of the labeling is denoted dom(λ). We say
that λ is consistent (with respect to functions G and H) if values are computed
according to functions G and H, i.e.,
– for every expansion vertex with incoming edge e0 ∈ dom(λ) and outgoing
– for every compression vertex with incoming edges e0, e1 ∈ dom(λ) and outedges 
e1, e2 ∈ dom(λ), G(λ(e0)) = (λ(e1), λ(e2)).
going edge e2 ∈ dom(λ), λ(e2) = H(λ(e0), λ(e1)).
We are interested in labeling functions deﬁned over cuts. A labeled cut is a
labeling function σ such that dom(σ) is the set of edges of a cut, i.e., dom(σ) =
Edges(C) for some C ∈ Cuts(V, E). If σ is a labeling with domain Edges(C)
then we write σ: C. Similarly, we denote as {σ: C} the set of all labellings with
domain Edges(C). Notice that any function σ: Edges(C) → R is consistent, i.e.,
the edges of a cut can be labeled independently. Any labeled cut σ: C can be
uniquely extended to a consistent labeling deﬁned over all edges ending in ¯S(C).

Proposition 1. For any directed acyclic graph (V, E), cut C ∈ Cuts(V, E) and
labeling σ: Edges(C) → R, there exists a unique labeling, denoted [σ], such that
(1)
(2)
(3)
Moreover, [σ] can be eﬃciently computed from σ.

dom([σ]) = E ∩ (V × ¯S(C))
[σ] is consistent, and
[σ](v) = σ(v) for all v ∈ Edges(C).

Notice that for any two cuts C1 (cid:13) C2, the set Edges(C2) is contained in
V × ¯S(C1). Therefore, given a labeled cut σ1: C1 and a cut C2 such that C1 (cid:13) C2,
we can deﬁne a labeled cut σ2: C2 by restricting the domain of [σ1] to Edges(C2).

Deﬁnition 1. For any ordered pair of cuts C1 (cid:13) C2, we deﬁne a corresponding
projection operation Π C1
(or, simply, ΠC2 when C1 is clear from the context)
C2
that maps any labeled cut σ1: C1 to a corresponding labeled cut σ2: C2 obtained
by ﬁrst extending σ1 to [σ1], and then restricting the domain of [σ1] to the set
Edges(C2).

The Provable Security of Graph-Based One-Time Signatures

385

Notice that if C1 = (S1, ¯S1) and C2 = (S2, ¯S2), then σ2 = ΠC2(σ1) can be

computed from σ1 with at most |S2 \ S1| applications of functions G and H.
Example 1. Figure 4 depicts two example cuts S(C1) = {0, 1, 2, 3, 4} with
Edges(C1) = {(2, 5), (4, 7), (4, 6), (3, 6), (3, 8)}, and S(C2) = {0, 1, 2, 3, 4, 5, 8}
with Edges(C2) = {(8, 9), (5, 7), (4, 7), (4, 6), (3, 6)}. As a toy example, consider
R = Z10, H(x, y) def= x+y, and G(x) def= (x, x). If we choose {((2, 5), 3), ((4, 7), 9),
((4, 6), 5), ((3, 6), 2), ((3, 8), 8)} as a labeled cut σ:C1 in G, then it is easy to check
that the labeled cut deﬁned by Π C2
(σ) (the consistent extension of C1 onto C2)
is {((8, 9), 1), ((5, 7), 3), ((4, 7), 9), ((4, 6), 5), ((3, 6), 2)}.
C1

3 The GBOTS Construction

A graph based one-time signature (GBOTS) scheme is speciﬁed by a directed
acyclic graph (V, E), a function µ : M → Cuts(V, E) from a message space M to
the set of cuts of the graph, a length doubling function G : R → R2 and a family
H of length halving functions H : R2 → R. Function µ must satisfy the security
property that if m (cid:20)= m(cid:2), then the cuts µ(m) and µ(m(cid:2)) are incomparable, i.e.,
neither µ(m) (cid:13) µ(m(cid:2)) nor µ(m(cid:2)) (cid:13) µ(m). In particular, function µ is injective.
Examples of such functions are presented in [BM96b,BM96a].
The secret key of a GBOTS scheme consists of a labeled cut σ⊥:{v⊥} and a
hash function H ∈ H, both chosen uniformly at random. The corresponding public 
key is given by function H and the labeled cut σ(cid:5) = Π{v(cid:1)}(σ⊥). A signature
for a message m ∈ M is a labeled cut σ: µ(m). Message m is signed using secret 
key (H, σ⊥) setting σ = Πµ(m)(σ⊥). A message signature pair (m, σ: µ(m))
is veriﬁed using public key (H, σ(cid:5)) checking that Π{v(cid:1)}(σ) = σ(cid:5). A formal
speciﬁcation of the GBOTS scheme is given in Figure 5.

Algorithm KG(1k)
H R← H, σ⊥ R← {σ:{v⊥}}
σ(cid:2) ← Π{v(cid:1)}(σ⊥)
pk ← (H, σ(cid:2)), sk ← (H, σ⊥)
return (pk, sk)

Algorithm Sig(sk, m)
parse sk as (H, σ⊥)
σ ← Πµ(m)(σ⊥)
return σ : µ(m)

Algorithm Vf(pk, m, σ)

parse pk as (H, σ(cid:2))
if Π{v(cid:1)}(σ) = σ(cid:2)

return 1

else return 0

Fig. 5. Key Generation, Signing and Veriﬁcation algorithms for GBOTS scheme.

4 The Reduction

In this section we relate the security of GBOTS to the security of the underlying 
pseudorandom generator G and family of hash functions H. Formally, we
show how a forger adversary F that successfully attacks the one-time signature
scheme, can be used to build eﬃcient procedures to successfully attack G and H
as follows: an inverter algorithm IH that attempts to invert a randomly chosen

Alejandro Hevia and Daniele Micciancio

386
function H ∈ H; an inverter algorithm IG that attempts to invert function G;
a collision ﬁnder algorithm CH that on input H ∈ H attempts to ﬁnd a collision 
to H, and a distinguisher DG that attempts to tell random strings and
pseudorandom strings apart.
None of the adversaries IG,IH ,CH ,DG is individually guaranteed to work,
but we can bound the success probability of the forger F as a function of the
combined success probabilities of IG,IH ,CH ,DG. So, if G,H are cryptographically 
secure, then the GBOTS scheme is secure. In the rest of this section we
show how to build IG,IH ,CH ,DG given black box access to the forger F. The
success probabilities of these adversaries are analyzed in the following section.
Adversaries IG,IH ,CH ,DG all use the forger F in a speciﬁc way, common to
all four of them. So, we describe this general procedure A ﬁrst. This procedure
takes as input a hash function H, a node v, and a labeling σv: Pred(v). The task
is, given oracle access to the forger algorithm, compute a labeling σ(cid:2)
v: Succ(v).
In other words, A gets as input a labeling of the smallest cut containing v, and
tries to output a labeling for the biggest cut not containing v (where biggest and
smallest refer to the (cid:13) ordering relation).

Procedure A(H, v, σv) operates as follows:

1. Compute σ(cid:5) = Π{v(cid:1)}(σv).
2. Run F on input pk = (H, σ(cid:5)).
3. Let m ∈ M be the message output by F. If v (cid:20)∈ µ(m), then abort. Otherwise,
compute σm = Πµ(m)(σv) and continue to the next step.
4. Run F on input σm to get a forgery m(cid:2), σ(cid:2). We assume, without loss of generality,
 that F always outputs a valid message-signature pair, i.e., Π{v(cid:1)}(σ(cid:2)) =
σ(cid:5). If F cannot forge a signature, then it outputs (m, σm)
5. If v ∈ µ(m(cid:2)) then abort. Otherwise, compute and output σ(cid:2)
v = ΠSucc(v)(σ(cid:2)).
A few remarks follow. First, for any vertex v, Pred(v) (cid:13) {v(cid:5)}, so the projection 
operation in step 1 can always be performed. This produces a pair
pk = (H, σ(cid:5)) which is similar, but not necessarily identically distributed, to
a public key. In step 3, if v ∈ µ(m), then Pred(v) ⊆ µ(m) because cut µ(m) is
closed. So, unless execution is aborted, Pred(v) (cid:13) µ(m) and σm can be computed 
from σv. Similarly, in step 5, if execution does not abort, v (cid:20)∈ µ(m(cid:2)) and
µ(m(cid:2)) (cid:13) Succ(v). So, σ(cid:2)
v can be computed from σ(cid:2). Therefore, A always either
aborts or it succeeds, i.e., it outputs a cut σ(cid:2)
v) = σ(cid:5).
We use A to deﬁne IG, IH, CH and DG.

v: Succ(v) such that Π{v(cid:1)}(σ(cid:2)

Inverting H

4.1
Algorithm IH on input a hash function H and target value y ∈ R, chooses one
vertex v ∈ VH at random, and selects σv uniformly at random among all labeled
cuts σ: Pred(v) such that σ(e) = y, where e is the only edge departing from v.
Then algorithm IH calls A(H, v, σv). If A aborts, also IH aborts. Otherwise, let
v: Succ(v) be the signature output by A. The output of IH is σ(cid:2)
σ(cid:2)
v(e1),
where e0, e1 are the edges pointing to v.

v(e0); σ(cid:2)

The Provable Security of Graph-Based One-Time Signatures

387
We remark that IH may either abort, terminate successfully with a pre-image
of y under H, or fail, i.e., terminate without aborting, but with an output value
x0; x1 such that H(x0; x1) (cid:20)= y. The distinction between aborting execution and
failure to invert will be used in the analysis.

Inverting G

4.2
The algorithm to invert G is similar to IH. IG on input a target value (x1; x2) ∈
R2, chooses H ∈ H uniformly at random, picks one vertex v ∈ VG, and selects σv
uniformly among all labeled cuts σ: Pred(v) such that σ(e1) = x1 and σ(e2) = x2,
where e1, e2 are the edges departing from v. Then it calls A(H, v, σv). If A aborts,
v: Succ(v) be the signature output by A. The
also IG aborts. Otherwise, let σ(cid:2)
output of IG is σ(cid:2)
v(e0) where e0 is the edge pointing to v. As for IH, inverter IG
can either abort, terminate successfully, or fail.

4.3 Finding Collisions

In order to describe the collision ﬁnder algorithm we need the following lemma.
The proof is simple and can be seen in the full version of this paper [HM02].
The proof uses the assumption that G is one-to-one.
Lemma 1. For any cut C ∈ Cuts(V, E), and labellings σ : C and σ(cid:2) : C, if σ (cid:20)=
σ(cid:2) and Π{v(cid:1)}(σ) = Π{v(cid:1)}(σ(cid:2)), then there exists a compression node v not in C
with incoming edges e0, e1 such that ([σ](e0), [σ](e1)) and ([σ](e0), [σ](e1)) form
a collision, i.e., H([σ](e0), [σ](e1)) = H([σ](e0), [σ](e1)) and [σ](ei) (cid:20)= [σ(cid:2)](ei)
for some i ∈ {0, 1}.

The collision ﬁnder CH takes as input a hash function H, and selects a vertex
v ∈ VG ∪ VH uniformly at random. Notice that v ∈ VG and v ∈ VH happen with
the same probability because VG and VH have the same size. The rest of the
collision ﬁnder algorithm is similar to IG or IH, depending on whether v ∈ VG
or v ∈ VH.
If v ∈ VG, then CH chooses x ∈ R uniformly at random, computes (y1; y2) =
G(x), and picks σv uniformly at random among all labeled cuts σ: Pred(v) such
that σ(e1) = y1 and σ(e2) = y2, where e1, e2 are the edges departing from v.
Then it calls A(H, v, σv). If A aborts, also CH aborts. Otherwise, let σ(cid:2)
v: Succ(v)
be the signature output by A, and consider the cut Succ(v) \ {v}. Notice that
Succ(v) (cid:13) Succ(v)\{v} and Pred(v) (cid:13) Succ(v)\{v}. Therefore, we can compute
v). If σ (cid:20)= σ(cid:2), then
two labeling σ = ΠSucc(v)\{v}(σv) and σ(cid:2) = ΠSucc(v)\{v}(σ(cid:2)
compute a collision from σ and σ(cid:2) using Lemma 1.
If v ∈ VH, then CH chooses x0, x1 ∈ R uniformly at random, compute x2 =
H(x0, x1), and pick σv uniformly at random among all labeled cuts σ: Pred(v)
such that σ(e2) = y2. It then call A(H, v, σv). If A aborts, also IH aborts. Other-
v: Succ(v) be the signature output by A, and consider the cut Succ(v)\
wise, let σ(cid:2)
{v}. As before, Succ(v) (cid:13) Succ(v)\{v} and Pred(v) (cid:13) Succ(v)\{v}. Therefore,
we can compute two labeling σ = ΠSucc(v)\{v}(σv) and σ(cid:2) = ΠSucc(v)\{v}(σ(cid:2)
v).
If σ (cid:20)= σ(cid:2), then compute a collision from σ and σ(cid:2) using Lemma 1.

388

Alejandro Hevia and Daniele Micciancio

4.4 Distinguishing G
Finally we describe a possible distinguisher for G. On input x1, x2 ∈ R2, DG
picks a random vertex v ∈ V and a hash function H ∈ H. This time vertex
v is not selected with uniform probability, but with probability proportional
to |VG ∩ (Pred(v) \ {v})|. Then DG chooses a node u ∈ VG ∩ (Pred(v) \ {v})
uniformly at random, and computes σv as follows. Let {σ:∪u(cid:2)≤uPred(u(cid:2))} denote
the set of all labellings deﬁned over the union of cuts Pred(u(cid:2)) for all expansion
vertices u(cid:2) ≤ u in the predecessor set of v but not including v; in other words, it
denotes the union of cuts Pred(u(cid:2)) such that u(cid:2) ≤ u, and u(cid:2) ∈ VG∩(Pred(v)\{v}).
In this union, each labeling satisﬁes σ(e1); σ(e2) = x1; x2, where e1, e2 are the
edges departing from u. Distinguisher DG selects σu uniformly at random in
{σ:∪u(cid:2)≤uPred(u(cid:2))}, and computes σv = ΠPred(v)(σu). Notice that for all u(cid:2)
predecessor of v, Pred(u(cid:2)) ⊂ Pred(v), and the labeled cut σv can be computed
from σu.
Procedure A is run on input H, v, σv. If A aborts then DG outputs “random”,
while if A does not abort DG outputs “pseudorandom”.

5 Analysis
In this section we relate the success probability of the forger algorithm F to the
success probability of attacks to G and H. The following result states that if
G is a one-to-one pseudorandom generator and H is a regular collision-resistant
hash function family then the GBOTS scheme is existentially secure under one-
chosen-message attack.

Theorem 1. Let (V, E) be a directed acyclic graph, G a one-to-one pseudorandom 
generator, and H a regular collision resistant family of hash functions, and
consider the corresponding GBOTS scheme. Let F be a forger that succeeds with
probability δ. Then δ ≤ (αD +C +G +H)n where α ≤ n is the average number
of VG predecessors of a random vertex in the graph and G, H , C, D are the
success probabilities (or advantage) of adversaries IG, IH, CH, DG as deﬁned in
the previous section.

In order to prove the result, we ﬁrst show that the success probability of
the adversaries IG, IH and CH is tightly related to the aborting probability of
procedure A, when called on randomly chosen inputs. We make this statement
more precise below. First, we need some notation.
A labeled cut σ is said to be consistent with (v, y) ∈ V × (R2 ∪ R) if one
of two cases hold: (a) if v ∈ VG and y = y1; y2 ∈ R2 then σ(e1) = y1 and
σ(e2) = y2 where e1 and e2 are the edges departing from v, or (b) if v ∈ VH
and y ∈ R then σ(e) = y where e is the only edge departing from v. The set of
all labeled cuts σ consistent with (v, y) is denoted {σ : Pred(v)y}. In particular,
if either v ∈ VG and y = G(x) for x ∈ R chosen uniformly at random, or
v ∈ VH and y = H(x1; x2) for x1; x2 ∈ R2 chosen uniformly at random, the set
{σ : Pred(v)y} is denoted {σ: Pred(v)H/G(·)}.

The Provable Security of Graph-Based One-Time Signatures

389
Consider the following experiment. First, we choose a vertex v ∈ VH ∪ VG,
a hash function H ∈ H and a labeled cut σv ∈ {σ: Pred(v)H/G(·)} uniformly at
random. Then we call procedure A on input (H, v, σv). (For simplicity’s sake,
when clear from the context, we use A(·) to denote A(H, v, σv)). Let NoAbort
denote the event that A does not abort in this experiment. The following lemma
shows that the combined success probability of adversaries IG, IH and CH is
equal to the probability of the event NoAbort.
Lemma 2. Let H, G and C the advantages of adversaries CH, IG and IH.
Let NoAbort be the event as described above. Then H + G + C = Pr [ NoAbort ]
Proof. We analyze the success probability of adversaries IH, IG and CH in turn.
First, the success probability H of adversary IH is the probability that, for
x1; x2 ∈ R2 and H ∈ H uniformly chosen at random, H(IH(H, H(x1; x2)))) =
H(x1; x2), that is, that IH returns a pre-image of H(x1; x2) for a random domain
point x1; x2. For X ∈ {H, G}, let PrX [ E ] denote the probability of event E when
H ∈ H, v ∈ VX and σv ∈ {σ: Pred(v)H/G(·)} are chosen uniformly at random.
Then

H = PrH [ H(x(cid:2)) = H(x), x(cid:2) ← A(H, v, σv), x(cid:2) (cid:20)= abort ]

= (1 − PrH [ H(x(cid:2)) (cid:20)= H(x) | A(·) (cid:20)= abort ]) · PrH [A(·) (cid:20)= abort ]

Similarly, for adversary IG we have

G = (1 − PrG [ G(x(cid:2)) (cid:20)= G(x) | A(·) (cid:20)= abort ]) · PrG [A(·) (cid:20)= abort ]

Lastly, recall that Adversary CH is successful if, after running A on a randomly
chosen v ∈ VH ∪ VG, either G(x) (cid:20)= G(x(cid:2)) if v ∈ VG or H(x) (cid:20)= H(x(cid:2)) if v ∈ VH.
Thus,

C =

1
2

· (PrH [ H(x(cid:2)) (cid:20)= H(x) | x(cid:2) ← A(·), x(cid:2) (cid:20)= abort ] · PrH [A(·) (cid:20)= abort ] +
PrG [ G(x(cid:2)) (cid:20)= G(x) | A(·) (cid:20)= abort ] · PrG [A(·) (cid:20)= abort ])

Combining the above results and using that |VH| = |VG| the result follows.

As a second step toward proving Theorem 1, next lemma shows that the
success probability of the distinguisher DG is related to the diﬀerence between
forger’s success probability and the probability that procedure A does not abort
(in the experiment described in the previous lemma).
Lemma 3. Let D and δ denote the advantage of distinguisher DG and forger
F respectively, and let α and NoAbort deﬁned as before. Then

δ ≤ n · (αD + Pr [ NoAbort ]) .

The following notation will be useful in the proof. For any v ∈ V , let W (v) =
VG ∩ Pred(v) \ {v} denote the set of all expansion vertices which are predecessors 
of v. Also, given a vertex v ∈ V and a vertex u ∈ W (v), let Predv(≤

Alejandro Hevia and Daniele Micciancio

390
u) = ∪u(cid:2)≤u, u(cid:2)∈W (v)Pred(u(cid:2)) the cut formed by the union over u(cid:2) ≤ u of all sets
Pred(u(cid:2)) ⊂ Pred(v). (Recall that ≤ is a total order relation over VG) Also, let
{σ: Predu(≤ v)} denote the set of all labeled cuts on Predv(≤ u); as before, for
y1; y2 ∈ R2, let σ: Predu(≤ v)y1;y2 denote the set of all labeled cuts compatible 
with (u, y1; y2). (We stress that the compatibility is with respect to vertex
u, that is, σ(e1); σ(e2) = y1; y2). As before, if x ∈ R is uniformly distributed,
the set {σ: Predv(≤ u)G(x)} is denoted by {σ: Predv(≤ u)G(·)}. Notice that in
this extended deﬁnition, Predv(≤ u) ⊂ Pred(v) and therefore a labeled cut for
Pred(v) can be computed from any labeled cut in {σ: Predu(≤ v)}.
Proof (Lemma 3). By deﬁnition, D = p1 − p0, where p1 and p0 denote the
probability that DG(y1; y2) = 1 when x R← R, y1; y2 ← G(x) and the probability
that DG(y1; y2) = 1 when y1; y2
R← R2, respectively. Consider the following two
experiments, which we denote Exp1 and Exp0. In the ﬁrst one, we choose H ∈ H
uniformly at random, v ∈ VH ∪ VG with probability proportional to |W (v)|,
u ∈ W (v) and σu ∈ {σ: Predv(≤ u)G(·)} uniformly at random; we then compute
σv as an extension of σu by σv = ΠPred(v)(σu) and ﬁnally call A on input
(H, v, σv). The second experiment, Exp0, is similar to the previous one, with the
exception that σu is drawn at random from {Predv(≤ u)y1;y2} for y1; y2
R← R2.
Let q1(v(cid:2), u(cid:2)) and q0(v(cid:2), u(cid:2)) denote the probability procedure A does not abort
in Exp1 and Exp0 respectively, conditioned on the event that v = v(cid:2) and u = u(cid:2)
are chosen in each experiment.
|W (v)| be the average number of expansion vertices of

(cid:3)

Let α = 1
n

a random vertex in the graph. We claim that,

v∈VH∪VG
(cid:4)

(cid:4)

v∈VH∪VG

u∈W (v)

p1 =

1
nα

·

q1(v, u) and p0 =

1
nα

·

(cid:4)

(cid:4)

v∈VH∪VG

u∈W (v)

q0(v, u)(1)

and that for all v ∈ VH ∪ VG, u ∈ W (v) ∪ {v}

(cid:4)

q0(v, u∗) = q1(v, u)
q1(v, v) ≥ δ

v∈VH∪VG
(cid:4)

v∈VH∪VG

q0(v, v∗) = n · Pr [ NoAbort ]

(2)
(3)

(4)

where w∗ = maxw(cid:2)<w(w(cid:2)), denotes the biggest vertex in VG smaller than w ∈ VG
and v = minv∈VG
(v) is the “smallest” expansion vertex in VG (where “biggest”
and “smallest” refer to the ≤ ordering relation).

Before proving these claims, we use them to ﬁnish the proof of the lemma.

Using equations (1-4), we have

D =

1
nα

{q1(v, v) − q0(v, v∗)} ≥ 1

nα

· (δ − n · Pr [ NoAbort ])

(cid:4)

v∈VH∪VG

which gives the desired result.

The Provable Security of Graph-Based One-Time Signatures

391

We now justify the claimed equations (1-4) by analyzing each them in turn.
To justify the ﬁrst part of (1), notice that by deﬁnition of p1 and standard
conditioning we have

(cid:1)

p1 = Pr

A(H, v, σv) (cid:20)= abort : v W← VG ∪ VH , u R← W (v), H R← H, x R← R,
R← Predv(≤ u)G(x)
σu
(cid:4)
(cid:4)

q1(v, u) · Pr [ u | v ] · Pr [ v ]

(cid:4)

v∈VH∪VG

u∈W (v)

(cid:2)

=

(cid:4)

=

q1(v, u)

Pr [ v ]
|W (v)|

v∈VH∪VG

u∈W (v)

where v W← VG ∪ VH means vertex v is drawn from set VG ∪ VH with probability
proportional to |W (v)|. Since, for all v ∈ V , Pr [ v ] = |W (v)|/(nα) Equation (1)
holds. The second part of (1) follows from a similar argument.
We justify Equation (2) as follows. Fix v ∈ VH ∪ VG and u ∈ W (v) ∪ {v}.
Consider experiment Exp0, and assume v and u∗ ∈ W (v) are the vertices chosen.
First of all, notice that Predv(≤ u∗) ⊂ Predv(≤ u) because u∗ ≤ u, and thus,
σu can be computed from σu∗. Second, assume v ∈ VG. Since the labeled cut
σu∗ ∈ σ: Predv(≤ u∗) is chosen uniformly at random, there is no other expansion
node in any path from u(cid:2) ≤ u∗ and u, and H is regular, the induced labeled cut
σu = ΠPred(u)(σu∗) ∈ σ: Predv(≤ u) is such that σu(e1); σu(e2) = G(x) for
some x ∈ R uniformly distributed (e1 and e2 are edges leaving vertex u). The
same argument when v ∈ VH boils down to σu(e) = H(x1; x2) for uniformly
distributed x1; x2 ∈ R2 and e the only leaving edge of u. Thus, σu ∈ σ: Predv(≤
u)R, and q0(v, u∗) = q1(v, u).
To justify Equation (3) we notice that when distinguisher DG chooses u = v,
the distribution of the public key and signature so computed by A from σu
follows the same distribution than the forger expects in the one-chosen-message
attack and, thus, the output of the forger is independent of the choice of v.

q1(v, v) =

(cid:4)

v∈VH∪VG
(cid:4)

v∈VH∪VG

Pr [F(m, σm) = (m(cid:2), σ(cid:2)), m (cid:20)= m(cid:2), v ∈ µ(m), v (cid:20)∈ µ(m(cid:2)) ] ≥ δ

where the last inequality follows from that, for any m, m(cid:2) ∈ M, if m (cid:20)= m(cid:2) there
always exists v ∈ VH ∪ VG such that v ∈ µ(m) but v (cid:20)∈ µ(m(cid:2)), otherwise m and
m(cid:2) would be comparable.
It remains to prove Equation (4). This follows from q0(v, v∗) = q1(v, v) =
Pr [ NoAbort | v ] and from vertex v ∈ VH∪VG being chosen uniformly at random
in the experiment that deﬁnes the event NoAbort. This concludes the proof of
the lemma.

Proof (Theorem 1). Immediate from Lemma 2 and Lemma 3.

392

Alejandro Hevia and Daniele Micciancio

6 Extensions

In this section we consider extensions of the basic security results presented in
the previous sections. The ﬁrst one concerns relaxing the security assumptions
about the underlying primitives G, H. The second applies the ideas in our proof
of security to build provably secure signature schemes with special algebraic
properties.

Universal One-Way Hash Functions: The collision-resistance requirement
on the hash function family H can be relaxed to universal one-wayness as deﬁned 
by Naor and Yung [NY89]. Recall that universal one-way hash function
(UOWHF) families are such that it is hard to ﬁnd a colliding pair x (cid:20)= x(cid:2) such
that H(x) = H(x(cid:2)) but the adversary must select x before H is given to it.
We modify our GBOTS construction, so that for each compression vertex v a
diﬀerent randomly chosen function Hv ∈ H is used. The security argument in
this case is modiﬁed as follows. In order to compute σ(cid:5) = Π{v(cid:1)}(σv), algorithm
A(H, v, σ) picks a hash function Hv ∈ H uniformly at random anew to compute
the label of each edge leaving a compression vertex with the exception of the
edge corresponding to v, for which H is used. Thus, adversary IH needs only
to pick ahead a random value x ∈ R2 and, once given a target hash function
H, to use procedure A to invert H(x). Similarly, for CH it suﬃces to guess the
compression vertex where the collision given by Lemma 1 will be found, and
use the target hash function H there. Adversaries IH and CH remain the same.
The remaining security argument does not diﬀer substantially from the one presented 
in Section 5. We point out that regular universal one-way hash functions
and one-to-one pseudorandom generators can be constructed from any one-way
permutation [NY89,CMR98].

Mapping Messages to Edges (or Vertices): In this paper, we associate
values to edges in the graph and functions to vertices. This approach can be
seen as dual to the one used in [BM94], which associates values to vertices
and function to edges. Both approaches are essentially equivalent from a syntax
viewpoint and in terms of the class of schemes they yield. From a foundational
viewpoint, we believe that the approach presented here is conceptually simpler.

Graph Based Algebraic Signature Schemes: Algebraic signature schemes
are signature schemes in which signatures for (certain) new messages can be produced 
by combining signatures with a restricted set of operations. Since these
operations do not require knowledge of the secret key, algebraic signatures are
not signature schemes in the standard interpretation of the term, but they are
a new cryptographic primitive. They are useful in contexts where possession of
signatures of certain messages automatically entitles possession of signatures of
new messages, such as in credential systems. Credentials may be implemented
as signed documents which specify capabilities (or attributions) to be granted to
the credential holder. Thus, if implemented with the appropriate algebraic signature,
 the possession of one or more credentials (signatures) will automatically

The Provable Security of Graph-Based One-Time Signatures

393

enable the computation of the entitled credentials without the involvement of the
original signer. Algebraic signatures were originally suggested by Rivest [MR02].
Informally, an algebraic signature scheme consists of three algorithms AS =
(KG, Sig, Vf) and a two set of operations O = {f1, f2, . . . , fq} and S = {g1, g2, . . . ,
gs}, where each fi (resp. gi) is a function that takes one or more messages (resp.
signatures) as inputs and produces one message (resp. signature) as output. KG,
Sig, and Vf are as in any digital signature scheme (see Section 2.1). We require
that if δ1, . . . , δt are valid signatures for m1, . . . , mt then gi(δ1, . . . , δt) is a valid
signature for fi(m1, . . . , mt) for all appropriate fi, gi. Notice that signatures so
generated are subject to existential forgery under chosen message attacks, so a
new deﬁnition of security is required. Let span(O,{m1, . . . , mt}) be the set of all
messages computable from {m1, . . . , mt} by applying functions in O on them.
The security of algebraic signatures is deﬁned in terms of unforgeability against
chosen-message attacks, where by convention, the forger is deemed successful
only if it outputs a signature of a message m not in the set span(O,{m1, . . . , mt}).
Graph-based one-time signatures can be used to build very eﬃcient algebraic
signatures. Indeed, for practical functions fi, it is possible to build graphs such
that fi is embedded in the order relation (cid:13). That is, if fi(m1, m2) = m3, then
there exists a labeling σ: µ(m3) which can be computed from labellings σ1: µ(m1)
and σ2: µ(m2) and it is consistent with them.
Notice that the proof of security of Section 4 and Section 5 can be easily modiﬁed 
to prove that our (graph-based) algebraic signature scheme AS is secure.
Indeed, the only technical diﬀerence is that the forger F can request multiple
signatures σm: µ(m). This can be easily factored in by modifying Procedure A
so each signature σm is computed from σv (or A aborts, if not possible). Since
the forger F must output (m(cid:2), σ(cid:2)) for m(cid:2) not in span(O,∪mµ(m)), there must
exist v ∈ ∪mµ(m) so v (cid:20)∈ µ(m(cid:2)) and the argument goes through. The rest of
the proof is identical and, in particular, adversaries IG, IH, CH, DG remain the
same, given black-box access to A.
Concrete Constructions of Algebraic Signature Schemes: In this
section we sketch concrete graph constructions that yield algebraic signature
schemes with respect to (a) union and subset operations, and (b) union and
super-intersection operations. (Recall that the super-intersection of sets A and
B, denoted A (cid:30) B, is the collection of all sets S such that A ∩ B ⊆ S ⊆ A ∪ B.)
Let M be the set of all subset of n elements, where we denote such elements as
t0, . . . , tn−1. Consider the graph shown in Figure 6. (Although the ﬁgure shows
vertices vi having indegree and outdegree 1, and the vertices v(cid:2)
(cid:5) having
outdegree and indegree n, respectively, it is easy to cast this graph as one with
the properties considered in this work. Indeed, it suﬃces to replace each vertex vi
with a small subgraph of 2 compression and 2 expansion vertices, and to connect
⊥ and v(cid:2)
each vi to both v(cid:2)
We map every set S into the set of vertices µ(S) = C deﬁned as follows:
⊥ are in C, and vertices vi are in C if and only if ti (cid:20)∈ S. Notice
vertices v⊥ and v(cid:2)
C is a valid cut for any set S. Given a labeled cut σ: µ(S) the labeling for any
C(cid:2) = µ(S(cid:2)) such that S(cid:2) ⊆ S can be computed by projecting σ: µ(S) on C(cid:2).

(cid:5) by simple tree construction).

⊥ and v(cid:2)

394

Alejandro Hevia and Daniele Micciancio

v(cid:2)
v(cid:6)
(cid:2)

v0

v1

vi

vn−1

v(cid:6)
⊥
v⊥

Fig. 6. DAG for algebraic scheme with operations {∪, subset}.

The union operation is deﬁned similarly, since given labeled cuts σ1: µ(S1) and
σ2: µ(S2) a consistent labeled cut for µ(S1 ∪ S2) can be computed.
A algebraic signature scheme for the {∪,(cid:30)} operations can be build by using
two graphs G1 and G2 each one like the one described above. In this case, given a
set S, we deﬁne the cut on the ﬁrst graph by using the above shown rule, while
for the second case we “invert” the condition, and we include the corresponding
vertices only if ti ∈ S. It is an easy exercise to verify that such mapping allows the
computation of labeled cuts corresponding to the union and super-intersection
of two sets S1 and S2, given labeled cuts σ1: µ(S1) and σ2: µ(S2).

7 Conclusions

In this paper, we analyze graph based signatures from a security viewpoint and
give suﬃcient conditions, namely the existence of one-way permutations, under
which the signature scheme is secure in the standard complexity model (no
random oracles). Additionally, we present a security proof which uses a new
hybrid argument where the number of hybrid distributions may be exponential.
We believe this technique is of independent interest. We also propose a new
paradigm for the construction of algebraic signature schemes, which are new
useful primitives for applications where controlled “forgeability” of signatures is
needed, as in credential systems.

Acknowledgments

We want to thank Bogdan Warinschi, and Yee Hea Ann for helpful comments
and discussions.

The Provable Security of Graph-Based One-Time Signatures

395

References

BM84.

BM99.

BM96a.

BM96b.

BKR94.

BM92.

BM94.

AR00.

BC93.

BN02.

BR97.

M. Abdalla and L. Reyzin. A new forward-secure digital signature scheme.
In ASIACRYPT’2000, LNCS 1976, pages 116–129. Springer-Verlag, 2000.
J. N. E. Bos and D. Chaum. Provable unforgeable signatures.
In
CRYPTO’92, LNCS 740, pages 1–14. Springer-Verlag, 1993.
M. Bellare, J. Kilian, and P. Rogaway. The security of the cipher block
chaining message authentication code. In CRYPTO’94, LNCS 839. Spring-
er-Verlag, 1994.
M. Blum and S. Micali. How to generate cryptographically strong sequences 
of pseudorandom bits. In Siam Journal of Computing, 13(4):850–
864, 1984.
M. Bellare and S. Micali. How to sign given any trapdoor function. In
Journal of Cryptology, 39(1):214–233, 1992.
D. Bleichenbacher and U. M. Maurer. Directed acyclic graphs, one-way
functions and digital signatures. In CRYPTO’94, LNCS 839, pages 75–82.
Springer-Verlag, 1994.
D. Bleichenbacher and U. M. Maurer. On the eﬃciency of one-time digital
signatures. In ASIACRYPT’96, LNCS 1163, pages 145–158. Springer-Verlag,
 1996.
D. Bleichenbacher and U. M. Maurer. Optimal tree-based one-time digital
signature schemes. In STACS’96, LNCS 1046, pages 363–374. SpringerVerlag,
 1996.
M. Bellare and S. Miner. A forward-secure digital signature scheme. In
CRYPTO’99, LNCS 1666, pages 431–448. Springer-Verlag, 1999.
M. Bellare and G. Neven. Transitive Signatures based on Factoring and
RSA In ASIA-CRYPT’02, (these proceedings).
M. Bellare and P. Rogaway. Collision-resistant hashing: Towards making
UOWHFs practical. In CRYPTO’97, LNCS 1294, pages 470–484. Spring-
er-Verlag, 1997.
T. H. Cormen, C. E. Leiserson, and R. L. Rivest. In Introduction to algorithms.
 MIT Press and McGraw-Hill Book Company, 6th ed., 1992.
R. Canetti, D. Micciancio, and O. Reingold. Perfectly one-way probabilistic 
hash functions. STOC’98, pages 131–140. ACM, 1998.
C. Dwork and M. Naor. An eﬃcient existentially unforgeable signature
scheme and its applications. In CRYPTO’94, LNCS 839, pages 234–246.
Springer-Verlag, 1994.
S. Even, O. Goldreich, and S. Micali. On-line/oﬀ-line digital signatures.
In Journal of Cryptology, 9(1):35–67, 1996.
S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme secure
against adaptive chosen-message attacks. In Siam Journal of Computing,
17(2):281–308, 1988.
R. Hauser, A. Przygienda, and G. Tsudik. Reducing the cost of security
in link state routing. In Symposium on Network and Distributed Systems
Security (NDSS ’97), pages 93–99, Internet Society, 1997.
A. Hevia and D. Micciancio. The provable security of Graph-Based OneTime 
Signatures and extensions to algebraic signature schemes. Full version 
of this paper, available via http://www-cse.ucsd.edu/users/ahevia.
JMSW02. R. Johnson, D. Molnar, D. Song, and D. Wagner. Homomorphic signature
schemes. In CT-RSA ’2002, LNCS 2271, pages 244–262. Springer-Verlag,
2002.

GMR88.

EGM96.

CLR92.

CMR98.

DN94.

HPT97.

HM02.

396

Alejandro Hevia and Daniele Micciancio

Lam79.

Mer82.

Mer87.

Mer90.

MM82.

L. Lamport. Constructing digital signatures from a one way function.
Technical Report CSL-98, SRI International, 1979.
R. C. Merkle. In Secrecy, Authentication, and Public Key Systems, vol. 18
of Computer science. Systems programming. UMI Research Press, 1982.
R. C. Merkle. A digital signature based on a conventional encryption
function.
In CRYPTO’87, LNCS 293, pages 369–378. Springer-Verlag,
1987.
R. C. Merkle. A digital signature based on a conventional encryption
function.
In CRYPTO’89, LNCS 435, pages 428–446. Springer-Verlag,
1990.
C. H. Meyer and S. M. Matyas. In Cryptography: A New Dimension in
Computer Data Security. John Wiley and Sons, New York, 1982.

MMM02. T. Malkin, D. Micciancio, and S. Miner. Eﬃcient generic forward-secure
In EUROMR02.


NY89.

Per01.

Rab78.

Roh99.

RSA78.

Sch90.

Vau92.

Yao82.

In CT-RSA

signatures with an unbounded number of time periods.
CRYPT’2002, LNCS 2332, pages 400–417. Springer-Verlag, 2002.
S. Micali and R. L. Rivest. Transitive signature schemes.
’2002, LNCS 2271, pages 236–243. Springer-Verlag, 2002.
M. Naor and M. Yung. Universal one-way hash functions and their cryptographic 
applications. STOC’89, pages 33–43. ACM, 1989
A. Perrig. The BiBa one-time signature scheme and broadcast authentication 
protocol. In Proceedings of the 8th ACM conference on Computer
and Communications Security, pages 28–37. ACM, 2001.
M. O. Rabin. Digitalized signatures. In R. A. DeMillo, D. P. Dobkin, A. K.
Jones, and R. J. Lipton, editors, Foundations of Secure Computation, pages
155–168. Academic Press, 1978.
P. Rohatgi. A compact and fast hybrid signature scheme for multicast
packet authentication. In Proceedings of the 6th ACM conference on Computer 
and communications security, pages 93–100, ACM, 1999.
R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital
signature and public-key cryptosystems. In Communications of the ACM,
21(2):120–126, 1978.
C. Schnorr. Eﬃcient identiﬁcation and signatures for smartcards.
CRYPTO’89, LNCS 435, pages 239–252. Springer-Verlag, 1990.
S. Vaudenay. One-time identiﬁcation with low memory.
In Eurocode
92, CISM Courses and Lectures, no. 339, pages 217–228, Springer-Verlag,
1992.
A. Yao. Theory and applications of trapdoor functions. FOCS’82, pages
80–91. IEEE, 1982.

In

