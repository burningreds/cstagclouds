Beating the Birthday Paradox in Dining

Cryptographer Networks

Pablo Garc´ıa1, Jeroen van de Graaf2, Alejandro Hevia3(B), and Alfredo Viola4

1 Universidad Nacional de San Luis, San Luis, Argentina

2 Depto. de Ciˆencia da Computa¸c˜ao, Universidade Federal de Minas Gerais,

3 Department of Computer Science, University of Chile, Santiago, Chile

Belo Horizonte, Brazil

ahevia@dcc.uchile.cl

4 Instituto de Computaci´on, Universidad de la Rep´ublica, Montevideo, Uruguay

Abstract. A Dining Cryptographer Network (DC-Net) allows multiple 
players to broadcast messages without disclosing the identity of the
sender. However, due to their probabilistic nature, message collisions
can occur, meaning that two or more messages sent by diﬀerent participants 
end up occupying the same slot, causing these messages to be
lost. In this work, we evaluate two diﬀerent strategies to deal with collisions.
 When repeating a DC-net sequentially, honest parties who see that
their message did not collide can switch to sending a null message, eﬀectively 
decreasing the collision probability in subsequent rounds. When
repeating a DC-net in parallel, no feedback exists, and there will always
remain a non-zero probability that one message collides in every round.
We analyze both strategies with respect to the number of parties, the
number of slots, the number of repetitions and the probability of success.
We obtain exact but rather convoluted combinatorial formulas for both
cases, together with more tractable approximations, the correctness of
which has been demonstrated by simulations.

1 Introduction

Dining Cryptographers and Collisions. A well-known protocol providing
anonymous message broadcast is the Dining Cryptographers protocol, developed
by Chaum [4]. A DC-net is a randomized protocol which allows a set of parties
to send messages anonymously. Typically, a DC-net protocol is parameterized
by the number of participants, n, and its bandwidth, m. In the simplest variant
of a DC-net, each party must randomly choose a slot number between 1 and m
in order to send her message.

A serious problem of DC nets, already recognized in the original paper, is
the fact that two or more parties can, by coincidence, submit their message to
the same slot, leading to a collision. Here we focus on random collisions which
occur because of users choosing the same slot. One way to deal with collisions
is to run a slot reservation protocol before the actual message is sent; another
c(cid:2) Springer International Publishing Switzerland 2015
D.F. Aranha and A. Menezes (Eds.): LATINCRYPT 2014, LNCS 8895, pp. 179–198, 2015.
DOI: 10.1007/978-3-319-16295-9 10

180

P. Garc´ıa et al.

is to run a mix-net ﬁrst to deal with the slot reservations [6]. Here we explore
another direction.

Because of these collisions, we can consider the original DC-net as an unreliable 
communication channel. We say that a DC-net is reliable if, for each
participant, the probability that she does not succeed in publishing her message 
(anonymously) is negligible in the security parameter κ. Theoretically this
should be interpreted as exponentially small in κ, and practically as below a
very small parameter such as 10−10 or smaller.

In this work, we explore new ways to build
Summary of Our Results.
collision-free (or reliable) DC-net protocols. Our focus is not the low-level design
of new DC-net protocols, but instead a precise evaluation of the eﬃciency of at
least two simple ways to build collision-free DC-nets: sequential repetition and
parallel repetition.

Sequential Repetition. A ﬁrst way to obtain a reliable DC-net is to consider
r sequential repetitions of an unreliable DC-net, for some ﬁxed parameter
r > 1. If the message for a given party is successfully sent (has not collided
with some other message) then that party starts sending the null message
in any subsequent repetition of the basic DC-net. After r rounds, all parties
stop.
Parallel Repetition. A second way to obtain a reliable DC-net is to consider
k parallel repetitions of the basic DC-net, for some ﬁxed parameter k ≥ 1.
Each party sends a copy of the message in each parallel instance, henceforth
called channel, of the DC-net protocol. In this case we say a message was
successfully sent if the message did not collide in at least one channel.

For both scenarios, we develop a quantitative analysis allowing a trade-oﬀ
between the probability of success, the number of participants n, the total number 
of available position m, and either the number of sequential repetitions r or
the number of parallel repetitions k.

We remark that both Chaum’s DC-net as well as Golle-Juels’ DC-net do not
really deal with collisions. In their papers [4,17] the authors seem to suggest the
strategy that the protocol needs to be repeated until each message is transmitted
collision-free – but no concrete algorithm is given.

Interestingly, as a byproduct of our analysis of the collision probability of
these iterated constructions, we show that collisions in Golle-Juels’ DC-net are
not random under the standard static adversary that corrupts t < n players. In
particular, the collision probability under such adversary for some honest user’
message is not t/n, but instead depends on the value of the message. Obtaining
a DC-net with random collisions can be easily done at the price of an extra
round. See Sect. 8 for details.

Related Work. An important motivation for our research is the observation
that anonymous broadcast can only be achieved in two ways: either by using DCnets 
or by using Mixnets, also invented by David Chaum [3]. However, a main

Beating the Birthday Paradox in Dining Cryptographer Networks

181

diﬀerence between these two alternatives is that DC-nets provide unconditional
anonymity (at the cost of a signiﬁcant message overhead), whereas in Mixnets
the anonymity is inherently computational. So at some time in the future, when
the NSA has broken RSA or ElGamal, it can retro-actively trace messages
sent through Tor back to their originators. To eliminate this drawback, we believe
that practical prototypes of unconditional DC-nets should be implemented, and
this paper should be regarded as a theoretical contribution towards this eﬀort.
Note that the Golle-Juels variant of DC-nets and its practical implementations,
 Dissent [5] and Verdict [6] do not satisfy this requirement, because in
that approach unconditional privacy is traded away in favor of eﬃciency: noninteractive 
DHKE and pseudo-random number generators, implying computational 
anonymity only. We are not convinced this is the right trade-oﬀ and believe
that more eﬀort should be spent to preserve unconditional privacy.

As a strategy to deal with disrupters we advocate the pro-active use of
cryptography (bit commitments, proofs of knowledge etc.), just as proposed in
[17,21]. The original proposal by Chaum suggested the use of traps, see Waidner
and Pﬁtzmann [22] for details. But we are somewhat sceptical about them. First,
traps assume sequential repetition, which in some cases is not available or not
desirable. Second, traps represent a re-active solution: disrupters need to be identiﬁed 
and excluded after they have started misbehaving. This means that a set
of sleeping Sybils can mount a collaborative denial-of-service attack and bring
down the network for a signiﬁcant period of time. We therefore prefer pro-active
approaches.

Herbivore [15] uses a diﬀerent topological model which reduces the impact
of disrupters. It also uses a slot reservation phase to avoid (or at least, reduce)
collisions which is in spirit similar to our sequential approach. However, their
performance metric is not the number of rounds, but the number of bits transmitted 
per node in order to send a packet anonymously and successfully.

The idea of using parallel Dining Cryptographers was ﬁrst suggested in [20]
(in German), but as far as we know no quantitative results have ever been published.
 Preliminary results of our research were published recently in [11,12] (in
Spanish). Very recently yet another strategy was proposed to deal with collisions 
which makes no a priori assumption about a distribution on the messages
submitted [9], using techniques from networking. An optimal solution oﬀering
unconditional privacy is presented in [10].

2 Preliminaries

Protocols, Messages, and Adversaries: For any integer s > 0, let [s] denote the
set {1, . . . , s}. We model a DC-net as a multi-sender broadcast anonymous channel 
as follows. We consider a setting with n+1 parties (n is some ﬁxed constant)
where sender parties P1, P2, . . . , Pn attempt to send messages M1, M2, . . . , Mn
(resp.) to a receiver party R, in an anonymous and reliable way. The communication 
between parties can be observed and even be inﬂuenced by a (possibly
computationally unbounded) adversary A which can statically corrupt at most

182

P. Garc´ıa et al.

t senders. In this work, since we start from secure DC-nets, we do not ﬁx a
particular model of interaction between the adversary and the parties. Instead,
we describe the protocols in terms of the messages input to the protocol and
the messages received by R. If M is a tuple of n messages for the sender parties 
we write ExecΠ(P (M ), A)(κ) for the output of party R when the parties
P = (P1, P2, . . . , Pn) and R execute the protocol in the presence of adversary
A for security parameter κ. We assume that this output is a set of messages.
Notice that the execution is randomized, so once M is ﬁxed, Exec(P (M ), A)(κ)
is a random variable. Also, we assume that any initialization that the protocol
requires (i.e. a public key infrastructure) are performed at the beginning of the
execution.

Commitments: In this work, we use commitment schemes [19] to implement
the parallel iterated DC-net. In its basic form, commitment schemes are a tuple
(K, Comm, Open), where the key generation algorithm K produce the commitment
parameters μ, after being executed during setup time by a trusted player. Then,
randomized algorithm Comm takes μ and a message M, and produces a pair
commitment value and opening (C, op) ← Commμ(M). Algorithm Open allows
opening the commitment using M and op. Yet, the security requirements we
assumed on the commitment schemes are stronger, including non-malleability.
Due to space constraints we refer the interested reader to the work of Abdalla
et al. [1].

3 Sequential Repetition of DC-Nets

Perhaps the most well-known strategy to ﬁx the collision problem is to sequentially 
repeat the protocol – so much it is pervasively mentioned in many places,
including [4,17]. The strategy is simple: given an anonymous broadcast protocol 
Γ , ﬁx a number of rounds r ≥ 1 and simply instruct parties to execute
Γ in sequence r times. In each execution, all senders attempt to transmit. For
each sender, if there is no collision (her message goes through) then that party
transmits the null message (denoted ⊥) from that point forward.

The main beneﬁt of this strategy is simplicity. The resulting reliable DC-net

protocol is very easy to implement in a black-box manner, given access to Γ .

We assume each player Pi can detect if a message (not necessarily sent by Pi)
was involved in a collision or not (see [2] for a way to implement this assumption).

Sequential Repetition of DC-Net: Let Γ (M ) denote a single instance of an
unreliable DC-net protocol executed by players P1, . . . , Pn under input M =
(r) = Γ1, Γ2,··· , Γr be
(M1, . . . , Mn) where Mj is the input of player j. We let Γ
the protocol consisting of r sequential repetitions of protocol Γ , so Γj = Γ for
j = 1, . . . , k. All parties participate in every sequential iteration of the protocol.
In the description below, we let ci = (ci,j)j∈[r] be the vector of slots randomly
chosen by player Pi. In the j-th iteration of Γ , player Pi transmits her message
in slot ci,j ∈ [m]. Protocol Γ

(r) takes input M and proceeds as follows:

Beating the Birthday Paradox in Dining Cryptographer Networks

183

1. Main Loop: All players do the following, from j = 1 up to j = r:

(i) Commit to a slot: Each player Pi chooses a value ci,j uniformly at
random in [m] as the transmission slot for the current execution of the
DC-net. Player Pi then computes and broadcast the associated commitment 
Ci,j = Com(ci,j).

(ii) Computing and broadcasting the pads: Each party Pi participates
in the execution of protocol Γj = Γ using Mi as input and ci,j as the
transmission slot. In Γj, any non-interactive zero-knowledge proof of correctness1 
is modiﬁed so Pi can prove that the slot ci,j used to prepare
the pad is consistent with the value committed in the previously broadcasted 
Ci,j. Let dj = (ci,j)i∈[n] be the vector of slots used by all parties
in round j.
(iii) Compute the transmitted values: Let Sj ← ExecΓj (P (M ; dj), A)(κ)
denote the ﬁnal output of Γj. If message Mi ∈ S then Pi sets Mi ← ⊥
in order to transmit the null message in every subsequent round.

2. Compute the ﬁnal set of transmitted values: The output of Γ

the union (as sets) of Sj over j ∈ [r].

(r) is then

Notice that a message is successful if there exists a round j ∈ [r] such that the
message is successfully broadcast under protocol Γj.

4 Analysis of Sequential Repetition of DC-Nets

In this section we analyze the collision probability of sequential approach in
terms of the number of players n, the number of slots per channel m, and the
number of rounds r. The sequential DC protocol can be modelled as a problem
of balls-in-bins, where balls correspond to messages and bins to slots (positions).
Following the symbolic method presented in [8], we let Gm(x, z) = (ez/m +
(x − 1)z/m)m. In this setting the coeﬃcient n![xkzn]Gm(x, z) is the probability
that when throwing n balls in m bins we have k bins with one ball. These bins
are ﬁlled by the messages that go through, and as a consequence do not have to
be sent again in the next round.
Theorem 1. With the convention that y0 = z, let

ˆGm(x, y0, y1, . . . , yr) =

n(cid:2)

i=1

Gm(x yi, yi−1/yi).

(1)

Then n![xn, zn, y0
r] is the probability generating function that all messages
go through in less than or equal r round when n messages are sent in m slots,
using the sequential algorithm.

1, . . . , y0

Sketch of the proof: The variable yi “marks” the number of balls that go
through in round i. Intuitively yi−1/yi takes care of the fact that the messages
that go through round i − 1 do not have to be sent in round i.
(cid:2)
1 For example, the term σ(cid:2)(cid:2)

i,θ in the Golle-Juels protocol, see Appendix A.

184

P. Garc´ıa et al.

Even though this is an exact approach, it is far from trivial to extract coeﬃcients
and to ﬁnd the probability that more than r rounds are needed.

By the Poisson Law which governs the asymptotic behavior of the problem
in the case n = λm with λ > 0 a constant ([8], pag. 177), the expected number
of bins with one ball when m, n → ∞ and n = λm is ne
−λ. It can be seen that
this value is concentrated around its mean.
is n − ne
the proportional constant λ1 is λ0(1 − e
If we iterate this process, then after iteration i, the expected number of
messages that has to be sent is ni+1 = λi+1m with λi+1 = λi(1 − e
−λi). The
process is ﬁnished at the iteration f such that nf < 1, that is λf < 1/m = λ0/n.

Let λ0 = n/m < 1. Then, the expected number of balls that fail in this round
−λ0, and as a consequence after the ﬁrst round, the expected value of

−λ0).

Theorem 2. Let 0 < δ < 1 and 0 < λ0 < 1 with (1 + δ)λ0 < 1, and let f be the
number of iterations made in the sequential algorithm when n balls are initially
thrown in m = n/λ0 bins. Moreover, let

low(n, λ0, δ) :=

(cid:4)

(cid:3)
lg

(cid:4)

(cid:5)(cid:5)

log

(cid:7)

n
λ0
(cid:4)

− lg (− log(((1 − δ)(1 − λ0/2)λ0))

(cid:6)

high(n, λ0, δ) :=

lg

log

(cid:5)(cid:5)

(cid:4)

n
λ0

− lg (− log((1 + δ)λ0))

(cid:8)

.

and

Then,

Pr [low(n, λ0, δ) ≤ f ≤ high(n, λ0, δ)] > 1 − e

− δ2(1−e−λ0 )

3

n.

where lg denotes the logarithm in base 2.

Sketch of the Proof. This is a proof by induction based on Chernoﬀ bounds.
After the ﬁrst iteration we have an average of n1 = n0(1 − e
−λ0) balls that had
collisions, where n = n0 = λ0m.
By Chernoﬀ bounds, we have
(cid:9)
λ1 > (1 + δ)λ0(1 − e

n1 > (1 + δ)n0(1 − e

(cid:10)
−λ0)

(cid:10)
−λ0)

= Pr

Pr

(cid:9)

(cid:9)
λ1 < (1 − δ)λ0(1 − e

(cid:10)
−λ0)

Pr

(cid:9)

< e
= Pr

n1 < (1 − δ)n0(1 − e

(cid:10)
−λ0)

− δ2(1−e−λ0 )

3

− δ2(1−e−λ0 )

2

< e

n,

n.

Moreover, since u − u2/2 ≤ 1 − eu ≤ u, then

(cid:9)
λ1 > (1 + δ)λ2
0

(cid:10)

Pr

< e

Pr [λ1 < (1 − δ) (1 − λ0/2) λ0] < e

− δ2(1−e−λ0 )
− δ2(1−e−λ0 )

3

2

n,

n.

Beating the Birthday Paradox in Dining Cryptographer Networks

185

In general,

P r[λi+1 > (1 + δ)λ2

P r[λi+1 < (1 − δ) (1 − λ0/2) λi ≤ (1 − δ) (1 − λi/2) λi

i ≥ (1 + δ)λi(1 − e

−λi)] < e

− δ2(1−e−λi )

3

≤ (1 − δ)λi(1 − e

−λi)] < e

− δ2(1−e−λi )

2

n,

n.

The sequential process ﬁnishes when nf = 1 (or equivalently when λf =

1/m = n/λ0). Furthermore, since

(cid:9)

Pr

f−1(cid:2)

i=0

λi+1 > (1 + δ)λ2
i

(cid:10)

(cid:9)
λ1 > (1 + δ)λ2
0

(cid:10)

,

< Pr

Pr [λi+1 < (1 − δ) (1 − λ0/2) λi] < Pr [λ1 < (1 − δ) (1 − λ0/2) λ0] ,

f−1(cid:2)

i=0

then, by chaining all the inequalities,

(cid:11)

Pr

λ0/n = λf > ((1 + δ)λ0)2f ≥ ((1 + δ)λ0)2f

(cid:11)
λ0/n = λf < (Cλ0)2f ≤ (Cλ0)2f

Pr

(1 + δ)

C

(cid:12)

(cid:12)

− δ2(1−e−λ0 )

3

< e

n,

(2)

− δ2(1−e−λ0 )

2

< e

n,

(3)

with C = (1 − δ)(1 − λ0/2)λ0.

The theorem then follows by ﬁnding f from Eqs. (2) and (3), and taking the
(cid:2)

complement of these events.
It is important to note that this leads to O(log log(n)) rounds. In terms of space,
if m = n, this means we have a O(n log log(n)) space algorithm, improving the
O(n2) cost given by the birthday paradox.

Experimental Results. For the experiments we have considered δ = 0.1
and λ0 ∈ {0.3, 0.5, 0.7, 0.9}. Moreover, for each of these values, and for n ∈
{104, 105, 106} we have calculated low(n, λ0, δ), high(n, λ0, δ), calculated the
probability of f being in the estimated range, run 100 experiments, and seen
how f falls in the estimated range. The probability is estimated up to 10 decimal 
digits (so, errors less than 10−10, will lead to probability equal to 1).

The results are shown in Fig. 1. It can be seen that not only the upper and
lower bounds are very good but that all the experiments fall in the estimated
range of values.

186

P. Garc´ıa et al.

n λ0 Prob low
104 0.3 0.9996 2
104 0.5 0.9999 3
104 0.7 0.9999 3
104 0.9 0.9999 3
105 0.3
3
105 0.5
3
105 0.7
3
105 0.9
3
106 0.3
3
106 0.5
3
106 0.7
3
106 0.9
4

1
1
1
1
1
1
1
1

(cid:2)

(cid:3)

(cid:3)
log

lg

n
λ0

(cid:4)(cid:4)(cid:5)

high # low # low + 1 # low + 2

4
4
4
4
4
4
4
4
4
4
4
4

4
5
6
10
4
5
6
11
4
5
6
11

0
0
0
0
10
0
0
0
0
0
0
24

76
97
95
97
90
86
88
85
100
29
28
76

24
3
5
3
0
14
12
15
0
71
72
0

Fig. 1. Experimental results of the sequential protocol.

5 Parallel Repetition of DC-Nets

Section 3 presented a variant that relies on a reactive strategy on behalf of the
players. This implies that all players have to be online during the execution of
the DC-net protocol, in particular, during r = O(n log(log(n))) iterations. In
some situations this is not possible or even desirable.

In this section we present a solution for a round-optimal reliable version
of the DC-net protocol (just r + 1 rounds if the underlying unreliable DC-net
takes r rounds). In particular, it is almost non-interactive (just 2 rounds) if
the underlying DC-net is non-interactive (e.g. Golle-Juels). Like the original
versions, it consists of three phases: (1) a preliminary phase, in which all pairs
of players exchange random keypads; (2) a two round phase, consisting of a
commitment round followed by a broadcast round, in which each party publishes
one contribution; (3) a message computation phase, in which the actual messages
are computed.

In the strategy described in Sect. 3 phase 2 was repeated and parties adapted
their new inputs as a function of the results of phase 3. We change the model
in this section by assuming that repeating phases 2 and 3 is not possible. We
assume each party can only broadcast one contribution (message) in phase 2,
and that is her only chance. So if a collision occurs, it means that no posterior
correction is possible. This implies that the probability of a collision should be
made to be negligible.

At the cost of extra bandwidth, this is not diﬃcult to achieve: we assume
the existence of several (say k) copies of the same DC-net. We refer to each DCnet 
as a channel, (reserving the word net for the whole construction consisting
of k channels). Each party chooses randomly a diﬀerent slot in each channel
and sends the same contribution to each of these channels. Now we say that a
message transmission fails if the message collides in all the channels; it succeeds
if in at least one channel the message is alone in the slot.

Beating the Birthday Paradox in Dining Cryptographer Networks

187

Parallel Repetition of DC-Nets: As before, let Γ (M ) denote a single instance
of an unreliable DC-net protocol executed by players P1, . . . , Pn under input
M = (M1, . . . , Mn), where Mj is the input of player j.
We let ˆΓ (k) = Γ1||Γ2||···||Γk be the protocol consisting of k parallel repetitions 
of the same protocol Γ(cid:5) = Γ , for (cid:6) = 1, . . . , k. All players participate 
in each parallel protocol Γ(cid:5), (cid:6) = 1, . . . , k. In the description below, we
denote by ci = (ci,(cid:5))(cid:5)∈[k] the vector of slots randomly chosen by player Pi so
ci,(cid:5) ∈ [m] is the slot used in the (cid:6)-th parallel channel Γ . Protocol ˆΓ (k) takes
input M = (M1, . . . , Mn) and proceeds as follows:

1. First round, committing to the slots: Each player Pi chooses a kdimensional 
vector of slots ci = (ci,(cid:5))(cid:5)∈[k] by choosing each ci,(cid:5) uniformly
at random in [m]. Player Pi then computes and broadcasts the corresponding
vector of commitments Ci = Com(ci,(cid:5))(cid:5)∈[k].

2. Second round, computing the pads: Each player Pi prepares to runs k
copies of Γ , namely Γ1 through Γk, using the same input Mi in all parallel
executions Γ(cid:5). That is, if M(cid:5),i denotes the message used by player Pi in
execution Γ(cid:5), then M(cid:5),i = Mi and the slot used by player Pi is ci,(cid:5).

3. Second round, Computing the Proof of Unique Message: Each player
Pi then computes a zero-knowledge proof ρi that the same message is used
in each parallel copy of Γ .

4. Second round, broadcast of proofs and anonymous broadcast of
messages: Each player Pi broadcasts ρi and then runs runs k parallel copies
of protocol Γ , where any non-interactive zero-knowledge proof of correctness
is modiﬁed to also prove that the slot used (ci,(cid:5)) is consistent with the previously 
broadcast commitment Ci.
5. Second round, computing received messages in each parallel channel:
Each player ﬁrst checks that ρj is a valid proof for player Pj, j ∈ [n]. If not
and if there is a reconstruction procedure for Γ , this is triggered with respect
to player Pj in each parallel run. If there is no reconstruction procedure,
the whole parallel protocol aborts and starts again, excluding the misbehaving 
party. Let ExecΓ(cid:4)(P (M ;{ci}i∈[n]), A)(κ) denote the ﬁnal output of
protocol Γ(cid:5). The output of ˆΓ (k) is then the union (as sets) over (cid:6) ∈ [k] of
ExecΓ(cid:4)(P (M;{ci}i∈[n]), A)(κ).

The following section presents the analysis of the collision probability of this
approach in terms of the number of players n, the number of slots per channel
m, and the number of parallel channels k.

6 Analysis of Parallel Repetition of DC-Nets

The parallel DC protocol can also be modelled as a problem of balls-in-bins,
where as before balls correspond to messages and bins to slots (positions).

In this setting we have a total of S bins, n balls and k parallel channels.
In each channel, each of the n balls chooses a position among m = S/k bins.

188

P. Garc´ıa et al.

The ball i (1 ≤ i ≤ n) is successful if in at least one of the channels falls in a bin
with only one ball.

We want to calculate Pm,n,k, the probability that all balls are successful if k
parallel channels are used. Moreover, the goal, for given values of n and S = km
is to ﬁnd the value of k that maximizes Pm,n,k.

These kind of problems of balls-in-bins are known as the occupancy problem;
see for instance [7,18]. However, this speciﬁc problem does not seem to have been
analyzed.
We have obtained an exact expression for Pm,n,k which can be described as
a convolution of 2k − 1 nested sums. Even though this expression is exact, it is
very diﬃcult to handle and far from trivial. We present it here, but then we use
an approximate model to predict the probability of success.

In the sequel

denotes the Stirling numbers of the second kind (number of
ways of placing a elements in b non-empty sets). Moreover the falling factorials
are deﬁned as mj = m(m − 1)(m − 2) . . . (m − j + 1).

(cid:13)

(cid:14)

a
b

The proof of the following Fact can be found in the standard literature of

the problem (for example in [8]).

Fact 3. Let Cn,m be the number of ways of placing n balls in m bins in such
j≥0 mj+rCn−r,j. Moreover, let
a way that no bin has one ball, and Tm,n,r =
Nm,n,r be the number of ways of throwing n balls in m bins in such a way that
r of the bins contain 1 ball. Then

(cid:15)

(cid:14)
n−i
m−i

(cid:17)(cid:13)

(cid:16)

(cid:15)
i≥0(−1)i
(cid:17)
(cid:16)
Tm,n,r.
mn = mn
mn .

n
i

.

n
r

1. Cn,m =
2. Nm,n,r =
3. Pm,n,1 = Nm,n,n
Sketch of the proof: Using symbolic techniques (as in [8]), Nm,n,r = n![urzn]
(ez + (u − 1)z)m and CN,M = N![zn](ez − 1 − z)M .

(cid:16)

(cid:17)

n
r

A more direct approach will be useful for the generalization.

.

– Choose r balls to go to the r bins with one ball. This gives the factor
– Choose r bins and place the remaining n − r balls in the other m − r bins
in such a way that no bin has 1 ball. This gives the factor Tm,n,r. It can be
achieved as follows
1. Choose r bins to place 1 ball at each one (mr).
2. Choose j bins from the remaining m− r bins to place the n− r balls that
give collisions. There are (m − r)j ways of doing this. Together with the
previous selection, this gives a factor mr+j.
3. Place the (n − r) balls in the j bins in such a way that none of these j
bins are empty or have one ball. This contributes with the factor Cn−r,j.
(cid:2)
(cid:17)
,
Fact 3 clearly divides the calculation of Nm,n,r in two parts. The ﬁrst one,
is related with the selection of successful balls and the second one, Tm,n,r, with
the selection of the bins and placement of the unsuccessful balls. This division
is key to derive a general results for all k. Since we were unable to use symbolic
techniques for the problem, we present a direct approach.

n
r

(cid:16)

Beating the Birthday Paradox in Dining Cryptographer Networks

189

Theorem 4. Let Ik = {0 ≤ j1 = s1 ≤ n− t} ∪ {0 ≤ ji ≤ si ≤ n− t, 2 ≤ i ≤ k}
be a set of indices, δi = si − ji and Jk =
m,n,t be the probability
of having t failures when throwing n balls in k parallel channels with sets of m
bins. Then

ji. Let Q(k)

k(cid:18)

i=1

1. Q(k)

m,n,t = R(k)

m,n,t

nkm , with R(k)

m,n,t =

(cid:4)

(cid:4)

(cid:5) (cid:18)

c(k)

n,t

k(cid:2)

i=1

Nm,n,si and.

n
t

J0

Ik

(cid:5)

c(1)
n − t − s1
n,t = 1 which equals
(cid:4)
(cid:5)(cid:4)
n − t − Jk−2

c(k)
n,t =

(cid:16)

c(k−1)
n−t−sk−1

n,t
Jk−2

(cid:17)

when s1 = n − t,

(cid:5)(cid:4)

(cid:5)
,

Jk−1

n − t − sk

Jk−2
δk−1

2 ≤ k.

jk−1

(cid:16)

(cid:17)

n
t

2. Pm,n,k = Q(k)

m,n,0.

Sketch of the proof: The factor
gives the number of ways to choose the t
balls that fail in all the channels. As a consequence the other n−t balls should fall
in an bin with one ball in at least one of the channels. To analyze the algorithm
it is better to think it as a sequential process.

In this setting, si is the number successful balls in channel i, ji is the number
of balls whose ﬁrst successful try is channel i and Ji is the total number of
successful balls up to channel i, with 1 ≤ i ≤ k. Then s1 = j1 since this is the
ﬁrst successful channel for these balls, and jk = n − t − Jk−1 since at the end
n − t balls are successful (Jk = n − t).
Moreover, for 1 ≤ i < k, the ji balls whose ﬁrst successful try is channel i
should be taken from the ones that have failed in all previous channels (n−t−Ji−i
. Furthermore, the other δi = si − ji balls
of them), giving the factor
(cid:17)
.
should be chosen among the one already successful, giving the factor
Since sk are successful in the last channel, we have to choose the other n− t− sk
unsuccessful balls (but successful ones in the k channels) among the already
successful Jk−1 balls (giving the factor

n−t−Ji−1

Ji−1

).

(cid:16)

(cid:17)

(cid:16)

(cid:17)

(cid:16)

δi

ji

The recursive deﬁnition of c(k)

n,t then follows by induction on k (the number of
channels). Notice that when k = 1, c(1)
. Since J0 = 0 this coeﬃcient
is 0, unless s1 = n − t, when it takes the value of 1. This is actually the case,
since all the n − t balls should be successful in the ﬁrst try.

n−t−s1

n,t =

(cid:17)

J0

Jk−1
n−t−sk
(cid:16)

The proof is then completed by noticing that

Nm,n,si counts the number
of ways to place all the n − si balls in m − si bins in such a way that no bin has
(cid:2)
one ball.
Since this exact expression is very diﬃcult to handle with large numbers, and
asymptotic results are diﬃcult to achieve, an alternate, approximate approach
will be given to ﬁnd an analytic expression to predict the results found by our
simulations.

i=1

k(cid:2)

190

P. Garc´ıa et al.

As it is presented in Sect. 4, if n balls are thrown in m bins, then the expected

number of bins with 1 ball is

E[# bins with 1 ball] = n

(cid:4)

1 − 1
m

(cid:5)n−1

.

(4)

If n, m → ∞ this value can be approached by ne

V ar[# bins with 1 ball] = n(n − 1)

−n/m. Its variance is
(cid:5)

(cid:4)

(cid:4)

(cid:5)n−2
1 − 2
m
(cid:5)n−1 − n2

1 − 1
m
(cid:5)

(cid:4)
1 − 1
m

2n−2

(cid:4)

1 − 1
m

+ n

.

(5)

Moreover, since when n, m → ∞ this variance is approached by ne
−n/m), the number of bins with one ball is concentrated around its mean.
e

−n/m(1 −
In the approximate model, let p = (1 − 1/m)n−1. So the expected number
of bins with one ball is np. Then, p can be interpreted as the probability that a
given ball is successful when n balls are thrown in m bins. Furthermore q = 1− p
can be interpreted as the probability that a given ball fails, since it falls in an
bin with two or more balls.
In this setting, we may consider a Bernoulli process where the probability
that a given ball fails in all the k channels is qk. Hence, with probability (1− qk)
a given ball succeeds in at least one of the channels. As a consequence, the
probability that all the n balls succeed in at least one channel is (1− qk)n. Then,
we have the following approximation, with S = km.
Theorem 5. Let, in the approximate model, p = (1 − 1/m)n−1 and S = km.
Moreover, let ˆPS,n,k be the probability (in this model) that when n balls are thrown
in k parallel channels each with m bins, all the balls are successful. Then

1.

⎛
⎝1 −

(cid:21)
1 −

(cid:4)
1 − k
S

(cid:5)n−1

(cid:22)k

n

⎞
⎠

.

ˆPS,n,k =

2. When S, n → ∞ and k = o(S), then p ≈ e
1 − e

ˆPS,n,k ≈

1 −

(cid:4)

(cid:25)

−nk
S , and then

(cid:5)n

(cid:26)k

−nk

S

.

3. In this setting, for ﬁxed S and n, the optimal number of channels (the value

of k that maximizes ˆPS,n,k) is k = (cid:11) Sx0

n (cid:12) with x0 = log(2).

4. The optimal probability is

(cid:4)

S,n ≈
∗
ˆP

(cid:5)n

.

1 − 1
2 Sx0

n

Beating the Birthday Paradox in Dining Cryptographer Networks

191

5. For given n, the minimal value of S to achieve an exponentially small error

1/2b (with b a constant like 80, for example) is

S = n
x0

(b + lg(n)),

where lg is the base 2 logarithm.

Sketch of the proof: Parts 1 and 2 are straightforward.

For parts 3 and 4, to ﬁnd the optimal value of k, let us call x = kn/S and so

ˆPS,n,k ≈ − ˆPS,n,k n(1 − e
−x)k
1 − (1 − e−x)k

∂
∂k

(cid:4)

(cid:25)

log(1 − e

log(1 − e

(cid:5)

.

−x) + xe

−x
1 − e−x
(cid:26)
−x0) + x0e−x0
1−e−x0

= 0, giving
The maximum is at the value x0 such that
x0 = log(2). As a consequence, the optimal number of channels is k = (cid:11) Sx0
n (cid:12)
(note that since S = Ω(n), then k = o(S) as requested), and so, the optimal
probability in this setting satisﬁes:
S,n ≈
∗
ˆP

(cid:5)n

(6)

(cid:4)

.

1 − 1
2 Sx0

n

Moreover, for part 5, given n and a constant b (like b = 80), if we want an
S,n = 1 − 1/2b, with b > 0), then from (6) and
∗

exponentially small error in b ( ˆP
the approximation (1 − 1

2b ) 1

n2b + O( 1

n2 ) then S should verify:

n = 1 − 1
S = n
x0

(b + lg(n)),

where lg is the base 2 logarithm.

(7)

(cid:2)

Experimental Results. When S = o(n2) (e.g. n2−, for a constant  > 0)
−n). It is then reasonable to
the probability of success tends to 0 with n (e.g. e
assume for our experiments that S = O(n2).

It is very hard to compute the exact probabilities for large values of k and n
using Theorem 4; these values are calculated only up to k = 4 and small values
of n. We use this to check against the approximations calculated in parts 1 and
2 of Theorem 5. For k = 1 the approximation is very bad but we use the exact
value of mn/mn (S = m in this case).

Each experiment consists of running 100.001 trials and counting how many
successful trials are found. Underlined and in bold are the maximal probabilities
(in this case k = 10). The table shows that even for small values of n, the
approximate and asymptotic formulae agree very well with the experimental
results (and with the exact probabilities when they could be computed) (Fig 2).
The next table tests part 5 of Theorem 5. In this setting given b and n
the formula gives the minimum value of S such that, when using the optimal
number kopt of channels the probability of error is less than 2−b. We normalize

192

P. Garc´ıa et al.

-

-

S n k exact approx1 approx2 experimental
360 23 1 0.4877
0.7165
360 23 2 0.7566 0.7348
0.8848
360 23 3 0.8992 0.8961
0.9421
360 23 4 0.9500 0.9493
0.9654
0.9704
360 23 5
0.9763
0.9801
360 23 6
0.9849
0.9877
360 23 8
0.9891
360 23 9
0.9866
0.9898 0.9874
360 23 10
0.9873
0.9898
360 23 12
0.9838
0.9869
360 23 15
0.9759
0.9799
360 23 18
360 23 20
0.9718
0.9670
0.9348
0.9410
360 23 24
360 23 30
0.8246
0.8226

0.4861
0.7587
0.8967
0.9497
0.9717
0.9802
0.9878
0.9891
0.9901
0.9897
0.9865
0.9803
0.9717
0.9406
0.8248

-
-
-
-
-
-
-
-
-
-
-

Fig. 2. Experimental results for the probability of success for a total of S = 360 and
k = 23 messages, slightly adjusted values from the birthday paradox.

the probability of success with the estimated value of error, and the quotient
should be close to one. The table shows that even for small values of n the
formulae are very good. For values of b up to 15, the test is run 200001 times
(with an average of 8 failures) (Fig. 3).

−b)

n b Sopt kopt experimental/(1 − 2
23 12 549 16
23 15 648 19
30 12 732 16
30 15 862 19
40 12 1000 17
40 15 1173 20
50 12 1273 17
50 15 1490 20

1.000134
1.000015
1.000119
1.000005
1.000034
0.999995
1.000024
1.000010

Fig. 3. Experimental results for the number of slots needed to guarantee a probability
of failure less than 2

−b. Ideally the last should be 1

7 Instantiating the Two Approaches

The two composition strategies analyzed in this paper can be instantiated with
several DC-nets yielding diﬀerent overall properties. Using an information-theoretical 
DC-net like the one proposed by van de Graaf [21] (based on the DCnet 
proposed by Chaum [4]) we can obtain privacy against computationally
unbounded adversaries. If, instead, we use Golle and Juels’ (short) DC-net [17],
then privacy against polynomial-time adversaries can be achieved. Moreover, the

Beating the Birthday Paradox in Dining Cryptographer Networks

193

reconstruction procedure of Golle-Juels’ DC-net translates into a collision-free
iterated DC-net with stronger robustness, where misbehaving parties can not
only be detected, but their contribution removed from the protocol result.

In any case, the analysis of the collision probability of Sects. 4 and 6 only
assumed two conditions over the underlying DC-net channel: (a) the adversary
can disrupt at most one slot per compromised party in each broadcast, where
the disrupted slot cannot depend on the slot selection by honest parties; and
(b) for the parallel construction, each party must transmit the same message
in all parallel channels. Condition (b) can be easily achieved by using (possibly 
information-theoretically hiding) commitments and non-interactive zeroknowledge 
proofs. Condition (a), on the other hand, it is trickier to achieve. In
fact, contrarily to what it was claimed, the well-known DC-net protocol by Golle
and Juels [17] does not achieve this property. Section 8 explains the attack and
presents a simple modiﬁcation that ﬁxes the protocol.

We believe the two conditions mentioned above suﬃce to prove security in the
standalone model under a reasonable deﬁnition of secure, single-channel DC-net.
Due to space constraints a formal deﬁnition of security as well as the security
proof for the constructions are left to the full version of this paper.

Cost Analysis. In order to evaluate the overhead of the two composition strategies,
 we compare them with a single execution of a DC-net achieving a similar
collision probability. Given the assumptions mentioned above, the cost associated 
to a single DC-net execution with S slots and n senders (each one sending a
single message) is at least O(n) commitments for the slots (one per sender), plus
the total numbers of bits CS,n transmitted during a single DC-net with S slots
and n players. Furthermore, we make the reasonable assumption that CS,n is
linear in S. The computation costs are simply those associated to computing the
commitments and verifying the committed slots are consistent with the actual
slots used.2

In terms of communication costs, our sequential repetition approach with n
senders, m = n slots and r = log log(n) rounds requires sending O(n log log(n))
commitments (one per sender per round), plus O(Cn,n log log(n)) bits. In terms
of computation costs, it is easy to see that the costs are r times the cost of
executing a single DC-net.
(cid:12)
For the parallel repetition approach with n senders, S slots and k = (cid:11) S log(2)
parallel executions, the total communication costs are now O(nk) commitments
(one per sender per parallel channel), the total length of the proof of message
equality among parallel channels (namely nTk bits if the cost of such proof is Tk
per sender) plus kCS/k,n bits, the communication costs of k parallel executions
of a S/k-slot DC-net. The computation costs are k times the cost of running a
single DC-net plus the costs associated to computing the commitments and the
proofs, and then verifying the committed slots are consistent with the actual
slots used.
2 The exact computation costs depends on the DC-net used.

n

194

P. Garc´ıa et al.

In order to achieve a high enough probability of success (a probability that
does not goes to 0 when n tends to inﬁnity), the standard single-channel DCnet 
must use Ω(n2) slots. But, even assuming O(n2) slots for the single-channel
DC-net, the communication overhead of our sequential repetition construction
is much less since it is O(Cn,n log log(n)).

For the parallel repetition construction, the communicational overhead is
O(nTk) bits from the proofs of message equality plus the extra commitments
(O(nk) = O(S) compared with O(n)). The computational overhead is simply
the costs of verifying the proofs of message equality. This follows from the fact
that running k = S/n copies of a single n-slot DC-net is comparable to running
a single S-slot DC-net both in communication as well as computational costs. To
the contrary of a standard DC-net, our construction guarantees an exponentially
small probability of failure (part 5 of Theorem 5 for b = n) with only O(n2) space.

8 Jamming Attack on Golle-Juels’ DC-Net

In the abstract of their paper [17], Golle and Juels argue that their construction
achieves “high-probability detection and identiﬁcation of cheating players”. It
turns out that this is not quite true if the messages sent are not encrypted (the
standard case when DC-nets are used as broadcast channels), as the malicious
players can still disrupt honest players’ transmissions by causing collisions with
probability 1 – well above the collision probability of honest users – without
being detected. Details follow.

The Golle-Juels’ short DC-Net protocol (see Appendix A for a more detailed
description) follows Chaum’s standard DC-net paradigm where each player Pi
initially prepares a m-dimensional vector (or “pad”). This pad satisﬁes a neat
property: if no player sends messages, the pair-wise multiplication of all player’s
pads results in the all-ones m-dimensional vector. Player Pi can use this property 
to transmit a message Mi (cid:13)= 1 by simply multiplying Mi into one of the
components of his pad. The index of this component, called Pi’s communication
slot and denoted ci, is chosen uniformly at random in [m].

To prevent that a malicious player transmits several messages simply multiplying 
them into diﬀerent component of the pad, a distinguished characteristic of
Golle-Juels’ protocol is that it uses proof of knowledge techniques [16] to force
each player to select at most one slot. Then, since a corrupted player ˆPj can
choose at most a single slot to transmit a value, it may seem that ˆPj cannot
do more harm that an honest player: both honest players and corrupted players
would have the same collision probability as the other players.

Unfortunately, this reasoning is ﬂawed if the adversary is rushing [13].
A rushing adversary is allowed to “speak last” in every communication round,
even in synchronous networks. Consider now a single player ˆPj corrupted under
such an adversary. This player can wait until all honest players have submitted
their pads and proofs, and then

Beating the Birthday Paradox in Dining Cryptographer Networks

195

1. internally and privately compute the resulting output by using an honestlyproduced 
pad as its own ( ˆPj’s pad). This allows the adversary to not only
obtain the messages sent by all honest parties, but also identify all the positions 
where those messages were sent (it does NOT allow the adversary to
know who sent it, though). And then,

2. the adversary can “choose” ˆPj’s slot cj to be equal to any of the slots where
honest parties have sent their messages. Clearly, the adversary can also choose
the value of ˆPj’s message Mj; this message can be chosen so the “collision”
with the honest player’s message in slot cj produces an arbitrary message of
the adversary’s choice. Then, ˆPj outputs his (honestly computed with slot
cj) pad and proof.

The resulting message in slot cj will be completely controlled by the adversary:
it can be made look like a collision or not3. Furthermore, this strategy gives free
range for the adversary to select her target slot: for example, the adversary could
select a position based on the value of the honest player’s message. Clearly, the
outcome is a collision with probability 1.

Fixing the problem: We can prevent the attack by simply forcing each player to
commit to her slot using non-malleable commitments [1]. Consider the description 
of the protocol given in Appendix A. To prevent the degenerate case where
a corrupted player copies everything (commitments, pads, proofs) together, one
could modify these proofs to assure that the secret exponent xi used in the com-
, for each θ ∈ [m], is the same exponent on Pi’s public
putation of the pad W (θ,(cid:5))
key yi. This worst case can be dealt, however, much more easily by rejecting
repeated proofs under some ﬁx ordering of the players.

i

Acknowledgements. The authors would like to thank the anonymous referees for
their helpful comments and suggestions which signiﬁcatively helped to improve the
paper presentation. The third author also thanks the support of INRIA Chile.

A The Golle-Juels’ DC-Net

The DC-net protocol proposed by Golle and Juels [17] (called Short DC-net)
directly extends the ideas from Chaum’s DC-net [4]. In Chaum’s original protocol,
 parties share secret keys (called keypads) in a pairwise fashion, which
satisﬁes that the addition of all keypads eﬀectively cancels out. To broadcast
a message, a party Pi adds (xors) the message into one of her pairwise-shared
keypads, so when keys are later combined, keys cancel out leaving her message
as the result. Notice that the Chaum’s original protocol outputs at most a single
message per execution.

Golle and Juels’ protocol dispenses with sharing private keys by having
each pair of parties non-interactively compute the keypads as Diﬃe-Hellman

3 See [2] for techniques to always detect this situation as a collision.

196

P. Garc´ıa et al.

keys. These keypads satisfy the same property – they cancel out once all are
combined – and enjoy speciﬁc algebraic properties (inherited from the pairingbased 
key agreement used) that allow public veriﬁcation of correctness of each
party’s keypad. In consequence, misconstructed keypads can be identiﬁed. Moreover,
 since each party’s private keys are initially threshold-shared among for all
parties, reconstruction of incorrectly-computed keypads is possible.

The full protocol is detailed below.

Common Public Inputs: k ∈ N, the security parameter, n ∈ N the number
of parties, t ∈ N a ﬁxed integer, z ∈ N a counter, and (cid:6) ∈ N the parallel
index. Also, G1, G2, e, g1, g, h, where G1, G2 are cyclic groups of prime order
p = O(2k), such that e: G1 × G1 → G2 is an admissible pairing, g1 is a
generator of G1, and g, h are independently-chosen generators of G2, and
H : { 0, 1}∗ → G1 a collision-resistant hash function.

to private key xi.

xi
Public Inputs: y1, . . . , yn, where yi = g
1 is the public key of Pi corresponding
Private Inputs: Pi has input Mi ∈ G2, and secret key xi ∈ Zp. V´ıa a one-time
setup procedure, Pi also gets a private key gets a (n, t)-share xj,i of party
Pj’s the secret key xj.
Public Output: Each honest Pi obtains a multiset M = {M1, . . . , Mn} ⊂ G2

consisting of (almost) all messages sent by parties.

1. First, Pi creates a shared pad by computing, for each θ ∈ {1, . . . , n}

(1) Transmission Step: In this round, each party Pi does as follows:
← Πj∈{1,...,n},j(cid:6)=ie(Qθ,(cid:5), yj)δi,j xi

$← H(z||θ||(cid:6)) and W (θ,(cid:5))

Qθ,(cid:5)
where δi,j = 1 if i < j and −1 otherwise.

i

2. Pi then chooses ci

vector V ((cid:5))
i ← W (θ,(cid:5))
V (θ,(cid:5))

i = (V (θ,(cid:5))
i
if not.

i

$← {1, . . . , n}. Then, Pi computes her transmission
← mi · W (θ,(cid:5))
)θ∈{1,...,n} as V (θ,(cid:5))
if θ = ci and
i,θ}θ∈{1,...,n}) as
i,{σ
(cid:7)(cid:7)
(cid:7)

i

i

3. Pi computes the veriﬁcation information σi = (σ

follows:
(a) For each θ∈{1, . . . , n}, Pi does the following:

i

, σi) be the values broadcast by Pi. Each Pj veriﬁes the validity 
of proofs σi. Let Ω ⊂ {1, . . . , n} be the subset of parties whose
proofs fail. If Ω = ∅, each Pj outputs the multiset M deﬁned by M ←
{ Πi∈{1,...,n}V (θ,(cid:5))
: θ ∈ [m] }. and ﬁnishes the protocol. Otherwise, set
M ← ∅ and execute the reconstruction phase of the protocol.

i

i. Pi picks ri,θ

$← Zp, and sets di,θ ← hri,θ if θ (cid:13)= ci, and di,θ ← ghri,θ
i,θ as P oK{(xi, ri,θ) : (V (θ,(cid:5))
(cid:7)(cid:7)

= e(Πj∈{1,...,n},j(cid:6)=iy

δi,j
j

ii. Pi computes σ

if θ = ci.
Qθ,(cid:5))xi ∧ dθ = hri,θ) ∨ (dθ = ghri,θ)}.

i

j∈{1,...,n} rj as the witness, Pi computes σ

,
i as P oK{ r ∈
(cid:7)

(b) Using r =
Zp : (Π n

(cid:15)
θ=1(dθ))/g = hr }.
, σi).

4. Pi then broadcasts (V ((cid:5))
5. Let (V ((cid:5))

i

Beating the Birthday Paradox in Dining Cryptographer Networks

197

(1) Correction Step: If xj is the secret key of party Pj, we let xi,j be the
xi,j
private share of xj hold by Pi, and let yi,j = g
be the corresponding public
1
share. We assume the shares were computed using known techniques, eg. [14],
so they satisfy xi,j = fi(j) where fi(x) is a random polynomial of degree
(t − 1) such that fi(0) = xi. Let λi,Γ = Πj∈Γ,j(cid:6)=i
j
j−i be the corresponding
Lagrange coeﬃcients used to recover xj from the shares xj,i, that is, xj =
(cid:15)

i∈Γ xj,iλi,Γ .
In this round, each party Pi reconstructs the shared pad for each (misxj,
i
θ,(cid:5)

for each θ ∈ {1, . . . , n}.

behaving) party Pj in Ω as by working as follows:
1. First, Pi broadcasts Zj,i ← Q
2. Let Θ = {Zu,v} be the set of all broadcast shares, where Zu,v was sent
by Pv. Each party checks the validity of share Zu,v by checking that
e(Zu,v, g1) ?= e(yu,v, Qθ,(cid:5)). Let Γ ⊂ Θ be a subset of shares that satisfy
the above validity condition, where |Γ| = t.
3. Then, Pi reconstructs the shared pad for each party Pj ∈ Ω as follows:
for each θ ∈ {1, . . . , n}, ˆV (θ,(cid:5))
← Πu∈{1,...,n},u(cid:6)=je(Πi∈Γ Z
4. Finally, Pi outputs the multiset M ← { Πi∈{1,...,n}\ΩV (θ,(cid:5))
θ ∈ [m] } and ﬁnishes the protocol.

, yu)δj,u.
· Πj∈Ω ˆV (θ,(cid:5))

λi,Γ
j,i

j

i

j

:

References

1. Abdalla, M., Benhamouda, F., Blazy, O., Chevalier, C., Pointcheval, D.: SPHFfriendly 
non-interactive commitments. In: Sako, K., Sarkar, P. (eds.) ASIACRYPT
2013, Part I. LNCS, vol. 8269, pp. 214–234. Springer, Heidelberg (2013)

2. Barthe, G., Hevia, A., Luo, Z., Rezk, T., Warinschi, B.: Robustness guarantees for

anonymity. In: CSF, pp. 91–106. IEEE Computer Society (2010)

3. Chaum, D.: Untraceable electronic mail, return addresses, and digital pseudonyms.

Commun. ACM 24(2), 84–88 (1981)

4. Chaum, D.: The dining cryptographers problem: Unconditional sender and recipient 
untraceability. J. Cryptology 1(1), 65–75 (1988)

5. Corrigan-Gibbs, H., Ford, B.: Dissent: accountable anonymous group messaging.
In: Al-Shaer, E., Keromytis, A.D., Shmatikov, V. (eds.) Proceedings of the 17th
ACM Conference on Computer and Communications Security, CCS 2010, pp. 340–
350. ACM (2010)

6. Corrigan-Gibbs, H., Wolinsky, D.I., Ford, B.: Proactively accountable anonymous
messaging in Verdict. In: King, S.T. (ed.) USENIX Security, pp. 147–162. USENIX
Association (2013)

7. Feller, W.: An Introduction to Probability Theory and its Applications, 3rd edn.

Wiley, New York (1968)

8. Flajolet, P., Sedgewick, R.: Analytic Combinatorics. Cambridge University Press,

New York (2009)

9. Franck, C.: Dining cryptographers with 0.924 veriﬁable collision resolution. CoRR,

abs/1402.1732 (2014). http://arxiv.org/abs/1402.1732

10. Franck, C., van de Graaf, J.: Dining cryptographers are practical (preliminary

version). CoRR, abs/1402.2269 (2014). http://arxiv.org/abs/1402.2269

11. Garc´ıa, P.: Optimizaci´on de un protocolo noninteractive dining cryptographers.
Master’s thesis, Universidad Nacional de San Luiz, 2013. Universidad Nacional de
San Luiz (2013)

198

P. Garc´ıa et al.

12. Garc´ıa, P., van de Graaf, J., Montejano, G., Bast, S., Testa, O.: Implementaci´on
de canales paralelos en un protocolo non interactive dining cryptographers. In:
43 Jornadas Argentinas de Inform´atica e Investigaci´on Operativa (JAIIO 2014),
Workshop de Seguridad Inform´atica (WSegI 2014) (2014)

13. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Secure distributed key generation 
for discrete-log based cryptosystems. In: Stern, J. (ed.) EUROCRYPT 1999.
LNCS, vol. 1592, pp. 295–310. Springer, Heidelberg (1999)

14. Gennaro, R., Jarecki, S., Krawczyk, H., Rabin, T.: Secure distributed key generation 
for discrete-log based cryptosystems. In: Stern, J. (ed.) EUROCRYPT 1999.
LNCS, vol. 1592, pp. 295–310. Springer, Heidelberg (1999)

15. Goel, S., Robson, M., Polte, M., Sirer, E.G.: Herbivore: A scalable and eﬃcient protocol 
for anonymous communication. Technical report TR2003-1890, Computing
and Information Science, Cornell University (2003). http://www.cs.cornell.edu/
people/egs/papers/herbivore-tr.pdf

16. Goldwasser, S., Micali, S., Rackoﬀ, C.: The knowledge complexity of interactive

proof systems. SIAM J. Comput. 18(1), 186–208 (1989)

17. Golle, P., Juels, A.: Dining cryptographers revisited. In: Cachin, C., Camenisch,
J.L. (eds.) EUROCRYPT 2004. LNCS, vol. 3027, pp. 456–473. Springer, Heidelberg
(2004)

18. Kolchin, V., Sevastyanov, B., Chistyakov, V.P.: Random Allocations. Wiley, New

York (1978)

19. Pedersen, T.P.: Non-interactive and information-theoretic secure veriﬁable secret
sharing. In: Feigenbaum, J. (ed.) CRYPTO 1991. LNCS, vol. 576, pp. 129–140.
Springer, Heidelberg (1992)

20. Pﬁtzmann,

A.:

teil-
nehmer¨uberpr¨ufbarem Datenschutz. Informatik-Fachberichte, vol. 234. Springer
(1990)

Kommunikationsnetze mit

Diensteintegrierende

21. van de Graaf, J.: Anonymous one-time broadcast using non-interactive dining cryptographer 
nets with applications to voting. In: Chaum, D., Jakobsson, M., Rivest,
R.L., Ryan, P.Y.A., Benaloh, J., Kutylowski, M., Adida, B. (eds.) Towards Trustworthy 
Elections. LNCS, vol. 6000, pp. 231–241. Springer, Heidelberg (2010)

22. Waidner, M., Pﬁtzmann, B.: The dining cryptographers in the disco: unconditional 
sender and recipient untraceability with computationally secure serviceability 
(abstract). In: Quisquater, J.-J., Vandewalle, J. (eds.) EUROCRYPT 1989.
LNCS, vol. 434, p. 690. Springer, Heidelberg (1990)

