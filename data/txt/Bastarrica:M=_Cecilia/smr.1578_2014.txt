JOURNAL OF SOFTWARE: EVOLUTION AND PROCESS
J. Softw. Evol. and Proc. 2014; 26:434–450
Published online 11 February 2013 in Wiley Online Library (wileyonlinelibrary.com). DOI: 10.1002/smr.1578

AVISPA: a tool for analyzing software process models

Julio A. Hurtado Alegría1,2,*,†, María Cecilia Bastarrica1 and Alexandre Bergel1

1Department of Computer Science (DCC), University of Chile, Chile

2IDIS Research Group, University of Cauca, Colombia

ABSTRACT

Deﬁning and formalizing the software development process is a common means for improving it. Software
process modeling is often a challenging and expensive endeavor, because a well speciﬁed process may still include
inefﬁciencies that are hardly detected before enacting it. Thus, assessing process quality is a relevant concern to
improve several aspects such as conceptual integrity, correctness, usability, maintainability, and performance,
among others. This paper describes AVISPA, a graphical tool that allows analyzing the quality of SPEM 2.0
software processes models. AVISPA identiﬁes a series of error patterns and highlights them in different blueprints.
A detailed description of the internals of AVISPA is provided to show both its structure and its extensibility
mechanisms. We also present an interactive mechanism to deﬁne new analysis scripts and to implement new
patterns and blueprints. This paper illustrates the application of AVISPA in an industrial case study where process
engineers are assisted to analyze the quality of their process. Copyright © 2013 John Wiley & Sons, Ltd.

Received 18 March 2012; Revised 14 August 2012; Accepted 19 October 2012

KEY WORDS:

software visualization; software process veriﬁcation; software process analysis

1. INTRODUCTION

A software process is a set of partially ordered process steps, with related artifacts, human and
computerized resources, organizational structures and constraints, intended to produce and maintain
the requested software deliverables [17]. A well-deﬁned software process model is a determinant
factor for achieving quality products and productive projects [10]. However, deﬁning a software
process model demands an enormous effort for making explicit common practices and deﬁning
practices that may not yet exist within the company. Standards such as the ISO/IEC15504 and
maturity models such as the Capability Maturity Model Integration (CMMI) are commonly used as
guidelines for deﬁning this process. However, there is still no standard wide-spread mechanism for
determining the quality of a deﬁned process, and thus the return-of-investment of software process
deﬁnition is not always apparent.

We have previously proposed process model blueprints [12] for visualizing and analyzing different
perspectives of a software process model. The three blueprints (ROLE BLUEPRINT, TASK BLUEPRINT,
and WORK PRODUCT BLUEPRINT) are applied to software process models deﬁned using SPEM 2.0
[19]. These blueprints enable the identiﬁcation of exceptional entities [6], that is, exceptions in the
quantitative data collected. Blueprints are successfully employed to identify ﬂaws in industrial
process models, but the process engineer knowledge still plays a key role in the analysis. We have
assessed several industrial process models and we discovered a set of recurrent errors [13].

For the last 6 years we have worked with a number of small software companies in Chile to deﬁne
their development processes in an effort to improve national industry standards. As part of this
practical experience, we have identiﬁed some recurrent errors in software processes. Some of them

*Correspondence to: Julio A. Hurtado Alegría, IDIS Research Group, University of Cauca, Colombia
†E-mail: ahurtado@unicauca.edu.co

Copyright © 2013 John Wiley & Sons, Ltd.

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

435

are due to conceptual errors in the process design and others are introduced during process
speciﬁcation. These errors are not easily identiﬁed and localized using traditional process modeling
tools because of a possibly large amount of process elements involved, multiple views, and informal
notations that may sometimes introduce ambiguity.

We have built AVISPA (Analysis and VIsualization for Software Process Assessment),a a tool that
builds blueprints and highlights error patterns for a given process model. Error patterns are identiﬁed
with process elements that are graphically ‘abnormally different’ from the remaining elements [6].
Counting on this tool, the process engineer only needs to analyze highlighted elements, demanding
little experience and also little previous knowledge for effective process model analysis, adding
usability as well. Visualization is a well known approach to identify anomalies and errors that
cannot be determined otherwise by letting software engineers use their ability to recognize cognitive
patterns [15]. A large body of research use visual patterns to identify positive or negative properties
of software systems [14, 22, 27]. However, none of the related work we are aware of elaborates on
visual patterns for identifying problems in software process models. Figure 1 depicts the pile of
technologies involved in our approach. Software process models speciﬁed in SPEM 2.0 are assumed
to exist. On top of them we deﬁne a series of metrics that are used for identifying errors and
improvement opportunities. Software process blueprints are visual representations of these metrics.

This paper presents a description of AVISPA detailing its blueprints and error patterns. It also
provides a description of its internal structure and the means for extending it in terms of new
blueprints or new error patterns. A discussion about the appropriate statistical precision of the
patterns is included.

We have analyzed the process model of a Chilean software company using AVISPA. In addition to
our previous case studies, we have found several of the deﬁned error patterns, and most of them
resulted in actual errors. AVISPA has been highly welcomed in the company and process engineers
also pointed out that it is relevant for them to count on AVISPA for maintaining their software
process model, an application we have not envisioned before. Similar results were obtained in three
other companies [13].

This article extends our previous work [13] by relating our experience, lessons learned, and

providing some critical detail of our tool.

The rest of the paper is structured as follows. Section 2 presents a description of empirically found
error patterns, their implications, and how they look in AVISPA. A detailed description of the structure
of AVISPA is included in ecrefavispa including extension scenarios. Its application for localizing error
patterns in an industrial software process model is reported in Section 4. Related work is discussed in
Section 5, and some conclusions and further work are presented in Section 6.

2. SOFTWARE PROCESS MODELS, BLUEPRINTS, AND ERROR PATTERNS

For the past 6 years we have conducted applied research in the area of software process models in small
software companies in Chile [26] and Iberoamerica [23]. Along this work we have identiﬁed a number
of common errors and problematic situations in software process model speciﬁcations, either because
of misconceptions or misspeciﬁcation. In this section we report a series of these patterns and how they
may be identiﬁed with AVISPA. We say that there is a misspeciﬁcation in the software process model if
the development process is well designed but its speciﬁcation does not necessarily reﬂect the actual
practices, for example, there exist some guidance for a role but it is not speciﬁed as part of the
model. We say that there is a misconception whenever there is a ﬂaw in the software process design,
for example, a task produces a work product that is not a deliverable and neither a task nor a role needs.

2.1. Software process models

Modeling a software process refers to the deﬁnition of the process as a model [1]. A process model
provides deﬁnitions of the process to be used, instantiated, enacted, or executed. Therefore, a process

ahttp://www.moosetechnology.org/tools/ProcessModel. AVISPA is free under the MIT license.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

436

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

Figure 1. Technology pile implementing AVISPA.

model can be analyzed, validated, simulated or executed if it is appropriately deﬁned according to these
goals. Some beneﬁts of software process modeling are [5]: ease of understanding and communication,
process management support and control, provision for automated orientation and process performance,
provision for automated execution support and process improvement support.

SPEM 2.0 (Software and Systems Process Engineering Metamodel) [19] is a standard proposed by
the Object Management Group (OMG). It is based on the Meta Object Facility and it is the most
popular language used to specify software processes. The SPEM conceptual model, as depicted in
Figure 2, allows identifying roles that
related skills, competencies, and
responsibilities in the development team. Roles are responsible for speciﬁc types of work products.
For creating and modifying work products, roles are assigned as performers in tasks where speciﬁc
types of work products are consumed (inputs) and produced (outputs). Although the SPEM
metamodel provides several other features, these three concepts together with guidance, are the key
elements used by AVISPA.

represent a set of

2.2. Process model blueprints

ROLE BLUEPRINT, TASK BLUEPRINT, and WORK PRODUCT BLUEPRINT are three graphical views of a
software process model provided by AVISPA. Each of them focuses on a particular aspect of the
process model, namely roles, tasks, and work products, respectively. Each blueprint is depicted as a
polymetric view [14].

In the ROLE BLUEPRINT, nodes are roles whose size represents the number of tasks in which they are
involved, and edges between two nodes indicate role collaboration between roles. Figure 3 shows an
example ROLE BLUEPRINT.

In the TASK BLUEPRINT, nodes are tasks whose height and width represent the number of input and
output work products of the task, respectively. Edges between two nodes represent precedence: a task
T1 precedes another task T2 if there is an output work product of T1 that is an input work product of
T2. Figure 4 depicts a TASK BLUEPRINT. The color indicates the number of roles involved.

In the WORK PRODUCT BLUEPRINT nodes represent work products whose dimensions represent the

number of tasks that write and read the work product, respectively.

An edge between two work products WP1 and WP2 implies that there is a task that consumes WP1

and produces WP2.

Figure 2. Conceptual model of SPEM.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

437

Figure 3. ROLE BLUEPRINT.

Figure 4. TASK BLUEPRINT where potential errors are suggested but not localized.

2.3. Error patterns

There is a number of anomalies in software process speciﬁcations we have realized that are recurrent.
We call them error patterns. We here describe some of them along with their consequences and how
they would look in the blueprint where they may be found. We also provide a tentative
quantiﬁcation for how bad may be considered too bad, to automate their location.

2.3.1. Isolated roles. There may be certain tasks that a role executes by itself, but it is not frequently
right to have a role that never collaborates in any task with other roles. In general, this kind of error
pattern shows a misspeciﬁcation: a role should have been assigned to take part in a certain task but
appears to be left apart. This error pattern is apparent in the ROLE BLUEPRINT.

2.3.2. Independent subprojects. In a TASK BLUEPRINT and a WORK PRODUCT BLUEPRINT, tasks and
work products are related with edges indicating precedence. The process model speciﬁes the way to
proceed when working on one unique project, so it is conceptually odd to have disconnected
subgraphs in both blueprints. In general, these situations arise because of underspeciﬁcations, when
work products have not been speciﬁed as input or output of certain tasks when they should have.

2.3.3. Overloaded roles. If a role is involved in a large number of tasks, it becomes a risk; if it fails,
all the associated tasks will fail as well. This is a possible error in the process model conception. Better
choices would be either specializing the role by dividing its responsibilities or reassigning some tasks
to other roles. We would say that a role is overloaded if it is more than one standard deviation larger
than the average size. This error pattern is shown in the ROLE BLUEPRINT.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

438

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

2.3.4. Multiple purpose tasks. A process where tasks have too many output work products may reveal
that these tasks are not speciﬁed with the appropriate granularity. A task with too many output work
products may be too complex because its goal is not unique. This may reﬂect a misconception in the
process model. This pattern is seen in the TASK BLUEPRINT. We consider a task to be too complex
if it is wider than one standard deviation from the average task width.

2.3.5. Demanded work products. Work products required for a high number of tasks may cause
serious bottlenecks when they are not available, and thus this pattern could reveal a misconception.
This situation is seen in the WORK PRODUCT BLUEPRINT where we highlight nodes whose width is
more than one standard deviation from the average.

2.3.6. Roles, tasks, and work products without guidance. If a role, task, or work product has no
guidance about how to be executed, there is a big chance that it will not be properly executed. This
error is generally a misspeciﬁcation, meaning that there should have been certain guidance associated
with each element. In the respective blueprint we highlight elements without guidance.

2.3.7. Waste work products. Deliverables are those artifacts that need to be handed to the customer
as part of the ﬁnal product. Work products may be either deliverables or intermediate work products
needed for coordinating successive tasks. However, if there are work products that are neither
deliverables nor input for any task within the process, they are waste. All leaves in the WORK
PRODUCT BLUEPRINT, that is, nodes with no successor, should represent deliverable work products.
AVISPA highlights all those leaves that are not deliverables. The process engineer needs to analyze
all highlighted nodes so that he/she could determine if they are actually required as input of a task,
and thus they are not leaves, if they should have been deﬁned as deliverables, or if they are actually
waste in the process.

Table I summarizes the error patterns that have been identiﬁed so far.
Isolated roles and Independent subprojects are always underspeciﬁcations. Overloaded roles, Multiple
purpose tasks and Demanded work products are exceptional elements in the blueprints and they suggest
possible conceptual errors. Roles, tasks and work products without guidance, and Waste work products
are not apparent in blueprints but still reveal improvement opportunities.

3. THE AVISPA TOOL

This section describes the implementation of AVISPA including the technologies involved, its structure,
the scripts for implementing two of the error patterns, and a scenario for extending the tool.

Error pattern

Description

Localization

Identiﬁcation

Table I. Error patterns identiﬁed by AVISPA.

A role that does
not collaborate
Independent subgraphs

A role involved in
too many tasks

Isolated role

Independent
subprojects
Overloaded role

TASK BLUEPRINT or
WORK PRODUCT BLUEPRINT
ROLE BLUEPRINT

A node that is not connected
with an edge
Subgraphs that are not
connected with edges
Nodes over one deviation
larger than the mean
Nodes whose more than one
Multiple purpose Tasks with too many
tasks
deviation wider than the mean
output work products
Demanded Work Work products required WORK PRODUCT BLUEPRINT Nodes more than one deviation
products
No guidance
associated
Waste
Work products

for too many tasks
An element with no
guidance associated
Independent subgraphs WORK PRODUCT BLUEPRINT Work products that are neither
Useless work products

higher than the mean

ROLE BLUEPRINT

TASK BLUEPRINT

any blueprint

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

deliverables nor input for any task

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

439

3.1. AVISPA technologies

The expressiveness of AVISPA stems from combining meta-modelisation and visualization techniques.
A process model, described in an XML ﬁle, is parsed and each structural element is reiﬁed to form an
instance of our SPEM meta-model. We provide a set of metrics and navigation queries that may be
computed on any SPEM model. The process structure and the result of the metrics are then
graphically rendered.

AVISPA is built at the top of the Moose software analysis platform.b We have deﬁned the SPEM
metamodel as an extension of the FAMIX metamodel family.c Mondriand is an agile visualization
engine to easily build polymetric views [14]. Mondrian operates on any arbitrary set of values and
relations to visually render graphs. As exempliﬁed in the coming sections, visualizations are speciﬁed
with the Mondrian domain speciﬁc language.

AVISPA has become a reliable tool to import and visualize SPEM 2.0 based process models. It is
built on top of Moose and the PHARO programming language,e and so it beneﬁts from a large
toolset for navigation and visualization. Its navigation panel shows four entry points to begin an
analysis: activities, artifacts, roles, and tasks. Navigation is realized through the information available
in the metamodel. Metrics and other speciﬁc information (textit, e.g., descriptions and annotations) are
also available.

3.2. AVISPA architecture

From an architectural point of view, AVISPA follows a layered pattern, as shown in Figure 5. The
AvispaImporter module has the responsibility of creating an AVISPA model from an XML model
provided by the Eclipse Process Framework (EPF). The AvispaModel module has
the
responsibility of representing process blueprints and calculating programmed metrics. AvispaUI
includes navigation and visualization scripts. These functionalities are illustrated in Figure 6.
Importers, models, model elements, navigation, and visualization modules have been implemented
and integrated using abstract solutions of the Moose technology.

Figure 7 shows how a process model is imported. It starts from a MoosePanel object, where
the import event is caught by a ProcessModelImporterCommand object and it gets the process
model sending the importXML message to the ProcessImporter object. In the importXML of
the ProcessImporter object, each process element
is imported by using the class method
fromXMLDescription and stored in collections, which are used for building the process model. Then
the process model internal relationships are resolved using the resolveReferences method and the
metrics are initialized via initializeMetrics method. Metrics have been programmed in each process
model element. Finally, the model is installed in the Moose platform and the model is added to the
MoosePanel using the ProcessModelImporterCommand object.

Figure 8 shows how a visualization is performed. In this case,

the visualization is about
the independent project error pattern applied to the TASK BLUEPRINT. The sequence starts when
the user, located on the PMTaskGroup selects the visualize option and selects viewTaskBlueprint.
The PMTaskGroup object creates a view (of
the
viewTaskBlueprintOn method. This method uses the view previously created to generate the
blueprint and to highlight the problematic cases using a Mondrian script.

type MOViewRenderer) and performs

The partial class UML diagram in Figure 9 summarizes and localizes the behavior in the respective

classes according to the described scenarios. It also deﬁnes the main class relationships in AVISPA.

Gray classes in Figure 9 belong to the Moose platform. The class ProcessModelImporter is an
the class
extension of ProcessModelImporterCommand class and includes the import methods;
PMModel
is an extension of the ProcessModel class and it contains collections of PMTasks,
PMArtefacts, and PMRoles. The class PMObject and its derived PMTask, PMArtefact, and PMRole

bhttp://www.moosetechnology.org
chttp://www.moosetechnology.org/docs/famix
dhttp://www.moosetechnology.org/tools/mondrian
ehttp://www.pharo-project.org

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

440

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

Avispa

Avispa

UI

Avispa
Model

Avispa 
Importer

<<allowed to use>>

Moose

Mondrian

Glamour

Figure 5. AVISPA module view type.

Import 
Model

Navigate 

Model

Visualize 
blueprint

Visualize 

Error 
Pattern

Create 

new error 
pattern

Process 
Engineer

Create 

visualization

metrics

Update 
Importer

Figure 6. AVISPA use case diagram.

information and they are responsible for calculating the
classes include the respective element
respective metrics and for implementing the navigation features. These elements are grouped by the
respective MooseGroup. This grouping facilitates visualizing features.

3.3. Error pattern implementation in AVISPA

We illustrate the implementation of two error patterns: independent projects and multiple purpose
tasks. We provide the script for each of them, and the rationale in each implementation. The
implementation of the other error patterns is conceptually similar to these ones.
3.3.1. Independent subprojects. In this kind of error each independent subgraph is colored
differently in AVISPA, and having a TASK BLUEPRINT with more than one color means that there are
some missing dependencies. On the other hand, if the TASK BLUEPRINT is all the same color, this
means that there are no independent subprojects, and the process is ﬁne with respect to this error

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

441

:ProcessModel

Importer
Command

:ProcessModel

Importer

model:

PMModel

:Process Engineer

1:import()

2:execute()

4:pmModel:=importXMLDocument()

5:<<create>>

6:resolveReferences()

7:computeMetrics()

8:install()

9:addModel(model)

Figure 7. Importing an EPF process in AVISPA.

pattern. The following script builds a colored TASK BLUEPRINT where independent subprojects are
identiﬁed. Independent subprojects always denote errors in the process model speciﬁcation.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

442

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

taskGroup:

PMTaskGroup

each:PMTask
each:PMTask

view:

MOViewRenderer

:ProcessEngineer

1:viewTaskblueprint()

3: viewTaskBlueprintOn()

2:<<create>>

4:shape()

view shape rectangle
  border color: [ :v | cycleColor value: v ];
  borderwidth: 3;
  linearFillColor: #numberOfRoles within: self;
  width: [ :each | each numberOfArtifactOutputs * 10];
  height: [ :each | each numberOfArtifactMandatoryInputs * 10 ].

5:nodes(taskGroup)

6:shape()

view edges: self 
       from: #yourself 
       toAll: #followingTasks

7:edges(taskGroup)

view shape arrowedLine.

8:treeLayout()

Figure 8. Visualization of the independent error pattern in AVISPA.

First, a cycle is computed so that edges of connected subgraphs are painted with the same
color. Second, individual nodes are built assigning them a size and a color. Tasks are represented
as rectangular nodes whose color is that of the subgraph they belong to. Finally, the blueprint
is displayed.

3.3.2. Multiple purpose tasks. Nodes in the TASK BLUEPRINT that are wider than one standard
deviation from the average number of output work products are highlighted to indicate a potential
error. One standard deviation in a normal distribution function was the empirical value calibrated
from the F-measure (Section 4.3).

A series of metrics are precalculated so that the script can be executed. numberOutputsi is the
number of output work products of task i in the process. Then, considering that there are n tasks, we
can compute the mean number of output work products for the whole process,
the standard
deviation, and the distance to the mean as follows:

X

MeanOutW P ¼

Copyright © 2013 John Wiley & Sons, Ltd.

n
i¼1

numberOutputsi

n

(1)

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

443

MoosePanel

ImporterCommand

ProcessModel

ImporterCommand
+execute()
+addModel()

ProcessModelImpo

rterCommand

+execute()
+addModel()

MooseModel

MooseEntity

PMModel

+install()
+initializeMetrics()
+resolveReferences()

-myTasks

-myArtefacts

-myRoles

0..*

0..*
0..*

PMObject

PMTask

-followingTasks
-numberOfArtefacts
-numberOfArtefactsMandatory
-numberOfRoles
+followingTasks()
+numberOfArtefacts()
+numberOfArtefactsMandatory()
+numberOfRoles
+fromXML(...)

PMArtefact

PMRole

-artefacts

-roles

PMArtefactGroup

PMRoleGroup

PMTaskGroup
+viewTaskBlueprint()

MooseGroup

Figure 9. Partial class diagram of AVISPA.

s
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
X
Þ2
numberOutputsi   MeanOutW P

ð

n
i¼1

n

sigmaOut ¼

distToMeanOutW Pi ¼ numberOutputsi   MeanOutWP

j

j

(2)

(3)

These metrics are used as part of the script for identifying multiple purpose tasks to determine the

color of each node in the TASK BLUEPRINT.

The main part of the script is devoted to determining the color of each node. If the distance from the
number of output work products to the mean is larger than one standard deviation, then the node is
painted in red and otherwise white.

Obtaining a TASK BLUEPRINT with several red tasks clearly suggests a poor design.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

444

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

3.4. Extending AVISPA

AVISPA is extensible in various ways. The easiest way is to use the interactive views of Mondrian
Easel, where the group of elements is opened and a scripting window is displayed, new scripts are
written and a view is generated using only the script and the visualized group. The process engineer
can explore other polymetric views using new layouts, nodes, metric combinations, and edges.
More complex extensions can be introduced to AVISPA’s object-oriented code considering simple
hot spots provided by Moose. A new visualization previously tested using Mondrian Easel can
be implemented adding some methods in the respective MooseGroup; if the new visualization
requires a new metric, attributes, and methods must be added to the respective PMObject. The most
complicated scenario occurs when the visualization requires new process elements not currently
included in AVISPA. In this case, a new class derived from PMObject must be deﬁned including a
fromXML method, and the resolveReferences method of PMModel must be updated.

3.4.1. Deﬁning a new visualization. Deﬁning a new visualization is carried out in three steps: a
Mondrian Easel window is displayed, a view is programmed and generated using the Mondrian
script language, and the visualization is integrated into AVISPA’s code. The following scenario
the process engineer needs to deﬁne some technical requirements to support
illustrates it:
collaboration. Therefore, it is useful to know which tasks require more collaboration support. The
number of roles involved in each task is used to identify the tasks with more collaboration. If the
process engineer considers that a task with more than two roles involved should be identiﬁed, then
this reference point could be used to deﬁne a visualization script in Mondrian Easel. In the script
presented and visualized in Figure 10 collaborative tasks have been highlighted in yellow, and the
subview shows the roles involved.

Once the new pattern script has been tested using the generate view button, its code has to be added to
the AVISPA tool code as a new pattern. In this case the pattern does not refer to an error; instead the
pattern refers to useful information to introduce collaboration practices. To include this functionality
in the AVISPA code two new methods must be added: viewCollaborativeTaskPatternOn and
viewCollaborativeTaskPattern. The former is the same Mondrian Easel script, but replacing the
reference to the PMTaskGroup object by self reference because the message is received by the
PMTaskGroup in the navigator.

Figure 10. Extending AVISPA interactively with Mondrian Easel.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

445

3.4.2. Importing a new process element. AVISPA uses a small subset of SPEM 2.0. If the process
engineer wants to add another concept in AVISPA, a class of this new concept must be created
inheriting the class PMObject implementing the fromXMLDescription class method. Additionally a
group must be created inheriting the class MooseGroup. For instance, to add the SPEM Activity to
AVISPA, a PMActivity class must be added as follows:

The fromXMLDescription method can be programmed reusing the general importing functionality

and adding new attributes, in this case the performer primary id:

If the new element includes references, then the method that resolves references of the process
model must be modiﬁed adding these references. Additionally, navigation methods are created in the
method navigation category as follows:

3.4.3. Deﬁning new metrics. New metrics are obtained from numerical attributes deﬁned in different
process elements, for example, the number of predecessor elements of an activity is available to the
different blueprints. This metric is added to the class PMActivity in the metric method category as follows:

4. APPLYING AVISPA IN A REAL WORLD SOFTWARE PROCESS MODEL

AVISPA was applied on Amisoft, a Chilean software company.f First, we brieﬂy present the context of
the company and then we describe the results of applying AVISPA to analyze its process model. We
illustrate the application of AVISPA with two error patterns:
independent projects in the TASK
BLUEPRINT and tasks with too many output work products. Independent projects is also analyzed in

fhttp://www.amisoft.cl.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

446

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

the WORK PRODUCT BLUEPRINT. The process model used in this research was developed in the last two
years and was obtained from the company’s library using the exporter feature of EPF. The process
model was analyzed and then the results were discussed with the process engineers.

4.1. Application scenario

Amisoft is around 10 years old and it employs 30 qualiﬁed employees. Its main goal is to deliver
specialized and quality services. Its development areas are: client/server architecture solutions,
enterprise applications based on J2EE and Systems integration using TCP/IP and MQ Series.
Amisoft started its software process improvement project in 2009, and it is currently implementing
the ISO9001:2008 standard and the CMMI approach. Its software process has been inspired by the
Open Uniﬁed Process (OpenUP)g.

4.2. Process model analysis

AVISPA helped to identify ﬁve instances of the pattern independent subprojects (in this case
disconnected tasks) corresponding to the nodes with a color different from blue in Figure 11. These
nodes represent the tasks: Conﬁguration Items Update, Non-Compliant Communications, Delivery
Document Generation and Sending, Getting Conﬁguration Items and Execute Unitary Test to Interfaces
and Communications. These disconnected subgraphs represent a high risk because the conﬁguration
management process could be chaotic and the testing of interfaces and communications could be
forgotten just when it is required the most.

The multiple purpose task pattern was also applied (red nodes in Figure 12). In this case the result
was nine potential errors of multiple purpose tasks out of 93 tasks in total (9.7%). However, reviewing
these tasks, many of them refer to management tasks where different inputs are actually required to
evaluate the project advance or to make some decisions, and as a result these tasks modify many
the granularity cannot be ﬁner, but more guidance could be added.
work products. Therefore,
However, the task Document Requirements could have been better decomposed into two different
tasks separating abstraction levels (concerns covered or users of the requirements). On the other
hand the task Measure Data Collection is shown as a multipurpose task and it really is, because the
measurement results are not available directly in a unique work product but in many work products.

4.3. Pattern tuning

The F-Measure [24] has been used to evaluate the effectiveness of the patterns because AVISPA
recovers problematic elements in software process models but not all are actual errors. The F-Measure

Figure 11. TASK BLUEPRINT for localizing disconnected subgraphs in Amisoft.

Figure 12. TASK BLUEPRINT for localizing multiple purpose tasks in Amisoft.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

447

is obtained identifying two types of sets: recovered potential problems (retrievedElements) and the actual
relevant problems (relevantElements). The recall (R — fraction of the process elements that are relevant
to the query that are successfully retrieved) and precision (P — the fraction of retrieved process elements
that are relevant to the search) metrics are calculated according to the formulas

R ¼ jj relevantElements

f

g∩ retrievedElements

f

gjj

jj relevantElements
f

gjj

P ¼ jj relevantElements

f

g∩ retrievedElements

f

gjj

jj retrievedElements
f

gjj

FMeasure ¼ 2  P  R
P þ R

(4)

(5)

(6)

The analysis is focused on the applied patterns: independent projects and multipurpose tasks.
The ﬁrst pattern is very effective because most of the identiﬁed problems were actual problems, so its
F-Measure is 0.9. The second pattern is not as effective as the ﬁrst one. Therefore, it was tuned to
achieve the largest beneﬁt using as reference unit a standard deviation (sigma) and three cases were
analyzed: using 1-sigma, 2-sigma, and 3-sigma as problem identiﬁcation ﬁlters. The values obtained
were: 0.50 for 1-sigma, 0.17 for 2-sigma, and 0.33 for 3-sigma.

Therefore, the multipurpose task pattern was tuned to 1-sigma: each task positively deviated 1-sigma

from the average number of outputs will be identiﬁed as a potential error of multipurpose task.

5. RELATED WORK

Software process model quality can be addressed from different approaches: metrics [3], testing,
simulation [9], or formal veriﬁcation [8]. Metrics work ﬁne for data of the overall software process
model, but metrics for partial portions of the process or individual process elements are usually not a
suitable presentation for a reviewer. Process testing is an effective way to evaluate a process model;
assessments and audits are based on data of executed projects, but executing the process is expensive.
Our approach provides a means for a priori evaluation of the software process quality. Cook and Wolf
[4] presented a formal veriﬁcation and validation technique for testing and measuring the discrepancies
between process models and actual executions. The main limitation of testing is that it can only be
carried out once the process model has already been implemented, tailored, and enacted. Simulation has
a shorter cycle, but it still requires enactment data to be reliable. Formal checking is effective too but it
presents semantic limitations [28]. In AVISPA we use metrics as a basis for building two visualization
layers that help process engineers to localize problems in the models. We propose a complementary
approach to analyze software process models in an early stage, based on reviewing the architectural
views of a software process model deﬁned as Software Process Blueprints [12]. There, each blueprint is
built following a model-driven strategy where the process model is separated in a set of partial views
that may be more illustrative for ﬁnding errors. However, the usability and complexity of process
model blueprints was threatened when dealing with large and complex process models. According to
our practical experience with AVISPA, it has improved usability by identifying a set of common error
patterns, and highlighting them, but more importantly it encapsulates specialized knowledge of an
expert software process engineer for identifying improvement opportunities and thus requiring less
experienced process engineers.

As stated by Osterweil [20], software processes are software too, therefore techniques that apply to
software programs can be also applied in process models. Finding error patterns in source code has
been fairly successful [7, 16], therefore following a similar approach we have been able, based on a
vast empirical experience, to automatically identify and localize a series of error patterns in software

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

448

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

process models. The classical domain for software visualization is software source code. There has
been a great deal of work on visualizing classes and methods [14], software architecture [18], and
even source code annotations [2]. The work presented in this paper has the same rationale:
providing concise information about an engineering artifact to maintain and improve it. By taking
some of these ideas and applying them to analyze software process models, the analysis obtained
similar beneﬁts to those achieved with other software artifacts.

Osterweil and Wise [21] demonstrated how a precise deﬁnition of a software development process can
be used to determine whether the process deﬁnition satisﬁes some of its requirements. A deﬁnition of
a Scrum process written in the Little-JIL process deﬁnition language is presented to motivate their
contributions. We developed a similar analysis [11] to the Scrum process model using AVISPA where
we found a number of speciﬁcation problems. In general both approaches show the advantages of a
precise speciﬁcation of the process. Soto et al. [25] presented a case study that analyzes a process
model evolution using the history of a large process model under conﬁguration management with the
purpose of understanding model changes and their consequences. The goal of Soto et al. is oriented
toward the impact of the changes in the software process models whereas our approach is oriented to
early analyzing a new or changed process model just before the model is used in a speciﬁc project.

6. CONCLUSIONS

In this paper we have presented AVISPA, a tool for process model analysis that localizes a set of
identiﬁed error patterns within a process model speciﬁed in SPEM 2.0. These errors may come
either from process conceptualization or from misspeciﬁcation. We described how each of the error
patterns identiﬁed are found in the appropriate blueprint, and we made AVISPA highlight them. Also,
some extension scenarios have been described showing the extension capability of AVISPA.

The process model of a Chilean company we have been working with for 2 years has been analyzed
using AVISPA. Some errors were found, and some improvement opportunities, showing the
effectiveness of the patterns and the tool. These errors were not foreseen by process engineers, but
they agreed they were real improvement opportunities.

As part of the application experience we have realized that the quality of the analysis highly depends on
the quality of the deﬁnition of the error patterns. Even though the error patterns presented in this paper are
effective in ﬁnding improvement opportunities, there is some room for ﬁne tuning them. The F-Measure
was applied to show that one standard deviation was effectively the best option for the multipurpose task
error pattern.

The tool is targeted to those software process models formally speciﬁed in SPEM 2.0. This may be one
of its main limitations because it is hard and expensive to formally deﬁne a complete process mainly for
small software organizations. However, if a company decides it is worth the effort, then AVISPA provides
an added value to this investment assuring, at least partially, the quality of the speciﬁed process.

As part of our ongoing work, we are deﬁning a set of solution patterns that the tool will suggest, so
that each error pattern found could be solved in an assisted manner. In this way, the round trip for
software process improvement will be complete.

This work was partly funded by project Fondef D09I1171 of Conicyt, Chile. The work of Julio A. Hurtado
was also partially funded by NIC Chile. This work was partly funded by Program U-INICIA 11/06 VID
2011, grant U-INICIA 11/06, University of Chile, and FONDECYT 1120094.

ACKNOWLEDGEMENTS

REFERENCES

1. Acuña ST, Ferré X. Software process modelling. In World Multiconference on Systemics, Cybernetics and Informatics,
ISAS-SCIs 2001, July 22–25, 2001, Orlando, Florida, USA, Proceedings, Volume I: Information Systems Development,
2001; 237–242.

2. Brühlmann A, Gîrba T, Greevy O, Nierstrasz O. Enriching reverse engineering with annotations. In International
Conference on Model Driven Engineering Languages and Systems, volume 5301 of LNCS, Springer-Verlag,
2008; 660–674.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

15. Lieberman H, Fry C. ZStep 95: A reversible, animated source code stepper. In Software Visualization — Programming
as a Multimedia Experience, Stasko J, Domingue J, Brown MH, Price BA (eds.). The MIT Press: Cambridge, MALondon,
 1998; 277–292.

16. Livshits B, Zimmermann T. Dynamine: ﬁnding common error patterns by mining software revision histories.

SIGSOFT Software Engineering Notes 2005; 30(5):296–305.

17. Lonchamp J. A Structured Conceptual and Terminological Framework for Software Process Engineering. Second

International Conference on the Continuous Software Process Improvement, 1993; 41–53.

18. Lungu M, Lanza M. Softwarenaut: Exploring Hierarchical System Decompositions. In Proceedings of the 10th
European Conference on Software Maintenance and Reengineering), IEE Computer Society Press: Los Alamitos,
CA, 2006; 351–354.

19. OMG. Software Process Engineering Metamodel SPEM 2.0 OMG Speciﬁcation. Technical Report ptc/07-11-01, OMG, 2008.
20. Osterweil LJ. Software Processes Are Software Too. In International Conference on Software Engineering, IEE Computer 
Society Press: Los Alamitos, CA, 1987; 2–13.

AVISPA: A TOOL FOR ANALYZING SOFTWARE PROCESS MODELS

449

3. Cánfora G, García F, Piattini M, Ruiz F, Visaggio CA. A family of experiments to validate metrics for software

process models. Journal of Systems and Software 2005; 77(2):113–129.

4. Cook JE, Wolf AL. Software process validation: quantitatively measuring the correspondence of a process to a

model. ACM Transactions On Software Engineering Methodology 1999; 8(2):147–176.

5. Curtis B, Kellner MI, Over J. Process modeling. Communications of the ACM 1992; 35(9):75–90.
6. Demeyer S, Ducasse S, Nierstrasz O. Object-Oriented Reengineering Patterns. Square Bracket Associates, 2008.
7. Durães J, Madeira H. Emulation of Software Faults: A Field Data Study and a Practical Approach. IEEE Transactions

on Software Engineering 2006; 32(11):849–867.

8. Ge J, Hu H, Gu Q, Lu J. Modeling Multi-View Software Process with Object Petri Nets. ICSEA 2006 2006; 0:41.
9. Gruhn V. Validation and veriﬁcation of software process models. In Proc. of the Software development environments

and CASE technology, 1991; 271–286.

10. Humphrey WS. Managing the software process. Addison-Wesley Longman Publishing Co., Inc.: Boston, MA, USA, 1989.
11. Hurtado JA, Bergel A, Bastarrica MC. Analyzing the Scrum Process Model with AVISPA. In Proceedings of the

SCCC’2010, Antofagasta, Chile, November 2010.

12. Hurtado JA, Lagos A, Bergel A, Bastarrica MC. Software Process Model Blueprints. In Proceedings of the International

Conference on Software Process, ICSP’2010, volume 6195 of LNCS, Springer-Verlag, 2010; 273–284.

13. Hurtado Alegría JA, Bastarrica MC, Bergel A. Analyzing software process models with avispa. In Proceedings of the 2011

International Conference on Software and Systems Process, ICSSP ’11, ACM: New York, NY, USA, 2011; 23–32.

14. Lanza M, Ducasse S. Polymetric Views-A Lightweight Visual Approach to Reverse Engineering. Transactions on

Software Engineering 2003; 29(9):782–795.

21. Osterweil LJ, Wise AE. Using Process Deﬁnitions to Support Reasoning about Satisfaction of Process Requirements. In
ICSP, volume 6195 of LNCS, Münch J, Yang Y, Schäfer W (eds.). Springer-Verlag: Berlin, Heidelberg, 2010; 2–13.
22. Perin F, Gîrba T, Nierstrasz O. Recovery and analysis of transaction scope from scattered information in Java enterprise

applications. In Proceedings of International Conference on Software Maintenance 2010, Sept. 2010.

23. Pino FJ, Alegria JAH, Vidal JC, García F, Piattini M. A process for driving process improvement in VSEs, international
conference on software process, icsp 2009 vancouver, canada, may 16–17, 2009 proceedings. In ICSP, volume 5543 of
Lecture Notes in Computer Science, Springer, 2009; 342–353.

24. Rijsbergen CJV. Information Retrieval, 2nd edn. Butterworth-Heinemann: Newton, MA, USA, 1979.
25. Soto M, Ocampo A, Münch J. Analyzing a software process model repository for understanding model evolution. In
Proceedings of the International Conference on Software Process: Trustworthy Software Development Processes,
ICSP ’09, Springer-Verlag: Berlin, Heidelberg, 2009; 377–388.

26. Valdés G, Astudillo H, Visconti M, López C. The Tutelkán SPI Framework for Small Settings: A Methodology
Transfer Vehicle. In Proceedings of the 17th European System & Software Process Improvement and Innovation,
Grenoble, France, September 2010.

27. Wettel R, Lanza M, Robbes R. Software systems as cities: a controlled experiment. In Proceedings of the 33rd

International Conference on Software Engineering, ICSE ’11, ACM: New York, NY, USA, 2011; 551–560.

28. Yoon I-C, Min S-Y, Bae D-H. Tailoring and Verifying Software Process. In th Asia-Paciﬁc Software Engineering

Conference (APSEC 2001), Macau, China, 2001; 202–209.

AUTHORS’ BIOGRAPHIES:

Julio Ariel Hurtado is a Titular Professor at the Systems Department at the
University of Cauca. He received his Ph.D. in Computer Science from the University 
of Chile in 2012 and a Bachelor in Engineering from the University of
Cauca in 1998. Julio’s research interests include software processes, modeldriven 
engineering, software process lines, process visualization, agile methods
and collaboration engineering. Julio’s webpage is http://dcc.uchile.cl/~jhurtado.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

450

JULIO A. HURTADO ALEGRÍA, MARIA CECILIA BASTARRICA AND ALEXANDRE BERGEL

María Cecilia Bastarrica Universidad de Chile. She coordinates the MaTE group
(Model and Transformation Engineering) since 2007. She received her Ph.D. in Computer 
Science and Engineering from the University of Connecticut in 2000, a Master of
Science from the Pontiﬁcia Universidad Catlica de Chile in 1994, and a Bachelor in
Engineering from the Catholic University of Uruguay in 1991. Her main research
topics are software engineering, software architecture, model-driven engineering, and
software product lines. Lately, her work has focused on applying using MDE techniques 
for modeling software processes. Cecilia’s web page is http://dcc.uchile.cl/~cecilia.

Alexandre Bergel obtained his PhD in 2005 from the University of Berne. His PhD
has been awarded by the prestigious Ernst-Denert award in 2006. After his PhD, he
completed a ﬁrst postdoc at Lero & Trinity College Dublin, Ireland, and a second
one at the Hasso-Plattner Institute, Germany. Alexandre Bergel and his collaborators
carry out research in software engineering and software quality, more speciﬁcally on
code proﬁling, testing and software visualization. Alexandre has also a strong interest
in applying his research results to industry. Several of his research prototypes have
been turned into products. Alexandre’s web page is. http://bergel.eu.

Copyright © 2013 John Wiley & Sons, Ltd.

J. Softw. Evol. and Proc. 2014; 26:434–450
DOI: 10.1002/smr

