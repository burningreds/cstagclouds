Extracting Object Interactions Out of Software

Contracts Using Model Transformations(cid:2)

Andr´es Vignaga, Daniel Perovich, and Mar´ıa Cecilia Bastarrica

Department of Computer Science, Universidad de Chile

{avignaga,dperovic,cecilia}@dcc.uchile.cl

Abstract. One popular approach to object design proposes to identify
responsibilities from software contracts, apply a number of principles
to assign them to objects, and ﬁnally construct an object interaction
that realizes the contract. This three-step activity is currently a manual
process that is time-consuming and error-prone, and is among the most
challenging activities in object-oriented development. In this paper, we
present a model transformation that partially automates this activity.
Such a transformation is modularized in three stages. The ﬁrst stage
automatically transforms a software contract to a trace of state modiﬁcation 
actions. In the second stage the designer manually extends the
trace with design decisions. Finally, the extended trace is automatically
transformed to an object interaction in the third stage. A prototype of
the whole transformation was developed and successfully applied to a
case study from the literature. Our technique allows the extraction of
valuable information from software contracts, provides a bridge between
analysis and design artifacts, and signiﬁcantly reduces the eﬀort of interaction 
design.

1 Introduction

Responsibility-Driven Design (RDD) [26] is a popular approach to object design.
Its core activity is the deﬁnition of object interactions from a system behavioral
speciﬁcation, by identifying and assigning responsibilities to objects. A responsibility 
is a ‘knowing’ or ‘doing’ obligation of an element. Diﬀerent methods base
their design stage on such an approach. One of those methods is [11], which is
oriented to information-intensive software systems.

An object interaction speciﬁes how messages are exchanged over time between
object roles within a collaboration [16]. In turn, a possible approach to a system
behavioral speciﬁcation involves treating the system as a black box and identifying 
its public operations [5], usually called system operations. Conceptually, the
state of a system is speciﬁed by a Domain Model, and a system operation can
be understood as a command or partial function that operates on that state.
Larman in [11] further proposes to identify system operations from use case
scenarios, and to specify their semantics using software contracts [14]. In that

(cid:2) The work of A. Vignaga and D. Perovich was partially funded by CONICYT Chile.

A. Vallecillo, J. Gray, A. Pierantonio (Eds.): ICMT 2008, LNCS 5063, pp. 245–259, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008

246

A. Vignaga, D. Perovich, and M.C. Bastarrica

context, a software contract for a system operation expresses a binary relation
between its input and output state.

In [11], the purpose of object design is the realization of every use case. A
use case realization embodies an object interaction for each system operation
identiﬁed for the use case, and a proper class model enabling these interactions.
 Building an object interaction essentially involves three steps: (i) identify
responsibilities, (ii) assign them to objects, and (iii) express them as message
ﬂows. In step (i) responsibilities are identiﬁed by inspecting preand 
postconditions 
of the software contract associated to the system operation. In step (ii)
participating objects are determined, as responsibilities are distributed among
them. General Responsibility Software Assignment Patterns (GRASP) reduce
the search space, and allow to avoid common pitfalls. In (iii) responsibilities are
expressed as message ﬂows among the participating objects and the interaction
is eﬀectively deﬁned. This involves the creation of a UML interaction diagram
expressing the result. During such a process, a designer can probe the decisions
made during the previous step and apply corrective actions if required. As a
consequence, steps (ii) and (iii) are usually carried out concurrently.

This approach exhibits a number of shortcomings. In step (i), no systematic
technique is provided for responsibility identiﬁcation, and thus it heavily relies on
the designer’s intuition about the problem. For step (ii) GRASP provides diﬀerent 
design alternatives. In some cases GRASP can be applied straightforwardly,
but in others, the designer needs to make trade-oﬀ decisions. In step (iii), no
systematic technique is proposed for expressing responsibilities as ﬂows of messages.
 A designer must repeatedly ﬁgure out the set of messages that are required
for fulﬁlling each responsibility. Additionally, the representational gap between
software contracts and object interactions is signiﬁcative: software contracts are
declarative analysis artifacts expressed as text, while object interactions are imperative 
design models expressed as diagrams. In most practical cases such a
gap is even more signiﬁcant since contracts are seldom speciﬁed due to a poor
cost/beneﬁt ratio; building a precise and useful contract is usually costly, and extracting 
information from it is performed ad hoc. Therefore, designing an object
interaction is one of the most challenging activities in object-oriented development.
 Currently, this activity is a manual process that is time-consuming and
error-prone, and whose success highly depends on the designer’s skills.

In this paper, we present a technique which partially automates the generation 
of an object interaction from a software contract. We understand the steps
already discussed as concerns that do not need to be sequentially addressed. Our
technique interleaves these concerns and is organized in three stages, as shown
in Fig. 1. In the ﬁrst stage, we express contracts for system operations using a
relational model transformation language. An engine capable of executing such
speciﬁcations on a model of a source state will then be able to produce a model
of the target state. Particularly, the engine modiﬁes, or more concretely, performs 
a set of actions on the source state in order to produce the proper target
state. Such a set of actions can be regarded as a trace of the execution leading
from the source to the target state, and hence as a set of ‘doing’ responsibilities.

Extracting Object Interactions Out of Software Contracts

247

Auto

Engine

Target State

Source 
State

Auto

MT
Environment

XTrace2CD

Object

Interaction

Software
Contract

Trace

Manual

Designer

Extended

Trace

Fig. 1. The three stages of the technique. Black boxes are inputs, dark greyed boxes
are outputs, and light grayed boxes are speciﬁc tools.

In the second stage the designer applies GRASP and augments the trace with
responsibility assignments. Although a default assignment might be automatically 
chosen, manual intervention provides ﬂexibility. In the third stage we apply
another model transformation to the extended trace for producing the object interaction,
 in the form of a UML communication diagram. Such a transformation
encodes the knowledge about generating message ﬂows, but also identiﬁes and
assigns other responsibilities from the Domain Model if required.

Current work on MDE technologies tends to focus on producing implementation 
and deployment artifacts from detailed design models [7]. Our technique
provides a bridge between analysis and design artifacts, allowing a signiﬁcant reduction 
in the eﬀort for interaction design. It also increases the value of contracts
as it presents a systematic technique for extracting information from them. A
prototype of the whole transformation which is detailed in [24] was successfully
applied to the complete case study introduced in [11].

The rest of the paper is organized as follows. In Sect. 2 we motivate our technique 
by discussing manual interaction design on a concrete example. Section 3
describes our technique and noteworthy details are presented in Sect. 4. Related
work is presented in Sect. 5, and Sect. 6 concludes and suggests further work.

2 Motivating Example

In this section we use an example for motivating the addressed problem and informally 
explaining the manual generation of object interactions. The example
is based on the NextGen Point-of-Sale (POS) system introduced in [11]. A POS
system is a computerized application used to record sales and handle payments
in a retail store, which is deployed on each register. A Domain Model for a POS
is illustrated in Fig. 2. The main use case in such a system is Process Sale, which
deals with customers buying products at the store. Its main success scenario
involves creating a new sale using system operation makeNewSale(), adding
products to that sale using enterItem(), ending the sale using endSale(), and
recording the payment using makeCashPayment(). Handling check payments belongs 
to an alternative scenario. In what follows we only focus on enterItem().

248

A. Vignaga, D. Perovich, and M.C. Bastarrica

class 

«datatype»

«datatype»

year : Integer
month : Integer
day : Integer

hour : Integer
minute : Integer

description : String
price : Float
itemID : Integer

1..*
specs

contains

1

prodCat

1

used-by

described-by

prodSpec

1

*

quantity : Integer

1..*

contained-in

lineItems

1

1

paid-by

1

amount : Float

date : Date
time : Time
isCompleted : Boolean

initiated-by

*

1

cashTendered : Float

idNumber : String

logs-completed

captured-on 

*
compSales
0..1
curSale

1..*

1

1

name : String
y
z

records-sales-on

*

*

Fig. 2. Domain Model for the POS system

object

object

r : Register

curSale

s : Sale

r : Register

curSale

s : Sale

enterItem(id,qty)

pc : Product

Catalog

ps : Product
Specification
itemID = id

sli : Sales
LineItem

quantity = qty

pc : Product

Catalog

ps : Product
Specification
itemID = id

Fig. 3. Snapshots exemplifying the eﬀect of enterItem() on the system state

The semantics of enterItem(id,qty) system operation can be speciﬁed using
a software contract. Diﬀerent versions of such a contract with varying degrees
of formality are shown in [24]. Textually, its precondition requires a sale s to be
underway, a product speciﬁcation ps with itemID equal to parameter id in the
product catalog, and a positive value for qty. In turn, the postcondition ensures
that s has a new line item and its quantity attribute equals qty, and there is a
link relating such line item and the product speciﬁcation identiﬁed by id. By
inspecting this contract, it can be deduced that such speciﬁcation can be realized
by the following sequence of actions on a system state, also called a trace: (i)
create an instance sli of class SalesLineItem, (ii) set sli.quantity to qty, (iii) link
sli to s, and (iv) link sli to ps. The eﬀect on a sample state of such realization
scheme is shown using a visual contract [13] in Fig. 3; sourceState represents a
canonical state satisfying the preconditions discussed above, and the result of
executing enterItem() on that particular state is represented by targetState.

The design of a system operation raises a number of design problems. Some
of them are independent of the particular system operation, for example, which

Extracting Object Interactions Out of Software Contracts

249

comm

enterItem(id,qty)

2: makeLineItem(spec,qty)

 : Register

 : Sale

1: spec := findSpecification(id)

2.2: add(sl)

2.1: sl := create(spec,qty)

 : Product
Catalog

1.1: spec := find(id)

lineItems

: Collection

 : Sales

LineItem [*]

 : Sales
LineItem

specs
: Collection

 : Product

Specification [*]

Fig. 4. Object interaction for enterItem()

class should handle the system operation call. Other problems are speciﬁc to the
operation and are introduced by the trace, for example, which class should create
instances of class SalesLineItems. GRASP address these problems by suggesting
a reduced set of diﬀerent solutions to each of them. Applying GRASP means
choosing one of the solutions. The alternatives are discussed in a later section.
The application of GRASP for enterItem() is as follows. Applying GRASP
Controller class Register is chosen for handling the system operation. Action (i)
in the trace introduces the problem of deﬁning the responsible for creating line
items. By GRASP Creator class Sale is chosen. Action (ii) introduces the problem 
of setting an attribute of a line item. By GRASP Expert class Sale is the
responsible. In turn, the problem of linking sales to line items is introduced by
action (iii). Again by Expert, class Sale is chosen. Finally, action (iv) introduces
the problem of linking line items to product speciﬁcations, which in turn introduces 
a number of subproblems. By Expert, a sale is chosen as the responsible
for handing the product speciﬁcation to a line item. The product speciﬁcation
must be found and by Expert the catalog is chosen as the responsible for doing
that. Similarly, by Expert again, the register is chosen as the responsible for
retrieving a speciﬁcation from the catalog and also passing it to the sale. Figure 
4 illustrates an object interaction which fulﬁlls the contract and reﬂects the
responsibility assignment just discussed.

3 From Software Contracts to Object Interactions

In this section we present an overview of the technique while the next section
discusses some noteworthy details. An operational description of the automated
stages is presented in [24].

The purpose of the ﬁrst stage is to ﬁnd a sequence of atomic state changes
needed to achieve the same eﬀect as the system operation would have. A system
operation is a partial function O : State (cid:2)→ State. A software contract deﬁnes a
relation R ⊆ State × State such that O(σ1) = σ2 iﬀ (σ1, σ2) ∈ R, provided that
the contract is not underspeciﬁed. A contract may be expressed in a relational

250

A. Vignaga, D. Perovich, and M.C. Bastarrica

1

System
Operation

produces

models

behaves as

Source Model

Engine

+

Contract

2

models
(after MT
execution)

manipulates

Target Model

Fig. 5. A system operation transforms system state σ1 to σ2. A relational engine transforms 
models that model such states. Target Model is a copy of Source Model and thus
models σ1 before the engine executes; Target Model models σ2 only after the execution.

−→
R : State × State (cid:2)→ State where

model transformation language [4]. Speciﬁcations expressed in relational languages 
are in its pure form non-executable, however they can be given executable 
semantics [6]. Diﬀerent languages [1,8,12] propose their own execution
−→
semantics, however they share the same underlying principle. Relation R has an
associated transformation
R looks at a pair
of models (φ1, φ2) and ﬁgures out how to modify φ2 so as to enforce the relation
−→
R(φ1, φ2)) ∈ R [19]. If a system
R, returning the modiﬁed version, so that (φ1,
operation contract is executed by an engine, with both source and target models
modeling the same state, then the target model will be modiﬁed so as to make
both of them satisfy every relation in the contract. This means that the engine
−→
exhibits the same behavior as the system operation speciﬁed by the contract,
R(σ1, σ1) = O(σ1); see Fig. 5. Even more important is that the engine
that is
knows how to manipulate the (copy of the) source state for transforming it into
the target state. Such a manipulation can be expressed in terms of actions on
the system state and is the main result of the ﬁrst stage. Such actions represent 
‘doing’ responsibilities and we call them the trace of the transformation, as
discussed in Sect. 2. For expressing such actions we deﬁned a Domain Speciﬁc
Language (DSL) which is presented in the next section. The present stage is
aligned with the notion of diagram reconciliation, where it is assumed as possible 
to discover what changed in a model during a transformation [2]. These
actions can also be regarded as the diﬀerence between the two models of states.
The purpose of the second stage is to generate an extended trace consisting
of a trace and design decisions; the trace from the ﬁrst stage is augmented with
responsibility assignments resulting from the application of GRASP. The responsibilities 
we address are: (a) to receive and coordinate the system operation, (b)
to create a new instance of a class, and (c) to know a value which is calculated
using attributes of diﬀerent objects. For (a), GRASP Controller needs to be
applied. Alternatives are an object representing the overall system, or an object 
representing the use case within which the system operation is called. In
the POS example of Sect. 2 the former alternative was chosen. For (b), GRASP
Creator proposes to assign such a responsibility to a particular class. It needs
to be applied to every class involved in a CreateAction within the trace. In the
POS example, a new SalesLineItem needs to be created and class Sale is its creator.
 For (c), GRASP Expert proposes to assign such a responsibility to the class
that has the information necessary to fulﬁl it. In many cases, a class has all the

Extracting Object Interactions Out of Software Contracts

251

information required and the assignment can be done straightforwardly, but in
other cases the information is distributed among several objects. In the POS
example, the responsibility of obtaining the product speciﬁcation corresponding
to the new line item is distributed among the register, the product catalog and
the current sale. The process of augmenting the trace can be regarded as a model
transformation which is currently performed manually but which is intended to
be fully interactive. Such interactivity provides high ﬂexibility to the designer.
However, the structure of the Domain Model provides valuable information that
helps in choosing among alternatives. For example, it tells who is the owner of
certain attributes (for applying Expert), and who and how is associated to a class
that needs to be instantiated (for applying Creator). Therefore, this transformation 
could be partially automated by deﬁning default choices (not necessarily
optimal, though) for each case.

The purpose of the third stage is to produce an object interaction that fulﬁlls
the software contract and thus realizes the behavior of the associated system
operation. This is achieved by applying a model transformation that processes
the extended trace. Based on the models of system states (i.e. snapshots) involved 
in the ﬁrst stage, the transformation generates a graph as the basis of the
expected communication diagram, and transforms actions to ﬂows of messages
among participating objects (i.e. nodes in the generated graph) using responsibility 
assignments explicitly found in the extended trace and implicitly found in
the Domain Model.

4 Technical Details

4.1 Deriving the Trace

We assume a loose semantic interpretation for the contracts of the system operations,
 and express them using a relational model transformation language; for
example, Fig. 6 shows the contract for enterItem() using QVT-like syntax. A
software contract is deﬁned as one or more binary relations between the source
state and the target state. Each relation is a pair of predicates, one over the
source state (i.e. precondition) and the other over both states (i.e. postcondi-
tion). Contracts built on multiple relations tend to be simpler, as disjunctions
occurring in the precondition can be split across several relations, and their associated 
implication connectives for case analysis are no longer needed in the
postcondition. For example, the single-relation contract on the left can be expressed 
as the two relations on the right:

pre: P1 ∨ P2
post: P1 → Q1 ∧ P2 → Q2

pre: P1
post: Q1

pre: P2
post: Q2

These predicates use speciﬁcation variables [10] for relating both states. Such
variables are initialized when checking the precondition on the source state and
their values are used when enforcing the postcondition. By this means, a postcondition 
can also express properties about the source state. This leads to more
compact expressions, and avoids the use of constructs for accessing the source

252

A. Vignaga, D. Perovich, and M.C. Bastarrica

1 transformation enterItem(sourceState:POSDomainModel, targetState : POSDomainModel) {

key Register(name);
key ProductSpeciﬁcation(itemID);
key Sale(date, time);
input parameter id : Integer;
input parameter qty : Integer;
top relation SystemOperation {

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33 }

vname : String;
vdate : Date;
vtime : Time;
checkonly domain sourceState r : Register {

name = vname;
curSale = s : Sale {date = vdate, time = vtime},
prodCat = pc : ProductCatalog {
}

prodSpec = ps : ProductSpeciﬁcation {itemID = id}

};
enforce domain targetState r’ : Register {

name = vname,
curSale = s’ : Sale {
date = vdate,
time = vtime,
lineItem = sli’ : SalesLineItem {

quantity = qty,
prodSpec = ps’ : ProductSpeciﬁcation {itemID = id}

}

}

};
when { qty > 0 }

}

Fig. 6. Transformation for enterItem() in QVT Relations

state such as OCL’s @pre or JML’s \old. For example, assuming sli as a known
instance of SalesLineItem, the contract on the left can be expressed with speciﬁcation 
variables as the contract on the right:

pre: qty > 0
post: sli.quantity = sli.quantity@pre + qty

var: q:Integer
pre: qty > 0 ∧ sli.quantity = q
post: sli.quantity = q + qty

Also, as a system operation may have arguments and a result, predicates can
refer to input parameters and the postcondition must specify the returned values
whenever required.

For processing a contract, a canonical state is chosen to feed the relational
transformation engine. Such a state must satisfy the preconditions and conform
to the Domain Model, and can be regarded as the left part of a visual contract 
[13]. Provided that both source and target models model the canonical
state, while processing the contract, the engine enforces every relation in it in
sequence by manipulating the target model, according to the structure speciﬁed
by the Domain Model. Such a manipulation takes the form of a sequence of
actions on the model of the system state. They correspond to a subset of UML
actions [9] formalized in [22], and allow creating objects, linking and unlinking

Extracting Object Interactions Out of Software Contracts

253

pairs of objects, and setting values of attributes. Explicit object deletion is not
supported; an object is implicitly deleted when unreachable.

An engine must decide which actions are required and this cannot be achieved
for arbitrary boolean expressions within postconditions. Their form is restricted
to expressions that reduce to a conjunction of terms of the form: (i) result =
(cid:5)exp(cid:6), (ii) (cid:5)obj(cid:6).(cid:5)prop(cid:6) = (cid:5)exp(cid:6), or (iii) (cid:5)obj(cid:6).(cid:5)prop(cid:6) (cid:7)= (cid:5)exp(cid:6). Terms as (i) are used
for specifying the returned value, and terms of the form (ii) and (iii) suﬃce for
deriving any of the state manipulation actions. In (ii), when prop is an attribute,
and hence exp reduces to a data value, a setAction is induced. In the example
of Fig. 6, this is the case for lines 23, 24 and 26. Otherwise prop must be a role
of an association end opposite to obj, and exp reduces to an object, namely obj’.
A linkAction involving obj and obj’ is induced (lines 25 and 27 in the example).
When at most one object can be linked to either obj or obj’, unlinkActions are
also required for disconnecting them from the already connected object. Additionally,
 when obj’ does not exist in the target state, a createAction is induced
(line 25 in the example). In (iii), exp must reduce to an object and prop can only
be an opposite role, and hence an unlinkAction is induced. Clearly, incomplete
traces are obtained from underspeciﬁed contracts. Finally, the sequential order
of actions within the trace takes their precedence into account, e.g. an object
must be created before being linked to another object.

4.2 Expressing the Extended Trace
An extended trace is a model which is an instance of the ExtendedTraceMM
metamodel. Such a metamodel deﬁnes the notion of an ExtendedTrace as an
aggregation of the diﬀerent pieces of information required to derive the object
interaction:

Parameters. Input parameters are used for setting attributes and for ﬁnding 
objects. Output parameters are used for returning values.

Search values. A search value relates a class and the input parameter used

for ﬁnding speciﬁc objects of that class.

Domain Model. A reference to the Domain Model is preserved for typing 
instance speciﬁcations within the trace. It conforms to the Classes
diagram of the Kernel package of the UML metamodel [9].

Snapshots. A reference to the pair of snapshots representing the source
and target states is preserved for declaring instance speciﬁcations within
the trace. They conform to the Instances diagram of the Kernel package
of the UML metamodel.

Actions. The sequence of actions encoding responsibilities. Actions’ metamodel 
is based on the IntermediateActions package of UML. Particularly,
createAction is extended in order to contain nested actions for expressing 
object initialization.

GRASP. The application of GRASP encoding responsibility assignments.

This part of the metamodel is discussed next.

Figure 7 details the part of the ExtendedTraceMM metamodel concerning the
application of GRASP. This metamodel reuses a number of metaclasses from

254

A. Vignaga, D. Perovich, and M.C. Bastarrica

Fig. 7. The GRASP diagram of the ExtendedTraceMM package

the Kernel package of UML, colored in grey in the ﬁgure. Metaclass Controller
represents an application of Controller, and the InstanceSpeciﬁcation responsible
of controlling the system operation is associated. Creator represents an application 
of Creator, and the involved classes are related by two separate associations.
Finally, Expert represents an application of Expert that assigns the responsibility 
of knowing how a property is derived; straightforward applications of Expert
are handled on the ﬂy during the third stage. Expert has associated the DerivedProperty 
and the expert class. A derived property is a specialization of a
standard Property, and is related to the properties that are required for its calculation 
(targetProperty role). Since there may be more than one association
from the expert class to the owner class of a required property, that relation
(metaclass PropertyDerivationRelationship) also speciﬁes which opposite association 
end (providerRole role) needs to be used. For the POS example, instances
of these classes can be used for expressing that the total of a sale is calculated
using the subtotals of its sale line items, and so forth.

In Fig. 8 the extended trace for enterItem() is shown. Input parameter id is
used as a search value for ﬁnding speciﬁc instances of ProductSpeciﬁcation (e.g.
message 1.1 in Fig. 4). Actions nested in the creation of sli specify the responsibilities 
involved in its initialization. Finally, Sale is the creator of SalesLineItem,
and object r from sourceState is the controller of the system operation.

4.3 Synthesizing the Interaction

The third and last part of our technique consists of a model transformation
called XTrace2CD that produces the object interaction. The source model of this
transformation is the extended trace produced during the second stage, and the

Extracting Object Interactions Out of Software Contracts

255

1 xtrace enterItem(id : Integer, qty : Integer) {

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16 }

domain model POSDomainModel;
snapshots sourceState, targetState;

search value id of ProductSpeciﬁcation;
createAction sli : SalesLineItem {
linkAction s, sli, contained-in;
setAction sli, quantity, qty;
linkAction sli, ps, described-by;

}

creator Sale of SalesLineItem;
controller r;

Fig. 8. Extended trace for enterItem()

target model is a UML communication diagram whose metamodel [23] restricts
UML’s to our practical needs.

The target model can be understood as a directed multigraph of objects,
where a particular edge, called the entry point of the diagram, represents the
message which starts the interaction. Such a message corresponds to the system
operation, and by convention it has no source object and it is handled by the
controller. The ﬁrst step of the transformation consists of generating the entry
point. In the second step, the sequence of actions included in the extended trace
is iteratively processed in order. For each action a set of messages is produced
for resolving the corresponding sub-interaction. This set involves one or more
messages for the action itself, and since the controller is ultimately the source of
every action in the interaction, the set also involves a path of messages from the
controller to the object performing the action. Arguments required for performing 
the action, such as input parameters or objects, are collected along such a
path. In what follows we brieﬂy discuss the processing of each kind of action; a
detailed example on a concrete extended trace can be found in [24].

Except for objects modeling collections, the structure of the target state is
similar to that of the communication diagram (see objects and links of targetState
in Fig. 3, and in the interaction in Fig. 4). In general, a merge of the source and
target state is therefore used as the basis for the structure of the interaction. A
[createAction c : C] induces a create message from an instance of the creator
of C to object c. Nested actions are used for selecting the speciﬁc source of the
message, its arguments, and possible nested sub-interactions. A [linkAction a,
b, r] induces a message from an object which has visibility on a and b. The
target of such a message is a which receives b as an argument, or viceversa,
depending on the existing applications of GRASP Expert. Depending on the
upper bound of multiplicity in the proper end of r, the insertion of the argument
into a collection may be required as a sub-interaction. An [unlinkAction a, b, r]
is treated similarly, but the possible sub-interaction could involve the removal
of the argument from the collection instead. Finally, when not occurring as a

256

A. Vignaga, D. Perovich, and M.C. Bastarrica

nested action, a [setAction o, a, v] induces a message to o from an object which
has visibility to it and has access to value v.

4.4 Tool Support
As a proof of concept for our technique we developed a prototype of the two
tools shown as light greyed boxes in Fig. 1. The ﬁrst tool named Engine is a
reduced relational model transformation engine developed in Prolog. Its execution 
semantics is based on QVT Relations [8]. The engine processes relational
model transformations as discussed in Sect. 4.1 and is also capable of producing
the proper trace. The second tool named XTrace2CD is an imperative model
transformation implemented in Kermeta [15] which synthesizes interactions as
explained in Sect. 4.3. The details of both implementations are reported in [24].
We applied our technique to the complete Process Sale use case of the POS
case study described in Sect. 2 using these tools. We deﬁned the required contracts 
in our variant of QVT Relations for every system operation, and used
the ﬁrst tool for producing the corresponding traces. All traces are correct with
respect to their associated contract. These traces matched those reported in [21]
where their correctness was formally proved. In turn, we applied the second
tool to the extended version of the traces for deriving the object interactions.
Such a result matched that reported in [11]. The implementation of the prototype 
as well as all artifacts involved in the complete case study are available at
http://mate.dcc.uchile.cl/research/tools/eoisc mt/.

5 Related Work

The generation of design artifacts from analysis speciﬁcations has been extensively 
addressed, with varying levels of automation and involving diﬀerent source
and target artifacts. For example, [20] fully automates the generation of statecharts 
from scenarios and properties, [25] assists the generation of a class model
from a formal requirements speciﬁcation, and [17] automates the generation of
pseudocode from a set of sequence diagrams. We use software contracts which are
a common technique for specifying behavior, and we produce object interactions
which are an abstraction of the runtime view of object-oriented systems.

The activity of generating object interactions from software contracts, as described 
in Sect. 2, is presented in [11]. This is a manual process where the developer 
must deduce responsibilities from software contracts, assign every single
responsibility to objects using GRASP, and ﬁnally manually build the communication 
diagram. Our technique automates most of this process.

In [18], design is also based on RDD and conceived as a sequence of transformations 
performed in two separate phases. First, from an informal text-based
problem description, a generative phase produces an initial design similar to a
Domain Model, and identiﬁes a set of responsibilities. Although they propose
some techniques for automating this task, a great deal of manual intervention
is required. Second, a transformational phase successively reconﬁgures the design.
 Such transformations are aimed at balancing the cohesion of participating

Extracting Object Interactions Out of Software Contracts

257

classes, and based on design patterns applications. This approach uses one single 
design artifact called collaboration graph which can be regarded as a Design
Class Diagram [11] but with no attributes or operations. The output of our technique 
is more detailed as it focuses on the dynamic aspects of the design, from
which a Design Class Diagram can be automatically generated [23].

Visual contracts [13] are an alternative approach to software contracts `a la
Meyer. The behavior of an operation is speciﬁed by providing a pair of snapshots
exemplifying its eﬀect on a particular state, which conforms to a particular class
diagram. Such a class diagram is transformed to structural Java code, while
visual contracts are transformed to JML speciﬁcations that annotate operations
within the Java code. The developer then manually implements methods for
such operations. Although our technique uses snapshots that resemble a visual
contract, its main input are traditional software contracts as they are more
expressive. While their approach relies on manual method implementation, we
generate method realizations in the form of a trace and object interactions.

In [3], a mechanism for generating a set of operations for a given class diagram 
is presented. Such a set embodies basic command operations which describe
how the system state can evolve. State modiﬁcations are also expressed in terms
of actions, and similarly to our technique, operations on speciﬁc classes need
to be derived for supporting them. Furthermore, operations derived using this
approach are intended to be executable, and the notion of dependency among
actions is thus introduced. In our technique, such dependencies are represented
by the ordering of actions within the trace. Finally, although the proposed mechanism 
could be automated, no tool support is reported.

6 Conclusions and Further Work

In this paper we presented a technique which automates most of the process for
extracting object interactions out of software contracts using model transformations.
 For exploring the feasibility of our technique we developed a prototype tool
which was successfully applied to a well-known case study from the literature.
This technique embodies the practical application of several aspects of Model
Driven Engineering (MDE). We consider software contracts as relational model
transformations, a relational engine is used in a non-standard fashion, a DSL was
deﬁned, and diﬀerent approaches to model transformations (i.e., relational and
imperative) were applied. As a whole, our technique can be regarded as a composition 
of model transformations. In scenarios where a complex transformation is
divided into sub-transformations, deﬁning their scope is not straightforward and
the form of intermediate models (e.g. the extended trace) varies signiﬁcantly.
Applying our technique, software contracts can become cost-eﬀective since important 
information can be extracted from them, and also such information can
be used for producing other artifacts. The technique also provides a direct mechanism 
for testing software contracts, as the snapshot generated by the engine
can be examined for checking if the transformation produced the expected result.
 Finally, an engine executing contracts on the actual system state, rather

258

A. Vignaga, D. Perovich, and M.C. Bastarrica

than on a model of it, can be understood as a functional prototype of the system
at an early stage of development.

The technique we have developed currently lacks two desirable features. First,
given the sequential form of the actions within a trace, it is not possible to
perform case analysis. There are a number of situations where disjunctions could
be required: (a) cases based on the values of input parameters, (b) cases based on
the values returned by messages within the interaction, mainly for (i) alternative
paths of execution imposed by business rules, and (ii) error handling. Case (b.ii)
is generally ignored when specifying interactions since only typical behavior is
usually shown. On the other hand, cases (a) and (b.i) may be addressed in a
similar fashion. In this scenario, a diﬀerent source state should be used for each
case. Using several relations in the contract for expressing cases as discussed
in Sect. 4.1 simpliﬁes the identiﬁcation of such canonical states. From them,
diﬀerent traces are generated as before, and may be merged afterwards; [17]
proposes a technique aiming a similar purpose. Second, a common practice in
object-oriented design is to introduce classes not present in the problem domain.
This usually occurs as a consequence of applying GRASP High Cohesion and
Pure Fabrication [11] or design patterns. Our technique restricts interactions to
instances of classes in the Domain Model. Simons et al. [18] propose a technique
based on model transformations that detects cases of low cohesive classes and
suggest to restructure the design by applying design patterns. This technique can
be applied after generating the interactions, hence improving the object design.
As further work we plan to enhance our technique for including the features
just discussed, and also for achieving some degree of automation within the
second stage. We also plan to evolve the existing prototype towards an integrated
tool that fully realizes our technique.

References

1. Akehurst, D.H., Kent, S., Patrascoiu, O.: A Relational Approach to Deﬁning and
Implementing Transformations between Metamodels. Software and System Modeling 
2(4), 215–239 (2003)

2. Alanen, M., Lundkvist, T., Porres, I.: Creating and Reconciling Diagrams after
Executing Model Transformations. Science of Computer Programming 68(3), 155–
178 (2007)

3. Cabot, J., G´omez, C.: Deriving Operation Contracts from UML Class Diagrams.
In: Engels, G., Opdyke, B., Schmidt, D.C., Weil, F. (eds.) MODELS 2007. LNCS,
vol. 4735, pp. 196–210. Springer, Heidelberg (2007)

4. Cariou, E., Marvie, R., Seinturier, L., Duchien, L.: OCL for the Speciﬁcation of
Model Transformation Contracts. In: OCL and Model-Driven Engineering UML
2004 Workshop, Lisbon, Portugal (2004)

5. Coleman, D., Arnold, P., Bodoﬀ, S., Dollin, C., Gilchrist, H., Hayes, F., Jeremaes,
P.: Object-Oriented Development: The Fusion Method. Prentice-Hall, Inc., Upper
Saddle River (1994)

6. Czarnecki, K., Helsen, S.: Feature-based Survey of Model Transformation Approaches.
 IBM Systems Journal 45(3), 621–645 (2006)

Extracting Object Interactions Out of Software Contracts

259

7. France, R., Rumpe, B.: Model-driven Development of Complex Software: A Research 
Roadmap. In: FOSE 2007: Future of Software Engineering 2007, pp. 37–54.
IEEE Computer Society, Los Alamitos (2007)

8. O. M. G. Inc. Meta Object Facility (MOF) 2.0. Query/View/Transformation Speciﬁcation.
 OMG Document ptc/05-11-01 (November 2005)

9. O. M. G. Inc. UML Superstructure, v2.1.1. OMG Document formal/07-02-05 (February 
2007)

10. Kaldewaij, A.: Programming: The Derivation of Algorithms. Prentice-Hall International 
Series in Computer Science (1990)

11. Larman, C.: Applying UML and Patterns: An Introduction to Object-Oriented
Analysis and Design and Iterative Development, 3rd edn. Prentice Hall, Englewood
Cliﬀs (2004)

12. Lawley, M., Raymond, K.: Implementing a Practical Declarative Logic-based Model

Transformation Engine. In: SAC 2007, pp. 971–977 (2007)

13. Lohmann, M., Sauer, S., Engels, G.: Executable Visual Contracts. In: 2005 IEEE
Symposium on Visual Languages and Human-Centric Computing (VL/HCC 2005),
Dallas, TX, USA, pp. 63–70. IEEE Computer Society, Los Alamitos (2005)

14. Meyer, B.: Object-Oriented Software Construction. 2 edn. Prentice-Hall, Inc., Upper 
Saddle River, NJ, USA (1997)

15. Muller, P.-A., Fleurey, F., J´ez´equel, J.-M.: Weaving Executability into ObjectOriented 
Meta-languages. In: Briand, L.C., Williams, C. (eds.) MoDELS 2005.
LNCS, vol. 3713, pp. 264–278. Springer, Heidelberg (2005)

16. Rumbaugh, J., Jacobson, I., Booch, G.: Uniﬁed Modeling Language Reference Manual,
 2nd edn. Pearson Higher Education (2004)

17. Selonen, P., Syst¨a, T., Koskimies, K.: Generating Structured Implementation

Schemes from UML Sequence Diagrams. In: TOOLS 2001, pp. 317–330 (2001)

18. Simons, A.J.H., Snoeck, M., Hung, K.S.Y.: Using Design Patterns to Reveal the
Competence of Object-Oriented Methods in System-Level Design. International
Journal of Computer Systems Science and Engineering 14(6), 343–352 (1999)

19. Stevens, P.: Bidirectional Model Transformations in QVT: Semantic Issues and
Open Questions. In: Engels, G., Opdyke, B., Schmidt, D.C., Weil, F. (eds.) MODELS 
2007. LNCS, vol. 4735, pp. 1–15. Springer, Heidelberg (2007)

20. Uchitel, S., Brunet, G., Chechik, M.: Behaviour model synthesis from properties
and scenarios. In: ICSE 2007, pp. 34–43. IEEE Computer Society, Los Alamitos
(2007)

21. Vignaga, A.: A Case Study in Formal Reasoning about the Use of State Modiﬁcation 
Primitives. Technical Report 04-09, InCo/Pedeciba (2004)

22. Vignaga, A.: A Formal Semantics of State Modiﬁcation Primitives of ObjectOriented 
Systems. Master’s thesis, Pedeciba and Universidad de la Rep´ublica,
Uruguay (February 2004)

23. Vignaga, A., Bastarrica, M.C.: Transforming System Operations’ Interactions into

a Design Class Diagram. In: SAC 2007, pp. 993–997 (2007)

24. Vignaga, A., Perovich, D., Bastarrica, M.C.: On Extracting a Design out of Software 
Contracts. Technical Report TR/DCC-2007-1, DCC, Universidad de Chile
(2007)

25. Wahono, R.S., Far, B.H.: A Framework for Object Identiﬁcation and Reﬁnement
Process in Object-Oriented Analysis and Design. In: IEEE ICCI, pp. 351–360.
IEEE Computer Society, Los Alamitos (2002)

26. Wirfs-Brock, R., McKean, A.: Object Design: Roles, Responsibilities, and Collaborations.
 Pearson Education (2002)

