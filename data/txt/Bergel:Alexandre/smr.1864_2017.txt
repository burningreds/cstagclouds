Received: 12 August 2016

Revised: 12 January 2017

Accepted: 14 February 2017

DOI: 10.1002/smr.1864

R E S E A R C H A R T I C L E

Identifying Classes in Legacy JavaScript Code

Leonardo Humberto Silva1
Nicolas Anquetil3 Anne Etien3

Marco Tulio Valente1 Alexandre Bergel2

1Department of Computer Science, Federal
University of Minas Gerais, Belo Horizonte,
Brazil
2Department of Computer Science, DCC -
Pleiad Lab, University of Chile, Santiago, Chile
3RMod Project Team, INRIA Lille Nord Europe,
France

Correspondence
Leonardo Humberto Silva, Department of
Informatics, Federal Institute of Northern
Minas Gerais, Salinas, Brazil.
Email: leonardo.silva@ifnmg.edu.br

Funding information
STICAmSud, Grant/Award Number: 14STIC-02;
FONDECYT, Grant/Award Number: 1160575

Abstract

JavaScript is the most popular programming language for the Web. Although the language is
prototype-based, developers can emulate class-based abstractions in JavaScript to master the
increasing complexity of their applications. Identifying classes in legacy JavaScript code can support 
these developers at least in the following activities: (1) program comprehension; (2) migration
to the new JavaScript syntax that supports classes; and (3) implementation of supporting tools,
including IDEs with class-based views and reverse engineering tools. In this paper, we propose
a strategy to detect class-based abstractions in the source code of legacy JavaScript systems.
We report on a large and in-depth study to understand how class emulation is employed, using
a dataset of 918 JavaScript applications available on GitHub. We found that almost 70% of the
JavaScript systems we study make some usage of classes. We also performed a field study with
the main developers of 60 popular JavaScript systems to validate our findings. The overall results
range from 97% to 100% for precision, from 70% to 89% for recall, and from 82% to 94% for
F-score.

KEYWORDS

JavaScript, Program comprehension, Reverse engineering

1

INTRODUCTION

JavaScript is the most popular programming language for the Web. The
language was initially designed in the mid-1990s to extend web pages
with small executable code. Since then, its popularity and relevance
only grew.1-3 JavaScript is now the most popular language on GitHub,
including newly created repositories. Richards et al4 also reported that
the language is used by 97 out of the web's 100 most popular sites.
Concomitantly with its increasing popularity, the size and complexity of
JavaScript software is in steady growth. The language is now used to
implement mail clients, office applications, and IDEs, which can reach
hundreds of thousands of lines of code.*

JavaScript is an imperative and object-oriented language centered
on prototypes, rather than a class-based language.5-7 Recently, the
new standard version of the language, named ECMAScript 6 (ES6),
included syntactical support for classes.8 In this new version, it is
possible to implement classes using a syntax very similar to the one
provided by mainstream class-based object-oriented languages, like

Java and C++. However, there is a large codebase of legacy JavaScript
source code, ie, code implemented in versions prior to the ES6 standard.
 To mention an example, GitHub has currently over 3 million active
repositories whose main language is JavaScript†, most of them implemented 
in ECMAScript 5. In this legacy code, developers can emulate 
class-based abstractions, ie, data structures including attributes,
methods, constructors, inheritance, etc, using the prototype-based
object system of the language, which is part of JavaScript since
its first version.

In a previous paper, we presented a set of heuristics followed by
an empirical study to analyze the prevalence of class-based structures
in legacy JavaScript code.9 This empirical study was conducted on 50
popular JavaScript systems, all implemented according to ECMAScript
5. The results indicated that (1) class-based constructs are present in
74% of the studied systems, that (2) there is no correlation between
code size and the number of class-like structures, and that (3) emulating
inheritance through prototype chaining is not common. In this paper,
we extend this previous work as follows:

*http://sohommajumder.wordpress.com/2013/06/05/gmail-has-biggest-collection-of-
javascript-code-lines-in-the-world

†http://githut.info/

J Softw Evol and Proc. 2017;29:e1864.
https://doi.org/10.1002/smr.1864

wileyonlinelibrary.com/journal/smr

Copyright © 2017 John Wiley & Sons, Ltd.

1 of 20

2 of 20

SILVA ET AL.

• We conduct a new study and increase our dataset from 50 to
918 systems. We use an external library called Linguist to allow
the extraction of a large dataset from GitHub, ignoring binary or
third-party files and suppressing files generated automatically.

• We perform a field study with 60 professional JavaScript developers
to evaluate the accuracy of the proposed strategy to detect class-like
structures in legacy JavaScript code.

• We measure precision, recall, and F-score for the identification of
classes, methods, and attributes. The overall results range from 97%
to 100% for precision, from 70% to 89% for recall, and from 82% to
94% for F-score.

• We investigate if JavaScript developers intend to use the new support 
for classes that comes with ES6.

The main objective of this work is to propose, implement, and evaluate 
a set of heuristics to identify class-based structures and their
dependencies, in legacy JavaScript code. Identifying classes in legacy
JavaScript code is important for 2 major reasons. Firstly, it can support 
developers to migrate their legacy code to ES6, manually or by
using tools that rely on the heuristics proposed in this paper. Secondly,
 it opens the possibility to implement a variety of analysis tools
for legacy JavaScript code, including IDEs with class-based views, bad
smells detection tools, reverse engineering tools, and techniques to
detect violations and deviations in class-based architectures.

The main contributions of our work are as follows:

• We document how prototypes are used in JavaScript to support the
implementation of structures including both data and code and that
are further used as a template for the creation of objects (Section
2). We use the term classes to refer to such structures, because they
have a very similar purpose as the native classes from mainstream
object-oriented languages.

• We propose a strategy to statically identify classes in JavaScript code
(Section 3). We also propose an open source supporting tool, called
JSCLASSFINDER, that practitioners can use to detect and inspect
classes in legacy JavaScript software.

• We provide a thorough study on the usage of classes in a dataset of
918 JavaScript systems available on GitHub (Section 4). This study
aims to answer the following research questions: (RQ #1) Do developers 
emulate classes in legacy JavaScript applications? (RQ #2)
Do developers emulate subclasses in legacy JavaScript applications?
(RQ #3) Is there a relation between the size of a JavaScript application 
and the number of class-like structures? (RQ #4) What is the
shape of the classes emulated in legacy JavaScript code? By “shape
of a class” we mean how it is organized in terms of the number of
attributes and methods.

• We report the results of a field study with 60 professional JavaScript
developers (Section 5). We rely on these developers to validate our
findings and our strategy to detect classes. This study aims to answer
the following research questions: (RQ #5) How accurate is our strategy 
to detect classes? (RQ #6) Do developers intend to use the new
support for classes that comes with ECMAScript 6?

The remainder of this paper is organized as follows: Section 2 provides 
a background on how classes are emulated in legacy JavaScript
code using functions and prototypes. Section 3 introduces our

strategy and tool to identify classes in JavaScript. Section 4 describes
the research questions that guide this work, along with the dataset,
metrics, and methodology used in our studies. We show and discuss
answers to the proposed research questions in Section 5. We discuss
the implications of our results and future research opportunities in
Section 6. Threats to validity are exposed in Section 7, and related work
is discussed in Section 8. We conclude by summarizing our findings in
Section 9.

2

CLASSES IN JAVASCRIPT

In this section, we discuss how classes can be emulated in legacy
JavaScript code (Subsection 2.1). We also describe the syntax proposed
in ECMAScript 6 to support classes (Subsection 2.2).

2.1

Class emulation in legacy JavaScript code

This section describes the different mechanisms to emulate classes
in legacy JavaScript. To identify these mechanisms, we conducted an
informal survey on documents available on the web, including tuto-
rials‡, blogs§, and StackOverflow discussions¶. We surveyed a catalogue 
of five encapsulation styles for JavaScript proposed by Gama
et al10 and JavaScript books targeting language practitioners.11,12
We also interviewed the developer of a real JavaScript project to
tune our tool and strategy. This developer is the leader of the
open source project select2‖ (a customizable replacement for
select boxes).

An object in JavaScript is a set of name-value pairs. Methods and variables 
are called properties, and their values can be any objects, including
immediate values (eg, numbers and boolean) and functions. To implement 
classes in JavaScript, prior to ECMAScript 6 standard, the most
common strategy is to use functions. Particularly, any function can be
used as a template for the creation of objects. When a function is used
as a class constructor, its this is bound to the new object being constructed.
 Variables linked to this are used to define properties that
emulate attributes and methods. If a property is an inner function, then
it represents a method, otherwise, it is an attribute. The operator new
and the method Object.create( … ) are usually used to instantiate
classes.

To illustrate the definition of classes in legacy JavaScript code,
we use a simple Circle class. Listing 1 presents the function that
defines this class (lines 1-8), which includes 2 attributes (radius
and color) and 2 methods (getArea and setColor). Functions
used to define methods can be implemented inside the body of the
class constructor, like getArea (lines 4-6), or outside, like setColor
(lines 9-11). An instance of the class Circle is created with the
keyword new (line 13).

‡https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_
Object-Oriented_JavaScript
§http://javascript.crockford.com/prototypal.html
¶http://stackoverflow.com/questions/387707/whats-the-best-way-to-define-
a-class-in-javascript
‖https://select2.github.io/

SILVA ET AL.

3 of 20

Each object in JavaScript has an implicit prototype property that
refers to another object. The instance link between an object and
its class in mainstream object-oriented languages is assimilated to
the prototype link between an object and its prototype in JavaScript.
To evaluate an expression like obj.p, the runtime system starts
searching for property p in obj, then in obj.prototype, then in
obj.prototype.prototype, and so on until it finds the desired
property or the search fails. When an object is created using newC its
prototype is set to the prototype of the function C, which by default
is defined as pointing to Object (the global base object in JavaScript).
Therefore, a chain of prototype links usually ends at Object.

By manipulating the prototype property, we can define methods
whose implementations are shared by all object instances. It is also
possible to define attributes shared by all objects of a given class,
akin to static attributes in class-based languages. In Listing 2, Circle 
includes a pi static attribute (line 2) and a getCircumference
method (lines 5-7). It is worth noting that getCircumference is not

attached to the class (as a static method in Java). It has for example
access to the object this, whose value is not determined using lexical

scoping rules, but instead using the caller object.

Prototypes are also used to introduce inheritance hierarchies.13,14
In JavaScript, we can consider that a class C2 is a subclass of C1 if C2's
prototype refers to C1's prototype or to an instance of C1. For example,
Listing 3 shows a class Circle2D that extends Circle with its position
in a Cartesian plane.

Alternatively, the subclass may refer directly to the prototype of the
superclass, which is possible using the Object.create() method.
This method creates a new object with the specified prototype object,
as illustrated by the following code:

Table 1 summarizes the mechanisms presented in this section to map

class-based object-oriented abstractions to JavaScript abstractions.

4 of 20

SILVA ET AL.

TABLE 1 Class-based languages vs JavaScript

3.1

Strategy to detect classes

Class-based languages

JavaScript

Class

Attribute

Method

Static attribute

Inheritance

Function

Field property

Inner function property

Prototype property

Prototype chaining

2.2

ECMAScript 6 classes

ECMAScript is the standard definition of JavaScript.5 ECMAScript 68 is
the latest version of this standard, which was released in 2015**. Interestingly,
 a syntactical support to classes is included in this last release.
For example, ES6 supports the following class definition:

However, this support to classes does not impact the semantics of the
language, which remains prototype-based. For example, the previous
class is equivalent to the following code:

The emulation strategies discussed in the previous section straightforwardly 
detects this code as a Circle class, with a radius attribute
and a getArea method. Therefore, identifying class-like structures
in legacy JavaScript code can, for example, motivate developers to
migrate such structures to syntax-based classes, according to the ES6
standard.

DETECTING CLASSES IN LEGACY

3
JAVASCRIPT

In this section, we describe our strategy to statically detect classes
in legacy JavaScript source code (Subsection 3.1). Subsection 3.2
describes the tool we implemented for this purpose. We also report
limitations of this strategy, mainly because of the dynamic nature of
JavaScript (Subsection 3.3).

To detect classes, we reuse with minimal adaptations a simple grammar,
originally proposed by Anderson et al15 to represent how objects are
created in JavaScript and how objects acquire fields and methods. This
grammar is as follows:

This grammar assumes that a program is composed of functions and
that a function's body is an expression. The expressions of interest are
the ones that create objects and add properties to functions via this
or prototype.

Definition 1. A class is a tuple (C, , ), where C is the class name,
 = {a1, a2, … , ap} are the attributes defined by the class, and  =
{m1, m2, … , mq} are the methods. Moreover, a class(C, , ), defined
in a JavaScript program P, must respect the following conditions:

• P must have a function with name C.
• For each attribute a ∈ , the class constructor or one of its methods 
must include an assignment this.a= Exp or P must include an
assignment C.prototype.a= Exp.

• For each method m ∈ , function C must include an assignment
this.m= function{ Exp } or P must include an assignment
C.prototype.m= function{ Exp }.

However, when functions matching Definition #1 are implemented in
the same lexical scope, as functions Circle and setColor in Listing 1,
we must distinguish those that are class constructors from those that
are methods. To achieve that, we do not consider as a class constructor
a function that (1) has no inner functions bound to this, (2) does not
participate in inheritance relationships defined using prototypes, and
(3) is never instantiated with neither new nor Object.create. In Listing 
1, function setColor does not have inner functions bound to this
nor inheritance relationships and it is never instantiated. Therefore, it
is not considered a function constructor, but a method of class Circle.

Definition 2. Assuming that (C1, 1, 1) and (C2, 2, 2) are
classes in a program P, we define that C2 is a subclass of C1 if 1 of the
following conditions holds:

• P includes an assignment C2.prototype=newC1().
• P includes an assignment C2.prototype=Object. create

(C1.prototype).

3.2

Tool support

**https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/
ECMAScript_6_support_sin_Mozilla

We implemented a tool, called JSCLASSFINDER,16 for identifying
classes in legacy JavaScript programs. As illustrated in Figure 1, this tool

SILVA ET AL.

5 of 20

FIGURE 1

JSClassFinder's architecture

can interact with a Moose model to access all visualization features 
and metric values. This model also allows the use of drill-down
and drill-up operations when an entity is selected. The visualization
options include UML class diagrams,18 distribution maps,19 and tree
views.

It is possible for a user to customize the diagrams and to choose
which elements to expose. For example, Figure 2 shows a distribution 
map for the system JADE. In this visualization, classes are represented 
by external rectangles, the small blue squares are methods,
and the links between classes represent inheritance relationships. It is
also possible to show a similar diagram where the external squares are
JavaScript files and the internal squares are classes.

JSCLASSFINDER also collects the following metrics: number of
attributes (NOA), number of methods (NOM), depth of inheritance tree
(DIT), and number of children.20

FIGURE 2 Example of distribution map for system JADE, generated
by JSClassFinder

3.3

Limitations

works in 2 steps. In the first step, Esprima††—a widely used JavaScript
Parser—is used to generate a full abstract syntax tree (AST), in JSON
format. In the second step, the “Class Detector” module is responsible 
for identifying classes in the JavaScript AST and producing an
object-oriented model of the source code.

The models generated by JSCLASSFINDER are integrated with
Moose‡‡, which is a platform for software and data analysis.17
This platform provides visualizations to interact with the tool and
to “navigate” the application's model. All information about classes,
methods, attributes, and inheritance relationships is available. Users

We acknowledge that there is not a single strategy to emulate classes
in JavaScript. For example, it is possible to create “singleton” objects
directly, without using any class-like constructions, as in Listing 4. Even
though we do not consider such objects as classes, we chose to follow 
the definition presented in the previous study,21 in which Booch
et al state that classes and objects are tightly interwoven, but there are
important differences between them (“a class is a set of objects that
share a common structure, common behavior, and common semantics,”
“a single object is simply an instance of a class,” page 93).

In addition, there are various JavaScript frameworks, like Proto-
type§§ and ClazzJS¶¶, that support their own style for implementing

††http://esprima.org
‡‡http://www.moosetechnology.org/

§§http://prototypejs.org
¶¶https://github.com/alexpods/ClazzJS

6 of 20

SILVA ET AL.

class-like abstractions. For this reason, we do not struggle to cover
the whole spectrum of alternatives to implement classes. Instead, we
consider only the strategy closest to the syntax and semantics of
class-based languages and that ES6 code can be directly translated (as
discussed in Subsection 2.2).

Moreover, there are object-oriented abstractions that are more
difficult to emulate in JavaScript, like abstract classes and interfaces.
Encapsulation is another concept that does not have a straightforward
mapping to JavaScript. A common workaround to simulate private
members in JavaScript is by using local variables and closures. As shown
in Listing 5, an inner function f2 in JavaScript has access to the variables 
of its outer function f1, even after f1 returns. Therefore, local
variables declared in f1 can be viewed as private, because they can
only be accessed by the “private function” f2. However, we do not classify 
f2 as a private method, mainly because it cannot be accessed from
the object this, nor can it be directly called from the public methods
associated to the prototype of f1.

In JavaScript, it is possible to remove properties from objects dynamically,
 eg, by calling deletemyCircle.radius. Therefore at runtime,
an object can have less attributes than the ones initially defined. It is
also possible to modify the prototype chains dynamically, which would
mean modifying the “inheritance” links. Finally, the behavior of a program 
can also be dynamically modified using the eval operator.22,23
However, we do not consider the impact of eval in the strategy
described in Subsection 3.1. For example, we do not account for classes
entirely or partially created by means of eval.

Still because of the dynamic nature of JavaScript, if a class has a
property that receives the return of a function call, this property is
classified as an attribute, even if this call returns another function.
Listing 6 shows an example in which the property this.x (line 6)
is classified as an attribute,
instead of a method, because the
language is loosely typed and we do not evaluate the results of
function calls.

4

EVALUATION DESIGN

In this section, we describe the methodology we use to evaluate and
to validate the strategy proposed to detect classes in legacy JavaScript
code. We first present the questions that motivate our research
(Subsection 4.1). Next, we describe the process we follow to select
JavaScript repositories on GitHub and to carry out the necessary clean
up of the downloaded code (Subsection 4.2). The metrics we use in our
evaluation are described in Subsection 4.3. Finally, we report the design
of a field study with JavaScript developers in Subsection 4.4.

4.1

Research questions

is to evaluate the strategy that we propose
Our main goal
to detect
software.
 To achieve this goal, we pose the following research
questions:

class-like abstractions

in legacy JavaScript

• RQ #1: Do developers emulate classes in legacy JavaScript applica-

tions?

• RQ #2: Do developers emulate subclasses in legacy JavaScript appli-

cations?

• RQ #3: Is there a relation between the size of a JavaScript application 
and the number of class-like structures?

• RQ #4: What is the shape of the classes emulated in legacy

JavaScript code?

• RQ #5: How accurate is our strategy to detect classes?
• RQ #6: Do developers intend to use the new support for classes that

comes with ECMAScript6?

With RQ #1, we check if the emulation of classes is a common
practice in legacy JavaScript applications. RQ #2 checks the usage of
prototype-based inheritance. With RQ #3, we verify if the number of
JavaScript classes in a system is related to its size, measured in lines of
code. With RQ #4, we analyze the shape of JavaScript classes regarding 
the relation between the number of attributes and the number
of methods. With RQ #5, we evaluate the accuracy of the proposed
approach to identify class-like structures. With RQ #6, we verify if
developers intend to use the concrete syntax to define classes provided
by ES6.

4.2

Dataset

Our dataset includes the last version of the top 1000 JavaScript
repositories on GitHub, according to the number of stars. This selection 
was performed in July, 2015. After cloning the repositories,
we used an external library called Linguist‖‖ to clean up the source
code files. Linguist is used by GitHub to ignore binary, third-party,
and automatically-generated files when computing statistics on the
programming languages used by a repository. After running Linguist,
we also performed a custom-made script to remove tests, examples,
 documentation, and configuration files. More specifically, this
script removes the following files: gulpfile.js, gruntfile.js,
package.js,
*_tests.js,

*thirdparty.js,

*_test.js,

‖‖https://github.com/github/linguist

SILVA ET AL.

7 of 20

FIGURE 3 Dataset size distributions (log scales). A, #Files; B, # Functions; C, LOC; LOC, lines of code

test.js, tests.js, and license.js; and the following fold-
ers: test, tests, examples, example, build, dist, spec,
demos, demo, minify, release, releases, docs, bin, test-*,
and testing.

After this clean up process, 82 systems were not exploitable because
they did not contain any significant contributions, ie, they remained
with no source code files. Therefore, the final dataset was composed of
918 systems. Figure 3 shows the distribution of number of files, number 
of functions, and lines of code (LOC) in logarithm scale (base 10).
The width of the “violin plot” indicates the number of systems for a
given value. The largest system (gaia) has 375,615 LOC and 1650 files
with .js extension. The smallest system (jswiki) has 8 LOC and a single 
file. The average size is 8778 LOC (standard deviation 21,801 LOC)
and 41 files (standard deviation 163 files). The median (white dot at the
center of the “violin”) is 2170 LOC and 10 files.

4.3 Metrics

used to support classes). The denominator includes all functions in a

JavaScript program. We use the number of functions to implement
methods (function methods) instead of the number of methods because,

in JavaScript, it is possible to share the same function to implement

multiple methods. Listing 7 shows an example found in the system

SLICK, where a function body is shared by 2 methods. In this example,
the Slick class provides 2 methods (getCurrent and slickCur-
rentSlide) that perform the same action when called. Therefore,
the number of methods is equal to 2, but the number of function
methods is 1.

We used CD to classify the systems in 4 main groups:

• Class-free systems: systems that do not use classes at all (CD = 0).
• Class-aware systems: systems that use classes but marginally (0 <

CD ⩽ 0.25).

• Class-friendly systems: systems with an important usage of classes

(0.25 < CD ⩽ 0.75).

• Class-oriented systems: systems where most structures are classes

In the following, we describe the metrics we use to answer the first 4
research questions proposed in Subsection 4.1.

(CD > 0.75).

4.3.1

Class density (CD)

4.3.2

Subclass density (SCD)

To measure the amount of source code related to the emulation of
classes (as defined in Subsection 3.1) we use Class Density (CD), which is
defined as:

CD = # function methods + # classes

# functions

To evaluate the usage of inheritance, we propose the metric subclass
density (SCD), defined as:

SCD = |{C ∈ Classes|DIT(C) ⩾ 2}|

|Classes| − 1

This metric is the ratio of functions in a program that are related to
the implementation of classes, ie, that are methods or that are classes
themselves. It ranges between 0 (system with no functions related
to classes) to 1 (a fully class-oriented system, where all functions are

where Classes is the set of all classes in a given system and DIT is
the Depth of Inheritance Tree. Classes with DIT = 1 only inherit from
the common base class (Object). SCD ranges from 0 (system that
does not make use of inheritance) to 1 (system where all classes

8 of 20

SILVA ET AL.

inherit from another class, except the class that is the root of the
class hierarchy). SCD is only defined for systems that have at least
2 classes.

4.3.3

Data-oriented class ratio (DOCR)

In a preliminary analysis, we noticed many classes having more
attributes than methods. This contrasts to the common shape of classes
in class-based languages, when classes usually have more methods than
attributes.24 To better understand the members of JavaScript classes,
we propose a metric called Data-oriented class ratio (DOCR), defined
as follows:

DOCR = |{C ∈ Classes|NOA(C) > NOM(C)}|

|Classes|

where Classes is the set of all classes in a system. Data-oriented class
ratio ranges from 0 (system where all classes have more methods than
attributes or both measures are equal) to 1 (system where all classes
are data-oriented classes, ie, their number of attributes is greater than
the number of methods).Data-oriented class ratio is only defined for
systems that have at least one class.

4.4

Field Study Design

To validate our strategy for detecting classes, we perform a field study
with the developers of 60 JavaScript applications, including 50 systems
from our previous work9 and 10 new systems. These systems have at
least 1000 stars on GitHub, 150 commits, and are not forks of other
projects. After checking out each system, we cleaned up the source
code to remove unnecessary files, as we did for the dataset described
in Subsection 4.2.

The systems considered in the field study are presented in Table 2,
including their version, a brief description, size (in lines of code), number 
of files, and number of functions. The selection includes well-known
and widely used JavaScript systems, from different domains, covering
frameworks (eg, ANGULAR.JS and JASMINE), editors (e.g, BRACKETS),
browser plug-ins (eg, PDF.JS), games (eg, 2048 and CLUMSY-BIRD),
etc. The largest system (ACE) has 140,023 LOC and 594 files with .js
extension. The smallest system (MASONRY) has 208 LOC and a single
file. The average size is 12,870 LOC (standard deviation 25,961 LOC)
and 56 files (standard deviation 101 files). The median size is 3,363 LOC
and 13 files.

This field study was conducted between March and June, 2015. For

each system, we performed the following steps:

1. We downloaded the latest version on GitHub and cleaned up the

source code.

2. We executed the parser (Esprima) to generate the AST.
3. We executed JSClassFinder to identify class-like structures and to

build a class diagram.

4. We used the information available on GitHub to identify the
main developers of each system. For systems supported by a
team of developers, the developer selected was the one with
the highest number of commits in the previous 3 months. We
then sent an email to the application's main developer with the

class diagram attached and asked him to validate the detected
classes. Figure 4 shows the class diagram sent to the developer of
ALGORITHMS.JS. This diagram includes 14 classes representing
common data structures, such as Stack, LinkedList, Graph,
HashTable, etc.

5. We analyzed and categorized the developer's responses.

In the mails to the developers, we asked 2 questions:

• Do you agree that the classes in the attached class diagram are

correct?

• Do you intend to use the new support for classes that comes with

ECMAScript 6? Why?

The developers had to answer the questions and point out their
reasons. The first question aims to evaluate the accuracy of our
approach to detect class-like structures (RQ #5). The second question 
aims to measure the interest in a concrete syntax to implement
classes in JavaScript (RQ #6). In the cases where, after 1 month,
an answer was not received, a gentle reminder was sent. For the
systems where we did not find any classes, we also sent emails requesting 
the developers to confirm that they really do not emulate classes in
their systems.

We sent 60 emails and received 33 answers, which represents a

response ratio of 55%. Out of the 33 answers, 29 were obtained after a

first round, and the other 4 after sending a gentle reminder.

We had 3 answers that could not be properly classified in our

study. The first came from a developer who said he agreed with

our findings but he was not totally sure. In the second case, the

developer sent a web link which contains the API documentation of
his application, and he recommended us to validate the classes ourselves.
 In the last case, the developer just stated that we should

never use classes. Therefore, after discarding these cases, we have 30

valid answers.

Figure 5 shows the distribution of the valid answers per group of

systems according to the class density (CD values). The distribution

indicates that our field study includes systems in all 4 main groups:
class-free (4 answers),
class-friendly
(7 answers), and class-oriented (4 answers).

class-aware (15 answers),

Finally, we use developers' answers to measure precision, recall, and
F-score for the classes, methods, and attributes identified by our tool.
These measures are calculated as follows:

Precision (P) =

TP

TP + FP

TP

Recall (R) =

TP + FN
F-score (F1) = 2 × P × R
P + R

,

where TP represents the true positives, FP the false positives, and FN
the false negatives. For classes, TP is the number of class-like structures
correctly identified by our tool, FP is the number of class-like structures
erroneously identified, and FN is the number of existing class-like structures 
that are not identified. F-score is the harmonic mean of precision

and recall. For methods and attributes, the measures are defined in a

SILVA ET AL.

9 of 20

TABLE 2
or more classes. The DOCR can only be computed for systems with at least one class

JavaScript systems (ordered by the CD column, see description in accompanying text). The SCD can only be computed for systems with 2

Version

Description

LOC

#Files

#Func

#Class

#Meth

#Attr

CD

SCD

DOCR

semantic-UI

1.12.3

UI component framework

18,369

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.01

0.01

0.02

0.02

0.02

0.02

0.02

0.03

0.03

0.04

0.05

0.05

0.06

0.07

0.07

0.09

0.09

0.09

0.11

0.11

0.11

0.12

0.14

0.16

0.17

0.22

0.22

0.24

0.31

0.33

0.34

0.36

0.44

0.47

0.51

0.55

0.55

-

-

-

-

-

-

-

-

-

-

-

-

-

-

0.00

-

0.00

0.00

0.00

0.21

-

0.00

0.00

0.00

0.22

0.00

0.00

0.29

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

0.00

-

-

0.01

-

0.00

0.09

0.03

-

0.23

0.11

0.00

0.00

0.21

-

-

-

-

-

-

-

-

-

-

-

-

-

1.00

1.00

0.00

0.50

1.00

0.57

0.20

0.00

0.67

0.90

1.00

0.58

0.00

0.25

0.50

0.50

0.27

0.08

0.67

0.40

0.50

0.92

0.00

0.41

0.00

0.00

0.46

0.00

0.33

0.31

0.21

0.00

0.21

0.44

0.40

0.33

0.34

System

masonry

randomColor

respond

resume

clumsy-bird

impress.js

jquery-pjax

async

modernizr

deck.js

zepto.js

photoSwipe

jQueryFileUp

leaflet

backbone

chart.js

turn.js

react

meteor

underscore

jasmine

paper.js

typeahead.js

d3

wysihtml5

sails

ionic

jquery

ghost

timelineJS

express

reveal.js

video.js

three.js

numbers.js

polymer

grunt

skrollr

ace

mousetrap

hammer.js

brackets

angular.js

intro.js

algorithms

pdf.js

bower

mustache.js

less.js

3.2.3

0.2.0

1.4.2

-

-

0.5.3

1.9.3

1.1.0

2.8.3

1.1.0

1.1.6

4.0.7

Cascading grid layout library

Color generator

Polyfill for CSS3 queries

Resume creator

Flappy Bird Game

Presentation framework

Plugin to handle Ajax requests

Async utilities

HTML5 and CSS3 detector

Modern HTML Presentations

Minimalist jQuery API

Image gallery

208

373

460

460

672

769

913

1,114

1,382

1,473

2,497

4,401

9.9.3

0.7.3

1.1.2

1.0.2

4.0.0

File upload widget

Library for interactive maps

Data structure for web apps

HTML5 charts library

Page flip effect for HTML5

0.13.2

Library for building UI

1.1.0.2

Development platform

1.8.2

2.2.1

0.9.22

0.10.5

3.5.5

0.3.0

Functional helpers

JavaScript testing framework

Vector graphics framework

Auto-complete library

Visualization library

Rich text editor

0.11.0

MVC framework for Node

1.0.0.4

HTML5 mobile framework

2.1.4

0.6.2

2.35.6

4.12.3

3.0.0

4.12.5

0.0.71

-

0.5.5

0.4.5

jQuery JavaScript library

Blogging platform

Visualization chart

Minimalist framework

HTML presentation framework

HTML5 video library

JavaScript 3D library

Mathematics library for Node

Library for building web apps

JavaScript task runner

0.6.29

Scrolling library

4,011

8,711

1,681

3,463

6,916

16,654

41,195

1,531

7,749

26,039

2,576

13,079

5,913

12,724

19,322

7,736

15,290

18,371

3,590

5,811

9,823

39,449

2,965

11,849

1,932

1,772

1

1

3

1

7

1

1

1

1

6

17

9

23

14

75

2

6

5

143

72

1

62

65

19

268

69

101

103

79

142

93

11

16

46

10

16

15

19

36

24

33

100

69

51

233

185

1,191

179

677

115

189

267

608

1,378

123

892

1,071

233

1,259

343

425

492

330

659

896

131

242

586

202

1,266

10

1

11

1

132

763

103

58

0

0

0

0

0

0

0

0

0

0

0

0

0

1

4

1

2

3

7

15

1

3

30

11

19

2

8

8

6

15

12

3

5

6

99

2

22

1

1

0

0

0

0

0

0

0

0

0

0

0

0

0

1

0

1

2

3

8

12

5

8

10

1

45

17

23

26

25

47

69

12

22

63

48

16

103

16

12

0

0

0

0

0

0

0

0

0

0

0

0

0

3

7

0

5

6

17

14

1

11

115

72

41

8

40

21

31

44

11

14

18

17

544

4

68

8

0

Source code editor

140,023

594

4,337

291

673

785

1.1.9

1.5.3

2.0.4

1.3.0

Library for handling shortcuts

Handle multi-touch gestures

Source code editor

1.4.0.1 Web application framework

1.0.0

0.8.1

1.1.1

1.4.1

2.0.0

2.3.1

Templates for introductions

Data structures & algorithms

Web PDF reader

Package manager

Logic-less template syntax

CSS pre-processor

1,281

2,348

130,770

49,220

1,255

3,263

57,359

8,464

594

12,045

5

19

392

191

1

58

88

60

1

99

46

124

1

6

10

33

4,298

173

1,239

981

42

165

61

1

14

2,277

181

304

33

707

15

3

64

276

14

59

895

143

15

327

0

25

750

171

2

32

795

97

7

278

10 of 20

TABLE 2 Continued

System

Version

Description

LOC

#Files

#Func

#Class

#Meth

#Attr

3.8.11

Streaming build system

Library to remove click delays

99

841

3

1

gulp

fastclick

pixiJS

isomer

2048

slick

floraJS

parallax

jade

socket.io

1.0.6

3.0.2

0.2.4

-

1.5.2

3.1.1

2.1.3

1.9.2

1.3.5

Rendering engine

21,024

113

Isometric graphics library

Number puzzle game

Carousel visualization engine

Simulation of natural systems

Motion detector for devices

Template engine for Node

Realtime app framework

770

873

2,300

2,942

1,007

11,427

1,297

7

10

1

20

3

27

4

5

23

703

47

76

81

86

57

169

57

1

1

87

7

7

1

18

2

19

4

2

16

453

31

62

86

62

56

142

58

6

10

546

27

29

0

315

75

73

46

SILVA ET AL.

SCD

DOCR

-

-

0.33

0.00

0.00

-

0.00

0.00

0.83

0.00

1.00

0.00

0.46

0.57

0.14

0.00

0.94

1.00

0.26

0.00

CD

0.60

0.74

0.76

0.81

0.91

0.93

0.93

0.95

0.95

1.00

Abbreviations: CD, class density; DOCR, data-oriented class ratio; LOC, lines of code; SCD, subclass density.

FIGURE 4 Class diagram for ALGORITHMS.JS, generated by JSClassFinder

similar way, but searching for method-like and attribute-like structures,

respectively.

5

RESULTS

In this section, we present the answers to the 6 proposed research
questions.

Do developers emulate classes in legacy

5.1
JavaScript applications?

We found classes in 623 out of 918 systems (68%). The system with the
largest number of classes is GAIA (1,001 classes), followed by NODEINSPECTOR 
(330 classes), and BABYLON.JS (294 classes). MATHJAX is
the largest system (122,683 LOC) that does not have classes. Figure 6A
shows the distribution of the number of classes for the systems that
have at least 1 class. The first quartile is 2 (lower bound of the black box
within the “violin”) with 135 systems having only 1 class. The median is
5 and the third quartile is 15 (upper bound of the black box). Listing 8

FIGURE 5 Number of answers, per group, from developers that agree
with our findings

SILVA ET AL.

11 of 20

FIGURE 6 Metric distributions. Results in (A) and (C) are reported only for systems with at least 1 class. A, # Classes; B, CD(All Systems); C,CD; CD,
class density

Figure 7 shows the number of systems in each of the 4 proposed 
groups (class-free, class-aware, class-friendly, and class-oriented
systems) according to the CD values. The largest group is the
class-aware (34%), in which systems use classes but they correspond to
less than 25% of the implemented functions. Class-oriented is the smallest 
group, in which the systems use more than 75% of their functions to
emulate classes.

shows an example of a class Color, detected in the system THREE.JS.
We omit part of the code for the sake of readability.

Figure 6B shows the distribution of the CD values. We found that
295 systems have CD equal to 0. In other words, 32% of the systems do
not use classes at all or are using an abstraction other than the one we
are looking for. The median is 0.08 and the third quartile is 0.41. We also
found seven fully class-oriented systems (CD = 1). Table 3 shows the 10
systems with the highest values of CD.

Figure 6C shows the CD distribution when we only consider the systems 
with CD greater than 0. The first quartile is 0.08, the median is
0.26, and the third quartile is 0.52. In other words, the emulation of
classes represents on the median 26% of the functions, for the systems
that include at least 1 class.

TABLE 3 Top-10 systems with highest CD values

System

SKEUOCARD

RAINYDAY.JS

SIDE-COMMENTS

ZOOM.JS

STEADY.JS

TMI

LAYZR.JS

SOCKET.IO

CLNDR

SLAP

CD

1.00

1.00

1.00

1.00

1.00

1.00

1.00

0.97

0.97

0.97

#Class

8

5

3

2

1

1

1

4

1

11

LOC

1,685

1,005

523

229

215

203

164

1,350

1,197

938

Abbreviations: CD, class density; LOC, lines of code.

FIGURE 7 Class density groups

12 of 20

SILVA ET AL.

Do developers emulate subclasses in legacy

5.2
JavaScript applications?

As shown in Figure 8, the use of prototype-based inheritance is rare
in JavaScript systems. First, we counted 499 systems (54%) having 2
or more classes, ie, systems where it is possible to detect the use of
inheritance. However, in 429 of such systems (86%), we did not find any
subclasses (SCD = 0). The system with the highest use of inheritance is
PROGRESSBAR.JS (SCD = 0.8). Figure 9 shows the class diagram for
this system. As can be seen, the Shape class has 4 subclasses: Circle,
Line, SemiCircle, and Square.

Is there a relation between the size of a

5.3
JavaScript application and the number of class-like
structures?

Figure 10 shows scatterplots with size metrics on the x-axis in a logarithmic 
scale and CD on the y-axis. We also computed the Spearman's
rank correlation coefficient between CD and the following size metrics:
size KLOC, number of files, and number of functions. The results are
presented in Table 4. We found a weak correlation for KLOC (P = .250),
number of files (P = .178), and for number of functions (P = .289). For
example, there are systems with similar sizes having both low and high
class densities. ALOHA-EDITOR is an example of a system with a considerable 
size (69 KLOC) and low class density (CD = 0.05). By contrast,
END-TO-END is also a large system (67 KLOC) but with a high class
density (CD = 0.78).

We also used the Kruskal–Wallis test to check if the LOC distributions 
in all 4 groups (class-free, class-aware, class-friendly,

FIGURE 8

Subclass density distribution

and class-oriented systems) are equal. The test resulted in a
p-value < 2.2e−16, leading us to reject the null hypothesis (the groups
have systems with equal size), at a 5% significance level. In fact, the
median measures of each tested group are quite different (690, 5667,
2578, and 1150).

5.4 What is the shape of the classes emulated
in legacy JavaScript code?

To verify the shape of JavaScript classes, regarding the number of methods 
and attributes, we focus on systems that have the number of classes
greater than or equal to 15 (which represents the 3rd quartile of this
distribution). Figure 11 shows the quantile functions for the NOA and
NOM in such systems. The x-axis represents the quantiles, and the
y-axis represents the metric values for the classes in a given quantile.
For example, suppose the value of a quantile p (x-axis) is k (y-axis), for
NOA. This means that p% of the classes in this system have at most k
attributes. As can be observed, the curves representing the systems
have a right-skewed (or heavy-tailed) behavior. In fact, this behavior is
normally observed in source code metrics.25-27

Regarding NOA, the quantile functions reveal that the vast majority
of the classes have at most 28 attributes (90th percentile). Regarding
NOM, the vast majority of the classes have less than 61 methods (90th
percentile). To compare NOA and NOM measures, Figure 12 shows
the DOCR distribution using a violin plot. The median DOCR value is
0.39, which is a high measure when compared to other languages. For
example, metric thresholds for Java suggest that classes should have at
most 8 attributes and 16 methods.28 By contrast, half of the JavaScript
systems that we studied have more than 39% of their classes with more
attributes than methods. We hypothesize that it is due to JavaScript
developers placing less importance on encapsulation. For example, getters 
and setters are rare in JavaScript.

5.5

How accurate is our strategy to detect classes?

As described in Section 4, we measure accuracy using precision, recall,
and F-score. Table 5 summarizes the results according to the develop-
ers' answers. The developers of 21 out of 30 systems (70%) fully agreed
that the class diagrams we provided, on the basis only of the code base
of their systems, correctly model the classes they implemented. Therefore,
 precision, recall, and F-score for these systems are equal to 100%.
The following 2 comments are examples of answers we received for
such systems:

“Yes, everything looks like it actually is in the code base.”
(Developerof system LESS.JS)

“I do in fact agree with your findings on classes/methods/
attributes. In building numbers.js I did have OOP in mind.”
(Developer of system NUMBERS.JS)

SILVA ET AL.

13 of 20

FIGURE 9

Inheritance in system PROGRESSBAR.JS

FIGURE 10

Size metrics vs Class Density. A, KLOC vs CD; B, # Files vs CD; C, Func vs CD; CD, class density

TABLE 4 Correlation between CD and size metrics

Spearman
p value

KLOC

0.250

# Files

0.178

# Func

0.289

1.407e−14

6.216e−08

< 2.2e−16

14 of 20

SILVA ET AL.

FIGURE 11 Quantile functions. A, NOA; B, NOM; NOA, number of attributes; NOM, number of methods

some entities as classes. In both cases, the false positives are due to a limitation 
regarding JavaScript scoping rules. Listing 9 shows an example

for ANGULAR.JS. In this example, we have a MessageFormatParser
class, with a method startStringAtMatch (lines 4-6). Since there

is also a function match in the global scope (line 1) our tool initially

classifies stringQuote as a method (line 5). However, because of the

scoping rules of JavaScript, this property is initialized with the formal 
parameter of startStringAtMatch, which is also named match.

Moreover, match always receives a nonfunction value, and therefore

it should have been classified as an attribute. A similar issue happens

in ACE.

False positives for attributes. We have 2 situations in which methods 
are indeed identified as attributes in the system ANGULAR.JS.
Listing 10 shows part of the implementation for the class JQLite. Our
strategy correctly classifies the property ready (line 2) as a method,
but it is not able to do the same with the property splice (line 3).
The function [].splice is not recognized as a function because its
implementation is not part of the source code of ANGULAR.JS (it is a
JavaScript native function from Array object). Currently, our implementation 
does not recognize as methods functions that are initialized

with JavaScript built-in functions.

Listing 11 shows another example of a property that is not identified 
as a method in ANGULAR.JS, as we can see in the following
comment:

“$get is marked as attribute a lot, it should always be a
method.” (Developer of ANGULAR.JS)

FIGURE 12 Data-oriented class ratio distribution

5.5.1

Precision

We achieve a precision of 100% in 28 out of 30 systems for classes; in
all 30 systems for methods; and in 29 systems for attributes. In the following 
paragraphs, we discuss the false positives we detected for classes
and attributes.

False positives for classes. The developers of systems ACE and

ANGULAR.JS pointed out that our strategy incorrectly identified

SILVA ET AL.

15 of 20

TABLE 5 Precision, Recall, and F-score results

Classes

Precision (%)
Methods

Attributes

Classes

Recall (%)
Methods

Attributes

Classes

F-Score (%)
Methods

Attributes

Systems

ACE

ALGORITHMS.JS

ANGULAR.JS

BOWER

CLUMSY-BIRD

D3

EXPRESS

INTRO.JS

JADE

JASMINE

JQUERY

JQUERYFILEUP

LEAFLET

LESS.JS

MASONRY

MODERNIZR

MOUSETRAP

MUSTACHE.JS

NUMBERS.JS

PAPER.JS

PDF.JS

PIXIJS

RANDOMCOLOR

SAILS

SKROLLR

SLICK

SOCKET.IO

THREE.JS

UNDERSCORE

VIDEO.JS

93

100

92

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

87

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

0

83

60

100

100

7

100

100

9

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

11

99.57

85.67

100

100

93

100

0

48

36

100

100

5

100

100

0

100

100

100

100

100

100

3

100

100

100

100

100

100

100

100

100

15

80

100

100

100

100

0

79

56

100

100

24

100

100

4

100

100

100

100

100

100

59

100

100

100

100

100

100

100

100

100

16

96

100

96

100

0

91

75

100

100

13

100

100

17

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

100

20

100

100

96

100

0

65

53

100

100

10

100

100

0

100

100

100

100

100

100

6

100

100

100

100

100

100

100

100

100

26

100

100

93

100

0

88

72

100

100

39

100

100

8

100

100

100

100

100

100

74

100

100

100

100

100

100

100

100

100

28

84.6

86.93

81.87

86.73

Mean

99.5

In this case, the property $get receives an array that contains a

function in its second element. Although the developer considers that

this property is a method, our approach identifies it as an array and
therefore classifies it as an attribute.

We achieve a recall of 100% in 24 out of 30 systems for classes;
in 22 systems for methods; and in 23 systems for attributes. In the
following paragraphs, we discuss the false negatives we detected for
classes, methods, and attributes.

5.5.2

Recall

16 of 20

SILVA ET AL.

“From a pure Object Orientation point of view, I would probably 
call almost every file inside ‘src / core‘ in the jasmine
repo its own class (minus a few like ‘util.js‘ and ‘base.js‘ at
least), which is more like 45 classes.” (Developer of system
JASMINE)

False negatives for methods and attributes. In all 6 systems with
missing classes, we also have, as consequence, missing methods and
attributes. Besides these cases, developers of other 2 systems pointed
out missing methods. In the first case, for system ANGULAR.JS, our
approach identified some methods as attributes, as discussed in the
previous subsection (precision). In the second case, PAPER.JS’s developers 
use a customized implementation that allows our approach to
identify the classes, but not the methods. Listing 13 illustrates this
issue for the class Line. In this case, the association between the
constructor Line (line 3) and the methods getPoint(), getVec-
tor(), etc (lines 9-11) is built by using a project-specific function
called Base.extend (line 1). The usage of this function hides the methods 
and some attributes from our tool.

5.5.3

F-Score

Table 5 also reports the F-score results. The measures are equal to
100% in 22 out of 30 systems for classes, methods, and also for

False negatives for classes. Six developers pointed out at least 1
missing class in their systems. In the case of the system CLUMSY-BIRD,
the base class constructors are not available in the GitHub repository.
The application imports an external
file, which contains these
base classes.*** The import statement is placed directly in the main
HTML file. For this reason, we were not able to detect classes in
this system.

As a second case, EXPRESS' developer stated that our tool missed 2

classes, as shown in the following answer excerpt:

“So I have taken a look at the UML diagram you attached
to the email and they do look mostly right. The main thing
missing is there is also an Application class and a Router
class, to round out a total of five main classes. The three
you have there do look right, though.” (Developer of system
EXPRESS)

According to our strategy, Application and Router are not
classes. Application is implemented as a singleton object, and we
do not identify such structures as classes, as commented in Subsection 
3.3. Router is not a class because its methods and attributes are
not directly bound to this nor prototype. Instead, the constructor
function uses __proto__ (an accessor property), as we can see in Listing 
12 (line 5). In fact, __proto__ is a special name used by Mozilla's
JavaScript implementation to expose the internal prototype of the
object through which it is accessed. However, the use of __proto__
has been discouraged†††, mostly because it is not supported by other
browsers.

In the 4 remaining systems (D3, JASMINE, VIDEO.JS, and LEAFLET),
the causes for missing classes are related to the use of external
frameworks and libraries that provide their own style for implementing 
class-like abstractions. The following comments are examples of
answers in this category:

classes

Leaflet
own

you found are only a small part
“The
is because
Leaflet uses
of
https://github.com/Leaflet/
its
Leaflet/blob/master/src/core/Class.js” (Developer of system
LEAFLET)

classes. This
class
utility:

***http://cdn.jsdelivr.net/melonjs/2.0.2/melonJS.js
†††https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/
Object/proto

FIGURE 13 Overall results for precision, recall, and F-score

SILVA ET AL.

17 of 20

TABLE 6

Intention to use ECMAScript 6 classes

Type of answer

Yes

No

Did not know

#

19

12

2

%

58

36

6

attributes. In the remaining systems, the measures range from 0%
(CLUMSY-BIRD) to 96% (ACE and ANGULAR.JS) for classes, from 0%
(CLUMSY-BIRD and LEAFLET) to 96% (ANGULAR.JS) for methods, and
from 0% (CLUMSY-BIRD) to 93% (ANGULAR.JS) for attributes. The
system CLUMSY-BIRD has F-score equal to 0 because it uses base
class constructors that are not available in its source code repository, as
discussed in Subsection 5.5.2.

5.5.4

Overall results

Figure 13 presents the results for precision, recall, and F-score considering 
the whole population of classes, methods, and attributes, independently 
from system. The overall measurements range from 97%
(classes) to 100% (methods) for precision, from 70% (methods) to 89%
(attributes) for recall, and from 82% (methods) to 94% (attributes) for
F-score.

Do developers intend to use the new support

5.6
for classes that comes with ECMAScript 6?

Table 6 summarizes the answers for this question. Nineteen developers
(58%) answered that they intend to use the new syntax. Two of them
declared to have plans to migrate their systems to the new syntax, while
the others stated that they intend to use it only when implementing
new features and projects, as stated in the following answer:

“I'm quite confident that ES6 will make for a more robust
codebase. And I think the most interesting point is that it
can be applied progressively. We don't have to make a massive 
rewrite. Any new code we add can be ES6, and then we
can slowly rewrite old code to be ES6 as well.” (Developer of
system SOCKET.IO)

Twelve developers (36%) declared they do not intend to use ES6 syntax 
for classes, because they have to keep compatibility with legacy
code, as stated in the following answer:

“For us right now it makes more sense to use CJS patterns and integrate
with existing module ecosystems. When the ES6 penetration and support is
higher, maybe we will switch.” (Developer of system PIXIJS)

6

DISCUSSION

Heuristics limitations and improvement

6.1
opportunities

On the basis of the evaluation presented in Subsection 5.5, we summarize 
possible improvements to our heuristics to avoid both false
positives and false negatives.

A false positive may occur when there are different identifiers with
equal names, in different scopes. For example, when an identifier is
declared with the same name of a global function. In this case, when
the identifier is assigned to a class property, we can improve our heuristics 
by checking if this identifier corresponds to a variable or parameter
that is valid in the same scope. This way, the property can be classified 
as an attribute, instead of being wrongly classified as a method.
We also acknowledge that, during the program's execution, identifiers 
can receive a function as a value, transforming the class property
into a method. However, this is the case of dynamically modified features,
 and our approach identifies class structures statically. The same
understanding can be applied to class properties assigned to functions
that are not part of the application, ie, functions that belong to the
JavaScript API or to external libraries and frameworks.

To reduce the chances of false negatives, we can modify the heuristics 
to also recognize the syntax with __proto__, used by Mozilla's
JavaScript implementation, to expose the internal prototype of
objects. Even though, as mentioned in Subsection 5.5.2, the use of this
syntax has been discouraged by Mozilla. Moreover, we can also review
our heuristics regarding singletons. Because not every singleton object
is a class, further research is needed to precisely determine which ones
indeed represent classes in a legacy JavaScript system. For the other
false negatives pointed in Subsection 5.5, the base class constructors
implemented in external files (eg, in libraries and frameworks) cannot
be statically identified as classes because their source code is not part
of the system under analysis.

6.2

Practical implications

Almost 70% of the systems we studied use classes (CD > 0). In fact, this
usage may increase in the future because many developers intend to
use the new ES6 syntax for classes, as shown in our field study (Subsection 
5.6). Therefore, we might consider the adaptation to the JavaScript
ecosystem of many tools, concepts, and techniques widely used in
class-based languages, like (1) metrics to measure class properties like
coupling, cohesion, complexity, etc; (2) reverse engineering techniques
and tools to extract class and other diagrams from source code; (3)
IDEs that include class-based views, like class browsers; (4) tools to
detect bad smells in JavaScript classes; (5) recommendation engines
to suggest best object-oriented programming practices; (6) techniques
to detect violations and deviations in the class-based architecture of
JavaScript systems; and (7) tools to migrate to ES6.

7

THREATS TO VALIDITY

This section presents threats to validity according to the guidelines proposed 
by Wohlin et al.29 These threats are organized in 3 categories,
addressing internal, external, and construct validity.

Internal Validity. In the field study, to address RQ #5, we recognize 3
internal threats. First, we consider that the developers correctly evaluated 
all elements we provided in the class diagrams of their systems. We
acknowledge this activity is error-prone. However, we asked the main
developers of each system, who are probably the most qualified people
to conduct such evaluation. Second, because some developers did not
provide the names of all classes that represent false negatives in their
systems, the first author of this study performed a manual verification

18 of 20

SILVA ET AL.

in the related source code files to identify the remaining structures. The
third internal threat is related to the nonclassification of singletons as
classes, as mentioned in Subsection 3.3. In fact, in our field study some
of the interviewed developers considered that singletons are classes.

External Validity. To address the first 4 research questions, we used
a dataset of 918 JavaScript systems. For research questions RQ #5
and RQ #6, which involved contacting developers, we used a dataset
of 60 JavaScript systems. As a threat, our datasets, both obtained
from GitHub repository, might not represent the whole population of
JavaScript systems. But, at least, we selected a representative number 
of popular and well-known systems, of different sizes and covering
various domains.

Construct Validity. We use the library Linguist and a custom-made
script, as described in Subsection 4.2, to remove unnecessary files from
our dataset. We assume that this clean up process does not remove any
source code files that could be used to implement classes.

8

RELATED WORK

Richards et al22 conduct a large-scale study on the use of eval in
JavaScript, on the basis of a corpus of more than 10,000 popular web
sites. They report that eval is popular and not necessarily harmful,
although its use can be replaced with equivalent and safer code or language 
extensions in most scenarios. Moreover, it is usually considered a
good practice to use eval when loading scripts or data asynchronously.
After this first study, restricted to eval, the authors conduct a second
study on a broad range of JavaScript dynamic features.4 They conclude,
for example, that libraries often change the prototype links dynamically,
 but such changes are restricted to built-in types, like Object and
Array, and changes in user-created types are more rare. The authors
also report that most JavaScript programs do not delete attributes
from objects dynamically. To some extent, these findings support the
feasibility of using heuristics to extract class-like structures statically
from JavaScript code, as proposed in this paper.

inside/outside constructor

Gama et al10 identify 5 styles for implementing methods in
JavaScript:
functions using anony-
mous/nonanonymous functions and using prototypes. Their main goal
is to implement an automated approach to normalizing JavaScript code
to a single consistent object-oriented style. They claim that mixing
styles in the same code may hinder program comprehension and make
maintenance more difficult. The strategy proposed in this paper covers 
the 5 styles proposed by the authors. Additionally, we also detect
attributes and inheritance.

Feldthaus et al30,31 describe a methodology for implementing automated 
refactorings on a nearly complete subset of the JavaScript
language (ECMAScript 5). The authors specify and implement 3 refac-
torings: rename property, extract module, and encapsulate property.
The rename property is similar to the refactoring rename field for
typed languages. The main difference is that while fields in Java, for
example, are statically declared within class definitions, properties in
JavaScript are associated with dynamically-created objects and are
themselves dynamically-created after first write. The goal of the refactoring 
extract module is to use anonymous functions to make global
functions become local. These anonymous functions will then return
object literals with properties through which the previous global functions 
can be invoked. The encapsulate property refactoring can be used
to encapsulate state by making a field private and redirecting access
to that field via newly-introduced getter and setter methods. It targets
constructor functions that emulate classes in JavaScript. To determine
if a function works as a constructor, they look for functions that initialize 
an object when invoked, like those that are invoked with new or
Object.create().

Fard and Mesbah32 propose a set of 13 JavaScript code smells,
including generic smells (eg, long functions and dead code) and smells
specific to JavaScript (eg, creating closures in loops and accessing
this in closures). They also describe a tool, called JSNose, for detecting 
code smells on the basis of a combination of static and dynamic
analysis. Among the proposed patterns, only Refused Bequest is
directly related to class-emulation in JavaScript. In fact, this smell
was originally proposed to class-based languages,33,34 to refer to
subclasses that do not use or override many elements from their
superclasses. Interestingly, our strategy to detect classes opens the
possibility to detect other well-known class-based code smells in
JavaScript, like Feature Envy, Large Class, Shotgun Surgery, Divergent
Change, etc.

Nicolay et al35 present an abstract machine for a core JavaScript-like
language that tracks write side-effects in JavaScript functions to detect
their purity. A function is considered pure if it does not generate observable 
side effects. Because classes and methods, detected by our strategy,
 are functions in JavaScript, it is possible to extend the concept of
purity to such class-like structures to improve program understanding
and maintenance.

Nguyen et al36 use a static-analysis–based mining method to mine
JavaScript usage patterns in web applications. They introduce JSModel,
a graph representation for JavaScript code, and JSMiner, a tool that
mines interprocedural and data-oriented JavaScript usage patterns.
Although they do not consider class-like structures in their work, the
different strategies for class emulation can be considered usage patterns 
in JavaScript.

There is also a variety of tools and techniques for analyzing, improving,
 and understanding JavaScript code, including tools to prevent
security attacks,37-39 and to understand event-based interactions.40-43
CoffeeScript‡‡‡ is another language that aims to expose the “good
parts of JavaScript” by only changing the language's syntax.44,45 CoffeeScript 
compiles one-to-one into JavaScript code. As ECMAScript 6, the
language includes class-related keywords, like class, constructor,
extends, etc.

9

CONCLUSION

This paper provides a large-scale study on the usage of class-based
structures in JavaScript, a language that is used nowadays to implement
complex single-page applications for the Web. We propose a strategy to
statically detect class emulation in JavaScript and the JSCLASSFINDER
tool, which supports this strategy. We use JSCLASSFINDER on a corpus 
of 918 popular JavaScript applications, with different sizes and
from multiple domains, to describe the usage of class-like structures in

‡‡‡http://coffeescript.org

SILVA ET AL.

19 of 20

legacy JavaScript systems. We perform a field study with JavaScript
developers to evaluate the accuracy of our strategy and tool.

We summarize our findings as follows. First, there are essentially 4
types of JavaScript software, regarding the usage of classes: class-free
(systems that do not make any usage of classes), class-aware (systems
that use classes marginally), class-friendly (systems that make relevant
usage of classes), and class-oriented (systems that have the vast majority 
of their data structures implemented as classes). The systems in
these categories represent, respectively, 32%, 34%, 27%, and 7% of
the systems we studied. Precision, recall and F-score measures indicate 
that our tool is able to identify the classes, methods, and attributes
in JavaScript systems. The overall results range from 97% to 100% for
precision, from 70% to 89% for recall, and from 82% to 94% for F-score.
Second, we found that there is no significant relation between size
and class usage. Therefore, we cannot conclude that the larger the system,
 the greater the usage of classes, at least in proportional terms.
For this reason, we hypothesize that the background and experience of
the systems' developers have more impact on the decision to design a
system around classes, than its size.

Third, prototype-based inheritance is not popular in JavaScript.
We counted only 70 out of 918 systems (8%) using inheritance. We
hypothesize that there are 2 main reasons for this. First, even in
class-based languages there are strong positions against inheritance,
and a common recommendation is to “favor object composition over
class inheritance”.46,47 Second, prototype-based inheritance is more
complex than the usual implementation of inheritance available in
mainstream class-based object-oriented languages.

Fourth, classes in JavaScript have usually less than 28 attributes and
61 methods (90th percentile measures). It is also common to have
data-oriented classes, ie, classes with more attributes than methods. In
half of the systems, we have at least 39% of such classes.

Fifth, 58% of JavaScript developers answered our field study saying
they intend to use the ES6 new syntax for class emulation, but usually
only for new features and projects.

As future work, we plan to adapt our approach to be able to (1)
measure other class properties, like coupling, cohesion, and complexity;
 (2) extract class dependencies and other diagrams from source
code; (3) identify bad smells in JavaScript classes; (4) recommend best
object-oriented programming practices for JavaScript; (5) detect violations 
and deviations in the class-based architecture of JavaScript systems;
 and (6) support developers that intend to migrate their legacy
code to use ES6 classes.

All our data and toolset are publicly available at https://github.com/

aserg-ufmg/JSClassFinder.

ACKNOWLEDGMENTS

The authors would like to thank CNPq, CAPES, and FAPEMIG. This
research is partially supported by STICAmSud project 14STIC-02 and
FONDECYT1160575.

REFERENCES

1. Kienle HM. It's about time to take JavaScript (more) seriously. IEEE

Software. 2010;27(3):60–62.

Reliability Engineering (ISSRE): IEEE Computer Society, Hiroshima,
Japan; 2011:100–109.

3. Nederlof A, Mesbah A, van Deursen A. Software engineering for
the web: the state of the practice. 36th International Conference on
Software Engineering (ICSE), Companion Proceedings; Hyderabad, India;
2014:4–13.

4. Richards G, Lebresne S, Burg B, Vitek J. An analysis of the dynamic
behavior of JavaScript programs. Conference on Programming Language
Design and Implementation (PLDI); ACM, New York, USA; 2010:1–12.

5. European Association for Standardizing Information and Communication 
Systems (ECMA). ECMA-262: ECMAScript Language Specification.
 edition 5.1; 2011.

6. Borning AH. Classes versus prototypes in object-oriented languages.
ACM Fall Joint Computer Conference; IEEE Computer Society Press,
Dallas, Texas, USA; 1986:36–40.

7. Guha A, Saftoiu C, Krishnamurthi S. The essence of JavaScript. 24th
European Conference on Object-Oriented Programming (ECOOP); Springer
Berlin Heidelberg, Maribor, Slovenia; 2010:126–150.

8. European Association for Standardizing Information and Communication 
Systems (ECMA). ECMAScript Language Specification, 6th edition,
 Draft October, 2014.

9. Silva LH, Ramos M, Valente MT, Bergel A, Anquetil N. Does JavaScript
software embrace classes? 22nd IEEE International Conference on Software 
Analysis, Evolution, and Reengineering (SANER), IEEE, Montreal,
Canada; 2015:73–82.

10. Gama W, Alalfi MH, Cordy JR, Dean TR. Normalizing object-oriented
class styles in JavaScript. 14th IEEE International Symposium on
Web Systems Evolution (WSE), IEEE Computer Society, Trento, Italy;
2012:79–83.

11. Crockford D. JavaScript: The Good Parts: O'Reilly; 2008.
12. Flanagan D. Javascript: The Definitive Guide: O'Reilly; 2011.
13. Ungar D, Smith RB. SELF: The power of simplicity. 2nd Conference on
Object-Oriented Programming Systems, Languages and Applications (OOP-
SLA): ACM, Orlando, Florida, USA; 1987:227–242.

14. Borning AH. Classes versus prototypes in object-oriented languages.
Proceedings of 1986 ACM Fall Joint Computer Conference: IEEE Computer
Society Press, Dallas, Texas, USA; 1986:36–40.

15. Anderson C, Giannini P, Drossopoulou S. Towards type inference for
JavaScript. 19th European Conference on Object-Oriented Programming
(ECOOP); Springer-Verlag, Glasgow, UK; 2005:428–452.

16. Silva LH, Hovadick D, Valente MT, Bergel A, Anquetil N, Etien A.
JSClassFinder: A Tool to Detect Class-like Structures in JavaScript.
6th Brazilian Conference on Software: Theory and Practice (CBSOFT), Tools
Demonstration Track; CoRR, Belo Horizonte, Brazil; 2015:113–120.

17. Nierstrasz O, Ducasse S, Girba T. The story of moose: An agile reengineering 
environment. 10th European Software Engineering Conference
Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations 
of Software Engineering (ESEC/FSE-13), ESEC/FSE-13. New York,
NY, USA: ACM; 2005:1–10.

18. Fowler M. Uml Distilled: A Brief Guide to the Standard Object Modeling
Language. 3rd ed.: Addison-Wesley Longman Publishing Co., Inc.; 2003.
19. Ducasse S, Gîrba T, Kuhn A. Distribution map. 22nd IEEE International
Conference on Software Maintenance (ICSM); IEEE Computer Society,
Philadelphia, Pennsylvania, USA; 2006:203–212.

20. Chidamber SR, Kemerer CF. A metrics suite for object oriented design.

IEEE Trans Software Eng. 1994;20(6): 476–493.

21. Booch G, Maksimchuk R, Engle M, Young B, Conallen J, Houston K.
Object-Oriented Analysis and Design with Applications (3rd Edition): Addison 
Wesley Longman Publishing Co., Inc.; 2004.

22. Richards G, Hammer C, Burg B, Vitek J. The eval that men do:
A large-scale study of the use of eval in JavaScript applications.
25th European Conference on Object-Oriented Programming (ECOOP);
Springer-Verlag, Lancaster, UK; 2011;52–78.

2. Ocariza FS Jr., Pattabiraman K, Zorn B. JavaScript errors in the wild:
An empirical study. 22nd IEEE International Symposium on Software

23. Meawad F, Richards G, Morandat F, Vitek J. Eval begone!:
Semi-automated removal of eval from JavaScript programs. 27th

20 of 20

SILVA ET AL.

Conference on Object Oriented Programming Systems Languages and
Applications (OOPSLA); ACM, Tucson, Arizona, USA; 2012:607–620.

24. Terra R, Miranda LF, Valente MT, Bigonha RS. Qualitas.class Cor-
pus: A compiled version of the Qualitas Corpus. Software Eng Notes.
2013;38(5): 1–4.

25. Baxter G, Frean M, Noble J, Rickerby M, Smith H, Visser M, Melton H,
Tempero E. Understanding the Shape of Java Software. 21st Conference
on Object-Oriented Programming Systems, Languages, and Applications
(OOPSLA): ACM, Portland, Oregon, USA; 2006:397–412.

26. Louridas P, Spinellis D, Vlachos V. Power Laws in Software. ACM Trans

Software Eng Method. 2008;18: 1–26.

27. Wheeldon R, Counsell S. Power Law Distributions in Class Relationships.
 International Working Conference on Source Code Analysis and
Manipulation; IEEE, Amsterdam, Netherlands; 2003:45–54.

28. Oliveira P, Valente MT, Lima F. Extracting relative thresholds for source
code metrics. IEEE Conference on Software Maintenance, Reengineering 
and Reverse Engineering (CSMR-WCRE); IEEE, Antwerp, Belgium;
2014:254–263.

29. Wohlin C, Runeson P, Höst M, Ohlsson MC, Regnell B. Experimentation

in Software Engineering: Springer; 2012.

30. Feldthaus A, Millstein TD, Møller A, Schäfer M, Tip F. Refactoring 
towards the good parts of JavaScript. 26th Conference on
Object-Oriented Programming (OOPSLA), Companion Proceedings; ACM,
Portland, Oregon, USA; 2011:189–190.

31. Feldthaus A, Millstein TD, Møller A, Schafer M, Tip F. Tool-supported
refactoring for JavaScript. 26th Conference on Object-Oriented Programming,
 Systems, Languages, and Applications (OOPSLA); ACM, Portland,
Oregon, USA; 2011:119–138.

32. Fard AM, Mesbah A. JSNOSE: Detecting JavaScript code smells. 13th
IEEE International Working Conference on Source Code Analysis and Manipulation 
(SCAM); IEEE Computer Society, Eindhoven, The Netherlands;
2013:116–125.

33. Fowler M. Refactoring:

Improving the Design of Existing Code:

Addison-Wesley; 1999.

34. Lanza M, Marinescu R. Object-Oriented Metrics in Practice: Using
Software Metrics to Characterize, Evaluate, and Improve the Design of
Object-Oriented Systems: Springer; 2006.

35. Nicolay J, Noguera C, Roover CD, Meuter WD. Detecting function
purity in JavaScript. 15th IEEE International Working Conference on
Source Code Analysis and Manipulation (SCAM); IEEE Computer Society,
Bremen, Germany; 2015:101–110.

36. Nguyen HV, Nguyen HA, Nguyen AT, Nguyen TN. Mining interprocedural,
 data-oriented usage patterns in JavaScript web applications.
36th International Conference on Software Engineering (ICSE); ACM,
Hyderabad, India; 2014:791–802.

37. Vogt P, Nentwich F, Jovanovic N, Kirda E, Krügel C, Vigna G. Cross site
scripting prevention with dynamic data tainting and static analysis. Network 
and Distributed System Security Symposium (NDSS); The Internet
Society, San Diego, CA, USA; 2007; 1–12.

38. Guha A, Krishnamurthi S, Jim T. Using static analysis for Ajax intrusion
detection. 18th International Conference on World Wide Web (WWW);
ACM, Madrid, Spain; 2009:561–570.

39. Yu D, Chander A, Islam N, Serikov I. JavaScript instrumentation for
browser security. 34th Symposium on Principles of Programming Languages 
(POPL); ACM, Nice, France; 2007:237–249.

40. Alimadadi S, Sequeira S, Mesbah A, Pattabiraman K. Understanding
JavaScript event-based interactions. International Conference on Software 
Engineering (ICSE); ACM, Hyderabad, India; 2014:367–377.

41. Zaidman A, Matthijssen N, Storey M-AD, rie van D. Understanding
Ajax applications by connecting client and server-side execution traces.
Empirical Software Eng. 2013;18(2): 181–218.

42. Alimadadi S, Mesbah A, Pattabiraman K. Hybrid DOM-Sensitive
Change Impact Analysis for JavaScript. 29th European Conference
on Object-Oriented Programming (ECOOP 2015), vol. 37; Schloss
Dagstuhl–Leibniz-Zentrum fuer Informatik, Prague, Czech Republic;
2015:321–345.

43. Gallaba K, Mesbah A, Beschastnikh I. Don't call us, we'll call you: Characterizing 
callbacks in JavaScript. 9th ACM/IEEE International Symposium 
on Empirical Software Engineering and Measurement (ESEM): IEEE
Computer Society, Beijing, China; 2015:247–256.

44. Bates M. Programming in Coffeescript. 1st ed.: Addison-Wesley Professional;
 2012.

45. MacCaw A. The Little Book on Coffeescript: O'Reilly Media, Inc.; 2012.
46. Gamma E, Helm R, Johnson R, Vlissides JM. Design Patterns: Elements
of Reusable Object-Oriented Software: Addison-Wesley Professional;
1994.

47. Stefanov S. JavaScript Patterns: O'Reilly Media; 2010.

How to cite this article:
Silva LH, Valente MT, Bergel A,
Anquetil N, Etien A.
Identifying
in legacy
javascript code. J Softw Evol and Proc. 2017;29:e1864.
https://doi.org/10.1002/smr.1864

classes

