Engineering with Computers (2001) 17: 287–298
 2001 Springer-Verlag London Limited

Approximate Shape Quality Mesh Generation

B. Simpson1, N. Hitschfeld2,3 and M.-C. Rivara3
1Department of Computer Science, University of Waterloo, Waterloo, Ontario, Canada; 2Integrated Systems Laboratory,
ETH-Zu¨rich, Zu¨rich, Switzerland; 3Department of Computer Science, University of Chile, Chile

Abstract. We present two techniques for simplifying the
list processing required in standard iterative reﬁnement
approaches to shape quality mesh generation. The goal of
these techniques is to gain simplicity of programming,
efﬁciency in execution, and robustness of termination. ‘Shape
quality’ for a mesh generation method usually means that,
under suitable conditions, a mesh with all angles exceeding
a prescribed tolerance is generated. The methods introduced
in this paper are truncated versions of such methods. They
depend on the shape improvement properties of the terminaledge 
LEPP-Delaunay reﬁnement technique; we refer to them
as approximate shape quality methods. They are intended
for geometry-based preconditioning of coarse initial meshes
for subsequent reﬁnement to meet data representation needs.
One technique is an algorithm re-organization to avoid
maintaining a global list of triangles to be reﬁned. The reorganization 
uses a recursive triangle processing strategy.
Truncating the recursion depth results in an approximate
method. Based on this, we argue that the reﬁnement process
can be carried out using a static list of the triangles to be
reﬁned that can be identiﬁed in the initial mesh. Comparisons
of approximate to full shape quality meshes are provided.

Keywords. Quality triangulation; Mesh generation;
Pre-conditioning

1. Introduction

In general terms, (planar) quality mesh generation
(qmg) has come to mean generating a mesh for a
given domain in the plane, possibly including
internal features, which meets speciﬁed size and
triangle shape requirements. These two types of
requirements are quite different. The size requirement 
depends very strongly on the speciﬁcs of the
application for the target mesh. It is typically variCorrespondence 
and offprint requests to: B. Simpson, Department
of Computer Science, University of Waterloo, 200 Waterloo
Avenue W, Waterloo, Ontario N2L 3G1, Canada. E-mail:
rbsimpson얀uwaterloo.ca

able throughout the given domain and, if the requirement 
is stated as an upper bound on triangle size
measures is relatively easily met by reﬁnement
algorithms. The shape requirement is predominantly
motivated by the beneﬁts for most applications of
having triangles that are roughly equilateral (albeit
possibly in some non-Euclidean metric in the case
of anisotropic meshes [1]). These motivations are
connected to optimality properties and to computational 
robustness. Hence, the shape criterion has
typically been a global lower bound on the minimal
angle of each triangle, and it is not usually related
to the speciﬁcs of an application. It has not been
simple to ensure that reﬁnement methods meet this
criterion.

The study of how to meet a global shape criterion
has been undertaken particularly in computational
geometry [2–8]. We will refer to the problem of
reﬁning
a Constrained Delaunay Triangulation
(CDT) on a given Planar Straight Line Graph
(PSLG) to meet a minimum angle bound, while
respecting the edges of the PSLG as a shape quality
mesh generation problem. Algorithms that solve this
problem are reviewed below in section 2. Viewed
slightly differently, a histogram of shape quality for
mesh generated by these methods would show a
sharp cut-off at some prescribed minimum quality
parameter. One context for shape quality mesh generation 
problem is as an intermediate step in the task
of generating a mesh to serve data representation for
an application. In this context, shape quality is, in
effect a form of geometry based pre-conditioning
for the application driven mesh which is usually
much larger. As such, it may not be necessary to
have a mesh whose shape quality metric histogram
has an absolute cut-off at a prescribed minimum
quality parameter; but a mesh with a ‘good’ shape
quality histogram may be good enough.

Using this premise,

in this paper we discuss
methods that generate meshes that approach good

288

B. Simpson et al.

two main topics

quality but are simpler to implement, more efﬁcient
to execute, and have robust termination conditions.
The methods exploit the shape improvement properties 
of the terminal edge LEPP-Delaunay technique,
reviewed in Section 5, for selecting the vertex for
Delaunay insertion in the reﬁnement process. We
discuss
for developing such
methods. The more general one describes replacing
the iterative reﬁnement organization of conventional
qmg methods as discussed in Section 2 by a recursive 
one as discussed in Section 3. Central to this
reorganization is the identiﬁcation of small edges in
the input PSLG. It is then proposed to identify as
an approximate method the procedure formed by
truncating the recursion at a ﬁxed arbitrary, but
small, depth. We argue that, due to the shape
improvement properties of the reﬁnement method,
the largest gains in shape improvement occur at the
smaller levels of reﬁnement.

this top level,

The second technique involves simplifying the list
of triangles to be reﬁned at the top level of recursive
reﬁnement. At
the triangles to be
reﬁned are all identiﬁable with small edges in the
initial CDT of the PSLG, possibly with some preprocessing 
required to introduce some additional small
constrained edges. In Sections 5 and 6, we show
that by identifying these triangles with their small
constrained edges, and relaxing the application of
the small angle criterion appropriately, we can obtain
a simple static list representation of the triangles
requiring reﬁnement. The approximate method then
makes a single scan down this
list, applying
recursive reﬁnement to each triangle. A comparison
of meshes generated by the approximate and full
iterative versions of terminal-edge LEPP Delaunay
reﬁnement are presented in Section 6.

2. Iterative Reﬁnement for Shape
Quality Mesh Generation

We formulate the shape qmg problem and review
some of the features of Delaunay reﬁnement algorithms 
for it. The region to be meshed is described
by a PSLG, P [2]. This is presented to algorithms
via the constrained Delaunay triangulation of P,
which we denote ␶(0) ([9, p. 85, 10]). A reﬁnement
of ␶(0) is a mesh, ␶, on the same region as ␶(0) such
that the edges of ␶ cover those of P. An edge of
␶ that lies on an edge of P is a boundary edge. It
may be an internal boundary edge (two neighboring
triangles in ␶,) or an external one. A Delaunay
reﬁnement of ␶(0) is a reﬁnement that is a constrained
Delaunay triangulation of its boundary edges. By

the term ‘shape quality mesh for angle tolerance
␣tol’, then, we will mean a Delaunay reﬁnement of
␶(0), ␶(␣tol), such that the smallest angle in ␶(␣tol) at
a vertex that is not incident on two boundary edges
is not less than ␣tol.
We will refer to:

a bad triangle;

쐌 a triangle with its smallest angle ⬍ than ␣tol as
쐌 a triangle with exactly one angle ⬍ than ␣tol as
쐌 a triangle with two angles ⬍ than ␣tol as a 2a 
1-small-angle triangle;

small-angle triangle.

The iterative Delaunay reﬁnement approach to
shape qmg involves the repeated use of the Delaunay
insertion operation to remove each bad triangle t in
the current mesh, ␶. This operation has two major
subtasks: selecting a point, P to be inserted as a
new vertex in ␶ and updating the mesh to include
techniques for improving
P. The use of powerful
the mesh in these two subtasks is crucial
to the
success of this approach both theoretically and practically.


The second task is the familiar Delaunay vertex
insertion to update the old mesh, ␶,
to a new
mesh, ␶⬘, which is a Delaunay reﬁnement of ␶.
Algorithmically, the update can be accomplished by
a simple insertion of P followed by a series of edge
swaps [5], or equivalently, as the Delaunay kernel
operation [9], which involves the explicit removal
of the cavity of P in ␶, denoted Cav(P)1, and the
insertion of the ball of P in ␶⬘, denoted B(P)2. This
can be expressed by the formula (the Delaunay
kernal [11], p. 55]):

␶⬘ ⫽ ␶ ⫺ Cav(P) ⫹ B(P)

(1)

This update might be implemented by modifying
the memory space of a deleted bad triangle to
represent a newly added one. Whatever the implementation 
is, it will reﬂect these set operations.
We use such set notation and operations to abstract
representation dependent details in our following
discussion.

An iterative Delaunay reﬁnement algorithm computes 
a sequence of Delaunay reﬁnements, ␶(n), n ⫽
0, 1, 2, . . . and it maintains a representation of the
set, S, of bad triangles in ␶(n). So, in addition to
updating ␶ the Delaunay reﬁnement algorithm must
update S from being the set of bad triangles in ␶
to S⬘, the set of bad triangles in ␶⬘. We introduce

1 Cav(P) is the set of triangles in ␶ with P in their circumcircle.
2 B(P) is the set of triangles in ␶⬘ incident on P.

Approximate Shape Quality Mesh Generation

289

subsets Sdel ⫽ S 傽 Cav(P) and Sadd ⫽ S⬘ 傽 B(P),
and express this update as
S⬘ ⫽ S ⫺ Sdel ⫹ Sadd

(2)

Iterative Delaunay reﬁnement methods for shape
qmg typically take the form of the following Qual-
ity-Mesh-Generation procedure. It calls a procedure
Delaunay-Insertion, which takes as input a triangle
t to be reﬁned in mesh ␶ and the minimum angle
tolerance. It performs the two tasks of Delaunay
insertion referred to above, and returns the two sets
Sadd and Sdel as well as updating ␶:
Quality-Mesh-Generation (P, ␣tol)
Input: a PSLG P (deﬁned by a set of vertices
and edges) and a tolerance parameter ␣tol (␣tol
ⱕ 30°)
initialize ␶ ⫽ ␶(0)
initialize S ⫽ {t 苸 ␶ 兩 t is a bad triangle其

for t in S do

(Sadd,Sdel) ⫽ Delaunay-Insertion (t, ␶,␣tol)
S ⫽ S ⫺ Sdel ⫹ Sadd
end for

An algorithm based on this outline would have
to specify:
쐌 some data structure for the set S. This would be
a dynamic data structure supporting insertions and
deletions as per the set update operation (2);

쐌 the order of access to the elements of S for the

for loop.

The approximate qmg methods that we describe
below permit implementations which can use a small
array of size computable from the initial CDT, ␶(0).
This array can be processed in a sorted order with
no modiﬁcations required of it during reﬁnement.

Chew [3] laid the theoretical basis for Delaunay
reﬁnement based on circumcircle insertion. Quality
meshes are assured with angles between 30° and
120° for some limits on the angles present in the
initial CDT, and termination is assured by a lower
limit on the sizes of triangle in the mesh. A comprehensive 
treatment of an iterative form of the shape
quality algorithm for this approach was presented
by Ruppert [7], as well as the variable size aspect
of the algorithm. Termination is rigorously established 
for ␣tol ⬍ 20° under restrictions on the boundary 
edge angles. It is observed that termination is
to be expected for a wider range of ␣tol, and preprocessing 
to handle difﬁcult boundary conﬁgurations
is discussed. This algorithm development stream
culminated in the implementation of Triangle by
Shewchuk [8]. This paper includes a discussion of

the list structures used to represent
the set S of
bad triangles, and a discussion of the difﬁculty in
developing robust heuristics for treatment of edges
in the initial ␶(0) that meet at small angles.

It has

[4,12,13].

The Longest Edge Propagation Path (LEPP) technique 
for identifying insertion points for reﬁnement
was initially adapted to the quality mesh generation
problem using Delaunay insertion by Rivara and
coauthors
subsequently been
developed to the form presented as the terminaledge 
Delaunay algorithm [5,14]. The terminal-edge
LEPP-Delaunay algorithms are guaranteed to produce 
quality meshes for ␣tol up to 30° [14], with
an adequate preprocessing of infrequent boundary
related conﬁgurations which appear in the initial
CDT. In Section 5, we discuss approximation modiﬁcations 
of the terminal-edge LEPP(t) technique.

3. Approximate Shape Quality Mesh
Generation

Mesh generation by reﬁnement generally proceeds
from a very coarse initial triangulation of the domain
to be meshed (e.g. its CDT), to a large mesh whose
triangle sizes and shapes are computed to control
the error in some data representation. The initial
mesh is essentially a data structure for the geometry
of the region. The shape quality mesh generation
task we have just described increases the mesh size
somewhat to improve the triangle shape solely on
the basis of the geometry. It in effect preconditions
the mesh for the task of generating a discretization
suitable to an application. This geometrically based
shape improvement may be interleaved with size
distribution motivated reﬁnement, or carried out as
a separate preprocessing step. But in any case, the
effect is an intermediate one in the total process of
producing a ﬁnal mesh. It seems appropriate, then, to
look for simpler and more efﬁcient preconditioning
methods, which we are referring to as approximate
shape quality mesh generation algorithms.

We turn to formalizing the requirements of

approximate qmg.

Deﬁnition 1. A small edge detail (sed) of the input
PSLG P,
is a directed edge, e→, of
its CDT, ␶(0),
with a 1-small-angle triangle, tneigh, on its right and
the small angle of tneigh opposite e→.

Note that an undirected,

the
augmented input PSLG can be a sed for one of its
directions, and not for the other; alternatively it
could be a sed for both directions. We assume that

internal edge of

290

B. Simpson et al.

an arbitrary input CDT has been ‘preprocessed’, i.e.
extended so that it:

(a)
(b)

contains only 1-small-angle triangles,
the shortest edge of every 1-small-angle triangle
is a constrained edge, i.e. belongs to P.

For the theoretical discussion, this means that the
CDT of a general PSLG must be preprocessed to
reﬁne all its 2-small-angle triangles [15], and any
new edges opposite small angles added to P. Some
comments on our experience with implementing
such preprocessing are given in Section 6. See that
‘small’ for an edge in this context means relative
to some length of its immediate neighbors in ␶(0).
It follows trivially from the deﬁnition that:

Lemma 1. A sed is the smallest edge of its deﬁning
neighboring triangle.

A sed is removed by a reﬁnement of ␶ that results
in a modiﬁcation of its neighboring triangle so that
it ceased to be a 1-small-angle triangle.

least

We note that, at

in principle, a boundary
edge that is a sed in one or both of its directions
could be split by a reﬁnement
that created two
smaller seds. This would introduce algorithmic complications,
 as well as the undesirable effect of making 
seds even smaller. We discuss in Section 5 how
to avoid this situation.

Delaunay-Insertion-R.

Our approach to approximate quality mesh generation 
uses a re-organization of the Quality-MeshGeneration 
outline of Section 2 to incorporate a
recursive form of Delaunay insertion that we will
Delaunaydesignate

Insertion-R uses a general procedure Select-Inser-
tion-Point (t, ␶), which is an abstraction for the
method of reﬁnement. It
includes the semi-global
methods based on LEPP and circumcircle insertion
referred to above. Select-Insertion-Point takes as
input a triangle, t, to be reﬁned that belongs to the
mesh, ␶. It returns the new vertex. P*, to be inserted
in ␶ and a triangle, t*, used to locate P* in ␶ for
the Delaunay insertion.
Its input parameters are
unchanged.

calls

Delaunay-Insertion-R also

procedure
UpDate-Mesh (P,t,␶,Scum
del, ␣tol) to perform a Delaunay 
insertion (1), and keep track of the changes to
the set S of bad triangles in ␶. The input to UpDateMesh 
is:
쐌 a vertex, P, not in mesh ␶,
쐌 a triangle t to locate P in ␶,
쐌 a set, Scum
쐌 the small angle tolerance, ␣tol.

del, of bad triangles no longer in ␶,

As its output, UpDate-Mesh returns the set Sadd,
as described in Eq. (2). It modiﬁes ␶ as mentioned,
del by adding the set of bad triangles
and modiﬁes Scum
removed from ␶ by the update. P, t and ␣tol are
unchanged.

The inputs t, ␶, and ␣tol for Delaunay-InsertionR 
are as previously described; it also takes a set of
del , not in ␶. This set is updated by
bad triangles, Scum
UpDate-Mesh to accumulate the triangles removed
during a call to Delaunay-Insertion-R. When this
del and ␶. The
procedure returns, it has updated Scum
is a reminder that this set
superscript cum on Scum
del
accumulates bad triangles over all recursive subcalls
by the parent procedure Delaunay-Insertion-R.

Note that the loop for removing t from the input
mesh ␶ has been incorporated into Delaunay-
Insertion-R, so, unlike the Delaunay-Insertion of
Section 2, which inserts one vertex per call, it can
insert more than one vertex even without the recursive 
quality enhancement loop being executed.

Delaunay-Insertion-R (t, Scum

del , ␶, ␣tol)

Note: no Sadd in parameter list其

while t is not in Scum

del do

(P*, t*) ⫽ Select-Insertion-Point(t, ␶)
Sadd ⫽ UpDate-Mesh (P*, t*, ␶, Scum

del , ␣tol)

{Sadd is a temporary set local to Delaunay-Insertion-R其

for s in Sadd ⫺ Scum
Delaunay-Insertion-R(Scum

del do

del ,␣)

{refer to this as the recursive quality enhancement其

Sadd ⫽ Sadd ⫺ {s其
end for
end while

return

Theorem 1. On a return from Delaunay-InsertionR,
 triangle t has been removed from ␶ and no new
bad triangles have been added to ␶.

Proof by induction. There are two looping structures 
that must terminate if Delaunay-Insertion-R
is to return. The recursion occurs in the inner for
loop which we have called the recursive enhancement 
process. The import of the theorem is then,
that if the inner for loop terminates all its instances,
and the outer while terminates, then the procedure
returns as stated. The recursion ends only if all calls
to UpDate-Mesh do not return any bad triangles,
(Sadd ⫽ NULL), during the execution of the outer
while.
In this case, a return from Delaunay-
Insertion-R implies the outer while exits with
t 苸 Scum

del , i.e. ␶ is as stated in the theorem.

We now assume that the theorem is true for the
recursive quality enhancement calls. If the for loop

Approximate Shape Quality Mesh Generation

291

terminates, then particular at each pass through the
loop Delaunay-Insertion-R returns. By the induction 
assumption, at the bottom of the for loop the
current
triangle s has been remove from and no
new bad ones added to it, and Sadd is reduced in
size. The for loop terminates, having removed all
the bad triangles created by the Delaunay insertion
of P* into ␶. Since we are assuming that Delaunay-
Insertion-R, returns, we must have t 苸 Scum
del , and
hence ␶ satisﬁes the statement of the theorem.

This completes the proof, but we also note that
the outer loop, the while t remains a bad triangle
loop, has been shown to terminate in Rivara and
Hitschfeld [5], assuming the inner for loop always
terminates.

The modiﬁed form of Quality-Mesh-Generation

then looks like this:
Quality-Mesh-Generation-R (P, ␣tol)
Input: a PSLG, P (deﬁned by a set of vertices
and edges) and a tolerance parameter ␣tol
Construct ␶ the CDT of P,
cessing
S ⫽ {t 苸 ␶ 兩 t is a bad triangle其

including preprofor 
t in S do
del ⫽ ␾;
Scum
Delaunay-Insertion-R(␶,t,Scum
Scum
del
end for

del ,␣tol) S ⫽ S ⫺

The maintenance of set S in this top level module
is simpliﬁed, since no additions to S take place at
this level as indicated by Theorem 1. We note
that this organization for Quality-Mesh-Generation
partially speciﬁes the order of access to the bad
triangle set, S.

Theorem 2. If Quality-Mesh-Generation-R terminates,
 then the resulting mesh meets the shape quality 
criterion.

Clearly,

the

generation

termination

of Quality-Mesh-
Generation-R is tied to the termination of Quality-
Mesh-Generation; it is only to be expected under
the restrictions on ␣tol and the angles present in the
initial mesh, ␶(0). We can get an approximate quality
mesh
the
recursion at some depth. The intuitive justiﬁcation
for
the recursive quality
enhancement is that for a good choice of insertion
point, and Delaunay insertion,
the quality of the
new triangles should be improving with each level
of recursion. Evidently,

limiting the depth of

algorithm by

truncating

Theorem 3. A truncated version of Quality-Mesh-
Generation-R terminates, for any ␣tol.

The price of deﬁnitive termination is, of course, that
the result of Theorem 2 cannot be expected to
extend to a truncated version of Quality-Mesh-
Generation-R. In fact, while we expect that a truncated 
version of Quality-Mesh-Generation-R would
produce a good triangle as the the neighbor of every
sed of the initial CDT, ␶(0),
this does not seem
proveable in a direct way, if at all.

For simplifying implementations, an important
feature of Quality-Mesh-Generation-R is that no
additions to S take place during the processing of
triangles in S at the top level of recursion. So, at
the bad triangles to be processed
this level, all
are known from the initial
(preprocessed) CDT.
Moreover, each bad triangle can be identiﬁed with
a sed, which lies on a constrained edge of the
CDT. The implications of this for simplifying an
implementation are described below in Section 6.

We

intend the

introduction of Delaunay-
Insertion-R to be seen as primarily a conceptual
organization rather than a template for a recursive
implementation. Tests with terminal edge LEPPDelaunay 
base reﬁnement (described in the next
section and in Section 6) indicate that signiﬁcant
shape improvement is already usually achieved with
one level of recursion. So an efﬁcient implementation 
would be to simply unroll the recursion for
one level, rather that
implementing recursive procedures,
 literally.

4. Comparing these Methods: An
Example

To demonstrate these ideas, we present some
meshes generated for
shaped domain
distributed with the Triangle quality mesh generation 
program [8]. Figure 1 shows the initial CDT

the ‘A’

Fig. 1. Initial mesh.

292

B. Simpson et al.

Fig. 2. Iterative reﬁnement (no recursion).

Fig. 3. Approximate shape quality: one recursion level.

for this domain; and Fig. 2 shows a shape quality
mesh generated by iterative reﬁnements using the
terminal edge LEPP Delaunay method (see Section 
5.) The angle tolerance is ␣tol ⫽ 30° for
the meshes shown here. Figure 3 and 4 show the
approximate shape quality meshes generated by
Quality-Mesh-Generation-R truncated at 1 and 2
levels of recursion, respectively.

The iterative reﬁnement mesh is generated with
the set of bad triangles, S, ordered largest ﬁrst. We
note that
the order imposed on the processing of
bad triangles by the recursive organization is not
largest ﬁrst. This is likely why there are more
triangles in the meshes generated by the truncated
recursive methods.

5. Simplifying the Use of the
Terminal-edge LEPP-Delaunay
Method

In the case that LEPP(t)

To present a further simpliﬁcation, we ﬁrst present
some speciﬁcs of the terminal-edge LEPP-Delaunay
algorithm [5,14], in the approximate quality mesh
generation framework just presented. For any bad
quality triangle t, the longest edge propagation path
of t, LEPP (t), is found as the ﬁnite sequence of
increasing neighbor triangles, LEPP(t)⫽{tk,k ⫽ 1,
m其, where tj is the neighbor of tj⫺1 by the longest
edge of tj⫺1 for j ⫽ 2, m and t1 ⫽ t, and the
associated terminal-edge is the common longest edge
l of both terminal triangles tm⫺1 and tm if this edge
exists.
is an interior
sequence of triangles (without involving constrained
edges), the midpoint of the terminal-edge is selected
for point
insertion. Some boundary related edge
point insertions must be also considered in the case
where LEPP(t) includes constrained edges or vertices.
 Thus, the terminal-edge Delaunay algorithm can
be described as the following Select-Insertion-Point
procedure. It calls a procedure named Risky-Vertex-
Boundary-Terminal-Triangle, which returns true
or false depending on a boundary related conﬁguration 
of terminal triangles of the LEPP (see elsewhere 
[5,14] for details).

(P*,t*) ⫽ Select-Insertion-Point(t,␶)
Compute the sequence, {tk, k ⫽ 1, m其, of triangles

in LEPP(t)

boundary

for k ⫽ 1 to m; accept the ﬁrst instance of do
case ⫽ 1 ⇔ tk has a longest edge on the
case ⫽ 2 ⇔ (not case ⫽1) and largest angle (tk)
ⱕ 120° and second longest edge on the boundary
case ⫽ 3 ⇔ (not case ⫽ 1,2) and k ⫽ m⫺1 or
m and Risky-Vertex-Boundary-Terminal-Triangle (tk)
case ⫽ 4 ⇔ (not case ⫽ 1,2,3) and k ⫽ m
i.e. tm⫺1, tm are a pair of terminal triangles sharing
a terminal-edge
end for

Select insertion vertex as:

Switch (case):
case ⫽ 1: P* ⫽ midpoint of longest edge of t* ⫽
tk – boundary insertion
case ⫽ 2: P* ⫽ midpoint of second longest edge
of of t* ⫽ tk – boundary insertion
case ⫽ 3: P* ⫽ midpoint of second longest edge
of of t* ⫽ tk – internal insertion

Fig. 4. Approximate shape quality: two recursion level.

Approximate Shape Quality Mesh Generation

293

case ⫽ 4: P* ⫽ midpoint of longest edge of t* ⫽
tm – internal insertion
end Switch

1. Since this procedure always selects the longest,
or second longest, edge of a triangle, and a sed
is necessarily the shortest edge of its deﬁning
triangle, we have the following:

2. Case 3,

Theorem 4. Approximate quality mesh generation 
based on Select-Insertion-Point never
selects a sed for the directed edge to be reﬁned.
in which Risky-Vertex-Boundary-
Terminal-Triangle is invoked, is required in the
terminal-edge method to ensure termination of
the iterative reﬁnement algorithm in a case that
in fractal reﬁnement and
otherwise can result
non-convergence. However,
if an approximate
method is designed by truncating Delaunay-
Insertion-R,
then the method is guaranteed to
converge. In this case, the simpliﬁcation of dropping 
case 3 is possible.

3. The criterion of case 2 that the largest angle (tk)
ⱕ 120° is not essential. It is included because it
is known [14], that triangles with angles in excess
of 120° are modiﬁed by the terminal edge Delaunay 
insertion method automatically.

We now look at a simpliﬁcation that can be made
in the top level of Quality-Mesh-Generation-R. If
we could be sure that an edge which is a sed in
one, or both, of its directions would not be selected
for
selection,
then the maintenance of
the set of current bad
triangles), S, at the top level of the recusion would
be substantially simpliﬁed. Unfortunately, this is not
guaranteed by Theorem 4.

splitting by Select-Insertion-Point

Figure 5 shows how, in general, processing the
deﬁning neighbour of one sed can lead to bisection
another. It shows a triangle, t1, that deﬁnes a sed

on edge AB. LEPP(t1) leads to triangle ta, which is
well shaped and has second longest edge BC which
is a constrained edge, i.e. an internal boundary edge.
The neighbouring triangle, tb, deﬁnes CB as a sed.
But case 2 of Select-Insertion-Point requires the
bisection of BC.

We can, however, reduce the likelihood of the
processing of one sed in S leading to the splitting
of another by processing S on a largest deﬁning
triangle ﬁrst basis. For processing triangle t1, of
the shortest edge that can
longest edge lmax (t1),
be chosen for bisection has length greater
than
lmax (t1)/2. This is because:

1. the sizes of

longest edges in the sequence

LEPP (t1) are increasing;

2. Select-Insertion-Point can select either the longest,
 or second longest edge for bisection.

We can see qualitatively that if in Fig. 5 the longest
edge of tb were signiﬁcantly shorter than lmax (t1),
then edge CB could not be the second longest edge
of a triangle in LEPP (t1). This leads us to the
common idea to access S by a largest deﬁning
triangle ﬁrst ordering.

To be more quantitative about this, we need to
develop a limit on the maximum size of a sed in
terms of the longest edge of its deﬁning triangle and
the angle tolerance, ␣tol. This we do in Theorem 5:

length lmax. Let

Theorem 5. Let t be a 1-small-angled triangle with
its shortest edge
longest edge of
have length lmin and be opposite angle ␪min. Then
lmin ⭐ lmax/cos(␣tol) ⫹ cotan (␪min)sin(␣tol))
1.
2. Let f* be the (smallest positive) solution of
cos(␣tol) ⫹ cotan (f*␣tol)sin(␣tol) ⫽ 2
(4)
and let ␴(␣tol) ⫽ sin(␣tol)/(2 ⫺ cos(␣tol)). Then f*
depends on ␣tol according to
f*(␣tol) ⫽ arctan*␴(␣tol))/␣tol

(3)

⬇ 1/(1 ⫹ ␣2

tol/2)

(5)

3. If ␪min ⱕ f* (␣tol)␣tol then

lmin ⱕ lmax/2

(6)

Proof (Part 1). Let the intermediate and maximal
angles of t be ␪int and ␪max, respectively, and let
lmax be the length of the longest edge. Then ␪int ⱖ
␣tol, and

␪max ⫽ ␲ ⫺ (␪int ⫹ ␪min) ⱖ ␲ ⫺ (␣tol
⫹ ␪min)

(7)

Fig. 5. Example: sed splitting.

The sine law for triangles and Eq. (7) indicate that

294

But

lmin ⫽ (sin(␪min)/sin(␪max))lmax

ⱕ (sin(␪min)/sin(␪min ⫹ ␣tol))lmax

sin(␪min ⫹ ␣tol)/sin(␪min)

(8)

(9)

(10)

⫽ [sin(␪min)cos(␣tol) ⫹ cos(␪min)sin(␣tol))]/sin(␪min)
from which Eq. (3) follows.

Proof (Part 2). Let the vertices of t be labeled ABC,
with AB being the longest edge, of length lmax, and
BC the shortest edge, of length lmin. Figure 6 shows
the edge AB of t
lying along the positive x-axis
in longest edge coordinates [1].) This ﬁgure
(i.e.
shows as dashed lines the region in which C can
lie if t is a 1-small-angle triangle.

The point Y is located at x ⫽ lmax/2 such that
angle YAB ⫽ ␣tol. Since the smallest angle, ␪min,
is at A and is less than ␣tol, C must lie below AY.
The angle ABY is also equal to ␣tol. Since t has
only one small angle, C must lie above BY. The
dashed circular arc through B is part of the circle
of radius, lmax centered on A. Since AC is shorter
than lmax, C must lie inside this circle. So C must
lie in the sector XYB.

The dotted circle of radius centered on B belongs
to the circle of radius lmax/2; evidently, lmin ⬍ lmax/2
if C lies inside this circle. However, the diagram
shows a small shaded region in which C can lie
and not be inside this circle. The bottom right corner
of
this shaded region is denoted Z. We deﬁne
f* (␣tol) by

f*(␣tol)␣tol ⫽ angle ZAB

(11)
If ␪min ⬍ f*(␣tol)␣tol, then C lies inside the dotted
circle, which establishes Eq. (6). To establish Eq.
(4), see that

兩B ⫺ Z兩 ⫽ lmax/2

⫽ lmaxsin(f*(␣tol)␣tol)/sin(␪max)

(12)

If we replace ␪min in Eq. (10) by f* (␣tol)␣tol, we
get (4).

Fig. 6. Geometry of lmin bound (3).

B. Simpson et al.

The implication of Theorem 5 for the largest ﬁrst
ordering of S for an approx qmg method using
LEPP-Delaunay selection is derived from Theorem
6.

Theorem 6. Let t be the triangle deﬁning the largest
sed in S. Select-Insertion-Point can only select P
on an edge that has a sed associated with one of
its directions if

1. It

terminates

Point, and

in case 2 of Select-Insertion2.
 This edge is an internal boundary edge, and, for

one of its neighbours

␪min(t) ⬎ f*(␣tol)␣tol

(13)

Proof. Select-Insertion-Point will terminate with a
triangle t* and point P that is the midpoint of one
of its edges. Let us call this edge the insertion edge
and let e→(t*) be its directed edge on which t* is its
neighbor. In cases 1, 3, and 4. Select-Insertion
Point either selects an internal edge of or a boundary 
edge of length ⫽ lmax (t*) ⱖ lmax (t). In any
case, the insertion edge cannot be associated with
a sed.

Assume that the selection process terminates in
the insertion edge is an internal
case 2, and that
boundary edge. Let t⬘ be the triangle neighboring
on this edge with the opposite direction, i.e. ⫺e→(t*)
⫽ e→(t⬘). Then

lmin(t⬘) ⬎ lmax(t*)/2 ⱖ lmax(t)/2

(14)
By Lemma 1, e→(t*) cannot be a sed. Let us assume
that t⬘ is a 1-small-angle triangle, so that e→(t⬘) is a
sed. Unless ␪min (t⬘) ⬎ f* ␣tol,

lmin(t⬘) ⱕ lmax(t⬘)/2 ⱕ lmax(t)/2

(15)
so lmin (t⬘) cannot be processed as a result of LEPPDelaunay 
reﬁnement of t.

We would like to have the simplicity of an
approximate qmg method which does not split existing 
seds in S. Theorem 6 shows that
the approx
qmg method with LEPP-Delaunay point selection
can split seds, but only under speciﬁc circumstances
that are unlikely to be common. Note that
the
approximation, f* (␣tol) ⬇ 1/(1 ⫹ ␣2
tol/2) and (13)
show that for a bad triangle t to meet these conditions,
 it must be very close to meeting the angle
criterion, at least for small ␣tol. In fact, for ␣tol ⫽
30° ⫽ ␲/6 radians, 1/(1 ⫹ ␣2
tol)/2 ⫽ 0.88, while
the exact value of f* (␣tol) is 0.80. So the simplest
way to gain this simplicity would seem to be to
extend the approximate nature of the method by

Approximate Shape Quality Mesh Generation

295

removing the sed that would be bisected from S
(but still bisect it as a boundary edge), i.e. referring
to Fig. 5, to make tb an acceptable triangle of the
approximate quality mesh, in this case. This has the
effect of possibly allowing a triangle that does not
meet the angle tolerance as a neighbor of a boundary
edge, in some evidently rare circumstances.

6. Implementation and Some
Comparisons

We present a comparison between meshes generated
by a standard iterative quality mesh generation program 
organization and those generated by an
approximate shape quality mesh generation program
based on truncated recursion (Section 3), and a sed
based list (Section 5). Both programs use the same
vertex selection technique, (terminal-edge LEPP) and
use a CDT Delaunay insertion mesh update. The
angle tolerance used in all cases is angTol ⫽ 30°.
Consequently, the comparison differences are due to
the simpliﬁed list processing carried out
in the
approximate shape qmg program, which we detail
below. The iterative implementation is implemented
as outlined in Quality-Mesh-Generation of Section
2. It uses a dynamic list for the bad triangle set
which it repeatedly scans using a heuristic to select
the larger triangles ﬁrst.

In the sed-based recursive implementation,

triangles 
are reﬁned by a version of recursive Delaunay
reﬁnement as outlined in Delaunay-Insertion-R of
Section 3, truncated at a preset maximum recursion
level. This level is set to one in most of our tests.
The program does not keep a list of bad triangles
directly. Instead, prior to commencing the reﬁnement
process, it builds an array of seds present in the
initial
(preprocessed) mesh, sorted by decreasing
length. We will refer to it as the sed list. The
program carries out a single scan of the sed list,
processing the (current) neighbouring triangle of
each sed by Delaunay-Insertion-R.

The point of listing seds instead of bad triangles
is that
the program can act on a static list. The
Delaunay insertions that occur when one bad triangle
is being processed typically modify other bad triangles.
 In terms of the set, S, of bad triangles, a
modiﬁcation of a bad triangle is its deletion from
the set and, possibly, the addition of another; this
is what necessitates dynamic list representations for
S. Because seds are constrained edges of the CDT
of the mesh, they are not modiﬁed by the Delaunay
insertions. Moreover,
the arguments of Section 5
show that a sed is not selected for bisection in the

In the set

for the reﬁnement of an earlier triangle.

reﬁnement process of a triangle connected to another
sed of greater size. Although the neighbouring triangle 
of a sed may be modiﬁed during the processing 
of a sed earlier in the sed list, the sed itself
is unchanged. Since triangle modiﬁcations by the
terminal edge LEPP-Delaunay insertion are shape
improving,
the new neighbour will have a bigger
smallest angle. In fact, it may no longer be a bad
triangle by the time the associated sed is reached
in the sed list scan.
terminology of
Quality-Mesh-Generation-R of Section 3, the bad
triangle that originally deﬁned the sed appears in
Scum
del
Recall that before building the representation of
the bad triangle list in Quality-Mesh-GenerationR,
 we indicated that the initial ␶(0) should be preprocessed 
to ensure that each bad triangle is associated
with some sed. We found that our results for the
approximate qmg technique were sensitive to the
choice of 2-small-angle triangles to preprocess. If
one simply preprocesses all of them in the initial
mesh, then for some of the test cases, the method
generated an unnecessarily large number of triangles.
We now restrict the preprocessing to triangles with
maximum angle ⬍ 120°. The terminal edge LEPPDelaunay 
insertion process automatically modiﬁes
triangles with larger maximum angles; see Rivara
and Hitschfeld [5]. These other 2-small-angle triangles 
are treated as one-small-angle triangles using
the sed opposite the smallest angle.

The ﬁgures for each case presented come in vertically 
displayed pairs (with one exception). One ﬁgure 
of the pair displays the mesh generated by
either the full iterative shape qmg method or by the
approximate shape qmg method. The other ﬁgure of
the pair shows a histogram of the common shape
quality metric, the ratio of the longest edge to the
circumradius, normalized to 1 for an equilateral
triangle. This metric is denoted QK in George and
Borouchaki [6].

Figure 7 shows

the mesh generated by the
interative shape qmg program for a ‘fat comma’

Fig. 7. Iterative Reﬁnement (no recursion) cursion.

296

B. Simpson et al.

Fig. 8. One level of recursion.

Fig. 11. Iterative reﬁnement.

Fig. 9. Iterative Reﬁnement shape quality.

shape. Figure 9 shows the histogram of associated
triangle shape metrics. The single poorly shaped
triangle in evidence in the histogram is located at
the tip of the tail of the comma. The histogram of
the mesh generated by the approximate
Qk
method, shown in Fig. 10, is generally quite good,
but the distribution shows a tail of ﬁve triangles in
the 0.15 to 0.4 range

for

The next

test case has a simple geometry that
belies its difﬁculty as a test for shape quality mesh
generation. The initial PSLG has a square external
boundary and a pair of isolated line segments that
meet in the center at a small angle, and are signiﬁcantly 
different in length. They can be seen as the
heavier
line segments in the center of Fig. 11.
This conﬁguration was used by Shewchuk [8] in a
discussion of the difﬁculty of ensuring termination
of algorithms for isolating small angles of the PSLG
as part of iterative shape qmg algorithms.

Figure 11 shows the mesh generated by the iterative 
qmg program, and Fig. 13 shows the corresponding 
histogram of shape quality triangle metrics. The
program used a reasonably successful heuristic to

Fig. 10. Approx shape QMG shape quality.

Fig. 12. Two levels of recursion.

Fig. 13. Triangle quality histogram.

handle the small internal angles of the r(0). Figures
12 and 14 shows the corresponding plots for the
approximate shape qmg program with two levels of
recursion. This is our most challenging test for the
approximation technique;
there are 10 triangles
below the 0.4 quality cut-off in the interative distribution 
and this is an improvement over the mesh
generated by one level of recursion. There are two
test cases that we have studied in which there is
signiﬁcant additional
incurred by a
second level of recursion:
the A shape shown in
Section 3 is the other one. Notice that even with two
levels of reﬁnement, substantially fewer triangles are
generated by the approximate qmg method in this
case. For iterative reﬁnement, heuristics are required
to prevent
the base method from producing too
many triangles in this case, or even not terminating.
It appears that
the approximate method has the
opposite difﬁculty; without some special treatment
of this conﬁguration, it terminates prematurely.

reﬁnement

Approximate Shape Quality Mesh Generation

297

Fig. 14. Triangle quality histogram.

Fig. 17. One level of recursion, triangle quality.

based mesh. But the approximate method produces
a perhaps surprisingly good mesh for this relatively
complicated domain. It generated about 25% more
triangles, however.

The recursive reﬁnement approximate shape qmg
method quite generally produces more triangles that
the iterative reﬁnement method; 150 versus 248 for
the ‘fat comma’, 88 versus 129 for the A shape
shown in Fig. 2. The reverse is true for the second
test case above, the square with segment meeting
as a small angle in the centre; for this case the
ratio is 88 (iterative) to 51. Since our intended goal
for the recursive reﬁnement approximate shape qmg
method is to produce initial triangulations for further
size reﬁnement, these somewhat larger meshes do
not seem to be a disadvantage.

7. Conclusions and Further
Investigations

We have discussed how some ideas of approximate
shape quality mesh generation can simplify the
maintenance of the bad triangles set, S, of Delaunay
reﬁnement methods. Iterative reﬁnement forms of
qmg as typiﬁed by Quality-Mesh-Generation of
Section 2 use a global list of bad triangles in the
current mesh that
is managed in the top level of
the modularization. This is a dynamic data structure
that supports insertions and deletions as well as
access for selection and modiﬁcation.

In the recursive organization described in Section
3,
the set of bad triangles is distributed into the
modularization. The growth of the set
is handled
in local sets of the recursive Delaunay-Insert-R
procedure. These sets are small, which makes their
list
representation processing more efﬁcient. The
part of the set handled at the top level does not
grow. However, in general its entries may require
modiﬁcation due to the action of Delaunay-InsertR.
 An approximate method constructed by limiting
the levels of recursion is then guaranteed to terminate,
 since the growth of S has been curtailed.

In Section 5, a further simpliﬁcation is described

Fig. 15. Iterative reﬁnement.

We also tested a large complicated polygonal
region of geographical data that is the outline of a
watershed. The polygonal boundary of this domain
consists of 536 vertices. Since the mesh is quite
large, only the one generated by the iterative shape
qmg program is shown in Fig. 15. In Fig. 16, we
show the histogram of triangle quality for the 2204
triangles in the mesh generated by the iterative
shape qmg program. In Fig. 17, we show the corresponding 
histogram for the 2882 triangles in the
mesh generated by the approximate qmg method
with one level of recursion. A small tail of lower
quality triangles are again in evidence in the shape
quality metric histogram of the approximate qmg

Fig. 16. Iterative reﬁnement, triangle quality.

298

B. Simpson et al.

that uses speciﬁc details of the terminal-edge point
selection scheme of the LEPP-Delaunay approach
to triangle shape improvement. Using it in conjunction 
with the recursive organization of reﬁnement
an approximate qmg method can be designed that
uses a small global array of size computable in
advance of reﬁnement plus distributed local storage.
This array can be processed in sorted order with no
modiﬁcations of it required during the reﬁnement.
An important extension of this investigation is to
identify how best to incorporate these approximate
shape quality techniques with a data representation
driven size requirement for full mesh generation. It
seems likely to us that the shape criterion can simply
be dropped after the pre-conditioning of the initial
␲(0) by an approximate shape quality method. Modiﬁed 
terminal-edge LEPP algorithms for the approximate 
size and shape qmg problem can be envisaged.
Another intriguing challenge is to identify how this
idea of
through judicious
approximations could be used to advantage for space
meshing. Formally,
the techniques applied in this
paper apply directly to three space.

simplifying methods

Acknowledgements

The contributions of the ﬁrst author have been supported
by the Natural Science and Engineering Research Council
of Canada and the ones of the second and third authors
have been partially supported by Fondecyt 1981033

References

1. Simpson, R. B. (1994) Anisotropic mesh transformations 
and optimal error control. Appl Num Math, 14,
183–198

2. Bern, M., Eppstein, D. (1992) Mesh generation and

optimal triangulation. In: F.K. Huang, (editor) Computing 
in Euclidean Geometry. World Scientiﬁc

3. Chew, L. P. (1993) Guaranteed-quality mesh generation 
for curved surfaces. 9th Annual Symposium on
Comp Geometry, San Diego, CA, 274–280

4. Rivara, M. C. (1997) New longest-edge algorithms
for the reﬁnement and/or improvement of unstructured
triangulations. Int J Num Methods, 40, 3313–3324

5. Rivara, M. C., Hitschfeld, N. (1999) LEPP-Delaunay
algorithm: a robust
tool for producing size-optimal
quality triangulations. Proc 8th Int Meshing Roundtable,
 205–220

6. Rivara, M. C., Inostroza, P. (1997) Using longestside
bisection techniques for the automatic reﬁnement of
delaunay triangulations. Int J Num Meth Eng, 40,
581–597

7. Ruppert, J. (1995) A Delaunay reﬁnement algorithm
for quality 2-dimensional mesh generation. J Algorithms,
 18, 548–585

8. Shewchuk, J. R. (1996) Triangle: Engineering a 2D
quality mesh generator and delaunay triangulator. First
Workshop on Applied Computational Geometry. Philadelphia,
 PN, 124–133

9. George, P. L., Borouchaki, H. (1998) Delaunay Triangulation 
and Meshing. Hermes

10. Chew, L. P. (1994) Constrained delaunay triangulation.

Algorithmica, 4, 97–108

11. Borouchaki, H., George, P. L. (1997) Aspects of 2-d
delaunay mesh generation. Int J Num Meth Eng, 40,
1957–1975

12. Rivara, M. C. (1996) New mathematical

tools and
techniques for the reﬁnement and/or improvement of
unstructured triangulations. Proc 5th Int Meshing
Roundtable, Pittsburgh, PN, 77–86

13. Rivara, M. C., Palma, M. (1997) New LEPP algorithms 
for quality polygon and volume triangulation:
Implementation issues and practical benhavier. In: S.
A. Cannan and S. Saigal (editors), Trends Unstructured
Mesh Generation. ASME, 1–8

14. Rivara, M. C., Hitschfeld, N., Simpson, R. B. (2001)
Terminal edges Delaunay (small angle based) algorithm 
for the quality triangulation problem. ComputerAided 
Design 33, 263–277

15. Joe, B., Simpson, R. B. (1986) Triangular meshes for
regions of complicated shape. Int J Num Meth Eng,
23, 751–778

