DERI – DIGITAL ENTERPRISE RESEARCH INSTITUTE

1
1
0
2

 

p
e
S
1

 

 
 
]

B
D
.
s
c
[
 
 

1
v
1
8
1
0

.

9
0
1
1
:
v
i
X
r
a

IMPROVING THE RECALL OF

DECENTRALISED LINKED DATA
QUERYING THROUGH IMPLICIT

KNOWLEDGE

J¨urgen Umbrich

Aidan Hogan

Axel Polleres

DERI TECHNICAL REPORT 2011-09-01

SEPTEMBER 2011

DERI – DIGITAL ENTERPRISE RESEARCH INSTITUTE

DERI Galway
IDA Business Park
Lower Dangan
Galway, Ireland
http://www.deri.ie/

DERI TECHNICAL REPORT

DERI TECHNICAL REPORT 2011-09-01, SEPTEMBER 2011

IMPROVING THE RECALL OF DECENTRALISED LINKED DATA

QUERYING THROUGH IMPLICIT KNOWLEDGE

J¨urgen Umbrich 1

Aidan Hogan 2

Axel Polleres 3

Abstract. Aside from crawling, indexing, and querying RDF data centrally, Linked Data principles
allow for processing SPARQL queries on-the-ﬂy by dereferencing URIs. Proposed link-traversal
query approaches for Linked Data have the beneﬁts of up-to-date results and decentralised (i.e.,
client-side) execution, but operate on incomplete knowledge available in dereferenced documents,
thus affecting recall. In this paper, we investigate how implicit knowledge – speciﬁcally that found
through owl:sameAs and RDFS reasoning – can improve the recall in this setting. We start with
an empirical analysis of a large crawl featuring 4 m Linked Data sources and 1.1 g quadruples:
we (1) measure expected recall by only considering dereferenceable information, (2) measure the
improvement in recall given by considering rdfs:seeAlso links as previous proposals did. We
further propose and measure the impact of additionally considering (3) owl:sameAs links, and
(4) applying lightweight RDFS reasoning (speciﬁcally ρDF) for ﬁnding more results, relying on
static schema information. We evaluate our methods for live queries over our crawl.

Keywords: SPARQL , Web of Data, RDFS reasoning.

1DERI, National University of Ireland, Galway, Ireland. juergen.umbrich@deri.org
2DERI, National University of Ireland, Galway, Ireland. aidan.hogan@deri.org
3DERI, National University of Ireland, Galway, Ireland / Siemens AG ¨Osterreich, Siemensstrasse 90, 1210 Vienna,

Austria axel.polleres@siemens.com

Acknowledgements: This material is based upon works in parts jointly supported by the Science Foundation
Ireland under Grant No. SFI/08/CE/I1380 (Lion-2).
Copyright c(cid:13) 2018 by the authors

DERI TR 2011-09-01

Contents
1 Introduction

2 Background and Related Work

3 Motivating Example

4 Preliminaries
.

.

.

.
.
4.1 RDF .
.
4.2 Linked Data .
4.3 SPARQL .
.
.
4.4 RDFS and OWL .

.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

.
.
.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
.
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5 Link Traversal Based Query Execution
.
.

5.1 Baseline LTBQE .
.
5.2 Extending LTBQE .

.
.

.
.

.
.

.
.

.
.

.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6 Empirical Study

6.1 Recall for Baseline .
.
6.2 Recall for Extensions .

7 Evaluation

7.1 Query Generation .
7.2 Results .
.

.

.

.

.

.

.
.

.
.

8 Conclusion

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

.
.

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

I

1

2

3

5
5
5
6
6

7
7
8

9
10
11

11
12
12

13

DERI TR 2011-09-01

1 Introduction

1

Recently, a rich lode of RDF data has been published on the Web as Linked Data, by governments, academia,
industry, communities and individuals alike [12]. Publishing Linked Data is governed by four principles,
here summarising [1]: (P1) use URIs to name things, such that (P2) those URIs can be dereferenced via
HTTP, such that (P3) dereferencing yields useful RDF content about that which is named, such that (P4) the
returned content includes links (mentions external URIs) for further discovery. Given that the URIs used to
name resources map (through HTTP) to the physical location of structured information about them, information 
published as Linked Data can be viewed as forming a scale-free, decentralised database, consisting
of millions of structured Web documents [10]. Further still, thanks to the provision of typed “RDF links”
between such documents [12, § 4.5], agents can traverse and navigate the resulting Web of Data in a manner
analogous to browsing through the Web of Documents.

Tangentially, SPARQL [19]—the W3C standardised RDF query language—provides the declarative
means to formulate structured queries against these data. Interestingly, SPARQL also encodes the notion of
Named Graphs, which (loosely) corresponds to a means of logically partitioning some RDF corpus, such that
combinations of partitions can be queried in isolation. Often, these partitions are based on the provenance of
data, with the named-graph IRI corresponding to the location from which an RDF document is retrieved—
e.g., a Web location. Thus, given a (HTTP) correspondence between graph names and addresses, SPARQL
could be supported by means of live querying such that the content of these graphs is retrieved from the Web
at runtime. However, SPARQL semantics considers a ﬁxed dataset from which to generate query answers,
whereas live querying explores an a priori unbounded Web of Data for on-the-ﬂy answers without ever
considering the dataset it operates over in its entirety.

Although there is a clear symbiosis between Linked Data principles, which state that URIs should be
dereferenceable, thus giving follow-your-nose cues as to where RDF data about a given resource might be
found; and SPARQL, which gives a declarative means of stating which graphs the given query should be
posed against; as of yet, SPARQL does not formally leverage the former set of principles. Along these lines,
Hartig et al. [9] investigate using dereferenceable URIs in the query—and recursively, in the intermediate
results of the query—to automatically determine a focussed set of sources which, by Linked Data principles,
are likely to be query relevant. These query-relevant sources are then retrieved and used to generate answers
to the user query, and possibly recursively, to traverse links and ﬁnd further query relevant sources. When
operating over sufﬁciently compliant Linked Data, their approach bypasses the need for source graphs to be
explicitly named in the original SPARQL query and allows for new sources to be discovered in an ad hoc
manner by traversing links at query time. Later work by Hartig [8] calls this approach Link Traversal Based
Query Execution (LTBQE).

Note that there is an inherent trade-off in the LTBQE approach between the amount of data accessed
and the recall of the response (the percentage of globally available answers returned), which varies from
accessing no sources and returning no results, to (theoretically) processing the entire Web of Data. Thus,
LTBQE relies on Linked Data principles as cues to identify a minimal amount of sources that maximise
results.

In this paper, we ﬁrst present an abstract formalism of the LTBQE approach, highlighting theoretical
completeness. We then analyse the recall of the LTBQE approach in practice using an empirical analysis
of a recent Linked Data crawl of ∼4 m RDF Web documents. We examine, e.g., the expected percentage
of dereferenceable URIs, and the ratio of triples returned in documents dereferenced to by some URI vs.
all data available about that URI in the entire sample. We also look at how incorporating rdfs:seeAlso
links into the LTBQE approach—as originally proposed by Hartig et al. [9]—affects recall. We further

2

DERI TR 2011-09-01

propose extensions of LTBQE to (i) minimise the amount of sources accessed by skipping lookups for
bindings of non-distinguished variables; (ii) increase recall by considering some lightweight semantics of
Linked Data which allow for (ii.a) ﬁnding additional query-relevant sources and data though consideration
of owl:sameAs links, and (ii.b) ﬁnding additional query-relevant data through rule-based materialisation
with respect to a lightweight subset of RDFS (viz. ρDF [17]). With regards to (ii.b), we currently use a
static set of schema data collected a priori. We measure the expected effect on recall for each of these
extensions through analysis of our Linked Data sample. Finally, and again using our sample corpus, we
randomly generate a set of benchmark queries featuring dereferenceable URIs and run them live over the
remote sources, comparing all techniques discussed with respect to the number of sources accessed, the
number of triples processed, and the number of answers returned.

2 Background and Related Work

Traditional approaches to query Linked Data locally replicate the content of the remote Linked Data sources,
e.g., in a triple or quad store and execute the SPARQL queries over the local copy. Such approaches typically
feature a crawler or other data acquisition component which, e.g., follows links between documents to
discover new information, and/or downloads documents which have been requested for indexing by remote
parties. In previous years, we supported such a service powered by YARS2 [7] allowing for querying over
millions of RDF Web documents (and their entailments), but have since discontinued the endpoint due to
prohibitive running costs for our research hardware. Current centralised SPARQL endpoints harvesting
Linked Data include OpenLink’s LOD cache1 powered by the Virtuoso quad store [6], the FactForge [2]
SPARQL endpoint2 which includes materialised data supported by BigOWLIM [3], and more recently the
Sindice [18] SPARQL endpoint3 again powered by Virtuoso. The primary challenges for such an approach
are (i) to have as much coverage of the Web of Data as possible, (ii) to keep results up to date, (iii) to
be able to process potentially expressive (i.e., expensive) SPARQL queries in an efﬁcient manner and with
high concurrency. These objectives are (partially) met using distribution techniques, replication, optimised
indexes, compression techniques, data synchronisation, and so on [3, 6, 7, 18]. Still, given that such services
often index millions of documents, they often require large amounts of resources to run.
In particular,
maintaining a local, up-to-date index with good coverage of the Web of Data is a Sisyphean task.

Alternative approaches apply federated query processing techniques for the query execution. Recently,
Ladwig and Tran [14] identify three conceptual approaches for the federated execution of SPARQL queries
over Linked Data: (i) top-down query evaluation, (ii) bottom-up query evaluation, and (iii) mixed strategy
query evaluation.

The top-down evaluation determines the query relevant sources before the actual query execution using
knowledge about the available sources stored in a so-called “source-selection index”. These source-selection
indexes can vary from simple inverted-index structures [16,18], to query-routing indexes [22], schema-level
indexes [21], and lightweight hash-based structures [23].

The bottom-up query evaluation strategy involves discovering query-relevant sources on-the-ﬂy during
the evaluation of queries. The LTBQE approach [9] and the work in the present paper fall into this category.
A “seed set” of remote query-relevant sources are extracted from the query; links are followed from these
initial sources to ﬁnd further query relevant sources and to ﬁnd more answers or satisfy additional sub-goals

1http://lod.openlinksw.com/sparql
2http://factforge.net/sparql
3http://sparql.sindice.com/

DERI TR 2011-09-01

3

in the query; the process continues recursively until all known query-relevant sources have been exhausted.
Since no local index is required, this approach can be used in decentralised scenarios, where clients can
execute queries remotely over the Web without accessing a centralised service. The unique challenges for
such an approach are (i) to ﬁnd as many query-relevant sources as possible to improve recall of answers; (ii)
to conversely minimise the amount of sources accessed to avoid trafﬁc and slow query-response times; (iii)
to optimise query execution in the absence of typical selectivity estimates, etc. [8,9]. In this paper, we focus
on the ﬁrst two challenges.

The third strategy involves a hybrid combination of top-down and bottom-up techniques. This strategy
uses (in a top-down fashion) some knowledge about sources to map query terms or query sub-goals to
sources which can contribute answers, then discovering additional query relevant sources using a bottom-up
approach [14].

Such approaches translate into signiﬁcant savings with respect to the resources required to locally index 
data; where these savings are sufﬁcient enough, the approach can be used for decentralised querying
whereby clients (those posing queries) can host the source-selection index locally on their machine. We
note that there is still huge variance between the different approaches, targeting different scenarios and usecases.
 For example, the inverted index traditional proposed by Sindice [18] is still very much a lightweight
version of a centralised service. Conversely, our hash-based data summaries approach [23] is more geared
towards lightweight, client-side processing. Depending on the particular approach taken, challenges may
vary (as before) between those identiﬁed for top-down and bottom-up strategies; for example, keeping local
knowledge up-to-date, or identifying a low number of query-relevant sources, etc.

A tangential approach is that of federated SPARQL querying, where remote SPARQL endpoints offer

service descriptions which are indexed locally and used to route queries [20].

As such, moving towards a mature Linked Data query-answering system, one could consider a combination 
of approaches, where each has its complementary advantages and disadvantages. An interesting and
relatively novel research area would then be investigating how to combine local and remote querying techniques 
both on a theoretical, engineering, and social level (cf., e.g., [10, 15]). For example, using top-down
approaches seems well suited for relatively static data (e.g., DBpedia, DBLP, etc.), whereas bottom-up approaches 
seem better suited to dynamic data (e.g., identi.ca, MusicBrainz, etc.) or potentially sensitive data,
with mixed strategies falling somewhere in-between; cf [24].

In this paper, we focus on an empirical analysis of the expected recall of the LTBQE bottom-up strategy
for Linked Data, as well as proposing and evaluating extensions to ﬁnd additional query-relevant sources.
In addition, our approach performs reasoning over the retrieved content to potentially increase recall. Our
approach uses RDFS rules and a static TBox – as opposed to dynamic extraction of the TBox from fetched
content as proposed by Li [16] – since we assume that terminological knowledge on the Web is relatively
small (and can be kept in memory client-side [13]) and static. Moreover, we avoid “non-authoritative”
redeﬁnitions of ontology terms [13] during reasoning.

3 Motivating Example

Before continuing, we motivate our extensions by means of a concrete, real-world example: Figure 1 illustrates 
an RDF (sub)graph taken from four interlinked sources on the Web of Data.4 The graph contains 
structured information about one publication (l3sPub:HartigBF09), “four” persons (oh:olaf,

4last data access on 23.06.2011

4

DERI TR 2011-09-01

cb:chris, l3sAuth:Olaf Hartig, l3sAuth:Christain Bizer) and four dereferenceable
documents.

Figure 1: Snapshot of a subgraph from the Linked Open Data Web.

A typical query which can be answered by the LTQBE approach which also considers rdfs:seeAlso
links is to ask for the pictures of friends of the person oh:olaf (cf. Query 1). The query processor evaluates
this query by dereferencing the content of the query URI oh:olaf, following and dereferencing all URI
bindings for the variable ?f and matching the second query pattern ?f foaf:depiction ?n over the
retrieved content to ﬁnd the pictures. However, the query processor needs to follow the rdfs:seeAlso
link from cb:chris to cbDoc since the URI cb:chris is not dereferenceable (a dashed arrow in Fig. 1
denotes dereferenceability).

Query 2, asking for the co-authors who are also friends of oh:olaf, will not give results if executed
with the current LTQBE approach since explicit equality information about URIs is not currently considered.
The owl:sameAs relationship between oh:olaf and l3sAuth:Olaf Hartig states that both URIs
are equivalent and referring to the same real world entity.

Eventually, Query 3 asks for the labels of friends of oh:olaf. A pure link-traversal based query
processor would miss the answer “Chris Bizer” because implicit knowledge encoded in ontologies used to
describe real world things and their relations is not considered in the query execution. The implicit missing
information to the query engine is that the foaf:name relation is a subProperty of the rdfs:label
relation; particularly, note that dereferenceing the rdfs:label URI would not help here, since the subProperty 
relation is stored in the FOAF ontology. Knowledge about the commonly used vocabularies and
simple RDFS inference would address this use case.

rdfs:seeAlsoowl:sameAsrdfs:labell3sPub   =http://dblp.l3s.de/d2r/resource/publications/conf/semweb/l3sAut-...=http://dblp.l3s.de/d2r/resource/authors/l3sAutP. =http://dblp.l3s.de/d2r/page/authors/oh          =http://olafhartig.de/foaf.rdf#   ohDoc..=http://olafhartig.de/foaf.rdfcb      ....=http://www.bizer.de#             cbDoc..=http://www4.wiwiss.fu-berlin.de/bizer/foaf.rdfcb:chrisoh:olaffoaf:knows"Chris Bizer"foaf:nameowl:sameAsl3sAut:Christian_Bizerfoaf:imgfoaf:depictionhttp://....http://....ohDoccbDocl3sPub:HartigBF09dc:creatorfoaf:makerl3sAuth:Olaf_Hartig"Olaf Hartig"foaf:namedc:creator   foaf:makerl3sAutP:Christian_Bizerl3sAutP:Olaf_HartigdereferenceableDERI TR 2011-09-01

5

SELECT ?f, ?img WHERE {
oh:olaf foaf:knows ?f .
?f foaf:depiction ?img }

SELECT ?f WHERE {
oh:olaf foaf:knows ?f .
?pub dc:creator ?f, oh:olaf}

SELECT ?o, ?l WHERE {
oh:olaf foaf:knows ?f .
?f rdfs:label ?l }

Query 1: Pictures of friends.

Query 2: Co-authors who are friends.

Query 3: Labels of friends

4 Preliminaries
In this section, we cover some necessary preliminaries and notation relating to RDF (§ 4.1), Linked Data
(§ 4.2), SPARQL (§ 4.3) and RDFS & OWL (§ 4.4).

4.1 RDF

We ﬁrst provide some standard notation for dealing with RDF [11].

Deﬁnition 4.1 (RDF Term, Triple and Graph)
The set of RDF terms consists of the set of URIs U, the set of blank-nodes B and the set of literals L
(which includes plain and datatype literals). An RDF triple t := (s, p, o) is an element of the set G :=
UB × U × UBL (where, e.g., UB is a shortcut for set-union). Here s is called subject, p predicate,
and o object. A ﬁnite set of RDF triples G ⊂ G is called an RDF graph. We use the functions subj(G),
pred(G), obj(G), terms(G), to denote the set of all terms projected from the subject, predicate, object and
any position of a triple t ∈ G respectively.

4.2 Linked Data
The Linked Data principles [1] have already been introduced in § 1. We now provide some notation which
helps to formalise these principles and relate them to RDF. As per [9], we currently do not consider temporal
issues with, e.g, HTTP-level functions.

Deﬁnition 4.2 (Data Source and Linked Dataset)
We deﬁne the http-download function get : U → 2G as the mapping from URIs to RDF graphs provided by
means of HTTP lookups which directly return status code 200 OK and data in a suitable RDF format.We
deﬁne the set of (RDF) data sources S ⊂ U as the set of URIs S := {s ∈ U : get(s) (cid:54)= ∅}. We deﬁne a
(u,G)∈Γ G as the RDF

Linked Dataset as Γ ⊂ get; i.e., a ﬁnite set of pairs (u, get(u)), and merge(Γ) :=(cid:85)

merge of graphs in Γ which preserves the uniqueness of blank-node labels across graphs [11].

Deﬁnition 4.3 (Dereferencing RDF) A URI may issue a HTTP redirect to another URI with a 30x response 
code; we denote this function as redir : U → U which maps a URI to itself in the case of failure
(e.g., where no redirect exists); note that redir would also strip the fragment identiﬁer of a URI if present.
We denote the ﬁxpoint of redir as redirs, denoting traversal of a number of redirects (a limit may be imposed
to avoid cycles). We denote dereferencing by the composition deref := get ◦ redirs which maps a URI to an
RDF graph retrieved with status code 200 OK after following redirects, or which maps a URI to the empty
set in the case of failure. We denote the set of dereferenceable URIs as D := {d ∈ U : deref(d) (cid:54)= ∅}; note
that D ⊂ S and we place no expectations on what deref(d) returns (as long as it returns some valid RDF).

6

DERI TR 2011-09-01

4.3 SPARQL
We now introduce some concepts relating to SPARQL [19]. Note that herein, we focus on evaluating simple,
conjunctive, basic graph patterns (BGPs), where we do not consider do not consider more expressive parts
of the SPARQL language (although they can be layered on top of our methods).

Deﬁnition 4.4 (Variables, Triple Patterns and Queries (BGPs))
Let V be the set of variables ranging over UBL. A triple pattern tp := (s, p, o) is an element of the set
Q := VUL× VU× VUL. For simplicity, we do not consider blank-nodes in triple patterns (they could be
roughly emulated by an injective mapping from B to V). A ﬁnite (herein, non-empty) set of triple patterns
Q ⊂ Q is called a Basic Graph Pattern, or herein, simply a query. We use vars(Q) ⊂ V to denote the set
of variables in Q. Finally, we may overload graph notation for queries, where, e.g., terms(Q) returns all
elements of VUL in Q.

Deﬁnition 4.5 (SPARQL solutions)
Call the partial function µ : dom(µ) ∪ UL → UBL a solution mapping which grounds variables in
dom(µ) ⊂ V to UBL and which is the identify function for UL. Overloading notation, let µ : Q → G
and µ : 2Q → 2G also resp. denote a solution mapping from triple patterns to RDF triples, and basic
graph patterns to RDF graphs such that µ(tp) := (µ(s), µ(p), µ(o)) and µ(Q) := {µ(tp) | tp ∈ Q}.
Now, we deﬁne the set of solutions for a query Q over a Linked Dataset Γ as Ω(Γ, Q) := {µ | µ(Q) ⊆
merge(Γ) ∧ dom(µ) = vars(Q)}. Note that herein, and unlike SPARQL, solutions are given as sets (not
multi-sets), implying a default DISTINCT semantics for queries.

4.4 RDFS and OWL
We deﬁne some preliminaries relating to RDFS and OWL. In particular, we support a subset of OWL 2
RL/RDF rules, given in Table 1, which constitute a partial axiomatisation of the OWL RDF-Based Semantics.
 Our RDFS rules are a subset of the ρDF rules proposed by Mu˜noz et al. [17] which deal with instance
data entailments (as opposed to schema-level entailments).5 Our subset of OWL rules are speciﬁcally chosen 
to support the semantics of equality (particularly replacement) for owl:sameAs. Note that these rules
support the RDFS/OWL features originally recommended for use by Bizer et al. when publishing Linked
Data [4, §4.2, §6]. The rules we consider are given in Table 1. More recent guidelines [12, §4.4.3] recommend 
use of additional OWL features; we leave support for more expressive OWL reasoning to future work.
For convenience, we re-use previous notation in the following formalisms.

Deﬁnition 4.6 (Entailment Rules and Least Model)
An entailment rule is a pair r = (Body, Head) such that Body, Head ⊂ Q; and vars(Head) ⊆
vars(Body). The immediate consequences of r for a Linked Dataset Γ are denoted and given as:

T(Γ, r) := {µ(Head) | µ ∈ Ω(Γ, Body)}

(cid:83)
RΓ0 := Γ ∪ {(υ, G0)} and let RΓi := Γ ∪(cid:0){υ, T(RΓi−1, R) ∪ Gi−1

Let R denote a set of entailment rules. The immediate consequences of R over Γ are given as T(Γ, R) :=
r∈R T(Γ, r). Further, let υ denote a fresh URI which names the graph G of inferred data, let G0 = ∅,

(cid:1)} for i ∈ N. The least model of R for

Γ is given as the least n such that RΓn = RΓn+1 (i.e., the closure is reached); we denote the least model as
RΓ. Query answers incl. entailments are given by Ω(RΓ, Q).

5We drop implicit typing [17] rules as we allow generalised RDF in intermediate inferences.

DERI TR 2011-09-01

7

Body

ID
PRP-SPO1 ?p1 rdfs:subPropertyOf ?p2 .
PRP-DOM ?p rdfs:domain ?c .
PRP-RNG ?p rdfs:range ?c .
CAX-SCO ?c1 rdfs:subClassOf ?c2 .
EQ-SYM
?x owl:sameAs ?y .
EQ-TRANS ?x owl:sameAs ?y .
EQ-REP-S ?s owl:sameAs ?s(cid:48) .
EQ-REP-P ?p owl:sameAs ?p(cid:48) .
EQ-REP-O ?o owl:sameAs ?o(cid:48) .

?s ?p ?o .

?s ?p ?o .

?s a ?c1 .

?y owl:sameAs ?z .
?s ?p ?o .
?s ?p ?o .
?s ?p ?o .

Head

?s ?p1 ?o . ?s ?p2 ?o .

?p a ?c .
?o a ?c .
?s a ?c2 .
?y owl:sameAs ?x .
?x owl:sameAs ?z .
?s(cid:48) ?p ?o .
?s ?p(cid:48) ?o .
?s ?p ?o(cid:48) .

Table 1: ρDF and owl:sameAs rules with OWL 2 RL/RDF naming

5 Link Traversal Based Query Execution

We now discuss the Link Traversal Based Query Execution (LTBQE) approach introduced by Hartig et
al. [9], where we present a novel, abstract formalisation and characterise the completeness of the approach
with respect to the Web of Data (§ 5.1). We then look at extensions of the approach which improve recall
(§ 5.2).

5.1 Baseline LTBQE
Deﬁnition 5.1 (LTBQE Query Relevant Sources and Answers) Deﬁne derefs : 2U → U × 2G; U (cid:55)→
{(redirs(u), deref(u)) | u ∈ U )} as the mapping from a set of URIs to the Linked Dataset it represents by
dereferencing all URIs. Given a BGP query Q as before, let UQ := terms(Q) ∩ U denote the set of URIs
0 := derefs(UQ) represent the dataset retrieved by dereferencing all query URIs.6
appearing in Q. Let ΓQ
Next let uris(µ) := {u ∈ U | ∃v s.t. (v, u) ∈ µ} denote the set of URIs in a solution mapping µ, and let
i−1)} for i ∈ N be the set of URIs which appear
Ui := {u ∈ uris(µ) | ∃µ,∃tp ∈ Q s.t. µ({tp}) ⊆ merge(ΓQ
0 .7 The
as a solution mapping for a triple pattern in Q for the dataset ΓQ
i−1, and let ΓQ
set of LTBQE query relevant sources for Q is given as the least n such that ΓQ
n+1, denoted simply
ΓQ. The set of LTBQE query answers for Q is given as Ω(ΓQ, Q), or simply ΩQ.

:= derefs(Ui) ∪ ΓQ
n = ΓQ

i

With regards to completeness, let get denote the dataset (theoretically) represented by the entire Web of
Data (note: get ⊂ U × 2G). One may then ask when ΩQ is complete with respect to get. A trivial sufﬁcient
condition for completeness is given by ΓQ = get. A “top down” condition is given by looking at all of the
answers available for get:
Proposition 5.1 Let Q be a query s.t. terms(Q) ∩ U (cid:54)= ∅. Let Ω(get, Q) denote the set of answers given
by the Web of Data. For each µ ∈ Ω(get, Q), let D := (V, A) denote a directed graph with vertices
V = U ∩ terms(µ(Q)) and arcs:

E := {(x, y) ∈ V × V | ∃t ∈ µ(Q) s.t. {x, y} ⊆ terms({t}) and t ∈ deref(s)}

Again denote the query URIs by UQ := terms(Q) ∩ U, let A+ denote the transitive closure of the arcs, and
let

Q := UQ ∪ {u ∈ U | ∃uQ ∈ UQ s.t. (uQ, u) ∈ A+}
U +

6One could consider ΓQ
7Or, equivalently (for static data) ΓQ
i

0 as also containing “seed” data [9].

:= ΓQ

i−1 ∪ derefs(Ui \ Ui−1).

8

DERI TR 2011-09-01

denote the set of URIs reachable in the graph from a query URI. Now, ΩQ contains a solution isomorphic to
Q )) |= µ(Q) (i.e., the former simple-entails
µ (up to blank-node relabelling) if and only if merge(derefs(U +
the latter [11]).

Proof 5.1 (Sketch) The above proposition essentially rephrases the LTBQE algorithm to highlight the reachability 
condition from a query URI, where ΓQ is equivalent to derefs(U +
Q ).

The proposition has some interesting consequences. First, given a query with no dereferenceable URIs,
LTBQE cannot return results. Second, given a query with multiple URIs, different reachability conditions
can occur from different starting points; thus, all query URIs must be initially retrieved [9]. Third, answers
“connected” by literals or involving blank-nodes in unreachable documents will often affect completeness.
Fourth, in the general case, reachability is heavily dependent on the amount of data returned by the deref(u)
function, which would ideally return all triples mentioning u on the Web of Data. The fourth assumption is
clearly idealised; hence, in Section 6 we will empirically analyse how much the assumption holds in practice,
giving insights into the recall of LTBQE. Beforehand, we propose some extensions to extend LTBQE recall
by considering implicit knowledge.

5.2 Extending LTBQE

We now look at three extensions to the baseline LTBQE approach.

1. Following rdfs:seeAlso: The ﬁrst extension is that proposed by Hartig et al., which considers
rdfs:seeAlso links to extend the set of query-relevant sources. Here, we brieﬂy summarise. Adapting
Deﬁnition 5.1, let ¯ΓQ

0 := ΓQ

0 and let:

¯Ui := Ui ∪ {u ∈ U | ∃u(cid:48) ∈ Ui s.t. (u(cid:48), rdfs:seeAlso, u) ∈ merge(¯ΓQ

i−1)} ,

:= derefs( ¯Ui)∪ΓQ

let ¯ΓQ
i
Here, rdfs:seeAlso links are used to expand the set of query relevant sources.

0 , and ﬁnally let ¯ΓQ be the ﬁxpoint as before and let ¯ΩQ be the respective solutions.

2. Following and reasoning over owl:sameAs: We propose an extension of LTBQE to consider
owl:sameAs inferences. Let R denote the set of rules of the form EQ-* in Table 1. Let now eΓQ
0 := RΓQ
(recalling RΓ from Def. 4.6 and ΓQ

0 from Def. 5.1), and let:

0

i := {u ∈ uris(µ) | ∃µ,∃tp ∈ Q s.t. µ({tp}) ⊆ merge(eΓQ
U(cid:48)
eUi := {u ∈ U | ∃u(cid:48) ∈ U(cid:48)

i−1)} ,
i s.t. (u(cid:48), owl:sameAs, u) ∈ merge(eΓQ

i−1)} ,

:= Rderefs(eUi) ∪ eΓQ

where eΓQ
0 , and ﬁnally let eΓQ be the ﬁxpoint as before and let eΩQ be the rei

spective solutions. Here, owl:sameAs links are used to expand the set of query relevant sources, and
owl:sameAs rules are used to materialise implicit knowledge given by the OWL semantics, potentially
generating additional answers.

DERI TR 2011-09-01

9

3. Reasoning for ρDF: We propose a ﬁnal novel extension of LTBQE to consider a subset of RDFS
reasoning as per the prp-* and cax-sco rules in Table 1, which we again denote here by R. We currently
consider a static set of schema data representing vocabularies on the Web, which we denote by Γvoc. This
serves as input into the LTBQE algorithm. In future work, we plan to investigate dereferencing schema
knowledge live from the Web of Data.

Now, adapting Deﬁnition 5.1, let ρΓQ

0 := Γvoc ∪ RΓQ

0 and let:

ρUi := {u ∈ uris(µ) | ∃µ,∃tp ∈ Q s.t. µ({tp}) ⊆ merge(ρΓQ

i−1)} ,

:= Rderefs(ρUi) ∪ρΓQ

where ρΓQ
0 , and ﬁnally let ρΓQ be the ﬁxpoint as before and let ρΩQ be the respective
i
solutions. Here, RDFS rules and background schema knowledge are used to materialise implicit knowledge,
potentially generating additional answers (and thus possibly ﬁnding new query relevant sources).

Combined Of course, the above methods can be combined in a natural fashion, where, e.g., for combining
all extensions, the query relevant sources are denoted e
ρ

¯ΓQ and the answers by e
ρ

¯ΩQ.

6 Empirical Study

In Section 5.1, we mentioned that the recall of the LTBQE approach is—in the general case—dependent
on the dereferenceability of data. Along those lines, we now present the results of our empirical study
of a Linked Data corpus. We survey the ratio of all triples mentioning a URI in our corpus against those
returned in the dereferenceable document of that URI; we do so for different triple positions. We also
look at the comparative recall of data considering (1) explicit, dereferenceable information; (2) including
rdfs:seeAlso links [9]; (3) including owl:sameAs links and implicit knowledge; (4) including RDFS
reasoning.

Empirical corpus Our corpus was crawled in mid-May 2010 from 3.985 million RDF/XML documents
spanning 783 pay-level domains (data providers). URIs in all triples positions were considered for crawling.
We conducted the crawl in a breadth-ﬁrst manner to guarantee a broad sample of data-providers (and to
ensure polite crawling), we assign each pay-level domain (PLD) an individual priority queue. The PLD
queues are sampled in a round-robin fashion during the crawl, with the highest linked URIs for each domain
being returned ﬁrst.

The resulting corpus contains 1.118 g quadruples (965 m unique triples) mentioning 286 m RDF terms,
of which 29 m (10%) are Literals, 165 m (57.8%) are blank nodes, and 92 m (32.2%) are URIs. We denote
the corpus as Γ∼. It’s important to note that this corpus is only a sample of the Web of Data; in particular,
we have not performed a HTTP lookup on all URIs in the corpus, where we looked up—and thus only have
knowledge of redir and deref functions for—8.63 m URIs; all of these URIs are HTTP and do not have
non-RDF ﬁle-extensions. We denote these URIs by U∼. Of the 8.63 m, 5.65 m (65.5%) dereferenced to
RDF; we denote these by D∼. Further note that, wrt. the Web of Data, our sample recall measures specify
an upper bound.

More details about the parameters of the crawl and various statistics about the corpus are presented

in [13].

10

DERI TR 2011-09-01

RDFS Schema From our corpus, we extract a static set of schema data for the RDFS reasoning. As
argued in [5], schema data on the Web is often noisy, where third-party publishers “redeﬁne” popular terms
outside of their namespace; for example, one document deﬁnes nine properties as the domain of rdf:type,
which would have a drastic effect on our reasoning.8 Thus, we perform authoritative reasoning, which
conservatively discards certain third-party schema axioms (cf. [5]). Thus, our schema data only considers
triples of the following form:

(s, rdfs:subPropertyOf, o) ∈ deref(s), (s, rdfs:subClassOf, o) ∈ deref(s)

(s, rdfs : domain, o) ∈ deref(s), (s, rdfs : range, o) ∈ deref(s)

We extracted 397,749 such authoritative RDFS triples from 70 PLDs as follows: 229,575 rdfs:subClassOf
(55 PLDs); 12,266 rdfs:subPropertyOf (43 PLDs); 85,071 rdfs:domain (57 PLDs); 70,837
rdfs:range (58 PLDs).

6.1 Recall for Baseline

We ﬁrst measure the average dereferenceability of information in our sample. For a dereferenceable uri d,
we compute the sample dereferencing recall sdr(d) as the ratio of the number of unique triples mentioning d
in deref(d) vs. unique triples mentioning d across the entire sample. We denote by sdr∼ the average sdr(d)
for all d ∈ D∼. We also analyse the sdr(d) restricting the speciﬁc triple positions where d appears. We
ignore d in the average if it does not appear in the relevant triple position in the sample.

Table 2 presents the results, where for different triples positions we present (i) number of URIs appearing
in that position, (ii) number of which were dereferenceable, (iii) ratio of dereferenceable URIs, (iv) sdr∼
for that position, (v) standard deviation of sdr∼. Column type-object considers d appearing as object in an
rdf:type triple separately.

The analysis provides some interesting insights into the LTBQE approach. Given a HTTP URI without
a common non-RDF extension, we have a 65% success ratio to receive RDF/XML content regardless of the
triple position; for subjects, the percentage increases to 84%, etc. If such a URI dereferences to RDF, we
receive on average 65% of all triples in which it appears. Given a triple pattern with a URI in the subject
position, the dereferenceable ratio increases to 95%; for objects, the ratio drops to 44%; LTBQE would
perform poorly for triple patterns with (only) a URI in the predicate position; etc. In summary, LTBQE
performs well when URIs appear in the subject position of triple patterns, moderately when URIs appear in
the object, but poorly when URIs appear in the predicate or object of an rdf:type triple.

|U∼|
|D∼|

|U∼|/|D∼|
AVG sdr∼
SD sdr∼

any
8.63 m
5.65 m
0.65
0.65
0.47

subject
6.51 m
5.46 m
0.84
0.95
±0.19

predicate
15.15 k

635
0.04

0.00009
±0.009

object
6.60 m
3.02 m
0.46
0.44
±0.47

type-object

74.72 k
21.2 k
0.28
0.0037
±0.06

Table 2: Dereferenceability results for different triple positions

8viz. http://www.eiao.net/rdf/1.0

DERI TR 2011-09-01

6.2 Recall for Extensions

11

We now measure the sdr increase given by extending LTBQE to also consider rdfs:seeAlso and
owl:sameAs links, as well as implicit knowledge given by owl:sameAs and RDFS reasoning.

Beneﬁt of following rdfs:seeAlso links We measured the percentage of dereferenceable URIs in D∼
which have at least one rdfs:seeAlso link in their dereferenced document to be 7% for our sample.
Where such links exist, following them increases the amount of unique triples by a factor of 1.016× vs.
the unique triples in the dereferenced document alone. We conclude that, in the general case, considering
rdfs:seeAlso information for the query processing will only marginally effect the recall increase of
LTBQE.

Beneﬁt of following owl:sameAs links & implicit knowledge We measured the percentage of dereferenceable 
URIs in D∼ which have at least one owl:sameAs links in their dereferenced document to be
18% for our sample. Where such links exist, following them and applying the EQ-* entailment rules over
the resulting information increases the amount of unique triples by a factor of 3.85× vs. the unique (ex-
plicit) triples in the dereferenced document alone. We conclude that, in the general case, owl:sameAs
links are not so commonly found for deferenceable URIs, but where available, following them and applying
the entailment rules generates signiﬁcantly more data for generating answers.

Beneﬁt of including ρDF implicit knowledge We measured the percentage of dereferenceable URIs in
D∼ whose dereferenced documents given non-empty unique entailments through authoritative ρDF reasoning 
with respect to Γvoc as 98%. Where such entailments are non-empty, they increase the amount of unique
triples by a factor of 2.44× vs.
the unique (explicit) triples in the dereferenced document. We conclude
that such reasoning often increases the amount of data available for LTBQE query answering, and by a
signiﬁcant amount.

7 Evaluation

We evaluate our proposed LTBQE extensions for a set of pseudo-randomly generated queries over our
Linked Data corpus. Our main goal is to compare and contrast different setups and to assess our proposed
extensions in a realistic scenario.

Implementation We have implemented Hartig et al.’s iterator-based algorithm for LTBQE (which was
shown to be complete) [9]. We use ARQ to parse and process input SPARQL queries.9 We further
use the LDSpider crawling framework for performing live Linked Data lookups; LDSpider respects the
robots.txt policy, blacklists typical non-RDF URI patterns (e.g., .jpeg) and enforces a half-second
delay between two consequential lookups for URIs hosted at the same domain.10 We use the SAOR engine
to support the aforementioned rule-based reasoning extensions [5]. Note that we use the same input RDFS
data as used in the empirical study of the previous section.

9http://jena.sourceforge.net/ARQ/
10http://code.google.com/p/ldspider/

12

DERI TR 2011-09-01

Optimised LTBQE Inspired by our empirical analysis, we also implement and evaluate a variation of the
LTBQE approach which does not dereference URIs appearing only in the predicate position of a (possibly
partially bound) triple-pattern. Further, we add another optimisation which avoids dereferencing URIs which
are only bound by non-distinguished variables not appearing elsewhere in the query (i.e., variables whose
value is not used elsewhere). Since these optimisation reduce the number of query-relevant sources, they
may in theory lead to less results, though in practice (and as per our empirical survey), we would expect a
minimal change in recall over the baseline.

7.1 Query Generation
Query shapes and generation We benchmark queries of elemental graph shapes, viz., entity, star and
path queries.
Entity queries (entity-[s|o|so]) ask for all available triples for an entity. We generate three types of entity
queries, asking for triples where a URI appears (entity-s) as the subject; (entity-o) as the object; (entity-so)
as the subject or object. An example for entity-so would be {<d> ?p1 ?o .
Star queries (star-[s3|o3|s1-o1|s2-o1|s1-o2]) contain three acyclic triple patterns which share exactly one
URI (called the center node) and where predicate terms are constant. We generate four different variations
of such queries, differing in the number of triple patterns in which the center node appears at the subject (s)
or object (o). Thus, each query has 4 constants and 3 variables. An example for star-s2-o1 would be {<d>
foaf:knows ?o ;foaf:name ?o1 .
Path queries ([s|o]-path-[2|3]) consist of 2 or 3 triple patterns which form a path—precisely two triple
pattern share the same variable. Exactly one triple pattern has a URI at either the subject or object position
and all predicate terms are constant. We generate four different sub-types: path shaped queries of length 2
and 3 in which either the subject or object term of one of the triple pattern is a constant. An example for
s-path-2 is Query 1.

?o3 dc:creator <d> .}

?s ?p2 <d> .}

In total, we generate 200 SELECT DISTINCT queries for each of the above 12 query shapes using
random walks in our corpus. To help ensure that queries return non-empty results (in case there are no HTTP
connection errors or time outs) we consider dereferenceable information for the query generation which (1)
picks randomly a pay-level-domain available in the dereferenceable URIs D∼, (2) selects randomly a URI
from D∼ for that PLD and (3) generates appropriate triple patterns from the dereferenceable document of the
selected URI. For path shape queries, when performing steps (2) and (3), the URI for the next triple pattern
is selected out of the URIs contained for the previous triple pattern, as per a random walk of dereferenceable
URIs.

Distinguished variables are picked by randomly choosing a single variable as distinguished and make

further variables distinguished with a probability of 0.5.

7.2 Results
We measure for each query the following six metrics: (1) the number of distinct results (result), (2) the total
time to execute the query (time), (3) time elapsed until the ﬁrst result was returned (ﬁrst), (4) number of
total lookups (http), (5) total number of triples processed (retrieved) and (6) total number of inferred triples
(inferred).

We execute each query with six different setups: base gives the LTBQE baseline; select denotes
optimised LTBQE; seeAlso, sameAs, and ρDF extend optimised LTBQE; combined denotes all extensions 
over optimised LTBQE. Note that we present wall-clock times “as-is”: running queries live over the
Web of Data introduces many external variables which we cannot account for.

DERI TR 2011-09-01

13

We ran our 200 benchmark queries directly over the Web of Data. We encountered various HTTPlevel 
issues which affected comparability of results for the six setups. Thus, we select and present results
for “stable” queries which returned a non-empty results and where none of the required HTTP lookups
resulted in a response code of 5xx or other connection errors (e.g., timeouts). The detailed benchmark
results are listed in Table 3. Overall, the expected recall improvements from our empirical analyses for
the different optimisations are veriﬁed by our experiments. Our source selection optimisation reduces the
number of total lookups by two to three times without signiﬁcantly affecting the result recall. We observed
that considering rdfs:seeAlso information for the query processing marginally affects the content recall
but has no measurable inﬂuence on the results. Further, we observe that following owl:sameAs links, if
available, and applying the entailment rules generates signiﬁcantly more data and increase the number of
returned answers. A similar increase in data and results can be measured if we consider ρDF inferences.
The combination of all optimisation returned for all query the most answers and effectively increased the
amount of query relevant data.

8 Conclusion

Proposed link-traversal query approaches for Linked Data have the beneﬁt of up-to-date results and decentralised 
execution, but operate over incomplete knowledge available in dereferenced documents, thus
affecting recall for results. We empirically study this issue for a large sampling of the Web of Data, consisting 
of 4 m Linked Data sources and 1.1 g quadruples. We further propose to improve recall by considering
implicit knowledge, speciﬁcally that found through owl:sameAs and RDFS reasoning. We again validate
our extensions by analysis of our corpus, where we show increases in data available to the LTBQE approach 
(1) of 1.02× considering rdfs:seeAlso information as proposed in [9], (2) of 3.8× considering
owl:sameAs and (3) of 2.4× if we apply ρDF reasoning using static schema information. We further generate 
and run queries (of twelve different shapes) live over the Web of Data, comparing six different setups,
and demonstrating improvements for our extensions in the average number of answers generated, albeit at
the cost of accessing more data.

Our source code and stable experimental queries are available at http://code.google.com/p/

lidaq/wiki/Lidaq.

Future Work We plan to extend our entailment rules to cover more of OWL (2) and investigating changes
in recall when considering dynamically dereferenced schema data vs. static schema data. We also plan to
investigate owl:sameAs optimisations for canonicalising equivalent URIs as opposed to materialising all
equivalent data.

References

[1] T. Berners-Lee. Linked Data. Design issues, W3C, 2006.

[2] B. Bishop, A. Kiryakov, D. Ognyanoff, I. Peikov, Z. Tashev, R. Velkov. FactForge: A fast track to the

web of data. Sem. Web J., (to appear), 2011.

[3] B. Bishop, A. Kiryakov, D. Ognyanoff, I. Peikov, Z. Tashev, R. Velkov. OWLIM: A family of scalable

semantic repositories. SWJ, 2(1):33–42, 2011.

14

DERI TR 2011-09-01

[4] C. Bizer, R. Cyganiak, T. Heath. How to Publish Linked Data on the Web. linkeddata.org Tutorial,

July 2008.

[5] P. A. Bonatti, A. Hogan, A. Polleres, L. Sauro. Robust and Scalable Linked Data Reasoning Incorporating 
Provenance and Trust Annotations. JWS, 2011.

[6] O. Erling, I. Mikhailov. RDF Support in the Virtuoso DBMS. Networked Knowledge – Networked

Media, volume 221, p. 7–24. Springer, 2009.

[7] A. Harth, J. Umbrich, A. Hogan, S. Decker. YARS2: A Federated Repository for Querying Graph

Structured Data from the Web. ISWC, 2007.

[8] O. Hartig. Zero-knowledge query planning for an iterator implementation of link traversal based query

execution. ESWC (1), p.154–169, 2011.

[9] O. Hartig, C. Bizer, J.-C. Freytag. Executing sparql queries over the web of linked data. ISWC’09, 2009.

[10] O. Hartig, A. Langegger. A database perspective on consuming linked data on the web. DatenbankSpektrum,
 10(2):57–66, 2010.

[11] P. Hayes. RDF Semantics. W3C Recommendation, Feb. 2004.

[12] T. Heath, C. Bizer. Linked Data: Evolving the Web into a Global Data Space, volume 1. Morgan &

Claypool, 2011.

[13] A. Hogan. Exploiting RDFS and OWL for Integrating Heterogeneous, Large-Scale, Linked Data Corpora.
 PhD thesis, DERI, NUIG, 2011.

[14] G. Ladwig, T. Tran. Linked data query processing strategies. ISWC (1), p. 453–469, 2010.

[15] G. Ladwig, T. Tran. Sihjoin: Querying remote and local linked data. ESWC (1), p. 139–153, 2011.

[16] Y. Li, J. Heﬂin. Using reformulation trees to optimize queries over distributed heterogeneous sources.

ISWC, p. 502–517, 2010.

[17] S. Mu˜noz, J. P´erez, C. Gutierrez. Simple and Efﬁcient Minimal RDFS. J. Web Sem., 7(3):220–234,

2009.

[18] E. Oren, R. Delbru, M. Catasta, R. Cyganiak, H. Stenzhorn, G. Tummarello. Sindice.com: a documentoriented 
lookup index for open linked data. IJMSO, 3(1):37–52, 2008.

[19] E. Prud’hommeaux, A. Seaborne. SPARQL Query Language for RDF. W3C Recommendation, Jan.

2008. http://www.w3.org/TR/rdf-sparql-query/.

[20] B. Quilitz, U. Leser. Querying distributed rdf data sources with sparql. ESWC, p. 524–538, 2008.

[21] H. Stuckenschmidt, R. Vdovjak, G.-J. Houben, J. Broekstra. Index structures and algorithms for querying 
distributed RDF repositories. WWW, 2004.

[22] T. Tran, L. Z. 0007, R. Studer. Summary models for routing keywords to linked data sources. ISWC

(1), p. 781–797, 2010.

DERI TR 2011-09-01

15

[23] J. Umbrich, K. Hose, M. Karnstedt, A. Harth, A. Polleres. Comparing data summaries for processing

live queries over linked data. WWWJ, p. 1–50, 2011.

[24] J. Umbrich, B. Villaz´on-Terrazas, M. Hausenblas. Dataset Dynamics Compendium: A Comparative

Study. COLD Workshop, 2010.

16

DERI TR 2011-09-01

Setup

Results

Time (sec)

First (sec)

HTTP

Retrieved (k)

Inferred (k)

20.19
20.07
20.07
24.53
33.99
45.66

10.68
10.67
10.67
14.72
15.73
21.66

2.54
2.52
2.52
2.77
2.52
2.77

1.87
1.87
1.87
1.91
2.6
2.66

4.64
4.64
4.71
6.13
4.64
6.18

1.76
1.76
1.76
3.48
2.59
15.44

Query class entity-s with 79 queries
(±10.2)
base
(±10.2)
select
(±10.2)
seeAlso
(±24.98)
sameAs
(±11.97)
ρDF
(±40.18)
combined
Query class entity-o with 98 queries
(±3.35)
base
(±3.35)
select
(±3.35)
seeAlso
(±3.42)
sameAs
(±3.35)
ρDF
(±3.54)
combined
Query class entity-so with 70 queries
(±34.99)
base
(±35)
select
(±35)
seeAlso
(±48.76)
sameAs
(±56.32)
ρDF
(±86.07)
combined
Query class s-path-2 with 66 queries
(±1.83)
base
(±1.83)
select
(±1.83)
seeAlso
(±8.26)
sameAs
(±2.64)
ρDF
(±95.93)
combined
Query class o-path-2 with 56 queries
(±3.98)
base
(±3.99)
select
(±3.99)
seeAlso
(±4.05)
sameAs
(±3.99)
ρDF
(±4.05)
combined
Query class s-path-3 with 53 queries
(±1.63)
base
(±1.63)
select
(±1.63)
seeAlso
(±1.63)
sameAs
(±2.28)
ρDF
(±2.28)
combined
Query class o-path-3 with 45 queries
(±11.94)
base
(±11.94)
select
(±11.93)
seeAlso
(±15.41)
sameAs
(±11.94)
ρDF
(±15.4)
combined
Query class star-s3 with 91 queries
(±13.13)
base
(±13.13)
select
(±13.13)
seeAlso
(±13.15)
sameAs
(±75.27)
ρDF
(±75.27)
combined
Query class star-s2-o1 with 80 queries
(±3.16)
base
(±3.16)
select
(±3.16)
seeAlso
(±3.24)
sameAs
(±3.69)
ρDF
(±4.44)
combined
Query class star-s1-o1 with 69 queries
(±4.21)
base
(±4.21)
select
(±4.21)
seeAlso
(±4.21)
sameAs
(±4.31)
ρDF
(±4.31)
combined
Query class star-s1-o2 with 70 queries
(±5.27)
base
(±5.27)
select
(±5.27)
seeAlso
(±7.13)
sameAs
(±5.3)
ρDF
(±7.24)
combined
Query class star-o3 with 71 queries
(±4.54)
(±4.54)
(±4.54)
(±9.4)
(±4.54)
(±9.4)

base
select
seeAlso
sameAs
ρDF
combined

3.45
3.45
3.45
3.57
11.78
11.97

2.81
2.8
2.8
2.85
2.86
3.02

1.71
1.71
1.71
1.96
2.66
3.21

1.55
1.55
1.55
1.55
1.72
1.72

1.77
1.77
1.77
2.4
1.86
2.6

2.56
2.52
2.52
3.56
2.52
3.56

7.97
4.08
3.36
7.27
3.48
33.22

4.08
2.1
2.11
3.38
2.49
2.71

7.83
2.9
2.56
5.25
3.44
36.04

2.49
1.84
2.09
17.41
10.59
17.89

6.21
2.55
2.87
2.68
2.55
3.09

9.77
5.65
6.77
22.79
5.33
7.03

10
6.51
6.76
7.25
6.73
7.26

4.05
2.68
2
3.92
2.24
3.63

4.25
2.52
1.99
2.98
2.3
2.48

2.85
1.43
1.84
2.05
2.83
2.5

3.91
2.35
1.7
2.58
1.85
1.99

4.89
2.49
2.79
2.66
3.11
3.24

(±11.52)
(±11.81)
(±7.66)
(±25.92)
(±9.13)
(±220.89)

(±4.89)
(±2.83)
(±2.71)
(±12.3)
(±4.39)
(±4.88)

(±11.64)
(±3.94)
(±2.61)
(±17.71)
(±4.58)
(±271.09)

(±2)
(±1.74)
(±2.6)
(±79.4)
(±22.48)
(±72.65)

(±9.51)
(±2.06)
(±4.86)
(±2.34)
(±2)
(±4.92)

(±18.93)
(±6.83)
(±12.84)
(±30.3)
(±7.15)
(±13.98)

(±17.18)
(±11.07)
(±10.82)
(±11.64)
(±11.18)
(±10.29)

(±5.99)
(±6.13)
(±3.54)
(±16.77)
(±4.76)
(±14.92)

(±5.85)
(±6.53)
(±2.54)
(±5.64)
(±3.81)
(±3.24)

(±2.75)
(±1.67)
(±2.86)
(±3.93)
(±7.46)
(±5.63)

(±5.76)
(±3.99)
(±1.46)
(±6.21)
(±1.91)
(±2.77)

(±5.3)
(±2.04)
(±2.82)
(±3.28)
(±4.25)
(±4.67)

1.02
1.49
1.03
0.88
0.85
1.14

1.3
1.24
1.2
1.3
1.56
1.74

1.52
1.15
1.02
1.04
1.31
1.34

1.15
0.96
1.05
1.3
5.44
3.05

1.94
1.72
1.4
1.74
1.74
1.64

2.14
2.13
1.93
9.13
1.93
1.77

1.84
1.62
1.6
1.7
1.49
1.74

1.45
2.36
1.63
1.79
1.84
1.69

2
2.21
1.62
2.14
1.95
1.68

1.18
1.08
1.4
1.65
2.28
2.01

1.75
2.03
1.37
1.93
1.52
1.34

2.25
2.2
2.36
1.86
2.77
2.47

(±1.98)
(±6.55)
(±2.53)
(±1.5)
(±1.21)
(±1.81)

(±1.25)
(±1.42)
(±1.45)
(±1.44)
(±3.51)
(±4.15)

(±4.4)
(±1.71)
(±1.21)
(±1.16)
(±2.96)
(±2.45)

(±1.71)
(±1.1)
(±1.39)
(±1.59)
(±15.53)
(±11.43)

(±2.02)
(±1.74)
(±1.04)
(±2.02)
(±1.53)
(±1.5)

(±3.33)
(±3.13)
(±3.14)
(±12.48)
(±2.88)
(±2.96)

(±3.12)
(±1.18)
(±0.99)
(±0.96)
(±0.84)
(±0.94)

(±3.91)
(±6.08)
(±3.51)
(±4.95)
(±4.61)
(±4.27)

(±3.01)
(±6.47)
(±2.53)
(±4.98)
(±3.77)
(±2.19)

(±1.4)
(±1.38)
(±2.75)
(±3.8)
(±7.13)
(±5.45)

(±2.37)
(±3.97)
(±1.45)
(±5.6)
(±1.83)
(±1.12)

(±1.93)
(±1.99)
(±2.84)
(±1.73)
(±4.15)
(±4.05)

17.72
5.33
5.52
13.96
7.25
16.75

6.24
2.29
2.46
2.4
2.29
2.57

16.9
5.09
5.16
9.14
7.3
11.37

5.27
2.32
2.71
6.62
2.35
6.95

7.02
2.55
3.16
2.75
2.55
3.45

7.98
4.11
4.3
4.55
4.19
4.81

11.53
5.42
6.44
5.89
5.42
6.78

7.66
1.35
1.43
2.05
1.35
2.11

6.98
1.58
1.71
2.49
1.58
2.61

5.67
1.39
1.52
1.51
1.39
1.64

6.69
1.67
1.8
2.14
1.67
2.26

8.48
1.89
2.17
2.51
1.89
2.73

(±16.95)
(±11.93)
(±11.97)
(±59.97)
(±12.99)
(±67.43)

(±5.52)
(±3.75)
(±3.91)
(±3.78)
(±3.75)
(±3.93)

(±8.86)
(±5.41)
(±5.57)
(±24.22)
(±7.14)
(±25.25)

(±2.33)
(±1.95)
(±3.06)
(±13.87)
(±1.94)
(±13.54)

(±8.17)
(±1.55)
(±3.11)
(±1.76)
(±1.55)
(±4.43)

(±3.96)
(±3.29)
(±3.24)
(±3.61)
(±3.28)
(±3.68)

(±16.05)
(±5.17)
(±5.82)
(±5.28)
(±5.17)
(±6.5)

(±6.75)
(±0.5)
(±0.6)
(±5.76)
(±0.5)
(±5.76)

(±5.77)
(±0.59)
(±0.77)
(±4.52)
(±0.59)
(±4.63)

(±4.83)
(±0.49)
(±0.63)
(±1.04)
(±0.49)
(±1.1)

(±1.72)
(±0.5)
(±0.65)
(±3.66)
(±0.5)
(±3.78)

(±7.97)
(±0.32)
(±0.76)
(±3.6)
(±0.32)
(±3.86)

3.41
2.26
2.26
10.81
4.91
24.13

1.39
0.31
0.36
0.94
0.65
2.39

1.60
0.43
0.47
3.57
1.64
11.61

0.90
0.26
0.30
10.90
0.61
13.59

1.99
0.16
0.20
0.52
0.40
1.98

3.04
2.26
2.29
7.05
4.19
13.21

3.36
1.52
1.63
5.13
3.14
11.11

1.96
0.35
0.37
2.55
0.78
3.84

1.41
0.14
0.14
1.67
0.35
2.59

1.21
0.45
0.46
1.35
1.13
3.49

1.40
0.1
0.1
1.15
0.24
1.83

2.12
0.16
0.16
1.30
0.29
2.11

(±10.59)
(±10.30)
(±10.30)
(±40.36)
(±18.90)
(±87.03)

(±2.39)
(±1.24)
(±1.28)
(±3.73)
(±2.28)
(±7.18)

(±2.62)
(±0.53)
(±0.60)
(±11.34)
(±2.03)
(±44.43)

(±0.66)
(±0.54)
(±0.59)
(±46.04)
(±1.15)
(±51.97)

(±3.60)
(±0.25)
(±0.41)
(±0.77)
(±0.53)
(±5.93)

(±6.67)
(±6.52)
(±6.51)
(±19.51)
(±11.59)
(±34.69)

(±4.77)
(±3.39)
(±3.44)
(±10.26)
(±7.10)
(±23.15)

(±7.58)
(±1.52)
(±1.52)
(±14.01)
(±3.03)
(±15.33)

(±3.10)
(±0.31)
(±0.31)
(±7.47)
(±0.60)
(±9.11)

(±2.61)
(±2.58)
(±2.58)
(±7.75)
(±4.89)
(±14.70)

(±1.68)
(±0.11)
(±0.11)
(±7.12)
(±0.25)
(±8/74)

(±3.47)
(±0.23)
(±0.24)
(±7.14)
(±0.55)
(±8.93)

0
0
0
8.16
4.05
33.70

0
0
0
3.13
0.42
4.61

0
0
0
3.84
1.18
41.74

0
0
0
27.41
0.38
34.84

0
0
0
0.01
0.24
0.46

0
0
0
0.06
2.02
2.13

0
0
0
0.15
2.85
3.99

0
0
0
3.70
0.43
4.93

0
0
0.01
1.27
0.22
1.74

0
0
0
0.01
0.71
0.72

0
0
0
0.87
0.17
1.14

0
0
0
0.88
0.19
1.20

(±0)
(±0)
(±0)
(±45.10)
(±19.79)
(±220.28)

(±0)
(±0)
(±0)
(±0.02)
(±1.42)
(±1.25)

(±0)
(±0)
(±0)
(±21.65)
(±1.62)
(±32.78)

(±0)
(±0)
(±0)
(±146.68)
(±0.68)
(±17.23)

(±0)
(±0)
(±0)
(±0.06)
(±0.31)
(±1.59)

(±0)
(±0)
(±0)
(±0.25)
(±5.28)
(±5.17)

(±0)
(±0)
(±0)
(±0.49)
(±7.20)
(±5.20)

(±0)
(±0)
(±0)
(±34.99)
(±1.51)
(±42.49)

(±0)
(±0)
(±0.01)
(±7.84)
(±0.32)
(±9.22)

(±0)
(±0)
(±0)
(±0.02)
(±2.64)
(±2.60)

(±0)
(±0)
(±0)
(±7.21)
(±0.12)
(±8.12)

(±0)
(±0)
(±0)
(±7.16)
(±0.38)
(±8.07)

Table 3: Benchmark results with mean and standard deviation.

