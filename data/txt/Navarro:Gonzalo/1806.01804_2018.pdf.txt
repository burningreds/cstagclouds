Tree Path Majority Data Structures ∗
Travis Gagie1, Meng He2, and Gonzalo Navarro3

1 CeBiB — Center for Biotechnology and Bioengineering, Chile; School of

Computer Science and Telecommunications, Diego Portales University, Chile.
travis.gagie@gmail.com
Faculty of Computer Science, Dalhousie University, Canada. mhe@cs.dal.ca
2
3 CeBiB — Center for Biotechnology and Bioengineering, Chile; Millenium

Institute for Foundational Research on Data, Chile; Department of Computer
Science, University of Chile, Chile. gnavarro@dcc.uchile.cl

8
1
0
2

 

n
u
J
 

5

 
 
]
S
D
.
s
c
[
 
 

1
v
4
0
8
1
0

.

6
0
8
1
:
v
i
X
r
a

Abstract

We present the ﬁrst solution to τ-majorities on tree paths. Given a tree of n nodes, each with a
label from [1..σ], and a ﬁxed threshold 0 < τ < 1, such a query gives two nodes u and v and asks
for all the labels that appear more than τ · |Puv| times in the path Puv from u to v. Note that
the answer to any query is of size up to 1/τ. On a w-bit RAM machine, we obtain a linear-space
data structure that lists all the majorities in time O((1/τ) lg∗ n lg lgw σ). For any κ > 1, we can
also build a data structure that uses O(n lg[κ] n) space, where lg[κ] n is the iterated logarithm,
and answers queries in time O((1/τ) lg lgw σ). The construction time of both data structures is
O(n lg n). We also describe succinct-space solutions, both reaching the same query time of the
linear-space structure. One uses 2nH +4n+o(n)(H +1) bits, where H ≤ lg σ is the entropy of the
distribution of labels in T, and can be built in O(n lg n) time. The other uses nH + O(n)+ o(nH)
bits and is built in O(n lg n) randomized time.

1998 ACM Subject Classiﬁcation E.1 Data Structures; E.4 Coding and Information Theory

Keywords and phrases Majorities on Trees; Succinct data structures

Digital Object Identiﬁer 10.4230/LIPIcs...

Introduction

1
Finding frequent elements in subsets of a multiset is a fundamental operation for data analysis
and data mining [15, 13]. When the sets have a certain structure, it is possible to preprocess
the multiset to build data structures that eﬃciently ﬁnd the frequent elements in any subset.
The best studied multiset structure is the sequence, where the subsets that can be queried
are ranges (i.e., contiguous subsequences) of the sequence. Applications of this case include
time sequences, linear-versioned structures, and one-dimensional models, for example. Data
structures for ﬁnding the mode (i.e., the most frequent element) in a range require time

O(pn/ lg n), and it is unlikely that this can be done much better within reasonable extra

space [8]. Instead, listing all the elements whose relative frequency in a range is over some
fraction τ (called the τ-majorities of the range) is feasible within linear space and O(1/τ)
time, which is worst-case optimal [1]. Mode and τ-majority queries on higher-dimensional
arrays have also been studied [16, 8].

In this paper we focus on ﬁnding frequent elements when the subsets that can be queried
are the labels on paths from one given node to another in a labeled tree. For example, given a

∗ Funded with basal funds FB0001, Conicyt, Chile, by Millenium Institute for Foundational Research on

Data, Chile, and by NSERC, Canada.

© Travis Gagie, Meng He, Gonzalo Navarro;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

XX:2

Tree Path Majority Data Structures

minimum spanning tree of a graph, we might be interested in frequent node types on the path
between two nodes. Path mode or τ-majority queries on multi-labeled trees could be useful
when handling the tree of versions of a document or a piece of software, or a phylogenetic
tree (which is essentially a tree of versions of a genome). If each node stores a list of the
sections (i.e., chapters, modules, genes) on which its version diﬀers from its parent’s, then we
can eﬃciently query which sections are changed most frequently between two given versions.
There has been relatively little work previously on ﬁnding frequent elements on tree
n lg n). This was

recently improved by Durocher et al. [14], who obtained O(pn/w lg lg n) time on a RAM

paths. Krizanc et al. [18] considered path mode queries, obtaining time O(

√

machine of w = Ω(lg n) bits. Like on the more particular case of sequences, these times are
not likely to improve much. No previous work has considered the problem of ﬁnding path
τ-majority queries, which is more tractable than ﬁnding the path mode. This is our focus.
We present the ﬁrst data structures to support path τ-majority queries on trees of n
nodes, with labels in [1..σ], on a RAM machine. We ﬁrst obtain a data structure using
O(n lg n) space and O((1/τ) lg lgw σ) time (Theorem 3). Building on this result, we reduce the
space to O(n) at the price of a very slight increase in the query time, O((1/τ) lg∗ n lg lgw σ)
(Theorem 6). We then show that the original query time can be obtained within very slightly
superlinear space, O(n lg[κ] n) for any desired κ > 1, where lg[κ] n is the iterated logarithm
(Theorem 7). Finally, we show that our linear-space data structure can be further compressed,
to either 2nH + 4n + o(n)(H + 1) bits or nH + O(n) + o(nH) bits, where H ≤ lg σ is the
entropy of the distribution of the labels in T, while retaining the same query times of the
linear-space data structure (Theorems 8 and 9). All our structures can be built in O(n lg n)
deterministic time; only the latter one requires O(n) additional randomized time. We close
with a brief discussion of directions for future research. In particular, we describe how to
adapt our results to multi-labeled trees.

Durocher et al. [14] also considered queries that look for the least frequent elements and
τ-minorities on paths. In the appendix, we show how to compress their data structure for
τ-minorities with only a very slight increase in query time.

2

Preliminaries

2.1 Deﬁnitions
We deal with rooted ordinal trees (or just trees) T. Further, our trees are labeled, that is,
each node u of T has an integer label label(u) ∈ [1..σ]. We assume that, if our main tree
has n nodes, then σ = O(n) (we can always remap the labels to a range of size at most n
without altering the semantics of the queries of interest in this paper).

The path between nodes u and v in a tree T is the (only) sequence of nodes Puv = hu =
z1, z2, . . . , zk−1, zk = vi such that there is an edge in T between each pair zi and zi+1, for
1 ≤ i < k. The length of the path is |Puv| = k, for example the length of the path Puu is 1.
Any path from u to v goes from u to the lowest common ancestor of u and v, and then from
there it goes to v (if u is an ancestor of v or vice versa, one of these two subpaths is empty).
Given a real number 0 < τ < a, an τ-majority of the path Puv is any label that appears
(strictly) more than τ ·|Puv| times among the labels of the nodes in Puv. The path τ-majority
problem is, given u and v, list all the τ-majorities in the path Puv. Note that there can be
up to b1/τc such τ-majorities.

Our results hold in the RAM model of computation, assuming a computer word of

w = Ω(lg n) bits, supporting the standard operations.

Travis Gagie, Meng He, and Gonzalo Navarro

XX:3

Our logarithms are to the base 2 by default. By lg[k] n we mean the iterated logarithm,
lg[0] n = n and lg[k+1] n = lg(lg[k] n). By lg∗ n we denote the minimum k such that lg[k] n ≤ 1.

2.2 Sequence representations
A bitvector B[1..n] can be represented within n + o(n) bits so that the following operations
take constant time: access(B, i) returns B[i], rankb(B, i) returns the number of times bit b
appears in B[1..i], and selectb(B, j) returns the position of the jth occurrence of b in B
[12]. If B has m 1s, then it can be represented within m lg(n/m) + O(m) bits while retaining
the same operation times [22]. Those structures can be built in linear time. Note the space
is o(n) bits if m = o(n).

Analogous operations are deﬁned on sequences S[1..n] over alphabets [1..σ]. For example,
one can represent S within nH + o(n)(H + 1) bits, where H ≤ lg σ is the entropy of the
distribution of symbols in S, so that rank takes time O(lg lgw σ), access takes time O(1), and
select takes any time in ω(1) [4, Thm. 8]. The construction takes linear time. While this rank
time is optimal, we can answer partial rank queries in O(1) time, prank(S, i) = rankS[i](S, i),
by adding O(n(1 + lg H)) bits on top of a representation giving constant-time access [3,
Sec. 3]. This construction requires linear randomized time.

2.3 Range τ-majorities on sequences
A particular version of the path τ-majority queries on trees is range τ-majority queries on
sequences S[1..n], which are much better studied. Given i and j, the problem is to return all
the distinct symbols that appear more than τ · (j − i + 1) times in S[i..j]. The most recent
result on this problem [2, 1] is a linear-space data structure, built in O(n lg n) time, that
answers queries in the worst-case optimal time, O(1/τ).

For our succinct representations, we also use a data structure [1, Thm. 6] that requires
nH + o(n)(H + 1) bits, and can answer range τ-majority queries in any time in (1/τ) · ω(1).
The structure is built on the sequence representation mentioned above [4, Thm. 8], and thus
it includes its support for access, rank, and select queries on the sequence. To obtain
the given times for τ-majorities, the structure includes the support for partial rank queries
[3, Sec. 3], and therefore its construction time is randomized. In this paper, however, it
will be suﬃcient to obtain O((1/τ) lg lgw σ) time, and therefore we can replace their prank
queries by general rank operations. These take time O(lg lgw σ) instead of O(1), but can be
built in linear time.1 Therefore, this slightly slower structure can also be built in O(n lg n)
deterministic time.

When a set has no structure, we can ﬁnd its τ-majorities in linear time. Misra and
Gries [19] proposed an optimal solution that computes all τ-majorities using O(n lg(1/τ))
comparisons. When implemented on a word RAM over an integer alphabet of size σ, the
running time becomes O(n) [13].

2.4 Tree operations
For tree nodes u and v, we deﬁne the operations root (the tree root), parent(u) (the parent
of node u), depth(u) (the depth of node u, 0 being the depth of the root), preorder(u) (the
rank of u in a preorder traversal of T), postorder(u) (the rank of u in a postorder traversal

1 In fact, their structure [1] can be considerably simpliﬁed if one can spend the time of a general rank

query per returned majority.

XX:4

Tree Path Majority Data Structures

of T), subtreesize(u) (the number of nodes descending from u, including u), anc(u, d)
(the ancestor of u at depth d), and lca(u, v) (the lowest common ancestor of u and v). All
those operations can be supported in constant time and linear space on a static tree after a
linear-time preprocessing, trivially with the exceptions of anc [6] and lca [7].

A less classical query is labelanc(u, ‘), which returns the nearest ancestor of u (possibly
u itself) labeled ‘ (note that the label of u needs not be ‘). If u has no ancestor labeled ‘,
labelanc(u, ‘) returns null. This operation can be solved in time O(lg lgw σ) using linear
space and preprocessing time [17, 25, 14].

2.5 Succinct tree representations
A tree T of n nodes can be represented as a sequence P[1..2n] of parentheses (i.e., a bit
sequence). In particular, we consider the balanced parentheses representation, where we
traverse T in depth-ﬁrst order, writing an opening parenthesis when reaching a node and a
closing one when leaving its subtree. A node is identiﬁed with the position P[i] of its opening
parenthesis. By using 2n + o(n) bits, all the tree operations deﬁned (except those on labels)
can be supported in constant time [21].

This representation also supports access, rank and select on the bitvector of parentheses,
and the operations close(P, i) (the position of the parenthesis closing the one that opens at
P[i]), open(P, i) (the position of the parenthesis opening the one that closes at P[i]), and
enclose(P, i) (the rightmost position of a parenthesis enclosing P[i], i.e., its parent).

Labeled trees can be represented within nH + 2n + o(n)(H + 1) bits by adding the
sequence S[1..n] of the node labels in preorder, so that label(i) = access(S, preorder(i)).

An O(n lg n)-Space Solution

3
In this section we design a data structure answering path τ-majority queries on a tree of n
nodes using O(n lg n) space and O(lg lgw σ) time. This is the basis to obtain our ﬁnal results.
We start by marking O(τ n) tree nodes, in a way that any node has a marked ancestor at
distance O(1/τ). A simple way to obtain these bounds is to mark every node whose height
is ≥ d1/τe and whose depth is a multiple of d1/τe. Therefore, every marked node is the
nearest marked ancestor of at least d1/τe − 1 distinct non-marked nodes, which guarantees
that there are ≤ τ n marked nodes. On the other hand, any node is at distance at most
2d1/τe − 1 from its nearest marked ancestor.

For each marked node x, we will consider preﬁxes Pi(x) of the labels in the path from x

to the root, of length 2i, that is,

Pi(x) = hlabel(x), label(parent(x)), label(parent2(x)), . . . , label(parent2i(x))i

(terminating the sequence at the root if we reach it). For each 0 ≤ i ≤ dlg depth(x)e, we
store Ci(x), the set of (τ /2)-majorities in Pi(x). Note that |Ci(x)| ≤ 2/τ for any x and i.
By successive applications of the next lemma we have that, to ﬁnd all the τ-majorities in
the path from u to v, we can partition the path into several subpaths and then consider just
the τ-majorities in each subpath.
(cid:73) Lemma 1. Let u and v be two tree nodes, and let z be an intermediate node in the path.
Then, a τ-majority in the path from u to v is a τ-majority in the path from u to z (including
z) or a τ-majority in the path from z to v (excluding z), or in both.
Proof. Let duz be the distance from u to z (counting z) and dzv be the distance from z to v
(not counting z). Then the path from u to v is of length d = duz + dzv. If a label ‘ occurs

Travis Gagie, Meng He, and Gonzalo Navarro

XX:5

≤ τ · duz times in the path from u to z and ≤ τ · dzv times in the path from z to v, then it
occurs ≤ τ(duz + dzv) = τ · d times in the path from u to v.
(cid:74)

Let us now show that the candidates we record for marked nodes are suﬃcient to ﬁnd

path τ-majorities towards their ancestors.
(cid:73) Lemma 2. Let x be a marked node. All the τ-majorities in the path from x to a proper
ancestor z are included in Ci(x) for some suitable i.
Proof. Let dxz = depth(x) − depth(z) be the distance from x to z (i.e., the length of the
path from x to z minus 1). Let i = dlg dxze. The path Pi(x) contains all the nodes in an
upward path of length 1 + 2i starting at x, where dxz ≤ 2i < 2dxz. Therefore, Pi(x) contains
node z, but its length is |Pi(x)| < 1 + 2dxz. Therefore, any τ-majority in the path from x
to z appears > τ · (1 + dxz) > (τ /2) · (1 + 2dxz) > (τ /2) · |Pi(x)| times, and thus it is an
(cid:74)
(τ /2)-majority recorded in Ci(x).

3.1 Queries
With the properties above, we can ﬁnd a candidate set of size O(1/τ) for the path τ-majority
If v 6= z, let us also deﬁne
between arbitrary tree nodes u and v. Let z = lca(u, v).
z0 = anc(v, depth(z) + 1), that is, the child of z in the path to v. The path is then split into
at most four subpaths, each of which can be empty:
1. The nodes from u to its nearest marked ancestor, x, not including x. If x does not exist
or it is a proper ancestor of z, then this subpath contains the nodes from u to z. This
path is of length < 2d1/τe by the deﬁnition of marked nodes, and it is empty if u = x.
2. The nodes from v to its nearest marked ancestor, y, not including y. If y does not exist
or it is an ancestor of z, then this subpath contains the nodes from v to z0. This path is
of length < 2d1/τe by the deﬁnition of marked nodes, and it is empty if v = y or v = z.

3. The nodes from x to z. This path exists only if x exists and descends from z.
4. The nodes from y to z0. This path exists only if y exists and descends from z0.

By Lemma 1, any τ-majority in the path from u to v must be a τ-majority in some of
these four paths. For the paths 1 and 2, we consider all their up to 2d1/τe − 1 nodes as
candidates. For the paths 3 and 4, we use Lemma 2 to ﬁnd suitable values i and j so that
Ci(x) and Cj(y), both of size at most 2/τ, contain all the possible τ-majorities in those paths.
In total, we obtain a set of at most 8/τ + O(1) candidates that contain all the τ-majorities
in the path from u to v.

In order to check candidates, we follow the technique of Durocher et al. [14]. Every tree
node u will store count(u), the number of times its label occurs in the path from u to the
root. We also make use of operation labelanc(u, ‘). If u has no ancestor labeled ‘, this
operation returns null, and we understand that count(null) = 0. Therefore, the number of
times label ‘ occurs in the path from u to an ancestor z of u (including z), can be computed
as count(labelanc(u, ‘))−count(labelanc(parent(z), ‘)). Each of our candidates can then
be checked by counting their occurrences in the path from u to v using

(count(labelanc(u, ‘)) − count(labelanc(parent(z), ‘)))
+ (count(labelanc(v, ‘)) − count(labelanc(z, ‘))).

The time to perform query labelanc is O(lg lgw σ) using a linear-space data structure on
the tree [17, 25, 14], and therefore we ﬁnd all the path τ-majorities in time O((1/τ) lg lgw σ).

XX:6

Tree Path Majority Data Structures

The space of our data structure is dominated by the O(lg n) candidate sets Ci(x) we
store for the marked nodes x. These amount to O((1/τ) lg n) space per marked node, of
which there are O(τ n). Thus, we spend O(n lg n) space in total.
(cid:73) Theorem 3. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On a RAM
machine of w-bit words, we can build an O(n lg n) space data structure that answers path
τ-majority queries in time O((1/τ) lg lgw σ).

3.2 Construction
The construction of the data structure is easily carried out in linear time (including the ﬁelds
count and the data structure to support labelanc [14]), except for the candidate sets Ci(x)
of the marked nodes x. We can compute the sets Ci(x) for all i in total time O(depth(x))
using the linear-time algorithm of Misra and Gries [19] because we compute (τ /2)-majorities
of doubling-length preﬁxes Pi(x). This amounts to time O(mt) on a tree of t nodes and m
marked nodes. In our case, where t = n and m ≤ τ n, this is O(τ n2).

To reduce this time, we proceed as follows. First we build all the data structure components
except the sets Ci(x). We then decompose the tree into heavy paths [24] in linear time,
and collect the labels along the heavy paths to form a set of sequences. On the sequences,
we build in O(t lg t) time the range τ-majority data structure [2, 1] that answers queries in
time O(1/τ). The preﬁx Pi(x) for any marked node x then spans O(lg t) sequence ranges,
corresponding to the heavy paths intersected by Pi(x). We can then compute Ci(x) by
collecting and checking the O(1/τ) (τ /2)-majorities from each of those O(lg t) ranges.

Let the path from x to the root be formed by O(lg t) heavy path segments P1, . . . , Pk
We ﬁrst compute the O(1/τ) (τ /2)-majority in the sequences corresponding to each preﬁx
P1, . . . , Pi: For each Pi, we (1) compute its 2/τ majorities on the corresponding sequence in
time O(1/τ), (2) add them to the set of 2/τ majorities already computed for P1, . . . , Pi−1,
and (3) check the exact frequencies of all the 4/τ candidates in the path P1, . . . , Pi in time
O((1/τ) lg lgw σ), using the structures already computed on the tree. All the (τ /2)-majorities
for P1, . . . , Pi are then found.

Each path Pi(x) is formed by some preﬁx P1, . . . , Pi plus a preﬁx of Pi+1. We can then
carry out a process similar to the one to compute the majorities of P1, . . . , Pi+1, but using
only the proper preﬁx of Pi+1. The O(lg t) sets Ci(x) are then computed in total time
O((1/τ) lg t lg lgw σ). Added over the m marked nodes, we obtain O((1/τ)m lg t lg lgw σ)
construction time.
(cid:73) Lemma 4. On a tree of t nodes, m of which are marked, all the candidate sets Ci(x) can
be built in time O((1/τ)m lg t lg lgw σ).

The construction time in our case, where t = n and m ≤ τ n, is the following.

(cid:73) Corollary 5. The data structure of Theorem 3 can be built in time O(n lg n lg lgw σ).

4

A Linear-Space (and a Near-Linear-Space) Solution

We can reduce the space of our data structure by stratifying our tree. First, let us create a
separate structure to handle unary paths, that is, formed by nodes with only one child. The
labels of upward maximal unary paths are laid out in a sequence, and the sequences of the
labels of all the unary paths in T are concatenated into a single sequence, S, of length at most
n. On this sequence we build the linear-space data structure that solves range τ-majority

Travis Gagie, Meng He, and Gonzalo Navarro

XX:7

queries in time O(1/τ) [2, 1]. Each node in a unary path of T points to its position in S.
Each node also stores a pointer to its nearest branching ancestor.

The stratiﬁcation then proceeds as follows. We say that a tree node is large if it has more
than (1/τ) lg n descendant nodes; other nodes are small. Then the subset of the large nodes,
which is closed by parent, induces a subtree T 0 of T with the same root and containing
at most τ n/ lg n leaves, because for each leaf in T 0 there are at least (1/τ) lg n − 1 distinct
nodes of T not in T 0. Further, T − T 0 is a forest of trees {Fi}, each of size at most (1/τ) lg n.
We will use for T 0 a structure similar to the one of Section 3, with some changes to ensure
linear space. Note that T 0 may have Θ(n) nodes, but since it has at most τ n/ lg n leaves, T 0
has only O(τ n/ lg n) branching nodes (i.e., nodes with more than one child). We modify the
marking scheme, so that we mark exactly the branching nodes in T 0. Spending O((1/τ) lg n)
space of the candidate sets Ci(x) over all branching nodes of T 0 adds up to O(n) space.

The procedure to solve path τ-majority queries on T 0 is then as follows. We split the
path from u to v into four subpaths, exactly as in Section 3. The subpaths of type 1 and 2
can now be of arbitrary length, but they are unary, thus we obtain their 1/τ candidates in
time O(1/τ) from the corresponding range of S. Finally, we check all the O(1/τ) candidates
in time O((1/τ) lg lgw σ) as in Section 3.
The nodes u and v may, however, belong to some small tree Fi, which is of size
O((1/τ) lg n). We preprocess all those Fi in a way analogous to T 0. From each Fi we
deﬁne F 0
i as the subtree of Fi induced by the (parent-closed) set of the nodes with more than
i has O(|Fi|τ / lg lg n) branching nodes, which are marked.
(1/τ) lg lg n descendants; thus F 0
We store the candidate sets Ci(x) of their marked nodes x, considering only the nodes in F 0
i.
If the candidates were stored as in Section 3, they would require O((1/τ) lg σ) bits
per marked node.
Instead of storing the candidate labels ‘ directly, however, we will
store depth(y), where y is the nearest ancestor of x with label ‘. We can then recover
‘ = label(anc(x, depth(y))) in constant time. Since the depths in Fi are also O((1/τ) lg n),
we need only O(lg((1/τ) lg n)) bits per candidate. Further, by sorting the candidates by their
depth(y) value, we can encode only the diﬀerences between consecutive depths using γ-codes
[5]. Encoding k increasing numbers in [1..m] with this method requires O(k lg(m/k)) bits;
therefore we can encode our O(1/τ) candidates using O((1/τ) lg lg n) bits in total. Added
over all the O(lg n) values of i,2 the candidates Ci(x) require O((1/τ) lg lg n) words per
marked (i.e., branching) node. Added over all the branching nodes of F 0
i, this amounts to
O(|F 0
i|) space. The other pointers of Fi, as well as node labels, can be represented normally,
as they are O(n) in total.

The small nodes left out from the trees Fi form a forest of subtrees of size O((1/τ) lg lg n)
each. We can iterate this process κ times, so that the smallest trees are of size O((1/τ) lg[κ] n).
We build no candidates sets on the smallest trees. We say that T 0 is a subtree of level 1, our
F 0
i are subtrees of level 2, and so on, until the smallest subtrees, which are of level κ. Every
node in T has a pointer to the root of the subtree where it belongs in the stratiﬁcation.

The general process to solve a path τ-majority query from u to v is then as follows.
We compute z = lca(u, v) and split the path from u to z into k − k0 + 1 subpaths, where
k0 ≤ k ≤ κ are the levels of the subtree where z and u belong, respectively. Let us call ui
the root of the subtree of level i that is an ancestor of u, except that we call uk0 = z.
1.

If k = κ, then u belongs to one of the smallest subtrees. We then collect the O((1/τ) lg[κ] n)
candidates in the path from u to uκ, one by one, and then move to the parent of that

2 The values of i are also bounded by O(lg((1/τ) lg n)), but the bound O(lg n) = O(w) is more useful this

time.

XX:8

Tree Path Majority Data Structures

root, setting u ← parent(uκ) and k ← κ − 1.

2. At levels k0 ≤ k < κ, if u is a branching node, we collect the 2/τ candidates from the
corresponding set Ci(u), where i is suﬃcient to cover uk (Ci(u) will not store candidates
beyond the subtree root). We then set u ← parent(uk) and k ← k − 1.
3. At levels k0 ≤ k < κ, if u is not a branching node, let x be lowest between parent(z) and
the nearest branching ancestor of u. Let also p be the position of u in S. Then we ﬁnd the
1/τ τ-majorities in S[p..p + depth(u) − depth(x) − 1] in time O(1/τ). We then continue
from u ← x and k ← k(x), where k(x) is the level of the subtree where x belongs. Note
that k(x) can be the same k, but it can also be any other level k0 ≤ k(x) < k.

4. We stop when u = parent(z).

A similar procedure is followed to collect the candidates from v to z0. In total, since each
path has at most one case 2 and one case 3 per level k, we collect at most 4κ candidate sets
of size O(1/τ), plus two of size O((1/τ) lg[κ] n). The total cost to verify all the candidates is
then O((1/τ)(κ + lg[κ] n) lg lgw σ). The data structure uses linear space for any choice of κ,
whereas the optimal time is obtained by setting κ = lg∗ n.

The construction time, using the technique of Lemma 4 in level 1, is O(n lg lgw σ), since
T 0 has t = O(n) nodes and m = O(τ n/ lg n) marked nodes. For higher levels, we use the
basic quadratic method described in the ﬁrst lines of Section 3.2: a subtree F of level k
has t = O((1/τ) lg[k−1] n) nodes and m = O(τ t/ lg[k] n) marked nodes, so it is built in time
O(mt). There are O(τ n/ lg[k−1] n) trees of level k, which gives a total construction time of
O(n lg[k−1] n/ lg[k] n) for all the nodes in level k. Added over all the levels k > 1, this yields
O(n lg n/ lg lg n). Both times, for k = 1 and k > 1, are however dominated by the O(n lg n)
time to build the range majority data structure on S.
(cid:73) Theorem 6. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On a RAM
machine of w-bit words, we can build in O(n lg n) time an O(n) space data structure that
answers path τ-majority queries in time O((1/τ) lg∗ n lg lgw σ).

On the other hand, we can use any constant number κ of levels, and build the data
structure of Section 3 on the last one, so as to ensure query time O(1/τ) in this level as well.
We use, however, the compressed storage of the candidates used in this section. With this
storage format, a candidate set Ci(x) takes O((1/τ) lg[κ] n) bits. Multiplying by lg n (the
crude upper bound on the number of i values), this becomes O((1/τ) lg[κ] n) words. Since the
trees are of size O((1/τ) lg[κ−1] n) and the sampling rate used in Section 3 is τ, this amounts
to O((1/τ) lg[κ−1] n lg[κ] n) space per tree. Multiplied by the O(τ n/ lg[κ−1] n) trees of level κ,
the total space is O(n lg[κ] n).

The construction time of the candidate sets in the last level, using the basic quadratic
construction, is O(mt) = O((1/τ)(lg[κ−1] n)2), because t = O((1/τ) lg[κ−1] n) and m = τ t
according to the sampling used in Section 3. Multiplying by the O(τ n/ lg[κ−1] n) trees of
level κ, the total construction time for this last level is O(n lg[κ−1] n), again dominated by
the time to build the range majority data structures if κ > 1. This yields the following result.
(cid:73) Theorem 7. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On a RAM
machine of w-bit words, for any constant κ > 1, we can build in O(n lg n) time an O(n lg[κ] n)
space data structure that answers path τ-majority queries in time O((1/τ) lg lgw σ).

A Succinct Space Solution

5
The way to obtain a succinct space structure from Theorem 6 is to increase the thresholds
that deﬁne the large nodes in Section 4. In level 1, we now deﬁne the large nodes as those

Travis Gagie, Meng He, and Gonzalo Navarro

XX:9

whose subtree size is larger than (1/τ)(lg n)3; in level 2, larger than (1/τ)(lg lg n)3; and in
general in level k as those with subtree size larger than (1/τ)(lg[k] n)3. This makes the space
of all the Ci(x) structures to be o(n) bits. The price is that the traversal of the smallest trees
now produces O((1/τ)(lg[κ] n)3) candidates, but this is easily sorted out by using κ + 1 levels,
since (lg[κ+1] n)3 = o(lg[κ] n). To obtain succinct space, we will need that there are o(n)
subtrees of the smallest size, but that we ﬁnd only O((1/τ) lg∗ n) candidates in total. Thus
we set κ = lg∗ n − lg∗∗ n, so that there are O(κ) = O(lg∗ n) levels, and the last-level subtrees
are of size O((1/τ)(lg[κ+1] n)3) = o((1/τ) lg[lg∗ n−lg∗∗ n] n) = o((1/τ) lg∗ n). Still, there are
O(τ n/(lg[κ+1] n)3) = O(τ n/(lg[lg∗ n−lg∗∗ n+1] n)3) = O(τ n/(lg lg∗ n)3) = o(n) subtrees in the
last level.

The topology of the whole tree T can be represented using balanced parentheses in
2n + o(n) bits, supporting in constant time all the standard tree traversal operations we
use [21]. We assume that open and close parentheses are represented with 1s and 0s in P,
respectively. Let us now focus on the less standard operations needed.

5.1 Counting labels in paths
In Section 3, we count the number of times a label ‘ occurs in the path from u to the root
by means of a query labelanc and by storing count ﬁelds in the nodes. In Section 4, we
use in addition a string S to support range majority queries on the unary paths.

To solve labelanc queries, we use the representation of Durocher et al. [14, Lem. 7],
which uses nH + 2n + o(n)(H + 1) bits in addition to the 2n + o(n) bits of the tree topology.
This representation includes a string S[1..n] where all the labels of T are written in preorder;
any implementation of S supporting access, rank, and select in time O(lg lgw σ) can be
used (e.g., [4]). This string can also play the role of the one we call S in Section 4, because
the labels of unary paths are contiguous in S, and any node v can access its label from
S[preorder(v)].

On top of this string we must also answer range τ-majority queries in time O((1/τ) lg lgw σ).
We can use the slow variant of the succinct structure described in Section 2.3, which requires
only o(n)(H +1) additional bits and also supports access in O(1) time and rank and select
in time O(lg lgw σ). This variant of the structure is built in O(n lg n) time.

In addition to supporting operation labelanc, we need to store or compute the count
ﬁelds. Durocher et al. [14] also require this ﬁeld, but ﬁnd no succinct way to represent it.
We now show a way to obtain this value within succinct space.

The sequence S lists the labels of T in preorder, that is, aligned with the opening
parentheses of P. Assume we have another sequence S0[1..n] where the labels of T are listed
in postorder (i.e., aligned with the closing parentheses of P). Since the opened parentheses
not yet closed in P[1..i] are precisely node i and its ancestors, we can compute the number
of times a label ‘ appears in the path from P[i] to the root as

rank‘(S, rank1(P, i)) − rank‘(S0, rank0(P, i)).

Therefore, we can support this operation with nH + o(n)(H + 1) additional bits. Note
that, with this representation, we do not need the operation labelanc, since we do not need
that P[i] itself is labeled ‘.

If we do use operation labelanc, however, we can ensure that P[i] is labeled ‘, and
another solution is possible based on partial rank queries. Let o = rank‘(S, rank1(P, i))
and c = rank‘(S0, rank0(P, i)) be the opening and closing parentheses up to P[i], so that
we want to compute o − c. Since P[i] is labeled ‘, it holds that S[rank1(P, i))] = ‘, and
thus o = prank(S, rank1(P, i)). To compute c, we do not store S0, but rather S00[1..2n], so

XX:10 Tree Path Majority Data Structures

that S00[i] is the label of the node whose opening or closing parenthesis is at P[i] (i.e., S00 is
formed by interleaving S and S0). Then, prank(S00, i) = o + c; therefore the answer we seek
is o − c = 2 · prank(S, rank1(P, i)) − prank(S00, i).

We use the structure for constant-time partial rank queries [3, Sec. 3] that requires
O(n) + o(nH) bits on top of a sequence that can be accessed in O(1) time. We can build it
on S and also on S00, though we do not explicitly represent S00: any access to S00 is simulated
in constant time with S00[i] = S[rank1(P, i)] if P[i] = 1, and S00[i] = S[rank1(P, open(P, i))]
otherwise. This partial rank structure is built in O(n) randomized time.

5.2 Other data structures
The other ﬁelds stored at tree nodes, which we must now compute within succinct space, are
the following:

Pointers to candidate sets Ci(x)
All the branching nodes in all subtrees except those of level κ + 1 are marked, thus there
are O(n/(lg[κ+1] n)3) = o(n) such nodes. We can then mark their preorders with 1s in a
bitvector M[1..n]. Since M has o(n) 1s, it can be represented within o(n) bits [22] while
supporting constant-time rank and select operations. We can then ﬁnd out when a node
i is marked (iﬀ M[preorder(i)] = 1), and if it is, its rank among all the marked nodes,
r = rank1(M, preorder(i)). The Ci(x) sets of all the marked nodes x of any level can be
written down in a contiguous memory area of total size o(n) bits, sorted by the preorder of x.
A bitvector C of length o(n) marks the starting position of each new node x in this memory
area. Then the area for marked node i starts at p = select1(C, r). A second bitvector D
can mark the starting position of each Cj(x) in the memory area of each node x, thus we
access the speciﬁc set Cj(x) from position select1(D, rank1(D, p − 1) + j).

Pointers to subtree roots
We store an additional bitvector B[1..2n], parallel to the parentheses bitvector P[1..2n]. In
B, we mark with 1s the positions of the opening and closing parentheses that are roots of
subtrees of any level. As there are O(n/(lg[κ+1] n)3) = o(n) such nodes, B can be represented
within o(n) bits while supporting constant-time rank and select operations. We also store
the sequence of o(n) parentheses P 0 corresponding to those in P marked with a 1 in B. Then
the nearest subtree root containing node P[i] is obtained by ﬁnding the nearest position
to the left marked in B, r = rank1(B, i) and j = select1(B, r), and then considering the
corresponding node P 0[r]. If it is an opening parenthesis, then the nearest subtree root is
the node whose parenthesis opens in P[j]. Otherwise, it is the one opening at P[j0], where
j0 = select1(B, enclose(P 0, open(P 0, r))) (see [23, Sec. 4.1]).

Finding the nearest branching ancestor
A unary path looks like a sequence of opening parentheses followed by a sequence of closing
parentheses. The nearest branching ancestor of P[i] can then be obtained in constant time by
ﬁnding the nearest closing parenthesis to the left, l = select0(rank0(P, i)), and the nearest
opening parenthesis to the right, r = select1(rank1(close(P, i)) + 1). Then the answer is
the larger between enclose(P, open(P, l)) and enclose(P, r).

Travis Gagie, Meng He, and Gonzalo Navarro

XX:11

Determining the subtree level of a node
Since we can compute s = subtreesize(i) of a node P[i] in constant time, we can determine
the corresponding level: if s > (1/τ) lg3 n, it is level 1. Otherwise, we look up τ · s in a
precomputed table of size O(lg3 n) that stores the level corresponding to each possible size.
Therefore, depending on whether we represent both S and S0 or use partial rank structures,

we obtain two results within succinct space.
(cid:73) Theorem 8. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On
a RAM machine of w-bit words, we can build in O(n lg n) time a data structure using
2nH + 4n + o(n)(H + 1) bits, where H ≤ lg σ is the entropy of the distribution of the node
labels, that answers path τ-majority queries in time O((1/τ) lg∗ n lg lgw σ).
(cid:73) Theorem 9. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On a RAM
machine of w-bit words, we can build in O(n lg n) randomized time a data structure using
nH + O(n) + o(nH) bits, where H ≤ lg σ is the entropy of the distribution of the node labels,
that answers path τ-majority queries in time O((1/τ) lg∗ n lg lgw σ).

We note that, within this space, all the typical tree navigation functionality, as well as

access to labels, is supported.

Conclusions

6
We have presented the ﬁrst data structures that can eﬃciently ﬁnd the τ-majorities on the
path between any two given nodes in a tree. Our data structures use linear or near-linear
space, and even succinct space, whereas our query times are close to optimal, by a factor
near log-logarithmic.

of size n = |T 0| =P

As mentioned in the Introduction, many applications of these results require that the
trees are multi-labeled, that is, each node holds several labels. We can easily accommodate
multi-labeled trees T in our data structure, by building a new tree T 0 where each node u
of T with m(u) labels ‘1, . . . , ‘m(u) is replaced by an upward path of nodes u1, . . . , um(u),
each ui holding the label ‘i and being the only child of ui+1 (and um(u) being a child of v1,
where v is the parent of u in T). Path queries from u to v in T are then transformed into
path queries from u1 to v1 in T 0, except when u (v) is an ancestor of v (u), in which case we
replace u (v) by uu(m) (vm(v)) in the query. All our complexities then hold on T 0, which is
Our query time for path τ-majorities in linear space, O((1/τ) lg∗ n lg lgw σ), is over the
optimal time O(1/τ) that can be obtained for range τ-majorities on sequences [1]. It is
open whether we can obtain optimal time on trees within linear or near-linear space. Other
interesting research problems are solving τ0-majority queries for any τ0 ≥ τ given at query
time, in time proportional to 1/τ0 instead of 1/τ, and to support insertions and deletions of
nodes in T. Similar questions can be posed for τ-minorities, where our results in linear space,
O((1/τ) lg lgw σ), are also over the time O(1/τ) that can be obtained on sequences [1].

u∈T m(u).

References

1 D. Belazzougui, T. Gagie, J. I. Munro, G. Navarro, and Y. Nekrich. Range majorities and

minorities in arrays. CoRR, abs/1606.04495, 2016.

2 D. Belazzougui, T. Gagie, and G. Navarro. Better space bounds for parameterized range
majority and minority. In Proc. 12th Annual Workshop on Algorithms and Data Structures
(WADS), pages 121–132, 2013.

XX:12 Tree Path Majority Data Structures

3 D. Belazzougui and G. Navarro. Alphabet-independent compressed text indexing. ACM

Transactions on Algorithms, 10(4):article 23, 2014.

4 D. Belazzougui and G. Navarro. Optimal lower and upper bounds for representing sequences.

ACM Transactions on Algorithms, 11(4):article 31, 2015.

5 T. C. Bell, J. Cleary, and I. H. Witten. Text Compression. Prentice Hall, 1990.
6 M. Bender and M. Farach-Colton. The level ancestor problem simpliﬁed. Theoretical

Computer Science, 321(1):5–12, 2004.

7 M. A. Bender, M. Farach-Colton, G. Pemmasani, S. Skiena, and P. Sumazin. Lowest
common ancestors in trees and directed acyclic graphs. Journal of Algorithms, 57(2):75–94,
2005.

8 T. M. Chan, S. Durocher, K. G. Larsen, J. Morrison, and B. T. Wilkinson. Linear-space
data structures for range mode query in arrays. Theory of Computing Systems, 55(4):719–
741, 2014.

9 T. M. Chan, S. Durocher, M. Skala, and B. T. Wilkinson. Linear-space data structures for

range minority query in arrays. Algorithmica, 72(4):901–913, 2015.

10 T. M. Chan, M. He, J. I. Munro, and G. Zhou. Succinct indices for path minimum, with

applications. Algorithmica, 78(2):453–491, 2017.

11 B. Chazelle. Computing on a free tree via complexity-preserving mappings. Algorithmica,

2(1):337–361, 1987.

14

12 D. R. Clark. Compact PAT Trees. PhD thesis, University of Waterloo, Canada, 1996.
13

E. D. Demaine, A. López-Ortiz, and J. I. Munro. Frequency estimation of internet packet
streams with limited space.
In Proc. 10th Annual European Symposium on Algorithms
(ESA), pages 348–360, 2002.
S. Durocher, R. Shah, M. Skala, and S. V. Thankachan. Linear-space data structures for
range frequency queries on arrays and trees. Algorithmica, 74(1):344–366, 2016.

15 M. Fang, N. Shivakumar, H. Garcia-Molina, R. Motwani, and J. D. Ullman. Computing
iceberg queries eﬃciently. In Proc. 24th International Conference on Very Large Data Bases
(VLDB), pages 299–310, 1998.

16 T. Gagie, M. He, J. I. Munro, and P. K. Nicholson. Finding frequent elements in compressed
2d arrays and strings. In Proc. 18th International Symposium on String Processing and
Information Retrieval (SPIRE), pages 295–300, 2011.

17 M. He, J. I. Munro, and G. Zhou. A framework for succinct labeled ordinal trees over large

alphabets. Algorithmica, 70(4):696–717, 2014.

18 D. Krizanc, P. Morin, and M. H. M. Smid. Range mode and range median queries on lists

19

20

and trees. Nordic Journal of Computing, 12(1):1–17, 2005.
J. Misra and D. Gries. Finding repeated elements. Science of Computer Programming,
2(2):143–152, 1982.
S. Muthukrishnan. Eﬃcient algorithms for document retrieval problems.
Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 657–666, 2002.

In Proc. 13th

21 G. Navarro and K. Sadakane. Fully-functional static and dynamic succinct trees. ACM

Transactions on Algorithms, 10(3):article 16, 2014.

22 R. Raman, V. Raman, and S. S. Rao. Succinct indexable dictionaries with applications
to encoding k-ary trees, preﬁx sums and multisets. ACM Transactions on Algorithms,
3(4):article 43, 2007.
L. Russo, G. Navarro, and A. Oliveira. Fully-compressed suﬃx trees. ACM Transactions
on Algorithms, 7(4):article 53, 2011. 35 pages.

24 D. Sleator and R. E. Tarjan. A data structure for dynamic trees. Journal of Computer and

23

System Sciences, 26(3):362–391, 1983.

25 D. Tsur. Succinct representation of labeled trees. Theoretical Computer Science, 562:320–

329, 2014.

Travis Gagie, Meng He, and Gonzalo Navarro

XX:13

Path τ-Minorities

A
If we try out A = 1 + b1/τc distinct elements in the path from u to v, then one of them will
turn out to be a τ-minority. With this idea, we extend the technique of Chan et al. [9] to
tree paths. To ﬁnd the τ-minorities, we will ﬁnd A distinct labels (or all the labels, if there
are not that many) in the path Puz, where z = lca(u, v), and check their frequency in Puv,
and then run an analogous process on the path Pvz. We will stop as soon as we ﬁnd a label
that is not a τ-majority. We describe the process on Puz, as Pvz is analogous.

To ﬁnd A distinct labels, we will simulate on Puz the algorithm of Muthukrishnan
[20], which ﬁnds A distinct elements in any range of an array E. Muthukrishnan builds
the array C[i] = max{j < i, E[j] = E[i]} ∪ {0} and builds on C a range minimum
query (RMQ) data structure. Then he ﬁnds A (or all the) distinct elments in any range
E[i..j] via O(A) RMQs. In our case, we store for each node u the ﬁeld prevlabel(u) =
depth(labelanc(parent(u), label(u))), the depth of the nearest ancestor of u with its same
label (and −1 if there is none), and thus it holds that E[i] = label(anc(u, i + depth(z) − 1))
and C[i] = 1 + prevlabel(anc(u, i + depth(z) − 1)). Then we can run Muthukrishnan’s
algorithm and obtain the A distinct labels of Puz.

To solve RMQs on Puz, we use the data structure of Chazelle [11], which takes constant
time and linear space. This yields our ﬁrst result, which slightly reduces the O((1/τ) lg lg n)
time (within linear space) of Durocher et al. [14]. Note that the prevlabel ﬁelds are easily
computed in O(n) time in a DFS traversal.
(cid:73) Theorem 10. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On a
RAM machine of w-bit words, we can build an O(n) space data structure that answers path
τ-minority queries in time O((1/τ) lg lgw σ). The structure is built in linear time.

It is likely that the result of Durocher et al. [14] can be improved to match ours, by just
using a faster predecessor data structure. We can, however, make our solution succinct by
using our tree representation of 2n + o(n) bits [21]. Instead of storing ﬁeld prevlabel, we
compute it on the ﬂy with the given formula. Using the structures of Durocher et al. [14,
Lem. 7], we can compute labelanc in time O(lg lgw σ). Their structure uses 2n + o(n) bits
in addition to the topology of T and the representation of S.

The structure for RMQs, on the other hand, can be replaced by the one of Chan et al. [10],
which uses 2n + o(n) further bits and answers RMQs with O(α(n)) queries prevlabel(u),
where α is the inverse Ackermann function. Therefore, we can spot the A candidates in time
O(A · α(n) lg lgw σ) and then verify them in time O(A · lg lgw σ). This yields the ﬁrst result
for path α-minority queries within succinct space.
(cid:73) Theorem 11. Let T be a tree of n nodes with labels in [1..σ], and 0 < τ < 1. On a RAM
machine of w-bit words, we can build in O(n) time a data structure using nH+6n+o(n)(H+1)
bits, where H ≤ lg σ is the entropy of the distribution of the node labels, that answers path
τ-minority queries in time O((1/τ)α(n) lg lgw σ), where α is the inverse Ackermann function.

