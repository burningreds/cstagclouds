2
1
0
2

 

n
a
J
 

7
1

 
 
]
S
D
.
s
c
[
 
 

1
v
2
0
6
3

.

1
0
2
1
:
v
i
X
r
a

Compact Binary Relation Representations

with Rich Functionality ∗

J´er´emy Barbay

University of Chile

jbarbay@dcc.uchile.cl

Francisco Claude

University of Waterloo
fclaude@cs.uwaterloo.ca

Gonzalo Navarro
University of Chile

gnavarro@dcc.uchile.cl

July 17, 2018

Abstract

Binary relations are an important abstraction arising in many data
representation problems. The data structures proposed so far to represent 
them support just a few basic operations required to ﬁt one particular
application. We identify many of those operations arising in applications
and generalize them into a wide set of desirable queries for a binary relation 
representation. We also identify reductions among those operations.
We then introduce several novel binary relation representations, some simple 
and some quite sophisticated, that not only are space-eﬃcient but also
eﬃciently support a large subset of the desired queries.

1

Introduction

Binary relations appear everywhere in Computer Science. Graphs, trees, inverted 
indexes, strings and permutations are just some examples. They also
arise as a tool to complement existing data structures (such as trees [5] or
graphs [2]) with additional information, such as weights or labels on the nodes
or edges, that can be indexed and searched. Interestingly, the data structure
support for binary relations has not undergone a systematic study, but rather
one triggered by particular applications. We aim to start such a study in this
article.
Let us say that a binary relation R relates objects in [1, n] with labels in
[1, σ], containing t pairs out of the nσ possible ones. We focus on space-eﬃcient
∗An early version of this article appeared in Proc. LATIN 2010.Partially funded by Fondecyt 
grant 1-110066, Chile (ﬁrst and third authors). Funded in part by Google U.S./Canada
PhD Fellowship Program and David R. Cheriton Scholarships Program (second author).

1

Figure 1: An example of binary relation.

representations considering a simple entropy measure,

= t lg

nσ
t

+ O(t)

t

(cid:18)nσ

(cid:19)

H(R) = lg

bits, which ignores any other possible regularity. Figure 1 illustrates a binary
relation (we identify labels with rows and objects with columns henceforth).

Previous work focused on relatively basic primitives for binary relations:
extract the list of all the labels associated with an object or of all the objects
associated with a label (an operation called access), or extracting the j-th such
element (an operation called select), or counting how many of these are there
up to some object/label value (called operation rank).

The ﬁrst representation speciﬁcally designed for binary relations [5] supports
rank, select and access on the rows (labels) of the relation, for the purpose
of supporting faster joins on labels. The idea is to write the labels of the pairs
in object-major order and to operate on the resulting string plus some auxiliary
data. This approach was extended to support more general operations needed
for text indexing [16]. The ﬁrst technique [5] was later reﬁned [6] into a scheme
that allows one to compress the string while still supporting the basic operations
on both labels and objects. The idea is to store auxiliary data on top of an
arbitrary representation of the binary relation, which can thus be compressed.
This was used to support labeled operations on planar and quasi-planar labeled
graphs [2].

Ad-hoc compressed representations for inverted lists [34] and Web graphs [15]
can also be considered as supporting binary relations. The idea here is to
write the objects of the pairs, in label-major order, and to support extracting
substrings of the resulting string, that is, little more than access on labels. One
can add support for access on objects by means of string select operations [14].
The string can be compressed by diﬀerent means depending on the application.
In this paper we aim at settling the foundations of eﬃcient compact data

structures for binary relations. In particular, we address the following points:
• We deﬁne a large set of operations of relevance to binary relations, widely

2

123456789A..1......B.....11..C...1.1.1.D.1.......E1..11....F........1G....1.1..H11.......extending the classic set of rank, select and access. We give a number
of reductions among operations in order to deﬁne a core set that allows
one to eﬃciently support the extended set of operations.

• We explore the power of the reduction to string operators [5] when the operations 
supported on the string are limited to rank, select and access.
This structure is called BinRel-Str, and we show it achieves interesting
bounds only for a reduced set of operations.

• We show that a particular string representation, the wavelet tree [24],
although not being the fastest one, provides native support for a much
wider set of operations within logarithmic time. We call BinRel-WT
this binary relation representation.

• We extend wavelet trees to generalized wavelet trees [18], and design new
algorithms for various operations that take advantage of their larger fanout.
 As a result we speed up most of the operations within the same space.
This structure is called BinRel-GWT.

• We present a new structure, binary relation wavelet tree (BRWT), that is
tailored to represent binary relations. Although the BRWT gives weaker
support to the operations, it is the only one that approaches the entropy
space H(R) within a multiplicative factor (of 1.272).

For the sake of brevity, we aim at the simplest description of the operations,
ignoring any practical improvement that does not make a diﬀerence in terms of
asymptotic time complexity, or trivial extensions such as interchanging labels
and objects to obtain other space/time tradeoﬀs.

2 Compact Data Structures for Sequences

Given a sequence S of length n, drawn from an alphabet Σ of size σ, we deﬁne
the following queries (omitting S if clear from context):

• ranka(S, i) counts the occurrences of symbol a ∈ Σ in S[1, i].
• selecta(S, j) ﬁnds the position of the j-th occurrence of symbol a ∈ Σ in

S.

• access(S, i) = S[i].

The solutions in the literature are quite diﬀerent depending on the alphabet

size, σ.

3

2.1 Binary Sequences
For the special case Σ = {0, 1}, there exist representations using o(n) bits on
top of a plain representation of S, and answering the three queries in constant
time [13]. The extra space can be made as low as O(n lg lg n/ lg n), which is
optimal [21]. This extra data structure on top of a plain representation of S is
called an index.

If we are allowed, instead, to represent S in a speciﬁc way, then one can
compress the sequence while still supporting the three operations in constant
time. The overall space can be reduced to nH0(S) + o(n) bits [33]. Here H0(S)
is the zero-order entropy of sequence S, deﬁned as

H0(S) =

(cid:88)

a∈Σ

na
n

lg

n
na

,

where na is the number of occurrences of symbol a in S. The o(n) extra space
on top of the entropy can be made as small as O(n/ lgc n) for any constant c
[32].

2.2 Sequences over Small Alphabets
If σ = O(lg n), for a constant 0 <  < 1, it is still possible to retain the space and
time complexities of binary sequence representations [18]. The main idea is that
we only need a compressed sequence representation that provides constant-time
access, or more precisely, that can access O(lgσ n) consecutive symbols from
S in constant time (this is achieved by extending similar compressed bitmap
representations [33]).

Then, in order to support ranka and selecta, we act as if we had an explicit
bitmap Ba[1, n], where Ba[i] = 1 iﬀ S[i] = a. Then ranka(S, i) = rank1(Ba, i)
and selecta(S, j) = select1(Ba, j). We store only the rank/select index of
each Ba, and can solve rank/select on Ba by extracting any desired chunk
from S. The only diﬀerence is that we cannot access O(lg n) contiguous bits
from Ba in constant time, but only O(lgσ n).
As a result, the index for each Ba requires O(n lg lg n/ lgσ n) bits of space.
Added over all the a ∈ Σ, the total space for the indexes is O(nσ lg lg n/ lgσ n) =
o(n).

2.3 General Sequences and Wavelet Trees

The wavelet tree [24] reduces the three operations on general alphabets to those
on binary sequences.
It is a perfectly balanced tree that stores a bitmap of
length n at the root; every position in the bitmap is either 0 or 1 depending on
whether the symbol at this position belongs to the ﬁrst half of the alphabet or to
the second. The left child of the root will handle the subsequence of S marked
with a 0 at the root, and the right child will handle the 1s. This decomposition
into alphabet subranges continues recursively until reaching level (cid:100)lg σ(cid:101), where
the leaves correspond to individual symbols. We call Bv the bitmap at node v.

4

Figure 2: Example of a wavelet tree for the sequence EHDHACEEGBCBGCF.

The access query S[i] can be answered by following the path described for
position i. At the root v, if Bv[i] = 0/1, we descend to the left/right child,
switching to the bitmap position rank0/1(Bv, i) in the left/right child, which
then becomes the new v. This continues recursively until reaching the last
level, when we arrive at the leaf corresponding to the desired symbol. Query
ranka(S, i) can be answered similarly to access, except that we descend according 
to a and not to the bit of Bv. We update position i for the child node
just as before. At the leaves, the ﬁnal bitmap position i is the answer. Query
selecta(S, j) proceeds as ranka, but upwards. We start at the leaf representing
a and update j to select0/1(Bv, j) where v is the parent node, depending on
whether the current node is its left/right child. At the root, position j is the
result.

If the bitmaps Bv are represented in plain form (with indexes that support
binary rank/select), then the wavelet tree requires n lg σ + o(n) lg σ bits of
space, while answering all the queries in O(lg σ) time. If the bitmaps Bv are
instead represented in compressed form [32], the wavelet tree uses nH0(S)+o(n)
bits and retains the same time complexities. Figure 2 illustrates the structure.
Wavelet trees are not only used to represent strings [18], but also grids [10],
permutations [8], and many other structures. We refer in particular to a recent
article [20] where in particular some (folklore) capabilities are carefully proved:
(1) any range of symbols [α, β] is covered by k = O(lg(β − α + 1)) wavelet tree
nodes, and these can be reached from the root by traversing O(k + lg σ) nodes.
A way to speed up the wavelet tree operations is to use generalized wavelet
trees [18]. These are multiary wavelet trees, with arity µ = O(lg n), for a constant 
0 <  < 1. Bitmaps Bv are replaced by sequences Sv over a (small) alphabet 
of size µ. All the operations on those sequences are still solved in constant
time, but now the wavelet tree height is reduced to O(lgµ σ) = O(lg σ/ lg lg n),
and thus this is the complexity of the operations. The space can still be bounded
by nH0(S) + o(n) [23].

Wavelet trees are not the only sequence representation achieving basically

5

123456789101112131415EHDHACEEGBCBGCFA-D/E-H11010011100010135610111214DACBCBCA-B/C-D101010151012ABBA/B011C/D361114DCCC10001247891315EHHEEGGFE-F/G-H0110011017815EEEFE/F000124913HHGGG/H1100nH0(S) bits of space [22, 4]. The best current alternative [4] uses nH0(S) +
o(nH0(S)) + o(n) bits and solves the three queries within time O(lg lg σ). This
is preferable when σ is large.

2.4 Range Minimum Queries (RMQs)

The Range Minimum Query (RMQ) operation on a sequence S[1, n] was not
listed among the basic ones, but we cover it because we will make use of it in
Lemma 11. It is deﬁned as rmq(S, i, j) = argmini≤k≤jS[k], that is, it returns
the position of the minimum value in a range S[i, j]. If there are more than one,
it returns the leftmost minimum.

It is possible to solve this query in constant time using just 2n + o(n) bits

of space, without even accessing S itself [19].

3 Operations

3.1 Deﬁnition of operations

We now motivate the set of operations we deﬁne for binary relations. Their full
list, formal deﬁnition, and illustration, are given in A.

One of the most pervasive examples of binary relations are directed graphs,
which are precisely binary relations between a vertex set V and itself. Extracting
rows or columns in this binary relation supports direct and reverse navigation
from a node. To support powerful direct access to rows and columns we deﬁne
operations obj acc1(α, x, y), which retrieves the objects in [x, y] related to label 
α, in arbitrary order, and the symmetric one, lab acc1(α, β, x). In case we
want to retrieve the pairs in order, obj min1(α, x), which gives the ﬁrst object
≥ x related to label α, can be used as an iterator, and similarly lab min1(α, x).
These operations are also useful to ﬁnd out whether the link (α, x) exists. Note
that adjacency list representations only support eﬃciently the retrieval of direct 
neighbors, and adjacency matrix only support eﬃciently the test for the
existence of a link.

Web graphs, and their compact representation supporting navigation, have
been a subject of intense research in recent years [9, 11, 15] (see many more
references therein). In a Web graph, the nodes are Web pages and the edges
are hyperlinks. Nodes are usually sorted by URL, which not only gives good
compression but also makes ranges of nodes correspond to domains and subdirectories1.
 For example, counting the number of connections between two
ranges of nodes allows estimating the connectivity between two domains. This
count of points in a range is supported by our operation rel num(α, β, x, y),
which counts the number of related pairs in [α, β] × [x, y]. The individual links
between the two domains can be retrieved, in arbitrary order, with operation
rel acc(α, β, x, y). In general, considering domain ranges enables the analysis
and navigation of the Web graph at a coarser granularity (e.g., as a graph of

1More precisely, we have to sort by the reversed site string concatenated with the path.

6

hosts, or institutions). Our operations obj acc(α, β, x, y), which gives the objects 
in [x, y] related to a label in [α, β], extends obj acc1 to ranges of labels,
and similarly lab acc(α, β, x, y) extends lab acc1. Ordered enumeration and
(coarse) link testing are supported by operations obj min(α, β, x), which gives
the ﬁrst object ≥ x related to a label in [α, β], and similarly lab min(α, x, y)
for labels.

A second pervasive example of a binary relation is formed by the twodimensional 
grids, where objects and labels are simply coordinates, and where
pairs of the relation are points at those coordinates. Grids arise in GIS and many
other geometric applications. Operation rel num allows us to count the number
of points in a rectangular area. A second essential operation in these applications
is to retrieve the points from such an area. If the retrieval order is not important,
rel acc is suﬃcient. Otherwise, operation rel acc lab maj(x, y, α, z) serves as
an iterator to retrieve the points in label-major order.
It retrieves the ﬁrst
point in [α, α] × [z, y], if any, and otherwise the ﬁrst point in [α+1, σ] × [x, y].
Operation rel acc obj maj(α, β, γ, x) is similar, for object-major order. For
an even more sophisticated processing of the points, rel sel lab maj(α, j, x, y)
and rel sel obj maj(α, β, x, j) give access to the j-th element in such lists.

Grids also arise in more abstract scenarios. For example, several text indexing 
data structures [12, 16, 25, 27] resort to a grid, which relates for example
text suﬃxes (in lexicographic order) with their text positions, or phrase preﬁxes 
and suﬃxes in Lempel-Ziv compression, or two labels that form a rule in
grammar-based compression, etc. The operations most commonly needed are,
again, counting and retrieving (in arbitrary order) the points in a rectangle.

Another important example of binary relations are inverted indexes [34],
Inwhich 
support word-based searches on natural language text collections.
verted indexes can be seen as a relation between vocabulary words (the labels)
and the documents where they appear (the objects). Apart from the basic operation 
of extracting the documents where a word appears (obj acc1), a popular
operation is the conjunctive query (e.g., in Google-like search engines), which
retrieves the documents where k given words appear. These are solved using a
combination of the complementary queries obj rnk1(α, x) and obj sel1(α, x, j)
[5, 7]. The ﬁrst operation counts the number of points in [α, α]× [1, x], whereas
the second gives the j-th point in [α, α] × [x, n].

Extending these operations to a range of words allows for stemmed and/or
preﬁx searches (by properly ordering the words), and are implemented using
obj rnk(α, β, x) and obj sel(α, β, x, j), which extend obj rnk1 and obj sel1
to ranges of labels. Extracting a column, on the other hand (lab acc1), gives
important summarization information on a document: the list of its diﬀerent
Intersecting columns (using the symmetric operations lab rnk1(α, x)
words.
and lab sel1(α, x, j)) allows for analysis of content between documents (e.g.,
plagiarism or common authorship detection). Handling ranges of documents
(supported with the symmetric operations lab acc, lab rnk(α, x, y), and
lab sel(α, j, x, y)) allows for considering hierarchical document structures such
as XML or ﬁle systems (where one operates over a whole subtree or subdirec-
tory).

7

Figure 3: Reductions among operations.

Similar representations are useful to support join operations on relational
databases and, in combination with data structures for ordinal trees, to support
multi-labeled trees, such as those featured by semi-structured documents (e.g.,
XML) [5]. A similar technique [2] combining various data structures for graphs
with binary relations yields a family of data structures for edge-labeled and
vertex-labeled graphs that support labeled operations on the neighborhood of
each vertex. For example, operations rel min lab maj and rel min obj maj
support the search for the highest neighbor of a point, when the binary relation
encodes the levels of points in a planar graph representing a topography map [2].
The extension of those operations to the union of labels in a given range allows 
them to handle more complex queries, such as conjunctions of disjunctions.
For example, in a relational database, consecutive labels may represent a range
of parameter values (e.g., people of age between 20 and 40).

We deﬁne other operations for completeness: rel rnk lab maj acts like
the inverse of rel sel lab maj, and similarly rel rnk obj maj; lab num and
obj num are more complete versions of lab rnk and obj rnk; and rel rnk is a
more basic version of rel num.

3.2 Reductions among operations

We give a set of reductions among the operations introduced. The results are
sumarized in the following theorem.
Theorem 1. For any solid arrow op → op(cid:48) in Figure 3, it holds that if op is
solved in time t, then op(cid:48) can be solved in time O(t). For the dotted arrows with

8

labnumlabrnklabrnk1relrnklabmajrelrnkobjmajobjnumobjrnk1objrnkrelnumrelrnkrelminlabmajrelminobjmajlabminobjminlabaccobjacclabacc1objacc1objselobjmin1objsel1labsellabmin1labsel1relaccrelsellabmajrelselobjmajlg(σn)lg(σn)lgσlgnassociated penalty factors O(t(cid:48)), it holds that if op is solved in time t, then op(cid:48)
can be solved in time O(tt(cid:48)).

Proof. Several reductions are immediate from the deﬁnition of the operations
in A (those arrows are in bold in Figure 3). We prove now the other ones. We
consider only the reductions for the left side of the ﬁgure (operations related to
labels); the same idea applies for the right side (objects).

• rel rnk → rel num

rel num(α, β, x, y) = rel rnk(α − 1, x − 1) − rel rnk(α − 1, y)

−rel rnk(β, x − 1) + rel rnk(α − 1, x − 1).

• rel rnk lab maj → rel num

rel num(α, β, x, y) = rel rnk lab maj(β, x, y, y)

−rel rnk lab maj(α − 1, x, y, y).

• rel acc → (lab acc1, obj acc1)

lab acc1(α, β, x) = {γ, (γ, x) ∈ rel acc(α, β, x, x)},
obj acc1(α, x, y) = {z, (α, z) ∈ rel acc(α, α, x, y)}.

• rel sel lab maj → rel min lab maj:

to solve query
rel min lab maj(α, x, y, z) we ﬁrst test if rel sel lab maj(α, 1, z, y) gives
a pair of the form (α, w), in which case we return it. Otherwise, we return
rel sel lab maj(α + 1, 1, x, y).

in order

• rel min lab maj → rel acc: to solve rel acc(α, β, x, y), we ﬁnd a ﬁrst
point (γ, z) = rel min lab maj(α, x, y, x). The next element is obtained
as (γ(cid:48), z(cid:48)) = rel min lab maj(γ, x, y, z + 1) and so on, until we reach the
ﬁrst answer with label greater than β.

• rel min lab maj → lab min:

then lab min(α, x, y) = γ.

let (γ, z) = rel min lab maj(α, x, y, x),

• lab min → lab acc: we report γ = lab min(α, x, y), γ(cid:48) = lab min(γ +
1, x, y), and so on until reaching a result larger than β. The points reported
form lab acc(α, β, x, y).

• lab min1 → lab acc1: similar to the previous reduction.

Finally, the non-constant time reductions are explained the following way:
• (rel rnk lab maj, rel sel lab maj) works in both ways by doing a binary
search over the results of the other operation, in the worst case considering
nσ elements.

9

Figure 4: Sequence S and bitmap B for representing the binary relation shown
in Figure 1.

• (lab num, lab sel) operates the same way as the previous one, but searching 
among σ elements in the worst case, thus the O(lg σ) penalty. (For
the objects this becomes O(lg n).)

The reductions presented here allow us to focus on a small subset of the
most diﬃcult operations. In some cases, however, we will present more eﬃcient
solutions for the simpler operations and will not use the reduction.

4 Reduction to Strings: BinRel-Str
A simple representation [5, 16] for a binary relation R formed by t pairs in
[1, n]×[1, σ] uses a bitmap B[1, n+t] and a string S[1, t] over the alphabet [1, σ].
The bitmap B concatenates the consecutive cardinalities of the n columns of
the relation, in unary. The string S contains the rows (labels) of the pairs of
the relation in column (object)-major order. Figure 4 shows the representation
for the binary relation shown in Figure 1. Barbay et al. [5] showed that an easy
way to support operations obj rnk1 and obj sel1 on the binary relation is to
support the operations rank and select on B and S, using any data structure
known for bitmaps and strings (recall Section 2). Note also that the particular
case rel num(1, σ, x, y) can be answered in O(1) time using B. In the sequel we
extend Barbay et al.’s work as much as possible considering our considerably
larger set of operations. This approach, building only on rank, select and
access on B and S, will be called BinRel-Str.

We deﬁne some notation used in the rest of the paper. First, we call map(x)
the mapping from a column number x to its last element in S: map(x) =
rank1(B, select0(B, x)). The inverse, from a position in S to its column
number, is called unmap(m) = rank0(B, select1(B, m)) + 1. Both mappings
take constant time. Finally, let us also deﬁne for shortness rankc(B, x, y) =
rankc(B, y) − rankc(B, x − 1).

Assume our representation of S supports access in time a, rank in time r
and select in time s. Table 1 shows the complexity achieved for each binary
relation operation using this approach. As it can be seen, the scheme extends
nicely only to operations involving one row or one column.
In all the other
cases, the complexities are linear in the lengths of the ranges to consider. As

10

123456789101112131415SEHDHACEEGBCBGCFB110110101101101101101010the algorithms are straightforward and their complexities uninteresting, we defer
them to B.2

some redundancy [24, 22, 4]. This is tH0(S) =(cid:80)

Various string representations [22, 4] oﬀer times a, r, and s that are constant
or log-logarithmic on σ. These yield the best time complexities we know of for
the row-wise and column-wise operations, although these form a rather limited
subset of the operations we have deﬁned.
The space used by techniques based on representing B and S (including
BinRel-WT and BinRel-GWT) is usually unrelated to H(R), the entropy of
the binary relation. Various representations for S[1, t] achieve space tH0(S) plus
, where nα is
the number of pairs of the form (α,·) in R. While this can be lower than H(R)
(which shows that our measure H(R) is rather crude), it can also be arbitrarily
higher. For example an almost full binary relation has an entropy H(R) close to
zero, but its tH0(S) is close to nσ lg σ. A clearer picture is obtained if we assume
that S is represented in plain form using t lg σ bits. This is to be compared to
H(R) = t lg nσ
t +O(t), which shows that the string representation is competitive
for sparse relations, t = O(n).

α∈[1,σ] nα lg t
nα

5 Using Wavelet Trees: BinRel-WT

Among the many string representations of S we can choose in BinRel-Str
scheme, wavelet trees [24] turn out to be particularly interesting. Although
the time wavelet trees oﬀer for a, r and s is O(lg σ), not the best ones for
large σ, wavelet trees allow one to support many more operations eﬃciently, via
other algorithms than those used by the three basic operations. We call this
representation BinRel-WT. Table 1 summarizes the time complexity for each
operation using BinRel-WT, in comparison to a general BinRel-Str. Next,
we show how to support some key operations eﬃciently; the other complexities
are inferred from Theorem 1.

The ﬁrst lemma states a well-known algorithm on wavelet trees [27].

Lemma 1. BinRel-WT supports rel rnk(α, x) in O(lg σ) time.

Proof. This is rank≤α(S, map(x)), where operation rank≤α(S, p) counts the
number of symbols ≤ α in S[1, p].
It can be supported in time O(lg σ) on
the wavelet tree of S by following the root-to-leaf branch corresponding to α,
while counting at each node the number of objects preceding position p that are
related with a label preceding α, as follows. Start at the root v with counter
c ← 0. If α corresponds to the left subtree, then enter the left subtree with
p ← rank0(Bv, p). Else enter the right subtree with c ← c + rank0(Bv, p) and
p ← rank1(Bv, p). Continue recursively until a leaf is reached (indeed, that of
α), where the answer is c + p.

2To simplify, in Table 1 we omit some complexities that are most likely to be inferior to

their alternatives.

11

Operation
rel num(α, β, x, y)

rel rnk(α, x)

rel rnk lab maj(α, x, y, z)

BinRel-Str
O((β − α + 1)r)
O((y − x + 1)a lg β)
O(αr)
O(xa lg α)
O(αr)
O((y − x + 1)a lg α)
O((σ − α + 1)r + s)
O((σ − α + 1)r + s)
O((y − x + 1)a lg α)

rel sel lab maj(α, j, x, y)
rel min lab maj(α, x, y, z)
rel rnk obj maj(α, β, γ, x) O((β − α + 1)r)

rel acc(α, β, x, y)

lab num(α, β, x, y)
lab rnk(α, x, y)
lab sel(α, j, x, y)
lab acc(α, β, x, y)

lab min(α, x, y)

O(xa lg β)
O((n − x + 1)a lg β)
rel sel obj maj(α, β, x, j)
rel min obj maj(α, β, γ, x) O((β − α + 1)(s + r))
O((n − x + 1)a lg α)
O((β − α + 1)r + sk)
O((y − x + 1)a lg α + ak)
O((β − α + 1)r)
O(αr)
O((σ − α + 1)r)
O((β − α + 1)r)
O((y − x + 1)a lg α)
O((σ − α + 1)r)
O((y − x + 1)a lg α)
O((y − x + 1)a lg α)
O(xa lg α)
O((n − x + 1)a lg α)
O((β − α + 1)(r + sk))
O((y − x + 1)a lg α)
O((β − α + 1)(r + s))
O((n − x + 1)a lg α)
O(a lg α)
O(a lg α)
O(a lg α)
O(a(k + lg α))
O(r)
O(r + s)
O(r + s)
O(r + sk)

lab rnk1(α, x)
lab sel1(α, j, x)
lab min1(α, x)
lab acc1(α, β, x)
obj rnk1(α, x)
obj sel1(α, x, j)
obj min1(α, x)
obj acc1(α, x, y)

obj num(α, β, x, y)
obj rnk(α, β, x)
obj sel(α, β, x, j)
obj acc(α, β, x, y)

obj min(α, β, x)

BinRel-WT

O(lg σ)

O(lg σ)

O(lg σ)

O(lg σ)
O(lg σ)

O(lg σ)
O(lg j lg(β − α + 1) lg σ)
O(lg n lg σ)
O(lg σ)

O((k + 1) lg σ)
O(β − α + lg σ)
O(α + lg σ)
O(j lg σ)
O((k + 1) lg σ)

O(lg σ)
O((y − x + 1) lg σ)
O(x lg σ)
O(j lg σ)
O((k + 1) lg σ)

O(lg σ)

O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)

Table 1: Time complexity for the operations using BinRel-Str and BinRelWT.
 The parameter k represents the size of the output for the access operators;
one can consider k = 1 for the reductions given in Theorem 1.

12

The next lemma solves an extended variant of a query called range quantile
in the literature, which was also solved with wavelet trees within the same
complexity [20]. Note that the lemma gives also a solution within the same time
complexity for lab min, which in the literature [20] was called range next value
and solved with an ad-hoc algorithm, within the same time.

Lemma 2. BinRel-WT supports rel sel lab maj(α, j, x, y) in O(lg σ) time.
Proof. We ﬁrst get rid of α by setting j ← j + rel num(1, α − 1, x, y) and
thus reduce to the case α = 1. Furthermore we map x and y to the domain
of S by p ← map(x − 1) + 1 and q ← map(y). We ﬁrst ﬁnd which is the
symbol β whose row contains the j-th element. For this sake we ﬁrst ﬁnd the
β such that rank≤β−1(S, p, q) < j ≤ rank≤β(S, p, q). This is achieved in time
O(lg σ) as follows. Start at the root v and set j(cid:48) ← j. If rank0(Bv, p, q) ≥ j,
then continue to the left subtree with p ← rank0(Bv, p − 1) + 1 and q ←
rank0(Bv, q). Else continue to the right subtree with j(cid:48) ← j(cid:48) − rank0(Bv, p, q),
p ← rank1(Bv, p − 1) + 1, and y ← rank1(Bv, q). The leaf arrived at is β.
Finally, we answer (β, unmap(selectβ(S, j(cid:48) + rankβ(S, p − 1)))).

The wavelet tree is asymmetric with respect to objects and labels. The
transposed problem, rel sel obj maj, turns out to be harder. We present,
however, a polylogarithmic-time solution.

Lemma
O(min(lg n, lg j lg(β − α + 1)) lg σ) time.

3. BinRel-WT supports

rel sel obj maj(α, β, x, j)

in

Proof. Remember that the elements are written in S in object major order.
 First, we note that the particular case where [α, β] = [1, σ] is easily
solved in O(lg σ) time, by doing j(cid:48) ← j + rel num(1, σ, 1, x − 1) and returning 
(S[j(cid:48)], unmap(j(cid:48))).
In the general case, one can obtain time O(lg n lg σ)
by binary searching the column y such that rel num(α, β, x, y − 1) < j ≤
rel num(α, β, x, y). Then the answer is (lab sel1(α, j − rel num(α, β, x, y −
1), y), y) (note that Lemma 2 already gives us lab sel1 in time O(lg σ)).
To obtain the other complexity, we ﬁnd the O(lg(β − α + 1)) wavelet tree
nodes that cover the interval [α, β]; let these be v1, v2, . . . , vk. We map position 
p = map(x − 1) + 1 from the root towards those vis, obtaining all the
mapped positions pi in O(k + lg σ) time.
[20] Now the answer is within the
positions [pi, pi + j − 1] of some i. We cyclically take each vi, choose the middle
element of its interval, and map it towards the root, obtaining position q, corresponding 
to pair (S[q], unmap(q)). If rel rnk obj maj(α, β, S[q], unmap(q)) −
rel num(α, β, 1, x − 1) = j, the answer is (S[q], unmap(q)). Otherwise we know
whether q is before or after the answer. So we discard the left or right interval
in vi. After O(k lg j) such iterations we have reduced all the intervals of length
j of all the nodes vi, ﬁnding the answer. Each iteration costs O(lg σ) time.

The next lemma solves a more general variant of a problem that was called
prevLess in the literature, and also solved with wavelet trees [26]. We achieve
the same complexity for this more general variant. Note this is a simpliﬁcation

13

of rel sel obj maj that we can solve within time O(lg σ), whereas for general
j we cannot.

Lemma 4. BinRel-WT supports rel min obj maj(α, β, γ, x) in O(lg σ) time
per pair output.

Proof. We ﬁrst use lab min1(γ, x) (which we already can solve in time O(lg σ)
as a consequence of Lemma 2) to search for a point in the band [γ, β] × [x, x].
If we ﬁnd one, then this is the answer, otherwise we continue with the area
[α, β] × [x + 1, n].

Just as for the second solution of Lemma 3, we obtain the positions pi at
the nodes vi that cover [α, β]. The ﬁrst element to deliver is precisely one of
those pi. We have to merge the results, choosing always the smaller, as we
return from the recursion that identiﬁes the vi nodes. If we are in vi, we return
q = pi. Else, if the left child of v returned q, we map it to q(cid:48) ← select0(Bv, q).
Similarly, if the right child of v returned q, we map it to q(cid:48)(cid:48) ← select1(Bv, q).
If we have only q(cid:48) (q(cid:48)(cid:48)), we return q = q(cid:48) (q = q(cid:48)(cid:48)); if we have both we return
q = min(q(cid:48), q(cid:48)(cid:48)). The process takes O(lg σ) time. When we arrive at the root
we have the next position q where a label in [α, β] occurs in S, and thus return
unmap(q).

The next result can also be obtained by considering the complexity of the

BinRel-Str scheme implemented over a wavelet tree.

Lemma 5. BinRel-WT supports obj sel1(α, x, j) in O(lg σ) time.

Proof. This is a matter of selecting the j-th occurence of the label α in S,
after the position of the pair (α, x). The formula is unmap(selectα(S, j +
obj rnk1(α, x − 1))).

The next operation is the ﬁrst of the set we cannot solve within polylogarithmic 
time.
Lemma 6. BinRel-WT supports lab num(α, β, x, y) in O(β − α + lg σ) time.

Proof. After mapping [x, y] to positions S[p, q], we descend in the wavelet tree
to ﬁnd all the leaves in [α, β] while remapping [p, q] appropriately. We count
one more label each time we arrive at a leaf, and we stop descending from an
internal node if its range [p, q] is empty. The complexity comes from the number
of wavelet tree nodes accessed to reach such leaves [20].

The remaining operations are solved naively: lab sel and obj sel use,
respectively, lab min and obj min successively, and obj num and obj rnk use
obj rnk1 successively,

The overall result is stated in the next theorem and illustrated in Figure 5.
Theorem 2. The structure BinRel-WT, for a binary relation R of t pairs
over [1, σ]× [1, n], uses t lg σ + O(n + t) bits of space and supports the operations
within the time complexities given in Table 1.

14

Figure 5: Reductions among operations supported by BinRel-WT. The dotted 
boxes are operations supported in ω(lg σ) time, the ﬁlled boxes represent
operations directly addressed in the paper, and the blank boxes are supported
via reductions.

Proof. The space assumes a plain uncompressed wavelet tree and bitmap representations,
 and the time complexities have been obtained throughout the section.


6 Using a Generalized Wavelet Tree: BinRelGWT


The results we obtained for the wavelet tree can be extended to the generalized
wavelet tree, improving complexities in many cases (recall Section 2.3). We
refer to the structure that represents S using the generalized wavelet tree as
BinRel-GWT, and we use µ to represent the fan-out of the tree. We require
µ ∈ O(lg(nσ)), assuming that the RAM machine can address up to n× σ cells.
To simplify we will assume σ ≤ n and then use simply µ ∈ O(lg n).

A ﬁrst simple result stems from the fact that the string operations are sped

up on generalized wavelet trees.

Lemma 7. BinRel-GWT supports obj rnk1 and obj sel1 in time O(lgµ σ)
for any µ ∈ Θ(lg n) and any constant 0 <  < 1.
Proof. This follows directly from the results on general BinRel-Str structures.

15

labnumlabrnklabrnk1relrnklabmajrelrnkobjmajobjnumobjrnk1objrnkrelnumrelrnkrelminlabmajrelminobjmajlabminobjminlabaccobjacclabacc1objacc1objselobjmin1objsel1labsellabmin1labsel1relaccrelsellabmajrelselobjmajlg(σn)lg(σn)lgσlgnThe following notation will be useful to describe our algorithms within

wavelet tree nodes. Note that all are easily computed in constant time.

• child(k): Given a symbol k ∈ [1, µ], this is the subtree labeled k of the

current node.

• g(α): Given a symbol α ∈ [1, σ], g(α) is the symbol k such that child(k)

contains the leaf corresponding to α.

• g−1(k): Given a symbol k ∈ [1, µ], g−1(k) = min{α, k = g(α)}.

The next lemma shows how to speed up all the range counting operations.
The result is known in the literature for n× n grids, even within n lg n(1 + o(1))
bits of space [10].

Lemma 8. BinRel-GWT supports rel rnk(α, x) in O(lgµ σ) time, for any
µ ∈ Θ(lg n) and any constant 0 <  < 1.
Proof. As in the case of BinRel-WT, we reduce this problem to the one of
computing rank≤α(S, map(x)), which can be done by following a similar pro-
cedure: We follow the path for α starting at the root in position p = map(x)
and with a counter c ← 0. Every time we move to a subtree, we increase
c ← c + rank≤g(α)−1(Sv, p). When we arrive at the leaf, the answer is c + p.
Operation rank≤k(Sv, p) can be solved in constant time for µ ∈ Θ(lg n)
analogously as done for rankk on small alphabets (recall Section 2.2). We store
for each k ∈ [1, µ] a bitmap B≤k such that B≤k[i] = 1 iﬀ Sv[i] ≤ k. Thus
rank≤k(Sv, p) = rank1(B≤k, p) is computed in constant time and the whole
process takes O(lgµ σ) time.

The next lemma covers operation rel sel lab maj, on which we cannot
improve upon the complexity given by BinRel-WT. Note this means that
O(lg σ) is still the best time complexity for supporting range quantile queries
within linear space [20].

Lemma 9. BinRel-GWT supports rel sel lab maj(α, j, x, y) in O(lg σ)
time.

Proof. This is solved in a similar way to the one presented for BinRel-WT. We
ﬁnd v such that rank≤β−1(S, p, q) < v ≤ rank≤β(S, p, q). The only diﬀerence is
that in this case we have to do, at each node, a binary search for the right child
k ∈ [1, µ] to descend, and thus the time is O(lg µ lgµ σ) = O(lg σ).

For the next operations we will augment the generalized wavelet tree with
a set of bitmaps inside each node v. More speciﬁcally, we will add µ(µ +
1)/2 bitmaps Bk,l, where Bk,l[i] = 1 iﬀ Sv[i] ∈ [k, l]. Just as bitmaps B≤k,
bitmaps Bk,l are not represented explicitly, but only their index is stored (recall
Section 2.2), and their content is simulated in constant time using Sv. Their
total space for a sequence Sv[1, n] is O(nµ2 lg lg n/ lgµ n). To make this space

16

negligible, that is, o(n lg µ), it is suﬃcient that µ = O(lg n) for any constant
0 <  < 1/2. (A related idea has been used by Farzan et al. [17].)

The next lemma shows that the current solution for operation prevLess [26]

can be sped up by an O(lg lg n) factor.

Lemma 10. BinRel-GWT supports rel min obj maj(α, β, γ, x) in O(lgµ σ)
time, for any µ ∈ Θ(lg n) and any constant 0 <  < 1/2.

Proof. We ﬁrst run query rel min obj maj(γ, β, γ, x), and if the result is on
column x, we report it. Otherwise we run query rel min obj maj(α, β, α, x +
1).
This means that we can focus on a simpler query of the form
rel min obj maj(α, β, x), which ﬁnds the ﬁrst pair in [α, β] × [x, n], in objectmajor 
order. We map [x, n] to S[p, t] as usual and then proceed recursively on
the wavelet tree, remapping p. At each node v, we decompose the query into
three subqueries, and then take the minimum result of the three:
1. rel min obj maj(α, g−1(g(α) + 1) − 1, x) on node child(α);
2. rel min obj maj(g−1(g(α) + 1), g−1(g(β)) − 1, x) on the same node v;
3. rel min obj maj(g−1(g(β)), β, x) on node child(β).

Note that queries of type 1 will generate, recursively, only O(lgµ σ) further
queries of type 1 and 2, and similarly queries of type 3 will generate O(lgµ σ)
further queries of type 3 and 2. The only queries that actually deliver values
are those of type 2, and we will have to take the minimum over O(lgµ σ) such
results.
A query of type 2 is solved in constant time using bitmap Bg(α)+1,g(β)−1, by
computing q = select1(Bg(α)+1,g(β)−1, rank1(Bg(α)+1,g(β)−1, p − 1) + 1). This
returns a position Sv[q]. As we return from the recursion, we remap q in its
parent in the usual way, and then (possibly) compare q with the result of a
query of type 1 or 3 carried out on the parent. We keep the minimum q value
along the way, and when we arrive at the root we return (S[q], unmap(q)).

For the next lemma we need a further data structure. For each sequence
Sv[1, n], we store an RMQ structure (Section 2.4), using O(n) = o(n lg µ) bits
and ﬁnding in constant time position of a minimum symbol in any range Sv[i, j].
This results improves upon the result for query range next value [20].

Lemma 11. BinRel-GWT supports rel min lab maj(α, x, y, z) in O(lgµ σ +
lg µ) time, for any µ ∈ Θ(lg n) and any constant 0 <  < 1.

Proof. Again, we can focus on a simpler query rel min lab maj(α, x, y). We
map [x, y] to S[p, q] as usual, and the goal is to ﬁnd the leftmost minimum
symbol in S[p, q] that is larger than α.

Assume we are in a wavelet tree node v and the current interval of interest is
Sv[p, q]. Then, if Sv[p, q] contains symbol g(α) (which is known in constant time
with rankg(α)(Sv, p, q) > 0), we have to consider it ﬁrst, by querying recursively
the child labeled g(α). If this recursive call returns an answer p(cid:48), we return it

17

in turn, remapping it to the parent node. If it does not, then any symbol larger
than α in the range must correspond to a symbol strictly larger than g(α) in
Sv[p, q]. We check in constant time whether there is any value larger than g(α)
in Sv[p, q], using rank≤g(α)(Sv, p, q) < q − p + 1. If there is none, we return in
turn with no answer.
If there is an answer, we binary search for the smallest k ∈ [g(α) + 1, µ] such
that rank≤k(Sv, p, q) > rank≤g(α)(Sv, p, q). This binary search takes O(lg µ)
time and is done only once along the whole process. Once we identify the right
k, we descend to the appropriate child and start the ﬁnal stage of the process.
The ﬁnal stage starts at a node where all the local symbols represent original
symbols that are larger than α, and therefore we simply look for the position
m = rmq(Sv, p, q), which gives us, in constant time, the ﬁrst occurrence of
the minimum symbol in Sv, and descend to child S[m]. This is done until
reaching a leaf, from where we return to the root, at position p(cid:48), and return
(S[p(cid:48)], unmap(p(cid:48))). It is easy to see that we work O(1) time on O(lgµ σ) nodes
and O(lg µ) once.

12. BinRel-GWT supports
Lemma
O(min(lg n, lg j lg(β − α + 1)) lgµ σ) time,
constant 0 <  < 1/2.

rel sel obj maj(α, β, x, j)
in
for any µ ∈ Θ(lg n) and any

Proof. The complexities are obtained the same way as for BinRel-WT. The
binary search over rel num is sped up because BinRel-GWT supports this operation 
faster. The other complexity is in principle higher, because the interval
[α, β] is split into as much as O(µ lg(β − α + 1)) nodes. However, this can be
brought down again to O(lg(β − α + 1)) by using the parent node v of each
group of (up to µ) contiguous leaves [k, l], and using select1 on the bitmaps
Bk,l of those parent nodes in order to simulate a contiguous range with all the
values in [k, l]. So we still have O(lg(β − α + 1)) binary searches of O(lg j) steps,
and now each step costs O(lgµ σ).
Lemma 13. BinRel-GWT supports lab num(α, β, x, y) in O(β − α + lgµ σ)
time, for any µ ∈ Θ(lg n) and any constant 0 <  < 1/2.
Proof. We follow the same procedure as for BinRel-WT. The main diﬀerence
is how to compute the nodes covering the range [α, β]. This can be done in a
na¨ıve way by just verifying whether each symbol appears in the range of Sv, but
this raises the complexity by a factor of µ. Thus we need a method to list the
symbols appearing in a range of Sv without probing non-existent ones. We resort
to a technique loosely inspired by Muthukrishnan [29]. To list the symbol from a
range [k, l] that exist in Sv[p, q], we start with the ﬁrst symbol of the range that
appears in Sv[p, q]. This is obtained with p(cid:48) = select1(Bk,l, rank1(Bk,l, p −
1) + 1). If p(cid:48) > q then there are no such symbols. Otherwise, let k(cid:48) = Sv[p(cid:48)].
Then we know that k(cid:48) appears in Sv[p, q]. Now we continue recursively with
subranges [k, k(cid:48) − 1] and [k(cid:48) + 1, l]. The recursion stops when no p(cid:48) is found, and
it yields all the symbols appearing in Sv[p, q] in O(1) time per symbol.

18

Figure 6: Reductions among operations supported by BinRel-GWT. The dotted 
boxes are operations supported in ω(lg σ) time, the solid ones in O(lg σ)
time, and the thick ones in time O(lgµ σ) or O(lgµ σ + lg µ). The ﬁlled boxes
represent operations addressed directly, and the blank boxes are supported via
reductions.

The remaining operations are obtained by brute force, just as with BinRelWT.
 Figure 6 illustrates the reductions used.
Theorem 3. The structure BinRel-GWT, for a binary relation R of t pairs
over [1, σ] × [1, n], requires t lg σ(1 + o(1)) + O(n + t) bits of space and supports
the operations within the time complexities given in Table 2.

7 Binary Relation Wavelet Trees (BRWT)

v and Br

v and Br

v. At the root, Bl

We propose now a special wavelet tree structure tailored to the representation of
binary relations. This wavelet tree contains two bitmaps per level at each node
v, Bl
v[1, n] has the x-th bit set to 1 iﬀ there exists a pair
(α, x) with α ∈ [1,(cid:98)σ/2(cid:99)], and Br
v has the x-th bit set to 1 iﬀ there exists a pair
(α, x) with α ∈ [(cid:98)σ/2(cid:99) + 1, σ]. Left and right subtrees are recursively built on
the positions set to 1 in Bl
v, respectively. The leaves (where no bitmap
is stored) correspond to individual rows of the relation. We store a bitmap
B[1, σ + t] recording in unary the number of elements in each row. See Figure 7
for an example. For ease of notation, we deﬁne the following functions on
B, trivially supported in constant-time: lab(r) = 1 + rank0(B, select1(B, r))
gives the label of the r-th pair in a label-major traversal of R; while its inverse

19

labnumlabrnklabrnk1relrnklabmajrelrnkobjmajobjnumobjrnk1objrnkrelnumrelrnkrelminlabmajrelminobjmajlabminobjminlabaccobjacclabacc1objacc1objselobjmin1objsel1labsellabmin1labsel1relaccrelsellabmajrelselobjmajlg(σn)lg(σn)lgσlgnBinRel-WT

O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg j lg(β − α + 1) lg σ)
O(lg n lg σ)
O(lg σ)
O((k + 1) lg σ)
O(β − α + lg σ)
O(α + lg σ)
O(j lg σ)

BinRel-GWT

Operation
rel num(α, β, x, y)
rel rnk(α, x)
rel rnk lab maj(α, x, y, z)
rel sel lab maj(α, j, x, y)
rel min lab maj(α, x, y, z)
rel rnk obj maj(α, β, γ, x) O(lg σ/ lg lg n)
rel sel obj maj(α, β, x, j)

O(lg σ/ lg lg n)
O(lg σ/ lg lg n)
O(lg σ/ lg lg n)
O(lg σ)
O(lg σ/ lg lg n + lg lg n)
O(lg j lg(β − α + 1) lg σ/ lg lg n)
O(lg n lg σ/ lg lg n)

rel min obj maj(α, β, γ, x) O(lg σ/ lg lg n)
rel acc(α, β, x, y)
lab num(α, β, x, y)
lab rnk(α, x, y)
lab sel(α, j, x, y)
lab acc(α, x, y)
lab min(α, x, y)
obj num(α, β, x, y)
obj rnk(α, β, x)
obj sel(α, β, x, j)
obj acc(α, β, x)
obj min(α, β, x)
lab rnk1(α, x)
lab sel1(α, j, x)
lab min1(α, j, x)
lab acc1(α, j, x)
obj rnk1(α, x)
obj sel1(α, x, j)
obj min1(α, x, j)
obj acc1(α, x, j)

O((k + 1) lg σ/ lg lg n)
O(β − α + lg σ/ lg lg n)
O(α + lg σ/ lg lg n)
O(j(lg σ/ lg lg n + lg lg n))
O((k + 1)(lg σ/ lg lg n + lg lg n)) O((k + 1) lg σ)
O(lg σ/ lg lg n + lg lg n)
O((y − x + 1) lg σ/ lg lg n)
O((y − x + 1) lg σ/ lg lg n)
O(j lg σ/ lg lg n)
O((k + 1) lg σ/ lg lg n)
O(lg σ/ lg lg n)
O(lg σ/ lg lg n)
O(lg σ)
O(lg σ/ lg lg n + lg lg n)
O((k + 1) lg σ/ lg lg n)
O(lg σ/ lg lg n)
O(lg σ/ lg lg n)
O(lg σ/ lg lg n)
O((k + 1) lg σ/ lg lg n)

O(lg σ)
O((y − x + 1) lg σ)
O((y − x + 1) lg σ)
O(j lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)

Table 2: Time complexity for the operations for BinRel-GWT and BinRelWT.
 The parameter k represents the size of the output for the access operators;
one can consider k = 1 for the reductions shown in Theorem 1.

poslab(α) = rank1(B, select0(B, α)) gives the position in the traversal where
the pairs for label α start.

Note that, because an object x may propagate both left and right, the sizes
of the second-level bitmaps may add up to more than n bits. Indeed, the last
level contains t bits and represents all the pairs sorted in row-major order. As
we will see, the BRWT has weaker functionality than our former structures
based on wavelet trees, but it reaches space proportional to H(R).

Lemmas 14 to 18 give a set of operations that can be supported with the

BRWT structure.
Lemma 14. BRWT supports rel num(α, β, x, y) in O(β − α + lg σ) time.

Proof. We project the interval [x, y] from the root to each leaf in [α, β], adding
up the resulting interval sizes at the leaves. Of course we can stop earlier if the
interval becomes empty. Note that we can only count pairs at the leaves, not
at internal nodes.

Lemma 15. BRWT supports rel min lab maj(α, x, y, z) in O(lg σ) time.

Proof. As
query
rel min lab maj(α, x, y). We reach the O(lg σ) wavelet tree nodes v1, v2, . . .

before, we

consider

only

need

to

the

simpler

20

Figure 7: Example of the BRWT for the binary relation in Figure 1.

that cover the interval [α, σ], and map [x, y] to all those nodes, in O(lg σ) time
[20]. We choose the ﬁrst such node, vk, left to right, with a nonempty interval
[x, y]. Now we ﬁnd the leftmost leaf of vk that has a nonempty interval [x, y],
which is easily done in O(lg σ) time. Once we arrive at such a leaf γ with
interval [x, y], we map x back to the root, obtaining x(cid:48), and the answer is
(γ, x(cid:48)).
Lemma 16. BRWT supports rel min obj maj(α, β, γ, x) in O(lg σ) time.

to

the

simpler

only

need

consider

before, we

Proof. As
query
rel min obj maj(α, β, x). Analogously to the proof of Lemma 4, we cover
[α, β] with O(lg σ) wavelet tree nodes v1, v2, . . . , and map x to xi at each such
vi, all in O(lg σ) time. Now, on the way back of this recursion, we obtain the
smallest y ≥ x in the root associated to some label in [α, β]. In this process we
keep track of the node vi that is the source of y, preferring the left child in case
of ties. Finally, if we arrive at the root with a value y that came from node vi,
we start from position x(cid:48) = xi at node vi and ﬁnd the leftmost leaf of vi related
v[x(cid:48)] = 1) and right
to y. This is done by going left whenever possible (i.e., if Bl
otherwise, and remapping x(cid:48) appropriately at each step. Upon reaching a leaf
γ, we report (γ, y).

Lemma 17. BRWT supports obj sel1(α, x, j) in O(lg σ) time.
Proof. We map x − 1 from the root to x(cid:48) in leaf α, then walk upwards the path
from x(cid:48) + j to the root and report the position obtained.
Lemma 18. BRWT supports lab num(α, β, x, y) in O(β − α + lg σ) time.
Proof. We map [x, y] from the root to each leaf in [α, β], adding one per leaf
where the interval is non-empty. Recursion can also stop when [x, y] becomes
empty.

21

123456789A-D011101110E-H110110101234678A-B010110C-D101101367A100B0112468C0111D1000124579E-F101101G-H1101101459E1110F00011257G0011H1100Figure 8: Reductions among operations supported by BRWT. The dotted boxes
are operations supported in ω(lg σ) time, the ﬁlled boxes represent operations
directly addressed in the paper, and the blank boxes are supported via reductions.


The remaining complexities are obtained by brute force: rel sel lab maj
and rel sel obj maj are obtained by iterating with rel min lab maj and
rel min obj maj, respectively; and similarly lab sel, obj sel and lab sel1
using lab min, obj min, and lab min1. Finally, as before obj num and obj rnk
are obtained by iterating over obj rnk1. We have obtained the following theorem,
 illustrated in Figure 8.
Theorem 4. The BRWT structure, for a binary relation R of t pairs over
√
2)H(R) + O(t + n + σ) bits of space and supports the
[1, σ]× [1, n], uses lg(1 +
operations within the complexities given in Table 3.

Proof. The operations have been obtained throughout the section. For the
space, B is of length σ + t. Thus O(t + n + σ) bits account for B and for the
2n bits at the root of the wavelet tree. The rest of the bits in the wavelet tree
can be counted by considering that each bit not in the root is induced by the
presence of a pair.

Each pair has a unique representative bit in a leaf, and also induces the
presence of bits up to the root. Yet those leaf-to-root paths get merged, so that
not all those bits are diﬀerent. Consider an element x related to tx labels. It
induces tx bits at tx leaves, and each such bit at a leaf induces a bit per level on
a path from the leaf towards the single x at the root.3 At worst, all the O(tx)

3For example, in Figure 7, object x = 4 is related to labels C and D (see also Figure 1).

22

labnumlabrnklabrnk1relrnklabmajrelrnkobjmajobjnumobjrnk1objrnkrelnumrelrnkrelminlabmajrelminobjmajlabminobjminlabaccobjacclabacc1objacc1objselobjmin1objsel1labsellabmin1labsel1relaccrelsellabmajrelselobjmajlg(σn)lg(σn)lgσlgnwe get O(t) +(cid:80)

bits up to level lg tx are created for these elements, and from there on all the tx
paths are diﬀerent, adding up a total of O(tx) + tx lg σ
bits. Adding over all x
tx
. This is maximized when tx = t/n for all x, yielding

O(t) + t lg σn

x tx lg σ
tx

t = H(R) + O(t) bits.

v and Br

To improve the constant lg 3 to lg(1 +

Instead of representing two bitmaps (which would multiply the above value
by 2), we can represent a single sequence Bv with the possible values of the two
bits at each position, 00, 01, 10, 11. Only at the root is 00 possible. Except for
those 2n bits, we can represent the sequence over an alphabet of size 3 with a
zero-order representation [23], to achieve at worst (lg 3)H(R) + o(t) bits for this
part while retaining constant-time rank and select over each Bl
v. (To
achieve this, we maintain the directories for the original bitmaps, of sublinear
size.)
2), we consider that the zero-order
representation actually achieves |Bv|H0(Bv) bits. We call Bx the concatenation
of all the symbols induced by x, (cid:96)x = |Bx| ≤ tx, and Hx = |Bx|H0(Bx).
Assume the tx bits are partitioned into t01 01’s, t10 10’s, and t11 11’s, so that
tx = t01 +t10 +2t11, (cid:96)x = t01 +t10 +t11, and Hx = t01 lg (cid:96)x
+t11 lg (cid:96)x
.
As t11 = (tx − t01 − t10)/2, the maximum of Hx as a function of t01 and t10
t11
t01
2
yields the worst case at t01 = t10 =
4 )tx and (cid:96)x =
( 1
2)tx bits. This can be achieved separately for
2 +
each symbol. Using the same distribution of 01’s, 10’s, and 11’s for all x we add
2)H(R) + O(t) bits. (Note that, if
up to lg(1 +
we concatenate all the wavelet tree levels, the Hx strings are interleaved in this
concatenation.)

√
2
4 )tx, where Hx = lg(1 +

√
4 tx, so t11 = ( 1

2 − √

2)t lg σn

t + O(t) = lg(1 +

+t10 lg (cid:96)x
t10

√

2

√

√

√

Note that this is a factor of lg(1 +

2) ≈ 1.272 away of the entropy of R.

√

8 Conclusions and Future Work
Motivated by the many applications where a binary relation R between σ labels
and n objects arises, we have proposed a rich set of primitives of interest in
such applications. We ﬁrst extended existing representations and showed that
their potential is very limited outside single-row or single-column operations.
Then we proposed a representation called BinRel-WT, that uses a wavelet
tree to solve a large number of operations in time O(lg σ). This structure has
been already of use in particular cases, but here we have made systematic use of
it and exposed its full potential. Furthermore, we have extended the results to
generalized wavelet trees, to obtain the structure BinRel-GWT. This structure
achieves O(lg σ/ lg lg n) time for many operations. It had already been used for
range counting and reporting [10], but here we have extended its functionality

Its 1 at the second leaf, for C, induces a 1 at its parent, for C-D, and a 1 at the root, for A-D.
Its 1 at the third leaf, for E, induces a 1 at its parent for E-F and the 1 at the root for E-H.
The fact that (4, C) ∈ R induces the creation of one column at the leaf for C and one at its
parent. On the other hand, there are two pairs related to object 1, but they are merged at
the second level and thus there is only one path arriving at the root.

23

Operation
rel num(α, β, x, y)
rel rnk(α, x)
rel rnk lab maj(α, x, y, z)
rel sel lab maj(α, j, x, y)
rel min lab maj(α, x, y, z)
rel rnk obj maj(α, β, γ, x) O(β − α + lg σ)
rel sel obj maj(α, β, x, j)

BRWT
O(β − α + lg σ)
O(α + lg σ)
O(α + lg σ)
O(j lg σ)
O(lg σ)

O(j lg σ)

rel acc(α, β, x, y)
rel min obj maj(α, β, γ, x) O(lg σ)
lab num(α, β, x, y)
lab rnk(α, x, y)
lab sel(α, j, x, y)
lab acc(α, x, y)
lab min(α, x, y)
obj num(α, β, x, y)
obj rnk(α, β, x)
obj sel(α, β, x, j)
obj acc(α, β, x)
obj min(α, β, x)
lab rnk1(α, x)
lab sel1(α, j, x)
lab min1(α, j, x)
lab acc1(α, j, x)
obj rnk1(α, x)
obj sel1(α, x, j)
obj min1(α, x, j)
obj acc1(α, x, j)

O((k + 1) lg σ)
O(β − α + lg σ)
O(α + lg σ)
O(j lg σ)
O((k + 1) lg σ)
O(lg σ)
O((y − x + 1) lg σ)
O((y − x + 1) lg σ)
O(j lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(j lg σ)
O(lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)

BinRel-WT

O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg j lg(β − α + 1) lg σ)
O(lg n lg σ)
O((k + 1) lg σ)
O(lg σ)
O(β − α + lg σ)
O(α + lg σ)
O(j lg σ)
O((k + 1) lg σ)
O(lg σ)
O((y − x + 1) lg σ)
O((y − x + 1) lg σ)
O(j lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)
O(lg σ)
O(lg σ)
O(lg σ)
O((k + 1) lg σ)

Table 3: Time complexity for the operations for BRWT and BinRel-WT. The
parameter k represents the size of the output for the access operators; one can
consider k = 1 for the reductions shown in Theorem 1.

to many other operations, so that its use as a replacement of the better known
BinRel-WT structure improves the times achieved in various applications by
a lg lg n factor.

Some of those speedups have already been mentioned in the article, namely
operations range next value and prevLess [20, 26] (range quantile, on the other
hand, is an interesting operation that has resisted our attempts to improve it;
it is equivalent to rel sel lab maj). Another example is ﬁnding the dominant
points on a grid, that is, those (x, y) so that there is not another (x(cid:48), y(cid:48)) with
x(cid:48) ≤ x and y(cid:48) ≤ y. Using successive calls to rel min obj maj and restricting
the next call to the area [x + 1, n] × [1, y − 1] where (x, y) is the last pair found,
structure BinRel-GWT can ﬁnd the dominant points in time O(lg n/ lg lg n)
per point, on an n × n grid. This improves upon the O(lg n) time achieved in
the literature [30].

The speedup on counting and reporting on grids is useful in various text
indexing data structures. As an example, Arroyuelo et al. [1] describe a LempelZiv 
compressed index that is able to ﬁnd the occ occurrences of a pattern of
length m in a text T [1, n] in time O(m2 + (m + occ) lg n). For this sake they use
a 2-dimensional grid where O(m) rel rnk and O(occ) rel acc operations are
carried out. By using our new BinRel-GWT structure, their time complexity

24

drops to O(m2 + (m + occ) lg n/ lg lg n). As a second example, Claude and
Navarro [16] use grammar-based compression to solve the same problem. Given
a grammar of n rules and height h, they achieve search time O(m(m + h) +
h occ) lg n). They use a 2-dimensional grid where operations rel acc, lab sel1,
and obj sel1 are carried out, and therefore using a BinRel-GWT structure
their time is reduced to O(m(m + h) + h occ) lg n/ lg lg n).

Despite the fact that our structures solve many of the queries we have proposed 
in polylogarithmic (and usually logarithmic) time, supporting others remains 
a challenge. In particular, we have no good solutions for label-level or
object-level rank and select queries on ranges.

Another challenge is space. All of the described structures use essentially
t lg σ bits of space, where t is the number of pairs in the relation. While this is
reasonable in many cases, it can be far from the entropy of the binary relation,
H(R), for dense relations. We have proposed a variant, BRWT, that uses space
within a multiplicative factor 1.272 of H(R), yet its functionality is more limited:
Apart from label-level and object-level queries, this structure does not support
to eﬃciently count and select arbitrary points in ranges, albeit it can eﬃciently
enumerate them.

Since the publication of the conference version of this article [3], a followup 
work [17] used our representation BinStr-WT as an internal structure
to achieve asymptotically optimum space, H(R)+o(H(R)) bits, and was able to
solve query rel rnk in time O(lg n), and queries rel acc, rel sel lab maj and
rel sel obj maj in time O(lg2 n), on n × n grids. Once again, using structure
BinRel-GWT their times for rel rnk and rel acc can be divided by lg lg n.
It is therefore an open challenge to approach space H(R) as much as possible 
while retaining the maximum possible functionality and the best possible
eﬃciency. It is unclear which are the limits in this space/time tradeoﬀ, although
some lower bounds from computational geometry are useful. For example, we
cannot count points in ranges faster than the BinRel-GWT structure within
polylogarithmic space [31].
On the other hand, H(R) is a crude measure that does not account for
regularities in the row/column distribution, or clustering, that arises in real-life
binary relations. For example, structures BinRel-WT and BinRel-GWT can
be compressed to the zero-order entropy of a string of length t, and this can in
some cases be below H(R), which shows that this measure is not suﬃciently
reﬁned. It would be interesting to consider ﬁner measures of entropy and try to
match them.

There might also be other operations of interest apart from the set we have
identiﬁed. For example, determining whether a pair is related in the transitive
closure of R is relevant for many applications (e.g., ancestorship in trees, or
paths in graphs). Another extension is to d-ary relations, which would more
naturally capture joins in the relational model.

Finally, we have considered only static relations. Our representations do
allow dynamism, where new pairs and/or objects can be inserted in/deleted from
the waveleet trees [28]. Adding/removing labels, instead, is an open challenge,
as it alters the shape of the wavelet tree.

25

A Formal Deﬁnition of Operations

We formally deﬁne our set of operations. Figure 9 graphically illustrates some
of them.

• rel acc(α, β, x, y) = {(γ, z) ∈ R, γ ∈ [α, β] ∧ z ∈ [x, y]}
• rel sel lab maj(α, j, x, y) = j-th smallest pair of rel acc(α, σ, x, y) in

order (α, x) ≤ (β, y) ⇔ α < β ∨ (α = β ∧ x ≤ y)

• rel min lab maj(α, x, y, z) = under the same order, smallest pair of

rel acc(α, α, z, y) ∪ rel acc(α+1, σ, x, y)

• rel sel obj maj(α, β, x, j) = j-th smallest pair of rel acc(α, β, x, n) in

order (α, x) ≤ (β, y) ⇔ x < y ∨ (x = y ∧ α ≤ β)

• rel min obj maj(α, β, γ, x) = under the same order, smallest pair of

rel acc(γ, β, x, x) ∪ rel acc(α, β, x+1, n)

• lab acc(α, β, x, y) = {γ, ∃z, (γ, z) ∈ rel acc(α, β, x, y)}
• lab acc1(α, β, x) = lab acc(α, β, x, x)
• lab sel(α, j, x, y) = j-th smallest label of lab acc(α, σ, x, y)
• lab sel1(α, j, x) = lab sel(α, j, x, x), or rel sel lab maj(α, j, x, x)
• lab min(α, x, y) = lab sel(α, 1, x, y)
• lab min1(α, x) = lab min(α, x, x), or lab sel1(α, 1, x)
• obj acc(α, β, x, y) = {z, ∃γ, (γ, z) ∈ rel acc(α, β, x, y)}
• obj acc1(α, x, y) = obj acc(α, α, x, y)
• obj sel(α, β, x, j) = j-th smallest object of obj acc(α, β, x, n)
• obj sel1(α, x, j) = obj sel(α, α, x, j), or rel sel obj maj(α, α, x, j)
• obj min(α, β, x) = obj sel(α, β, x, 1)
• obj min1(α, x) = obj min(α, α, x), or obj sel1(α, x, 1)
• rel num(α, β, x, y) = |rel acc(α, β, x, y)|
• rel rnk(α, x) = rel num(1, α, 1, x)
• rel rnk lab maj(α, x, y, z) = rel num(1, α−1, x, y)+rel num(α, α, x, z)
• rel rnk obj maj(α, β, γ, x) = rel num(α, β, 1, x−1)+rel num(α, γ, x, x)
• lab num(α, β, x, y) = |lab acc(α, β, x, y)|
• lab rnk(α, x, y) = lab num(1, α, x, y)

26

• lab rnk1(α, x) = lab rnk(α, x, x), or rel num(1, α, x, x)
• obj num(α, β, x, y) = |obj acc(α, β, x, y)|
• obj rnk(α, β, x) = obj num(α, β, 1, x)
• obj rnk1(α, x) = obj rnk(α, α, x), or rel num(α, α, 1, x)

B Algorithms on BinRel-Str

We prove some of the complexities in Table 1. The others can be derived using
Theorem 1.
Lemma 19. BinRel-Str supports rel num(α, β, x, y) in O(min((β − α +
1)r, (y − x + 1)a lg β)) time.

Proof. We can compute rel num(α, β, x, y) in two ways:

• Using that rel num(α, β, x, y) = (cid:80)
• Using that rel num(α, β, x, y) =(cid:80)

α≤γ≤β rel num(γ, γ, x, y) and that
rel num(γ, γ, x, y) = rankγ(S, map(x − 1) + 1, map(y)), we achieve time
O((β − α + 1)r).

x≤z≤y rel num(α, β, z, z), we can compute 
the value for each z by searching for the successor of α and the predecessor 
of β in S[map(z − 1) + 1, map(z)]. As this range of S is sorted we
can ﬁnd the predecessors and successors using exponential search, which
requires in O(lg β) access operations. Thus the overall process takes time
O((y − x + 1)a lg β).

Lemma 20. BinRel-Str supports lab num(α, β, x, y) in O(min((β − α +
1)r, (y − x + 1)(lg α + β − α)a)) time.

Proof. We can compute lab num(α, β, x, y) in two ways:

• Using that lab num(α, β, x, y) = (cid:80)

α≤γ≤β lab num(γ, γ, x, y), and that
lab num(γ, γ, x, y) = 1 iﬀ rel num(γ, γ, x, y) > 0 and zero otherwise, we
can achieve the same time as in the ﬁrst alternative of Lemma 19.

• Using that lab num(α, β, x, y) = | ∪x≤z≤y lab acc(α, β, z, z)|, we can collect 
the labels in [α, β]× [z, z] for each z and insert them into a dictionary.
The labels related to a single z can be found by using a similar method
as the one in Lemma 19: use exponential search to ﬁnd the ﬁrst element
≥ α in z’s area of S, and then scan the next symbols until surpassing β.
We mark each label found in a bitmap of length β − α + 1, and then we
report the number of ones in it.

27

Figure 9: Some operations illustrated.

28

relacc(α,β,x,y)αβxyBinaryRelation–Operationsrelsellabmaj(α,j,x,y)αxy...relminlabmaj(α,x,y,z)αxyzrelselobjmaj(α,β,x,j)αβx...relminobjmaj(α,β,γ,x)αβxlabacc(α,β,x,y)αxγlabmin(α,x,y)αxβyyobjmin(α,β,x)αβxobjsel(α,β,x,j)αβxrelnum(α,β,x,y)αβxyn11σobjacc(α,β,x,y)αβxylabsel(α,j,x,y)αyxLemma 21. BinRel-Str supports obj num(α, β, x, y) in O(min((y − x +
1)a lg α, (β − α + 1)(r + (y − x + 1)s))) time.

Proof. We can compute obj num(α, β, x, y) in two ways:

• Using that obj num(α, β, x, y) = (cid:80)

x≤z≤y obj num(α, β, z, z), and that
obj num(α, β, z, z) = 1 iﬀ rel num(α, β, z, z) > 0 and zero otherwise, we
can proceed similarly as in the second alternative of Lemma 19, by exponentially 
searching for the ﬁrst value ≥ α in z’s area of S and checking
whether it is ≤ β.

• Using that obj num(α, β, x, y) = | ∪α≤γ≤β obj acc(γ, γ, x, y)|, we can collect 
the objects in [γ, γ]×[x, y] for each γ and insert them into a dictionary,
as in Lemma 20. The objects related to a single γ can be found by using
successive selectγ(S, j) operations on S[map(x − 1) + 1, map(y)], starting
with j = rankγ(S, map(x − 1)) + 1. The complexity considers the worst
case where each such γ appears y − x + 1 times.

Note that, when reducing to implement obj rnk, the rankγ(S,·) operation

is not necessary. For obj rnk1 it is better to reduce from rel num.
Lemma 22. BinRel-Str supports rel sel lab maj(α, j, x, y) in O(min((σ −
α)r + s, (y − x + 1)(σ − α + 1)a)) time.

Proof. Again, we have two possible solutions:

• Set c ← 0. For each label γ in [α, σ], compute c(cid:48) ← c + rankγ(S, map(x −
If at some step it holds c(cid:48) ≥ j, the answer is
1) + 1, map(y)).
(γ, unmap(selectγ(S, j − c + rankγ(S, map(x − 1)))). Otherwise, update
c ← c(cid:48). The overall process takes O((σ − α + 1)r + s) time.

• Similarly, but ﬁrst accumulating all the occurrences of all the labels γ
and then ﬁnding j using the accumulators. We simply traverse the area
S[map(z − 1) + 1, map(z)] backwards, for each z ∈ [x, y], accessing each
label S[k] and incrementing the corresponding counter. The process takes
O((y − x + 1)(σ − α + 1)a) time.

From this operation we can obtain complexities for rel min lab maj,
lab min, lab min1, lab acc, and lab acc1. Some of the results we give are
better than those obtained by a blind reduction; we leave to the reader to check
these improvements. We also note that an obvious variant of this algorithm is
our best solution to compute lab sel, within the same time.
Lemma 23. BinRel-Str supports rel sel obj maj(α, β, x, j) in O(min((n−
x + 1)a lg β, (β − α + 1)((n − x + 1)s + r))) time.

Proof. Once again, we have two possible solutions:

29

• Set c ← 0. For each object z in [x, n], use exponential search on z’s area of
S to ﬁnd the range S[a, b] corresponding to [α, β], and set c(cid:48) ← c+b−a+1.
If at some step it holds c(cid:48) ≥ j, the answer is (S[j−c+a−1], z). Otherwise,
update c ← c(cid:48). The overall process takes O((n − x + 1)a lg β) time.

• Similarly, but ﬁrst accumulating all the occurrences of all the objects z
and then ﬁnding j using the accumulators. We traverse the area S[map(x−
1) + 1, map(y)] for each label γ in [α, β], using successive selectγ(S, j(cid:48))
queries, starting at j(cid:48) = rankγ(S, map(x − 1)) + 1. The process takes
O((β − α + 1)((n − x + 1)s + r)) time.

From this operation we can obtain complexities for rel min obj maj,
rel acc, obj min, obj min1, obj acc, and obj acc1. Once again, some of
the results we give are better than a blind reduction and we leave the reader to
verify those. Finally, an obvious variant of this algorithm is our best solution
to compute obj sel.

A ﬁnal easy exercise for the reader is to show that lab sel1(α, j, x) can be
solved in time O(a lg α), and that obj sel1(α, x, j) is solved in time O(r + s).

References

[1] D. Arroyuelo, G. Navarro, and K. Sadakane. Stronger Lempel-Ziv based

compressed text indexing. Algorithmica, 62(1):54–101, 2012.

[2] J. Barbay, L. Aleardi, M. He, and J. Munro. Succinct representation of

labeled graphs. Algorithmica, 62(1-2):224–257, 2012.

[3] J. Barbay, F. Claude, and G. Navarro. Compact rich-functional binary
relation representations. In Proc. 9th Latin American Symposium on Theoretical 
Informatics (LATIN), LNCS 6034, pages 170–183, 2010.

[4] J. Barbay, T. Gagie, G. Navarro, and Y. Nekrich. Alphabet partitioning
for compressed rank/select and applications. In Proc. 21st Annual International 
Symposium on Algorithms and Computation (ISAAC), LNCS 6507,
pages 315–326. Springer, 2010. Part II.

[5] J. Barbay, A. Golynski, I. Munro, and S. S. Rao. Adaptive searching in
succinctly encoded binary relations and tree-structured documents. Theoretical 
Computer Science, 387(3):284–297, 2007.

[6] J. Barbay, M. He, I. Munro, and S. S. Rao. Succinct indexes for strings,
binary relations and multi-labeled trees. In Proc. 18th Symposium on Discrete 
Algorithms (SODA), pages 680–689, 2007.

[7] J. Barbay, A. L´opez-Ortiz, T. Lu, and A. Salinger. An experimental investigation 
of set intersection algorithms for text searching. ACM Journal of
Experimental Algorithmics, 14, 2009.

30

[8] J. Barbay and G. Navarro. Compressed representations of permutations,
and applications. In Proc. 26th International Symposium on Theoretical
Aspects of Computer Science (STACS), pages 111–122, 2009.

[9] P. Boldi and S. Vigna. The WebGraph framework I: compression techniques.
 In Proc. 13th World Wide Web Conference (WWW), pages 595–
602, 2004.

[10] P. Bose, M. He, A. Maheshwari, and P. Morin. Succinct orthogonal range
In Proc.
search structures on a grid with applications to text indexing.
20th Symposium on Algorithms and Data Structures (WADS), pages 98–
109, 2009.

[11] N. Brisaboa, S. Ladra, and G. Navarro. K2-trees for compact web graph
representation. In Proc. 16th International Symposium on String Processing
and Information Retrieval (SPIRE), LNCS 5721, pages 18–30, 2009.

[12] Y.-F. Chien, W.-K. Hon, R. Shah, and J. Vitter. Geometric BurrowsWheeler 
transform: Linking range searching and text indexing. In Proc.
18th Data Compression Conference (DCC), pages 252–261, 2008.

[13] D. Clark. Compact Pat Trees. PhD thesis, Univ. of Waterloo, Canada,

1996.

[14] F. Claude and G. Navarro. Extended compact Web graph representations.
In T. Elomaa, H. Mannila, and P. Orponen, editors, Algorithms and Applications 
(Ukkonen Festschrift), LNCS 6060, pages 77–91. Springer, 2010.

[15] F. Claude and G. Navarro. Fast and compact Web graph representations.

ACM Transactions on the Web, 4(4):article 16, 2010.

[16] F. Claude and G. Navarro. Self-indexed grammar-based compression. Fundamenta 
Informaticae, 111(3):313–337, 2010.

[17] A. Farzan, T. Gagie, and G. Navarro. Entropy-bounded representation of
point grids. In Proc. 21st Annual International Symposium on Algorithms
and Computation (ISAAC), LNCS 6507, pages 327–338, 2010. Part II.

[18] P. Ferragina, G. Manzini, V. M¨akinen, and G. Navarro. Compressed representations 
of sequences and full-text indexes. ACM Transactions on Algorithms,
 3(2):article 20, 2007.

[19] J. Fischer. Optimal succinctness for range minimum queries. In Proc. 9th
Symposium on Latin American Theoretical Informatics (LATIN), LNCS
6034, pages 158–169, 2010.

[20] T. Gagie, G. Navarro, and S. Puglisi. New algorithms on wavelet trees and
applications to information retrieval. Theoretical Computer Science, 2011.
. To appear. http://arxiv.org/abs/1011.4532.

31

[21] A. Golynski. Optimal lower bounds for rank and select indexes. Theoretical

Computer Science, 387(3):348–359, 2007.

[22] A. Golynski, I. Munro, and S. Rao. Rank/select operations on large alpha-
bets: a tool for text indexing. In Proc. 17th Annual Symposium on Discrete
Algorithms (SODA), pages 368–373, 2006.

[23] A. Golynski, R. Raman, and S. Rao. On the redundancy of succinct data
In Proc. 11th Scandinavian Workshop on Algorithm Theory

structures.
(SWAT), LNCS 5124, pages 148–159, 2008.

[24] R. Grossi, A. Gupta, and J. Vitter. High-order entropy-compressed text
indexes. In Proc. 14th Annual Symposium on Discrete Algorithms (SODA),
pages 841–850, 2003.

[25] J. K¨arkk¨ainen. Repetition-Based Text Indexing. PhD thesis, U. Helsinki,

Finland, 1999.

[26] S. Kreft and G. Navarro. Self-indexing based on LZ77. In Proc. 22nd Annual 
Symposium on Combinatorial Pattern Matching (CPM), LNCS 6661,
pages 41–54, 2011.

[27] V. M¨akinen and G. Navarro. Rank and select revisited and extended.

Theoretical Computer Science, 387(3):332–347, 2007.

[28] V. M¨akinen and G. Navarro. Dynamic entropy-compressed sequences and
full-text indexes. ACM Transactions on Algorithms, 4(3):article 32, 2008.

[29] S. Muthukrishnan. Eﬃcient algorithms for document retrieval problems.
In Proc 13th Annual Symposium on Discrete Algorithms (SODA), pages
657–666, 2002.

[30] G. Navarro and L. Russo. Space-eﬃcient data analysis queries on grids.

CoRR, 1106.4649, 2011. http://arxiv.org/abs/1106.4649.

[31] M. P˘atra¸scu. Lower bounds for 2-dimensional range counting. In Proc. 39th
Annual ACM Symposium on Theory of Computing (STOC), pages 40–46,
2007.

[32] M. P˘atra¸scu. Succincter. In Proc. 49th Annual Symposium on Foundations

of Computer Science (FOCS), pages 305–313, 2008.

[33] R. Raman, V. Raman, and S. S. Rao. Succinct indexable dictionaries with
applications to encoding k-ary trees and multisets. In Proc. 13th Annual
Symposium on Discrete Algorithms (SODA), pages 233–242, 2002.

[34] I. Witten, A. Moﬀat, and T. Bell. Managing Gigabytes. Morgan Kaufmann

Publishers, 2nd edition, 1999.

32

