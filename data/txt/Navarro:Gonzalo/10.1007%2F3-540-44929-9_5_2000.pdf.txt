An Index for Two Dimensional String Matching

Allowing Rotations

Kimmo Fredriksson1?, Gonzalo Navarro2??, and Esko Ukkonen1? ? ?

1 University of Helsinki, Department of Computer Science,

P.O.Box 26, FIN-00014 Helsinki, Finland,

Fax: +358 9 1914 4441, Kimmo.Fredriksson@cs.Helsinki.FI.

2 Department of Computer Science, University of Chile.

Abstract. We present an index to search a two-dimensional pattern
of size m (cid:2) m in a two-dimensional text of size n (cid:2) n, even when the
pattern appears rotated in the text. The index is based on (path com-
pressed) tries. By using O(n2) (i.e. linear) space the index can search the
pattern in O((log(cid:27) n)5=2) time on average, where (cid:27) is the alphabet size.
We also consider various schemes for approximate matching, for which
we obtain either O(polylog(cid:27)n) or O(n2(cid:21)) search time, where (cid:21) < 1 in
most useful cases. A larger index of size O(n2(log(cid:27) n)3=2) yields an average 
time of O(log(cid:27) n) for the simplest matching model. The algorithms
have applications e.g. in content based information retrieval from image
databases.

1 Introduction

Two dimensional pattern (image) matching has important applications in many
areas, ranging from science to multimedia. String matching is one of the most
successful special areas of algorithmics. Its theory and potential applications
in the case of one{dimensional data, that is, linear strings and sequences, is
well understood. However, the string matching approach still has considerable
unexplored potential when the data is more complicated than just a linear string.
Two dimensional digital images are an example of such a data.

Examples of combinatorial pattern matching algorithms that work in two
dimensions, but do not allow rotations are e.g. [1,7,11,12,13,14,15]. On the other
hand, there are many non{combinatorial approaches to rotation invariant pattern 
matching, for a review, see e.g. [16]. The only combinatorial methods, that
come close to us in some respects, are [12,14]. However, these do not address the
pattern rotations. As stated in [2], a major open problem in two{dimensional
(combinatorial) pattern matching is to (cid:12)nd the occurrences of a two-dimensional

? Work supported by ComBi.
?? Work developed while the author was in a postdoctoral stay at the Dept. of Computer 
Science, Univ. of Helsinki. Partially supported by the Academy of Finland and
Fundaci(cid:19)on Andes.

? ? ? Work supported by the Academy of Finland.

J. van Leeuwen et al. (Eds.): IFIP TCS 2000, LNCS 1872, pp. 59{75, 2000.
c(cid:13) Springer-Verlag Berlin Heidelberg 2000

K. Fredriksson, G. Navarro, and E. Ukkonen

60
pattern of size m (cid:2) m in a two-dimensional text of size n (cid:2) n when the pattern
can appear in the text in rotated form. This was addressed from a combinatorial
point of view (cid:12)rst in [3], in which an online algorithm allowing pattern rotations
was presented.

In this work we give the (cid:12)rst algorithms for o(cid:15)ine searching, that is, for
building an index over the text that allows fast querying. The data structure we
use is based on tries. Su(cid:14)x trees for two-dimensional texts have been considered,
e.g. in [8,9,10]. The idea of searching a rotated pattern using a \su(cid:14)x" array of
spiral like strings is mentioned in [10], but only for rotations of multiples of 90
degrees. The problem is much more complex if we want to allow any rotation.
In [3] the consideration was restricted to the matches of a pattern inside the
text such that the geometric center of the pattern has been put exactly on top
of the exact center point of some text cell. This is called the \center{to{center
assumption". Under this assumption, there are O(m3) di(cid:11)erent relevant rotation
angles to be examined for each text cell. In this paper we make this assumption,
too, and consider the following four matching models:
Exact: the value of each text cell whose center is covered by some pattern cell
Hamming: an extension of the Exact model in which an error threshold 0 (cid:20)
k < m2 is given and one is required to report all text positions and rotation
angles such that at most k text cells do not match the covering pattern cell.
Grays: an extension of the Exact model more suitable for gray level images: the
value of each text cell involved in a match must be between the minimum
and maximum value of the 9 neighboring cells surrounding the corresponding
pattern cell [5].

must match the value of the covering pattern cell.

Accumulated: an extension of the Hamming model, more suitable for gray
levels. The sum of the absolute di(cid:11)erences between the value of the text
cells involved in a match and the values of the corresponding patterns cells
must not exceed a given threshold k.

Our results are summarized in Table 1. For some algorithms we have two
versions, one with pattern partitioning technique, and one without it. We denote
by (cid:27) the alphabet size and assume in our average case results that the cell
values are uniformly and independently distributed over those (cid:27) values. The
times reported are average{case bounds for the search. In the Hamming and
Accumulated models (cid:11) = k=m2 (note that (cid:11) < 1 for Hamming and (cid:11) < (cid:27)
for Accumulated) and k(cid:3)
A denote the maximum k values up to where
A = k=((cid:27)=(2e) − 1). Moreover,
some techniques work: k(cid:3)
(cid:27) ((cid:11)) = −(cid:11) log(cid:27)((cid:11)) + (1 +
(cid:27) ((cid:11)) = −(cid:11) log(cid:27)((cid:11)) − (1 − (cid:11)) log(cid:27)(1 − (cid:11)) and H A
H H
(cid:11)) log(cid:27)(1 + (cid:11)). According to Table 1, the search times are sublinear on average
when the conditions are met, which implies in particular that (cid:11) < 1 − e=(cid:27) for
Hamming and (cid:11) < (cid:27)=(2e) − 1 for Accumulated. In all the cases the index needs
O(n2) space and it can be constructed in average time O(n2 log(cid:27) n).

H and k(cid:3)
H = k=(1 − e=(cid:27)) and k(cid:3)

We have also considered the alternative model in which the pattern centers
are used instead of the text centers. For this case we obtain an index that for
the Exact model needs O(n2(log(cid:27) n)3=2) space and gives O(log(cid:27) n) time.

An Index for Two Dimensional String Matching Allowing Rotations

61

Model
Exact

Hamming

Hamming (pattern partitioning)

Grays

Accumulated

Accumulated (pattern partitioning)

Search time
(log(cid:27) n)5=2

Condition

(cid:25)m2=4 (cid:21) log(cid:27) n2

(2 log(cid:27) n)k+3=2((cid:27)=k)k
n2((cid:11)+HH
(cid:27) ((cid:11)))m5= log(cid:27) n
n2(1−log(cid:27) (5=4))(log(cid:27) n)3=2

(cid:25)m2=4 (cid:21) log(cid:27) n2 > k(cid:3)
(cid:25)m2=4 (cid:21) log(cid:27) n2 > k(cid:3)
nlog(cid:27) 4(1 + 2(log(cid:27) n)=k)k(log(cid:27) n)3=2 (cid:25)m2=4 (cid:21) log(cid:27) n2 > k(cid:3)
(cid:25)m2=4 (cid:21) log(cid:27) n2 > k(cid:3)

(cid:25)m2=4 (cid:21) log(cid:27) n2

(cid:27) ((cid:11)))m5= log(cid:27) n

n2(log(cid:27) 2+HA

A

A

H

H

Table 1. Time complexities achieved under di(cid:11)erent models.

The algorithms are easily generalized for handling large databases of images.
That is, we may store any number of images in the index, and search the query
pattern simultaneously from all the images. The time complexities remain the
same, if we now consider that n2 denotes the size of the whole image library.

2 The Data Structures

Let T = T [1::n; 1::n] and P = P [1::m; 1::m] be two dimensional arrays of point
samples, such that m < n. Each sample has a color in a (cid:12)nite ordered alphabet
(cid:6). The size j(cid:6)j of (cid:6) is denoted by (cid:27). The arrays P and T are point samples
of colors of some \natural" image. There are several possibilities to de(cid:12)ne a
mapping between T and P , that is, how to compare the colors of P to colors
of T . Our approach to the problem is combinatorial. Assume that P has been
put on top of T , in some arbitrary position. Then we will compare each color
sample of T against the color of the closest sample of P . The distance between
the samples is simply the Euclidean distance. This is also technically convenient.
The Voronoi diagram for the samples is a regular array of unit squares.

Hence we may de(cid:12)ne that the array T consists of n2 unit squares called
cells, in the real plane R2 (the (x; y){plane). The corners of the cell for T [i; j]
are (i − 1; j − 1); (i; j − 1); (i − 1; j) and (i; j). Each cell has a center which
is the geometric center point of the cell, i.e., the center of the cell for T [i; j] is
(i− 1
2). The array of cells for pattern P is de(cid:12)ned similarly. The center of the
whole pattern P is the center of the cell in the middle of P . Precisely, assuming
for simplicity that m is odd, the center of P is the center of cell P [ m+1
2 ; m+1
2 ].
For images, the cells are usually called pixels.

2 ; j− 1

2 ; j − 1

2); (cid:18)), where (i− 1

Assume now that P has been moved on top of T using a rigid motion (translation 
and rotation), such that the center of P coincides exactly with the center
of some cell of T . The location of P with respect to T can be uniquely given as
((i− 1
2) is the location of the center of P in T , and
(cid:18) is the angle between the x{axis of T and the x{axis of P . The occurrence (or
more generally, distance) between T and P at some location, is determined by
comparing the colors of the cells of T and P that overlap. We will use the centers
of the cells of T for selecting the comparison points. That is, for the pattern at
location ((i − 1
2); (cid:18)), we look which cells of the pattern cover the centers
of the cells of the text, and compare the corresponding colors of those cells. As

2 ; j − 1

2 ; j − 1

62

K. Fredriksson, G. Navarro, and E. Ukkonen

the pattern rotates, the centers of the cells of the text move from one cell of P
to another. In [3] it is shown that this happens O(m3) times, so there are O(m3)
relevant orientations of P to be checked. The actual comparison result of two
colors depends on the matching model.

We propose to use a trie based index of the text, de(cid:12)ned as follows. Trie is a
well{known tree structure for storing strings in which each edge is labeled by a
character. Each cell of the text de(cid:12)nes a string which is obtained by reading text
positions at increasing distances from the center of the cell. The (cid:12)rst character
is that of the cell, then come the 4 closest centers (from the cells above, below,
left and right of the central cell), then the other 4 neighbors, and so on. The
cells at the same distance are read in some prede(cid:12)ned order, the only important
thing is to read the cells in the order of increasing distance from the center cell.
This e(cid:11)ectively utilizes the O(m3) result to restrict the number of rotations our
algorithms must consider on average, see Sec. 3. If such a string hits the border
of the text it is considered (cid:12)nished there. We will call sistrings (for \semi{in(cid:12)nite
strings") [10] the strings obtained in this way. Figure 1 shows a possible reading
order.

22

15

9

14

16

10

17

5

4

8

1

0

3

6

2

7

21

13

12

20

23

18

11

19

24

(a)

(b)

2

1

3

31

2

56

12

1

3

9

1

5

19

2

3

2

7

6

28

13

5

23

12

22

4

(c)

Fig. 1. A possible reading order (\spiral") for the sistring that starts in the middle of
a text of size 5 (cid:2) 5. Figure (a) shows the reading order by enumerating the cells, and
(cid:12)gure (b) shows the enumeration graphically. Figure (c) shows the color values of the
cells of the image, and for that image the sistring corresponding to the reading order
is < 3; 2; 19; 2; 6; 7; 5; 5; 28; 3; 12; 1; 12; 13; 31; 1; 56; 1; 9; 23; 22; 2; 2; 3; 4 >

Therefore each text cell de(cid:12)nes a sistring of length O(n2). A trie on those
strings (called the sistring trie) can be built, which has average size O(n2) and
average depth O(log(cid:27) n2). Alternatively, the unary paths of such a trie can be
compressed, in similar manner used to compress the su(cid:14)x trees. In such a tree
each new string adds at most one leaf and one internal node, so the worst case
size is O(n2).

Still another possibility is to construct an array of n2 pointers to T , sorted in
the lexicographic order of the n2 sistrings in T . Such an array, called the sistring
array, can be formed by reading the leaves of a sistring trie in the lexicographic
order, or directly, by sorting the sistrings. The array needs O(n2) space, but is

An Index for Two Dimensional String Matching Allowing Rotations

63

much smaller that the sistring trie or tree in practice. Hence the sistring array is
the most attractive alternative from the practical point of view and will therefore
be used in the experiments.

The sistring trie can be built in O(n2 log(cid:27) n) average time, by level{wise
construction. The sistring array can be built in O(n2 log n) string comparisons,
which has to be multiplied by O(log(cid:27) n2) to obtain the average number of character 
comparisons. The sistring array is very similar to the su(cid:14)x array, which
in turn is a compact representation of a su(cid:14)x tree.

For simplicity, we describe the algorithms for the sistring trie, although they
run with the same complexity over sistring trees. For sistring arrays one needs
to multiply the search time results by O(log n) as well, because searching the
array uses binary search.

We consider now a property of the sistring trie that is important for all the
results that follow. We show that under a uniform model, the number of sistring
trie nodes at depth ‘ is (cid:2)(min((cid:27)‘; n2)). This roughly is to say that in levels
‘ (cid:20) h, for h = log(cid:27)(n2) = 2 log(cid:27) n all the di(cid:11)erent strings of length ‘ exist, while
from that level on the (cid:2)(n2) sistrings are already di(cid:11)erent. In particular this
means that nodes deeper than h have O(1) children because there exists only
one sistring in the text with that pre(cid:12)x of length h (note that a sistring pre(cid:12)x is
graphically seen as a spiral inside the text, around the corresponding text cell).
To prove this property we consider that there are n2 sistrings uniformly
distributed across (cid:27)‘ di(cid:11)erent pre(cid:12)xes, of length ‘, for any ‘. The probability of
a pre(cid:12)x not being \hit" after n2 attempts is (1− 1=(cid:27)‘)n2, so the average number
of di(cid:11)erent pre(cid:12)xes hit (i.e. existing sistring trie nodes) is

(cid:27)‘(1 − (1 − 1=(cid:27)‘)n2) = (cid:27)‘(1 − e−(cid:2)(n2=(cid:27)‘)) = (cid:27)‘(1 − e−x)

for x = (cid:2)(n2=(cid:27)‘). Now, if n2 = o((cid:27)‘) then x = o(1) and 1 − e−x = 1 − (1 −
x + O(x2)) = (cid:2)(x) = (cid:2)(n2=(cid:27)‘), which gives the result (cid:2)(n2). On the other
hand, if n2 = Ω((cid:27)‘) then x = Ω(1) and the result is (cid:2)((cid:27)‘). Hence the number
of sistring trie nodes at depth ‘ is on average (cid:2)(min((cid:27)‘; n2)), which is the same
as the worst case. Indeed, in the worst case the constant is 1, i.e. the number of
di(cid:11)erent strings is at most min((cid:27)‘; n), while on average the constant is smaller.
We need this result for giving bounds for the maximum number of sistring trie
nodes inspected by our algorithms.

3 The Exact Model

We (cid:12)rst describe the algorithm for the exact matching model. The other algorithms 
are relatively straight{forward extensions of it. As shown in [3], there
are O(m3) relevant orientations in which the pattern can occur in a given text
position. A brute force approach is to consider the O(m3) pattern orientations
in turn and search each one in the sistring trie. To check the pattern in a given
orientation we have to see in which order the pattern cells have to be read so
that they match the reading order of the sistring trie construction.

64

K. Fredriksson, G. Navarro, and E. Ukkonen

Figure 2 shows the reading order induced in the pattern by a rotated occurrence,
 using the spiral like reading order given in Figure 1. For each possible
rotation we compute the induced reading order, build the string obtained by
reading the pattern in that order from its center, and search that string in the
sistring trie. Note in particular that some pattern cells may be read twice and
others may not be considered at all. Observe that in our example the cells numbered 
30, 32, 34, and 36 are outside the maximum circle contained in the pattern,
and are therefore ignored in the sistring trie search. This is because those values
cannot be used unless some levels are skipped in the search, which would mean
entering into all the branches after reading cell number 20. Text cells 21{29, 31,
33, 35, and 37{ all fall outside the pattern.

The algorithm (cid:12)rst considers the sistring of P for angle (cid:18) = 0. The sistring
is searched from the trie until some cell of P mismatches, at depth ‘. Now
the pattern must be rotated a little in order to read the next sistring. The next
rotation to try is such that any of the (cid:12)rst ‘ cells of the previous sistring changes,
that is, any of the centers of the cells of T hits some border of the (cid:12)rst ‘ sistring
cells of P .

34

16

15

9

10

17

18

5

4

8

1

0

3

6

2

7

32

14

13

12

36

11

19

20

30

(a)

(b)

2

1

3

9

2

3

9

1

3

4

19

7

1

7

6

12

7

5

4

5

5

2

3

2

6

(c)

Fig. 2. Reading order induced in the pattern by a rotated occurrence. Figure (a) shows
the pattern superimposed on the image, Figure (b) shows the enumeration of the induced 
reading order, and Figure (c) shows the color values for the pattern cells. The corresponding 
sistring is < 3; 2; 4; 2; 6; 7; 5; 5; 12; 9; 19; 9; 5; 6; 7; 3; 1; 7; 1; 1; 3 >. Cells numbered 
30, 32, 34, and 36 are ignored in the trie search.

The number of rotations to try depends on how far we are from the center.
That is, the number of the text centers that any cell of P may cover depends on
how far the cell is from the rotation center. If the distance of some cell of P from
the rotation center id d, then it may cover O(d) center of T . In general, there
are O(m3) rotations for a pattern of size m (cid:2) m cells. The number of rotations
grows as we get farther from the center, and they are tried only on the existing
branches of the sistring trie. As the pattern is read in a spiral form, when we
p
are at depth ‘ in the sistring trie we are considering a pattern cell which is at
‘) from the center. This means that we need to consider O(‘3=2)
distance O(

An Index for Two Dimensional String Matching Allowing Rotations

65

di(cid:11)erent rotations if the search has reached depth ‘. For each rotation we assume
in the analysis that the sistring is read and compared from the beginning.

The fact that on average every di(cid:11)erent string up to length h exists in the
sistring trie means that we enter always until depth h. The number of sistring
trie nodes considered up to depth h is thus

hX

‘3=2 = O(h5=2)

‘=1

At this point we have O(h3=2) candidates that are searched deeper in the
sistring trie. Now, each such candidate corresponds to a node of the sistring
trie at depth h, which has O(1) children because there exist O(1) text sistrings
which share this pre(cid:12)x with the pattern (a \pre(cid:12)x" here means a circle around
the pattern center).

Two alternative views for the same process are possible. First, consider all
the O(h3=2) candidates together as we move to deeper levels ‘ > h in the sistring
trie. There are on average n2=(cid:27)‘ sistrings of length ‘ matching a given string, so
the total work done when traversing the deeper levels of the sistring trie until
the candidates get eliminated is

X

‘(cid:21)h+1

n2
(cid:27)‘

‘3=2 =

X

(‘ + h)3=2

‘(cid:21)1

(cid:27)‘

= O(h3=2)

An alternative view is that we directly check in the text each candidate that
arrived to depth h, instead of using the sistring trie. There are O(h3=2) candidates
and each one can be checked in O(1) time: if we perform the comparison in a
spiral way, we can add the (cid:12)ner rotations as they become relevant. The ‘-th
‘ from the center) is compared (i.e. the
pattern cell in spiral order (at distance
comparison is not abandoned before) with probability ‘3=2=(cid:27)‘. Summing up the
probabilities of being compared over all the characters yields

p

X

‘(cid:21)1

‘3=2
(cid:27)‘

= O(1)

where for simplicity we have not considered that we have compared already h
characters and have an approximate idea of the orientations to try.

Therefore we have a total average search cost of O((log(cid:27) n)5=2). This assumes
that the pattern is large enough, i.e. that we can read h characters from the center 
in spiral form without hitting the border of the pattern. This is equivalent to
the condition m2 (cid:21) 4
(cid:25) log(cid:27) n2 which is a precondition for our analysis. Smaller
patterns leave us without the help of the sistring trie long before we have eliminated 
enough candidates to guarantee low enough average time to check their
occurrences in the text.

66

K. Fredriksson, G. Navarro, and E. Ukkonen

4 The Hamming Model

This model is an extension of the exact matching model. An additional parameter
k is provided to the search algorithm, such that a mismatch occurs only when
more than k characters have not matched. In this section we use (cid:11) = k=m2. We
require 0 (cid:20) (cid:11) < 1, as otherwise the pattern would match everywhere.

The problem is much more complicated now. Even for a (cid:12)xed rotation, the
number of sistring trie nodes to consider grows exponentially with k. To see this,
note that at least k characters have to be read in all the sistrings, which gives
a minimum of O((cid:27)k) nodes. This means in particular that if k (cid:21) h then we will
consider the n2 sistrings and the index will be of no use, so we assume k < h;
still stricter conditions will appear later. We (cid:12)rst present a standard technique
and then a pattern partitioning technique.

4.1 Standard Searching

Imagine that for each possible rotation we backtrack on the sistring trie, entering 
into all the possible branches and abandoning a path when more than k
mismatches have occurred. As explained, up to depth k we enter into all the
branches. Since h > k, we have to analyze which branches we enter at depths
k < ‘ (cid:20) h. Since all those strings exist in the sistring trie, this is the same as
to ask how many di(cid:11)erent strings of length ‘ match a pattern pre(cid:12)x of length ‘
with at most k mismatches.

A pessimistic model assumes that there are

ways to choose the cells that
will not match, and (cid:27)k selections for them. As we can replace a cells by itself we
are already counting the cases with less than k errors. The model is pessimistic
because not all these choices lead to di(cid:11)erent strings. To all this we have to add
the fact that we are searching O(‘3=2) di(cid:11)erent strings at depth ‘. Hence, the
total number of sistring trie nodes touched up to level h is

(cid:1)

(cid:0)

‘
k

kX

hX

(cid:18)

(cid:19)

‘
k

(cid:18)

(cid:18)

(cid:19)(cid:19)

h
k

‘3=2(cid:27)‘ +

‘3=2

(cid:27)k = O

h3=2(cid:27)k

‘=1

‘=k+1

For the second part of the search, we consider that there are on average n2=(cid:27)‘
sistrings of length ‘ > h equal to a given string. So the total amount of nodes

touched after level h isX

(cid:18)

(cid:19)

‘3=2

‘
k

(cid:27)k n2
(cid:27)‘

‘(cid:21)h+1

(cid:18)

(cid:19)

‘3=2n2

‘
k

1
(cid:27)‘−k

X
(cid:1) 1

‘(cid:21)h+1

=

(cid:0)

In the Appendix A we show that

‘
k

(cid:27)‘−k is exponentially decreasing with ‘

for

‘ > k(cid:3)
p

H =

k

1 − e=(cid:27)

while otherwise it is Ω(1=

‘).

An Index for Two Dimensional String Matching Allowing Rotations
H. If h (cid:20) k(cid:3)

Therefore, the result depends on whether or not h > k(cid:3)

H, then
the (cid:12)rst term of the summation alone is Ω(hn2) and there is no sublinearity. If,
on the other hand, h > k(cid:3)
H, we have an exponentially decreasing series where
the (cid:12)rst term dominates the whole summation. That is, the cost of the search
in levels deeper than h is

67

(cid:18)

(cid:19)

(cid:18)

(cid:19)

(cid:16)

(cid:17)

h3=2n2

h
k

1

(cid:27)h−k

= h3=2

h
k

(cid:27)k = O

(log(cid:27) n)k+3=2((cid:27)=k)k

which matches the cost of the (cid:12)rst part of the search as well. Therefore, the
condition for a sublinear search time is k(cid:3)
H < h < m2. This in particular implies
that (cid:11) < 1 − e=(cid:27).

4.2 Pattern Partitioning

The above search time is still polylogarithmic in n, but exponential in k. We
present now a pattern partitioning technique that obtains a cost of the form
O(n2(cid:21)) for (cid:21) < 1. The idea is to split the pattern in j2 pieces (j divisions across
each coordinate). If there are at most k mismatches in a match, then at least
one of the pieces must have at most bk=j2c errors. So the technique is to search
for each of the j2 pieces (of size (m=j)(cid:2) (m=j)) separately allowing k=j2 errors,
and for each (rotated) match of a piece in the text, go to the text directly and
check if the match can be extended to a complete occurrence with k errors. Note
that the (cid:11) for the pieces is the same as for the whole pattern.

The center{to{center assumption does not hold when searching for the pieces.
However, for each possible rotation of the whole pattern that matches with the
center{to{center assumption, it is possible to (cid:12)x some position of the center of
each piece inside its text cell. (The center of the piece is ambiguous, as there
are in(cid:12)nitely many angles for the matching pattern: there are O(m3) di(cid:11)erent
relevant rotations of the pattern, and between the corresponding angles, there are
in(cid:12)nitely many angles where the occurrence status does not change. However,
any of the possible positions for the center of the pieces can be chosen). The
techniques developed to read the text in rotated form can be easily adapted to
introduce a (cid:12)xed o(cid:11)set at the center of the matching subpattern. Therefore we
search each of the j2 pieces in every of the O(m3) di(cid:11)erent rotations.

The search cost for this technique becomes j2m3 times the cost to search a
piece (with a (cid:12)xed rotation and center o(cid:11)set) in the sistring trie and the cost to
check for a complete occurrence if the piece is found.
If we consider that (m=j)2 (cid:20) h, then all the strings exist when a piece is
searched. Therefore the cost to traverse the sistring trie for a piece at a (cid:12)xed
rotation is equivalent to the number of strings that can be obtained with k
mismatches from it, i.e.

(cid:18)

(cid:19)

U =

(m=j)2
k=j2

(cid:27)k=j2

while the cost to check all the U candidates is U kn2=(cid:27)(m=j)2, i.e. k times per
generated string times the average number of times such a string appears in the

68

K. Fredriksson, G. Navarro, and E. Ukkonen

text. Therefore the overall cost is

(cid:18)

j2m3

U + U k

(cid:19)

n2

(cid:27)(m=j)2

p

where (after distributing the initial factor) the (cid:12)rst term decreases and the second 
term increases as a function of j. The optimum is found when both terms
2 log(cid:27) n which is in the limit of our condition (m=j)2 (cid:20) h. In
meet, i.e. j = m=
fact, the second term is decreasing only for (cid:11) < 1− e=(cid:27), otherwise the optimum
is j = 1, i.e. no pattern partitioning.

For this optimal j, the overall time bound becomes

(cid:18)

O

m5
log(cid:27) n

n2((cid:11)+HH

(cid:27) ((cid:11)))

(cid:19)

(cid:27) ((cid:11)) = −(cid:11) log(cid:27)((cid:11)) − (1 − (cid:11)) log(cid:27)(1 − (cid:11)):

where we have written H H
This bound is sublinear as long as (cid:11) < 1 − e=(cid:27). On the other hand, we can
consider to use a larger j, violating the assumed condition (m=j)2 (cid:20) h in order
to reduce the veri(cid:12)cation time. However, the search time will not be reduced
and therefore the time bound cannot decrease.

5 The Grays Model

In the Grays model a match requires that the color of text cell must be between
the minimum and maximum pattern colors in a neighborhood of the pattern cell
that corresponds to the text cell. In this case, we do not enter into a single branch
of the sistring trie, but for each pattern cell we follow all branches where color is
between the minimum and maximum neighbor of that pattern cell. The number
of characters qualifying for the next pattern character is a random variable that
we call (cid:1), where 1 (cid:20) (cid:1) (cid:20) (cid:27).
hX

Since there are now O((cid:1)‘) possible strings that match the pattern pre(cid:12)x of

length ‘, we touch

‘3=2(cid:1)‘ = O(h3=2(cid:1)h)

‘=1

sistring trie nodes up to depth h, because all those qualifying strings exist up to
that depth. From that depth on, there are on average O(n2=(cid:27)‘) sistrings in the
text matching a given string of length ‘. Therefore, the work in the deeper part

of the sistring trie isX
‘3=2 n2
(cid:27)‘

‘>h

(cid:19)

(cid:18)

h3=2 n2
(cid:27)h

(cid:1)‘ = O

(cid:1)h

= O(h3=2(cid:1)h)

since the (cid:12)rst term of the summation dominates the rest. Therefore, the total
complexity is

(cid:16)

(cid:17)

(cid:16)

O(h3=2(cid:1)h) = O

(log(cid:27) n)3=2n2 log(cid:27) (cid:1)

= O

(log(cid:27) n)3=2n2(1−log(cid:27) 5=4)

:

(cid:17)

An Index for Two Dimensional String Matching Allowing Rotations

69

Here the last step is based on that (cid:1), the average value of (cid:1), equals (4=5)(cid:27)
as the di(cid:11)erence between the maximum and minimum of 9 values uniformly
distributed over (cid:27) On the other hand, the cost function is concave in terms of
(cid:1), and hence f((cid:1)) (cid:20) f((cid:1)). In practice (cid:1) is much less than (4=5)(cid:27), see [5].

6 The Accumulated Model

Even more powerful model is the Accumulated model, which provides a Hamminglike 
matching capability for gray-level images. Here, the sum of the absolute
di(cid:11)erences between text colors and the color of the corresponding pattern cell
must not exceed k.

As for the Hamming model, we have to enter, for each relevant rotation, into
all the branches of the sistring trie until we obtain an accumulated di(cid:11)erence larger 
than k. We present (cid:12)rst a standard approach and then a pattern partitioning
technique.

6.1 Standard Searching
We enter into all the branches of the sistring trie until we can report a match or
the sum of the di(cid:11)erences exceeds k. As we show in Appendix B, the number of
.
strings matching a given string of length ‘ under this model is at most 2‘
Since up to length h all them exist, we traverse

(cid:0)

(cid:1)

k+‘

k

(cid:18)

(cid:19)

‘3=22‘

k + ‘

k

hX

‘=1

(cid:18)

(cid:19)(cid:19)

k + h

k

= O

h3=22h

nodes in the trie. For the deeper parts of the trie there are O(n2=(cid:27)‘) strings
matching a given one on average, so the rest of the search takes
k + ‘

X

k + ‘

(cid:18)

(cid:19)

(cid:18)

(cid:19)

‘3=2 n2 2‘
(cid:27)‘

k

‘3=2 n2
(cid:27)‘

2‘

(cid:0)
p
for k=‘ < (cid:27)=(2e) − 1, otherwise it is Ω(1=

In Appendix B we show that (2=(cid:27))‘

‘>h

k

k+‘

k

=

is exponentially decreasing with ‘

‘). Therefore, we de(cid:12)ne

(cid:18)

X
(cid:1)

‘>h

k(cid:3)
A =

k

(cid:27)=(2e) − 1

and if h (cid:20) k(cid:3)
on the other hand, h > k(cid:3)
(cid:19)(cid:19)
rest, for a total search cost of

(cid:18)

(cid:18)

O

h3=22h

= O

k + h

k

A the summation is at least O(hn2) and therefore not sublinear. If,
A, then the (cid:12)rst term of the summation dominates the

 
(log(cid:27) n)3=2n2 log(cid:27) 2

(cid:18)

1 +

2 log(cid:27) n

k

!

(cid:19)k

which is sublinear in n for (cid:27) > 2. On the other hand, (cid:27) = 2 means a bilevel image,
where the Hamming model is the adequate choice. Hence we obtain sublinear
complexity (albeit exponential on k) for k(cid:3)

A < 2 log(cid:27) n.

70

K. Fredriksson, G. Navarro, and E. Ukkonen

6.2 Pattern Partitioning

As for the Hamming model, we can partition the pattern to j2 subpatterns that
are searched exhaustively in the sistring trie. Again considering (m=j)2 (cid:20) h we
have a total search cost of

j2m3

U + U k

n2

(cid:27)(m=j)2

(cid:18)

(cid:18)

(cid:19)

(cid:19)

(cid:19)

where this time

U = 2(m=j)2

(m=j)2 + k=j2

k=j2

After distributing the initial factor of the cost formula, we see that the (cid:12)rst
term decreases and the second term increases as a function of j. The optimum is
2 log(cid:27) n which is consifound 
when both terms meet, which is again j = m=
stent with our condition (m=j)2 (cid:20) h. In fact, the second term is decreasing only
for (cid:11) < (cid:27)=(2e) − 1, otherwise the optimum is j = 1, i.e. no pattern partitioning.

p

For this optimal j, the overall complexity is

(cid:18)

O

m5
log(cid:27) n

n2(log(cid:27) 2+H A

(cid:27) ((cid:11)))

where we have de(cid:12)ned H A

This complexity is sublinear as long as (cid:11) < (cid:27)=(2e)−1. Again, we can consider

(cid:27) ((cid:11)) = −(cid:11) log(cid:27)((cid:11)) + (1 + (cid:11)) log(cid:27)(1 + (cid:11)):

to use a larger j value but the complexity does not improve.

7 An Alternative Matching Model

We have considered up to now that text centers match the value of the pattern
cells they lie in. This has been done for technical convenience, although an
equally reasonable alternative model is that the pattern cells must match the
text color where their centers lie in the text.

Except for the Grays model, all the algorithms considered can be adapted to
this case. The algorithms are more complex in practice now, because there may
be more than one pattern center lying at the same text cell, and even no pattern
center at all. This means that in some branches of the sistring trie we may have
more than one condition to (cid:12)t (which may be incompatible and then the branch
can be abandoned under some models) and there may be no condition at all, in
which case we have to follow all the branches at that level of the trie.

On average, however, we still have (cid:2)(‘) conditions when entering in the
sistring trie with a pattern string of length ‘, and therefore all the time bounds
remain the same. However, in the Exact matching model, we can do better using
the pattern centers.

We consider now indexing the rotated versions of the text sistrings, instead of
considering the rotated versions of the pattern at search time. Hence, the pattern
is simply searched with no rotations. Imagine that we index all the rotations of

An Index for Two Dimensional String Matching Allowing Rotations

71

the text up to depth H. This means that there will be O(n2H3=2) sistrings, and
the sizes of the sistring trie and array will grow accordingly.

The bene(cid:12)t comes at search time: in the (cid:12)rst part of the search we do not
need to consider rotations of the pattern, since all the rotated ways to read the
text are already indexed. Since we index O(n2H3=2) strings now, all the di(cid:11)erent
sistrings will exist until depth h0 = log(cid:27)(n2H3=2) = 2 log(cid:27) n+3=2 log(cid:27) H. We (cid:12)rst
assume that H (cid:21) h0. This means that until depth H we pay O(H). After that
depth all the surviving rotations are considered. Since H (cid:21) h0, they all yield
di(cid:11)erent strings, and the summation, as in Section 3, yields O(n2H3=2=(cid:27)H).
Therefore the total search time is

(cid:18)

(cid:19)

O

H + n2H3=2

(cid:27)H

which is optimized for H = 2 log(cid:27) n + (1=2) log(cid:27) H. Since this is smaller than h0
we take the minimal H = h0. For instance H = x log(cid:27) n works for any x > 2.
This makes the total search time O(log(cid:27) n) on average. The space complexity
becomes now O(n2(log(cid:27) n)3=2). Trying to use H < h0 worsens the complexity.
The matching model has changed, however. In the normal index the text
sistrings are indexed once at a (cid:12)xed rotation (zero). When a given pattern rotation 
is tried, the pattern is read in rotated form, in an order driven by the text
centers. Now the text sistrings are read in all the rotated forms, and the pattern
will be read once. The way to index a text sistring in rotated form is to assume
that a rotated pattern is superimposed onto it and read the text cells where the
pattern cells, read in order, fall. This e(cid:11)ectively corresponds to the model we
are considering in this section.

8 Experimental Results (Preliminary)

We have implemented the algorithms for Exact and Accumulated models, without 
the pattern partitioning technique. For the index structure, we used sistring
array. The array based implementation is much more space e(cid:14)cient, but the
search cost is also higher (both asymptotically and by the constant factors).

The implementation is in C, compiled using gcc 2.95.2 on Linux 2.0.38,
running in 700MHz PentiumIII machine. The implementation is not very optimized,
 and much of the time is spent in trigonometry; for computing the next
angle to try, and for computing the coordinates of the cells for the given angle.
Our test text was an image of size 768 (cid:2) 768 cells, with 35 colors (gray levels),
and a pattern of size 41 (cid:2) 41 was extracted from it.

Table 2 shows some timings for the search. The di(cid:11)erence between the times
of the Exact model and the Accumulated model with k = 0 reveals the more
complex implementation of the Accumulated model. Our results show that the
algorithms can be implemented, and although preliminary versions, they run
reasonably fast. For comparison, our optimized O(n2(k=(cid:27))3=2) expected time
on{line algorithm [4] spends 0.81 seconds for k = 0, 1.67 seconds for k = 8, 3.62
seconds for k = 192, and 3.85 seconds for k = 256. With the pattern partitioning,
the algorithms would be much faster for large k.

72

K. Fredriksson, G. Navarro, and E. Ukkonen

k

Exact

0

1

time 0.0055 0.0086 0.0088 0.0089 0.0090 0.0097 0.0110 0.0165 0.0567 0.1720 0.3930 2.0390 6.3910

2

4

8

16

32

64

96

128

192

256

Table 2. Experimental results for the Exact and Accumulated models. The times are
given in seconds.

9 Conclusions and Future Work

We have proposed a sistring tree index to search two dimensional patterns in
two dimensional texts allowing rotations. We have considered di(cid:11)erent matching
models and obtained average time bounds that are sublinear for most reasonable
cases.

It is possible to extend the model by removing the center{to{center assumption 
[4]. In this case the number of patterns grows as high as O(m7) and therefore
there are O(‘7=2) sistrings to search at depth ‘. The search time for the Exact
model becomes O(log(cid:27) n)9=2. By indexing all the rotations and center displacements 
we get O(log(cid:27) n) time again, but at a space cost of O(n2(log(cid:27) n)7=2).

It is also possible to extend the methods to three dimensions [6]. With the
center{to{center assumption we have O(m11) rotations. This means O(‘11=3)
sistrings at depth ‘. Therefore, at O(n3) space the total search time becomes
O((log(cid:27) n)14=3) for exact searching. If we index all the rotations up to H =
x log(cid:27) n with x > 3 we will have a space requirement of O(n3(log(cid:27) n)11=3) and a
search cost of O(log(cid:27) n). For the Grays model we have O((log(cid:27) n)11=3n3(1−log(cid:27)
(28=27)) time. All the other techniques can be extended as well.

References

1. A. Amir, G. Benson, and M. Farach. Alphabet independent two dimensional matching.

In N. Alon, editor, Proceedings of the 24th Annual ACM Symposium on
the Theory of Computing, pages 59{68, Victoria, B.C., Canada, May 1992. ACM
Press.

2. A. Amir. Multidimensional pattern matching: A survey. Technical Report GIT-

CC-92/29, Georgia Institute of Technology, College of Computing, 1992.

3. K. Fredriksson and E. Ukkonen. A rotation invariant (cid:12)lter for two-dimensional
string matching. In Proceedings of the 9th Annual Symposium on Combinatorial
Pattern Matching (CPM’98), LNCS 1448, pages 118{125, 1998.

4. K. Fredriksson and E. Ukkonen. Algorithms for 2{d hamming distance under

rotations. Manuscript, 1999.

5. K. Fredriksson and E. Ukkonen. Combinatorial methods for approximate image
matching under translations and rotations. Pattern Recognition Letters, 20(11{
13):1249{1258, 1999.

6. K. Fredriksson and E. Ukkonen. Combinatorial methods for approximate pattern

matching under rotations and translations in 3D arrays. Submitted, 2000.

7. Z. Galil and K. Park. Truly alphabet-independent two-dimensional pattern matching.
 In IEEE, editor, Proceedings of the 33rd Annual Symposium on Foundations
of Computer Science, pages 247{257, Pittsburgh, PN, October 1992. IEEE Computer 
Society Press.

An Index for Two Dimensional String Matching Allowing Rotations

73

8. R. Giancarlo. A generalization of su(cid:14)x trees to square matrices, with applications.

SIAM J. on Computing, 24:520{562, 1995.

9. R. Giancarlo and R. Grossi. On the construction of classes of su(cid:14)x trees for square
matrices: Algorithms and applications. Information and Computation, 130:151{
182, 1996.

10. G. H. Gonnet. E(cid:14)cient searching of text and pictures. Report OED-88-02, University 
of Waterloo, 1988.

11. J. K¨arkk¨ainen and E. Ukkonen. Two and higher dimensional pattern matching in
optimal expected time. In Daniel D. Sleator, editor, Proceedings of the 5th Annual
ACM-SIAM Symposium on Discrete Algorithms, pages 715{723, Arlington, VA,
January 1994. ACM Press.

12. G. M. Landau and U. Vishkin. Pattern matching in a digitized image. Algorithmica,

12(4/5):375{408, October 1994.

13. G. Navarro and R. Baeza-Yates. Fast multi-dimensional approximate string matching.
 In Proceedings of the 10th Annual Symposium on Combinatorial Pattern
Matching (CPM’99), LNCS, pages 243{257, 1999.

14. T. Takaoka. Approximate pattern matching with grey scale values. In Michael E.
Houle and Peter Eades, editors, Proceedings of Conference on Computing: The
Australian Theory Symposium, pages 196{203, Townsville, January 29{30 1996.
Australian Computer Science Communications.

15. J. Tarhio. A sublinear algorithm for two-dimensional string matching. PRL: Pattern 
Recognition Letters, 17, 1996.

16. J. Wood. Invariant pattern recognition: a review. Pattern Recognition, 29(1):1{17,

1996.

A Probability of Matching under the Hamming Model

We need to determine which is the probability of the search being active at a
given node of depth ‘ in the sistring trie under the Hamming model. We are
therefore interested in the probability of a pattern pre(cid:12)x of length ‘ matching
a text substring of length ‘. For this to hold, at least ‘ − k text characters text
must match the pattern. Hence, the probability of matching is upper bounded
by

(cid:18)

(cid:19)

1
(cid:27)‘−k

‘
k

where the combinatorial counts all the possible locations for the matching characters.


In the analysis that follows, we call (cid:12) = k=‘ and take it as a constant (which
is our case of interest, as seen later). We will prove that, after some length ‘,
the matching probability is O(γ((cid:12))‘), for some γ((cid:12)) < 1. By using Stirling’s
2(cid:25)x(1 + O(1=x)) over the matching probability we
approximation x! = (x=e)x
have

p

 

!(cid:18)

p
p
‘‘
kk(‘ − k)‘−k
(cid:19)‘

1

2(cid:25)‘
2(cid:25)k

‘−1=2

1 + O

p
2(cid:25)(‘ − k)
 
1p
2(cid:25)(cid:12)(1 − (cid:12))

(cid:18)

(cid:19)(cid:19)
(cid:19)!

1
‘

(cid:18)

+ O

1
‘

1
(cid:27)‘−k

which is (cid:18)

(cid:27)1−(cid:12)(cid:12)(cid:12)(1 − (cid:12))1−(cid:12)

74

K. Fredriksson, G. Navarro, and E. Ukkonen

p
This formula is of the form γ((cid:12))‘ O(1=

‘), where we de(cid:12)ne

γ(x) =

1

(cid:27)1−xxx(1 − x)1−x

Therefore the probability is exponentially decreasing with ‘ if and only if

γ((cid:12)) < 1, that is,

(cid:18)

(cid:19) 1
1−(cid:12) =

(cid:27) >

1

(cid:12)(cid:12)(1 − (cid:12))1−(cid:12)

1

(cid:12)

1−(cid:12) (1 − (cid:12))

(cid:12)

It is easy to show analytically that e−1 (cid:20) (cid:12)

1−(cid:12) (cid:20) 1 if 0 (cid:20) (cid:12) (cid:20) 1, so it su(cid:14)ces
that (cid:27) > e=(1− (cid:12)), or equivalently, (cid:12) < 1− e=(cid:27) is a su(cid:14)cient condition for the
probability to be exponentially decreasing with ‘.
Hence, the result is that the matching probability is very high for (cid:12) = k=‘ (cid:21)
p
1 − e=(cid:27), and that otherwise it is O(γ((cid:12))‘=

‘), where γ((cid:12)) < 1.

(cid:12)

B Probability of Matching under the Accumulated Model

We need to determine what is the probability of the search being active at a
given node of depth ‘ in the sistring trie under the Accumulated model. We are
therefore interested in the probability of two random strings of length ‘ matching
with at most k errors. Our model is as follows: we consider the sequence of ‘
absolute di(cid:11)erences between both strings (cid:14)1 : : : (cid:14)‘. The matching condition states
that

P‘
i=1 (cid:14)i (cid:20) k.

The number of di(cid:11)erent sequences of di(cid:11)erences satisfying this is

, what
can be seen as the number of ways to insert ‘ divisions into a sequence of k
elements. The ‘ divisions divide the sequence in ‘ + 1 zones. The sizes of the
(cid:12)rst ‘ zones are the (cid:14)i values and the last allows the sum to be (cid:20) k instead of
exactly k. Note that we are pessimistically forgetting about the fact that indeed
(cid:14)i (cid:20) (cid:27).
Finally, each di(cid:11)erence (cid:14)i can be obtained in two ways: Pi +(cid:14)i and Pi−(cid:14)i (we
again pessimistically count twice the case (cid:14)i = 0). Therefore, the total matching
probability is upper bounded by

(cid:0)

(cid:1)

k+‘

‘

(cid:18)

(cid:19)

2‘
(cid:27)‘

‘ + k

k

In the analysis that follows, we call (cid:12) = k=‘ and take it as a constant (which
is our case of interest, as seen later). We will prove that, after some length ‘,
the matching probability is O(γ((cid:12))‘), for some γ((cid:12)) < 1. By using Stirling’s
2(cid:25)x(1 + O(1=x)) over the matching probability we
approximation x! = (x=e)x
have

p

 

p

!(cid:18)

2‘
(cid:27)‘

(k + ‘)k+‘
p

2(cid:25)(k + ‘)
p

kk‘‘

2(cid:25)k

2(cid:25)‘

1 + O

(cid:18)

(cid:19)(cid:19)

1
‘

An Index for Two Dimensional String Matching Allowing Rotations

75

which is

(cid:18)

2(1 + (cid:12))1+(cid:12)

 s

(cid:19)‘

‘−1=2

(cid:19)!

(cid:18)

1
‘

1 + (cid:12)
2(cid:25)(cid:12)

+ O

(cid:27)(cid:12)(cid:12)

p
This formula is of the form γ((cid:12))‘ O(1=

‘), where we de(cid:12)ne

Therefore the probability is exponentially decreasing with ‘ if and only if

γ((cid:12)) < 1, that is,

γ(x) =

2(1 + x)1+x

(cid:27)xx

(cid:18)

(cid:19)(cid:12)

2(1 + (cid:12))

(cid:27)

1 +

1
(cid:12)

< 1

It can be easily seen analytically that (1 + 1=(cid:12))(cid:12) (cid:20) e, so (cid:12) < (cid:27)=(2e) − 1 is
a su(cid:14)cient condition for the probability to be exponentially decreasing with ‘.
Hence, the result is that the matching probability is very high for (cid:12) = k=‘ (cid:21)
p
(cid:27)=(2e) − 1, and that otherwise it is O(γ((cid:12))‘=

‘), where γ((cid:12)) < 1.

