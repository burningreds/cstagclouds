1
1
0
2

 
t
c
O
0
2

 

 
 
]
S
D
.
s
c
[
 
 

1
v
3
9
4
4

.

0
1
1
1
:
v
i
X
r
a

Improved Grammar-Based Compressed Indexes (cid:63)

Francisco Claude1 and Gonzalo Navarro2

1 David R. Cheriton School of Computer Science, University of Waterloo. fclaude@cs.uwaterloo.ca.

2 Department of Computer Science, University of Chile. gnavarro@dcc.uchile.cl.

Abstract. We introduce the ﬁrst grammar-compressed representation of a sequence that supports
searches in time that depends only logarithmically on the size of the grammar. Given a text T [1..u]
that is represented by a (context-free) grammar of n (terminal and nonterminal) symbols and size N
(measured as the sum of the lengths of the right hands of the rules), a basic grammar-based representation 
of T takes N lg n bits of space. Our representation requires 2N lg n + N lg u +  n lg n + o(N lg n)
bits of space, for any 0 <  ≤ 1. It can ﬁnd the positions of the occ occurrences of a pattern of

(cid:1) + occ lg n(cid:1) time, and extract any substring of length (cid:96) of T in time

length m in T in O(cid:0)(m2/) lg(cid:0) lg u

lg n

O((cid:96) + h lg(N/h)), where h is the height of the grammar tree.

1 Introduction and Related Work

Grammar-based compression is an active area of research that dates from at least the seventies. A given
sequence T [1..u] over alphabet [1..σ] is replaced by a hopefully small (context-free) grammar G that generates
just the string T . Let n be the number of grammar symbols, counting terminals and nonterminals. Let N
be the size of the grammar, measured as the sum of the lengths of the right-hand sides of the rules. Then
the grammar-compressed representation of T requires N lg n bits, versus the u lg σ bits required by a plain
representation.

Grammar-based methods can achieve universal compression [21]. Unlike statistical methods, that exploit
frequencies to achieve compression, grammar-based methods exploit repetitions in the text, and thus they are
especially suitable for compressing highly repetitive sequence collections. These collections, containing long
identical substrings, possibly far away from each other, arise when managing software repositories, versioned
documents, temporal databases, transaction logs, periodic publications, and computational biology sequence
databases.
∗ that represents a given text T is NP-complete [33, 9]. Moreover, the
smallest grammar is never smaller than an LZ77 parse [35] of T . A simple method to achieve an O(lg u)-
approximation to the smallest grammar size is to parse T using LZ77 and then to convert it into a grammar

Finding the smallest grammar G

[33]. A more sophisticated approximation achieves ratio O(lg(u/N∗)), where N∗ is the size of G

While grammar-compression methods are strictly inferior to LZ77 compression, and some popular grammar-

∗.

based compressors such as LZ78 [36], Re-Pair [24] and Sequitur [30], can generate sizes much larger than the
smallest grammar [9], some of those methods (in particular Re-Pair) perform very well in practice, both in
classical and repetitive settings.3

In reward, unlike LZ77, grammar compression allows one to decompress arbitrary substrings of T almost
optimally [16, 6]. The most recent result [6] extracts any T [p, p + (cid:96) − 1] in time O((cid:96) + lg u). Unfortunately,
the representation that achieves this time complexity requires O(N lg u) bits, possibly proportional but in
practice many times the size of the output of a grammar-based compressor. On the practical side, applications
like Comrad [23] achieve good space and time performance for extracting substrings of T .

More ambitious than just extracting arbitrary substring from T is to ask for indexed searches, that is,
ﬁnding all the occ occurrences in T of a given pattern P [1..m]. Self-indexes are compressed text representations 
that support both operations, extract and search, in time depending only polylogarithmically on u.

(cid:63) This work was partially supported by Google U.S./Canada PhD Fellowship and David R. Cheriton Scholarships
program (ﬁrst author), and by Millennium Institute for Cell Dynamics and Biotechnology (ICDB), Grant ICM
P05-001-F, Mideplan, Chile (second author).

3 See the statistics in http://pizzachili.dcc.uchile.cl/repcorpus.html for a recent experiment.

They have appeared in the last decade [28], and have focused mostly on statistical compression. As a result,
they work well on classical texts, but not on repetitive collections [25]. Some of those self-indexes have been
adapted to repetitive collections [25], but they cannot reach the compression ratio of the best grammar-based
methods.

Searching for patterns on grammar-compressed text has been faced mostly in sequential form [2], that
is, scanning the whole grammar. The best result [20] achieves time O(N + m2 + occ). This may be o(u), but
still linear in the size of the compressed text. There exist a few self-indexes based on LZ78-like compression
[15, 3, 32], but LZ78 is among the weakest grammar-based compressors. In particular, LZ78 has been shown
not to be competitive on highly repetitive collections [25].

The only self-index supporting general grammar compressors [13] operates on “straight-line programs”
(SLPs), where the right hands of the rules are of length 1 or 2. Given such a grammar they achieve, among
other tradeoﬀs, 3n lg n + n lg u bits of space and O(m(m + h) lg2 n) search time, where h is the height of
the parse tree of the grammar. A general grammar of n symbols and size N can be converted into a SLP of
N − n rules.
More recently, a self-index based on LZ77 compression has been developed [22]. Given a parsing of T
into n phrases, the self-index uses n lg n + 2n lg u + O(n lg σ) bits of space, and searches in time O(m2h +
(m + occ) lg n), where h is the nesting of the parsing. Extraction requires O((cid:96)h) time. Experiments on
repetitive collections [11, 12] show that the grammar-based compressor [13] can be competitive with the best
classical self-index adapted to repetitive collections [25] but, at least that particular implementation, is not
competitive with the LZ77-based self-index [22].

Note that the search time in both self-indexes depends on h. This is undesirable as h is only bounded by

n. That kind of dependence has been removed for extracting text substrings [6], but not for searches.

Our main contribution is a new representation of general context-free grammars. The following theorem

summarizes its properties. Note that the search time is independent of h.

(cid:16)

(cid:17)

+ occ lg n

Theorem 1. Let a sequence T [1..u] be represented by a context free grammar with n symbols, size N and
height h. Then, for any 0 <  ≤ 1, there exists a data structure using at most 2N lg n + N lg u +  n lg n +
in T in time
o(N lg n) bits of
. It can extract any substring of length (cid:96) from T in time O((cid:96) + h lg(N/h)).
O
The structure can be built in O(u + N lg N ) time and O(u lg u) bits of working space.

the occ occurrences of any pattern P [1..m]

space that ﬁnds

(m2/) lg

(cid:16) lg u

(cid:17)

lg n

In the rest of the paper we describe how this structure operates. First, we preprocess the grammar to
enforce several invariants useful to ensure our time complexities. Then we use a data structure for labeled
binary relations [13] to ﬁnd the “primary” occurrences of P , that is, those formed when concatenating
symbols in the right hand of a rule. To get rid of the factor h in this part of the search, we introduce a
new technique to extract the ﬁrst m symbols of the expansion of any nonterminal in time O(m). To ﬁnd
the “secondary” occurrences (i.e., those that are found as the result of the nonterminal containing primary
occurrences being mentioned elsewhere), we use a pruned representation of the parse tree of T . This tree is
traversed upwards for each secondary occurrence to report. The grammar invariants introduced ensure that
those traversals amortize to a constant number of steps per occurrence reported. In this way we get rid of
the factor h on the secondary occurrences too.

2 Basic Concepts

2.1 Sequence Representations

Our data structures use succinct representations of sequences. Given a sequence S of length N , drawn from
an alphabet of size n, we need to support the following operations:

– access(S, i): retrieves the symbol S[i].
– ranka(S, i): number of occurrences of a in S[1..i].
– selecta(S, j): position where the jth a appears in S.

2

In the case where n = 2, Raman et al. [31] proposed two compressed representations of S, that are
useful when the number n(cid:48) of 1s in S is small (or large, which is not the case in this paper). One is
called a “fully indexable dictionary” (FID). It takes n(cid:48) lg N
n(cid:48) + O(n(cid:48) + N lg lg N/ lg N ) bits of space and
supports all the operations in constant time. A weaker one is an “indexable dictionary” (ID), that takes
n(cid:48) + O(n(cid:48) + lg lg N ) bits of space and supports in constant time queries access(S, i), rank(S, i) if
n(cid:48) lg N
S[i] = 1, and select1(S, j).

For general sequences, the wavelet tree [18] requires N lg n + o(N ) bits of space [17] and supports all three
operations in O(lg n) time. Another representation, by Barbay et al. [4], requires at most N lg n + o(N lg n)
bits and solves access(S, i) in constant time and select(S, j) in time O(lg lg n), or vice versa. Query rank(S, i)
takes time O(lg lg n).

2.2 Labeled Binary Relations

A labeled binary relation corresponds to a binary relation R ⊆ A × B, where A = [1..n1] and B = [1..n2],
augmented with a function L : A × B → L ∪ {⊥}, L = [1..(cid:96)], that deﬁnes labels for each pair in R, and ⊥
for pairs that are not in R. Let us identify A with the columns and B with the rows in a table. We describe
a simpliﬁcation of a representation of binary relations [13, 14], for the case of this paper where each element
of A is associated to exactly one element of B, so |R| = n1. We use a string SB[1..n1] over alphabet [1..n2],
where SB[i] is the element of B associated to column i. A second string SL[1..n1] on alphabet [1..(cid:96)] is stored,
so that SL[i] is the label corresponding to the pair represented by SB[i].

If we use a wavelet tree for SB (see Section 2.1) and a plain string representation for SL, the total space
is n1(lg n2 + lg (cid:96)) + O(n1) bits. With this representation we can answer, among others, the following queries
of interest in this paper.

– Find the label of the element b associated to a given a, SL[a], in O(1) time.
– Enumerate the k pairs (a, b) ∈ R such that a1 ≤ a ≤ a2 and b1 ≤ b ≤ b2, in O((k + 1) lg n2) time.

2.3 Succinct Tree Representations

There are many succinct tree representations for trees T with N nodes. Most take 2N + o(N ) bits of space.
In this paper we use one called DFUDS [5], which in particular answers in constant time the following
operations. Node identiﬁers v are associated to a position in [1..2N ].

– node(p): the node with preorder number p.
– preorder(v): the preorder number of node v.
– leafrank (v): number of leaves to the left of v.
– numleaves(v): number of leaves below v.
– parent(v): the parent of v.
– child(v, k): the kth child of v.
– nextsibling(v): the next sibling of v.
– degree(v): the number of children of v.
– depth(v): the depth of v.
– level -ancestor (v, k): the kth ancestor of v.

The DFUDS representation is obtained by traversing the tree in DFS order and appending to a bitmap

the degree of each node, written in unary.

3 Preprocessing and Representing the Grammar

Let G be a grammar that generates a single string T [1..u], formed by n (terminal and nonterminal) symbols.
The σ ≤ n terminal symbols come from an alphabet Σ = [1, σ],4 and then G contains n − σ rules of the
4 Non-contiguous alphabets can be handled with some extra space, as shown in previous work [14].

3

form Xi → αi, one per nonterminal. This αi is called the right-hand side of the rule. We call N =(cid:80)

|αi|
the size of G. Note it holds σ ≤ N , as the terminals must appear in the right-hand sides. We assume all
the nonterminals are used to generate the string; otherwise unused rules can be found and dropped in O(N )
time.

decreasing n and without increasing N .

We preprocess G as follows. First, for each terminal symbol a ∈ Σ present in G we create a rule Xa → a,
and replace all other occurrences of a in the grammar by Xa. As a result, the grammar contains exactly n
nonterminal symbols X = {X1, . . . , Xn}, each associated to a rule Xi → αi, where αi ∈ Σ or αi ∈ X +. We
assume that Xn is the start symbol.
Any rule Xi → αi where |αi| ≤ 1 (except for Xa → a) is removed by replacing Xi by αi everywhere,
We further preprocess G to enforce the property that any nonterminal Xi, except Xn and those Xi →
a ∈ Σ, must be mentioned in at least two right-hand sides. We traverse the rules of the grammar, count
the occurrences of each symbol, and then rewrite the rules, so that only the rules of those Xi appearing
more than once (or the excepted symbols) are rewritten, and as we rewrite a right-hand side, we replace any
(non-excepted) Xi that appears once by its right-hand side αi. This transformation takes O(N ) time and
does not alter N (yet it may reduce n).

the original grammar (the transformed one has size at most N + σ).

Note that n is now the number of rules in the transformed grammar G. We will still call N the size of
We call F(Xi) the single string generated by Xi, that is F(Xi) = a if Xi → a and F(Xi) = F(Xi1) . . .F(Xik )
if Xi → Xi1 . . . Xik . G generates the text T = L(G) = F(Xn).
Our last preprocessing step, and the most expensive one, is to renumber the nonterminals so that i < j ⇔
F(Xi)rev < F(Xj)rev, where Srev is string S read backwards. The usefulness of this reverse lexicographic
order will be apparent later. The sorting can be done in time O(u + n lg n) and O(u lg u) bits of space [13,
14], which dominates the previous time complexities. Let us say that Xn became Xs after the reordering.

We deﬁne now a structure that will be key in our index.

Deﬁnition 1. The grammar tree of G is a general tree TG with nodes labeled in X . Its root is labeled Xs.
Let αs = Xs1 . . . Xsk . Then the root has k children labeled Xs1, . . . , Xsk . The subtrees of these children are
deﬁned recursively, left to right, so that the ﬁrst time we ﬁnd a symbol Xi, we deﬁne its children using αi.
However, the next times we ﬁnd a symbol Xi, we leave it as a leaf of the grammar tree (if we expanded it the
resulting tree would be the parse tree of T , with u nodes). Also symbols Xa → a are not expanded but left as
leaves. We say that Xi is deﬁned in the only internal node of TG labeled Xi.

Since each right-hand side αi (cid:54)= a ∈ Σ is written once in the tree, plus the root Xs, the total number of
The grammar tree partitions T in a way that is useful for ﬁnding occurrences, using a concept that dates

nodes in TG is N + 1.
back to K¨arkk¨ainen [19], who used it for Lempel-Ziv parsings.

Deﬁnition 2. Let Xl1 , Xl2, . . . be the nonterminals labeling the consecutive leaves of TG. Let Ti = F(Xli),
then T = T1T2 . . . is a partition of T according to the leaves of TG. An occurrence of pattern P in T is called
primary if it spans more than one Ti, and secondary if it is inside some Ti.

Figure 1 shows the reordering and grammar tree for a grammar generating the string “alabaralalabarda”.
Our self-index will represent G using two main components. A ﬁrst one represents the grammar tree TG
using a DFUDS representation (Section 2.3) and a sequence of labels (Section 2.1). This will be used to
extract text and decompress rules. When augmented with a secondary trie TS storing leftmost/rightmost
paths in TG, the representation will expand any preﬁx/suﬃx of a rule in optimal time [16].
The second component in our self-index corresponds to a labeled binary relation (Section 2.2), where
B = X and A is the set of proper suﬃxes starting at positions j + 1 of rules αi: (αi[j],(cid:104)i, j + 1(cid:105)) will be
related for all Xi → αi and 1 ≤ j < |αi|. This binary relation will be used to ﬁnd the primary occurrences
of the search pattern. Secondary occurrences will be tracked in the grammar tree.

4

Fig. 1. On top left, a grammar G generating string “alabaralalabarda”. On top right, our reordering of the grammar
and strings F(Xi). In the middle, the grammar tree TG in black; the whole parse tree includes also the grayed part.
On the bottom we show our bitmap L (Section 4.2).

4 Extracting Text

We ﬁrst describe a simple structure that extracts the preﬁx of length (cid:96) of any rule in O((cid:96) + h) time. We
then augment this structure to support extracting any substring of length (cid:96) in time O((cid:96) + h lg(N/h)), and
ﬁnally augment it further to retrieve the preﬁx or suﬃx of any rule in optimal O((cid:96)) time. This last result is
fundamental for supporting searches, and is obtained by extending the structure proposed by Gasieniec et
al. [16] for SLPs to general context-free grammars generating one string. The improvement does not work for
extracting arbitrary substrings, as in that case one has to ﬁnd ﬁrst the nonterminals that must be expanded.
This subproblem is not easy, especially in little space [6].

As anticipated, we represent the topology of the grammar tree TG using DFUDS [5]. The sequence of
labels associated to the tree nodes is stored in preorder in a sequence X[1..N +1], using the fast representation
of Section 2.1 where we choose constant time for access(X, i) = X[i] and O(lg lg n) time for selecta(X, j).
We also store a bitmap Y [1..n] that marks the rules of the form Xi → a ∈ Σ with a 1-bit. Since the
rules have been renumbered in (reverse) lexicographic order, every time we ﬁnd a rule Xi such that Y [i] = 1,
we can determine the terminal symbol it represents as a = rank1(Y, i) in constant time. In our example of
Figure 1 this vector is Y = 101011100.

4.1 Expanding Preﬁxes of Rules
Expanding a rule Xi that does not correspond to a terminal is done as follows. By the deﬁnition of TG, the
ﬁrst left-to-right occurrence of Xi in sequence X corresponds to the deﬁnition of Xi; all the rest are leaves
in TG. Therefore, v = node(selectXi (X, 1)) is the node in TG where Xi is deﬁned. We traverse the subtree
rooted at v in DFS order. Every time we reach a leaf u, we compute its label Xj = X[preorder(u)], and
either output a terminal if Y [j] = 1 or recursively expand Xj. This is in fact a traversal of the parse tree
starting at node v, using instead the grammar tree. Such a traversal takes O((cid:96) + hv) steps [13, 14], where

5

X1→aX2→X9X1X6X9X5X1X3→bX4→X1X6X1X3X5→dX6→lX7→rX8→X1X7X9→X4X8⇒¯X1→a¯X2→b¯X3→d¯X4→l¯X5→r¯X6→¯X1¯X5¯X7→¯X1¯X4¯X1¯X2¯X8→¯X7¯X6¯X9→¯X8¯X1¯X4¯X8¯X3¯X1X2aalabaralalabardabalabdlraralabarX9X1X6X9X5X1X4X8X1X7X1X6X1X3X4X8X1X7X1X6X1X3X1X6X1X3X1X7X1X6X9X5X1L=1111111110000011hv ≤ h is the height of the parsing subtree rooted at v. In particular, if we extract the whole rule Xi we pay
O((cid:96)) steps, since we have removed unary paths in the preprocessing of G and thus v has (cid:96) > hv leaves in
the parse tree. The only obstacle to having constant-time steps are the queries selectXi(X, 1). As these are
only for the position 1, we can have them precomputed in a sequence F [1..n] using n(cid:100)lg N(cid:101) = n lg n + O(N )
further bits of space.
The total space required for TG, considering the DFUDS topology, sequence X, bitmap Y , and sequence
F , is N lg n + n lg n + o(N lg n) bits. We reduce the space to N lg n + δ n lg n + o(N lg n), for any 0 < δ ≤ 1,
as follows. Form a sequence X(cid:48)[1..N − n + 1] where the ﬁrst position of every symbol Xi in X has been
removed, and mark in a bitmap Z[1..N + 1], with a 1, those ﬁrst positions in X. Replace our sequence
F by a permutation π[1..n] so that selectXi(X, 1) = F [i] = select1(Z, π[i]). Now we can still access any
X[i] = X(cid:48)[rank0(Z, i)] if Z[i] = 0. For the case Z[i] = 1 we have X[i] = π−1[rank1(Z, i)]. Similarly,
selectXi(X, j) = select0(Z, selectXi(X(cid:48), j − 1)) for j > 1. Then use Z, π, and X(cid:48) instead of F and S.
All the operations retain the same times except for the access to π−1. We use for π a representation by
Munro et al. [27] that takes (1 + δ)n lg n bits and computes any π[i] in constant time and any π−1[j] in
time O(1/δ), which will be the cost to access X. Although this will have an impact later, we note that for
extraction we only access X at leaf nodes, where it always takes constant time.5

4.2 Extracting Arbitrary Substrings

In order to extract any given substring of T , we add a bitmap L[1..u + 1] that marks with a 1 the ﬁrst
position of each Ti in T (see Figure 1). We can then compute the starting position of any node v ∈ TG as
select1(L, leafrank (v) + 1).
To extract T [p, p + (cid:96) − 1], we binary search the starting position p from the root of TG. If we arrive at a
leaf that does not represent a terminal, we go to its deﬁnition in TG, translate position p to the area below
the new node v, and continue recursively. At some point we ﬁnally reach the position p, and from there on
we extract the symbols rightwards. Just as before, the total number of steps is O((cid:96) + h). However, the h
steps require binary searches. As there are at most h binary searches among the children of diﬀerent tree
nodes, and there are N + 1 nodes, in the worst case the binary searches cost O(h lg(N/h)), thus the total
cost is O((cid:96) + h lg(N/h)).

The number of ones in L is at most N . Since we only need select1 on L, we can use an ID representation
(see Section 2.1), requiring N lg(u/N ) + O(N + lg lg u) = N lg(u/N ) + O(N ) bits (since N ≥ lg u in any
grammar). Thus the total space becomes N lg n + N lg(u/N ) + δ n lg n + o(N lg n) bits.

4.3 Optimal Expansion of Rule Preﬁxes and Suﬃxes

Our improved version builds on the proposal by Gasieniec et al. [16]. We show how to extend their representation 
using succinct data structures so that we can handle general grammars instead of only SLPs.
Following their notation, call S(Xi) the string of labels of the nodes in the path from any node labeled Xi
to its leftmost leaf in the parse tree (we take as leaves the nonterminals Xa ∈ X , not the terminals a ∈ Σ).
We insert all the strings S(Xi)rev into a trie TS. Note that each symbol appears only once in TS [16], thus it
has n nodes. Again, we represent the topology of TS using DFUDS. However, its sequence of labels XS[1..n]
turns out to be a permutation in [1..n], for which we use again the representation by Munro et al. [27] that
takes (1 + )n lg n bits and computes any XS[i] in constant time and any X

−1
S [j] in time O(1/).

We can determine the ﬁrst terminal in the expansion of Xi, which labels node v ∈ TS, as follows. Since
the last symbol in S(Xi) is a nonterminal Xa representing some a ∈ Σ, it follows that Xi descends in
TS from Xa, which is a child of the root. This node is va = level -ancestor (v, depth(v) − 1). Then a =
rank1(Y, XS[preorder(va)]). Figure 2 shows an example of this particular query in the trie for the grammar
presented in Figure 1.
5 Nonterminals Xa → a do not have a deﬁnition in TG, so they are not extracted from X nor represented in π, thus
they are accessed in constant time. They can be skipped from π[1..n] with bitmap Y , so that in fact π is of length
n − σ an is accessed as π[rank0(Y, i)]; for π−1 we actually use select0(Y, π−1[j]).

6

Fig. 2. Example of the trie of leftmost paths for the grammar of Figure 1. The arrow pointing from X2 to X1 ilustrates
the procedure to determine the ﬁrst terminal symbol generated by X2.

A preﬁx of Xi is extracted as follows. First, we obtain the corresponding node v ∈ TS as v = X

−1
S [Xi].
Then we obtain the leftmost symbol of v as explained. The remaining symbols descend from the second and
following children, in the parse tree, of the nodes in the upward path from a node labeled Xi to its leftmost
leaf, or which is the same, of the nodes in the downward path from the root of TS to v. Therefore, for
each node w in the list level -ancestor (v, depth(v) − 2), . . . , parent(v), v, we map w to its deﬁnition u ∈ TG,
u = node(selectXj (X, 1)) where Xj = XS[preorder(w)]. Once u is found, we recursively expand its children,
from the second to the last, by mapping them back to TS, and so on. By charging the cost to the new symbol
to expand, and because there are no unary paths, it can be seen that we carry out O((cid:96)) steps to extract
the ﬁrst (cid:96) symbols. Moreover, the extraction is real-time [16]. All costs per step are constant except for the
O(1/) to access X

−1
S .

For extracting suﬃxes of rules in G, we need another version of TS that stores the rightmost paths. This

leads to our ﬁrst result (choosing δ = o(1)).

Lemma 1. Let a sequence T [1..u] be represented by a context free grammar with n symbols, size N , and
height h. Then, for any 0 <  ≤ 1, there exists a data structure using at most N lg n + N lg(u/N ) + (2 +
)n lg n + o(N lg n) bits of space that extracts any substring of length (cid:96) from T in time O((cid:96) + h lg(N/h)), and
a preﬁx or suﬃx of length (cid:96) of the expansion of any nonterminal in time O((cid:96)/).

5 Locating Patterns

A secondary occurrence of P inside a leaf of TG labeled by a symbol Xi occurs as well in the internal node of
TG where Xi is deﬁned. If that occurrence is also secondary, then it occurs inside a child Xj of Xi, and we
can repeat the argument with Xj until ﬁnding a primary occurrence inside some Xk. This shows that all the
secondary occurrences can be found by ﬁrst spotting the primary occurrences, and then ﬁnding all the copies
of the nonterminal Xk that contain the primary occurrences, as well as all the copies of the nonterminals
that contain Xk, recursively.

The strategy [19] to ﬁnd the primary occurrences of P = p1p2 . . . pm is to consider the m − 1 partitions
P = P1 · P2, P1 = p1 . . . pi and P2 = pi+1 . . . pm, for 1 ≤ i < m. For each partition we will ﬁnd all
the nonterminals Xk → Xk1 Xk2 . . . Xkr such that P1 is a suﬃx of some F(Xki) and P2 is a preﬁx of
F(Xki+1 ) . . .F(Xkr ). This ﬁnds each primary occurrence exactly once. The secondary occurrences are then
tracked in the grammar tree TG.6

5.1 Finding Primary Occurrences
As anticipated at the end of Section 3, we store a binary relation R ⊆ A× B to ﬁnd the primary occurrences.
It has n rows labeled Xi, for all Xi ∈ X = B, and N−n columns. Each column, denoted (cid:104)i, j +1(cid:105), corresponds
6 If m = 1 we can just ﬁnd all the occurrences of Xp1 in TG and track its secondary occurrences.

7

X1X3X5X6X7X4X8X9X2level-ancestor(v,depth(v)−1)vto a distinct proper suﬃx αi[j + 1..] of a right-hand side αi. The labels belong to [1..N + 1]. The relation
contains one pair per column: (αi[j],(cid:104)i, j + 1(cid:105)) ∈ R for all 1 ≤ i ≤ n and 1 ≤ j < |αi|. Its label is the
preorder of the (j + 1)th child of the node v ∈ TG where Xi is deﬁned. The space for the binary relation is
(N − n)(lg n + lg N ) + O(N ) bits.
Recall that, in our preprocessing, we have sorted X according to the lexicographic order of F(Xi)rev. We
also sort all the pairs (cid:104)i, j+1(cid:105) lexicographically according to the suﬃxes F(αi[j+1])F(αi[j+2]) . . .F(αi[|αi|]).
This can be done in O(u+N lg N ) time in a way similar to how X was sorted: Each pair (cid:104)i, j+1(cid:105), labeled p, can
be associated to the substring T [select1(L, rankleaf (node(p)) + 1) . . . select1(L, rankleaf (v) + numleaves(v) +
1)−1], where v is the parent of node(p). Then we can proceed as in previous work [13, 14]. Figure 3 illustrates
how R is used, for the grammar presented in Figure 1.
Given P1 and P2, we ﬁrst ﬁnd the range of rows whose expansions ﬁnish with P1, by binary searching for
P rev
in the expansions F(Xi)rev. Each comparison in the binary search needs to extract |P1| terminals from
the suﬃx of F(Xi). According to Lemma 1, this takes O(|P1|/) time. Similarly, we binary search for the
range of columns whose expansions start with P2. Each comparison needs to extract (cid:96) = |P2| terminals from
the preﬁx of F(αi[j + 1])F(αi[j + 2]) . . .. Let r be the column we wish to compare to P2. We extract the label
p associated to the column in constant time (recall Section 2.2). Then we extract the ﬁrst (cid:96) symbols from the
expansion of node(p) ∈ TG. If node(p) does not have enough symbols, we continue with nextsibling(p), and
so on, until we extract (cid:96) symbols or we exhaust the suﬃx of the rule. According to Lemma 1, this requires
time O(|P2|/). Thus our two binary searches require time O((m/) lg N ).
This time can be further improved by using the same technique as in previous work [14]. The idea is to
sample phrases at regular intervals and store the sampled phrases in a Patricia tree [26]. We ﬁrst search for the
pattern in the Patricia tree, and then complete the process with a binary search between two sampled phrases
(we ﬁrst verify the correctness of the Patricia search by checking that our pattern is actually within the range

1

found). By sampling every lg u lg lg n/ lg n phrases, the resulting time for searching becomes O

m lg

(cid:16)

(cid:17)(cid:17)

(cid:16) lg u

lg n

and we only require o(N lg n) bits of extra space, as the Patricia tree needs O(lg u) bits per node.

Once we have identiﬁed a range of rows [a1, a2] and a range of columns [b1, b2], we retrieve all the points
in the rectangle and their labels, each in time O(lg n), according to Section 2.2. The parents of all the nodes
node(p) ∈ TG, for each point p in the range, correspond to the primary occurrences. In Section 5.2 we show
how to report primary and secondary occurrences starting directly from those node(p) positions.
Recall that we have to carry out this search for m − 1 partitions of P , whereas each primary occurrence
is found exactly once. Calling occ the number of primary occurrences, the total cost of this part of the search
is O

(cid:16) lg u

(m2/) lg

(cid:16)

+ occ lg n

.

(cid:17)

(cid:17)

lg n

Fig. 3. Relation R for the grammar presented in Figure 1. The highlighted ranges correspond to the result of searching
for b · ar, where the single primary occurrence corresponds to X2.

8

X1X2X3X4X5X6X7X8X9X1X6X9X5X1X6X9X5X1X9X5X1X1X5X1X6X1X3X1X3X3X7X8X2X4X2X9X4X2X4X2X8X2X95.2 Tracking Occurrences Through the Grammar Tree

The remaining problem is how to track all the secondary occurrences triggered by a primary occurrence, and
how to report the positions where these occur in T . Given a primary occurrence for partition P = P1 · P2
located at u = node(p) ∈ TG, we obtain the starting position of P in T by moving towards the root while
keeping count of the oﬀset between the beginning of the current node and the occurrence of P . Initially, for
node u itself, this is l = −|P1|. Now, as long as u is not the root, we set l ← l + select1(L, rankleaves(u) + 1)−
select1(L, rankleaves(parent(u)) + 1) and then u ← parent(u). When we arrive at the root, the occurrence
of P starts at l.
It seems like we are doing this h times in the worst case, since we need to track the occurrence up to
the root. In fact we might do so for some symbols, but the total cost is amortized. Evey time we move
from u to v = parent(u), we know that X[v] appears at least once more in the tree. This is because of our
preprocessing (Section 3), where we force rules to appear at least twice or be removed. Thus v deﬁnes X[v],
but there are one or more leaves labeled X[v], and we have to report the occurrences of P inside them all.
For this sake we carry out selectX[v](X, i) for i = 1, 2 . . . until spotting all those occurrences (where P occurs
with the current oﬀset l). We recursively track them to the root of TG to ﬁnd their absolute position in T ,
and recursively ﬁnd the other occurrences of all their ancestor nodes. The overall cost amortizes to O(1)
steps per occurrence reported, as we can charge the cost of moving from u to v to the other occurrence of
v. If we report occ secondary occurrences we carry out O(occ) steps, each costing O(lg lg n) time. We can
thus use δ = O(1/ lg lg n) (Section 4.1) so that the cost to access X[v] does not impact the space nor time
complexity.

By adding up the space of Lemma 1 with that of the labeled binary relation, and adding up the costs,

we have our central result, Theorem 1.

6 Conclusions

We presented the ﬁrst grammar-based text index whose locate time does not depend on the height of the
grammar. There are previous results on generating balanced grammars to compress text, as for example the
ones proposed by Rytter [33] and Sakamoto [34]. These representations allow previous indexing techniques
to guarantee sublinear locating times, yet these techniques introduce a penalty in the size of the grammar.
Our index also extends the grammar-based indexing techniques to a more general class of grammars than
SLPs, the only class explored so far in this scenario.

We note that in our index each primary occurrence is reported in O(lg n) time, whereas each secondary
ones requires just O(lg lg n) time. The complexity of primary occurrences is dominated by the time to report
points in a range using our binary relation representation. We believe this can be lowered up to O(lg lg n),
in exchange for using more space. For example, Bose et al. [7] represent an n × n grid with n points within
n lg n+o(n lg n) bits, so that each point in a range can be reported in time O(lg n/ lg lg n); using O((1/)n lg n)
bits the time can be reduced to O(lg n) for any constant 0 <  ≤ 1 [10, 29, 8]; and using O(n lg n lg lg n) bits
one can achieve time O(lg lg n) [1, 8] (all these solutions have a small additive time that is not relevant for
our application). It seems likely that these structures can be extended to represent our n × N grid with N
points (i.e., our string SB). In the case of Bose et al. this could even be asymptotically free in terms of space.
Alternatively, instead of speeding up the reporting of primary occurrences, we can slow down that of
secondary occurrences so that they match, and in exchange reduce the space. For example, one of our largest
terms in the index space owes to the need of storing the phrase lengths in TG. By storing just the n internal
node lengths and one out of lg n lengths at the leaves of TG, we reduce N lg(u/N ) bits of space in our index
to (n + (N − n)/ lg n) lg(u/(n + (N − n)/ lg n)) ≤ (n + N/ lg n) lg(u/N ) + o(N lg n). Note this penalizes the
extraction time by an O(lg n) factor in the worst case.
Several questions remain open, for example: Is it possible to lower the dependence on m to linear, as
achieved in some LZ78-based schemes [32]? Is it possible to reduce the space to N lg n + o(N lg n), that is,
asymptotically the same as the compressed text, as achieved on statistical-compression-based self-indexes
[28]? Is it possible to remove h from the extraction complexity within less space than the current solutions
[6]?

9

References

1. S. Alstrup, G. Brodal, and T. Rauhe. New data structures for orthogonal range searching. In Proc. 41st Annual

Symposium on Foundations of Computer Science (FOCS), pages 198–207, 2000.

2. A. Amir and G. Benson. Eﬃcient two-dimensional compressed matching.

In Proc. 2nd Data Compression

Conference (DCC), pages 279–288, 1992.

3. D. Arroyuelo, G. Navarro, and K. Sadakane. Reducing the space requirement of LZ-index. In Proc. 17th Annual

Symposium on Combinatorial Pattern Matching (CPM), LNCS 4009, pages 319–330, 2006.

4. J. Barbay, T. Gagie, G. Navarro, and Y. Nekrich. Alphabet partitioning for compressed rank/select and applications.
 In Proc. 21st Annual International Symposium on Algorithms and Computation (ISAAC), LNCS 6507,
pages 315–326, 2010. Part II.

5. D. Benoit, E. Demaine, I. Munro, R. Raman, V. Raman, and S. Srinivasa Rao. Representing trees of higher

degree. Algorithmica, 43(4):275–292, 2005.

6. Philip Bille, Gad M. Landau, Rajeev Raman, Kunihiko Sadakane, Srinivasa Rao Satti, and Oren Weimann.
In Proc. 22nd Annual ACM-SIAM Symposium on Discrete

Random access to grammar-compressed strings.
Algorithms (SODA’11), pages 373–389, 2011.

7. P. Bose, M. He, A. Maheshwari, and P. Morin. Succinct orthogonal range search structures on a grid with
applications to text indexing. In Proc. 11th Algorithms and Data Structures Symposium (WADS), LNCS 5664,
pages 98–109, 2009.

8. T. Chan, K. Larsen, and M. Patrascu. Orthogonal range searching on the RAM, revisited. CoRR, abs/1103.5510,

2011.

9. M. Charikar, E. Lehman, D. Liu, R. Panigrahy, M. Prabhakaran, A. Sahai, and A. Shelat. The smallest grammar

problem. IEEE Transactions on Information Theory, 51(7):2554–2576, 2005.

10. B. Chazelle. Functional approach to data structures and its use in multidimensional searching. SIAM Journal

on Computing, 17(3):427–462, 1988.

11. F. Claude, A. Fari˜na, M. Mart´ınez-Prieto, and G. Navarro. Compressed q-gram indexing for highly repetitive

biological sequences. In Proc. 10th IEEE Conference on Bioinformatics and Bioengineering (BIBE), 2010.

12. F. Claude, A. Fari˜na, M. Mart´ınez-Prieto, and G. Navarro. Indexes for highly repetitive document collections.
In Proc. 20th ACM International Conference on Information and Knowledge Management (CIKM), 2011. To
appear.

13. F. Claude and G. Navarro. Self-indexed text compression using straight-line programs. In Proc. 34th International
Symposium on Mathematical Foundations of Computer Science (MFCS), LNCS 5734, pages 235–246. Springer,
2009.

14. F. Claude and G. Navarro. Self-indexed grammar-based compression. Fundamenta Informaticae, 2011. To appear.

www.dcc.uchile.cl/gnavarro/ps/fi10.pdf.

15. P. Ferragina and G. Manzini. Indexing compressed texts. Journal of the ACM, 52(4):552–581, 2005.
16. L. Gasieniec, R. Kolpakov, I. Potapov, and P. Sant. Real-time traversal in grammar-based compressed ﬁles. In

Proc. 15th Data Compression Conference (DCC), pages 458–458, 2005.

17. A. Golynski, R. Raman, and S. Rao. On the redundancy of succinct data structures. In Proc. 11th Scandinavian

Workshop on Algorithm Theory (SWAT), LNCS 5124, pages 148–159, 2008.

18. R. Grossi, A. Gupta, and J. Vitter. High-order entropy-compressed text indexes. In Proc. 14th Annual ACMSIAM 
Symposium on Discrete Algorithms (SODA), pages 841–850, 2003.

19. J. K¨arkk¨ainen. Repetition-Based Text Indexing. PhD thesis, Department of Computer Science, University of

Helsinki, Finland, 1999.

20. T. Kida, T. Matsumoto, Y. Shibata, M. Takeda, A. Shinohara, and S. Arikawa. Collage system: a unifying

framework for compressed pattern matching. Theoretical Computer Science, 298(1):253–272, 2003.

21. J. Kieﬀer and E.-H. Yang. Grammar-based codes: A new class of universal lossless source codes. IEEE Transactions 
on Information Theory, 46(3):737–754, 2000.

22. S. Kreft and G. Navarro. Self-indexing based on LZ77.
Pattern Matching (CPM), LNCS 6661, pages 41–54, 2011.

In Proc. 22th Annual Symposium on Combinatorial

23. S. Kuruppu, B. Beresford-Smith, T. Conway, and J. Zobel. Repetition-based compression of large DNA datasets.
In Proc. 13th Annual International Conference on Computational Molecular Biology (RECOMB), 2009. Poster.
24. J. Larsson and A. Moﬀat. Oﬀ-line dictionary-based compression. Proceedings of the IEEE, 88(11):1722–1732,

2000.

25. V. M¨akinen, G. Navarro, J. Sir´en, and N. V¨alim¨aki. Storage and retrieval of individual genomes. In Proc. 13th
Annual International Conference on Computational Molecular Biology (RECOMB), LNCS 5541, pages 121–137,
2009.

10

26. D. Morrison. PATRICIA – practical algorithm to retrieve information coded in alphanumeric. Journal of the

ACM, 15(4):514–534, 1968.

27. J. Munro, R. Raman, V. Raman, and S. Srinivasa Rao. Succinct representations of permutations. In Proc. 30th
International Colloquium on Automata, Languages, and Programming (ICALP), LNCS 2719, pages 345–356,
2003.

28. G. Navarro and V. M¨akinen. Compressed full-text indexes. ACM Computing Surveys, 39(1):article 2, 2007.
29. Y. Nekrich. Orthogonal range searching in linear and almost-linear space. Computational Geometry: Theory and

Applications, 42(4):342–351, 2009.

30. C. Nevill-Manning, I. Witten, and D. Maulsby. Compression by induction of hierarchical grammars. In Proc. 4th

Data Compression Conference (DCC), pages 244–253, 1994.

31. R. Raman, V. Raman, and S. Rao. Succinct indexable dictionaries with applications to encoding k-ary trees and
multisets. In Proc. 13th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 233–242, 2002.
Information Retrieval,

32. L. Russo and A. Oliveira. A compressed self-index using a Ziv-Lempel dictionary.

11(4):359–388, 2008.

33. W. Rytter. Application of Lempel-Ziv factorization to the approximation of grammar-based compression. Theoretical 
Computer Science, 302(1-3):211–222, 2003.

34. H. Sakamoto. A fully linear-time approximation algorithm for grammar-based compression. Journal of Discrete

Algorithms, 3:416–430, 2005.

35. J. Ziv and A. Lempel. A universal algorithm for sequential data compression. IEEE Transactions on Information

Theory, 23(3):337–343, 1977.

36. J. Ziv and A. Lempel. Compression of individual sequences via variable length coding. IEEE Transactions on

Information Theory, 24(5):530–536, 1978.

11

