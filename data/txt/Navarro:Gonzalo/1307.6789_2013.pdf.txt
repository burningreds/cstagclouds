3
1
0
2

 
l
u
J
 

1
3

 
 
]
S
D
.
s
c
[
 
 

2
v
9
8
7
6

.

7
0
3
1
:
v
i
X
r
a

Optimal Top-k Document Retrieval∗

Gonzalo Navarro

Yakov Nekrich

Department of Computer Science

Department of Computer Science

University of Chile, Chile
gnavarro@dcc.uchile.cl

University of Kansas, USA

yakov.nekrich@googlemail.com

Abstract

Let D be a collection of D documents, which are strings over an alphabet of size σ, of
total length n. We describe a data structure that uses linear space and and reports k most
relevant documents that contain a query pattern P , which is a string of length p, in time
O(p/ logσ n + k), which is optimal in the RAM model in the general case where lg D = Θ(log n),
and involves a novel RAM-optimal suﬃx tree search. Our construction supports an ample
set of important relevance measures, such as the number of times P appears in a document
(called term frequency), a ﬁxed document importance, and the minimal distance between two
occurrences of P in a document.

When lg D = o(log n), we show how to reduce the space of the data structure from O(n log n)
to O(n(log σ + log D + log log n)) bits, and to O(n(log σ + log D)) bits in the case of the popular
term frequency measure of relevance, at the price of an additive term O(logε n log σ) in the
query time, for any constant ε > 0.

We also consider the dynamic scenario, where documents can be inserted and deleted from
the collection. We obtain linear space and query time O(p(log log n)2/ logσ n+log n+k log log k),
whereas insertions and deletions require O(log1+ε n) time per symbol, for any constant ε > 0.
Finally, we consider an extended static scenario where an extra parameter par(P, d) is deﬁned,
 and the query must retrieve only documents d such that par(P, d) ∈ [τ1, τ2], where this
range is speciﬁed at query time. We solve these queries using linear space and O(p/ logσ n +
log1+ε n + k logε n) time, for any constant ε > 0.

Our technique is to translate these top-k problems into multidimensional geometric search

problems. As an additional bonus, we describe some improvements to those problems.

1

Introduction

The design of eﬃcient data structures for document (i.e., string) collections that can report those
containing a query pattern P is an important problem studied in the information retrieval and
pattern matching communities (see, e.g., a recent survey [46]). Due to the steadily increasing
volumes of data, it is often necessary to generate a list L(P ) of the documents containing a string
pattern P in decreasing order of relevance. Since the list L(P ) can be very large, in most cases we
are interested in answering top-k queries, that is, reporting only the ﬁrst k documents from L(P )
for a parameter k given at query time.

∗Partially funded by Fondecyt Grant 1-110066, Chile, and by Millennium Nucleus Information and Coordination
in Networks ICM/FIC P10-024F, Chile. An early partial version of this article appeared in Proc. SODA 2012 [47].

1

Inverted ﬁles [12, 39, 6] that store lists of documents containing certain keywords are frequently
used in practical implementations of information retrieval methods. However, inverted ﬁles only
work when query patterns belong to a ﬁxed pre-deﬁned set of strings (keywords). The suﬃx
tree [64], a handbook data structure known since 1973, uses linear space (i.e., O(n) words, where
n is the total length of all the documents) and ﬁnds all the occ occurrences of a pattern P in
O(p + occ) time, where p = |P|. Surprisingly, the general document listing problem, that is,
the problem of reporting all the documents that contain an arbitrary query pattern P , was not
studied until the end of the 90s. Suﬃx trees and other data structures for standard pattern
matching queries do not provide a satisfactory solution for the document listing problem because
the same document may contain many occurrences of P . Matias et al. [42] described the ﬁrst data
structure for document listing queries; their structure uses O(n) words of space and reports all docc
documents that contain P in O(p log D + docc) time, where D is the total number of documents
in the collection. Muthukrishnan [45] presented a data structure that uses O(n) words of space
and answers document listing queries in O(p + docc) time. Muthukrishnan [45] also initiated the
study of more sophisticated problems in which only documents that contain P and satisfy some
further criteria are reported. In the K-mining problem, we must report documents in which P
occurs at least K times; in the K-repeats problem, we must report documents in which at least
two occurrences of P are within a distance K. He described O(n)- and an O(n log n)-word data
structures that answer K-mine and K-repeats queries, respectively, both in O(p + occ) time, where
occ is the number of reported documents.

A problem not addressed by Muthukrishnan, and arguably the most important one for information 
retrieval, is the top-k document retrieval problem: report k most highly ranked documents
for a query pattern P in decreasing order of their ranks. The ranking is measured with respect to
the so-called relevance of a string P for a document d. A basic relevance measure is tf (P, d), the
number of times P occurs in d. Two other important examples are mindist(P, d), the minimum
distance between two occurrences of P in d, and docrank (d), an arbitrary static rank assigned to a
document d. Some more complex measures have also been proposed. Hon et al. [33] presented a solution 
for the top-k document retrieval problem for the case when the relevance measure is tf (P, d).
Their data structure uses O(n log n) words of space and answers queries in O(p + k + log n log log n)
time. Later, Hon, Shah and Vitter [37] presented a general solution for a wide class of relevance
measures. Their data structure uses linear space and needs O(p + k log k) time to answer a top-k
query. A recent O(n) space data structure [38] enables us to answer top-k queries in O(p + k) time
when the relevance measure is docrank (d). However, that result cannot be extended to other more
important relevance measures.

Our Results. Hon et al.’s results [37] are an important achievement, but their time is not yet
optimal.
In this paper we describe a linear space data structure that answers top-k document
queries in O(p/ logσ n + k) time, where σ is the alphabet size of the collection. This is optimal in
the Θ(log n)-word RAM model we use, unless the collection has very few documents, lg D = o(log n)
(i.e., D = o(nε) for any constant ε > 0). We support the same relevance measures as Hon et al. [37].

Theorem 1 Let D be a collection of strings (called documents) of total length n over an integer
alphabet [1, σ], and let w(S, d) be a function that assigns a numeric weight to string S in document
d, so that w(S, d) depends only on the set of starting positions of occurrences of S in d. Then
there exists an O(n)-word space data structure that, given a string P of length p and an integer k,

2

reports k documents d containing P with highest w(P, d) values, in decreasing order of w(P, d), in
O(p/ logσ n + k) time. The time is online on k.

Note that the weighting function is general enough to encompass measures tf (P, d), mindist (P, d)
and docrank (d). As stated, our solution is online on k: It is not necessary to specify k beforehand;
our data structure can simply report documents in decreasing relevance order until all the documents 
are reported or the query processing is terminated by a user.

An online top-k solution using the tf measure solves the K-mining problem in optimal time
and linear space. An online top-k solution using mindist measure solves the K-repeats problem
in optimal time and linear space. We remind that Muthukrishnan [45] had solved the K-repeats
problem using O(n log n)-word space; later Hon et al. [37] reduced the space to linear. Now all
these results appear as a natural corollary of our optimal top-k retrieval solution. Our results also
subsume those on more recent variants of the problem [38], for example when the rank docrank (d)
depends only on d (we just use w(P, d) = docrank (d)), or where in addition we exclude those d
where P appears less than K times for a ﬁxed pre-deﬁned K (we just use w(P, d) = docrank (d) if
tf (P, d) ≥ K, else 0).
Moreover, we can also answer queries for some relevance metrics not included in Theorem 1.
For instance, we might be interested in reporting all the documents d with tf (P, d) × idf (P ) ≥ τ ,
where idf (P ) = log(N/df (P )) and df (P ) is the number of documents where P appears [6]. Using
the O(n)-bit structure of Sadakane [56], we can compute idf (P ) in O(1) time from the suﬃx tree
locus of P . To answer the query, we use our data structure of Theorem 1 in online mode on
measure tf : For every reported document d we ﬁnd tf (P, d) and compute tf (P, d) × idf (P ); the
procedure is terminated when a document dl with tf (P, dl) × idf (P ) < τ is encountered. Thus we
need O(p/ logσ n + occ) time to report all occ documents with tf × idf scores above a threshold.
When lg D = o(log n), it is not clear that our time is RAM-optimal. Instead, we show that
in this case the space of our data structures can be reduced from O(n log n) bits to O(n(log σ +
log D + log log n)). This is o(n log n) bits unless lg σ = Θ(log n) (in which case the linear-space
data structure is already asymptotically optimal). For the most important tf relevance measure,
where we report documents in which P occurs most frequently, we obtain a data structure that uses
O(n(log σ+log D)) bits of space. The price of the space reduction is an additive term O(logε n log σ)
in the query time, for any constant ε > 0.

We also consider the dynamic framework, where collection D admits insertions of new documents
and deletions of existing documents. Those updates are supported in slightly superlogarithmic time
per character, whereas the query times are only slightly slowed down. We note that measure Cw is
just O(1) for the typical relevance measures tf and docrank , and O(log n) for mindist.

Theorem 2 Let D be a collection of documents of total length n over an integer alphabet [1, σ],
and let w(S, d) be a function that assigns a numeric weight to string S in document d, so that
w(S, d) depends only on the set of starting positions of occurrences of S in d, and can be computed
in O(Cw|d|) time for all the nodes of the suﬃx tree of document d. Then there exists an O(n)-
word space data structure that, given a string P of length p and an integer k, reports k documents d
containing P with highest w(P, d) values, in decreasing order of w(P, d), in O(p(log log n)2/ logσ n+
log n + k log log k) time, online in k. The structure can insert new documents and delete existing
documents in O(Cw + log1+ε n) time per inserted character and O(log1+ε n) per deleted character,
for any constant ε > 0.

3

We note that a direct dynamic implementation of the solution of Hon et al. [37] would require
at least performing p + k dynamic RMQs, which cost Ω(log n/ log log n) time [2]. Thus modeling
the original problem as a geometric one pays oﬀ in the dynamic scenario as well.

Furthermore, we can extend the top-k ranked retrieval problem by allowing a further parameter 
par(P, d) to be associated to any pattern P and document d, so that only documents with
par(P, d) ∈ [τ1, τ2] are considered. Some applications are selecting a range of creation dates, lengths,
or PageRank values for the documents (these do not depend on P ), bounding the allowed number
of occurrences of P in d, or the minimum distance between two occurrences of P in d, etc.

Theorem 3 Let D be a collection of documents of total length n over an integer alphabet [1, σ], let
w(S, d) be a function that assigns a numeric weight to string S in document d, and let par(S, d) be
another parameter, so that w and par depend only on the set of starting positions of occurrences
of S in d. Then there exists an O(n)-word space data structure that, given a string P of length p,
an integer k, and a range [τ1, τ2], reports k documents d containing P and with par(P, d) ∈ [τ1, τ2],
with highest w(P, d) values, in decreasing order of w(P, d), in O(p/ logσ n+log1+ε n+k logε n) time,
online in k, for any constant ε > 0.

Our solutions map these document retrieval problems into range search problems on multidimensional 
spaces, where points in the grids have associated weights. We improve some of the
existing solutions for those problems.

An early partial version of this article appeared in Proc. SODA 2012 [47]. This extended
version includes, apart from more precise explanations and ﬁxes, the improvement of the static
results to achieve RAM-optimality on the suﬃx tree traversal, and the new results on the dynamic
scenario. The paper is organized as follows. In Section 2 we review the top-k framework of Hon et
al. [37] and reinterpret it as the combination of a suﬃx tree search plus a geometric search problem.
We introduce a RAM-optimal suﬃx tree traversal technique that is of independent interest, and
state our results on geometric grids, each of which is related to the results we achieve on document
retrieval. Those can also be of independent interest. Sections 3 and 4 describe our basic static
solution. Section 5 describes our dynamic solution. In Section 6 we show how the static solution
can be modiﬁed to reduce its space requirements, and in Section 7 we show how it can be extended
to support an additional restriction on the documents sought. Finally, Section 8 concludes and
gives future work directions.

2 Top-k Framework

In this section we overview the framework of Hon, Shah, and Vitter [37]. Then, we describe a
geometric interpretation of their structure and show how top-k queries can be reduced to a special
case of range reporting queries on a grid.

Let T be the generalized suﬃx tree [64, 43, 62] for a collection of documents d1, . . . , dD, each
ending with the special terminator symbol “$”. T is a compact trie, such that all suﬃxes of all
documents are stored in the leaves of T . We denote by path(v) the string obtained by concatenating
the labels of all the edges on the path from the root to v. The locus of a string P is the highest
node v such that P is a preﬁx of path(v). Every occurrence of P corresponds to a unique leaf
that descends from its locus. We refer the reader to classical books and surveys [5, 32, 18] for an
extensive description of this data structure.

4

We say that a leaf l is marked with document d if the suﬃx stored in l belongs to d. An internal
node v is marked with d if at least two children of v contain leaves marked with d. While a leaf is
marked with only one value d (equal suﬃxes of distinct documents are distinguished by ordering
the string terminators arbitrarily), an internal node can be marked with many values d.

In every node v of T marked with d, we store a pointer ptr(v, d) to its lowest ancestor u such
that u is also marked with d. If no ancestor u of v is marked with d, then ptr(v, d) points to a
dummy node ν such that ν is the parent of the root of T . We also assign a weight to every pointer
ptr(v, d). This weight is the relevance score of the document d with respect to the string path(v).
The following statements hold; we reprove them for completeness.

Lemma 1 ([37], Lemma 4) The total number of pointers ptr(·,·) in T is bounded by O(n).
Proof : The total number of pointers ptr(v, d), v ∈ T , does not exceed the number of nodes marked
with d. The total number of internal nodes marked with d is smaller than the number of leaves
marked with d. Since there are O(|d|) leaves marked with d, the total number of pointers ptr(v, d)
for a ﬁxed document d is bounded by O(|d|), and those |d| add up to n.
Lemma 2 ([37], Lemma 2) Assume that document d contains a pattern P and v is the locus of
P . Then there exists a unique pointer ptr(u, d), such that u is in the subtree of v (which includes
v) and ptr(u, d) points to an ancestor of v.

(cid:3)

Proof : If d contains P then there is at least one leaf u marked d below the locus of P , with a
pointer ptr(u, d). If there are two maximal (in the sense of ancestorship) nodes u and u′ below v
with pointers ptr(u, d) and ptr(u′, d), then their lowest common ancestor v′ is also marked. Since v
is an ancestor of u and u′, v is v′ or an ancestor of v′ and then ptr(u, d) and ptr(u′, d) must point
to v′, not to an ancestor of v. Finally, if u is a unique maximal node with ptr(u, d) (not u might
be v), then it must point an ancestor of v.
(cid:3)

Moreover, in terms of Lemma 2, it turns out that path(u) occurs in d at the same positions as
path(v). Note that the starting positions of P and of path(v) in d are the same, since v is the locus
of P , and those are the same as the starting positions of path(u) in d. Thus w(P, d) = w(path(u), d)
for any measure w(·,·) considered in Theorem 1.

RAM-optimal suﬃx tree traversal. To achieve time O(p) for the locus search in the suﬃx
tree while retaining linear space, one needs to organize the children of each node in a perfect hash
function (phf) [27]. In order to reduce this time to the RAM-optimal O(p/ logσ n), we proceed as
follows. Let l(u, v) be the concatenation of string labels from node u to its descendant v. We collect
in a phf H(u), for the suﬃx tree root u, all the highest descendants v such that |l(u, v)| ≥ ℓ = logσ n.
Those nodes v are indexed with a key built from the ﬁrst ℓ symbols of l(u, v) interpreted as a number
of lg n bits. We build recursively phfs for all the descendants u identiﬁed. Since each suﬃx tree node
is included in at most one hash table, the total size is O(n) and the total deterministic construction
time is O(n log log n) [55]. Now P is searched for as follows. We take its ﬁrst chunk of ℓ characters,
interpret it as a number, and query the phf of the root. If no node u is found for that preﬁx of P ,
then P is not in the collection. Otherwise, the string depth of u is ≥ ℓ. We check explicitly the extra
|l(u, v)|− ℓ symbols in the text, by comparing chunks of ℓ symbols. If there is a match, we continue
with the next ℓ unread symbols of P , and so on, until there are less than ℓ symbols to match in the

5

remaining suﬃx P ′ of P . At this point we switch to using a weak preﬁx search (wps) data structure
[7]: For each node u holding a phf, we also store this wps data structure with all the nodes v that
descend from u where |l(u, v)| < ℓ. The wps data structure will return the lexicographic range of
the nodes of which P ′ is a preﬁx (here we identify nodes v with the strings l(u, v)). The ﬁrst in
that range is the locus of P . One detail is that, if there is no such node (i.e., P has no locus), the
wps structure returns an arbitrary value, but this can be easily checked in optimal time in the text.
The wps structure requires, for our length |P ′| < ℓ and in the RAM model, O(1) query time, and
can use, for the strings we store, of length < ℓ, O(√log n log log n) bits, or o(1) words, per stored
node [7, Thm. 6]. Once again, each node is stored only in one wps structure, so the overall extra
space is linear at worst. The wps construction is O(n logε n) randomized time. It can be made
deterministic O(n polylog(n)) time by using a phf inside the construction [1]. By replacing the wps
structure by layered phfs for (lgσ n)/2i symbols, we would have an additive term O(log logσ n) in
the query time.

Geometric interpretation. We index the nodes of T in the following way: All nodes of T are
visited in pre-order; we also initialize an index i ← 0. When a node v is visited, if v is marked
with values dv1 , . . . , dvj , we assign indexes i + 1, . . . , i + j to v and set i ← i + j. We will denote
by [lv, rv] the integer interval bounded by the minimal and maximal indexes assigned to v or its
descendants. Values lv and rv are stored in node v of T . Furthermore, for every dvt, 1 ≤ t ≤ j,
there is a pointer ptr(v, dvt ) that points to some ancestor ut of v. We encode ptr(v, dvt ) as a point
(i + t, depth(ut)), where depth denotes the depth of a node; depth(ν) = 0. Thus every pointer in
T is encoded as a two-dimensional point on an integer O(n) × O(n) grid. The weight of a point p
is that of the pointer p encodes. We observe that all the points have diﬀerent x-coordinates. Thus
we obtain a set S of weighted points with diﬀerent x-coordinates, and each point corresponds to a
unique pointer.

For the ﬁnal answers we will need to convert the x-coordinates of points found on this grid into

document numbers. We store a global array of size O(n) to do this mapping.

Answering queries. Assume that top-k documents containing a pattern P must be reported.
We ﬁnd the locus v of P in O(p/ logσ n) time. By Lemma 2, there is a unique pointer ptr(u, d),
such that u is a descendant of v (or v itself) and ptr(u, d) points to an ancestor of v, for every
document d that contains P . Moreover the weight of that point is w(P, d). Hence, there is a
unique point (x, y) with x ∈ [lv, rv] and y ∈ [0, depth(v) − 1] for every document d that contains P .
Therefore, reporting top-k documents is equivalent to the following query: among all the points in
the three-sided range [lv, rv]× [0, depth(v)), report k points with highest weights. We will call such
queries three-sided top-k queries. In Sections 3 and 4 we prove the following result. Theorem 1 is
an immediate corollary of it, as h = depth(v) − 1 and depth(v) ≤ p, and we can choose c ≥ 1.
Theorem 4 A set of n weighted points on an n × n grid can be stored in O(n) words of space
and built in O(n log n) time, so that for any 1 ≤ k, h ≤ n and 1 ≤ a ≤ b ≤ n, k most highly
weighted points in the range [a, b] × [0, h] can be reported in decreasing order of their weights in
O(h/ logc n + k) time, for any constant c.

Top-k queries on dynamic collections. The static suﬃx tree is replaced by a dynamic one,
with search time O(p(log log n)2/ logσ n + log n) and update time O(log n) per symbol. We must

6

also update the grid, for which we must carry out lowest common ancestor queries on the dynamic
suﬃx tree and also insert/delete points (and columns) in the grid. We split the grid of Theorem 4
into horizontal stripes of height m = polylog n to obtain improved performance, and query the
highest ⌈p/m⌉ of those grids. In the most general case (i.e., the last grid) we carry out a three-sided
top-k query. We address this in Section 5, where in particular we prove the following result on
dynamic grids. Theorem 2 is then obtained by combining those results.

Theorem 5 A set of n points, one per column on an n × n grid, with weights in [1, O(n)], can
be stored in O(n) words of space, so that for any 1 ≤ k ≤ n, 1 ≤ h ≤ n and 1 ≤ a ≤ b ≤ n, k
most highly weighted points in the range [a, b] × [0, h] can be reported in decreasing order of their
weights in O(h/ logc n + log n + k log log k) time, online in k, for any constant c. Points (and their
columns) can be inserted and deleted in O(log1+ε n) time, for any constant ε > 0.

Parameterized top-k queries. We use the same geometric interpretation as described above,
but now each pointer ptr(v, d) is also associated with the parameter value par(path(v), d). We
encode a pointer ptr(v, dvt ) as a three-dimensional point (i + t, depth(ut), par(path(v), dvt )), where
i, t, and ut are deﬁned as in the case of nonparameterized top-k queries. All the documents that
contain a pattern P (with locus v) and satisfy τ1 ≤ par(P, d) ≤ τ2 correspond to unique points in
the range [lv, rv]× [0, depth(v))× [τ1, τ2]. Hence, reporting top-k documents with par(P, d) ∈ [τ1, τ2]
is equivalent to reporting top-k points in a three-dimensional range. The following result is proved
in Section 7, and Theorem 3 is an immediate corollary of it, choosing any c ≥ 1.
Theorem 6 A set of n weighted points on an n× n× n grid can be stored in O(n) words of space,
so that for any 1 ≤ k, h ≤ n, 1 ≤ a ≤ b ≤ n, and 1 ≤ τ1 ≤ τ2 ≤ n, k most highly weighted
points in the range [a, b] × [0, h] × [τ1, τ2] can be reported in decreasing order of their weights in
O(h/ logc n + log1+ε n + k logε n) time, for any constants c and ε > 0.

3 An O(mf + k) Time Data Structure

In this section we give a data structure that does not yet achieve the desired O(h/ log n + k) time,
but its time depends on the width m of the grid. This will be used in Section 4 to handle vertical
stripes of the global grid, in order to achieve the ﬁnal result.

We assume that a global array gives access to the points of a set S in constant time:

if we
know the x-coordinate p.x of a point p ∈ S, we can obtain the y-coordinate p.y of p in O(1) time.
Both p.x and p.y are in [1, O(n)], thus the global array requires O(n) words of space. We consider
the question of how much additional space our data structure uses if this global array is available.
The result of this section is summed up in the following lemma, where we consider tall grids of m
columns and n rows.

Lemma 3 Assume that m ≤ n and let 0 < f < 1 be a constant. There exists a data structure
that uses O(m log m) additional bits of space and construction time. It answers three-sided top-k
queries for a set of m points on an m × n grid in O(mf + k) time.
Proof : The idea is to partition the points of S by weights, where the weights are disregarded
inside each partition. Those partitions are also reﬁned into a tree. Then we solve the problem by

7

More precisely, we partition S into classes S1, . . . , Sr, where r = mf ′

traversing the appropriate partitions and collecting all the points using classical range queries on
unweighted points. A tree of arity mΘ(f ) yields constant height and thus constant space per point.
for a constant 0 < f ′ < f .
For any 1 ≤ i < j ≤ r, the weight of any point pi ∈ Si is larger than the weight of any point
pj ∈ Sj. For 1 ≤ i < r, Si contains m1−f ′
points. Each class Si that contains more than one
element is recursively divided into min(|Si|, r) subclasses in the same manner. This subdivision
can be represented as a tree: If Si is divided into subclasses Si1, . . . , Sik , we will say that Si is the
parent of Si1, . . . , Sik . This tree has constant height O(1/f ′).

For every class Sj we store data structures that support three-sided range counting queries
and three-sided range reporting queries, in O(log m) and O(log m + occ) time respectively. These
structures will be described in Section 3.1 and require O(m1−f ′
log m) construction time; note they
do not involve weights. This adds up to O((1/f ′)m log m) construction time.

We will report k most highly weighted points in a three-sided query range Q = [a, b] × [0, h]
using a two-stage procedure. During the ﬁrst stage we produce an unsorted list L of k most highly
weighted points. During the second stage the list L is sorted by weight.

Let Qk denote the set of k most highly weighted points in S ∩ Q. Then Qk can be formed as
the union of the result of the three-sided query over certain classes, at most O(mf ′
) clases per level
over a constant number of levels. More precisely, there are O(mf ′
) classes Sc, such that p ∈ Qk if
and only if p ∈ Sc ∩ Q for some Sc. During the ﬁrst stage, we identify the classes Sc and report
all the points in Sc ∩ Q using the following procedure. Initially, we set our current tree node to
eS = S and its child number to i = 1. We count the number of points inside Q in the i-th child
Si of eS. If ki = |Si ∩ Q| ≤ k, we report all the points from Si ∩ Q and set k = k − ki. If k = 0,
the procedure is completed; otherwise we set i = i + 1 and proceed to the next child Si of eS. If
ki > k, instead, we set eS = Si, i = 1, and report k most highly weighted points in the children
of eS using the same procedure. During the ﬁrst stage we examine O(mf ′
) classes Si and spend
O(mf ′

log m + k) = O(mf + k) time in total.

When the list L is completed, we can sort it in O(mf + k) time. If L contains k < mf ′

points,
L can be sorted in O(k log k) = O(mf ) time. If L contains k ≥ mf ′
points, then we can sort it in
O(k) time using radix sort: As the set S contains at most m distinct weights, we store their ranks
in an array ordered by x-coordinate, and thus can sort the result using the ranks instead of the
original values. By sorting f ′ log2 m bits per pass the radix sort runs in time O(k).

As for the space, the structures in Lemmas 4 and 5 require O(log m) bits per point. Each point
of S belongs to O(1/f ′) classes Si. Hence, the total number of points in all classes is O(m), giving
O(m log m) bits of total space. The local array of weight ranks also uses O(m log m) bits.
(cid:3)

3.1 Counting and Reporting Points

It remains to describe the data structures that answer three-sided counting and reporting queries,
with no weights involved.

Lemma 4 Let v ≤ m ≤ n. There exists a data structure that uses O(v log m) additional bits and
answers three-sided range counting queries for a set of v points on an m × n grid in O(log v) time.
It can be built in O(v log v) time.

Proof : Using the rank space technique [28], we reduce the problem of counting on an m × n
grid to the problem of counting on a v × n grid:
let τ (p.x, p.y) = (rank(p.x, Sx), p.y), where the

8

set Sx consists of the x-coordinates of all the points in S and rank(a, S) = |{ e ∈ S | e ≤ a}|.
Then the mapped set is S′ = {τ (p.x, p.y), (p.x, p.y) ∈ S}. Let pred(a, S) = max{ e ∈ S | e ≤ a}
and succ(a, S) = min{ e ∈ S | e ≥ a}. Then a query [a, b] × [0, h] on S is equivalent to a query
[a′, b′]×[0, h] on S′, where a′ = rank(succ(a, Sx), Sx) and b′ = rank(pred(b, Sx), Sx). Using standard
binary search on an array, we can ﬁnd a′ and b′ in O(log v) time and v log m bits of space.
We store the points on a variant of the wavelet tree data structure [31]. Each node of this tree
W covers all the points within a range of y-coordinates. The root covers all the nodes, and the two
children of each internal node cover half of the points covered by their parent. The leaves cover
one point. The y-coordinate limits of the nodes are not stored explicitly, to save space. Instead,
we store the x-coordinate of the point holding the maximum y-coordinate in the node. With the
global array we can recover the y-coordinate in constant time. Each internal node v covering r
points stores a bitmap Bv[1..r], so that Bv[i] = 0 iﬀ the i-th point, in x-coordinate order, belongs
to the left child (otherwise it belongs to the right child). Those bitmaps are equipped with data
structures answering operation rankb(Bv, i) in constant time and r + o(r) bits of space [44], where
rankb(Bv, i) is the number of occurrences of bit b in Bv[1..i]. Since W has O(v) nodes and height
O(log v), its bitmaps require O(v log v) bits and its pointers and x-coordinates need O(v log m) bits.
The construction time is O(v log v).

We can easily answer range counting queries [a′, b′] × [0, h] on W [41]. The procedure starts
at the root node of W , with the range [a′, b′] on its bitmap B. This range will become [al, bl] =
[rank0(B, a′ − 1) + 1, rank0(B, b′)] on the left child of the root, and [ar, br] = [rank1(B, a′ − 1) +
1, rank1(B, b′)] on the right child. If the maximal y-coordinate of the left child is smaller than or
equal to h, we count the number of points p with p.x ∈ [a, b] stored in the left child, which is simply
bl − al + 1, and then visit the right child. Otherwise, the maximal y-coordinate in the left child is
larger than h, and we just visit the left child. The time is O(1) per tree level.

(cid:3)

Lemma 5 Let v ≤ m ≤ n. There exists a data structure that uses O(v log m) additional bits and
answers three-sided range reporting queries for a set S of v points on an m×n grid in O(log v +occ)
time, to report the occ results. It can be built in O(v log v) time.

Proof : We can reduce the problem of reporting on an m × n grid to the problem of reporting on
a v × n grid, as described above. The query time is increased by an additive O(log v) factor, and
the space usage increases by O(v log m) bits of space. Now we sort the v points in x-coordinate
order, build the sequence Y [1..v] of their y-coordinates, and build a Range Minimum Query (RMQ)
data structure on Y [25]. This structure requires only O(v) bits of space, does not need to access
Y after construction (so we do not store Y ), and answers in constant time the query rmq(c, d) =
arg minc≤i≤d Y [i] for any c, d. It is well known that with such queries one can recursively retrieve
all the points in the three-sided range in O(occ) time; see, for example, Muthukrishnan [45]. The
construction time is dominated by the sorting of points.
(cid:3)

4 An Optimal Time Data Structure

The data structure of Lemma 3 gives us an O(mf + k) time solution, for any constant f , where m is
the grid width. In this section we use it to obtain O(h/ log n + k) time. The idea is to partition the
space into vertical stripes, for diﬀerent stripe widths, and index each stripe with Lemma 3. Then
the query is run on the partition of width m so that the O(mf ) time complexity is dominated by
O(h/ log n + k). The many partitions take total linear space because the size per point in Lemma 3

9

is O(log m), and our widths decrease doubly exponentially. As a query may span several stripes, a
structure similar to the one used in the classical RMQ solution [11] is used. This gives linear space
for stripes of width up to Ω(log2 n). Smaller ones are solved with universal tables.

In addition to the global array storing p.y for each p.x, we use another array storing the weight
corresponding to each p.x. As there are overall O(n) diﬀerent weights, those can be mapped to the
interval [1, O(n)] and still solve correctly any top-k reporting problem. Thus the new global array
also requires O(n) words of space.

4.1 Structure

Let gj = 1/2j for j = 0, 1, . . . , r. We choose r so that ngr = O(1), thus r = O(log log n). The x-axis
is split into intervals of size ∆j = ngj log2 n and j = 1, . . . , r. For convenience, we also deﬁne ∆0 = n
j = ∆j/ log2 n = ngj . For every 1 ≤ j < r and for every interval Ij,t = [(t− 1)∆j , t∆j − 1], we
and ∆′
store all the points p with p.x ∈ Ij,t in a data structure Ej,t implemented as described in Lemma 3.
Ej,t supports three-sided top-k queries in O((∆j)f + k) time for any constant 0 < f < 1/4. We
also construct a data structure E0 that contains all the points of S and supports three-sided top-k
queries in O(n1/4 + k) time. To simplify the description, we also assume that I−1 = I0 = [0, n − 1]
and E−1 = E0.
The data structures Ej,t for a ﬁxed j contain O(n) points overall, hence by Lemma 3 all Ej,t use
O(n log ∆j) = O(n log(ngj log2 n)) = (1/2j )O(n log n)+O(n log log n) additional bits of space. Thus
all Ej,t for 0 ≤ j < r use Pr−1
j=0[(1/2j )O(n log n) + O(n log log n)] = O(n log n) bits, or O(n) words.
They also require O(n log n) total construction time. Since f < 1/4, a data structure Ej,t supports
top-k queries in time O((∆j)f +k) = O((ngj log2 n)f +k) = O(ngj+2/ log n+k) = O(∆′
j+2/ log n+k)
time. For each of the smallest intervals Ir,t we store data structures Er,t that use o(log2 n) words
of space (adding up to o(n)) and support three-sided top-k queries in O(h/ log n + k) time. This
structure will be described in Section 4.3.

Note that our choice of writing (ngj log2 n)f = O(ngj+2/ log n) was arbitrary, because f is strictly
less than 1/4. We could have written (ngj log2 n)f = O(ngj+2/ logc n) for any constant c, and this
would yield O(h/ logc n + k) query time. We have chosen to favor simplicity in the exposition, but
will return to this point at the end of Section 4.3.

4.2 Queries

We can carry out the query using a range of intervals Ij,t of any width ∆j. The key idea is to use
a j value according to the height of the three-sided query, so that the search time in Ij,t gives the
desired O(h/ log n) time. More precisely, assume we want to report k points with highest weights
in the range [a, b] × [0, h]. First, we ﬁnd the index j such that ∆′
j+2. The
index j can be found in O(log log(h + k)) time by linear search1.
If [a, b] is contained in some
interval Ij,t, then we can answer a query in O(∆′
j+2/ log n + k) = O(h/ log n + k) time using Ej,t.
If [a, b] is contained in two adjacent intervals Ij,t and Ij,t+1, we generate the lists of top-k points in
([a, b]∩ Ij,t)× [0, h] and ([a, b]∩ Ij,t+1)× [0, h] in O(h/ log n + k) time, and merge them in O(k) time.
To deal with the case when [a, b] spans one or more intervals Ij,t, we store pre-computed solutions
for some intervals.

j+1 > max(h, k) ≥ ∆′

1This is O(h/ log n + k) for sure if max(h, k) = Ω(log n log log n); otherwise a small table can be used to perform

the search in constant time.

10

j+1) for any t ∈ [0, n/∆j ], any 0 ≤ v ≤ log2(n/∆j), and any 0 ≤ c ≤ ∆′

For 1 ≤ j ≤ r, we consider the endpoints of intervals Ij,t. Let topj(a, b, c, k) denote the list of
top-k points in the range [a · ∆j, b · ∆j − 1] × [0, c] in descending weight order. We store the values
of topj(t, t + 2v, c, ∆′
j+1. All
j+1)2 log n) = O(n/ log n) words. Hence the total word
the lists topj(·,·,·,·) use space O((n/∆j)(∆′
space usage of all lists topj(·,·,·,·) for 2 ≤ j ≤ r is O(n log log n/ log n) = o(n). It can also be built
in o(n) time using dynamic programming.
Assume that [a, b] spans intervals Ij,t1+1, . . . , Ij,t2−1; [a, b] also intersects with intervals Ij,t1 and
Ij,t2. Let a′∆j and b′∆j denote the left endpoints of Ij,t1+1 and Ij,t2, respectively. The list Lm of
top-k points in [a′∆j, b′∆j − 1] × [0, h] can be generated as follows. Intervals [a′∆j, (a′ + 2v)∆j − 1]
and [(b′ − 2v)∆j, b′∆j − 1] for v = ⌈log2((b′ − a′)/∆j)⌉ cover [a′∆j, b′∆j − 1]. Let L′
m and L′′
m denote
the lists of the ﬁrst k points in topj(a′, a′ + 2v, h, ∆′
j+1) and topj(b′ − 2v, b′, h, ∆′
j+1) (we have k
results because k < ∆′
j+1; similarly we have the results for c = h because h < ∆′
j+1). We merge
both lists (possibly removing duplicates) according to the weights of the points, and store in Lm
the set of the ﬁrst k points from the merged list. Let Lt1 and Lt2 denote the sets of top-k points in
[a, a′∆j − 1] × [0, h] and [b′∆j, b] × [0, h]. We can obtain Lt1 and Lt2 in O(h/ log n + k) time using
data structures Ej,t1 and Ej,t2 as explained above. Finally, we can merge Lm, Lt1, and Lt2 in O(k)
time; the ﬁrst k points in the resulting list are the top-k points in [a, b] × [0, h].
4.3 A Data Structure for an O(log2 n) × n Grid.
The data structures Er,t for an interval Ir,t use the same general approach as the data structures
Ej,t, at a smaller scale. Note that these structures will be consulted only when max(h, k) <
r+1 = O(1). Each interval Ir,t is subdivided into log7/4 n intervals eI1, eI2, . . . of width
C = ∆′
log1/4 n. Let eS denote the set that contains the endpoints of eI1, eI2, . . .. For every x ∈ eS, each
1 ≤ v ≤ 2 log log n and each h ≤ C, we store the lists top(x, x + 2v, h, C). All such lists use
O((n/ log2 n)C 2 log7/4 n log log n) = o(n) space in total.
A query on Ir,t is processed as follows. Suppose that [a, b] intersects with intervals eIg1, . . . , eIg2
for some g1 ≤ g2. We ﬁnd the top-k points from (eIg1+1 ∪ . . .∪ eIg2−1)× [0, h] in O(k) time using lists
top(·,·,·,·), as before. We also ﬁnd top-k points from (eIg1 ∩ [a, b])× [0, h] and (eIg2 ∩ [a, b])× [0, h] in
O(k) time using data structures for eIg1 and eIg2, respectively, to be described next. We thus obtain
three lists of points sorted by their weights, and merge them in O(k) time as before.
Finally, we describe how to answer queries in O(k) time in the grids eIg, of width log1/4 n.
We replace the y-coordinates of points by their ranks; likewise, the weights of points are also
replaced by their ranks. The resulting sequence Xg contains all mapped points in eIg and consists
of O(log1/4 n log log n) bits, so all the descriptions of all sequences Xg require O(n log log n) bits,
or o(n) words. There are O(log1/2 n) queries that can be asked (considering all the sensible values
of [a, b], h and k), and the answers require O(k log(log1/4 n)) = O(log log n) bits. Thus we can
store a universal look-up table of size 2O(log3/4 n log log n)O(log log n) = o(n) words common to all
subintervals eIg. This table contains pre-computed answers for all possible queries and all possible
sequences Xg. Hence, we can answer a top-k query on Xg in O(k) time.

A query on eIg can be transformed into a query on Xg by reduction to rank space in the y
coordinates. Consider a query range Q = [a, b] × [0, h] on eIg. We can ﬁnd the rank h′ of h among
the y-coordinates of points from eIg in O(h) = O(1) time by linear search (remember that we store
only the reordering of the local x-coordinates, and the actual y-coordinates are found in the global

11

array). Then, we can identify the top-k points in Xg ∩ Q′, where Q′ = [a, b] × [0, h′], using the
look-up table and report those points in O(k) time.

Thus our data structure uses O(n) words of space and answers queries in O(h/ log n + k) time.
It can be built in O(n log n) time. As mentioned at the end of Section 4.1, we can obtain any query
time of the form O(h/ logc n + k), for any constant c. This completes the proof of Theorem 4, which
is given in this general form.

4.4 Online Queries

An interesting extension of the above result is that we can deliver the top-k documents in online
fashion. That is, after the O(p/ logσ n) time initialization, we can deliver the highest weighted
result, then the next highest one, and so on. It is possible to interrupt the process at any point
and spend overall time O(p/ logσ n + k) after having delivered k results. That is, we obtain the
same result without the need of knowing k in advance. This is achieved via an online version of
Theorem 4, and is based on the idea used, for example, in [13, 37]. We describe it for completeness.
Consider an arbitrary data structure that answers top-k queries in O(f (n) + kg(n)) time in the
case when k must be speciﬁed in advance. Let k1 = ⌈f (n)/g(n)⌉, ki = 2ki−1, and si = Pi−1
j=1 kj
for i ≥ 2. Let S be the set of points stored in the data structure and suppose that we must
report top points from the range Q in the online mode. At the beginning, we identify top-k1
points in O(f (n) + g(n)) time and store them in a list L1. Reporting is divided into stages.
During the i-th stage, we report points from a list Li. Li contains min(ki,|Q ∩ S| − si) top points
that were not reported during the previous stages. Simultaneously we compute the list Li+1 that
contains min(2ki + si,|Q ∩ S|) < 4ki top points. We identify at most 2ki + si top points in
O(f (n) + 4ki · g(n)) = O(ki · g(n)) time. We also remove the ﬁrst si points from Li+1 in O(ki) time.
The resulting list Li+1 contains 2ki = ki+1 points that must be reported during the next (i + 1)-th
stage. The task of creating and cutting the list Li+1 is executed in such a way that we spend O(1)
time when each point of Li is reported. Thus when all the points from Li are output, the list Li+1
that contains the next ki+1 top points is ready and we can proceed with the (i + 1)-th stage.

The reporting procedure described above outputs the ﬁrst k most highly weighted points in

O(f (n) + kg(n)) time. It can be interrupted at any time.

5 A Dynamic Structure

We consider now a scenario where insertions and deletions of whole documents are interspersed
with top-k queries. This has two important components: how to maintain the suﬃx tree and how
to maintain the grid. Then we consider how queries are performed. We ﬁrst consider just the
measure tf and then generalize to others at the end.

5.1 Dynamic Suﬃx Trees

We use a dynamic suﬃx tree maintenance algorithm where leaves and unary nodes can be inserted
and deleted, and lowest common ancestors can be computed, all in constant worst-case time [17].
The updates on leaves and unary nodes are the operations we need to insert and delete all the suﬃxes
of a document in the suﬃx tree, in time proportional to the length of the document inserted or
deleted, whereas the lowest common ancestor queries are necessary to compute the new ptr(·,·)

12

pointers to insert. In any node we will maintain the up to σ children using a linear-space dynamic
predecessor data structure that supports queries and updates in worst-case time o((log log σ)2) [3].
Upon insertion of a new document d of length |d|, we follow McCreight’s procedure to insert
a new string in a generalized suﬃx tree [43]. First we search for the new document string in the
suﬃx tree, add the corresponding leaf and, if necessary, insert its parent splitting an edge. Then
we compute the suﬃx link of the last node that belonged to the path found, follow the suﬃx link,
descend again as much as possible, create a new leaf and possibly an internal node, create suﬃx
links from the last to the current created nodes, and continue until exhausting the suﬃx. This
requires O(|d|) suﬃx tree operations, and total time O(|d|(log log σ)2).
The deletion of a document d is symmetric to insertion. We ﬁnd its corresponding string, delete
its leaf and possibly its parent if it becomes unary, follow the suﬃx link, and repeat the process
until removing all the leaves and possibly their parents. This takes O(|d|(log log σ)2) time.
In order to accelerate searches we will use a technique analogous to the one used with the
static suﬃx tree. We deﬁne ℓ = logσ n, and the level of a node v as lev(v) = ⌊|l(root, v)|/ℓ⌋.
Note that the level of a node depends on its string depth, and thus it does not change upon
updates. Each suﬃx tree node v with parent u such that lev(v) > lev(u) will maintain a predecessor
data structure called an accelerator, storing all its highest descendant nodes z such that lev(z) >
lev(v). The key used for the predecessor data structure are the ℓ characters (lg n bits) formed by
l(root, z)[lev(v)· ℓ + 1, (lev(v) + 1)· ℓ]. Note these keys do not depend precisely on v being the node
holding the accelerator; any other ancestor of z of the same level of v yields the same key. Note
also that the nodes z stored in the accelerator of v are owners of subsequent accelerators.

The predecessor structures hold O(n) nodes, and thus they require o((log log n)2) time and
linear space [3]. The total extra space is linear because each suﬃx tree node belongs to at most
one predecessor structure.

Upon searches, we start at the root and use the accelerators of successive nodes, using consecutive 
chunks of ℓ symbols in P . In some cases we may arrive at nodes whose string distance to the
previously visited node is more than ℓ; in those cases we check the missing symbols directly in the
text, also in chunks of ℓ characters. When, ﬁnally, the accelerator does not give a node matching
the next ℓ symbols of P , we switch to the character-based search. Thus the total search time is
O(p(log log n)2/ logσ n + (logσ n)(log log σ)2) = O(p(log log n)2/ logσ n + log n).

Those accelerators must be updated upon insertions and deletions of suﬃx tree nodes. Note
that we always know l(root, v) when we insert or delete a node v. Upon insertion of a leaf v as
a child of a node u, it may turn out that the leaf must be inserted into an accelerator (because
lev(v) > lev(u)). We can simply ﬁnd the nearest ancestor holding an accelerator via at most ℓ
parent operations from v. We must also initialize an empty accelerator for v. Symmetrically, when
a leaf v is removed, we may have to remove it from its ancestor’s accelerator. When an edge from
u to v is split with a new node z, it may be that lev(u) < lev(z) = lev(v). In this case, z takes
the role of v, “stealing” the accelerator from v (which needs no change, as explained). We must
also replace v by z in the accelerator stored at the proper ancestor of z. Another case that requires
care is when lev(u) < lev(z) < lev(v). In this case v is replaced by z in the proper ancestor of z,
but v retains its accelerator and z creates a new accelerator holding only v. Other cases require no
action. Upon deletions, the obvious reverse actions are necessary. The total update time can be
bounded by O(|d| log n) for both insertions and deletions.

13

5.2 Relating the Suﬃx Tree and the Grid

Since grid columns will appear and disappear upon document insertions and deletions, we will not
associate integers to columns, but just abstract labels. The mapping between the suﬃx tree and
the grid columns will be carried out via a dynamic technique to maintain order in a list X of such
abstract labels [21, 10]. The data structure supports the operations of creating a new label y as
the immediate successor of a given label x ∈ X, deleting a label y ∈ X, and determining which
of two labels comes ﬁrst in X, all in constant time. In addition, each suﬃx tree node v will hold
a (classical) doubly-linked list list(v) storing consecutive labels of X, each label corresponding to
a grid column where this node induces points, and will maintain pointers to the ﬁrst and the last
node in list(v). Finally, v will maintain special labels ﬁrst(v), last (v) ∈ X that do not represent any
column, but are the predecessor (resp. successor) in X of the ﬁrst (resp. last) label in its subtree.
As we insert a new leaf v as the child of u, we must create a predecessor of last (v′) to assign
to last(v), where v′ is the next sibling of v, and then create a predecessor of last (v) to assign to
ﬁrst(v).
If v is the last child of u, then we create a predecessor of last (u) to assign to last (v).
When, instead, we create a new node v that splits an edge from u to v′, then ﬁrst(v) will be a new
predecessor of ﬁrst(v′) and last (v) will be a new successor of last (v′). When a node v is removed,
its labels ﬁrst (v), last (v) are also removed from X.

As we insert a new document d, we must associate new grid columns to the new and existing
suﬃx tree nodes traversed. Each newly created pointer ptr(v, d) will require creating a new label
t(v, d) ∈ X as the successor of the last one currently held in list (v) (it will also be stored at the end
of list(v)). When list(v) is empty, the new label t(v, d) must be created as the successor of ﬁrst (v).
As we insert new leaves in the suﬃx tree, we collect them in an array L[1,|d|]. We also create
the ﬁrst label t(v, d) of such leaves v. Now we sort L by the labels t(v, d), and as a result the new
leaves become sorted by their suﬃx tree preorder. All the internal suﬃx tree nodes that must be
labeled with d are obtained as u = lca(v, v′) for consecutive leaves v = L[i] and v′ = L[i + 1]. We
create pointers ptr(v, d) and ptr(v′, d) towards node u, associated to the labels t(v, d) and t(v′, d),
respectively, and with weights w(v, d) = w(v′, d) = 1. For each new internal suﬃx tree node
u = lca(v, v′) obtained, we create a new label t(u, d) for the new grid column that u will originate,
and associate weight w(u, d) = 2 to it (at the end, w(u, d) will be the number of leaves labeled d
in the subtree of u). Each time u is obtained again (which we know because the last element of
list(u) is already t(u, d)), we increase w(u, d) by 1.

Now we have to propagate weights and pointers from internal nodes labeled with d to their
nearest ancestors labeled with d (i.e., the nodes that would be their parent in the suﬃx tree of
document d). For this sake, the internal nodes u = lca(v, v′) obtained are collected in a new array
I, of size up to |d| − 1, and I is sorted by the labels t(u, d), so that the nodes become sorted by
preorder. We traverse I left to right, simulating a recursive preorder traversal of the suﬃx tree
of document d, although the nodes are in the generalized suﬃx tree. Let u = I[i] and v = I[j],
initially for i = 1 and j = 2. If lca(u, v) = u, then u is the parent of v in the suﬃx tree of d. Thus
we recursively traverse the subtree that starts in v = I[j], which ﬁnishes at a node v′ = I[j′] that
is not anymore a descendant of v. Now we check whether lca(u, v′) = u (i.e., v′ is the second child
of u in the suﬃx tree of d), and so on. At some point, it will hold that I[j′] does not descend from
u, and we have ﬁnished the traversal of the subtree of u. Along this recursive traversal we will
identify the nearest ancestor u labeled d of each node v labeled d. For each such pair, and after
having processed v and computed w(v, d), we increase w(u, d) = w(u, d) + w(v, d) and generate the
pointer ptr(v, d) pointing to u, associated to label t(v, d) and weight w(v, d).

14

All the labels created when inserting a document d are additionally chained in a (classical)
list list(d), to facilitate deletion of the document. The overall time of this step is O(|d| log |d|),
dominated by the sorting via comparisons of labels in X.
Finally, we will create new columns and points in the grid associated to all the pointers
ptr(v, d) = u created. The label t(v, d) will be an identiﬁer for the x-coordinate of the point
(we remark that these are not integers, but just labels that can be compared). The y-coordinate
will be the string depth of the target node, |l(root, u)|. This value is stored in the suﬃx tree node
when the node is created and, unlike the tree depth, does not change upon suﬃx tree updates.
The document associated to the new point is the new one, d, and the weight is the value w(v, d)
associated to the source node of the pointer.

Handling the deletion of a document d is simple. After deleting all the corresponding suﬃx
tree nodes, we follow the chain of labels t(v, d) in list(d), delete them from X and remove their
nodes from the doubly-linked list list(v). This takes O(|d|) additional time. We also remove the
columns in the grid corresponding to the labels deleted, and the associated points. Both insertion
and deletion times are superseded by those of Section 5.1.

5.3 Slim Grids

To achieve faster searches, the grid will be divided into horizontal slices of small height r. For every
slice, we maintain a structure that reports k most highly weighted points from a horizontal range
of labels [a, b) intersected with a vertical range of integers [0, y). We describe here how those slices
are updated and queried for a sublogarithmic value of r, and in Section 5.4 we extend the solution
to grids of polylogarithmic height.

Each slice is represented with a B-tree ordered by the labels (i.e., x-coordinates) of the points,
of arity ρ to 2ρ− 1, for some sublogarithmic ρ to be deﬁned later (as usual, the root can have arity
as low as 2). Thus the B-tree has height O(logρ n). At each internal node u with a(u) children
v1, . . . , va(u), we will store a(u) arrays Wv1[0..r−1], . . . , Wva(u)[0..r−1]. In these arrays Wv, Wv[y] is
the point p with maximum weight among all points (1) whose x-coordinates belong to the subtree
of v, (2) with y-coordinate equal to y, and (3) not stored in Wu[y] for ancestors u of v (some Wv[y]
cells can be empty, if no point with y-coordinate y exists below v). We will also store a structure
Wroot for the root node root. Thus Wroot[y] contains the point pr of maximum weight among all
points with y-coordinate y; for a child v of root, Wv[y] contains the point pv of maximum weight
among all points p 6= pr in the subtree of v with y-coordinate y. In general, all points already
stored in ancestors are excluded from consideration. We store Wv[y] = (x, w, d), where x is the
x-coordinate, w is the weight, and d is the document of the point. Each point is also stored in
the corresponding leaf node. Those points in Wv are not used to separate the x-coordinates of the
points in the tree. Instead, new labels x(v1) . . . x(va(u)−1) ∈ X will be created and stored at node
u, to split the points between its a(u) consecutive children. That is, the x-coordinate of any point
stored below vi will be between x(vi−1) and x(vi). The size of the list X stays O(n).

The leaves of the B-tree will store r to 2r− 1 points. Leaves store the actual points, even if they
are also mentioned in some previous Wv structure. The points in leaves l are arranged in an array
W ′
l , which is similar to the arrays Wv and list the points in increasing y-coordinate order, except
that W ′
l has no empty cells and some y-coordinates can be repeated in the points. Therefore the
W ′

l cells store the full point data, W ′
To each internal node u with children v1, . . . , va(u) we will also associate structures Yx u[0..a(u)r−
1] and Yw u[0..a(u)r − 1], where the child numbers and the y-coordinates of the (up to) r points of

l [j] = (x, y, w, d).

15

the a(u) arrays Wvi are sorted by their x-coordinate label (in Yx u) and by their weight (in Yw u).
That is, in Yx u and Yw u we store the pair (i, y) for each entry Wvi[y], ordered by Wvi[y].x (in
Yx u) or by Wvi[y].w (in Yw u). Each value stored in Yx u and Yw u requires lg(2ρr) bits, thus all
the values in these two structures add up to at most 4ρr lg(2ρr) bits. Each time we modify a value
in a Wvi array, we rebuild from scratch the Yx u and Yw u structures of the parent u of vi.

We will also maintain structures Yx ′

l and Yw ′

l will just store positions j of the array W ′

l on the (up to) 2r− 1 points of leaves l, analogous
to the Yx u and Yw u structures of internal nodes. Instead of the pairs (i, y), structures Yx ′
l and
Yw ′
l (those positions would coincide with y-coordinates
in internal nodes). Leaves will also store an array Yl[0..r− 1] where Yl[y] = j if j is the last position
where W ′
l [j]
also appears in the Wv array of an ancestor v of l.

l [j] < y. Finally, leaves will store bitmaps Ql marking in Ql[j] whether the point in W ′

We will end up choosing ρr = o(log n), and thus universal tables of 24ρr lg(2ρr)·O(polylog (ρr)) =
o(n) bits will be used to query and update the arrays Yx u and Yw u, in constant time. Similarly,
leaves will use even smaller universal tables of 24r lg(2r) · O(polylog (r)) = o(n) bits.
The whole data structure requires linear space, because the leaves contain Θ(r) points. The Wv
arrays of internal nodes spend Θ(r) words and can be almost empty (if all the descendants have
the same y-coordinate, say), but there are only O(n/r) internal nodes. If the whole grid contains
less than r points, we just store the space for them in a leaf.

Insertions

5.3.1
Consider the insertion of a new point (x, y, w, d), with label x ∈ X, y-coordinate y ∈ [0, r), weight
w and document d. While following the normal insertion procedure on the B-tree (where we
compare the labels x(vi) of the nodes with x to decide the insertion path), we look for the highest
node v with Wv[y].w < w or with Wv[y] empty. For the ﬁrst (i.e., highest) such v we ﬁnd,
we set Wv[y] ← (x, w, d), and then we continue the classical insertion procedure (not looking at
Wv[y] entries anymore) until adding the point (x, y, w, d) in a leaf l. In the leaf we mark in the
corresponding Ql entry whether we had updated an entry Wv[y] in some ancestor v.

If we updated some Wv[y], and it already had a previous value Wv[y] = (x′, w′, d′), we perform
a process we call reinsertion of (x′, w′, d′). We restart the process of inserting the point (x′, y, w′, d′)
from node v (note that this point already exists in a leaf; reinsertion will not alter the structure of
the tree, but just rewrite some W and Q values). In the reinsertion path, if we arrive at a node v′
where Wv′[y].w < w, we set Wv′[y] ← (x′, w′, d′). If there was a previous value Wv′ [y] = (x′′, w′′, d′′),
we continue the reinsertion process for point (x′′, w′′, d′′) from node v′, and so on until either we ﬁnd
an empty space in some Wu[y] or we reach the leaf l where the point being reinserted is actually
stored. In this latter case, we clear the corresponding bit in Ql, indicating that this point is not
stored anymore in an ancestor structure.

Thus we traverse two paths, one for inserting the point, and another for reinserting the point(s)
possibly displaced from some Wv[y] structure. This part of the operation requires, in the worst
case, O(logρ n) updates to the structures Yx u and Yw u of the parents u of nodes v where Wv is
modiﬁed, plus an insertion in a leaf.

Rebuilding structures Yx u and Yw u. Upon an assignment Wvi[y] ← (x, w, d), we must rebuild
the structures Yx u and Yw u of the parent u of vi. We binary search Yx u for x, and binary search
Yw u for w, both in O(log(ρr)) time. In these binary searches we obtain the actual label and weight
of each element of Yx u and Yw u, respectively, using its (i, y) pair, as Wvi[y].x and Wvi[y].w. These

16

binary searches give the insertion positions 0 ≤ e < 2ρr and 0 ≤ g < 2ρr, respectively, of the
pair (i, y) in Yx u and Yw u. Note that the new contents of Yx u and Yw u depend only on their
current contents, on the values e and g, and on the incoming pair (i, y) (the existing occurrence of
(i, y), if any, must be removed). Thus, the new content of Yx u and Yw u for each (e, g, i, y) can be
precomputed in a universal table of o(n) bits, as explained, so that they are updated in constant
time. Therefore the time to update the structures is O(log(ρr)), and the cost of a full reinsertion
process is O(logρ n log(ρr)).

Removing the value of a cell Wvi[y] is analogous. We can insert all the cells of a whole new Wv
array, or remove all the cells of a whole Wv array, one by one in time O(r log(ρr)). When a whole
array is inserted or removed, we have to rename all the labels i in the cells (i, y), but those updates
can also be precomputed in universal tables of sublinear size.

l and recalculating Yl, Yx ′

In leaves l, we must actually insert the point, possibly displacing all the
Insertion in leaves.
entries in W ′
l and Ql, all in O(r) time. When a leaf overﬂows to 2r
points, we must split it into two leaves l′ and l′′ of r points each. We ﬁrst remove the array Wl
from the parent u of l, clearing the corresponding bits in Ql. Now we distribute the points of W ′
l
l′′, and make l′ and l′′ children of u, replacing the old l. We create a
into the new arrays W ′
new label x(l′) ∈ X right after the largest x-coordinate in l′, and add it to u separating l′ and l′′.
Now we build new arrays Wl′ and Wl′′. Those arrays, as well as the Y , Yx ′, Yw ′ and Q
structures of l′ and l′′, are built in O(r) time from W ′
l and Ql. We mark in Ql′ and Ql′′
the points that have been included in Wl′ and Wl′′ (we cannot choose any point for Wl′ and Wl′′
that is already marked in Ql). Finally, we insert Wl′ and Wl′′ in u.

l′ and W ′

l, Yw ′

l , Yx ′

l, Yw ′

The overall time is O(r), but this is dominated by the O(r log(ρr)) time needed to update the

Yx u and Yw u arrays upon the O(r) changes induced by substituting Wl by Wl′ and Wl′′.

Overﬂows in internal nodes. Further, the insertion in the parent u can trigger an overﬂow in
this internal node, if its arity reaches 2ρ. We must split u, with children v1, . . . , v2ρ, into two nodes,
u′ with children v1, . . . , vρ and u′′ with children vρ+1, . . . , v2ρ. The process is analogous to the case
of leaves, but slightly more complicated. We create a new x-coordinate x(u′) ∈ X following x(vρ),
to separate the points of u′ and u′′. We create the two nodes with their corresponding arrays Wvi,
and build the tables Yx and Yw of u′ and u′′, in O(ρr) time from Yx u and Yw u.

Now we must create new arrays Wu′ and Wu′′ to replace Wu in the parent of u. First, we move
the points in Wu[y] into Wu′[y] and Wu′′[y], according to their x-coordinate. Now we can get rid
of Wu, but we still have several empty cells in Wu′[y] and Wu′′[y]. Those are ﬁlled with a process
we call uninsertion: To ﬁll some cell Wu′[y] (analogously for u′′), we take the maximum weight in
cells Wv1[y], . . . , Wvρ [y]. The maximum Wvi[y].w is found in constant time using a universal table
on Yw u′. Then we copy Wu′[y] ← Wvi[y], and continue the uninsertion process for Wvi[y]. When
we ﬁnally arrive at uninserting a point from a leaf l, all we have to do is to mark the corresponding
entry in Ql. Note that uninsertion does not alter the structure of the tree; it just rewrites some W
and Q values. The cost of one uninsertion is O(logρ n log(ρr)), to rebuild the aﬀected structures
Yx and Yw . Thus the O(r) uninsertions in u′ and u′′ add up to O(r logρ n log(ρr)) time, which
subsumes the O(r log(ρr)) cost to replace Wu by Wu′ and Wu′′ in the parent of u.

Note that the insertion of a single point could produce one split per level of the B-tree. To
avoid this, we use a deamortization technique by Fleischer [26]. This maintains an (α, 2β)-tree
(for α ≤ 2β) storing n keys in the leaves, and each leaf is a bucket storing at most 2 logα n keys.

17

It supports constant-time insertion and deletion of a key once its location in a leaf is known,
guaranteeing at most one split per insertion or deletion. The premises are consistent with our
setting, with α = β = ρ, and storing O(r) = o(log n) keys per leaf.

5.3.2 Deletions

Deletion of a point (x, y) starts by searching the B-tree for the x-coordinate x. The point will be
found in its leaf, and also possibly in some cell Wv[y] of some internal node v. The search takes
O(log n) time because, for internal nodes u, we binary search the coordinates x(vi) stored in u for
the correct child v, in O(log ρ) time, and then only have to check if Wv[y].x = x. In leaves l, we
binary search for x in Yx ′

l in O(log r) time.

If the point has to be deleted from some Wv[y], we carry out the uninsertion process already
described, in O(logρ n log(ρr)) time. We also remove the point (x, y) itself from leaf l. When a leaf
l underﬂows, we merge it with a neighbor leaf and, if necessary, split it again. The merging process
is analogous to the splitting and can be easily carried out in O(r) time, plus O(r log(ρr)) to update
the structures Yx and Yw in the parent.

If an internal node underﬂows, we also merge it with its neighbor and re-split it if necessary. The
merging of two sibling nodes v and v′ is carried out in O(ρ) time, including the construction of the
Yx and Yw structures for the merged node, u. The diﬃcult part is, again, to get rid of the arrays
Wv and Wv′ at the parent node, replacing them by a new Wv∗ table for the merged node v∗. For
this sake, we choose the maximum weight between each Wv[y] and Wv′ [y] and assign it to Wv∗[y].
The point that was not chosen among Wv[y] and Wv′ [y] must be reinserted, as before. Finally, we
must rebuild the Yx and Yw structures of the parent of v∗. The total cost is O(r logρ n log(ρr)),
just as for insertions.

Note that, upon leaf or internal node merges, a separating label x(v) becomes unused, and it is

removed from X. Again, Fleischer’s technique [26] ensures at most one underﬂow per update.

5.3.3 Queries

Identifying the relevant nodes. To solve a top-k query with label restriction [a, b) and ycoordinate 
restriction [0, y) on the slice, we ﬁrst identify the O(logρ n) ranges of siblings of the
B-tree tree that exactly cover the interval of labels [a, b); plus up to 2 leaf nodes that partially
overlap the interval. For each node u that is the parent of a range of children vs, . . . , ve included
in the cover, we ﬁnd the maximum weight in Wvs[0, y − 1], . . . , Wve[0, y − 1] and insert the result
in a max-priority queue Q sorted by the weights of the points. Such maximum across Wvi[0, y − 1]
arrays is obtained in constant time using universal tables on Yw u. If l is a leaf partially covering
l [0, y′], where y′ = Yl[y]. In addition, we must binary search Yx ′
[a, b), then the interval is some W ′
l
for the range [xa, xb] corresponding to the interval [a, b). Furthermore, we can only return points
whose Ql bit is not set, to avoid repeated answers. Knowing the range in Yx ′
l[xa, xb] and the range
W ′
l and Ql with a universal table, in
constant time. Identifying the cover nodes and ﬁnding their O(logρ n) maxima takes O(log n) time,
and leaves add only O(log r) time.

l [0, y′], the maximum weight can be obtained from Yx ′

l, Yw ′

Each element inserted in Q coming from a range of siblings will be a tuple (u, s, e, i, z, k), where
u is the parent node of the range of children vs, . . . , ve in the cover, (i, z) means that the maximum
was found at Wvi[z] (s ≤ i ≤ e), and k indicates that the point Wvi[z] is the kth in the range of
interest for u. All the nodes initially inserted have k = 1.

18

The elements inserted in Q coming from leaves l are of the form [l, j, xa, xb, k], meaning that
l [0, Yl[y]] and Yx ′[xa, xb], and that

the maximum was found in W ′
the point is the kth in the range of interest. The ﬁrst insertions use k = 1.

l [j], that the range of interest is W ′

We also insert in Q a third kind of tuples, namely, the maximum-weight point in Wv[0, y − 1]
with x-coordinate in [a, b), for each of the O(logρ n) ancestors v of the cover nodes, as they may
also hold relevant points. To ﬁnd those maxima we consider the parent u of v and binary search
Yx u for a and b, to ﬁnd a mapped interval Yx u[xa, xb], in O(log(ρr)) time. Note that this area
of Yx u corresponds to nodes in Wv. Then we use universal tables on Yx u and Yw u to ﬁnd the
maximum weight of y-coordinate below y and in the range Yx u[xa, xb]. For these nodes we insert
tuples of the form hu, v, z, xa, xb, ki in Q, meaning that the maximum was obtained from Wv[z],
the range of interest is Yx u[xa, xb], and the point is the kth in its range of interest. Therefore the
initial computation on these nodes requires O(logρ n log(ρr)) time. Recall that the root node of the
B-tree will also have a W structure computed (this is easily treated as a special case).

We implement Q as a Thorup’s priority queue [60] on the universe of weights [1, O(n)]. Note
that we do not need to insert the whole initial set of O(logρ n) tuples in Q if this number exceeds
k: if a tuple is not among the ﬁrst k, it cannot contribute to the answer. Then we use linear-time
selection to ﬁnd the kth largest weight in the tuples and then insert only the ﬁrst k tuples in Q. This
structure supports insertions in constant time, thus the initialization of Q takes time O(logρ n).

l [j′] within W ′

l [0, Yl[y]] and Yx ′

Extracting the top-k points. The ﬁrst answer to the top-k query is among the O(k) tuples we
have inserted in Q. Therefore, to obtain the ﬁrst result, we extract the tuple with maximum weight
from Q. If it is of the form [l, j, xa, xb, k], that is, it comes from a leaf l, we report the point W ′
l [j],
compute the (k +1)th highest-weight point W ′
l[xa, xb] using universal
tables, and reinsert tuple [l, j′, xa, xb, k + 1] in Q. If, instead, the maximum tuple extracted from Q
is of the form hu, v, z, xa, xb, ki, that is, it becomes from an ancestor of a cover node, we report the
point Wv[z], compute the (k+1)th highest-weight point Wv[z′] with y-coordinate below y and within
Yx u[xa, xb] using universal tables, and reinsert tuple hu, v, z′, xa, xb, k + 1i. Finally, if the maximum
tuple extracted from Q is of the form (u, s, e, i, z, k), we report the point Wvi[z], where vi is the
ith child of u, compute the (k + 1)th highest-weight point Wvi′ [z′] in Wvs[0, y − 1], . . . , Wve [0, y − 1]
using universal tables, and reinsert tuple (u, s, e, i′, z′, k + 1). If the extracted point had k = 1,
however, it is possible that the next highest-weight element comes from the child vi. Therefore,
if vi is an internal node, we compute the highest-weight point in Yw vi with y-coordinate below y.
Let it be the pair (i′′, z′′), then we insert a new tuple (vi, 1, a(vi), i′′, z′′, 1) in Q. If, instead, vi is a
leaf l = vi with r(l) elements, then we ﬁnd the maximum-weight point W ′
l [0, Yl[y]] using
Yw ′
l, and insert the tuple [l, j′, 1, r(l), 1] in Q. In all cases the cost to compute and insert the new
tuples is constant.

l [j′] in W ′

If we carry out k extractions from Q, we will also carry out up to 2k insertions, thus the size
of Q will be O(k) and minima extractions will cost O(log log k) [60]. The cost of this part is then
O(k log log k), and the total query time is O(log n+log r+logρ n log(ρr)+logρ n+k log log k). Given
a constant 0 < ε < 1/2, we will choose r = ρ = lgε n, fulﬁlling the promise that ρr = o(log n).
Therefore, the update cost becomes O(r logρ n log(ρr)) = O(log1+ε n), and the query time becomes
O(log n + k log log k). Note that the process is not online: We must know k in advance so as to
initially limit the size of Q to k. We use the technique of Section 4.4 to make the process online in
k. That is, k is not speciﬁed in advance and the process can be interrupted after having produced
any number k of results, and the total cost paid will be O(log n + log log k).

19

5.4 Multiresolution Grids

We extend the result of Section 5.3 to grids of polylogarithmic height rc, for some constant c. We
will represent the grid at various resolutions and split it into slim grids for each resolution. Consider
a virtual perfect tree of arity r and n leaves, so that the ith left-ro-right node of height j covers
the rows (i − 1) · rj + 1 to i · rj. The tree is of height c.
For each node v of this tree we store a slim grid of r rows, one per child. All the points whose
row belongs to the area covered by the ith child of v will be represented as having y-coordinate i
in the slim grid of v.

When a new point (x, y, w, d) is inserted in the grid, we insert it into the c slim grids that cover
it, giving it the appropriate row value in each slim grid, and similarly when a point is deleted. The
x-coordinate labels are shared among all the grids. This arrangement multiplies space and insertion
and deletion times by the constant c.

Now consider a 3-sided top-k query with the restriction [a, b) on the x-coordinates and [0, y)
on the y-coordinates. The range [0, y) is covered with the union of one range in one slim grid per
level of the tree. Let yc, . . . , y1 be the child numbers of the path from the root to the y-th row of
the grid. Then we take the 3-sided query [a, b) × [0, yj ) at the node of height j in the path.
We start the searches in the c slim grids, and extract the ﬁrst result from each grid. We insert
those local maxima into a new global queue Q. Now we repeat k times the process of extracting
the next result from Q, reporting it, requesting the next result from the grid where the result came
from, and inserting it in Q. Note that Q can be implemented naively because it contains at most
c elements and c is a constant.
Initializing the searches will then require O(c log n) time, and extracting k results from the
slim grids will require O(k log log k) time. Managing Q will require O(ck) time even if done
naively. Therefore the total time is still O(log n + k log log k). The update time per element
stays O(c log1+ε n). The process is also online. Then we obtain the following lemma.

Lemma 6 A set of n points, one per column on an n × rc grid, for r = lgε n and any constant
0 < ε < 1 and c ≥ 1, with weights in [1, O(n)], can be stored in O(n) words of space, so that for any
1 ≤ k ≤ n, 1 ≤ h ≤ rc and 1 ≤ a ≤ b ≤ n, k most highly weighted points in the range [a, b] × [0, h]
can be reported in decreasing order of their weights in O(log n+k log log k) time, online in k. Points
(and their columns) can be inserted and deleted in O(log1+ε n) time.

5.5 The Final Result

We ﬁnd the locus v of P in the suﬃx tree in time O(p(log log n)2/ logσ n + log n). Then the xcoordinate 
range of labels to search for in the grid is [a, b), where a is the ﬁrst label in list(v) and
b = last (v). Since we store string depths in the grid, the y-coordinate range of the query is [0, p).
Our dynamic grid is horizontally split into bands of rc rows, for a constant c, which are handled
as explained in Section 5.4. Therefore, our 3-sided query is translated into 3-sided queries on the
ﬁrst ⌈p/rc⌉ bands. All but the last will query for the whole row interval [0, rc), whereas the latter
will query for the row interval [0, (p − 1) mod rc].
We start the searches in all the bands, and extract the ﬁrst result from each. If there are more
than k bands, we use linear-time selection to keep only the k highest weights. Then we insert the
local maxima into a new global queue Q. Now we repeat k times the process of extracting the ﬁrst
result from Q, and if it came from the ith band, then we request the next result from that band

20

and insert it in Q (unless it has no more results, in which case we continue with the remaining
bands). Again, Q will be implemented with Thorup’s priority queue [60].
Initializing the searches will then require O(⌈p/rc⌉ log n) time, and extracting k (and inserting
other k) results in Q will take time O(k log log k). We choose r = lgε n for some 0 < ε < 1/2,
as explained, and rename c as (c + 1)/ε. Therefore, we obtain a query time of O(p/ logc n +
log n + k log log k) for the grid. Once again, the scheme can be made online with the technique of
Section 4.4. Updating grid points, including extending the grid downwards, requires O(log1+ε n)
time. This yields Theorem 5.

We developed our result for tf as the relevance measure. It is very easy to support others like
docrank , but if the weights are not integer numbers, then Thorup’s priority queues [60] cannot be
used. In this case we insert all the new weights that appear in a data structure for monotonic list
labeling, which assigns them integers in a polynomial universe [1, nO(1)]. This adds at most O(log n)
time per symbol inserted [20] (deletions can be handled by deamortized periodic rebuildings). In
general we can support any measure that can be computed in time O(|d|Cw) over the suﬃx tree of
the document to insert: We explicitly build such suﬃx tree, compute the relevance measure for all
the nodes, and then use them to assign the weights as we insert the nodes in our suﬃx tree. At
the end we delete the suﬃx tree of d. This suﬃx tree can be built (and deleted) in O(|d|) time on
integer alphabets [22]. Therefore we simply charge O(Cw) time per character inserted in our text
collection. Note that Cw is O(1) for measures tf and docrank . Hon et al. [37] show how to compute
mindist from the suﬃx tree of the document in O(|d| log |d|) time, so Cw = O(log n) in this case.
Our scheme works as long as lg n has a ﬁxed value (plus O(1)). We use standard techniques to
incrementally rebuild the structure for larger or smaller lg n values as more insertions or deletions
are processed.

6 A Space-Eﬃcient Data Structure

We show now how the space of our static structure can be reduced to O(n(log σ + log D + log log n))
bits, where σ is the alphabet size and D is the number of documents, and retain almost the same
query time. Our approach is to partition the tree into minitrees, which are represented using
narrower grids.

Partitioning the tree. We deﬁne z = Θ(σD log n). We say that a node v ∈ T is heavy if the
subtree rooted at v has at least z leaves, otherwise it is light. A heavy node is fat if it has at least
two heavy children, otherwise it is thin.

All the non-fat nodes of T are grouped into minitrees as follows. We traverse T in depth-ﬁrst
order. If a visited node v has two heavy children, we mark v as fat and proceed. If v has no heavy
children, we mark v as thin or light, and make v the root of a minitree Tv that contains all the
descendants of v (which need not be traversed). Finally, if v has one heavy child v1, we mark v
as thin and make it the root of a minitree Tv. The extent of this minitree is computed as follows.
If vi, i ≥ 1, is a thin node with one heavy child vi+1, we visit nodes v1, v2, . . . vj−1 and include vi
and all the descendants of its other children, until either vj−1 has no heavy children or is fat, or
Tv contains more than σz nodes after considering vj. Then we continue our tree traversal from vj.
Note that Tv contains at the very least the descendants of v by children other than v1.

With the procedure for grouping nodes described above, the leaves of minitrees can be parents
of nodes not in the minitree. Those child nodes can be either fat nodes or roots of other minitrees.

21

However, at most one leaf of a minitree can have children in T .

Note that the size of a minitree is at most O(σz). On the other hand, as two heavy children
have disjoint leaves, there are O(n/z) fat nodes in T . Finally, minitrees can contain as little as
one node (e.g., for leaves that are children of fat nodes). However, note that a minitree root is
either a child of a fat node (and thus there are O(σn/z) minitrees of this kind), or a child of a
leaf of another minitree such that the sum of both minitree sizes exceeds σz (otherwise we would
have included the root vj of the child minitree as part of the parent minitree). Moreover, as said,
at most one of the leaves of a minitree can be the parent of another minitree, so these minitrees
that are “children” of others form chains where two consecutive minitrees cover at least σz nodes
of T . Thus there are O(n/(σz)) minitrees of this second kind. Adding up both cases, there are
O(σn/z) = O(n/(D log n)) minitrees in T .

Contracted tree and minitrees. The pointers in a tree T are deﬁned in the same way as in
Section 2. Since we cannot store T without violating the desired space bound, we store a contracted
tree T c and the minitrees Tv.

The contracted tree T c contains all fat nodes of T , plus one node vc for each minitree Tv. Each
pointer ptr(u, d) = u′ of T is mapped to a pointer ptrc(uc, d) = (u′)c of T c as follows. If u is a
fat node, then uc = u. Else, if u belongs to minitree Tv, then uc = vc. Similarly, if u′ is a fat
node then (u′)c = u′; else if u′ belongs to minitree Tv′ then (u′)c = (v′)c. In other words, nodes
of a minitree are mapped to the single node that represents that minitree in T c and pointers are
changed accordingly.

For each minitree Tv, we store one additional dummy node ν that is the parent of v. If a leaf
uh of Tv has a heavy child u′ 6∈ Tv, we store an additional dummy node ν ′ ∈ Tv that is the only
child of uh. Pointers of Tv are modiﬁed as follows. Each pointer ptr(u, d), u ∈ Tv, that points to an
ancestor of v is transformed into a pointer ptr(u, d) that points to ν. Every pointer ptr(u′′, d) that
starts in a descendant u′′ of uh and points to a node u ∈ Tv, u 6= uh, (respectively to an ancestor of
v) is transformed into ptr(ν ′, d) that starts in ν ′ and points to u (respectively to ν). By Lemma 2,
there are at most D such pointers ptr(u′′, d). We observe that there is no need to store pointers to
the node uh in the minitree Tv because such pointers are only relevant for the descendants of uh
that do not belong to Tv.

Suﬃx trees. The contracted tree T c consists of O(n/(D log n)) nodes, and thus it would require
just O(n/D) bits. The minitrees contain O(σz) nodes, but still an edge of a minitree can be
labeled with a string of length Θ(n). Instead of representing the contracted tree and the minitrees
separately, we use Sadakane’s compressed suﬃx tree (CST) [56] to represent the topology of the
whole T in O(n) bits, and a compressed representation [31, Thm. 5.3] of the global suﬃx array
(SA) of the string collection, which takes O(n log σ) bits. This SA representation ﬁnds the suﬃx
array interval [l, r] of P in time O(p/ logσ n + logε n log σ) for any constant ε > 0, and a lowest-
common-ancestor query for the l-th and r-th leaves of T ﬁnds the locus u of P in O(1) additional
time. A bitmap M [1, n] marks which nodes are minitree roots, and another bitmap C[1, n] marks
which nodes are fat or minitree roots. Both are indexed with preorder numbers of T , which
are computed in constant time on the CST. With a simple O(n)-bit structure for constant-time
marked ancestor queries that is compatible with our CST representation [54, Sec. 4.1], we can
ﬁnd the lowest ancestor v of u marked in M or in C. With bitmap M we can identify whether u
belongs to a minitree rooted at v (with local preorder preorderTv (u) = preorderT (u)−preorderT (v)

22

and depth depthTv (u) = depthT (u) − depthT (v); depths are also computed in constant time).
Similarly, with C and M we can identify whether u is a fat node, and ﬁnd out its preorder in T c
as preorderT c(u) = rank1(C, preorderT (u)), in constant time. Its depth in T c can be stored in an
array indexed by preorderT c in O(n/D) bits.

Contracted grid. We deﬁne the grid of the contracted tree T c as in Section 2, considering all
pointers ptrc. Those are either ptr pointers leaving from fat nodes, or leaving from inside some
minitree Tv and pointing above v. For every fat node and for every minitree Tv, and for each
document d, there is at most one such pointer by Lemma 2. Thus each node of T c contributes at
most D pointers ptrc. As there are O(n/(D log n)) nodes, there are O(n/ log n) pointers ptrc in T c.
Therefore, the grid associated to T c is of width O(n/ log n) and height O(n/(D log n)). As there
are O(n/ log n) distinct weights among the ptrc pointers, we only store their ranks. This change
does not alter the result of any top-k query. Therefore the data structure of Theorem 4 on T c
occupies O(n/ log n) words, or O(n) bits.

Local grids. The local grid for a minitree Tv collects the pointers ptr local to Tv. It also includes
at most D pointers towards its dummy root ν, and at most D pointers coming from its node ν ′, if it
has one. Overall Tv contains O(σz) pointers and O(σz) nodes, so its grid is of size O(σz) × O(σz).
The weights are also replaced by their ranks, so they are also in the range [1, O(σz)]. Using
Theorem 4 the minitree requires O(log(σz)) bits per node. Added over all the nodes of T that can
be inside minitrees, the total space is O(n log(σz)) = O(n(log σ + log D + log log n)). Note that the
tree topology is already stored in the CST, so information associated to nodes u ∈ Tv such as the
intervals [lu, ru] can be stored in arrays indexed by preorder numbers.

Queries. Given a query pattern P , we ﬁnd the locus u of P and determine whether u is a fat
node or it belongs to a minitree in O(p/ logσ n + logε n log σ) time, as explained. If u is fat, we solve
the query on the contracted grid of T c. Note that this grid does not distinguish among diﬀerent
nodes in the same minitree. But since u is an ancestor either of all nodes in a minitree or of none
of them, such distinction is not necessary.

If u belongs to a minitree Tv, we answer the query using the corresponding local grid. This grid
does not distinguish where exactly the pointers pointing to ν lead, nor where exactly the pointers
that originate in ν ′ come from. Once again, however, this information is not important in the case
where the locus u of P belongs to Tv.

Note that we still need to maintain the global array mapping x-coordinates to document identiﬁers.
 This requires O(n log D) bits.

Theorem 7 Let D be a collection of D documents over an integer alphabet [1, σ] with total length
n, and let w(S, d) be a function that assigns a numeric weight to string S in document d, that
depends only on the set of starting positions of occurrences of S in d. Then there exists an
O(n(log D + log σ + log log n))-bit data structure that, given a string P and an integer k, reports 
k documents d containing P with highest w(P, d) values, in decreasing order of w(P, d),
in O(p/ logσ n + logε n log σ + k) time, for any constant ε > 0.

In case p < lg1+ε n, we can use a diﬀerent compressed suﬃx array [8], which gives O(p) search

time, and the overall time becomes O(p + k).

23

6.1 A Smaller Structure when using Term Frequencies

In this section we show that the space usage can be further improved if w(P, d) = tf , i.e., when the
data structure must report k documents in which P occurs most frequently.

Our improvement is based on applying the approach of Theorem 7 to each minitree. The nodes
of a minitree are grouped into microtrees; if the structure for a microtree still needs too much space,
we store them in a compact form that will be described below.

Let z′ = σD log m, where m is the number of nodes in a minitree T . Using the same method as in
Theorem 7, we divide the nodes of T into O(m/z′) minifat nodes and O(m/(D log m)) microtrees,
so that each microtree contains O(σz′) nodes. We construct the contracted minitree and the
contracted grid for T as in Theorem 7. Both the contracted minitree and the structure for the
contracted grid use O(m) bits. We can traverse a path in the microtree using the implementation
of the global suﬃx tree described in the previous section, as well as compute local preorders and
depths, and attach satellite information to microtree nodes.

as in the proof of Theorem 7 with regard to ν and ν ′.

For every microtree Tv, we deﬁne the dummy nodes ν and ν ′. Pointers in Tv are transformed
Let m′ denote the number of nodes in a microtree. If log m′ = O(log σ + log D), we implement
the local grid data structure described in Theorem 7 for a microtree. In this case we can store a
data structure for a microgrid in O(log(m′ + D)) = O(log σ + log D) bits per node.

If, instead, log m′ = ω(log σ + log D), since log m′ = O(log(σz′)) = O(log σ + log D + log log m),
it follows that log m′ = O(log log m). Hence, the size of the microtree is m′ = logO(1) m = (log σ +
log D + log log n)O(1) = (log log n)O(1). The total number of pointers in the microtree is also
m′′ = m′ + O(D) = (log log n)O(1) (since log D = o(log m′)). Since all the grids in m′′× m′, with one
point per x-coordinate, and weights in [1, m′′], can be expressed in m′′(log m′ + log m′′) = o(log n)
bits, we can store pre-computed answers for all possible queries on all possible small microtrees.
The only technical diﬃculty is that weights of some pointers in a microtree can be arbitrarily large.
However, as explained below, it is not necessary to know the exact weights of pointers to answer a
query on a small microtree.

All pointers ptr(ul, d) where ul is a leaf node and ul 6= ν ′ have weight 1. The weights of ptr(ν ′, d)
can be arbitrarily large. The weight of a pointer ptr(u, d) for an internal node u equals to the sum
of weights of all pointers ptr(u′, d) for the same document d that lead to u. Thus the weight of
ptr(u, d) can also be large. We note that there is at most one pointer ptr(ν ′, d) for each d. Therefore
the weight of each pointer ptr(u, d) can be expressed as the sum w1(u) + w2(u), where w1(u) is the
weight of ptr(ν ′, d) or 0 and w2(u) ≤ m′. In other words, the weight of ptr(u, d) diﬀers from the
weight of ptr(ν ′, d) by at most m′.
Let N ′ =
{⌊w/m′⌋, ⌊w/m′⌋ + 1| w ∈ N}. To compare the weights of any two pointers it is suﬃcient to
know (i) the tree topology (ii) for every leaf ul, the document d whose suﬃx is stored in ul (iii) for
every ptr(ν ′, d), the pair (rank(⌊w/m′⌋,N ′), w mod m′) where w is the weight of ptr(ν ′, d). There
are o(n/ log n) possible combinations of tree topologies and possible pairs (rank(⌊w/m′⌋,N ′), w
mod m′). Hence, we can store answers to all possible queries for all microtrees in a global look-up
table of size o(n) bits.

Let the set N contain the weights of all pointers ptr(ul, d) and ptr(ν ′, d).

The topology of a microtree can be stored in O(m′) bits. We can specify the index of the
document d stored in a leaf ul with log D bits. We can specify each pair (rank(⌊w/m′⌋,N ′), w
mod m′) with O(log m′) bits. Since D = O(m′/ log m′), information from item (iii) can be stored
in O(m′) bits. Thus each microtree can be stored in O(m′ log D) bits if log m′ = ω(log σ + log D).

24

Summing up, our data for a minitree uses O(m(log σ + log D)) bits. Therefore the total space usage
is O(n(log σ + log D)) bits.

A query for a pattern P is answered by locating the locus u of P . If u is a fat node in T , the
query is answered by a data structure for the contracted grid. If u belongs to a minitree T and u
is a minifat node, we answer the query by employing the data structure for the contracted grid of
T . If u belongs to a microtree Tv, the query is answered either by a microgrid data structure or by
a table look-up.

Theorem 8 Let D be a collection of strings over an integer alphabet [1, σ] with total length n, and
let tf (P, d) denote the number of occurrences of P in d. Then there exists an O(n(log D + log σ))
bit data structure that, given a string P and an integer k, reports k documents d containing P with
highest tf (P, d) values, in decreasing order of tf (P, d), in O(p/ logσ n + logε n log σ + k) time, for
any constant ε > 0.

7 Parameterized Top-k Queries

In this section we improve a recent data structure that supports two-dimensional top-k queries [48,
Sec. 5]. The structure is similar to our wavelet tree W described in the proof of Lemma 4. In
addition, for the points stored at any node of W , it stores an RMQ data structure that gives in
constant time the position of the point with maximum weight within any interval. As explained,
this structure [25] uses O(t) bits if the node of W handles t points, and thus the total space of this
extended wavelet tree W is O(n) words for an O(n) × O(n) grid.
They [48] show how to support top-k queries in a general interval [a, b]×[c, d] by ﬁrst identifying
the O(log n) nodes v ∈ W that cover [c, d], mapping the interval [a, b] to [av, bv] in all those nodes
v, and setting up a priority queue with the maximum-weight point of each such interval. Now, they
repeat k times the following steps: (i) extract the maximum weight from the queue and report it;
(ii) replace the extracted point, say x ∈ [av, bv], by two points corresponding to [av, x − 1] and
[x + 1, bv], prioritized by the maximum weight in those ranges.
Their total time is O((k + log n) log n) if using linear space. The O(log n) extra factor is due to
the need to traverse W in order to ﬁnd out the real weights, so as to compare weights from diﬀerent
nodes. However, those weights can be computed in time O(logε n) and using O(n log n) extra bits
[15, 52, 14]. The operations on the priority queue can be carried out in O(log log n) time [60]. Thus
we have the following result.

Lemma 7 Given a grid of n× n points, there exists a data structure that uses O(n) words of space
and reports k most highly weighted points in a range Q = [a, b]× [c, d] in O((k + log n) logε n) time,
for any constant ε > 0. The structure is built in O(n log n) time.

Note this technique automatically admits being used in online mode (i.e., without knowing k in
advance), since we have not made use of k to speed up the priority queue as in previous sections.
We can easily stop the computation at some k and resume it later.

7.1 Limited Three-Dimensional Queries

In this section we slightly extend the scenario considered above. We assume that each point has
an additional coordinate, denoted z, and that p.z ≤ logα n for a constant α > 0. Top-k points in a

25

three-dimensional range [a, b]× [c, d]× [β, γ] must be reported sorted by their weights. Such queries
will be further called limited three-dimensional top-k queries. We can obtain the same result as in
Lemma 7 for these queries.

Instead of a binary wavelet tree, we use a multiary one [23], with node degree logε n and height
O(log n/ log log n). Now each node v ∈ W has associated a vector Bv so that Bv[i] contains the
index of the child in which the i-th point of v is stored. Using Bv and some auxiliary data structures,
we can obtain the weight of any point at any node in O(logε n) time [52]. All vectors Bv and the
extra data structures use O(n) words.

We regard the t points of each node v as lying in a two-dimensional grid of xand 
z-coordinates.
Instead of one-dimensional RMQs on the x-coordinates [av, bv], we issue two-dimensional RMQs
on [av, bv] × [β, γ]. The wavelet tree of the basic two-dimensional RMQ data structure [48] handles
n×m grids in O(n log m) bits of space and answers RMQs in time O(log2 m). In our case m < logα n
and thus the space is O(n log log n) bits and the query time is O((log log n)2). Thus the space of
the two-dimensional data structures is of the same order of that used for vectors Bv, adding up to
O(n) words. As RMQs are built in linear time, the construction time is O(n log n).

Now we carry out a procedure similar to that of the two-dimensional version. The range [a, b]
is covered by O(log1+ε n/ log log n) nodes. We obtain all their (two-dimensional) range maxima,
insert them in a priority queue, and repeat k times the process of extracting the highest weight
and replacing the extracted point x ∈ [av, bv] by the next highest weighted point in [av, bv] (thus
we are running these range maxima queries in online mode).
The two-dimensional RMQ structures at nodes v cannot store the absolute weights within
overall linear space. Instead, when they obtain the x-coordinate of their local grid, this coordinate
xv is mapped to the global x-coordinate in O(logε n) time, using the same technique as above.
Then the global array of weights is used. Hence these structures ﬁnd a two-dimensional maximum
weight in time O(logε n(log log n)2). This is repeated over O(log1+ε n/ log log n) nodes, and then
iterated k times. The overall time is O((k + log1+ε n/ log log n) logε n(log log n)2), which is of the
form O((k + log n) logε n) by adjusting ε. The times to handle the priority queue are negligible [60].

Lemma 8 Given a grid of n× n× logα n points, for a constant α > 0, there exists a data structure
that uses O(n) words of space and reports k most highly weighted points in a range Q = [a, b] ×
[c, d] × [β, γ] in O((k + log n) logε n) time, for any constant ε > 0. It is built in O(n log n) time.

Again, this result holds verbatim in online mode.

7.2 The Final Result
We divide the grid into horizontal stripes of height r = ⌈logc+1+ε n⌉ for any constant c, much as in
Section 5.5. We store a data structure for limited three-dimensional top-k queries for each slim grid,
taking y as the limited coordinate. A query [a, b]× [0, h]× [τ1, τ2] is processed just as in Section 5.5,
with the only diﬀerence that the queries [a, b] × [τ1, τ2] × [0, y′] to the local grids now require
O(log1+ε n) initialization time and then O(logε n) time per element retrieved, according to Lemma 8.
Then, we initialize our global query Q in time O(⌈h/r⌉ log1+ε n) = O(h/ logc n+log1+ε n), and then
extract each new result in time O(logε n). The time of the priority queue is blurred by adjusting
ε. Hence, the total query time is O(h/ logc n + (k + log n) logε n), and Theorem 6 is proved.

26

8 Conclusions

We have presented an optimal-time and linear-space solution to top-k document retrieval, which
can be used on a wide class of relevance measures and subsumes in an elegant and uniform way
various previous solutions to other ranked retrieval problems. We have also presented dynamic
variants, space-reduced indexes, and structures that solve extensions of the basic problem. The
solutions reduce the problem to ranked retrieval on multidimensional grids, where we also present
improved results, some tailored to this particular application, some of more general interest.

After the publication of the conference version of this article [47], Shah et al. [58] showed how to
achieve the optimal O(k) time once the locus of P is known. This is in contrast to our original result,
where we used time O(p + k) after having spent time O(p) to ﬁnd the locus. Their improvement
allows one to use these techniques in other scenarios where the loucs is obtained in some other way,
without the need to search for it directly using P . They also extend the results to the important
case of the external memory scenario. The new results we obtain in this article about how to search
the suﬃx tree in RAM-optimal time O(p/ logσ n), and how to handle the dynamic scenario, nicely
complement those results and add up to a rather complete solution to the problem.

There are several relevant research directions, on which we comment next.

In our previous conference version we had achieved time O(p + k), which was
RAM optimality.
optimal only in the comparison model (although we used RAM-based techniques). Now we have
improved this result to O(p/ logσ n+k), which is optimal in general in the RAM model (considering
the case lg D = Θ(log n)), because it is the size in words of the input plus the output. Achieving
O(p/ logσ n) time on the suﬃx tree, without any polylogarithmic additive penalty, is an interesting
result by itself, and we have obtained it without altering the topology of the suﬃx tree (which is
crucial for the invariants of Hon et al. [37] to work). However, we do not know if our solution is
optimal when there are very few distinct documents, lg D = o(log n). The question of whether
O(p/ logσ n + k/ logD n) time can be achieved is still open.

Construction time. Without considering the cost to compute weights w(path(u), d) for all pointers 
ptr in the suﬃx tree, the construction time of Hon et al. [37] (which achieves suboptimal query
time) is O(n). The time to build our grid structure is O(n log n), to which we must add O(n logε n)
randomized time to achieve RAM-optimal search time in the suﬃx tree traversal (or O(n polylog n)
deterministic time for a weaker version of it). Is it possible to achieve linear, or at least O(n log n),
deterministic construction time for our data structures?

Dynamic optimality.
In our dynamic variant, the static RAM-optimal search time in the suﬃx
tree becomes O(p(log log n)2/ logσ n + log n). There are schemes that do better for large σ, for
example O(p + (log log σ)2) time [24]. Although they do not support deletions yet, this seems to be
possible. On the other hand, we obtained O(log1+ε n) update time per symbol. A general question
is, which is the best search time we can obtain in the dynamic scenario?

Practical results. Our solutions are not complex to implement and do not make use of impractical 
data structures. A common pitfall to practicality, however, is space usage. Even achieving
linear space (i.e., O(n log n) bits) can be insuﬃcient. We have shown that our structure can use,

27

instead, O(n(log σ + log D)) bits for the tf measure (and slightly more for others), but the constants 
are still large. There is a whole trend of reduced-space representations for general document
retrieval problems with the tf measure [57, 63, 37, 19, 30, 34, 9, 29, 61, 36, 49]. The current
situation is as follows [46]: One trend aims at the least space usage. It has managed to use just
D log(n/D) + O(D) + o(n) bits on top of a compressed suﬃx array of the collection, and the best
time complexity it has achieved is O(p + k log2 k log1+ε n) for any constant ε > 0 [49]. Another
trend adds to the space the so-called document array [45], which uses n lg D + o(n lg D) bits and
enables faster solutions. Currently the fastest one achieves O(p + k(log σ log log n)1+ε) time [34]; a
recent unpublished result [50] obtains time O(p + k log∗ k). This is very close to optimal, but not
yet our O(p/ logσ n + k) time.

In practice, the most compact implementation in this trend [51] reaches about 1–2 times the
text size (including a representation of the text) and retrieves each of the top-k results within
milliseconds. An implementation of the ideas we propose in this article [40] makes use of the fact
that, under very general probabilistic models, the average height of the suﬃx tree (and hence of
our grids) is O(log n) [59]. This enables a simple implementation of our grid-based index that uses
2–3 times the text size and, although its average query time, O(p + (k + log log n) log log n), is not
optimal, it returns each answer within microseconds [40].

In the long term, the most interesting open questions are related to
More complex queries.
extending the one-pattern results to the bag-of-words paradigm of information retrieval. Our model
easily handles single-word searches, and also phrases (which is quite complicated with inverted
indexes [65, 6], particularly if their weights have to be computed). Handling a set of words or
phrases, whose weights within any document d must be combined in some form (for example using
the tf × idf model) is more challenging. We are only aware of some very preliminary results for this
case [16, 30, 35], which suggest that it is unlikely that strong worst-case results can be obtained.
Instead, one can aim at complexities related to the results achieved with inverted lists on the
simpler natural language model. It is interesting to note that our online result allows simulating
the left-to-right traversal, in decreasing weight order, of the virtual list of occurrences of any string
pattern P . Therefore, for a bag-of-word queries, we can emulate any algorithm designed for inverted
indexes which stores those lists in explicit form [53, 4], therefore extending any such technique to
the general model of string documents.

Acknowledgements

We thank Djamal Belazzougui and Roberto Grossi for helpful pointers.

References

[1] N. Alon and M. Naor. Derandomization, witnesses for Boolean matrix multiplication and

construction of perfect hash functions. Algorithmica, 16(4/5):434–449, 1996.

[2] S. Alstrup, T. Husfeldt, and T. Rauhe. Marked ancestor problems. In Proc. 39th IEEE Annual

Symposium on Foundations of Computer Science (FOCS), pages 534–544, 1998.

[3] A. Andersson and M. Thorup. Dynamic ordered sets with exponential search trees. Journal

of the ACM, 54(3):article 13, 2007.

28

[4] V. Anh and A. Moﬀat. Pruned query evaluation using pre-computed impacts. In Proc. 29th
Annual International ACM SIGIR Conference on Research and Development in Information
Retrieval (SIGIR), pages 372–379, 2006.

[5] A. Apostolico. The myriad virtues of subword trees. In Combinatorial Algorithms on Words,

NATO ISI Series, pages 85–96. Springer-Verlag, 1985.

[6] R. Baeza-Yates and B. Ribeiro-Neto. Modern Information Retrieval. Addison-Wesley, 2nd

edition, 2011.

[7] D. Belazzougui, P. Boldi, R. Pagh, and S. Vigna. Fast preﬁx search in little space, with
applications. In Proc. 18th Annual European Symposium on Algorithms (ESA), LNCS 6346,
pages 427–438 (part I), 2010.

[8] D. Belazzougui and G. Navarro. Alphabet-independent compressed text indexing. In Proc.

19th Annual European Symposium on Algorithms (ESA), LNCS 6942, pages 748–759, 2011.

[9] D. Belazzougui, G. Navarro, and D. Valenzuela.

Improved compressed indexes for full-text

document retrieval. Journal of Discrete Algorithms, 18:3–13, 2013.

[10] M. Bender, R. Cole, E. Demaine, M. Farach-Colton, and J. Zito. Two simpliﬁed algorithms for
maintaining order in a list. In Proc. 10th Annual European Symposium on Algorithms (ESA),
LNCS 2461, pages 152–164, 2002.

[11] M. Bender and M. Farach-Colton. The LCA problem revisited. In Proc. 4th Latin American

Theoretical Informatics Symposium (LATIN), LNCS 1776, pages 88–94, 2000.

[12] A. Blumer, J. Blumer, D. Haussler, R. McConnell, and A. Ehrenfeucht. Complete inverted

ﬁles for eﬃcient text retrieval and analysis. Journal of the ACM, 34(3):578–595, 1987.

[13] G. Brodal, R. Fagerberg, M. Greve, and A. L´opez-Ortiz. Online sorted range reporting. In
Proc. 20th International Symposium on Algorithms and Computation (ISAAC), LNCS 5878,
pages 173–182, 2009.

[14] T. Chan, K. G. Larsen, and M. Pˇatra¸scu. Orthogonal range searching on the RAM, revisited.

In Proc. 27th ACM Symposium on Computational Geometry (SoCG), pages 1–10, 2011.

[15] B. Chazelle. A functional approach to data structures and its use in multidimensional searching.

SIAM Journal on Computing, 17(3):427–462, 1988.

[16] H. Cohen and E. Porat. Fast set intersection and two-patterns matching. Theoretical Computer

Science, 411(40-42):3795–3800, 2010.

[17] R. Cole and R. Hariharan. Dynamic lca queries on trees. SIAM Journal of Computing,

34(4):894–923, 2005.

[18] M. Crochemore and W. Rytter. Jewels of Stringology. World Scientiﬁc, 2002.

[19] S. Culpepper, G. Navarro, S. Puglisi, and A. Turpin. Top-k ranked document search in general
text databases. In Proc. 18th Annual European Symposium on Algorithms (ESA), LNCS 6347,
pages 194–205 (part II), 2010.

29

[20] P. Dietz and R. Raman. Persistence, randomization and parallelization: On some combinatorial
In Proc. 3rd Workshop on Algorithms and Data

games and their applications (abstract).
Structures (WADS), LNCS 709, pages 289–301, 1993.

[21] P. Dietz and D. Sleator. Two algorithms for maintaining order in a list. In Proc. 19th Annual

ACM Symposium on Theory of Computing (STOC), pages 365–372, 1987.

[22] M. Farach. Optimal suﬃx tree construction with large alphabets.

In Proc. 38th Annual

Symposium on Foundations of Computer Science (FOCS), pages 137–143, 1997.

[23] P. Ferragina, G. Manzini, V. M¨akinen, and G. Navarro. Compressed representations of sequences 
and full-text indexes. ACM Transactions on Algorithms, 3(2):article 20, 2007.

[24] J. Fischer and P. Gawrychowski. Alphabet-dependent string searching with wexponential

search trees. CoRR, arxiv:1302.3347, 2013.

[25] J. Fischer and V. Heun. Space-eﬃcient preprocessing schemes for range minimum queries on

static arrays. SIAM Journal on Computing, 40(2):465–492, 2011.

[26] R. Fleischer. A simple balanced search tree with O(1) worst-case update time. International

Journal of Foundations of Computer Science, 7(2):137–149, 1996.

[27] M. Fredman, J. Koml´os, and E. Szemer´edi. Storing a sparse table with O(1) worst case access

time. Journal of the ACM, 31:538–544, 1984.

[28] H.N. Gabow, J.L. Bentley, and R.E. Tarjan. Scaling and related techniques for geometry
problems. In Proc. 16th ACM Symposium on Theory of Computing (STOC), pages 135–143,
1984.

[29] T. Gagie, J. K¨arkk¨ainen, G. Navarro, and S.J. Puglisi. Colored range queries and document

retrieval. Theoretical Computer Science, 483:36–50, 2013.

[30] T. Gagie, G. Navarro, and S. J. Puglisi. New algorithms on wavelet trees and applications to

information retrieval. Theoretical Computer Science, 426-427:25–41, 2012.

[31] R. Grossi, A. Gupta, and J. Vitter. High-order entropy-compressed text indexes. In Proc. 14th

Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 841–850, 2003.

[32] D. Gusﬁeld. Algorithms on Strings, Trees and Sequences: Computer Science and Computational 
Biology. Cambridge University Press, 1997.

[33] W.-K. Hon, M. Patil, R. Shah, and S.-Bin Wu. Eﬃcient index for retrieving top-k most

frequent documents. Journal of Discrete Algorithms, 8(4):402–417, 2010.

[34] W.-K. Hon, R. Shah, and S. Thankachan. Towards an optimal space-and-query-time index
In Proc. 23rd Annual Symposium on Combinatorial Pattern

for top-k document retrieval.
Matching (CPM), LNCS 7354, pages 173–184, 2012a.

[35] W.-K. Hon, R. Shah, S. Thankachan, and J. Vitter. String retrieval for multi-pattern queries. In
Proc. 17th International Symposium on String Processing and Information Retrieval (SPIRE),
LNCS 6393, pages 55–66, 2010.

30

[36] W.-K. Hon, R. Shah, S. Thankachan, and J. Vitter. Faster compressed top-k document retrieval.
 In Proc. 23rd Data Compression Conference (DCC), pages 341–350, 2013.

[37] W.-K. Hon, R. Shah, and J. Vitter. Space-eﬃcient framework for top-k string retrieval problems.
 In Proc. 50th IEEE Annual Symposium on Foundations of Computer Science (FOCS),
pages 713–722, 2009.

[38] M. Karpinski and Y. Nekrich. Top-k color queries for document retrieval.

In Proc. 22nd

Symposium on Discrete Algorithms (SODA), pages 401–411, 2011.

[39] D. Knuth. The Art of Computer Programming, volume 3: Sorting and Searching. AddisonWesley,
 1973.

[40] R. Konow and G. Navarro. Faster compact top-k document retrieval.

In Proc. 23rd Data

Compression Conference (DCC), pages 351–360, 2013.

[41] V. M¨akinen and G. Navarro. Rank and select revisited and extended. Theoretical Computer

Science, 387(3):332–347, 2007.

[42] Y. Matias, S. Muthukrishnan, S.C. Sahinalp, and J. Ziv. Augmenting suﬃx trees, with applications.
 In Proc. 6th European Symposium on Algorithms (ESA), LNCS 1461, pages 67–78,
1998.

[43] E. McCreight. A space-economical suﬃx tree construction algorithm. Journal of the ACM,

23(2):262–272, 1976.

[44] I. Munro. Tables.

In Proc. 16th Conference on Foundations of Software Technology and

Theoretical Computer Science (FSTTCS), LNCS 1180, pages 37–42, 1996.

[45] S. Muthukrishnan. Eﬃcient algorithms for document retrieval problems. In Proc 13th Annual

ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 657–666, 2002.

[46] G. Navarro. Spaces, trees and colors: The algorithmic landscape of document retrieval on

sequences. CoRR, arXiv:1304.6023, 2013.

[47] G. Navarro and Y. Nekrich. Top-k document retrieval in optimal time and linear space. In
Proc. 23rd Annual ACM-SIAM Symposium on Discrete Algorithms (SODA), pages 1066–1078,
2012.

[48] G. Navarro, Y. Nekrich, and L. Russo. Space-eﬃcient data-analysis queries on grids. Theoretical

Computer Science, 482:60–72, 2013.

[49] G. Navarro and S. Thankachan. Faster top-k document retrieval in optimal space. In Proc. 20th
International Symposium on String Processing and Information Retrieval (SPIRE), LNCS,
2013. To appear.

[50] G. Navarro and S. Thankachan. Top-k document retrieval in compact space and near-optimal

time. Submitted, 2013.

[51] G. Navarro and D. Valenzuela. Space-eﬃcient top-k document retrieval. In Proc. 11th International 
Symposium on Experimental Algorithms (SEA), LNCS 7276, pages 307–319, 2012.

31

[52] Y. Nekrich. A linear space data structure for orthogonal range reporting and emptiness queries.

International Journal of Computational Geometry and Applications, 19(1):1–15, 2009.

[53] M. Persin, J. Zobel, and R. Sacks-Davis. Filtered document retrieval with frequency-sorted

indexes. Journal of the American Society for Information Sicence, 47(10):749–764, 1996.

[54] L. Russo, G. Navarro, and A. Oliveira. Fully-compressed suﬃx trees. ACM Transactions on

Algorithms, 7(4):article 53, 2011.

[55] M. Ruˇzi´c. Constructing eﬃcient dictionaries in close to sorting time. In Proc. 35th International
Colloquium on Automata, Languages and Programming (ICALP), LNCS 5125, pages 84–95
(part I), 2008.

[56] K. Sadakane. Compressed suﬃx trees with full functionality. Theory of Computing Systems,

41(4):589–607, 2007.

[57] K. Sadakane. Succinct data structures for ﬂexible text retrieval systems. Journal of Discrete

Algorithms, 5(1):12–22, 2007.

[58] R. Shah, C. Sheng, S. V. Thankachan, and J. Vitter. Top-k document retrieval in external
memory. In Proc. 21st Annual European Symposium on Algorithms (ESA), 2013. To appear.

[59] W. Szpankowski. Probabilistic Analysis of Generalized Suﬃx Trees.

In Proc. 3rd Annual

Symposium on Combinatorial Pattern Matching (CPM), LNCS 644, pages 1–14, 1992.

[60] M. Thorup. Integer priority queues with decrease key in constant time and the single source

shortest paths problem. Journal of Computer and System Sciences, 69(3):330–353, 2004.

[61] D. Tsur. Top-k document retrieval

in optimal space.

Information Processing Letters,

113(12):440–443, 2013.

[62] E. Ukkonen. On-line construction of suﬃx trees. Algorithmica, 14(3):249–260, 1995.

[63] N. V¨alim¨aki and V. M¨akinen. Space-eﬃcient algorithms for document retrieval. In Proc. 18th
Annual Symposium on Combinatorial Pattern Matching (CPM), LNCS 4580, pages 205–215,
2007.

[64] P. Weiner. Linear pattern matching algorithm. In Proc. 14th Annual IEEE Symposium on

Switching and Automata Theory, pages 1–11, 1973.

[65] J. Zobel and A. Moﬀat.

Inverted ﬁles for text search engines. ACM Computing Surveys,

38(2):article 6, 2006.

32

