Compact DFA Representation for Fast Regular

Expression Search(cid:1)

Gonzalo Navarro1 and Mathieu Raﬃnot2

1 Dept. of Computer Science, University of Chile

Blanco Encalada 2120, Santiago, Chile

2 Equipe g´enome, cellule et informatique, Universit´e de Versailles

gnavarro@dcc.uchile.cl

45 avenue des Etats-Unis, 78035 Versailles Cedex

raffinot@genetique.uvsq.fr.

Abstract. We present a new technique to encode a deterministic ﬁnite
automaton (DFA). Based on the speciﬁc properties of Glushkov’s nondeterministic 
ﬁnite automaton (NFA) construction algorithm, we are able
to encode the DFA using (m + 1)(2m+1 + |Σ|) bits, where m is the number 
of characters (excluding operator symbols) in the regular expression
and Σ is the alphabet. This compares favorably against the worst case
of (m + 1)2m+1|Σ| bits needed by a classical DFA representation and
m(22m+1 + |Σ|) bits needed by the Wu and Manber approach implemented 
in Agrep.
Our approach is practical and simple to implement, and it permits searching 
regular expressions of moderate size (which include most cases of
interest) faster than with any previously existing algorithm, as we show
experimentally.

1 Introduction and Related Work

The need to search for regular expressions arises in many text-based applications,
such as text retrieval, text editing and computational biology, to name a few.
A regular expression is a generalized pattern composed of (i) basic strings, (ii)
union, concatenation and Kleene closure of other regular expressions. Readers
unfamiliar with the concept and terminology related to regular expressions are
referred to a classical book such as [1]. We call RE our regular expression, which
is of length m. This means that m is the total number of characters in RE, not
counting operators symbols “|”, “*” and parentheses. We note L(RE) the set of
words generated by RE and Σ the alphabet.

The traditional technique [10] to search a regular expression of length m in
a text of length n is to convert the expression into a nondeterministic ﬁnite
automaton (NFA) with O(m) nodes. Then, it is possible to search the text using
the automaton at O(mn) worst case time. The cost comes from the fact that

(cid:2) Partially supported by ECOS-Sud project C99E04 and, for the ﬁrst author, Fondecyt

grant 1-990627.

G. Brodal et al. (Eds.): WAE 2001, LNCS 2141, pp. 1–13, 2001.
c(cid:1) Springer-Verlag Berlin Heidelberg 2001

2

Gonzalo Navarro and Mathieu Raﬃnot

more than one state of the NFA may be active at each step, and therefore all
may need to be updated. A more eﬃcient choice [1] is to convert the NFA into a
deterministic ﬁnite automaton (DFA), which has only one active state at a time
and therefore allows searching the text at O(n) cost, which is worst-case optimal.
The problem with this approach is that the DFA may have O(2m) states, which
implies a preprocessing cost and extra space exponential in m.

Some techniques have been proposed to obtain a good tradeoﬀ between both
extremes. In 1992, Myers [7] presented a four-russians approach which obtains
O(mn/ log n) worst-case time and extra space. The idea is to divide the syntax
tree of the regular expression into “modules”, which are subtrees of a reasonable
size. These subtrees are implemented as DFAs and are thereafter considered as
leaf nodes in the syntax tree. The process continues with this reduced tree until
a single ﬁnal module is obtained.

The DFA simulation of modules is done using bit-parallelism, which is a
technique to code many elements in the bits of a single computer word (which
is called a “bit mask”) and manage to update all them in a single operation.
Typical bit operations are inﬁx “|” (bitwise or), inﬁx “&” (bitwise and), preﬁx
“∼” (bit complementation), and inﬁx “<<” (“>>”), which moves the bits of
the ﬁrst argument (a bit mask) to higher (lower) positions in an amount given
by the right argument. Additionally, one can treat the bit masks as numbers and
obtain speciﬁc eﬀects using the arithmetic operations +, −, etc. Exponentiation
is used to denote bit repetition, e.g. 031 = 0001.

In our case, the vector of active and inactive states is stored as bits of a
computer word. Instead of (ala Thompson [10]) examining the active states one
by one, the whole computer word is used to index a table which, together with
the current text character, provides the new bit mask of active states. This can be
considered either as a bit-parallel simulation of an NFA, or as an implementation
of a DFA (where the identiﬁer of each deterministic state is the bit mask as a
whole).

Pushing even more on this direction, one may resort to pure bit-parallelism
and forget about the modules. This was done in [13] by Wu and Manber, and
included in their software Agrep [12]. A computer word is used to represent the
active (1) and inactive (0) states of the NFA. If the states are properly arranged
and the Thompson construction [10] is used, then all the arrows carry 1’s from
bit positions i to i + 1, except for the ε-transitions. Then, a generalization of
Shift-Or [2] (the canonical bit-parallel algorithm for exact string matching) is
presented, where for each text character two steps are performed. First, a forward
step moves all the 1’s that can move from a state to the next one. This is achieved
by precomputing a table B : Σ → 2O(m), such that the i-th bit of B[c] is set if
and only if the character c matches at the i-th position of the regular expression.
Second, the ε-transitions are carried out. As ε-transitions follow arbitrary paths,
a table E : 2O(m) → 2O(m) is precomputed, where E[D] is the ε-closure of D.
To move from the state set D to the new D(cid:2) after reading text character c, the
action is

D(cid:2) ← E[(D << 1) | B[c]].

