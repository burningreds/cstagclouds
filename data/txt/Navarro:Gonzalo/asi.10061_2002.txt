XQL and Proximal Nodes

Ricardo Baeza-Yates and Gonzalo Navarro
Depto. de Ciencias de la Computacio´ n, Universidad de Chile, Blanco Encalada 2120, Santiago 6511224,
Chile. E-mail: {rbaeza,gnavarro}@dcc.uchile.cl

Despite the fact that several models to structure text
documents and to query on this structure have been
proposed in the past, a standard has emerged only relatively 
recently with the introduction of XML and its
proposed query language XQL, on which we focus in this
article. Although there exist some implementations of
XQL, efﬁciency of the query engine is still a problem. We
show in this article that an already existing model, Proximal 
Nodes, which was deﬁned with the goal of efﬁciency 
in mind, can be used as an efﬁcient query engine
behind an XQL front-end.

Introduction

Searching on structured text is becoming more important
with the increasing use of XML (Goldfar & Prescod, 1998).
Although SGML (International Standards Organization,
1986) existed for a long time, its complexity was the main
limitation for a wider use. By taking advantage of the
structure, content queries can be made more precise. This
issue is becoming more and more important, because as the
availability of textual data increases, structure and metadata
can help in coping with volume explosion. Also, XML data
can be seen as the meeting point between the database
community (in particular the work on semistructured data
and query languages for XML) and the information retrieval
community (structured text models).

Several models have been proposed since the eighties to
structure text documents and to query on this structure as
well as on content (see, e.g., the survey in Baeza-Yates &
Navarro, 1966). The importance of the area has grown
rapidly with the adoption of XML as a standard to structure
text. After the widespread acceptance of XML, most of the
research on structured text has not concentrated anymore on
proposing new structuring models but on designing suitable
query languages that work on XML-structured text. There is
not yet a standard for querying XML. Rather, there were a
number of proposals when this work was done (1999).
Among those we concentrate on XQL (Lapp, Robie, &
Schac, 1998) which was one of the strongest candidates to

© 2002 Wiley Periodicals, Inc. ● Published online 22 February 2002 in Wiley
InterScience (www.interscience.wiley.com). DOI: 10.1002/asi.10061

become the standard, and has inﬂuenced the current uniﬁed
proposal, Xquery (WWW Consortium, 2001). At the end of
1999, also appeared Xpath (WWW Consortium, 1999), the
query language for XML paths, which is inspired in XQL,
and hence many of our results are also valid for Xpath.

Many of the models proposed to structure and query text
documents had the goal of efﬁciency in mind. As a result,
several studies on the tradeoff between query language
expressiveness and the efﬁciency of its implementation
were carried out (Baeza-Yates & Navarro, 1966; Consens &
Milo, 1995). On the other hand, to the best of our knowledge 
there are no efﬁcient implementations of XQL, in the
sense that the structure is not fully indexed.

In 1995, we designed one of those structured text models,
 called Proximal Nodes (PN), with this tradeoff in mind
(Navarro & Baeza-Yates, 1995b, 1997). PN occupied a
place in the expressiveness/efﬁciency graph, where there
existed other more expressive and less efﬁcient models as
well as more efﬁcient and less expressive models.

Our goal in this article is to show that PN ﬁts very well
in the XML/XQL scheme. Its structuring model matches
quite well with XML (indeed, it is a little more powerful),
and its query model is just expressive enough to represent
the operations required by XQL. Other structured text models 
proposed are either less efﬁcient than what is possible or
less expressive than what is necessary to support XQL.

This makes the PN model an excellent alternative to
implement XQL. We envision a system that gives access to
a XML document database and uses XQL (or another XML
query language) as its front-end query language. Queries in
XQL are translated into the syntax of the PN model. On the
other hand, the XML database is indexed as required by the
PN model implementation. Hence, the back end of the
engine executes the query inside the PN model and delivers
the result back to the front-end, which in turn represents the
result in XML format to the end user (see Fig. 1).

This article is organized as follows. The next section
brieﬂy introduces the reader to XML and its query languages,
 as well as to the existing structured text models. The
XQL Query Language section presents the XQL query
language. Then the PN model is presented in some depth.

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY, 53(6):504 –514, 2002

guages for XML included XQL (Lapp et al., 1998), XMLQL 
(Florescu, Deutsch, Levy, Suciu, & Fernandez, 1999),
XGL (Clarke, Cormack, & Burkowski, 1995), Lorel (Widom,
 1999), Ozone (Lahiri, Abiteboul, & Widom, 1999),
Quilt (Chamberlin, Robie, & Quilt, 2000), and Squeal
(Spertus & Stein, 2000). Based on many of these languages,
the WWW Consortium has recently presented Xquery
(WWW Consortium, 2001), the proposed standard for XML
query language. Another recently important issue is the
integration of these languages with information retrieval
approaches [e.g., see (Florescu, Manolescu, & Kossmann,
2000; Schlieder & Meuss, 2002; Widom, 1999)]. There are
query languages for XML that are more powerful than
XQL, as well as for the Web as a database. A complete
comparison of these languages is presented in this issue
(Luk, Leong, Dillon, Chan, Croft, & Allan, 2002).

Few implementations for XQL have been offered, partly
because of the rise of newer XML query language proposals.
 Among these we can mention the inclusion of XQL in
Software AG’s Tamino, the GMD-IPSI’s engine, and a
subset included in Microsoft Explorer 5.0 browser (Robie,
2001). There is almost no documentation about the internals
of these implementations, but the available ones imply that
the XML structure is not fully indexed and sequential search
is used in most cases.

Before XML appeared, several models to query structured 
text were proposed. They were designed with efﬁciency 
as one of their goals. These approaches are characterized 
by generally imposing a hierarchical structure on the
database, and by mixing queries on content and structure.
Although this structuring is simpler than, for example, hypertext;
 even in this simpler case the problem of mixing
content and structure is not satisfactorily solved. A survey
on this topic can be found in Baeza-Yates and Navarro
(1966).

Some of the most prominent examples of these models
follow, together with the reasons that make them unsuitable
as a back-end for XQL. The Hybrid Model proposed in
Baeza-Yates and Navarro (1966) is one of the oldest, and
does not permit nesting in the structural components, so
hierarchies cannot be expressed. Moreover, the structure is
ﬁxed, which is too poor for XML. PAT Expressions (Salminen 
& Tompa, 1992) permit the dynamic deﬁnition of
different structural components in the text, but these, as well
as intermediate results, must be disjoint text areas, so one
cannot make the union of chapters and sections. Overlapped
lists (Clarke, Cormack, & Burkowski, 1995) permit overlapping 
but still not nesting. Lists of References (MacLeod,
1999) permits nesting, but only the top level elements are
returned as the result of a query (so the union of chapters
and sections returns just the chapters). Sgrep and other
similar models (Dao, Sacks-Davis, & Thom, 1996; Jaakkola
& Kilpela¨inen, 1996) permit nesting and overlapping in the
results, but they restrict the query operations to the simplest
containment and proximity ones, which is insufﬁcient for
XQL. In particular, they do not permit querying on positional 
inclusion and direct ancestorship (see later). Parsed

FIG. 1. A XML/XQL system backed by the PN model.

The Implementing XQL Operations section shows how
XQL can be implemented using the PN model. We conclude
with some work in progress.

XML, XQL, and Other Structured Text Models

XML stands for eXtensible Markup Language (Goldfar
& Prescod, 1998), and is a simpliﬁed subset of SGML
(International Standards Organization, 1986), a metalanguage 
for tagging structured text. That is, XML is not a
markup language, as HTML is, but a metalanguage that is
capable of containing markup languages in the same way as
SGML. XML allows having human-readable semantic
markup, which is also machine readable. As a result, XML
makes it easier to develop and deploy new speciﬁc markup,
enabling automatic authoring, parsing, and processing of
networked data.

XML does not have many of the restrictions imposed by
HTML and, on the other hand, imposes a more rigid syntax
on the markup, which becomes important at processing
time. In XML, ending tags cannot be omitted. Also, tags for
elements that do not have any content, like “BR” and
“IMG,” are specially marked by a slash before the closing
angle bracket. XML also distinguishes upper and lower
case, so “img” and “IMG” are different tags (unlike in
HTML). In addition, all attribute values must appear between 
quotes. That
implies that parsing XML without
knowledge of the tags is easier. In particular, using a DTD
(data deﬁnition table, as used in SGML) is optional. If there
is no DTD, the tags are obtained while the parsing is done.
With respect to SGML, there are a few syntactic differences,
 and many more restrictions.

In 1998, the WWW Consortium requested proposals for
a standard query language for XML. Proposed query lanJOURNAL 
OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

505

FIG. 2. Example of an XML formatted document.

Strings (Gonnet & Tompa, 1987) has different goals, being
a data manipulation language rather than a query language.
Tree Matching (Kipela¨inen & Manilla, 1993) offers powerful 
structural matching operators but it is weak at relating
text content and structure. Due to its power on structural
queries, which is unnecessarily powerful for XQL, the implementation 
of this model is very inefﬁcient. Newer developments 
on this model (Meuss & Schulz, 2001) obtained
polynomial time solutions but they do not seem practical
enough for large document databases. Recent work has
focused on ﬁltering techniques (Meuss & Strohmaier, 1999)
and other extensions.

The XQL Query Language

We brieﬂy describe in this section the capabilities of
XQL. We do not intend to give a complete overview of
XQL (see the original references, Lapp et al., 1998, for this
sake). Rather, we aim at showing the type of queries that
XQL permits through a running example, which is given in
Figure 2. The example is an extract of a book with a
structure of chapters, and sections, where sections can contain 
other sections and all have titles. We also permit
constructions such as ﬁgures and lists. Different constructions 
have different attributes. We assume that the reader is

506

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

familiar enough with XML so as to understand the example
without further explanation.

Path Expressions

The main type of expression in XQL is the so called
“path expression,” for example, “chapter/section/
title,” which retrieves all the titles that descend directly
from sections that descend directly from chapters (i.e., titles
of top level sections). In our example this query would
return

具title典Motivation具/title典
具title典Basic Concepts具/title典
具title典How to Use this Book具/title典

Transitive inclusion is expressed using a double bar “//,”
for example, “chapter//section/title” returns titles 
of sections that descend from a chapter. In our example
this returns

具title典Motivation具/title典

具title典Information versus Data
Retrieval具/title典
具title典Information Retrieval at the
Center of the Stage具/title典
具title典Basic Concepts具/title典
具title典How to Use this Book具title典

具title典Teaching Suggestions具/title典

This mechanism is extended to permit “absolute paths,”
i.e., paths that are evaluated from the root of the structure
tree, for example, “/book/title” corresponds to the
unique element

具title典Modern Information Retrieval
具/title典

XQL also permits the use of the wild card where a
structural name is expected, for example, “book/ⴱ/ti-
tle” to mean titles directly descending from something
that descends directly from a book constructor. The answer
is the only chapter title in the example
具title典Introduction具/title典
Finally, XQL permits queries of the type “section/
section[2],” meaning the second (sub)section contained 
in a section, as well as ranges such as chapter/
section[2–3]. The ﬁrst example would return

具section number⫽“1.1.2”典

具title典Basic Concepts具/title典
The effective retrieval of relevant
formation is directly affected . ..

in

具title典Information Retrieval at the
Center of the Stage具/title典
In the past 20 years, the area of

mation retrieval has grown .. .

infor
具/section典
具section number⫽“1.2”典

具ﬁgure number⫽“1.1” ﬁle⫽“ir-system.
eps”
caption⫽“Interaction of the user with
the retrieval system . . .”/典
具/section典

Filters

It is also possible to express that one wants the top level
instead of the bottom level nodes. This is done by using ﬁlters
“[ ],” for example, “chapter[section/ﬁgure],”
which selects chapters that contain a ﬁgure contained in a
section. This returns the whole chapter in our example,
because it contains a section that directly contains a ﬁgure.
To obtain chapters that directly contain a section that
directly contains a ﬁgure, one would write “chapter
[/section/ﬁgure],” which in our case would retrieve
the same result as before because the section containing the
ﬁgure is 1.2, a top level one.

Similarly, one can express “book[author[0] ⫽
‘R. Baeza-Yates’],” where the condition is that the
ﬁrst “author” element
that descends from the book
equals the string “R. Baeza-Yates.” The query would
return the whole book.

One can combine path expressions with ﬁlters, for example,
 “book[author ⫽ ‘B. Ribeiro-Neto’]/
ﬁgure” would return all the ﬁgures of books written by B.
Ribeiro-Neto, in our example
具ﬁgure number⫽“1.1” ﬁle⫽“ir-system.eps”
caption⫽“Interaction of the user with
the

retrieval system”/典

XQL permits boolean operations inside the ﬁlters. For
example, “chapter[ﬁgure or title ⫽ ‘Intro-
duction’]” returns chapters that either contain a ﬁgure
or have inside a title that reads “Introduction.” Similarly,
 we could ask for chapters that meet both conditions
using “chapter[ﬁgure and title ⫽ Introduc-
tion].” Finally, “chapter[not ﬁgure]” retrieves
chapters without ﬁgures.

An XQL extension permits to say “any” or “all”
inside the condition. The ﬁrst does not alter the usual
semantics, for example, both “chapter[ﬁgure]” and
“chapter[any ﬁgure]” retrieve chapters that contain
(any) ﬁgures. The second construction, “all,” makes
sense for predicates of equality or inequality and requires it
to hold for all the relevant constructors inside the element.
For example, “book[all author !⫽ ‘A. Mof-
fat’]” requires that no author ﬁeld inside the book be
equal to “A. Moffat.”

Other Features

Attributes. Another widely used feature of XQL are the
attributes of the nodes. Each structural node in XML can
have a number of attributes, which have a name and a value;
and it is possible to restrict the matches to those having

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

507

some attribute and even to those where some attribute has
some property. Contrary to a subﬁeld, an attribute cannot
have any internal structure.

For example “book[@publisher ⫽ ‘Addison-
Wesley’]” selects the books whose attribute “publish-
er” is “Addison-Wesley,” while “book[@isbn]”
selects books where there is an “isbn” ﬁeld. It is possible
to use all the boolean operators and other ﬁlters on attribute
values.

Semijoins. XQL permits comparing the content of absolute
paths. For example “book[@author ⫽ @me]”, where
“@me” is an attribute that descends directly from the root of
the hierarchy.

This can be done only for absolute paths, so that the
reference can have just one value across the whole collection.


Methods. XQL is designed to be embedded in Perl, and as
such it imports many of the Perl’s functions. Some of the
functions of interest are: text(), which corresponds to
the textual content of a node; value(), which is similar
to text() except that it can be cast to other types such as
integer or ﬂoat; and other aggregate functions such as the
number of structural components below a given node.

Set operations. XQL permits set operations such as union,
intersection, and difference. For example ﬁgure union
list returns all the ﬁgures and lists in the books.

Proximity operations. Despite the fact that the standard
XQL does not permit it, some implementations allow a kind
of “followed by” operation, for example, return sections
followed by a ﬁgure. Unfortunately, their description is not
very clear.

The Proximal Nodes Model

The Proximal Nodes Model (PN) (Navarro, 1995; Navarro 
& Baeza-Yates, 1995a, 1995b) presents a good compromise 
between expressiveness and efﬁciency. It does not
deﬁne a speciﬁc language, but a model in which it is shown
that a number of useful operators can be included, while
achieving good efﬁciency. Many independent structures can
be deﬁned on the same text, each one being a strict hierarchy,
 but allowing overlaps between areas delimited by different 
hierarchies (e.g., chapters/sections/paragraphs and
pages/lines). A query can relate different hierarchies, but
returns a subset of the nodes of one of them only (i.e., nested
elements are allowed in the answers, but not overlaps). Each
node has an associated segment, which is the area of the text
it comprises. The segment of a node includes that of its
descendants. Text matching queries are modeled as returning 
nodes from a special “text hierarchy.”

The model speciﬁes a fully compositional language with
three types of operators: (1) text pattern-matching; (2) to
retrieve structural components by name (e.g., all chapters);
and (3) to combine other results. The main idea behind the
efﬁcient evaluation of these operations is a bottom-up approach,
 by ﬁrst searching the queries on contents and then
going up the structural part. Two indices are used, for text
and for structure, meant to efﬁciently solve queries of type
1 and 2 without traversing the whole database. To make
operations of type 3 efﬁcient, only operations that relate
“nearby” nodes are allowed. Nearby nodes are those whose
segments are more or less proximal. This way, the answer is
built by traversing both operands in synchronization, leading 
in most cases to a constant amortized cost per processed
element.

As we show next, many useful operators ﬁt into this
model. There is a separate text matching sublanguage,
which is independent of the model. In Navarro and BaezaYates 
(1995a, 1995b), the expressiveness of this model is
compared against others and found competitive or superior
to most of them. This model can be efﬁciently implemented,
needing linear time for most operations and in all practical
cases (this is supported by analysis and experimental re-
sults). The time to solve a query is proportional to the sum
of the sizes of the intermediate results (and not the size of
the database).

Two different implementations of the model are proposed.
 A full evaluation version solves the query syntax tree
recursively, that is, both operands of the root are (recursive-
ly) solved completely and then the root operator is applied
to both arguments, which are by this time fully evaluated. A
lazy evaluation version regards the query syntax tree as an
entity that survives across the whole evaluation, to which
one requests results one by one. Upon receiving a request,
any node of this syntax tree requests, in turn, results from its
operand subtrees until it has enough information to deliver
one result. In our experiments the lazy version worked
better for more complicated queries and worse for simpler
queries.

The Proximal Nodes model permits any operation in
which the fact that a node belongs or not to the ﬁnal result
can be determined by the identity and text position of itself
and of nodes (in the operands) which are “proximal” to it, as
explained.

Figure 3 shows the scheme of a possible set of operations.
 There are basic extraction operators (forming the
basis of querying on structure and on contents), and operators 
to combine results from others, which are classiﬁed in
a number of groups:
those that operate by considering
included elements, including elements, nearby elements, by
manipulating sets, and by direct structural relationships.

We explain in some detail those that are relevant for the
case of a single hierarchy, which includes the XML model.

1. Matching sublanguage: is the only one that accesses 
the text content of the database, and is orthogonal
to the rest of the language.

508

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

FIG. 3. Possible operations for our model, classiﬁed by type. We have removed those that are relevant when several hierarchies exist, which is not the
case in XML.

(a) Matches: the matching language generates a set of
disjoint segments, which are introduced in the model as
belonging to a special “text hierarchy.” All the text
answers generate ﬂat lists. For example, “informa-
tion” generates the ﬂat set of all segments of 11 letters
where that word appears in the text. Note that the matching 
language could allow much more complex expressions 
(e.g., regular expressions).
(b) Operations on matches: are applicable only
to subsets of the text hierarchy, and make transformations 
to the segments. We see this point and the previous
one as the mechanism for generating match queries, and
we do not restrict our language to any sublanguage for
this. As an example, M collapse M⬘ superimposes both
sets of matches, merging them when an overlap results;
and M subtract M⬘ removes from the ﬁrst set the text
positions belonging to the second set, shortening, removing,
 and cutting segments as required.

2. Basic structure operators: are the other kind
of leaves of the query syntax tree, which refer to basic
structural components.
(a) Name of structural component: (“Con-
structor” queries). Is the set of all nodes of the given
type. For example, chapter retrieves all the chapters in
a book.
(b) Name of hierarchy: (“All” queries). Is the set
of all nodes of the hierarchy. The same effect can be
obtained by summing up (“⫹” operator) all the node
types of the hierarchy.

3. Included-In operators: select elements from
the ﬁrst operand, which are included in one of the second.

(a) Free inclusion: select any included element.
“P in Q” is the set of nodes of P, which are included in

a node of Q. For example, ﬁgure in section selects
all ﬁgures inside sections.
(b) Positional inclusion: select only those elements 
included at a given position. To deﬁne position,
only the top-level included elements for each including
node are considered. “[s] P in Q” is the same as in, but
only qualifying the nodes that descend from a Q-node in
a position (from left
to right) considered in s. The
language for expressing positions (i.e., values for s) is
also independent. We consider that ﬁnite unions of
i . . . j, last ⫺i . . . last ⫺ j, and i . . . last ⫺ j would
sufﬁce for most purposes. The range of possible values if
1 . . . last. For example, [3. . .5] section in section 
retrieves the 3rd, 4th, and 5th sections from all
sections. If sections include other sections, only the
top-level ones are considered.

4. Including operators: select from the ﬁrst operand 
the elements including elements from the second
one. “P with (k) Q” is the set of nodes of P that include
at least k nodes of Q. If (k) is not present, we assume 1.
For example, section with (5) “information”
selects the sections in which the word “information”
appears ﬁve or more times.

5. Direct structure operators: select elements
from the ﬁrst operand based on direct structural criteria,
i.e., by direct parentship in the structure tree corresponding 
to the hierarchy.
(a) “[s] P child Q” is the set of nodes of P which are
children (in the hierarchy) of some node of Q, at a
position considered in s (that is, the s-th children). If [s]
is not present, we assume 1 . . . last. For example, title 
child chapter retrieves the titles of all chapters
(and not titles of sections inside chapters).
(b) “P parent (k) Q” is the set of nodes of P that are

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

509

parents (in the hierarchy) of at least k nodes of Q. If (k)
is not present, we assume 1. For example, chapter
parent (3) section selects chapters with three or more
top-level sections.

6. Distance operators: select from the ﬁrst operand
elements that are at a given distance of some element of
the second operand, under certain additional conditions.
(a) “P after/before Q (C)” is the set of nodes of P
whose segments begin/end after/before the end/beginning 
of a segment in Q. If there is more than one
P-candidate for a node of Q, the nearest one to the
Q-node is considered (if they are at the same distance,
then one of them includes the other and we select the
including one). For a P-node to be considered a candidate 
for a Q-node, the minimal node of C containing
them must be the same, or must not exist in both cases.
For example, list after ﬁgure (chapter) retrieves 
the nearest lists following ﬁgures, inside the same
chapter.
(b) “P after/before (k) Q (C)” is the set of all nodes of
P whose segments begin/end after/before the end/beginning 
of a segment in Q, at a distance of at most k text
symbols (not only nearest ones). C plays the same role as
above. For example, “information” before (10)
“retrieval” (section) selects the words “infor-
mation” that are followed by “retrieval” at a distance of
at most 10 symbols, inside the same section.

7. Set manipulation operators: manipulate both
operands as sets, implementing union, difference, and
intersection under different criteria.
(a) “P ⫹ Q” is the union of P and Q. For example,
ﬁgure ⫹ list is the set of all ﬁgures and lists. To
make a union on text segments, use collapse.
(b) “P ⫺ Q” is the set difference of P and Q. For
example, chapter ⫺ (chapter with ﬁgure) are
the chapters with no ﬁgures. To subtract text segments,
we resort to operations on matches. (c) “P is Q” is the
intersection of P and Q. For example, ([1] section
in chapter) is ([3] section in book) selects the
sections that are ﬁrst (top-level) sections of a chapter and
at the same time third (top-level) section of the book. To
intersect text segments use same. (d) “P same Q” is the
set of nodes of P whose segments are the same segment
of a node in Q. For example, title same “Intro-
duction” gets the titles that say (exactly) “Introduc-
tion”.

Except for set manipulation ones, the model also permits
the negated version of all the operators. For example, P not
with Q is the same as P ⫺ (P with Q), although the
evaluation is more efﬁcient.

Clearly, inclusion can be determined by the text area
covered by a node, and the fact that an element in A
qualiﬁes or not depends only on elements of B that include
it or are included in it. Direct ancestorship can be determined 
by the identity of the nodes and appropriate information 
on the hierarchical relations between nodes. Note
that just the information on text areas covered is not enough
to discern between direct and general inclusion. Distance
operations can be carried out by just considering the areas
covered and by examining nearby elements of the three

operands. Finally, set manipulations needs nothing more
than the identity of the nodes and depend on nearby nodes
of the other operands.

The Proximal Nodes model proposes an implementation
where an index is built on the structure of the text separated
from the normal index for the text content. The structural
index is basically the hierarchy tree with pointers to know
the parent, ﬁrst child, and next sibling of each node. In
addition, implicit lists for each different structural element
are maintained, so that one can traverse the complete tree or
the subtree of all the nodes of a given type.

At query time, each node of the query syntax tree is
converted into an intermediate result from the leaves to the
root (other evaluation orders are considered but here we
explain this one for clarity). The intermediate results are
trees that are subsets of the whole hierarchy. Leaves that are
structural elements are solved by using the structure index
directly; those that correspond to pure queries on the text
content are solved with the classical index on content (e.g.,
an inverted ﬁle) and translated into a list of text segments
that match the query. This list is a particular case of a tree
of answers.

Finally, internal query nodes correspond to operations
that are carried out once their operands have been solved
and converted into trees of nodes. As deﬁned by the model,
all the allowed operations can be solved by a synchronized
linear traversal over the operands, so that the total time to
solve a query is proportional to the total size of the intermediate 
results.

Implementing XQL Operations using Proximal
Nodes

We show in this section how the XQL query language
can be implemented using the PN model. We start by
considering the XML structure and then pay attention to
each XQL feature in turn. In passing, we show more in
detail why other models are not suitable for implementing
XQL.

Interpreting the XML Structure

The ﬁrst problem when mapping XQL over the PN query
language is whether the two structuring models are the
same. First, PN permits several hierarchies and XML just
one, so we will not use the extended PN features. Second,
XML permits arbitrary hyperlinks to other parts of the
structure, i.e., deﬁning reference points and later referencing
them, so that the referenced node is assumed to be duplicated 
at the referencing point. This permits XML building
an arbitrary graph, when loops, and hence inﬁnite paths,
may exist. The PN model does not permit expressing this
kind of structure, so we assume that references are either
disregarded or physically duplicated when they do not form
cycles.

Both solutions imply that PN is insufﬁcient to express
XML references. On the other hand, the only query models

510

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

able to deal with this kind of structure are graph query
languages such as Hy⫹ (Consens & Mendelzon, 1993),
which are not efﬁcient enough to handle large text databases.
 We strongly believe that no efﬁcient XML query
language can incorporate this feature.

The ﬁnal feature where XML and the PN model differ is
in the attributes. PN does not permit attributes to be attached
to structural nodes. A lot of attention is given to attributes in
the XML/XQL literature.

Let us consider again Figure 2. We have, for example,
the fact that the book has some attributes such as “pub-
lisher” and “isbn,” as well as some unique ﬁelds
such as “title.” Should the publisher be an attribute or
a unique ﬁeld? Let us consider the sections, which have an
attribute “number” and a unique ﬁeld “title.” Could
the number be a ﬁeld? The answer is that choosing that a
given piece of information is an attribute or a ﬁeld is a
matter of design decision, except that attributes must (1) be
unique and (2) have no internal structure. Therefore, any
attribute can be converted into a ﬁeld. An alternative for the
ﬁrst lines of the example of Figure 2 is

具book典

具publisher典Addison-Wesley具/publisher典
具isbn典0-201-39829-X具/isbn典
具author典R. Baeza-Yates具/author典
具author典B. Ribeiro-Beto具/author典
具title典Modern
具/title典
具chapter number⫽“1”典

Information

Retrieval

Hence, the indexer that reads the XML data and builds
the index needed for PN will treat attributes just as ﬁelds, as
any other descendant of the node. In this sense the PN
model is indeed more general than XQL because it does not
need to make such distinctions. The tags are used for
discovering the structure of the text, but these words are not
indexed as part of the content of the documents.

Figure 4 shows the hierarchical representation of the PN
index for our example of Figure 2. As can be seen, all the
text regions are included in the hierarchy, and the tags are
used to delimit the extent of the structural nodes. Observe
also how attributes and ﬁelds are treated the same way.

Path Expressions

At a ﬁrst sight, the XQL query language looks rather
different from the presented query language. Typical XQL
expressions are of the form

chapter/section/title

where the “/” represents direct inclusion. However, the
above expression is translated directly into a Proximal
Nodes query

title child section child chapter

that is, the lowest level elements are selected. Despite the
fact that it looks as a navigational operation (i.e., enter into
chapters, then move to sections, then to titles), we can
regard it as a search operation for nodes of a certain type
and certain ancestors.

The “/” operation is the most basic one in XQL, and it
immediately outrules many alternative models to query
structured text based on positional information only, because 
they cannot query by direct ancestorship. Transitive
inclusion can also be expressed using a double bar “//”, and
it can be translated into the in operation in Proximal Nodes.
The most navigational-looking feature of XQL is its
ability to express absolute paths, i.e., paths that are evaluated 
from the root of the structure tree. This can be simulated 
by adding an extra single root R node to the hierarchy
and adding “child R” to those queries.

The use of wild cards for structural names is permitted in
XQL, so one can write “book/ⴱ/title” to mean titles
directly descending from something that descends directly
from a book. The wild card can be replaced by the Proximal
Nodes feature that permits using “All” as a node name,
whose result is the whole hierarchy.

XQL permits queries of the type X/Y[k], meaning the
k-th Y contained in each X. This corresponds exactly to the
positional inclusion feature of Proximal Nodes, which cannot 
be found in any other existing model. In both models
this can be extended to arbitrary ranges of values, and to
indices relative to the ﬁrst or to the last included element.

Filters

It is also possible to express that one wants the top-level
instead of the bottom-level nodes. This is done by using
ﬁlters “[ ]”, for example,

chapter[section/ﬁgure]

which selects chapters that contain a ﬁgure contained in a
section. This is easily translated into

chapter with (ﬁgure child section)

Similarly, one can express “book[author[0] ⫽
‘R. Baeza-Yates’],” where the condition is on the
ﬁrst “author” element that descends from the book. This can
be translated into positional inclusion as

([1] author in book) same “R. Baeza-Yates”

XQL permits boolean operations inside the ﬁlters, and
this requires more care. First, “X[Y or Z]” (which selects
the X elements that contain some Y or some Z element) can
be converted into X[Y ⫹ Z]. On the other hand, “X[Y and

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

511

FIG. 4. Structural representation of our example, as it is stored by the PN index.

Z]” requires that X contains both some Y and some Z,
which can be converted into (X[Y])[Z]. Finally X[not Y],
which selects the X elements containing no Y element, can
be rewritten as X ⫺ X[Y], although Proximal Nodes permits 
the negated variants of the containment operations
(e.g., not with), and this has a more efﬁcient implementation.


An XQL extension permits to say any or all inside the
condition. While any maintains the normal semantics, all
requires extra care. For example, “book[all author
!⫽ ‘A. Moffat’]” requires that no author ﬁeld inside
the book be equal to “A. Moffat.” This cannot be
directly expressed in Proximal Nodes but it can be converted 
using double negation: X[all Y] ⫽ X ⫺ X[not Y].

512

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

Attributes

Methods

Another widely used feature of XQL are the attributes of
the nodes. This seems to deviate signiﬁcantly from simplifying 
models. Each structural node can have a number of
attributes, which have a name and a value; and it is possible
to restrict the matches to those having some attribute and
even to those where some attribute has some property. For
example

book[@publisher ⫽ “Addison-Wesley”]

selects the books whose attribute “publisher” is “Ad-
dison-Wesley.” The key observation is that an attribute 
appears in the text inside the text region of its node
and is clearly identiﬁed by its name. Hence, as explained, it
is not hard for the indexer to identify it and to treat it just as
any other descendant of the node. The previous query can be
thus translated into

book parent (publisher same “Addison-Wesley”)

where “Addison-Wesley” is a content query that will
return all the text segments where that string appears, and
“publisher” will return all the text areas that correspond 
to “publisher” attributes. Their
intersection
yields precisely the desired result. Treating attributes as
normal ﬁelds indeed simpliﬁes the query language. For
example, XQL treats as a different operation the query for
structural elements whose text value is equal to some constant,
 while in Proximal Nodes this is exactly the same
query we have just considered.

Semijoins

A somewhat special feature allowed by XQL is to permit
taking as constants the content of absolute paths. For example 
“book[@author ⫽ @me],” where “@me” is an
attribute that descends directly from the root. This is not
contemplated in the Proximal Nodes model, but can be
easily ﬁxed at the query processing phase, by detecting such
cases, getting the text directly from the ﬁle, and replacing
the reference by the text constant.

The key issue is that this can be done only for absolute
paths, so that the reference can have just one value. The
generalized feature is called a “semijoin,” and is not supported 
either by XQL or by Proximal Nodes. The semijoin
would allow selecting chapters whose title is mentioned in
the bibliography section of a given book. Note that this
violates the condition of Proximal Nodes model: the fact
that a book qualiﬁes or not cannot be determined considering 
the text areas of the titles of the books, but one needs to
compare the content of the titles with those found in the
bibliography of the other book. This is hard to implement
efﬁciently (Baeza-Yates, 1966; Consens & Milo, 1995).

As XQL is embedded in Perl, it imports many of Perl’s
functions. Of course, this is not general and cannot be
expected to be supported by an abstract model such as
Proximal Nodes. However, the most used methods are indeed 
supported. First, text() corresponds to the textual
content of a node, which is a basic method for Proximal
Nodes. Second, value() is similar to text() but it can
be cast to other types such as integer or ﬂoat. This permits
putting, say, numerical conditions on the content of a given
attribute. Despite the fact that this cannot be solved by a text
index, the Proximal Nodes model can coexist with many
independent content indexes, and therefore, a different index 
able to answer such questions could be built on the
numerical values found in the text, and it could gracefully
coexist with the rest of the system (Navarro & Baeza-Yates,
1997). This index should receive a condition, say “ⱕ30,” and
return all the text areas containing numbers smaller than 30.
Proximal Nodes permits some conditions on XQL aggregate 
functions as well, such as selecting elements including
(directly or transitively) at least k elements of some kind.

Set Operations

Finally, XQL permits set operations, which are directly
translated into Proximal Nodes operations. It is interesting
to mention that XQL requires the answer to be the set of
structural nodes that satisfy the query. This also matches
with the Proximal Nodes semantics, while some other models 
return only top-level or bottom-level elements.

Followed By

Although not included in the XQL proposal, some implementations 
of XQL permit a kind of “followed by”
operation. Unfortunately, their description is not very clear,
and this is not a coincidence. As shown in Consens and Milo
(1995), it is quite difﬁcult to ﬁnd a satisfactory and consistent 
deﬁnition of a “followed by” operation in a hierarchical
model.

In Proximal Nodes this has been carefully designed so
that either the element preceding the other or the element
following the other are selected. However, it is not possible
later to operate the result to know, say, which is the smallest
X containing Y followed by Z. Once we have selected the Ys
that are followed by Z, we lose information on which was
the Z that made each Y to be selected, and therefore, we
cannot guarantee that the smallest X that contains the selected 
Y will also contain the corresponding Z. The Proximal 
Nodes model tries to ﬁx the problem by permitting, at
the moment of executing the operation, to specify X, so that
we force that the smallest X that contains Y must contain Z.
This, however, does not totally solve the problem.

An alternative solution is to return a “supernode” that has
the necessary extension to contain Y and Z. However, this
node is fake, and does not ﬁt well in the hierarchy, which

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

513

yields consistency problems for later operations. The models 
that are able to handle this well (Clarke et al., 1995;
Jaakkola & Kilpela¨inen, 1996) do not rely on a strict hierarchy 
of nodes but permit their overlapping. Those models,
for example, cannot cope with direct inclusion.

A reasonable solution when there is just one hierarchy is
to return the lowest level nodes that contain Y followed by
Z. In this case we can later obtain nodes of some set that
also contain the pair (Y, Z) by asking which of them contain
some of those lowest level nodes. Of course, those lowest
level nodes can be larger than desired, but they still have
this useful minimality property.

Conclusions

We have considered the problem of efﬁciently implementing 
XQL. In the best of our knowledge, current implementations 
could not cope with large document databases.
Given that there has been considerable research in the past
on efﬁciently implementing structured text query languages,
it is natural to study which of the models already created are
suitable for mapping XQL queries onto it. From the existing
models we are aware of, the Proximal Nodes (PN) model
seems to be the one that ﬁts best. We have shown how to
efﬁciently map XQL query onto PN operations. We believe
that other XML query languages can also be implemented
efﬁciently following the same ideas of this article, including
languages that are more expressive than XQL such as
Xquery. Other features such as XML references, on the
other hand, are probably hard to deal with efﬁciently.

Based on the results of this article, we are currently
designing a prototype of Xquery, using PN as the underlying 
model. This software is able of parsing XML to obtain
the structural information, using that information to build a
PN index, applying the PN query algorithms (simpliﬁed to
the case of a single hierarchy) and displaying the results.
Several issues, such as algebraic query optimization and
design of efﬁcient access plans given the query tree, are
open and subject of future work.

Acknowledgments

This work was supported by Fondecyt Project 1-990627.

References

Consens, M., & Mendelzon, A. (1993). Hy⫹: A hygraph-based query and
visualization system. In Proc. ACM SIGMOD’93 (pp. 511–516). Video
presentation summary.

Consens, M., & Milo, T. (1995). Algebras for querying text regions. In

Proc. PODS’95.

Chamberlin, D.D., Robie, J., & Florescu, D. (2000). Quilt. An XML query
language for heterogeneous data sources. In WebDB (Informal Proceed-
ings) (pp. 53– 62).

Dao, T., Sacks-Davis, R., & Thom, J. (1996). Indexing structured text for
queries on containment relationships. In Proc of the 7th Australasian
Database Conference.

Florescu, D., Deutsch, A., Levy, A., Suciu, D., & Fernandez, M. (1999). A
query language for XML. In Eighth international World Wide Web
conference. http://www.w3.org/TR/1998/NOTE-xml-ql-19980819

Florescu, D., Manolescu, I., & Kossmann, D. (2000). Integrating keyword

search into XML query processing. In WWW9, Amsterdam.

Goldfarb, C., & Prescod, P. (1998). The XML handbook. Oxford: PrenticeHall.


Gonnet, G., & Tompa, F. (1987). Mind your grammar: A new approach to

modelling text. In Proc VLDB’87 (pp. 339 –346).

International Standards Organization. (1986). Information processing—
text and ofﬁce systems—standard generalized markup language
(SGML). ISO 8879-1986.

Jaakkola, J., & Kilpela¨inen, P. (1996). Using sgrep for querying structured
text ﬁles. Technical report C-1996-83, Dept. of Computer Science, Univ.
of Helsinki, Finland. Software available at http://www.cs.helsinki.ﬁ/u/
jjaakkol/sgrep.html

Kilpela¨inen, P., & Mannila, H. (1993). Retrieval from hierarchical texts by

partial patterns. In Proc ACM SIGIR’93 (pp. 214 –222).

Lahiri, T., Abiteboul, S., & Widom, J. (1999). Ozone: Integrating structured 
and semistructured data. In Seventh international workshop on
database programming languages. Kinloch Rannoch, Scotland.

Lapp, J., Robie, J., & Schac, D. (1998). XML query language (XQL). In
QL’98 —The query languages workshop. http://www.w3.org/TandS/
QL/QL98/pp/xql.html

Luk, R., Leong, H.V., Dillon, T., Chan, A., Croft, W.B., & Allan, J. (2002).
Improving index structures for structured document retrieval. JASIS,
this issue.

MacLeod, I. (1991). A query language for retrieving information from

hierarchic text structures. The Computer Journal, 34(3), 254 –264.

Meuss, H., & Strohmaier, C. (1999). Improving index structures for structured
document retrieval. In 21st annual colloquium on IR research (IRSG’99).
Meuss, H., & Schulz, K. (2001). Complete answer aggregates for tree-like
databases: A novel approach to combine querying and navigation. ACM
Transactions on Information Systems, to appear.

Navarro, G. (1995). A language for queries on structure and contents of
textual databases. Master’s thesis. Dept. of Computer Science, Univ. of
Chile. ftp://-sunsite.dcc.uchile.cl/pub/users/gnavarro/thesis95.ps.gz

Navarro, G., & Baeza-Yates, R. (1995a). Expressive power of a new model

for structured text databases. In Proc PANEL’95 (pp. 1151–1162).

Navarro, G., & Baeza-Yates, R. (1995b). A language for queries on structure
and contents of textual databases. In Proc ACM SIGIR’95 (pp. 93–101).
Navarro, G., & Baeza-Yates, R. (1999). Proximal nodes: A model to query
document databases by content and structure. ACM TOIS, 15(4), 401–435.

Robie, J. (2001). XQL FAQ. www.ibiblio.org/xql/.
Salminen, A., & Tompa, F. (1992). PAT expressions: An algebra for text

search. In COMPLEX’92 (pp. 309 –332).

Schlieder, T., & Meuss, H. (2002). Querying and ranking xml documents.

Baeza-Yates, B. (1966). An extended model for full-text databases. Journal

JASIS, this issue.

of Brazilian CS Society, 3(2), 57– 64.

Spertus, E., & Stein, L. A. (2000). Squeal: A structured query language for

Baeza-Yates, B., & Navarro, G. (1966). Integrating contents and structure

the Web. In WWW9, Amsterdam.

in text retrieval. ACM SIGMOD Record, 25(1), 67–79.

WWW Consortium. (1999). Xpath 1.0: XML path language. Technical

Ceri, S., Comai, A., Damiani, E., Fraternali, P., Paraboschi, S., & Letizia,
T. (1999). XML-GL: A graphical language for querying and restructuring 
XML documents. In WWW8.

Clarke, C., Cormack, G., & Burkowski, F. (1995). An algebra for structured
text search and a framework for its implementation. The Computer Journal.

report, WWW Consortium. www.w3.org/TR/xpath.html.

WWW Consortium. (2001). Xquery 1.0: An XML query language. Technical 
report, WWW Consortium. www.w3.org/TR/xquery/

Widom, J. (1999). Data management for XML: Research directions. IEEE

Data Engineering Bulletin, 22(3), 44 –52.

514

JOURNAL OF THE AMERICAN SOCIETY FOR INFORMATION SCIENCE AND TECHNOLOGY—April 2002

