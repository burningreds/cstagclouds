Fast, Small, Simple Rank/Select on Bitmaps(cid:2)

Gonzalo Navarro1 and Eliana Providel1,2

1 Department of Computer Science, University of Chile

2 Escuela de Ingenier´ıa Civil Inform´atica, Facultad de Ingenier´ıa,

gnavarro@dcc.uchile.cl

Universidad de Valpara´ıso, Valpara´ıso, Chile

eliana.providel@uv.cl

Abstract. Rank and select queries on bitmaps are fundamental for the
construction of a variety of compact data structures. Both can, in theory,
be answered in constant time by spending o(n) extra bits on top of the
original bitmap, of length n, or of a compressed version of it. However,
while the solution for rank is indeed simple and practical, a similar result
for select has been elusive, and practical compact data structure implementations 
avoid its use whenever possible. In addition, the overhead
of the o(n) extra bits is in many cases very signiﬁcant. In this paper we
bridge the gap between theory and practice by presenting two structures,
one using the bitmap in plain form and another using a compressed form,
that are simple to implement and combine much lower space overheads
than previous work with excellent time performance for rank and select
queries. In particular, our structure for plain bitmaps is far smaller and
faster for select than any previous structure, while competitive for rank
with the best previous structures of similar size.

1

Introduction

Compact data structures represent data within little space and can eﬃciently
operate on it, in contrast to plain structures that do not compress, and with
pure compression that needs full decompression in order to operate the data.
They have become particularly interesting due to the increasing performance
gap between successive levels in the memory hierarchy, in particular between
main memory and disk. Since Jacobson’s work [9], compact data structures for
trees [9,11], graphs [9,11], strings [8,6], and texts [8,4], etc. have been proposed.
Jacobson [9] noticed that bit vectors were fundamental to support various
compact data structures. In particular, he used the following two operations to
simulate general trees, and since then these two operations have proved fundamental 
to implement many other compact structures:

rankb(B, i) = number of occurrences of bit b in B[0, i];
selectb(B, i) = position of the i-th occurrence of bit b in B.

(cid:2) Partially funded by Fondecyt Grant 1-110066 and Institute for Cell Dynamics and

Biotechnology (ICDB), Grant ICM P05-001-F, Mideplan, Chile.

R. Klasing (Ed.): SEA 2012, LNCS 7276, pp. 295–306, 2012.
c(cid:2) Springer-Verlag Berlin Heidelberg 2012

296

G. Navarro and E. Providel

Much eﬀort has been spent on implementing rank and select eﬃciently. In
theory, they have long been solved in O(1) time using just o(n) bits on top of B
[2,10], an even on top of a compressed representation of B using nH0(B) + o(n)
bits [15,14]. H0(B) = n0 lg(n/n0) + n1 lg(n/n1), where B has n0 0s and n1 1s, is
the called the zero-order entropy of B, and is smaller when B has a few 0s or 1s.
By default we assume b = 1 (many applications need just rank1 and select1).

The practical solutions for rank over plain bitmaps are indeed simple, and
there exist implementations solving it within a few tenths of microsecond (µsec)
using 5% of extra space on top of B [7]. For select, instead, no practical solution
with guaranteed constant time exists. The original solution [2] leads to more
than 60% extra space in practice [7]. Only very recently there have been better
proposals running in a few tenths of µsec and requiring around 25% [12] and
even 7% [16] of extra space, on a bitmap with half 0s and 1s. Even worse, those
structures only solve select, and thus need to be coupled with another solving
rank, and we need two copies of them to solve both select0 and select1 (this
does not happen with rank because rank0(i) = i− rank1(i)). On the other hand,

implementations of compressed solutions [15,3] pose in practice an overhead over
27% (of the original bitmap size) on top of the entropy of the bitmap.

This situation has noticeably slowed down the growth of the area of compact
data structures in practice: While many solutions building on select, or relying
on bitmap compression, are very attractive in theory, in practice one must try to
avoid the use of select, and have in mind the signiﬁcant space overhead associated
to the o(n) terms. We largely remedy both problems in this paper.

First, we introduce a new implementation of compressed bitmaps [15] that
retains the time performance of the current implementation [3] while drastically
reducing its space overhead by 50%–60%. The resulting structure has a space
overhead of around 10% (of the original bitmap size) on top of the entropy
(compare to the 27% of the current implementation [3]) and solves rank queries
within about 0.4 µsec and select within 1 µsec. This is achieved by replacing
the use of universal tables by on-the-ﬂy generation of their cells. These universal
tables are of size exponential on a block size t, and the space overhead of the
data structure is O(n lg t/t). Removing the tables let us use t values that are 4
times larger, thereby reducing the space by a factor of ≈ lg 4/4 = 50%.

Second, we present a new combined data structure that solves rank and select
on plain bitmaps, instead of solving each operation separately. It integrates two
samplings, one for rank that is regular on the bitmap positions, and one for select
that is regular on the positions of the 1s. Each operation uses its own sampling
but takes advantage of the other if possible. We show that this structure is able
to solve both rank and select queries within around 0.2 µsec, using just 3% of
extra space on top of the plain bitmap. This is an unprecedented result, very far
from what current representations achieve, that ﬁnally puts rank and select on
the map of the operations that can be used in practice without reservations.

Fast, Small, Simple Rank/Select on Bitmaps

297

2 Related Work

Jacobson [9] showed that attaching a dictionary of size o(n) to a bit vector
B[0, n− 1] is suﬃcient to support rank operation in constant time on the RAM
model. Later, Munro [10] and Clark [2] obtained constant-time complexity for
select on the RAM model, using also o(n) extra space. Golynski [5] showed how
to reduce the o(n) term to O(n lg lg n/ lg n), and that this space is optimal if B
is stored explicitly. Others have studied representations that store a compressed
form of B, useful when it has few or many 1s [13,15,12,14]. Some [15,14] use
nH0(B) + o(n) bits and solve both operations in constant time, where o(n) can
c n) for any constant c [14]. Others [12] solve select in
be as small as O(n/ lg
constant time and rank in time O(lg(n/n1)), using nH0(B) + O(n1) bits.

The original solution for rank was simple, easy to program, and required three
table accesses. It has followed a simple path through practice. For example, a
competitive implementation [7] solves rank in a few tenths of microseconds using
5% of extra space on top of B, and in a few hundredths using 37.5% of extra
space. The ﬁrst ﬁgure is suﬃciently fast in most practical scenarios.

The solution for select, instead, has followed a more complicated path. The
original constant-time solution [2,10] is much more complicated than that of
rank, and in practice it is much slower and requires more space. An implementation 
[7] showed that it requires more than 60% of extra space. Indeed, a simple
solution that works better [7] for all reasonable bitmap sizes is to solve select via
binary searches on the rank directories. This, however, makes select signiﬁcantly
slower than rank, and less attractive in practice.

Okanohara and Sadakane [12] proposed a simpliﬁcation of the original solution 
that, although does not guarantee constant time, it works very well in
practice (a few tenths of microseconds). It requires, however, around 25% of
extra space and does not solve rank, so their complete rank/select solution for
their structure called dense array requires more than 50% extra space. Later on,
Vigna [16] achieved similar times within much less space overhead (7% to 12%
in our experiments), with a structure called simple-select. Again, this structure
does not solve rank. He proposed other two structures, rank9sel and rank9b, that
solve both operations within the same time and a space overhead of around 24%.
As for compressed bitmaps, Claude and Navarro [3] implemented the solution
by Raman et al. [15], achieving around 27% space overhead (this percentage
refers to the original bitmap size) on top of the entropy of the bitmap, and
solved rank within tenths of microseconds and select within a microsecond. This
space overhead is very signiﬁcant in practice. The structure is useful for densities
(n1/n) of up to 20% (at which point the entropy is more than 80% anyway, so
not much can be done). Okanohara and Sadakane [12] presented a structure
called sparse array, that uses n1 lg(n/n1) + O(n1) bits, and is very fast to solve
rank and select (as fast as rank on plain bitmaps). However, its space overhead
is very large for all but very sparse bitmaps (densities below 5%).

298

G. Navarro and E. Providel

3 A Structure for Compressed Bitmaps

2

(cid:3)

(cid:2)
t
k

(cid:2)
t
k

elements, so (cid:3)lg

We describe our rank/select data structure for compressed bitmaps. It is based
on the proposal by Raman et. al. [15] and its practical implementation [3]. We
ﬁrst describe this implementation and then our improvement.
(cid:4).
The structure partitions the input bitmap B into blocks of length t = (cid:3) lg n
These are assigned to classes: a block with k 1s belongs to class k. Class k
(cid:3)(cid:4) bits are used to refer to an element of it. A
contains
block is identiﬁed with a pair (k, r), where k is its class (0 ≤ k ≤ t, using
(cid:3)(cid:4)
(cid:3)lg(t + 1)(cid:4) bits), and r is the index of the block within the class (using (cid:3)lg
bits). A global universal table for each class k translates in O(1) time any index
r into the corresponding t bits. The sizes of all those tables add up to 2t t bits.
The sequence of (cid:3)n/t(cid:4) class identiﬁers k is stored in one array, K, and that of
the indexes r is stored in another, R. Note the indexes are of diﬀerent width, so
it is not immediate how to locate the r value of the j-th block. The blocks are
grouped in superblocks of length s = (cid:6)t lg n(cid:7). Each superblock stores the rank
up to its beginning, and a pointer to R where its indexes start.

(cid:2)
t
k

(cid:2)
t
k

To solve rank(i), we ﬁrst compute the superblock i belongs to, which stores
the rank value up to its beginning. Then we scan the classes from the start of the
superblock, accumulating the k values into our rank answer. At the same time
we maintain the pointer to array R: the superblock knows the pointer value
(cid:3)(cid:4) for each class k
corresponding to its beginning, and then we must add (cid:3)lg
we process. These values are obviously preprocessed, and note we do not access
R. This scanning continues up to the block i belongs to, whose index is extracted
from R and its bits are recovered from the universal table. We then scan the
remaining bits of the block and ﬁnish. Solving select(j) is analogous, except that
we ﬁrst binary search for the proper superblock and then scan the blocks.
The size of R is upper bounded by nH0(B), and the main space overhead
comes from K, which uses n(cid:3)lg(t + 1)/t(cid:4) bits (the superblocks add O(n/t) bits,
which is negligible). So we wish to have a larger t to reduce the main space
overhead. The size 2t t of the universal table, plus its low access locality, however,
prevents using a large t. In the practical implementation [3] they used t = 15,
so K is read by nibbles and the universal table requires only 64 KB of memory.
The price is that the space overhead is (cid:3)lg(t + 1)/t(cid:4) = 4/15 ≈ 27%.

Our Proposal. We propose to remove the universal table and compute its entry
on the ﬂy. Although we require O(t) time to rebuild a block from its index r,
we note this is done only once per query, so the impact should not be much. As
a reward, we will be able to use larger block sizes, such as t = 31 (with a space
overhead of 5/31 ≈ 16%) and t = 63 (with a space overhead of 6/63 ≈ 9.5%).1

The Computation of r. At compression time, the index r of a block of length
t and k 1s is assigned as follows. We start with r = 0. We consider the ﬁrst bit.
1 We do not use blocks larger than 63 because we would need special multiword
arithmetics in our computer, and all of our multiword approaches have been orders
of magnitude slower than the native arithmetic.

Fast, Small, Simple Rank/Select on Bitmaps

299

of them)
We number ﬁrst the blocks with this ﬁrst bit in zero (there are
(cid:2)
(cid:3)
t−1
k−1
and then those with the ﬁrst bit in one (there are
). Therefore, if the ﬁrst
bit is zero we just continue with the next bit (now the block is of length t − 1
(cid:3)
(cid:2)
t−1
and still has k 1s). Otherwise, we increase r by
and continue with the next
bit (now the block is of length t − 1 and has k − 1 1s).
k

(cid:3)
(cid:2)
t−1
k

Reconstructing a Block on the Fly. We must reverse the encoding process.
By checking the range of values r belongs to, we extract the bits consecutively.
(cid:3)
If r ≥ (cid:2)
t−1
, then the ﬁrst bit of the block was a 1. In this case we decrement t
(cid:2)
(cid:3)
k
t−1
and k, and decrease r by
. Otherwise, the ﬁrst bit of the block was a 0. In
k
this case we only decrement t. Now we continue extracting the next bit from a
block of length t − 1.

Note we can stop if r becomes zero, as this means that all the remaining bits
are zero. Also, to solve rank or select queries, it may also be possible to stop this
process before obtaining all the bits of the block. Finally, we (obviously) have
all the binomial coeﬃcients precomputed.

4 A Structure for Plain Bitmaps: Combined Sampling

We introduce a structure that answers rank/select queries on top of plain bitmaps.
This structure combines two sampling schemes: the ﬁrst one is a regular sampling 
on positions, that is, we divide the input bitmap B into blocks of ﬁxed size
Sr. Then, we store a sampling of rank answers from the beginning of B up to
the end of each block, sampleRank[j] = rank1(B, j · Sr). In the second sampling
scheme, we create blocks containing exactly Ss 1s. Note these blocks are of variable 
length. We ensure that each block starts with a 1, to minimize unnecessary
scanning. Thus sampleSelect[j] = select1(B, j · Ss + 1). Both samplings are
similar to the top-level samplings proposed in classical solutions [2,10] to rank
and select queries. The novelty is in how we combine them to solve each query.

Answering rank queries. To solve rank1(i), we start from block number
j = (cid:6)Sr/i(cid:7), up to which the number of 1s in B is sampleRank[j], and scan the
= j · Sr + 1 to position i. This scanning is done bytewise,
bitmap from position i(cid:3)
using a universal preocomputed table that counts the number of 1s in all the
256 bytes2. The sampling step Sr is always a multiple of 8, so that the scanning
starts at a byte boundary. On the other extreme, we may need to individually
scan the bits of the last byte.

Up to this point the technique is standard, and in fact corresponds to the
“small space” variant of Gonz´alez et al. [7]. The novelty is that we will also
make use of table sampleSelect to speed up the scanning. Imagine that r =
sampleRank[j], and we have to complete the scanning from bit positions i(cid:3)
to i.
It is possible that some sampleSelect values point between i(cid:3)
and i, and we can
= (cid:6)r/Ss(cid:7). Then sampleSelect[r(cid:3)
easily ﬁnd them: compute r(cid:3)
] points somewhere

2 In some architectures, a native popcount operation may be faster. We have not exploited 
this feature as it is not standard.

G. Navarro and E. Providel

300
. We scan sampleSelect[r(cid:3)
before i(cid:3)
k + 1] > i. At this point we call i(cid:3)(cid:3)
rank1(i(cid:3)(cid:3)
) = (r(cid:3)
can give a speedup unless k = 0.

+ k) · Ss + 1. Thus we only need to scan from i(cid:3)(cid:3)

+ k] for k = 1, 2 . . ., until sampleSelect[r(cid:3)
+
+ k] ≤ i, and know that
= sampleSelect[r(cid:3)
+ 1 to i. This

A ﬁnal tweak is that starting from positions i(cid:3)(cid:3)

+ 1 that are not byte-aligned
is cumbersome and aﬀects the performance. For this reason we slightly change
the meaning of table sampleSelect[j]. Instead of pointing to the precise bit
position of the (j · Ss + 1)-th 1, it points to its byte position, so the scanning
is always resumed from a byte-aligned position. A problem is that now do not
know which is the rank value up to the beginning of the byte (previously we
knew that there were exactly j · Ss + 1 bits set up to position sampleSelect[j]).
Fortunately, pointing to bytes instead of bits frees three bits from the integers
where the positions are stored. The three least signiﬁcant bits are therefore used
to store correction information, namely the number of 1s from the beginning of
the byte pointed by sampleSelect[j] to just before the exact position of the
(j · Ss + 1)-th 1. Therefore, the number of 1s up to the beginning of the byte
pointed by sampleSelect[j] is j · Ss minus the correction information.
Answering select Queries. To solve select1(B, i), we ﬁrst compute j = (cid:6)Ss/i(cid:7),
and use sampleSelect[j] to ﬁnd a byte-aligned position p up to where we know
the value r = rank1(B, p− 1). Then we scan byte-wise, incrementing r using the
universal popcount table, until we ﬁnd a byte where we exceed the rank value
we are looking for, r > i. Then we rescan the last byte bit-wise until ﬁnding the
exact position of the i-th 1 in B.
Once again, the byte-wise scanning can be sped up because we may go through
several sampled values in sampleRank. We compute q = (cid:6)p/Sr(cid:7), and scan the
successive values sampleRank[q + k], k = 1, 2 . . . until sampleRank[q + k + 1] > i.
= (q + k) · Sr, with
Then we may start the byte-wise scanning from position p(cid:3)
rank value r = sampleRank[q + k], thus speeding up the process.

5 Experimental Results

We compare our implementations with various existing solutions. All the experiments 
were carried out on a machine with two IntelCore2 Duo processors, with 3
Ghz and 6 MB cache each, and 8 GB of RAM. The operating system is Ubuntu
8.04.4. We used gcc compiler with full optimization. We experiment on bitmaps
of length n = 228 and average all our values over one million repetitions.

5.1 Compressed Representations

To benchmark this structure we compared the performance of rank and select
operations with the original Raman et. al. (RRR [15]) implementation [3], and
with the sparse array of Okanohara and Sadakane (Sada sparse [12]). For our
structure we considered block sizes of b = 15, 31, and 63, and for each block size
we considered superblocks of 32, 64, and 128 blocks. (Recall that RRR can use
only blocks of size 15.) We generated random bitmaps with densities 5%, 10%,
and 20% (their zero-order entropies are 0.286, 0.469, and 0.772, respectively).

Fast, Small, Simple Rank/Select on Bitmaps

301

(cid:29)(cid:26)(cid:21)(cid:30)(cid:1)(cid:31)(cid:32)(cid:15)(cid:18)(cid:13)(cid:15)(cid:20)(cid:33)(cid:1)(cid:27)(cid:13)(cid:28)(cid:14)(cid:26)(cid:25)(cid:1)(cid:22)(cid:15)(cid:21)(cid:20)(cid:13)(cid:28)(cid:34)(cid:1)(cid:8)(cid:35)(cid:33)(cid:1)(cid:20)(cid:13)(cid:36)(cid:15)(cid:1)(cid:5)(cid:37)(cid:5)(cid:11)

(cid:23)(cid:14)(cid:28)(cid:14)(cid:16)(cid:27)(cid:1)(cid:29)(cid:30)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:31)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:32)(cid:1)(cid:10)(cid:33)(cid:31)(cid:1)(cid:19)(cid:12)(cid:34)(cid:14)(cid:1)(cid:4)(cid:35)(cid:4)(cid:7)

(cid:23)
(cid:20)
(cid:22)
(cid:21)
(cid:19)
(cid:17)
(cid:15)
(cid:20)
(cid:19)
(cid:18)
(cid:17)
(cid:13)
(cid:14)

(cid:16)
(cid:1)
(cid:15)
(cid:14)
(cid:12)

(cid:13)

(cid:24)
(cid:21)
(cid:23)
(cid:22)
(cid:20)
(cid:18)
(cid:16)
(cid:21)
(cid:20)
(cid:19)
(cid:18)
(cid:14)
(cid:15)

(cid:17)
(cid:1)
(cid:16)
(cid:15)
(cid:13)

(cid:14)

(cid:24)
(cid:21)
(cid:23)
(cid:22)
(cid:20)
(cid:18)
(cid:16)
(cid:21)
(cid:20)
(cid:19)
(cid:18)
(cid:14)
(cid:15)

(cid:17)
(cid:1)
(cid:16)
(cid:15)
(cid:13)

(cid:14)

(cid:1)(cid:2)(cid:3)(cid:11)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:12)
(cid:1)(cid:2)(cid:3)(cid:11)
(cid:1)(cid:2)(cid:3)(cid:10)
(cid:1)(cid:2)(cid:3)(cid:9)
(cid:1)(cid:2)(cid:3)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:1)(cid:4)
(cid:1)(cid:2)(cid:3)(cid:12)
(cid:1)(cid:2)(cid:3)(cid:11)
(cid:1)(cid:2)(cid:3)(cid:10)
(cid:1)(cid:2)(cid:3)(cid:9)
(cid:1)(cid:2)(cid:3)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:29)(cid:29)(cid:29)
(cid:24)(cid:26)(cid:22)(cid:26)(cid:1)(cid:20)(cid:25)(cid:26)(cid:18)(cid:20)(cid:15)
(cid:27)(cid:38)(cid:4)(cid:8)
(cid:27)(cid:38)(cid:6)(cid:4)
(cid:27)(cid:38)(cid:9)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:6)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:7)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:8)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:24)(cid:25)(cid:26)(cid:17)(cid:15)(cid:1)(cid:16)(cid:27)(cid:13)(cid:28)(cid:20)(cid:1)(cid:25)(cid:15)(cid:18)(cid:1)(cid:27)(cid:13)(cid:28)(cid:23)

(cid:30)(cid:27)(cid:22)(cid:31)(cid:1)(cid:32)(cid:33)(cid:16)(cid:19)(cid:14)(cid:16)(cid:21)(cid:34)(cid:1)(cid:28)(cid:14)(cid:29)(cid:15)(cid:27)(cid:26)(cid:1)(cid:23)(cid:16)(cid:22)(cid:21)(cid:14)(cid:29)(cid:35)(cid:1)(cid:4)(cid:2)(cid:36)(cid:34)(cid:1)(cid:21)(cid:14)(cid:37)(cid:16)(cid:1)(cid:5)(cid:38)(cid:5)(cid:11)

(cid:30)(cid:30)(cid:30)
(cid:25)(cid:27)(cid:23)(cid:27)(cid:1)(cid:21)(cid:26)(cid:27)(cid:19)(cid:21)(cid:16)
(cid:28)(cid:39)(cid:4)(cid:8)
(cid:28)(cid:39)(cid:6)(cid:4)
(cid:28)(cid:39)(cid:9)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:8)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:9)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:10)(cid:8)

(cid:25)(cid:26)(cid:27)(cid:18)(cid:16)(cid:1)(cid:17)(cid:28)(cid:14)(cid:29)(cid:21)(cid:1)(cid:26)(cid:16)(cid:19)(cid:1)(cid:28)(cid:14)(cid:29)(cid:24)

(cid:30)(cid:27)(cid:22)(cid:31)(cid:1)(cid:32)(cid:33)(cid:16)(cid:19)(cid:14)(cid:16)(cid:21)(cid:34)(cid:1)(cid:28)(cid:14)(cid:29)(cid:15)(cid:27)(cid:26)(cid:1)(cid:23)(cid:16)(cid:22)(cid:21)(cid:14)(cid:29)(cid:35)(cid:1)(cid:5)(cid:2)(cid:36)(cid:34)(cid:1)(cid:21)(cid:14)(cid:37)(cid:16)(cid:1)(cid:5)(cid:38)(cid:5)(cid:11)

(cid:30)(cid:30)(cid:30)
(cid:25)(cid:27)(cid:23)(cid:27)(cid:1)(cid:21)(cid:26)(cid:27)(cid:19)(cid:21)(cid:16)
(cid:28)(cid:39)(cid:4)(cid:8)
(cid:28)(cid:39)(cid:6)(cid:4)
(cid:28)(cid:39)(cid:9)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:11)

(cid:1)(cid:2)(cid:3)(cid:12)

(cid:1)(cid:4)

(cid:1)(cid:4)(cid:3)(cid:4)

(cid:1)(cid:4)(cid:3)(cid:5)

(cid:1)(cid:4)(cid:3)(cid:6)

(cid:25)(cid:26)(cid:27)(cid:18)(cid:16)(cid:1)(cid:17)(cid:28)(cid:14)(cid:29)(cid:21)(cid:1)(cid:26)(cid:16)(cid:19)(cid:1)(cid:28)(cid:14)(cid:29)(cid:24)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:1)(cid:4)
(cid:1)(cid:8)(cid:3)(cid:7)
(cid:1)(cid:8)(cid:3)(cid:6)
(cid:1)(cid:8)(cid:3)(cid:5)
(cid:1)(cid:8)(cid:3)(cid:4)
(cid:1)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:1)(cid:4)
(cid:1)(cid:8)(cid:3)(cid:7)
(cid:1)(cid:8)(cid:3)(cid:6)
(cid:1)(cid:8)(cid:3)(cid:5)
(cid:1)(cid:8)(cid:3)(cid:4)
(cid:1)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:1)(cid:4)
(cid:1)(cid:8)(cid:3)(cid:7)
(cid:1)(cid:8)(cid:3)(cid:6)
(cid:1)(cid:8)(cid:3)(cid:5)
(cid:1)(cid:8)(cid:3)(cid:4)
(cid:1)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:36)(cid:36)(cid:36)
(cid:23)(cid:25)(cid:21)(cid:25)(cid:1)(cid:19)(cid:24)(cid:25)(cid:17)(cid:19)(cid:14)
(cid:26)(cid:37)(cid:8)(cid:10)
(cid:26)(cid:37)(cid:9)(cid:8)
(cid:26)(cid:37)(cid:6)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:9)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:5)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:10)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:23)(cid:14)(cid:28)(cid:14)(cid:16)(cid:27)(cid:1)(cid:29)(cid:30)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:31)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:32)(cid:1)(cid:8)(cid:2)(cid:33)(cid:31)(cid:1)(cid:19)(cid:12)(cid:34)(cid:14)(cid:1)(cid:4)(cid:35)(cid:4)(cid:7)

(cid:36)(cid:36)(cid:36)
(cid:23)(cid:25)(cid:21)(cid:25)(cid:1)(cid:19)(cid:24)(cid:25)(cid:17)(cid:19)(cid:14)
(cid:26)(cid:37)(cid:8)(cid:9)
(cid:26)(cid:37)(cid:38)(cid:8)
(cid:26)(cid:37)(cid:6)(cid:38)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:9)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:6)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:10)(cid:9)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:23)(cid:14)(cid:28)(cid:14)(cid:16)(cid:27)(cid:1)(cid:29)(cid:30)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:31)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:32)(cid:1)(cid:4)(cid:2)(cid:33)(cid:31)(cid:1)(cid:19)(cid:12)(cid:34)(cid:14)(cid:1)(cid:4)(cid:35)(cid:4)(cid:7)

(cid:36)(cid:36)(cid:36)
(cid:23)(cid:25)(cid:21)(cid:25)(cid:1)(cid:19)(cid:24)(cid:25)(cid:17)(cid:19)(cid:14)
(cid:26)(cid:37)(cid:8)(cid:38)
(cid:26)(cid:37)(cid:10)(cid:8)
(cid:26)(cid:37)(cid:6)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:8)

(cid:1)(cid:8)(cid:3)(cid:8)

(cid:1)(cid:8)(cid:3)(cid:4)

(cid:1)(cid:8)(cid:3)(cid:10)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

Fig. 1. Results for compressed bitmaps. Time is measured in µsec per query and space
in total bits per bit of the bitmap. The x coordinates start at the zero-order entropy
of the bitmap, so that the redundancy can be appreciated.

Fig. 1 gives the results. Increasing the block size from 15 to 63 greatly reduces

the space overhead of the representation, to around 40%–50% of its value.

Our implementation is 30-50% faster than RRR for select queries, even with
the same block size b = 15. Our times for select are almost insensitive to the
block size. This shows that the time to decode a block is negligible compared
to that of the binary search. On the other hand, smaller superblocks make the
operation faster, and a superblock of 32 or 64 blocks is recommended.

RRR is slightly faster than our implementation for rank, and also using longer
blocks has a more noticeable (but still slight) eﬀect on the performance. Overall,
the price is very low compared to the large space gain.

Finally, Sada sparse is signiﬁcantly faster than all other implementations,
especially for select. However, its space is competitive only for very low densities.
Overall, using block size b = 63 and superblocks of 32 or 64 blocks, our
data structure computes rank in about half a microsecond, select in about one

302

G. Navarro and E. Providel

microsecond, and requires a space overhead of less than 10% on top of the entropy.
 Overall this is a very convenient alternative for sparse bitmaps (of density
up to 20%, as thereafter the entropy becomes too close to 1.0). For very sparse
bitmaps (density well below 5%), Sada sparse technique becomes the best choice.
Note that our result would immediately improve on 128-bit processors.

5.2 Combined Sampling

We compare our combined sampling structure with several others. We consider,
 from Gonz´alez et al. [7], the variant that use blocks and superblocks and
pose 37.5% extra space (RG 37%) and the one that uses one level of blocks
(RG 1Level). From Vigna [16] we consider variants rank9sel, rank9b, and
simple-select. From Clark [2] we consider its implementation for select [7]
that uses 60% of extra space (Clark). Finally, from Okanohara and Sadakane
[12] we use their dense bitmaps (Sada dense).

For our structure, we try diﬀerent Sr and Ss combinations in the range
[28, 213]. We show a curve for each Sr, with varying values of Ss. In addition,
to test whether our combined approach is better than each structure separately,
we add a modiﬁed Combined Sampling structure in which each kind of query
only uses its respective supporting structure. In that case we use only the Sr
(for rank) or Ss (for select) sampling, without using the other sampling.

We made two experiments: in the ﬁrst, we evaluate rank and select queries
separately, to study their performance. In the second, we emulate a real application 
that requires both kinds of queries, and test combined sequences with
diﬀerent proportions of rank/select queries.

Independent Queries We execute either rank or select queries over bitmaps
of densities 10%, 50%, and 90%. The results are shown in Fig. 2.3

Note that our techniques provide a continuum of space/time tradeoﬀs by
varying Sr and Ss. The most interesting zone is the one where the extra space is
below 5% and the times are below 0.2 µsec (for rank) and 0.3 µsec (for select). In
particular, using Sr = 1024 and Ss = 8192 achieves extra space around 3% and
times in the range 0.1–0.2 µsec for rank and 0.2–0.25 for select. This space/time
tradeoﬀ had never been achieved before.

By regarding the performance without using Ss, it can be seen that the use
of the sampling of select does not make a big diﬀerence for rank (so we could use
the basic technique that does not use sampleSelect). However, the performance
without using Sr shows that select is sped up considerably by using the sampling
of rank. As a result, our combined structure is more than two separate structures
put together, as most of the structures in the literature.

3 We are aware that most of our curves are visually indistinguishable. However, our
aim is to show that, using some parameterization (for which we will give explicit
recommendations), our curves improve upon previous work, which is clearly distinguishable.
 Thus our curves can be regarded as a single, thick curve. We have not
replaced them by a single one formed by the dominant points because we want to
emphasize that the results are not much sensitive to a careful parameterization.

Fast, Small, Simple Rank/Select on Bitmaps

303

(cid:27)(cid:24)(cid:19)(cid:28)(cid:1)(cid:29)(cid:30)(cid:13)(cid:16)(cid:11)(cid:13)(cid:18)(cid:31)(cid:1)(cid:25)(cid:11)(cid:26)(cid:12)(cid:24)(cid:23)(cid:1)(cid:20)(cid:13)(cid:19)(cid:18)(cid:11)(cid:26)(cid:32)(cid:1)(cid:4)(cid:2)(cid:33)(cid:31)(cid:1)(cid:18)(cid:11)(cid:34)(cid:13)(cid:1)(cid:5)(cid:35)(cid:5)(cid:36)

(cid:23)(cid:14)(cid:28)(cid:14)(cid:16)(cid:27)(cid:1)(cid:29)(cid:30)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:31)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:32)(cid:1)(cid:8)(cid:2)(cid:33)(cid:31)(cid:1)(cid:19)(cid:12)(cid:34)(cid:14)(cid:1)(cid:4)(cid:35)(cid:4)(cid:7)

(cid:21)
(cid:18)
(cid:20)
(cid:19)
(cid:17)
(cid:15)
(cid:13)
(cid:18)
(cid:17)
(cid:16)
(cid:15)
(cid:11)
(cid:12)

(cid:14)
(cid:1)
(cid:13)
(cid:12)
(cid:10)

(cid:11)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:23)
(cid:20)
(cid:22)
(cid:21)
(cid:19)
(cid:17)
(cid:15)
(cid:20)
(cid:19)
(cid:18)
(cid:17)
(cid:13)
(cid:14)

(cid:16)
(cid:1)
(cid:15)
(cid:14)
(cid:12)

(cid:13)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:1)(cid:2)

(cid:22)(cid:16)(cid:37)(cid:5)(cid:8)(cid:9)(cid:31)(cid:1)(cid:22)(cid:18)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)
(cid:22)(cid:16)(cid:37)(cid:8)(cid:4)(cid:5)(cid:31)(cid:1)(cid:22)(cid:18)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)
(cid:22)(cid:16)(cid:37)(cid:4)(cid:2)(cid:5)(cid:7)(cid:31)(cid:1)(cid:22)(cid:18)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)
(cid:22)(cid:16)(cid:37)(cid:5)(cid:2)(cid:7)(cid:36)(cid:31)(cid:1)(cid:22)(cid:18)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)
(cid:22)(cid:16)(cid:37)(cid:7)(cid:2)(cid:39)(cid:9)(cid:31)(cid:1)(cid:22)(cid:18)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)
(cid:22)(cid:16)(cid:37)(cid:36)(cid:4)(cid:39)(cid:5)(cid:31)(cid:1)(cid:22)(cid:18)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)
(cid:22)(cid:16)(cid:37)(cid:5)(cid:8)(cid:9)(cid:38)(cid:36)(cid:4)(cid:39)(cid:5)(cid:31)(cid:1)(cid:19)(cid:17)(cid:1)(cid:22)(cid:18)
(cid:40)(cid:11)(cid:41)(cid:19)(cid:24)(cid:1)(cid:16)(cid:24)(cid:19)(cid:28)(cid:39)(cid:18)(cid:13)(cid:42)
(cid:40)(cid:11)(cid:41)(cid:19)(cid:24)(cid:1)(cid:16)(cid:24)(cid:19)(cid:28)(cid:39)(cid:25)
(cid:22)(cid:24)(cid:20)(cid:24)(cid:1)(cid:20)(cid:13)(cid:19)(cid:18)(cid:13)
(cid:27)(cid:43)(cid:1)(cid:4)(cid:44)(cid:13)(cid:45)(cid:13)(cid:42)
(cid:27)(cid:43)(cid:1)(cid:6)(cid:46)(cid:33)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)(cid:3)(cid:4)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:5)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:6)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:7)(cid:8)

(cid:22)(cid:23)(cid:24)(cid:15)(cid:13)(cid:1)(cid:14)(cid:25)(cid:11)(cid:26)(cid:18)(cid:1)(cid:23)(cid:13)(cid:16)(cid:1)(cid:25)(cid:11)(cid:26)(cid:21)

(cid:28)(cid:25)(cid:20)(cid:29)(cid:1)(cid:30)(cid:31)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:32)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:33)(cid:1)(cid:8)(cid:2)(cid:34)(cid:32)(cid:1)(cid:19)(cid:12)(cid:35)(cid:14)(cid:1)(cid:5)(cid:36)(cid:5)(cid:37)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:8) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:8) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:8) (cid:1)(cid:2)(cid:3)(cid:6) (cid:1)(cid:2)(cid:3)(cid:6)(cid:8) (cid:1)(cid:2)(cid:3)(cid:7) (cid:1)(cid:2)(cid:3)(cid:7)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:8)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:29)(cid:26)(cid:21)(cid:30)(cid:1)(cid:31)(cid:32)(cid:15)(cid:18)(cid:13)(cid:15)(cid:20)(cid:33)(cid:1)(cid:27)(cid:13)(cid:28)(cid:14)(cid:26)(cid:25)(cid:1)(cid:22)(cid:15)(cid:21)(cid:20)(cid:13)(cid:28)(cid:34)(cid:1)(cid:35)(cid:2)(cid:36)(cid:33)(cid:1)(cid:20)(cid:13)(cid:37)(cid:15)(cid:1)(cid:5)(cid:38)(cid:5)(cid:11)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:1)(cid:2) (cid:1)(cid:2)(cid:3)(cid:2)(cid:8)(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:11)

(cid:24)(cid:25)(cid:26)(cid:17)(cid:15)(cid:1)(cid:16)(cid:27)(cid:13)(cid:28)(cid:20)(cid:1)(cid:25)(cid:15)(cid:18)(cid:1)(cid:27)(cid:13)(cid:28)(cid:23)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:23)
(cid:20)
(cid:22)
(cid:21)
(cid:19)
(cid:17)
(cid:15)
(cid:20)
(cid:19)
(cid:18)
(cid:17)
(cid:13)
(cid:14)

(cid:16)
(cid:1)
(cid:15)
(cid:14)
(cid:12)

(cid:13)

(cid:1)(cid:4)
(cid:1)(cid:8)(cid:3)(cid:7)
(cid:1)(cid:8)(cid:3)(cid:6)
(cid:1)(cid:8)(cid:3)(cid:5)
(cid:1)(cid:8)(cid:3)(cid:4)
(cid:1)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:1)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:11)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:23)(cid:17)(cid:36)(cid:4)(cid:9)(cid:6)(cid:31)(cid:1)(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:7)(cid:8)(cid:38)(cid:4)
(cid:23)(cid:17)(cid:36)(cid:9)(cid:8)(cid:4)(cid:31)(cid:1)(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:7)(cid:8)(cid:38)(cid:4)
(cid:23)(cid:17)(cid:36)(cid:8)(cid:2)(cid:4)(cid:5)(cid:31)(cid:1)(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:7)(cid:8)(cid:38)(cid:4)
(cid:23)(cid:17)(cid:36)(cid:4)(cid:2)(cid:5)(cid:7)(cid:31)(cid:1)(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:7)(cid:8)(cid:38)(cid:4)
(cid:23)(cid:17)(cid:36)(cid:5)(cid:2)(cid:38)(cid:6)(cid:31)(cid:1)(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:7)(cid:8)(cid:38)(cid:4)
(cid:23)(cid:17)(cid:36)(cid:7)(cid:8)(cid:38)(cid:4)(cid:31)(cid:1)(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:7)(cid:8)(cid:38)(cid:4)
(cid:23)(cid:19)(cid:36)(cid:4)(cid:9)(cid:6)(cid:37)(cid:5)(cid:2)(cid:38)(cid:6)(cid:31)(cid:1)(cid:20)(cid:18)(cid:1)(cid:23)(cid:17)
(cid:39)(cid:12)(cid:40)(cid:20)(cid:25)(cid:1)(cid:19)(cid:12)(cid:13)(cid:24)(cid:28)(cid:14)(cid:41)(cid:19)(cid:14)(cid:28)(cid:14)(cid:16)(cid:27)
(cid:39)(cid:12)(cid:40)(cid:20)(cid:25)(cid:1)(cid:17)(cid:25)(cid:20)(cid:42)(cid:38)(cid:19)(cid:14)(cid:28)
(cid:39)(cid:12)(cid:40)(cid:20)(cid:25)(cid:1)(cid:17)(cid:25)(cid:20)(cid:42)(cid:38)(cid:26)
(cid:23)(cid:25)(cid:21)(cid:25)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:14)
(cid:43)(cid:44)(cid:1)(cid:8)(cid:45)(cid:14)(cid:46)(cid:14)(cid:28)
(cid:43)(cid:44)(cid:1)(cid:10)(cid:47)(cid:33)
(cid:48)(cid:28)(cid:25)(cid:17)(cid:42)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:9) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:9) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:9) (cid:1)(cid:2)(cid:3)(cid:10) (cid:1)(cid:2)(cid:3)(cid:10)(cid:9) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9)(cid:9) (cid:1)(cid:2)(cid:3)(cid:6)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:23)(cid:14)(cid:28)(cid:14)(cid:16)(cid:27)(cid:1)(cid:29)(cid:30)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:31)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:32)(cid:1)(cid:9)(cid:2)(cid:33)(cid:31)(cid:1)(cid:19)(cid:12)(cid:34)(cid:14)(cid:1)(cid:4)(cid:35)(cid:4)(cid:7)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:9) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:9) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:9) (cid:1)(cid:2)(cid:3)(cid:10) (cid:1)(cid:2)(cid:3)(cid:10)(cid:9) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9)(cid:9) (cid:1)(cid:2)(cid:3)(cid:6)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:24)(cid:15)(cid:29)(cid:15)(cid:17)(cid:28)(cid:1)(cid:30)(cid:31)(cid:15)(cid:18)(cid:13)(cid:15)(cid:20)(cid:32)(cid:1)(cid:27)(cid:13)(cid:28)(cid:14)(cid:26)(cid:25)(cid:1)(cid:22)(cid:15)(cid:21)(cid:20)(cid:13)(cid:28)(cid:33)(cid:1)(cid:34)(cid:2)(cid:35)(cid:32)(cid:1)(cid:20)(cid:13)(cid:36)(cid:15)(cid:1)(cid:5)(cid:37)(cid:5)(cid:11)

(cid:1)(cid:2) (cid:1)(cid:2)(cid:3)(cid:2)(cid:8)(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:11)

(cid:24)(cid:25)(cid:26)(cid:17)(cid:15)(cid:1)(cid:16)(cid:27)(cid:13)(cid:28)(cid:20)(cid:1)(cid:25)(cid:15)(cid:18)(cid:1)(cid:27)(cid:13)(cid:28)(cid:23)

Fig. 2. Rank/Select queries for plain bitmaps. Time is measured in µsec per query and
space in extra bits per bit of the bitmap.

For rank, structures like rank9b, rank9sel, and Sada dense, occupy signiﬁcantly
more space and are not noticeably faster than our 3%-space combination. Only
structure RG 37% is considerably faster, yet it requires 10 times more space.
Structure RG 1Level achieves a performance very similar to that of our new
structure, as expected.

For select, however, RG 1Level performs poorly. Other structures that do
not achieve better time than our 3%-space combination, while using much more
space, are rank9b, rank9sel, RG37%, Sada dense, and Clark. The best performance,
 still not competitive with ours, is that of simple-select. This one reaches
similar time, but 2–3 times more space than our 3%-space combination.

Mixed Queries In this experiment we use bitmap density 50% and execute
mixed queries, which combine rank and select, to mimic applications that need
both of them. We try rank/select proportions of 90%/10%, 70%/30%, 50%/50%,
and 30%/70%. We include a variant of our structure with the same value for both
samplings, Sr = Ss. The results are shown in Fig. 3 (see also Footnote 3).

304

G. Navarro and E. Providel

(cid:4)(cid:2)(cid:28)(cid:1)(cid:23)(cid:14)(cid:29)(cid:14)(cid:16)(cid:27)(cid:1)(cid:30)(cid:1)(cid:31)(cid:2)(cid:28)(cid:1)(cid:32)(cid:25)(cid:20)(cid:33)(cid:1)(cid:34)(cid:35)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:36)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:37)(cid:1)(cid:8)(cid:2)(cid:28)(cid:36)(cid:1)(cid:19)(cid:12)(cid:38)(cid:14)(cid:1)(cid:5)(cid:39)(cid:5)(cid:40)

(cid:6)(cid:2)(cid:30)(cid:1)(cid:25)(cid:16)(cid:31)(cid:16)(cid:18)(cid:29)(cid:1)(cid:32)(cid:1)(cid:10)(cid:2)(cid:30)(cid:1)(cid:33)(cid:27)(cid:22)(cid:34)(cid:1)(cid:35)(cid:36)(cid:16)(cid:19)(cid:14)(cid:16)(cid:21)(cid:37)(cid:1)(cid:28)(cid:14)(cid:29)(cid:15)(cid:27)(cid:26)(cid:1)(cid:23)(cid:16)(cid:22)(cid:21)(cid:14)(cid:29)(cid:38)(cid:1)(cid:8)(cid:2)(cid:30)(cid:37)(cid:1)(cid:21)(cid:14)(cid:39)(cid:16)(cid:1)(cid:5)(cid:40)(cid:5)(cid:11)

(cid:23)(cid:17)(cid:41)(cid:5)(cid:8)(cid:9)(cid:36)(cid:1)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:23)(cid:17)(cid:41)(cid:8)(cid:4)(cid:5)(cid:36)(cid:1)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:23)(cid:17)(cid:41)(cid:4)(cid:2)(cid:5)(cid:7)(cid:36)(cid:1)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:23)(cid:17)(cid:41)(cid:5)(cid:2)(cid:7)(cid:40)(cid:36)(cid:1)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:23)(cid:17)(cid:41)(cid:7)(cid:2)(cid:31)(cid:9)(cid:36)(cid:1)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:23)(cid:17)(cid:41)(cid:40)(cid:4)(cid:31)(cid:5)(cid:36)(cid:1)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:23)(cid:17)(cid:41)(cid:23)(cid:19)(cid:41)(cid:5)(cid:8)(cid:9)(cid:42)(cid:40)(cid:4)(cid:31)(cid:5)
(cid:43)(cid:12)(cid:44)(cid:20)(cid:25)(cid:1)(cid:17)(cid:25)(cid:20)(cid:33)(cid:31)(cid:19)(cid:14)(cid:29)
(cid:43)(cid:12)(cid:44)(cid:20)(cid:25)(cid:1)(cid:17)(cid:25)(cid:20)(cid:33)(cid:31)(cid:26)
(cid:23)(cid:25)(cid:21)(cid:25)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:14)
(cid:32)(cid:45)(cid:1)(cid:4)(cid:46)(cid:14)(cid:47)(cid:14)(cid:29)
(cid:32)(cid:45)(cid:1)(cid:6)(cid:10)(cid:28)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:8) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:8) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:8) (cid:1)(cid:2)(cid:3)(cid:6) (cid:1)(cid:2)(cid:3)(cid:6)(cid:8) (cid:1)(cid:2)(cid:3)(cid:7) (cid:1)(cid:2)(cid:3)(cid:7)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:8)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:9)(cid:2)(cid:28)(cid:1)(cid:23)(cid:14)(cid:29)(cid:14)(cid:16)(cid:27)(cid:1)(cid:30)(cid:1)(cid:9)(cid:2)(cid:28)(cid:1)(cid:31)(cid:25)(cid:20)(cid:32)(cid:1)(cid:33)(cid:34)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:35)(cid:1)(cid:26)(cid:12)(cid:27)(cid:13)(cid:25)(cid:24)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:27)(cid:36)(cid:1)(cid:9)(cid:2)(cid:28)(cid:35)(cid:1)(cid:19)(cid:12)(cid:37)(cid:14)(cid:1)(cid:4)(cid:38)(cid:4)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:8)(cid:3)(cid:4)

(cid:1)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:22)
(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:1)(cid:2)(cid:3)(cid:12)

(cid:1)(cid:2)(cid:3)(cid:11)

(cid:1)(cid:2)(cid:3)(cid:10)

(cid:1)(cid:2)(cid:3)(cid:9)

(cid:1)(cid:2)(cid:3)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:8)(cid:3)(cid:5)

(cid:1)(cid:8)(cid:3)(cid:4)

(cid:1)(cid:8)

(cid:1)(cid:2)(cid:3)(cid:7)

(cid:1)(cid:2)(cid:3)(cid:6)

(cid:1)(cid:2)(cid:3)(cid:5)

(cid:1)(cid:2)(cid:3)(cid:4)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:8) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:8) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:8) (cid:1)(cid:2)(cid:3)(cid:6) (cid:1)(cid:2)(cid:3)(cid:6)(cid:8) (cid:1)(cid:2)(cid:3)(cid:7) (cid:1)(cid:2)(cid:3)(cid:7)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:8)

(cid:25)(cid:26)(cid:27)(cid:18)(cid:16)(cid:1)(cid:17)(cid:28)(cid:14)(cid:29)(cid:21)(cid:1)(cid:26)(cid:16)(cid:19)(cid:1)(cid:28)(cid:14)(cid:29)(cid:24)

(cid:28)(cid:2)(cid:29)(cid:1)(cid:22)(cid:14)(cid:30)(cid:14)(cid:16)(cid:26)(cid:1)(cid:31)(cid:1)(cid:10)(cid:2)(cid:29)(cid:1)(cid:32)(cid:24)(cid:20)(cid:33)(cid:1)(cid:34)(cid:35)(cid:14)(cid:17)(cid:12)(cid:14)(cid:19)(cid:36)(cid:1)(cid:25)(cid:12)(cid:26)(cid:13)(cid:24)(cid:23)(cid:1)(cid:21)(cid:14)(cid:20)(cid:19)(cid:12)(cid:26)(cid:37)(cid:1)(cid:9)(cid:2)(cid:29)(cid:36)(cid:1)(cid:19)(cid:12)(cid:38)(cid:14)(cid:1)(cid:4)(cid:39)(cid:4)(cid:7)

(cid:24)
(cid:21)
(cid:23)
(cid:22)
(cid:20)
(cid:18)
(cid:16)
(cid:21)
(cid:20)
(cid:19)
(cid:18)
(cid:14)
(cid:15)

(cid:17)
(cid:1)
(cid:16)
(cid:15)
(cid:13)

(cid:14)

(cid:19)
(cid:21)
(cid:20)
(cid:18)
(cid:16)
(cid:14)
(cid:19)
(cid:18)
(cid:17)
(cid:16)
(cid:12)
(cid:13)

(cid:15)
(cid:1)
(cid:14)
(cid:13)
(cid:11)

(cid:12)

(cid:1)(cid:2)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:9) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:9) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:9) (cid:1)(cid:2)(cid:3)(cid:10) (cid:1)(cid:2)(cid:3)(cid:10)(cid:9) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9)(cid:9)

(cid:1)(cid:2)

(cid:1)(cid:2)

(cid:1)(cid:2)(cid:3)(cid:2)(cid:9) (cid:1)(cid:2)(cid:3)(cid:8) (cid:1)(cid:2)(cid:3)(cid:8)(cid:9) (cid:1)(cid:2)(cid:3)(cid:4) (cid:1)(cid:2)(cid:3)(cid:4)(cid:9) (cid:1)(cid:2)(cid:3)(cid:10) (cid:1)(cid:2)(cid:3)(cid:10)(cid:9) (cid:1)(cid:2)(cid:3)(cid:5) (cid:1)(cid:2)(cid:3)(cid:5)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9) (cid:1)(cid:2)(cid:3)(cid:9)(cid:9)

(cid:23)(cid:24)(cid:25)(cid:16)(cid:14)(cid:1)(cid:15)(cid:26)(cid:12)(cid:27)(cid:19)(cid:1)(cid:24)(cid:14)(cid:17)(cid:1)(cid:26)(cid:12)(cid:27)(cid:22)

(cid:22)(cid:23)(cid:24)(cid:16)(cid:14)(cid:1)(cid:15)(cid:25)(cid:12)(cid:26)(cid:19)(cid:1)(cid:23)(cid:14)(cid:17)(cid:1)(cid:25)(cid:12)(cid:26)(cid:27)

Fig. 3. Performance of mixed rank/select queries. Time is measured in µsec per query
and space in extra bits per bit of the bitmap.

It can be seen that, as soon as we have more than 10% of select queries,
our new structures become unparalleled. This is because operation select is, in
other structures, much slower than rank, and therefore a small fraction of those
queries aﬀects the overall time. Our structures, on the other hand, retain a
performance close to 0.2 µsec within 3% of extra space, achieved with Sr = 1024
and Ss = 8192. The variant using the same value for both samples is usually
suboptimal: Spending more space on the rank sampling pays oﬀ.

5.3 Applications

We illustrate the many applications of rank/select data structures with two
examples. In the ﬁrst one, we use our compressed representation to reimplement 
an FM-index [4]. This is a data structure that represents a text collection 
in compressed form and oﬀers search capabilities on it. Its most practical
and compact implementation [3] uses a Huﬀman-shaped tree storing at most
n(H0(T ) + 1) bits, and those bits are represented in compressed form. The FMindex 
can count the number of occurrences of a pattern P in T via a number
of rank operations over the bitmaps. We took this FM-index implementation
from http://libcds.recoded.cl, and compared this implementation with one
where we changed the compressed bitmaps to our new implementation. We indexed 
the 50 MB English text from http://pizzachili.dcc.uchile.cl and
searched for 50,000 patterns of length 20 extracted at random from the text.

As Fig. 4 (left) shows, our index with b = 63 is slightly slower than the original,
but still it counts in 90 µsec using 0.28 bits per bit, whereas the original one

Fast, Small, Simple Rank/Select on Bitmaps

305

needs 0.335 bits per bit to achieve the same time. That is, we reduce the space by
around 16%. Indeed, we achieve the least space ever reported for an FM-index
for this text (the results on other texts were similar).

Our second experiment uses a recent benchmark on compact representations
of general trees of n nodes, using 2n+o(n) bits [1]. They showed that LOUDS [9]
was one of the best performers, if its limited functionality was suﬃcient. LOUDS
simulates various tree operations (like going to the parent, to the i-th child, etc.)
via rank/select queries on the 2n bits that describe the tree topology.

We consider their 72-million node “suﬃx tree” [1] and, following their experimental 
setup, choose 33,000 random nodes with 5 children or more, and carry out
the operation that ﬁnds the 5th child. Fig. 4 (right) shows the eﬀect of replacing
the rank/select structure used in LOUDS with our combined sampled structure
(using various samplings in the range Sr = [512, 2048] and Ss = [1024, 32768]).
As it can be seen, LOUDS is much better than the alternatives, and we improve
RG-based LOUDS as soon as we use 3% of extra space or more, reaching an
improvement of up to 20% when using the same space.

(cid:30)(cid:20)(cid:31)(cid:22)(cid:29)(cid:1)(cid:32)(cid:31)(cid:16)(cid:19)(cid:14)(cid:16)(cid:21)

(cid:30)(cid:31)(cid:14)(cid:32)(cid:23)(cid:17)(cid:14)(cid:24)(cid:1)(cid:33)(cid:34)(cid:16)(cid:19)(cid:14)(cid:16)(cid:21)

(cid:24)
(cid:21)
(cid:23)
(cid:22)
(cid:20)
(cid:18)
(cid:16)
(cid:21)
(cid:20)
(cid:19)
(cid:18)
(cid:14)
(cid:15)

(cid:17)
(cid:1)
(cid:16)
(cid:15)
(cid:13)

(cid:14)

(cid:33)(cid:19)(cid:14)(cid:34)(cid:14)(cid:22)(cid:27)(cid:35)(cid:1)(cid:17)(cid:36)(cid:36)(cid:36)(cid:24)
(cid:28)(cid:37)(cid:7)(cid:12)
(cid:28)(cid:37)(cid:11)(cid:7)
(cid:28)(cid:37)(cid:5)(cid:11)

(cid:1)(cid:7)(cid:6)(cid:2)
(cid:1)(cid:7)(cid:5)(cid:2)
(cid:1)(cid:7)(cid:4)(cid:2)
(cid:1)(cid:7)(cid:3)(cid:2)
(cid:1)(cid:7)(cid:2)(cid:2)
(cid:1)(cid:6)(cid:2)
(cid:1)(cid:5)(cid:2)
(cid:1)(cid:4)(cid:2)
(cid:1)(cid:3)(cid:2)
(cid:1)(cid:2)
(cid:1)(cid:2)(cid:8)(cid:3)(cid:5) (cid:1)(cid:2)(cid:8)(cid:3)(cid:9) (cid:1)(cid:2)(cid:8)(cid:3)(cid:6) (cid:1)(cid:2)(cid:8)(cid:3)(cid:10) (cid:1)(cid:2)(cid:8)(cid:11) (cid:1)(cid:2)(cid:8)(cid:11)(cid:7) (cid:1)(cid:2)(cid:8)(cid:11)(cid:3) (cid:1)(cid:2)(cid:8)(cid:11)(cid:11) (cid:1)(cid:2)(cid:8)(cid:11)(cid:4) (cid:1)(cid:2)(cid:8)(cid:11)(cid:12) (cid:1)(cid:2)(cid:8)(cid:11)(cid:5) (cid:1)(cid:2)(cid:8)(cid:11)(cid:9)

(cid:25)(cid:26)(cid:27)(cid:18)(cid:16)(cid:1)(cid:17)(cid:28)(cid:14)(cid:29)(cid:21)(cid:1)(cid:26)(cid:16)(cid:19)(cid:1)(cid:28)(cid:14)(cid:29)(cid:24)

(cid:24)
(cid:21)
(cid:23)
(cid:22)
(cid:20)
(cid:18)
(cid:16)
(cid:21)
(cid:20)
(cid:19)
(cid:18)
(cid:14)
(cid:15)

(cid:17)
(cid:1)
(cid:16)
(cid:15)
(cid:13)

(cid:14)

(cid:1)(cid:2)(cid:3)(cid:12)
(cid:1)(cid:2)(cid:3)(cid:11)
(cid:1)(cid:2)(cid:3)(cid:10)
(cid:1)(cid:2)(cid:3)(cid:9)
(cid:1)(cid:2)(cid:3)(cid:8)
(cid:1)(cid:2)(cid:3)(cid:7)
(cid:1)(cid:2)(cid:3)(cid:6)
(cid:1)(cid:2)(cid:3)(cid:5)
(cid:1)(cid:2)(cid:3)(cid:4)
(cid:1)(cid:2)

(cid:35)(cid:36)(cid:37)(cid:38)(cid:38)
(cid:39)(cid:38)(cid:40)(cid:39)(cid:25)(cid:37)(cid:38)(cid:38)
(cid:41)(cid:42)(cid:40)(cid:39)(cid:25)(cid:37)(cid:43)(cid:44)
(cid:41)(cid:42)(cid:40)(cid:39)(cid:25)(cid:37)(cid:42)(cid:34)(cid:19)(cid:21)

(cid:1)(cid:5)

(cid:1)(cid:5)(cid:3)(cid:2)(cid:8)

(cid:1)(cid:5)(cid:3)(cid:4)

(cid:1)(cid:5)(cid:3)(cid:5)

(cid:1)(cid:5)(cid:3)(cid:4)(cid:8)
(cid:1)(cid:5)(cid:3)(cid:5)(cid:8)
(cid:25)(cid:26)(cid:27)(cid:18)(cid:16)(cid:1)(cid:17)(cid:28)(cid:14)(cid:29)(cid:21)(cid:1)(cid:26)(cid:16)(cid:19)(cid:1)(cid:22)(cid:20)(cid:23)(cid:16)(cid:24)

(cid:1)(cid:5)(cid:3)(cid:6)

(cid:1)(cid:5)(cid:3)(cid:6)(cid:8)

(cid:1)(cid:5)(cid:3)(cid:7)

Fig. 4. On the left, counting on the FM-index. On the right, operation child on suﬃx
trees. Time is measure in µsec per query, and space in overall number of bits per bit
of the plain encoding of the sequence.

6 Conclusions

We have introduced two new techniques that aim at solving two recurrent problems 
in rank/select data structures: (1) too much space overhead, (2) bad performance 
for select. We have achieved (i) a structure for compressed bitmaps that
retains the performance of existing ones, but reduces their space overhead by
50%–60%, reaching just 0.1 bit of space overhead over the entropy and solving
rank in about 0.4 µsec and select in about 1 µsec; and (ii) a structure for plain
bitmaps that combines rank/select data in a way that achieves just 3% of extra
space and solves both operations in about 0.2 µsec, very far from the current
space/time tradeoﬀs. In additions, our structures are rather simple.

These are two very relevant improvements that will ﬁnd immediate applications.
 We have already illustrated one application to compressed text indexes
and another to compact representations of trees.

306

G. Navarro and E. Providel

Our data structures could perform slower for select if the bitmap had very long
areas without 1s, even if we would traverse then fast using the Sr sampling. For
such long areas we could apply the basic idea of Clark [2] and store the precomputed
select answers inside. This requires insigniﬁcant extra space if applied on very long
blocks. Also, in order to support select0 we could add another sparse sampling using
Ss (recall that in the recommended setup this stores just one integer every 8192
positions, so doubling this sampling impacts very little). Finally, it is natural to
combine our two ideas into a single index for compressed bitmaps: right now our
compressed representation carries out select by binary searching the superblocks.
Our combined structure could speed this up to the times for rank, which are around
0.4 µsec on the compressed structure. This is our future work plan.

References

1. Arroyuelo, D., C´anovas, R., Navarro, G., Sadakane, K.: Succinct trees in practice.

In: Proc. 11th ALENEX, pp. 84–97 (2010)

2. Clark, D.: Compact Pat Trees. PhD thesis, University of Waterloo, Canada (1996)
3. Claude, F., Navarro, G.: Practical Rank/Select Queries over Arbitrary Sequences.
In: Amir, A., Turpin, A., Moﬀat, A. (eds.) SPIRE 2008. LNCS, vol. 5280, pp.
176–187. Springer, Heidelberg (2008)

4. Ferragina, P., Manzini, G.: Indexing compressed texts. Journal of the ACM 52(4),

552–581 (2005)

5. Golynski, A.: Optimal Lower Bounds for Rank and Select Indexes. In: Bugliesi,
M., Preneel, B., Sassone, V., Wegener, I. (eds.) ICALP 2006. LNCS, vol. 4051, pp.
370–381. Springer, Heidelberg (2006)

6. Golynski, A., Munro, I., Rao, S.: Rank/select operations on large alphabets: a tool

for text indexing. In: Proc. 17th SODA, pp. 368–373 (2006)

7. Gonz´alez, R., Grabowski, S., M¨akinen, V., Navarro, G.: Practical implementation

of rank and select queries. In: Proc. 4th WEA, pp. 27–38 (2005) (posters)

8. Grossi, R., Gupta, A., Vitter, J.: High-order entropy-compressed text indexes. In:

Proc. 14th SODA, pp. 841–850 (2003)

9. Jacobson, G.: Space-eﬃcient static trees and graphs. In: Proc. 30th FOCS, pp.

549–554 (1989)

10. Munro, I.: Tables. In: Chandru, V., Vinay, V. (eds.) FSTTCS 1996. LNCS,

vol. 1180, pp. 37–42. Springer, Heidelberg (1996)

11. Munro, I., Raman, V.: Succinct representation of balanced parentheses, static trees

and planar graphs. In: Proc. 38th FOCS, pp. 118–126 (1997)

12. Okanohara, D., Sadakane, K.: Practical entropy-compressed rank/select dictionary.

In: Proc. 9th ALENEX (2007)

13. Pagh, R.: Low Redundancy in Static Dictionaries with O(1) Worst Case Lookup
Time. In: Wiedermann, J., Van Emde Boas, P., Nielsen, M. (eds.) ICALP 1999.
LNCS, vol. 1644, pp. 595–604. Springer, Heidelberg (1999)

14. Patrascu, M.: Succincter. In: Proc. 49th FOCS, pp. 305–313 (2008)
15. Raman, R., Raman, V., Rao, S.: Succinct indexable dictionaries with applications

to encoding k-ary trees and multisets. In: Proc. 13th SODA, pp. 233–242 (2002)
16. Vigna, S.: Broadword Implementation of Rank/Select Queries. In: McGeoch, C.C.

(ed.) WEA 2008. LNCS, vol. 5038, pp. 154–168. Springer, Heidelberg (2008)

