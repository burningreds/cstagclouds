Property Patterns for Runtime Monitoring of

Web Service Conversations(cid:2)

Jocelyn Simmonds1, Marsha Chechik1, Shiva Nejati1,

Elena Litani2, and Bill O’Farrell2

1 University of Toronto, Toronto ON M5S3G4, Canada

{jsimmond,chechik,shiva}@cs.toronto.edu

2 IBM Toronto Lab, Markham ON L6G 1C7, Canada

{elitani,billo}@ca.ibm.com

Abstract. For a system of distributed processes, correctness can be ensured 
by statically checking whether their composition satisﬁes the properties 
of interest. However, web services are distributed processes that
dynamically discover properties of other web services. Since the overall
system may not be available statically and since each business process
is supposed to be relatively simple, we propose to use runtime monitoring 
of conversations between partners as a means of checking behavioral
correctness of the entire web service system. Speciﬁcally, we identify a
subset of UML 2.0 Sequence Diagrams (SD) as a property speciﬁcation
language. We show how our language can be used to specify the patterns
in the Speciﬁcation Property System (SPS) [1]. By formalizing this subset 
using automata, we can check ﬁnite execution traces of web services
against various complex properties. Finally, we discuss our experience
using our language for runtime monitoring of an existing application,
and conclude with a description of existing tool support.

1 Introduction

Web services are collections of components which discover and bind to other
components using published interfaces, with support of Service-Oriented Architectures 
(SOA). The goal of SOA is to increase the ﬂexibility of business interactions.
 Each web service component can be written in a traditional compiled
language such as Java R(cid:2), or in an XML-centric language such as BPEL [2].
Consider, for example, a web-based Loan Application system (LA), distributed
as a sample application with the IBM R(cid:2) Websphere R(cid:2) Integration Developer v6.0.2.
Users enter loan application information (name, taxpayer id, loan amount) through
a web page, and are eventually informed of the status of their applications. The LA
workﬂow ﬁrst checks the user’s credit score and declines a loan if the user has a bad
credit score, i.e., less than 750. If the credit score is good, the workﬂow then checks
the loan amount: loans for $50,000 or less are automatically approved; loans for
larger amounts are earmarked for manual approval.
(cid:2) c(cid:2) Copyright 2008, International Business Machines. All Rights Reserved.

M. Leucker (Ed.): RV 2008, LNCS 5289, pp. 137–157, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008

138

J. Simmonds et al.

(a)

(b)

Fig. 1. The LA system: (a) workﬂow, describing the high level steps of the LA system;
(b) assembly diagram, describing how the main process of the LA system interacts
with its partners

The workﬂow diagram in Fig. 1(a), which is described as a BPEL speciﬁcation,
shows high level steps that are executed in a loan application system, and Fig. 1(b)
shows an assembly diagram describing how the main process of the LA system
invokes its partners, such as CreditCheck (implemented in Java), rule groups
(LoanLimit), or human tasks (FollowUpDeclinedApp, CompleteTheLoan and
ProcessTheAppli− cation). Speciﬁcally, the CheckCredit activity in Fig. 1(a)
invokes the CreditCheck partner in Fig. 1(b), and the conditional activities
ScoreEvaluation and AutoApproval− Test invoke the LoanLimit partner. The
partners in Fig. 1(b) implement the following functions: CreditCheck uses the
taxpayer id to retrieve the corresponding credit score; the LoanLimit rule group
checks the credit score and the loan amount. The human tasks CompleteTheLoan,
ProcessApplication and FollowUp follow the application results Approved,
ManualApproval and Declined, respectively.

Since the LA system is a composition of several distributed business processes,
its correctness depends on the correctness of its partners and their interactions.
For example, the system should guarantee that every request is eventually acknowledged 
and none are lost or blocked indeﬁnitely, or that loans are only given
to customers with a good credit score. However, in the provided LA application,
the CreditCheck module assigns a credit score at random, without using the
customer id, thus preventing the overall system from satisfying this property.

Property Patterns for Runtime Monitoring of Web Service Conversations

139

Table 1. Some properties of the LA system

P1 The loan amount must be always greater than zero.
P2 The credit score should eventually be checked if the loan amount is greater than zero.
P3 A loan cannot be granted if the loan amount is less than or equal to zero.
P4 After checking that the applicant has a good credit score, a loan cannot be granted

if the loan amount is less than or equal to zero.

P5 Noone can get a loan without ﬁrst going through a credit check.

Since each web service is a relatively simple process, analysis can concentrate
on the message exchange between partners – their conversations. While static
techniques for checking partner composition against properties of interest, such
as [3,4,5,6,7], are appealing, they have a number of limitations: the problem is
decidable only under certain conditions [8], since the partners communicate via
inﬁnite-sized channels, and existing techniques are unable to deal with complex
message interactions and heterogeneity of partners.

Instead, we concentrate on the dynamic analysis via runtime monitoring. This
approach has been shown eﬀective for the webservice domain [9,10,11]. Our
goal is to build on the success of this technique to create an industrial-strength
(with partnership with the IBM Toronto Lab) monitoring framework that is
non-intrusive, supports the dynamic discovery of web services, deals with synchronous 
and asynchronous communication and partners implemented in different 
languages, allows for specifying and eﬃcient monitoring of a variety of
temporal behaviour, and is usable by practitioners.

In [12], we chose a subset of UML 2.0 Sequence Diagrams [13] as our speciﬁcation 
language. This language allows speciﬁcation of events, has an explicit
emphasis on components, and is able to deal with positive and negative scenarios 
of interaction as well as global properties. We have shown that this subset is
suﬃciently expressive for capturing safety (nothing bad can ever happen) and
liveness (something good will eventually happen) properties. For example, for
the LA system described earlier, possible safety and liveness properties are P1
and P2, respectively (see Table 1). While liveness properties are not monitorable
in general, they can be eﬀectively checked for web services with ﬁnitely terminating 
behaviours. For example, we can check whether the LA process terminates
without giving feedback to the customer. Speciﬁcally, for ﬁnite behaviours, liveness 
can be seen as the dual of safety: liveness properties are expressed as ﬁnite
positive traces, and safety properties as ﬁnite negative traces.

To enable monitoring, [12] formalized the chosen subset of Sequence Diagrams
using ﬁnite-state automata. These automata are then used in the implementation 
of our non-intrusive monitoring framework which runs in parallel with the
system being monitored, intercepting events from web service conversations. The
resulting system enables conformance checking of ﬁnite execution traces against
their speciﬁcations expressed in our subset of Sequence Diagrams.

In [12], we showed that assert and negate operators in UML 2.0 [13] can be
used to describe simple safety and liveness properties, namely, invariants, e.g.,
P1 in Table 1, and request-response properties, e.g., P2 in Table 1. However,

140

J. Simmonds et al.

in [12], we assumed that only one assert or negate operator can be applied to
a sequence diagram, always as the outermost operator. To conveniently specify 
and verify various system properties that arise in practice, e.g., P4 and P5
in Table 1, we need a more expressive language. In this paper, we extend this
language by allowing certain nested applications of assert and negate operators.
Furthermore, we enriched the language with several operators, adopted from
UML 2.0 [13] and other scenario-based languages [14]. Examples of these operators 
include critical, ref (which allows to reuse portions of sequence diagrams in
other diagrams) and message complementation. We show that the resulting language 
can not only be converted into ﬁnite-state automata for monitoring, but
is also suﬃciently expressive to capture a wide variety of frequently used properties,
 captured and catalogued in the Speciﬁcation Pattern System (SPS) [1].
This approach also gives basis for tool support to enable usable speciﬁcation of
runtime conversations.

The rest of this paper is organized as follows. We describe syntax of the subset 
of UML 2.0 sequence diagrams used for expressing properties of webservice
conversations in Section 2. Such properties are then converted into monitoring
automata using the techniques discussed in Section 3. We then show how our
speciﬁcation language can be used to specify the complete set of temporal logic
property patterns in Section 4. We describe the implementation of the runtime
monitoring framework and report on the result of applying our framework to
the LA system in Section 5. Finally, we conclude the paper in Section 6 with a
summary of the paper, comparison with related work, and an outline of future
research directions.

2 A Language for Specifying Conversations

We choose a subset of UML 2.0 Sequence Diagrams as our language for specifying 
web service conversations. Sequence Diagrams [13] is a popular formalism
for modeling behavioural scenarios by describing sequences of messages communicated 
between diﬀerent objects over time. Sequence Diagrams have two di-
mensions: vertical, representing time, and horizontal, representing objects. Each
object is illustrated by a rectangle with a vertical dashed line, called a lifeline.
Lifelines are connected by horizontal arrows denoting messages that are sent from
one object to another, synchronously or asynchronously. We refer to Sequence
Diagrams with these features as basic.

An example sequence diagram describing a scenario of the LA system is shown
in Fig. 2(a). The diagram contains three objects, MnPs, CtCk, and LnLt. Object
MnPs corresponds to the main workﬂow of the LA system, and CtCk and LnLt
correspond to components CreditCheck and LoanLimit, respectively. The diagram 
in Fig. 2(a) shows two alternative scenarios: In the ﬁrst alternative, MnPs
ﬁrst sends a check credit score request, i.e., ckCtSe, to CtCk and then a check
loan amount request, i.e., ckLnAt, to LnLt. In the second alternative, LnLt receives 
a check loan amount request from MnPs. Since the credit score has not yet
been checked, LnLt sends a check credit score request to CtCk.

Property Patterns for Runtime Monitoring of Web Service Conversations

141

SD Basic
consider

{ckLnAt,ckCtSe,ckTrID}

MnPs

CtCk

LnLt

alt

ckCtSe

ckLnAt

ckLnAt

ckCtSe

(a)

?ckCtSe

q0

!ckCtSe

q1

!ckLnAt

q2

q3

!ckLnAt

?ckCtSe

q4

q5

?ckLnAt

q6

?ckCtSe

?ckLnAt

(b)

Fig. 2. (a) An SD describing a scenario of the LA example; and (b) the NFA corresponding 
to the ﬁrst argument of the alt operator in Fig 2(a)

Basic Sequence Diagrams can be augmented by a number of operators to
capture more sophisticated scenarios. We use the operators described below in
our property speciﬁcation language, and refer to our language as SD.
Compositional operators: Operators parallel (par) and alternatives (alt) are
used to compute intersection and union of two SDs, respectively. The operator 
loop is used for repeating the scenario described by an SD multiple
times, opt – for denoting an optional scenario, equivalent to alt with only
one argument.

Alphabet changing operators: Operators consider and ignore are used for

modifying the communicating alphabet of SDs.

Critical operator: The critical operator is used to ensure atomicity of the

enclosed sequence.

Assertion and negation operators: Operators assert and negate allow users

to express mandatory and forbidden system scenarios, respectively.

Interaction use operator: SDs can be shared by references, using the ref operator.
 This is a shorthand for copying the contents of the referred SD where
the ref operator occurs, and is a new feature in UML 2.0.
To describe system scenarios, we often need to express complementation of an
individual message or a set of messages appearing on the same arrow. The negate
operator is unsuitable for this: it captures negative sequences of messages rather
than set complementation. Instead, we use the message complementation operator,
originally introduced in the Property Sequence Charts (PSC) language [14]. We
denote the complement of a message m by¬m and deﬁne it as the set of all messages
that are potentially exchanged between objects of the system except for m.

Basic Sequence Diagrams, denoted BasicSDs, are the building blocks of our
language. The critical, alphabet changing, interaction use, assert, and compositional 
operators, except for par, can be intermixed and applied any number of
times to BasicSDs. The use of negate and par operators, however, is restricted
to sequence diagrams which do not use an assert operator. We discuss this assumption 
and the rationale behind it in Section 3.1 and show in Section 4 that
even with this restriction, the resulting language remains very expressive.

142

J. Simmonds et al.

SD ::= BasicSD | unaryOp SD | SD alt SD | assert SD |

NotAssertedSD par NotAssertedSD | negate NotAssertedSD |
NotAssertedSD ::= BasicSD | unaryOp NotAssertedSD | negate NotAssertedSD |
NotAssertedSD alt NotAssertedSD |
NotAssertedSD par NotAssertedSD

unaryOp ::= consider E | ignore E | loop | critical | opt | ref

Fig. 3. Grammar of the SD language

The grammar for our language, SD, is given in Fig. 3 where BasicSD, par,
alt, loop, critical, opt, negate, assert, consider, ignore and ref are terminal
symbols, and E is a set of SD messages. Since operators consider and ignore
change the communicating alphabet of SDs, they take a set E of messages as an
input argument. In what follows, we denote by SD the set of Sequence Diagrams
generated by the above grammar.

3 From SDs to Automata

We deﬁne the formal semantics of SD by translating it into non-deterministic
ﬁnite automata (NFAs), following the approach of [15]. This translation allows
us to not only formalize our language but also to study its expressiveness. Specifically,
 in [12], we have shown that certain scenarios in SD can be captured by
particular forms of NFAs known as Safe and Live automata [16], indicating
that SD is capable of expressing safety and liveness properties. In what follows,
we brieﬂy review the translation of basic sequence diagrams and the operators
described in Section 2 into NFA. We then discuss that the negate and assert
operators allow us to express safety and liveness properties, respectively.

Basic sequence diagrams, i.e, diagrams describing a sequence of events without
any additional operator, can be translated into NFAs using the procedure in [15].
Consider the scenario in the ﬁrst argument of the alt operator in Fig 2(a). This
basic sequence diagram shows that MnPs ﬁrst sends event ckCtSe to CtCk and
then event ckLnAt to LnLt. We denote the sending of a message m by !m and its
receiving by ?m. Thus, the set of events of the sequence diagram in Fig. 2(a) is
{!ckCtSe, ?ckCtSe, !ckLnAt, ?ckLnAt}. Intuitively, lifelines and message arrows
in a sequence diagram deﬁne a partial order on the set of events of that diagram.
Given a basic sequence diagram S, an NFA AS is equivalent to S iﬀ AS accepts
exactly the set of traces that respect the partial order of S. For example, the
automaton AS corresponding to the scenario in the ﬁrst argument of the alt
operator in Fig 2(a) is shown in Fig 2(b).

The semantics of the compositional operators can be given in terms of the
standard operations deﬁned on NFAs (e.g., see [17]). For example, alt corresponds 
to the union operator and loop corresponds to the Kleene star operator.
Operators consider and its dual, ignore, are used to change the set of communicating 
alphabets of an SD. Both of them receive an SD S and a set of events E
as input, but consider adds the elements in E to the set of events of S, whereas
ignore removes the elements in E from the set of events of S.

Property Patterns for Runtime Monitoring of Web Service Conversations

143

a

b

critical

s

t

(a)

q0

!s

q1

!t

?s

q2

?s

q4

q2

?s

q4

?t

?t

q6

q0

!s

q1

Σ\ {!s}

!t

?s

?t

q6

?t

Σ

q3

q5

!t

(c)

q3

q5

!t

(b)

Fig. 4. (a) A basic SD enclosed by a critical operator and its corresponding NFAs: (b)
before applying critical ; (c) after applying critical

a

b

 {p,q}

(a)

a

alt

s

t

(b)

b

q2

?s

q4

q0

!s

!t

q1

?t

q3

(c)

Fig. 5. (a) An SD with message complementation; (b) the same SD after eliminating 
the complement operator, if the underlying alphabet Σ is {p, q, s, t}; and (c) its
corresponding NFA.

We can specify a critical region in a sequence diagram using the critical operator.
 A critical region means that the traces of the region cannot be interleaved
by other messages and thus should be treated atomically. We treat this operator
to mean that if the ﬁrst message of the critical region is observed, then the rest
of the behavior must be observed as well.

For a sequence enclosed by a critical operator, once the ﬁrst symbol of the
sequence has been seen, the entire sequence should be seen as well. For this
reason, the self-loop at the initial state of an automaton corresponding to a critical 
region is labelled by Σ minus the initial symbols of the expected sequences.
For example, Fig. 4(a) shows a sequence diagram with a critical operator, and
Fig. 4(c) – its corresponding automaton.

The operator ref is used for sharing portions of SDs between several others.
Our treatment of ref is to inline the SD being referenced, applying the necessary
translation rules to the result in order to obtain the corresponding NFA, as
illustrated in Fig. 6.
The message complement operator has been adopted from [14]. If Σ is the
set of messages exchanged in an SD, and m ∈ Σ, then ¬m is Σ \ {m}. For a
set {m, n} of messages, ¬{m, n} = Σ \ {m, n}. For example, let Σ = {p, q, s, t}.
Then, ¬p = {q, s, t} and ¬{p, q} = {s, t}.
This operator, although not being part of UML 2.0, can be expressed in terms
of UML operators as follows: Let S ⊆ Σ be a set of messages. We replace ¬S by
an SD fragment in which the operator alt is applied to individual messages in

144

J. Simmonds et al.

SD ex

a

ref

b

C

t

(a)

SD C

a

b

s

(b)

SD ex

a

b

s

t

(c)

q0

!s

q1

!t

?s

q2

?s

q4

q3

q5

!t

(d)

q6

?t

?t

Fig. 6. (a) An SD which references SD C; (b) SD C; (c) SD ex after copying the
content of SD C; and (d) its corresponding NFA
Σ \ S. For example, consider the SD in Fig. 5(a) with a message ¬{p, q}, and let
Σ = {s, t, p, q}. This SD is equivalent to the one in Fig. 5(b) where ¬{p, q} is
replaced by an alt fragment in which s and t are two alternative messages. The
NFA for the sequence diagram without message complement operators can be
generated in a straightforward way following the translation for the alt operator
(see Fig. 5(c)).

3.1 Assertion and Negation Operators

The negate operator provides a mechanism for specifying undesirable (negative)
scenarios, and the assert operator allows us to specify desirable (positive) scenarios.
 The former operator can be used to express safety properties, e.g., P1 in
Table 1, and the latter – ﬁnitary liveness properties, e.g., P2.

Various formal treatments of the semantics of the assert and negate operators
are given in the literature, e.g., [16,18,19]. These operators have a rich expressive
power, and yet their arbitrary combinations are not well understood. In particular,
 it is unclear whether negating an asserted scenario should mean that this
scenario is not required to occur or that its negation has to occur. In this section,
 we deﬁne the semantics of assert and negate operators in terms of NFAs.
Our formalization allows us to arbitrarily combine these operators as long as we
never attempt to apply a negate operator to a sequence diagram containing an
asserted fragment.

Representing safety properties. The negate operator over SDs is equivalent
to the complementation operator of NFA. Given an SD S and its corresponding
automaton AS, we ﬁrst add a self-loop transition labeled Σ, i.e., the underlying
alphabet of S, to the initial state of AS in order to enable AS to guess when
a satisfying run begins. For example, Fig. 7(b) illustrates the automaton corresponding 
to the SD in Fig. 7(a) after adding this self-loop and before complementation.
 Note that after adding this self-loop, AS becomes non-deterministic.
To obtain the automaton for the negated SD, we need to ﬁrst determinize AS,
and then complement the result.

As mentioned above, negate allows us to express safety properties. By applying 
negate to a SD S, we indicate that the scenario represented by S is
a forbidden one, and therefore, a safe system should never produce this

Property Patterns for Runtime Monitoring of Web Service Conversations

145

SD Safe

MnPs

LnLt

CtCk

neg

ckLnAt

lnAtNO

(a)

q1

!ckLnAt

?ckLnAt

q3

?lnAtNO

q0

Σ

q2

!lnAtNO

(b)

q4

Σ

Fig. 7. (a) An SD describing P1 in Table 1 and its corresponding NFAs: (b) before
applying negate

scenario [16]. For example, Fig. 7(a) shows a negate operator applied to the sequence 
!ckLnAt.?ckLnAt.!lnAtNo.?lnAtNo, representing the safety property P1
in Table 1.

Representing liveness properties. The meaning of the assert operator is
given by the UML standard as follows [13], “the sequences of the operand are the
only valid continuations. All other continuations result in invalid behaviour”.
This interpretation has been formalized in diﬀerent ways [18,16]. The one that
we have adopted is that of [18] which is described as follows: given an asserted
behaviour σ = σ0 . . . σn and a system behaviour σ(cid:3), every occurrence of σ0 in σ(cid:3)
should be followed by the rest of σ. Thus, an SD with an assert is interpreted
universally: “for every run, once it satisﬁes the start of the sequence, it must
complete the sequence before termination”. Note that the diﬀerence between
assert and critical is that the former checks all possible suﬃxes of the input run
to probe the sequence, whereas the latter only checks the ﬁrst occurrence of its
sequence.

In [18], alternating automata with universal initial states are used to capture
this meaning of assert. Such automata accept a trace if all of the runs emanating
from their initial states are accepting. NFA, however, accept a trace when there
exists an accepting run emanating from the initial state. Rather than moving
outside NFA (and thus complicating the monitoring framework), we chose to
reinterpret the acceptance for the assert operator instead: an NFA for an asserted 
trace σ checks all suﬃxes of the system traces, and if one is not accepted,
a failure is reported. This “universal” treatment is given to the entire sequence
diagram, not just the part containing assert. This works correctly as long as such
NFAs are not complemented or composed (in parallel) – the negation and parallel 
composition operators over automata with universally interpreted acceptance
are diﬀerent from those operators of NFA. While negation and parallel composition 
operators for NFA are computed via subset construction and cross-product,
respectively, these operators for the alternating automata simply convert universal 
states into existential or add an additional universal state, respectively [20].
Thus, we restrict the application of negate and par to SDs that contain an assert
described in Section 2.

Since alternating automata can be converted into NFA with a possibly exponential 
blow-up in size, we could have translated the assert operator directly into

146

J. Simmonds et al.

SD Live

MnPs

assert

LnLt

CtCk

lnAtOk
ckCtSe

(a)

q1

!lnAtOk

?lnAtOk

q3

?ckCtSe

∧

q0

Σ

q2

!ckCtSe

(b)

q4

Σ

Fig. 8. (a) An SD describing P2 in Table 1 and its corresponding NFAs: (b) after
applying assert

NFA. However, we chose not to do it to preserve the succinctness and relatively
small size of our monitoring automata.

Given the above discussion, the translation of assert operator is straightfor-
ward: After deriving the NFA AS for SD S and adding a self-loop labelled Σ
at its initial state, the automaton for assert S is obtained by interpreting the
initial state as universal (we follow the notation of [18], denoting this state with
a “∧”) and making it accepting. For example, the SD in Fig. 8(a) describes the
liveness property P2 in Table 1 – the desirable scenario is enclosed in the scope
of an assert operator. Fig. 8(b) shows the automaton corresponding to this SD.

Complexity of the Translation. The size of an automaton AS corresponding
to a basic sequence diagram S is O(nk) where n is the number of events and k
is the number of processes [15]. Applying the sequence diagram operators does
not cause a signiﬁcant increase in the size of the resulting automata except for
the cases that involve a determinzation step which can be exponential in the
number of states of AS. However, we note that in practice, the automata we
have generated are relatively small, less than 9 states and 30 transitions [12].
Obviously, it remains to be seen whether the approach remains feasible for larger
web service systems and more complex properties.

4 SD Templates for Temporal Logic Property Patterns

In this section, we introduce several templates expressed in the SD language for
describing temporal logic property patterns [1]. We ﬁrst provide an overview of
these patterns in Section 4.1. We then describe our templates in the SD language
in Section 4.2 and show how they can encode the property patterns.

4.1 Temporal Logic Property Patterns

The Speciﬁcation Pattern System (SPS), proposed by Dwyer et al. [21], is a
pattern-based approach to the presentation, codiﬁcation, and reuse of property
speciﬁcations. The system allows patterns like “event P is absent between events
Q and S” or “S precedes P between Q and R” to be easily expressed in and

Property Patterns for Runtime Monitoring of Web Service Conversations

147

Property Patterns

Occurrence

Order

Absence
Universality
Existence
Bounded
Existence

Precedence
Response
Chain
Precedence
Chain
Response

Fig. 9. Pattern Hierarchy

Fig. 10. Pattern Scopes

translated between linear-time temporal logic (LTL) [22], computational tree
logic (CTL) [22] and other state-based and event-based formalisms. SPS has
been advocated as a standard tool for measuring the practical usefulness and
expressive power of speciﬁcation languages, e.g., [14] and [23].

The property patterns are organized into a hierarchy based on the kinds of
system behaviors they describe (see Fig. 9): Occurrence patterns talk about the
occurrence of a given event/state during system execution, and Order patterns
specify relative order in which multiple events/states occur during system execution.
 The patterns are described below in detail:
Absence
Existence
Bounded Existence An event can occur at most a certain number of times within a

An event does not occur within a given scope;
An event must occur within a given scope;

Universality
Response
Response Chain

given scope;
An event must occur throughout a given scope;
An event must always be followed by another within a scope;
A chain of events must always be followed by another chain of
events within a scope;
An event must always be preceded by another within a scope;

Precedence
Precedence Chain A chain of events must always be preceded by another chain of

events within a scope.

Each pattern is associated with scopes – the regions of interest over which the

pattern must hold. There are ﬁve basic kinds of scopes (depicted in Fig. 10):
Global
Before R
After Q
Between Q and R All parts of the execution between events Q and R;
After Q until R

The entire program execution;
The execution up to event R;
The execution after event Q;

Similar to between, except that the designated part of
the execution continues even if the second event does
not occur.

For example, consider a property that says between every enqueue and empty
messages, there must be a dequeue message. This property falls into the “Ex-
istence” pattern group because it indicates the occurrence of an event within a
scope. The scope of this property is that of “Between” shown in Fig 10. Looking

148

J. Simmonds et al.

SD absence

SD  response

SD until (p U q)

a

b

a

b

a

b

neg

p

(a) Absence

SD existence

a

b

assert

p

loop *

assert

p

s

(e) Response

SD response 2s − 1r

a

b

(b) Existence

loop *

critical

SD bounded existence

assert

s

t

p

a

b

assert

loop 0,2

neg

p

p

(f) Response Chain
2 stimulus - 1 response

(c) Bounded Existence

a

b

SD response 1s − 2r

SD universality

a

b

neg

p

loop *

assert

p

s

t

neg

alt

neg

loop 1,n

p

p

{p,q}

(h) Until

SD precedence

a

b

alt

ref

ref

absence p

until (  p U s)

(i) Precedence

SD

precedence 2c − 1e

a

b

alt

ref

absence

p

ref
until (  p U (s,t))

(d) Universality

(g) Response Chain
1 stimulus - 2 response

(j) Precedence Chain

2 cause - 1 eﬀect

Fig. 11. Property pattern mappings for SDs

Property Patterns for Runtime Monitoring of Web Service Conversations

149

up the LTL formalization of this pattern/scope combination from the catalogue 
and substituting our event names, we obtain the formula 2((enqueue ∧
¬empty) ⇒ (¬empty W (dequeue ∧ ¬empty))).

4.2 Mapping Property Patterns to SDs

In this section, we provide several SD templates for the SPS patterns (see
Fig. 11), and show how these tempolates are used to express patterns in the
SPS hierarchy. Selected mappings are described below; the remainder can be
found in Appendix A.
Absence: Message p cannot occur in a given scope. This can be expressed as

shown in Fig. 11(a).

Existence: Message p must occur in a given scope. This can be expressed as

shown in Fig. 11(b).
Until: This pattern is not part of the SPS; however, it is used to specify the
Precedence patterns. A sequence p∗ of messages occurs until the ﬁrst occurrence 
of message q, in a given scope (see Fig. 11 (h)). This pattern,
formalized using a single “until” temporal operator [22], can be refuted in
one of two ways: a) p never occurs, or b) after seeing a ﬁnite number of
p messages (expressed using loop 1, n in Fig 11(h)), neither a p nor a q
message occurs (expressed as ¬{p, q} in Fig 11(h)).

Precedence: Message s (cause) precedes message p (eﬀect), as shown in Fig. 11
(i). Note that this pattern allows the cause part to occur without the eﬀect
part. We describe this pattern in SD by expressing the two possible cases
that this pattern speciﬁes: a) p never occurs, or b) p never occurs before s.
The ﬁrst case corresponds to checking absence of p; the second – to checking
¬p U s, since we want to be sure that no p messages are sent before the ﬁrst
s message.

In the SDs in Fig. 11, symbols p, q, s, and t can denote more complex SDs,
not just individual messages. In this case, we treat these symbols as place holders 
and use a ref operator for the SDs that should be inserted in their place,
and replace message complementation by negation. In Section 4.4, we provide
detailed examples of how these patterns are used to specify properties of the LA
system.

4.3 Mapping Property Scopes

We now show how to express property patterns involving scopes which are used to
deﬁne the traces over which a property will be monitored. Scopes can be simple
messages or more complex scenarios in our speciﬁcation language. The ref operator 
is used to introduce scope delimiters in the corresponding locations. For
example, to apply the Before R scope to a property, the scope delimiter R is inserted 
after the property we wish to verify (see Fig. 12(a)). In the case of the After 
Q scope, the delimiter is inserted before the property (see Fig. 12(b)). Finally,
both the Between (see Fig. 12(c)) and the After-until (see Fig. 12(d)) scopes

150

J. Simmonds et al.

a

b

a

b

ref

ref

Property

R

(a)

ref

ref

Q

Property

(b)

a

b

a

b

ref

ref

ref

Q

Property

R

(c)

ref

ref

Q

Property

opt ref

R

(d)

Fig. 12. Scope mapping for sequence diagrams: (a) Before R; (b) After Q; (c) Between 
Q and R; and (d) After Q until R

add before/after delimiters. In the After-until scope, the property is valid even
if the “until” part does not occur. Therefore, the second delimiter in this scope is
optional. Thus, there is an implicit opt operator in each scope delimiter.

4.4 Specifying Properties of the Loan Application
The following examples show how property patterns can be used to specify example 
properties of the LA system given in Table 1. Properties P1 and P2 are
described in Figs 7 and 8, respectively. The rest of the properties in that table
are discussed below.

Property P3: “A loan cannot be granted if the loan amount is less than or
equal to zero.”

We express this property using the Absence pattern (see Fig. 11(a)): our
property holds if there are no scenarios where a loan is granted after the system 
has been warned that the loan amount is less than or equal to zero. In the
LA system, the LnLt component sends a loanAmountNotOkay (lnAtNO) message 
when the loan amount is less than or equal to zero. A loan is considered
granted if it is manually or automatically approved, which can be monitored
by checking if the main workﬂow MnPs sends a completeTheLoan (ceLn) or
processTheApplication (psAn) message. See Fig. 13(a) for the corresponding
SD; the resulting monitor is shown in Fig. 13(b).

SD P3

MnPs

LnLt

CtCk

CeLn

PsAn

neg

ckLnAt

alt

lnAtNO

ceLn

psAn

(a)

Σ\{!ckLnAt}

{

Σ \

! c k L n A t
! c k L n A t ,

?

c k L n A t }

!ckLnAt

q0

Σ\{!ckLnAt, !lnAtNO}

q2

!ckLnAt

q1

?ckLnAt

!
c
k
L
n
A
t

n
L
e
c
!

Σ\{!ckLnAt,?lnAtNO}

!
l

n

A

t

N

O

q3

?lnAtNO

q4

!csLn

q5

Σ
\
{
!
c
e
L
n
,
!
p
s
A
n
,
?
c
e
L
n
}

?ceLn

?
p

s

A

n

n

L

e

c
?

!psAn

Σ

q7

n
A
s
p
?

q6

!psAn

Σ\{!ceLn, !psAn, ?psAn}

Σ\{!ceLn, !psAn}

(b)

Fig. 13. P3: Absence pattern. (a) SD describing the LA property P3 and (b) the
resulting monitor.

Property Patterns for Runtime Monitoring of Web Service Conversations

151

! c k L n A t
! c k L n A t ,

?

Σ\{!ckLnAt}

{

Σ \

c k L n A t }

q4

k
O
e
S
t
c
?

Σ\{!ckLnAt,!lnAtNO}
Σ\{!ckLnAt,?lnAtNO}

q6

!ckLnAt

q5

?c
k
L
n
A
t

!
c
k
L
n
A
t

n
L
e
c
!

t
A
n
L
k
!c

!l
n

A

t

N

O

q7

?lnAtNO

q8

!csLn

q9

Σ
\
{
!
c
e
L
n
,
!
p
s
A
n
,
?
c
e
L
n
}

?ceLn

?
p

s

A

n

n

L

e

c
?

!psAn

Σ

q11

n
A
s
p
?

q10

!psAn

Σ\{!ceLn, !psAn, ?psAn}

Σ\{!ceLn, !psAn}

q3

!ctSeOk

q2

?ckCtSe

q1

!ckCtSe

q0

(b)

SD P4

MnPs

LnLt

CtCk

CeLn

PsAn

ckCtSe

ctSeOk

ref

P3

(a)

Fig. 14. P4: Absence pattern, Scope After. (a) SD describing the LA property P4
and (b) the resulting monitor, obtained by concatenating the NFAs for the scope and
P3.

Property P4: “After checking that the applicant has a good credit score, a loan
cannot be granted if the loan amount is less than or equal to zero.”

This property is equivalent to the property P3 with the After Q scope, where
Q is “checking for a good credit score”. To express it, we introduce the scope
delimiter Q before the property P3, as seen in Fig. 12(b). The SD corresponding
to P4 is shown in Fig. 14(a) and consists of two parts: (1) scope Q and (2) property 
P3, i.e., the fragment speciﬁed by a ref operator which should be replaced
by the SD for P3. The resulting monitor is shown in Fig. 14(b).
Property P5: “Noone can get a loan without ﬁrst going through a credit check.”
At this point, we have identiﬁed common scenarios that occur in the LA
system: SDs creditCheck (Fig. 15(a)) and loanGranted (Fig. 15(b)). We can
now express property P5 using the Precedence pattern: SD creditCheck must
precede SD loanGranted. Note that the SD creditCheck is not optional and must
occur for the property to hold. The SD for P5 is shown in Fig. 15(c).

5 Tool Support and Experience

Tool Support. We have implemented our runtime monitoring framework within
the IBM WebSphere R(cid:2) business integration products [24]. In what follows, we
describe the architecture of our solution and its intended use. We also report
on preliminary experience of using this framework to check correctness of web
services. For implementation details, see [12].

Our solution uses the WebSphere Process Server (WPS) [25] and the WebSphere
Integration Developer (WID) [26]. The former provides a BPEL-compliant process
engine for executing BPEL processes and a built-in Service Component Architecture 
(SCA), which is a particular instantiation of SOA. The latter provides a development 
environment for building web service applications and a graphical package
for creating UML Sequence Diagrams.

152

J. Simmonds et al.

SD checkCredit

MnPs

LnLt

CtCk

ckCtSe

ctSeOk

(a)

SD loanGranted

MnPs

CeLn

PsAn

alt

ceLn

psAn

(b)

SD P5

MnPs

LnLt

CtCk

CeLn

PsAn

alt
ref

absence

loanGranted

ref
until ( loanGranted U creditCheck)

(c)

Fig. 15. P5: The Precedence pattern. (a) SD for checkCredit; (b) SD for loanGranted ;
(c) SD showing application of the Precedence pattern.

During and after application development, users can create UML SD speciﬁcations 
for their web service applications within the WID environment. If monitoring 
is enabled, our framework translates these diagrams into monitor automata
using the techniques in Section 3. During the execution of the web service, interaction 
events from the WPS are sent to our framework using sockets. These
events are immediately used to update the state of every active monitor automaton,
 until an error has been found or all partners terminate. This provides an
online feedback mechanism through the SD editor to report violations.

Our patterns are available as editable UML sequence diagrams (.dnx ﬁles).
Users must ﬁrst add these ﬁles to the WID project of the application they wish to
monitor. These patterns can now be modiﬁed to create actual system properties,
using our Sequence Diagram editor.

Violations in our framework are either due to the occurrence of a negative
trace (safety violation), or the absence of a positive trace (liveness violation). To
report violations, we display the causes in the Sequence Diagram editor by highlighting 
the beginning of the negative trace for safety violations (see Fig 16 (a)),
and the termination location for liveness violations (see Fig 16 (b)).
Experience. We applied our framework to the Loan Application system, with
the goal of specifying and checking the properties mentioned in Table 1. On
normal execution traces of this system, these properties should never fail, as
this application implements the workﬂow shown in Fig 1(a). As it is a sample
application, some details have been simpliﬁed. For example, the CreditCheck
component generates random credit scores.

We ran the system on two diﬀerent taxpayer ids (tpid) and three diﬀerent

loan amounts (la), with the following speciﬁc input conﬁgurations:

c1 = <tpid = 1234, la = $10,000>, c2 = <tpid id = 1234, la = $60,000>,
c3 = <tpid id = 1888, la = -$1,000>.

As the system is supposed to generate random credit scores, we ran the system
10 times with each conﬁguration. For conﬁguration c1, we expected to see some
automatic approvals of the loan, and some declines, based on whether the good
or the bad score is generated. For c2, we expected some manual approvals of
the loan (the loan amount is above the automatic approval limit), and some
declines. Finally, since the loan amount in c3 is invalid, we expected to see only
loan declines.

Property Patterns for Runtime Monitoring of Web Service Conversations

153

(a)

(b)

Fig. 16. Reporting errors: (a) A complete (negative) trace; (b) An incomplete sequence:
violation of a liveness property.

For conﬁgurations c1 and c2, the behavior we observed was as expected:
P1, P2, P5 always held and P3, P4 held when the loan was granted. However,
for all executions of c3, the system automatically approved the loan, meaning
that properties P1, P3 and P4 were violated. For all executions of c3, the system
produced the following faulty execution trace:

FT = (MnPs, ckCtSe, LnLt), (LnLt, ctSeOK, CtCk), (MnPs, ckLnAt, LnLt),

(LnLt, lnAtNO, CtCk), (MnPs, ceLn, CeLn).

where each triple (Sender , m, Receiver) denotes partner Sender sending a message 
m to partner Receiver. This trace depicts a failure of P1 because the loan
amount is not greater than zero, as indicated by the triple (LnLt, lnAtNO, CtCk).
This trace also shows a violation of P3 because it includes an invalid behaviour,
acceptance of the invalid loan, indicated by the subtrace

(MnPs, ckLnAt, LnLt), (LnLt, lnAtNO, CtCk), (MnPs, ceLn, CeLn).

Finally, P4, being the scoped version of the property P3, fails on this trace as
well.

To identify the cause of the violations, we examined the BPEL diagram in Fig. 1
(a) to see that the trace FT is produced if the LA system obtains the taxpayer’s
credit score, checks if the credit score is greater than 750 (ScoreEvaluation),
checks if the loan amount is greater than zero (input validation), and checks if
the loan amount is less than $50,001 (AutoApprovalTest). The ScoreEvaluation
should only occasionally be true, as the CreditCheck component generates random 
credit scores. However, we obtained trace FT every time the system was run
with the taxpayer id 1888, i.e., the system always approved a negative loan.

We traced this behaviour to two problems. The ﬁrst, identiﬁed after looking
at the BPEL code of the LA system, was that the application did not use the
results of the input validation, allowing requests for negative loans to go through.
The second, identiﬁed only after examining the source code for the CreditCheck
partner, was that the partner was distributed with hard-coded logic: an applicant
with a taxpayer id that ends with “888” was always given a good credit score
instead of a random one. Combined, these two problems yielded the approval of
the loan for conﬁguration c3 every single time.

154

J. Simmonds et al.

Overall, our experience showed that the system can handle simultaneous failure 
of several monitors and allowed us to specify interesting properties which
led to the discovery of two real faults in the LA system.

6 Conclusion

In this paper, we described our framework for runtime monitoring of web service
conversations developed as part of an industrial-strength system. The framework
is an aggregation of existing runtime veriﬁcation techniques and is a continuation 
of [12]. It is non-intrusive, running in parallel with the monitored system
and intercepting interaction events during run time. Thus, it does not require
any code instrumentation, does not signiﬁcantly aﬀect the performance of the
monitored system, and enables reasoning about partners expressed in diﬀerent
languages. Furthermore, the use of a subset of UML 2.0 SDs as a speciﬁcation
language ensures that the framework is usable by practitioners to specify a wide
range of properties. By formalizing this subset using automata, we can check ﬁnite 
execution traces of web services against these properties. Liveness becomes
ﬁnitary, where user-speciﬁed time limits or the process termination act as the
stopping conditions.

We have successfully mapped all the Speciﬁcation Property System patterns
into our SD subset. The availability of customizable patterns should improve
the usability of our speciﬁcation language. More complex conversations can be
checked, as it is easy to build properties through SD composition. Using SD
references, our properties are also easier to read, since details can be hidden.
Finally, we have created a library of such sequence diagram patterns and showed
how patterns can be used to specify monitors which lead to discovery of bugs in
real webservice applications.

Future Work. While the initial experience using the framework has been positive,
 we need to address a number of issues before it becomes fully usable. The
ﬁrst set of issues deals with increasing the range of properties that can be speciﬁed 
and monitored. In the examples presented here, all objects were unique,
whereas in practice, users may be interested in verifying interactions between
multiple processes of the same type. For example, a user with a good credit score
may concurrently apply for two loans, each for less than $50 001, to bypass the
manual approval required for a loan for the total amount. In this case, two bank
branches may want to communicate to avoid this kind of situation. We feel that
the problem can be easily solved by encoding process IDs into the speciﬁcation,
the automata transition relation, and interaction events.

We also plan to begin investigation of techniques to help locate cause of errors 
from seeing results of successful and unsuccessful runs of the system. For
example, given a monitor violation, we would like to produce similar conversations 
that do not cause a violation, so as to help pinpoint cause of the violation
(as the place signaled with the violation is not necessarily the cause). We will
experiment with the techniques in [27,28] for this task.

Property Patterns for Runtime Monitoring of Web Service Conversations

155

On a side note, our work so far has been built on a basis that all partners
operate within the same process server and thus a centralized monitor is a viable
option. In practice, most web services are distributed, requiring a distributed
monitoring framework. We plan to investigate techniques used in the DESERT
project [29] to turn a centralized monitor into a set of distributed ones, running
in diﬀerent process servers.

Acknowledgements and Trademarks

We thank Yuan Gan and Jonathan Amir for implementing several parts of the
monitoring framework, and Simon Moser and Axel Martens for generating many
useful discussions. This work is ﬁnancially supported by the IBM Toronto Centre
for Advanced Studies, Ontario Graduate Scholarship and NSERC.

IBM and WebSphere are trademarks or registered trademarks of International
Business Machines Corporation in the United States, other countries, or both.
Java and all Java-based trademarks are trademarks of Sun Microsystems, Inc.
in the United States, other countries, or both. Other company, product, and
service names may be trademarks or service marks of others.

References

1. Dwyer, M., Avrunin, G., Corbett, J.: Patterns in Property Speciﬁcations for FiniteState 
Veriﬁcation. In: Proceedings of 21st International Conference on Software
Engineering (ICSE 1999) pp. 411–420 (May 1999)

2. IBM: Business Process Execution Language for Web Services,

http://www-128.ibm.com/developerworks/library/specification/ws-bpel/

3. Fu, X., Bultan, T., Su, J.: Conversation Protocols: A Formalism for Speciﬁcation
and Veriﬁcation of Reactive Electronic Services. In: H. Ibarra, O., Dang, Z. (eds.)
CIAA 2003. LNCS, vol. 2759, pp. 188–200. Springer, Heidelberg (2003)

4. Fu, X., Bultan, T., Su, J.: Analysis of Interacting BPEL Web Services. In: Proceedings 
of the Thirteenth International World Wide Web Conference (WWW 2004),
New York, pp. 621–630 (May 2004)

5. Kazhamiakin, R., Pistore, M.: A Parametric Communication Model for the Veriﬁcation 
of BPEL4WS Compositions. In: EPEW/WS-FM, pp. 318–332 (2005)

6. Baldoni, M., Baroglio, C., Martelli, A., Patti, V., Schifanella, C.: Verifying the
Conformance of Web Services to Global Interaction Protocols: A First Step. In:
EPEW/WS-FM, pp. 257–271 (2005)

7. Foster, H., Uchitel, S., Magee, J., Kramer, J.: Model-based Veriﬁcation of Web
Service Compositions. In: Proceedings of 18th IEEE International Conference on
Automated Software Engineering (ASE 2003), pp. 152–163. IEEE Computer Society,
 Los Alamitos (2003)

8. Ghafari, N., Gurﬁnkel, A., Klarlund, N., Treﬂer, R.: Algorithmic Analysis of Piecewise 
FIFO Systems. In: Proceedings of 7th International Conference on Formal
Methods in Computer-Aided Design (FMCAD 2007), Austin, Texas, LNCS, pp.
45–52 (November 2007)

9. Baresi, L., Ghezzi, C., Guinea, S.: Smart Monitors for Composed Services. In:

ICSOC 2004, pp. 193–202 (2004)

156

J. Simmonds et al.

10. Robinson, W.N.: Monitoring Web Service Requirements. In: Proceedings of RE

2003, pp. 65–74 (2003)

11. Mahbub, K., Spanoudakis, G.: Run-time Monitoring of Requirements for Systems
Composed of Web-Services: Initial Implementation and Evaluation Experience. In:
Proceedings of ICWS 2005, pp. 257–265 (2005)

12. Gan, Y., Chechik, M., Nejati, S., Bennett, J., O’Farrell, B., Waterhouse, J.: Runtime 
Monitoring of Web Service Conversations. In: Proceedings of CASCON 2007
(November 2007)

13. Object Management Group (OMG): Uniﬁed Modeling Language (UML 2.0),

http://www.uml.org/

14. Autili, M., Inverardi, P., Pelliccione, P.: A Scenario Based Notation for Specifying

Temporal Properties. In: Proceedings of SCESM, ICSE 2006 Workshop (2006)

15. Alur, R., Yannakakis, M.: Model Checking of Message Sequence Charts. In: Baeten,
J.C.M., Mauw, S. (eds.) CONCUR 1999. LNCS, vol. 1664, pp. 114–129. Springer,
Heidelberg (1999)

16. Grosu, R., Smolka, S.A.: Safety-Liveness Semantics for UML 2.0 Sequence Diagrams.
 In: ACSD 2005, pp. 6–14 (2005)

17. Hopcroft, J.E., Ullman, J.D.: Introduction to Automata Theory, Languages and

Computation. Addison-Wesley, Reading (1979)

18. Harel, D., Maoz, S.: Assert and Negate Revisited: Modal Semantics for UML Sequence 
Diagrams. In: Proceedings of SCESM, ICSE 2006 Workshop, pp. 13–20
(2006)

19. St¨orrle, H.: Assert, Negate and Reﬁnement in UML 2 Interactions. In: Stevens, P.,
Whittle, J., Booch, G. (eds.) UML 2003. LNCS, vol. 2863, pp. 79–94. Springer,
Heidelberg (2003)

20. Vardi, M.: An Automata-Theoretic Approach to Linear Temporal Logic. In: Moller,
F., Birtwistle, G. (eds.) Logics for Concurrency. LNCS, vol. 1043, pp. 236–266.
Springer, Heidelberg (1996)

21. Dwyer, M.B., Avrunin, G.S., Corbett, J.C.: Property Speciﬁcation Patterns for
Finite-state Veriﬁcation. In: Proceedings of 2nd Workshop on Formal Methods in
Software Practice (March 1998)

22. Clarke, E., Grumberg, O., Peled, D.: Model Checking. MIT Press, Cambridge

(1999)

23. Yu, J., Manh, T.P., Han, J., Jin, Y., Han, Y., Wang, J.: Pattern Based Property
Speciﬁcation and Veriﬁcation for Service Composition. In: Aberer, K., Peng, Z.,
Rundensteiner, E.A., Zhang, Y., Li, X. (eds.) WISE 2006. LNCS, vol. 4255, pp.
156–168. Springer, Heidelberg (2006)

24. IBM: WebSphere Business

Integration Software, http://www-306.ibm.com/

software/info1/websphere/index.jsp?tab=products/businessint

25. IBM: WebSphere Process Server,

http://www-306.ibm.com/software/integration/wps/

26. IBM: WebSphere Integration Developer,

http://www-306.ibm.com/software/integration/wid/

27. Zeller, A.: Isolating cause-eﬀect chains from computer programs. SIGSOFT Softw.

Eng. Notes 27(6), 1–10 (2002)

28. Groce, A., Chaki, S., Kroening, D., Strichman, O.: Error explanation with distance

metrics. Int. J. Softw. Tools Technol. Transf. 8(3), 229–247 (2006)

29. Inverardi, P., Mostarda, L., Tivoli, M., Autili, M.: Synthesis of Correct and Distributed 
Adaptors for Component-Based Systems: an Automatic Approach. In:
Proceedings of ASE 2005, pp. 405–409 (2005)

Property Patterns for Runtime Monitoring of Web Service Conversations

157

A Other Property Patterns
k−Bounded Existence: Message p can occur at most k times in a given scope.
We can check the existence of at most k messages using the loop operator.
After the loop, we need to check that p does not occur, which corresponds
to the absence pattern (see Fig. 11 (c)).
Universality: Only a sequence p∗ of messages can occur in a given scope. This
is equivalent to checking for the absence of complement messages (see Fig. 11
(d)).

Response: Message p (stimulus) must be followed by message s (response),
in a given scope. A response can occur without stimuli, so the stimulus is
represented using a regular message, whereas the response is mandatory. The
existence of stimulus/response pairs are checked in an inﬁnite loop, as there
can be many stimulus/response pairs in one execution trace (see Fig. 11 (e)).
Response Chain: A sequence p1, . . . , pn of messages must be followed by the
sequence q1, . . . , qm of messages, in a given scope. We show two examples
of this pattern: p responds to s, t (see Fig. 11 (f)), and s, t responds to p
(see Fig. 11 (g)). Response chain patterns have the same basic form of the
response pattern.

– p responds to s, t: 2 stimulus – 1 response. The critical operator is used
to enclose the message sequence s, t, to ensure atomicity of this sequence.
An assert cannot be used since the stimulus sequence is optional.

– s, t responds to p: 1 stimulus – 2 response. The message sequence now occurs 
within the assert operator, so an additional critical operator would
be superﬂuous).

Precedence Chain: A sequence p1, . . . , pn of messages must precede the sequence 
q1, . . . , qm of messages, in a given scope. We show an example of this
pattern, 2 cause – 1 eﬀect, p is preceded by s, t (see Fig. 11 (j)). This pattern
is mapped using the absence and until patterns, just like in the precedence
pattern. The implicit negate operators in the absence and until patterns
handle the message sequences, so there is no need to add critical operators.

