SIAM J. COMPUT.
Vol. 46, No. 3, pp. 1111–1145

c(cid:13) 2017 Society for Industrial and Applied Mathematics

THE POWER OF LOCAL CONSISTENCY IN CONJUNCTIVE
QUERIES AND CONSTRAINT SATISFACTION PROBLEMS∗

GIANLUIGI GRECO† AND FRANCESCO SCARCELLO‡

Abstract. Answering conjunctive queries is a fundamental problem in database theory, and it is
equivalent to solving constraint satisfaction problems in artiﬁcial intelligence and to other fundamental 
problems arising in computer science, which can be recast in terms of looking for homomorphisms
between relational structures. The problem is NP-hard, so that several research eﬀorts have been
made in the literature for identifying tractable classes, known as islands of tractability, as well as
for devising clever heuristics for solving eﬃciently real-world instances. Many heuristic approaches
are based on enforcing on the given instance a property called local consistency (also, relational
arc-consistency), where each tuple in every query atom matches at least one tuple in every other
query atom. Interestingly, for many well-known classes of instances, such as for the acyclic ones,
enforcing local consistency is even suﬃcient to solve the given instance correctly. However, the precise 
power of such a procedure was unclear, but for some very restricted cases. The paper provides
answers to long-standing questions about the precise power of algorithms based on enforcing local
consistency. The paper deals with both the general framework of tree projections, where local consistency 
is enforced among arbitrary views deﬁned over the given database instance, and the speciﬁc
cases where such views are computed according to the so-called structural decomposition methods,
such as generalized hypertree width, component hypertree decompositions, and so on. Moreover, the
paper deals with both decision and computation problems, by characterizing those tuples that are
correct projections of query answers, which ﬁnds application in algorithms for answering queries and
solving constraint satisfaction problems. As a relevant special case, the power of algorithms based on
enforcing local consistency is characterized over the fundamental and deeply studied class of acyclic
conjunctive queries. It turns out that local consistency provides the correct answer to a Boolean
acyclic query if, and only if, the query is semantically acyclic.

Key words.

query processing,

local consistency, structural decomposition methods, tree

projections

AMS subject classiﬁcations. 68P15, 68W05

DOI. 10.1137/16M1090272

1. Introduction.

1.1. Acyclic conjunctive queries. Answering conjunctive queries, that is,
queries deﬁned through conjunctions of atoms without negation, is a basic problem
in database theory, and it is equivalent to many other fundamental problems, such
as conjunctive query containment and constraint satisfaction, which can be recast in
terms of homomorphism problems between relational structures [47].1

The problem is NP-hard in general, but it is tractable on the class of acyclic
(conjunctive) queries, which was the subject of many seminal research works since
the early ages of database theory (see, e.g., [8]). This class contains all queries Q
whose associated query hypergraph HQ is acyclic, where HQ is a hypergraph having
∗Received by the editors August 22, 2016; accepted for publication (in revised form) February 8,
2017; published electronically June 29, 2017. A preliminary version of parts of this paper appeared
in Proceedings of the 29th ACM Symposium on Principles of Database Systems, 2010.

by the Kurt G¨odel Society.

http://www.siam.org/journals/sicomp/46-3/M109027.html
Funding: The ﬁrst author’s work was supported by a Kurt G¨odel research fellowship, awarded
†Department of Mathematics and Computer Science, University of Calabria, Italy (ggreco@
‡DIMES Department, University of Calabria, Italy (scarcello@dimes.unical.it).
1In the paper, we adopt the database theory jargon and present our results in the context of

mat.unical.it).

evaluating conjunctive queries. The application to such equivalent problems is straightforward.

1111

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1112

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

the variables of Q as its nodes and the (sets of variables occurring in the) atoms of
Q as its hyperedges. In particular, we refer to the most liberal notion of hypergraph
acyclicity [22, 10], for which HQ is acyclic if it has a join tree, i.e., a tree whose
vertices are the hyperedges and where, for each variable X, the set of vertices in
which X occurs induces a (connected) subtree. Deciding whether this condition holds
is feasible in linear time [60] and also in deterministic logspace (cf. [28, 54]).

Example 1.1. Consider the following conjunctive query:

Q : r1(A, B) ∧ r2(B, C) ∧ r3(C, D) ∧ r4(D, E).

The hypergraph HQ associated with Q is reported in Figure 1. Note that this is
actually a graph, since every query atom is deﬁned over two variables. A join tree for
HQ is also reported in the ﬁgure; hence, Q is acyclic.

Consider ﬁrst the so-called simple queries, where each database relation is used
for at most one query atom (equivalently, each atom is deﬁned over a distinguished
relational symbol). In order to answer such queries, according to Yannakakis’s algorithm 
[62], we can process any join tree bottom-up, by performing upward semijoins
between the relations associated with the query atoms, thus keeping the size of the
intermediate relations small. At the end of the computation, which clearly takes polynomial 
time, the relation associated with the root of the join tree is empty if, and
only if, the set of query answers is empty.

Example 1.2. Consider the evaluation of the (simple) query Q in Example 1.1
over the database instance DB depicted in Figure 1. The ﬁgure reports a sequence of
semijoin operations performed according to Yannakakis’s algorithm. In particular, the
join tree is processed bottom-up starting from the leaf (associated with the relation)
r1. So, at the ﬁrst step (i), the relation r2 is updated as follows: r2 := r2 (cid:110) r1. Then,
we consider the other leaf r4, and at the second step (ii) the intermediate relation
r3 is updated as follows: r3 := r3 (cid:110) r4. Finally, at the third step (iii), r2 is further
updated, this time propagating the tuples coming from r3, hence r2 := r2 (cid:110) r3.

The result of the application of these semijoins is reported on the right part of
Figure 1. Note that, at the end of the computation, one tuple survives at the root r2,
which witnesses that Q has a nonempty answer.

Fig. 1. The hypergraph associated with the query Q in Example 1.1; a join tree for HQ;
an associated database instance DB with the sequence of semijoin operations performed over it by
Yannakakis’s algorithm; the result of the applications of such semijoins.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. CAEDBr1ABBCCDDEjoin treehypergraph ofr2r3r4A   B0    01    01    1B   C0    01    12    2r2r1(i) r2 := r2     r1C   D0    01    1r3D   E0    0r4(iii) r2 := r2    r3(ii) r3 := r3    r4sequence of semijoin operations over DBB   C0    01    12    2(i) r2 := r2     r1(ii) r3 := r3    r4C   D0    01    1(iii) r2 := r2    r3B   C0    01    12    2results of semijoinsDownloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1113

Fig. 2. Query answers in Example 1.3; relations in DB from Figure 1 after the bottom-up

phase of Yannakakis’s algorithm (and the tuple removed in the top-down phase).

After the bottom-up step described above and if the root relation is not empty, one
can perform the opposite top-down step by ﬁltering each child vertex from those tuples 
that do not match its parent tuples. In such acyclic queries, the ﬁltered database,
called fully reduced, then enjoys the global consistency property: every tuple in every
relation is what we call a solution tuple, that is, a tuple that participates in some
query answer (i.e., it is the projection of some query answer).
In particular, after
the top-down step (which is again feasible in polynomial time), every relation contains 
precisely the projection of the query answers over the variables occurring in its
associated query atom [62].

Example 1.3. In order to perform the top-down step in our running example, we
need to apply the three semijoins in reverse order, by also exchanging the role of the
child with that of the parent. Therefore, we have to perform r3 := r3(cid:110)r2, r4 := r4(cid:110)r3,
and r1 := r1 (cid:110) r2. The ﬁrst two semijoins do not alter the relations that result after
the bottom-up phase (illustrated in Figure 1), while the third operation removes one
tuple from r1. See Figure 2, which also shows the answers of Q over DB. Note that
each tuple surviving after Yannakakis’s algorithm is the projection of some answer.

By exploiting the global consistency property and the join tree, all answers to
acyclic queries can be eﬃciently2 computed with polynomial delay by means of a
backtrack-free procedure, i.e., with backtracks used to look for further solutions, and
never caused by wrong choices [62].

1.2. Local consistency and acyclic queries. Given a query Q and a database 
DB, we say that local (also, pairwise) consistency holds w.r.t. Q and DB if the
relations associated with the query atoms are not empty and we do not miss any tuple
by taking semijoins between any pair of them. Such a notion is also studied and used
in constraint satisfaction problems, where it is called relational arc-consistency [20]
or, equivalently, R(∗, 2)C consistency [45]. Local consistency can be enforced by
performing a semijoin operation between all pairs of relations in any arbitrary order,
until a ﬁxpoint is reached. It is well known and easy to see that the acyclic instances
that fulﬁll this property have a nonempty set of query answers and also fulﬁll the
global consistency property [8]. This is exempliﬁed below.

Example 1.4. Consider again the query Q introduced in Example 1.1 and recall
that, according to Yannakakis’s algorithm, we can get a fully reduced database enjoying 
the global consistency property by performing the following operations (cf.
Examples 1.2 and 1.3) in the given order:

2As acyclic queries may have exponentially many answers, eﬃcient computation means here
having algorithms that list them so that every new answer is returned within polynomial time from
the previous one.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. A B0 01 01 1r2r1r3D E0 0r4B C0 0C D0 0A B C D E0 0 0 0 01 0 0 0 0query answersDownloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1114

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

Fig. 3. Illustration of Example 1.5.

r2 := r2 (cid:110) r1, r3 := r3 (cid:110) r4, r2 := r2 (cid:110) r3

(cid:124)
(cid:125).
(cid:125), r3 := r3 (cid:110) r2, r4 := r4 (cid:110) r3, r1 := r1 (cid:110) r2

(cid:123)(cid:122)

(cid:124)

(cid:123)(cid:122)

bottom-up phase

top-down phase

While performing the various steps toward the ﬁxpoint, with each step involving
the semijoin operations between all pairs of relations, it is clear that we would also
perform the above sequence of semijoins, even though interleaved with other semijoins.
Now, the crucial observation is that any additional semijoin preserve the semantics
of the query, since they can ﬁlter out only tuples that will never contribute to any
query answer. Therefore, if some relation becomes empty during the process, then
the set of query answers is clearly empty, too. Otherwise, the set of answers is not
empty and we get a database instance coinciding with the one we would obtain by
Yannakakis’s algorithm, hence globally consistent.

Interestingly, a classical result about database queries says that acyclicity is also a
necessary condition to guarantee that the above properties related to local consistency
hold on simple queries. More formally, it is known that every class of simple queries for
which local consistency entails the existence of some query answer (or for which local
consistency entails global consistency) must contain acyclic instances only (cf. [8]).

The picture for general conjunctive queries where some database relation is shared
by diﬀerent atoms was less clear, so far. Note ﬁrst that, over queries that are not
simple, it is natural to deﬁne local consistency over an “augmented” database instance
that includes a diﬀerent copy for each query atom. Indeed, query atoms with the same
relation symbol (but having diﬀerent variables) play diﬀerent roles with respect to
the tuples they have in common in the input database. Therefore, in the algorithms
described in the paper, we shall assume that for each query atom q in Q, an additional
distinguished database relation, denoted by wq, is available. The relation wq is called
a query view, and it is initialized with the tuples of the relation over which q is deﬁned.

Example 1.5. Consider the following query:

Q0 : r(A, B) ∧ r(A, C) ∧ r(D, B) ∧ r(D, C).

It is not simple since we have a unique relation symbol occurring four times.

The associated hypergraph is depicted in Figure 3 as a graph, where edge orientation 
reﬂects the position of the variables in query atoms. Clearly, Q0 is not acyclic.
The query views are wr(A,B), wr(A,C), wr(D,B), and wr(D,C). All these views
are initialized with the tuples occurring in r. It can be shown that, by taking the
semijoin between any pair of such views, no tuple will be ﬁltered out, independently of
the tuples originally in r—see again Figure 3, where a generic tuple in r is replicated
in the four query views. That is, local consistency always holds, provided r is not
empty. Correspondingly, in this case, the set of answers of Q0 is always not empty.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. A                   BC                   DA    Bx     yD    Bx     yA    Cx     yD    Cx     yABwr(A,B)wr(A,C)wr(D,B)wr(D,C)Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1115

The fact that local consistency entails that some answer exists is not by chance
in the above example. Indeed, the query Q0 holds the property to be semantically
acyclic [7], because it has an acyclic core. For instance, the subquery consisting of the
one atom r(A, B) is a core of Q0, as shown by the homomorphism in Figure 3—recall
that a core is any minimal3 subquery Q(cid:48) to which there is a homomorphism from Q0.
Then, from the results in [15], one can derive that semantic acyclicity is a suﬃcient
condition for deciding whether the set of query answers is empty by just enforcing
local consistency. However, whether semantic acyclicity is also a necessary condition
was unknown so far. Answering positively this question is the ﬁrst main result of the
paper.

Theorem 1.6. For any query Q, the following are equivalent:
(1) For every database DB, the set of query answers of Q over DB is not empty

whenever local consistency holds w.r.t. Q and DB.

(2) Q is semantically acyclic.

After the above result (and in analogy with what is known for the case of simple
queries), we might be inclined to believe that semantic acyclicity is also the right notion 
to characterize those instances where local consistency entails global consistency.
Our second result shows that this is not the case. Indeed, the precise relationship
between local and global consistency is based on a more stringent condition.
For any query Q and query atom q, let us denote by Equiv (Q, q) the set of minimal
subqueries Q(cid:48) of Q such that q occurs in Q(cid:48), and there is a homomorphism from Q to
Q(cid:48) (hence, Q(cid:48) is homomorphically equivalent to Q).

Theorem 1.7. For any query Q, the following are equivalent:
(1) For every database DB, local consistency entails global consistency.
(2) For every query atom q, there exists an acyclic subquery in Equiv (Q, q).

It is worth noting that the acyclic subqueries in the above result are diﬀerent for

the various atoms, unless the given query is actually acyclic.

Example 1.8. Consider the query Q1 obtained from the query Q0 in Example 1.5

by adding the novel query atoms r(E, D) and r(C, F ), that is,

Q1 : r(A, B) ∧ r(A, C) ∧ r(D, B) ∧ r(D, C) ∧ r(E, D) ∧ r(C, F ).

The (hyper)graph associated with Q1 is shown in Figure 4. As for the previous
example, the (hyper)graph contains a cycle, but Q1 is semantically acyclic because
its core, which is the line F ← C ← D ← E, is acyclic. However, for this query local
consistency does not entail global consistency, in general.

Assume that the relation r contains the tuples shown in each query view in
Figure 4. The ﬁgure also shows the tuples that still belong to each query view after
we enforce local consistency on this database, by performing the semijoin between all
pairs of views until a ﬁxpoint is reached. The question is whether these tuples are
correct, in that they are part (i.e., projections) of some answer of Q1.

According to Theorem 1.7, in order to answer the above question, we can just
check whether every query atom q is contained in some equivalent acyclic subquery
in Equiv (Q1, q). Figure 4 shows an equivalent subquery of Q1, which witnesses that
the property holds on the atoms r(C, F ), r(D, C), r(E, D), and r(A, C). Similarly,
it can be checked that the property holds on r(D, B), too. However, the property
does not hold on r(A, B). Indeed, the only equivalent subquery of Q1 that contains

3With respect to the subquery relationship.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1116

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

Fig. 4. Illustration of Example 1.8.

r(A, B) is Q1 itself, which is a cyclic query. By Theorem 1.7, it then follows that
some tuple in the ﬁltered database is not correct. In particular, it can be checked
that the tuple (a0, b1) occurring in the query view wr(A,B) is wrong, in that it does
not participate in any query answer. For completeness, note that all tuples of the
other query views are correct. This is not by chance: Our subsequent results will
show that wrong tuples can belong only to query views whose atoms are not included
in some equivalent acyclic subquery.

1.3. Generalized hypertree decompositions. Queries arising from real applications 
are hardly precisely acyclic. Yet, they are often not very intricate and, in
fact, tend to exhibit some limited degree of cyclicity, which suﬃces to retain most
of the nice properties of acyclic ones. In order to capture this intuition, the concept
of generalized hypertree decomposition [30] has been proposed in the literature as a
natural generalization of hypergraph acyclicity (see [26] for a recent survey on this
notion and its applications).
Formally, a generalized hypertree decomposition of a hypergraph H is a tuple
HD = (cid:104)T, χ, λ(cid:105), where χ and λ are functions labeling each vertex p of T with a set
of nodes and hyperedges, respectively, from H such that (1) for each hyperedge h
of H, there exists a vertex p in T such that h ⊆ χ(p); (2) for each node Y of H,
the set {p in T | Y ∈ χ(p)} induces a (connected) subtree of T ; and (3) for each
h∈λ(p) h. The width of (cid:104)T, χ, λ(cid:105) is the number maxp(|λ(p)|). The
generalized hypertree width of H, deﬁned as the minimum width ghw(H) over all its
decompositions, is meant to characterize the degree of cyclicity of H. In particular,
H is acyclic if, and only if, ghw(H) = 1 [30].

p in T , χ(p) ⊆ (cid:83)

Example 1.9. Consider the following conjunctive query:

Q2 : r1(A, B) ∧ r2(B, C) ∧ r3(C, D) ∧ r4(D, E) ∧ r5(A, C, E),

which is obtained from the query in Example 1.1 by adding the query atom r5(A, C, E).
The hypergraph associated with Q2 is reported in the left part of Figure 5. Note
that there is no way to build a join tree for it. For instance, every attempt to add a
vertex to the join tree in Figure 1 to deal with the novel hyperedge {A, C, E} would
violate the connectedness condition. On the right of Figure 5, a width-2 generalized
hypertree decomposition of Q2 is shown. Note that the λ labeling clusters together
the hyperedges associated with r1 and r2 (resp., r3 and r4) in the left child (resp.,
right child) of the root vertex. For each vertex p of the decomposition, we have

h∈λ(p) h. Moreover, note that the connectedness condition holds.

χ(p) =(cid:83)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. A                   BC                   DFwr(A,B)EA                   C                   DFEA    Ba0    b0a1    b1a0    b1a0    c0a1    c1d0    c0d1    c1d0    b0d1    b1c0    f0c1    f1e0    d0e1    d1wr(A,C)A    Ca0    b0a1    b1a0    b1a0    c0a1    c1d0    c0d1    c1d0    b0d1    b1c0    f0c1    f1e0    d0e1    d1wr(D,B)D   Ba0    b0a1    b1a0    b1a0    c0a1    c1d0    c0d1    c1d0    b0d1    b1c0    f0c1    f1e0    d0e1    d1wr(D,C)D    Ca0    b0a1    b1a0    b1a0    c0a1    c1d0    c0d1    c1d0    b0d1    b1c0    f0c1    f1e0    d0e1    d1wr(E,D)E    Da0    b0a1    b1a0    b1a0    c0a1    c1d0    c0d1    c1d0    b0d1    b1c0    f0c1    f1e0    d0e1    d1wr(C,F)C    Fa0    b0a1    b1a0    b1a0    c0a1    c1d0    c0d1    c1d0    b0d1    b1c0    f0c1    f1e0    d0e1    d1Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1117

Fig. 5. The hypergraph of query Q2 in Example 1.9, and a width-2 generalized hypertree
decomposition (where hyperedges are identiﬁed via the relations on which query atoms are deﬁned).

It is known that deciding the existence of a width-k generalized hypertree decomposition 
of a given hypergraph is an NP-complete task [31]. However, it was shown
that queries having generalized hypertree width at most k can be solved in polynomial
time by using local computations only [15]. The technique can be seen as a generalization 
of the tractability result about acyclic queries, when local consistency is enforced
between each pair of views obtained by considering any subquery of k atoms. In fact,
any width-k generalized hypertree decomposition is a way to transform the original
cyclic query into an acyclic one, whose relations are built by joining at most k query
atoms. More formally, for any ﬁxed natural number k, deﬁne the view set v -hwk (Q),
containing one distinct view over each set of at most k query-atoms. Correspondingly,
for any database DB, let d -hwk (Q, DB) be the database obtained by associating each
view in v -hwk (Q) with the (natural) join of all relations over which its atoms are deﬁned.
 We say that k-local consistency holds w.r.t. Q and DB if the database obtained
by repeatedly enforcing the pairwise consistency among such relations is not empty.
Chen and Dalmau [15] have shown that whenever some core Q(cid:48) of Q has generalized 
hypertree width at most k, then k-local consistency implies that the set of query
answers is not empty. This result states a suﬃcient condition for deciding in polynomial 
time whether the answer is empty, without actually identifying such a subquery
Q(cid:48) and without computing a generalized hypertree decomposition of Q(cid:48), which are
both NP-hard tasks. A similar result was already known for structures having a ﬁxed
arity, when the tree decomposition method [21, 25] is considered, instead of the generalized 
hypertree decomposition method [19]. Interestingly, for this restricted setting,
it was also shown that the condition for tractability is also necessary for having the
guarantee that the k-local consistency approach works [6]. Unfortunately, the approach 
for proving the necessary condition does not work when moving from graphs
(or structures with ﬁxed arity) to hypergraphs, and in fact it does not even cover the
basic acyclic case. The second main achievement of our work is to provide a precise
answer to the general question, which was left open by [15, 6].

Theorem 1.10. For any query Q, the following are equivalent:
(1) For every database DB, the set of query answers of Q over DB is not empty

whenever k-local consistency holds w.r.t. Q and DB.

(2) Q has a core having generalized hypertree width at most k.

Contrasted with such previous works, our proof uses completely diﬀerent ingredients.
 We ﬁrst relate local consistency properties to inclusion dependencies in
databases. Then, we consider the possibly inﬁnite chase satisfying these dependencies
and use a result on the ﬁnite controllability of unions of conjunctive queries. EventuCopyright 
© by SIAM. Unauthorized reproduction of this article is prohibited. CAEDBr1r2r3r4r5{r5}{A,C,E}{r1,r2}{A,B,C}{r3,r4}{C,D,E}Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1118

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

ally, we prove a connection of such a chase with the existence of suitable equivalent
acyclic instances.

Moreover, note that the above results mainly deal with the decision problem, so
that the relationship between k-local consistency and global consistency (and hence
with the related problem of computing solutions) was missing. We provide such a
relationship, together with a more general characterization dealing with any set of
output variables occurring in the views. This is, however, more technical and will be
presented later in the paper, while we next summarize our result on query views, only.
Theorem 1.11. For any query Q and atom q occurring in Q, the following are

equivalent:

(1) For every database DB such that k-local consistency holds w.r.t. Q and DB,
the query view wq contains the solution tuples for q (i.e., all those tuples that
are projections of query answers over the variables occurring in q).

(2) There is a subquery in Equiv (Q, q) with generalized hypertree width at most k.

1.4. Tree projections. Besides generalized hypertree decompositions, a number 
of other notions have been proposed in the literature to identify nearly acyclic
hypergraphs, such as fractional hypertree [42], spread-cut [17], and component hypertree 
[31] decompositions.

Despite their diﬀerent technical deﬁnitions, there is a simple mathematical framework 
that encompasses all the above methods, which is the framework of the tree projections 
[34]. In this setting, a query Q is given together with a set V of atoms, called
views, which are deﬁned over the variables in Q. The question is whether (parts of)
the views can be arranged to form a tree projection (playing the role of a decomposition 
tree), i.e., a novel acyclic query that still “covers” Q. By representing Q and V
via the hypergraphs HQ and HV , where hyperedges one-to-one correspond with query
atoms and views, respectively, the tree projection problem reveals its graph-theoretic
nature. For a pair of hypergraphs H1,H2, let H1 ≤ H2 denote that each hyperedge
of H1 is contained in some hyperedge of H2. Then, a tree projection of HQ w.r.t. HV
is any acyclic hypergraph Ha such that HQ ≤ Ha ≤ HV . If such a hypergraph exists,
then we say that the pair of hypergraphs (HQ,HV ) has a tree projection.

Example 1.12. Consider the conjunctive query

Q3 : r1(A, B, C) ∧ r2(A, F ) ∧ r3(C, D) ∧ r4(D, E, F )
∧ r5(E, F, G) ∧ r6(G, H, I) ∧ r7(I, J) ∧ r8(J, K),

whose associated hypergraph HQ3 is depicted in Figure 6, together with other hypergraphs 
that are discussed next.

Fig. 6. A tree projection Ha of HQ3 w.r.t. HV3 . On the right: A join tree JTa for Ha.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. 33Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1119
To answer Q3, assume that a set V3 of views is available comprising the query
views plus four additional views. The set of variables of each view is a hyperedge in
the hypergraph HV3 (query views are depicted as dashed hyperedges). In the middle
between HQ3 and HV3, Figure 6 reports the hypergraph Ha which covers HQ3, and
which is in turn covered by HV3—e.g., {C, D} ⊆ {A, B, C, D} ⊆ {A, B, C, D, H}.
Since Ha is acyclic (just check the join tree in the ﬁgure), Ha is a tree projection of
HQ3 w.r.t. HV3 .

Observe that in the tree projection framework, views can be arbitrary, i.e., they
do not depend on the speciﬁc conjunctive query Q, and can be reused to answer different 
queries. In particular, views may be the materialized output of any procedure
over the database, possibly much more powerful than conjunctive queries. In particular,
 it is known and easy to see that any decomposition method based on clustering
subproblems can be viewed as an instance of this general setting, identifying a speciﬁc
set of views to answer a given query Q eﬃciently. For example, for a ﬁxed natural
number k and any given hypergraph H, let Hk be the hypergraph whose hyperedges
are all possible sets obtained by the union of at most k hyperedges of H. Notice
that Hk
Q is precisely the hypergraph associated with the views v -hwk (Q) described in
section 1.3. It is easy to see that a query Q has generalized hypertree width bounded
by k if, and only if, there is a tree projection of HQ w.r.t. Hk
Q (see, e.g., [4, 35, 37],
and also [40] for the greedy variant based on the hypergraph game characterizing tree
projections).

Similarly to generalized hypertree decompositions, deciding the existence of tree
projections is an NP-complete task [31]. However, if a tree projection exists, then
both deciding whether the query is not empty and computing a query answer (if any)
are feasible in polynomial time, by just enforcing local consistency, i.e., by taking
the semijoin between any pair of views in V until a ﬁxpoint is reached [53]. It was
conjectured that the existence of a tree projection is also a necessary condition for
having this property [34, 53], but the question remained open so far, although it was
attacked via diﬀerent approaches and proof techniques. Our third main result is to
show that there are queries where such local computations do work even if no tree
projection exists and that the concept of core again plays a crucial role.

Theorem 1.13. For any query Q and set V of views, the following are equivalent:
(1) For every database DB, the set of query answers of Q over DB is not empty
(2) Q has a core Q(cid:48) such that (HQ(cid:48),HV ) has a tree projection.
Moreover, we provide a precise characterization of the cases where local consiswhenever 
local consistency holds w.r.t. V and DB.

tency entails global consistency in the tree projection framework.

following are equivalent:

Theorem 1.14. For any query Q, set V of views, and atom q occurring in Q, the
(1) For every database DB such that local consistency holds w.r.t. V and DB, the
(2) There exists a subquery Q(cid:48) in Equiv (Q, q) such that (HQ(cid:48),HV ) has a tree

query view wq contains the solution tuples for q.

projection.

The above results come together with a more general characterization dealing
with any set of output variables occurring in the available views. The characterization
is rather technical and its presentation will be deferred to section 3. In fact, in the
paper, our results are ﬁrst proven for the general framework of tree projection and then
specialized to the structural methods mentioned above. In particular, the algorithmic

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1120

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

part of the proof described in section 3, which shows how to use local consistency to
answer conjunctive queries, recovers and generalizes with a single concise argument all
the tractability results proved so far for the various structural decomposition methods,
including classical and semantical acyclicity, and for both the decision and the search
problems.

We point out that the above results on the tree projection framework have a
broad spectrum of applicability. The notion of tree projection is indeed quite natural
and may be exploited in diﬀerent applications where hypergraphs naturally represent
structural properties of input instances. For example, Adler [3] pointed out that the
notion of acyclicity for a conjunctive query with negation Q, as deﬁned in [23], can
be immediately recast as the existence of a tree projection of HQ w.r.t. HQ+, where
the hyperedges of HQ+ are the sets of variables occurring in the positive atoms of Q
only, while the hyperedges of HQ correspond to all atoms, including the negative ones.
Then, we can generalize this notion to obtain larger classes of tractable instances, by
saying that a query with negation Q has generalized hypertree width at most k if the
pair (HQ,Hk
Q+) has a tree projection. Indeed, following the same reasoning as in [23],
it is easy to see that, given such a tree projection, the query Q can be evaluated in
polynomial time.

Moreover, in some applications one may relax the polynomial-time constraint
and consider instead ﬁxed-parameter tractable computations, for some (application-
speciﬁc) parameter. In other applications, views may be associated with subproblems
that can be solved by using nonstructural properties.
In this respect, we mention
an important line of research in constraint satisfaction, looking at restrictions on the
form of speciﬁc (ﬁxed) constraint relations, regardless of the structure of constraint
scopes; see, e.g., [16]. There are also hybrid approaches, looking at both structure
and data [57, 39, 18]. In concrete applications on big databases, some kind of hybrid
approach is mandatory: views should be subqueries such that their computation
cost is estimated to be low (that is, less than some given threshold), according to
information on the actual database instance, such as selectivity of attributes, keys,
cardinality of relations, indices, and so on.

1.5. Organization. The paper is organized as follows. Section 2 illustrates
some basic notions, concepts, and notation. The characterization of the power of
local consistency in the tree projection framework is given in section 3, while its
applications to structural decomposition methods and acyclic queries is reported in
section 4. A few further remarks and open issues are discussed in section 5.

2. Preliminaries.
Relational structures and homomorphisms. Let U and X be disjoint inﬁnite
sets that we call the universe of constants and the universe of variables, respectively.
A (relational) vocabulary τ is a ﬁnite set of relation symbols of speciﬁed (ﬁnite) arities.
A relational structure A over τ (short: τ -structure) consists of a universe A ⊆ U ∪ X
A ⊆ Aρ, where ρ is the arity of r.
and, for each relation symbol r in τ , of a relation r
Let A and B be two τ -structures with universes A and B, respectively. A homomorphism 
from A to B is a mapping h : A (cid:55)→ B such that h(c) = c for each
constant c in A ∩ U, and such that, for each relation symbol r in τ and for each
tuple (cid:104)a1, . . . , aρ(cid:105) ∈ r
. For any mapping h (not
necessarily a homomorphism), h((cid:104)a1, . . . , aρ(cid:105)) is used, as usual, as a shorthand for
(cid:104)h(a1), . . . , h(aρ)(cid:105).

, it holds that (cid:104)h(a1), . . . , h(aρ)(cid:105) ∈ r

A

B

A τ -structure A is a substructure of a τ -structure B if A ⊆ B and r

A ⊆ r

B

, for

each relation symbol r in τ .

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1121

Relational databases. Let τ be a given vocabulary. A τ -structure DB whose
universe is a set D ⊆ U of constants is also called a database instance (or, simply,
a database) over D. For each relation symbol r in τ , rDB is a relation instance
(or, simply, relation) of DB. Sometimes, we adopt the logical representation of a
database [61, 1], where a tuple (cid:104)a1, . . . , aρ(cid:105) of values from D belonging to the ρ-ary
relation (over symbol) r is identiﬁed with the ground atom r(a1, . . . , aρ). Accordingly,
a database DB can be viewed as a set of ground atoms. Unless otherwise stated, we
implicitly assume that databases are ﬁnite.

Conjunctive queries. A conjunctive query Q consists of a ﬁnite conjunction of
atoms of the form r1(u1) ∧ ··· ∧ rm(um), where r1, . . . , rm (with m > 0) are relation
symbols (not necessarily distinct), and u1, . . . , um are lists of terms (i.e., variables or
constants). The set of all atoms occurring in Q is denoted by atoms(Q). For a set
of atoms A, vars(A) is the set of variables occurring in the atoms in A. For short,
vars(Q) denotes vars(atoms(Q)). We say that Q is a simple query if every atom is
over a distinct relation symbol. Given a database DB over D, QDB denotes the set of
all answers of Q on DB, that is, all substitutions θ : vars(Q) (cid:55)→ D such that for each
1 ≤ i ≤ m, θ(cid:48)(ri(ui)) ∈ DB, where θ(cid:48)(t) = θ(t) if t ∈ vars(Q) and θ(cid:48)(t) = t otherwise
(i.e., if the term t is a constant).4
Note that any conjunctive query Q can be viewed as a relational structure Q,
whose vocabulary τQ and universe UQ are the set of relation symbols and the set of
terms occurring in its atoms, respectively. For each symbol ri ∈ τQ, its associated
is deﬁned to contain a tuple of terms u for each atom of the form ri(u) ∈
relation rQ
atoms(Q) deﬁned over ri. In the special case of simple queries, every relation rQ
i of
Q contains just one tuple of terms. According to this view, elements in QDB are in a
one-to-one correspondence with homomorphisms from Q to DBQ, where the latter is
the (maximal) substructure of DB over the (sub)vocabulary τQ. Hereafter, we adopt
this view but, for the sake of presentation, we identify queries and databases with
their relational structures, i.e., we use directly Q and DB in place of Q and DBQ.

i

For any given set S of variables, we denote by QDB[S] the restriction of the
(substitutions/)homomorphisms in QDB over the variables in S. For the extreme case
where S = ∅, deﬁne htrue to be the restriction of any homomorphism over the empty
set. Then, QDB[∅] = {htrue} if QDB (cid:54)= ∅, and QDB[∅] = ∅ if QDB = ∅. If a is an atom,
then QDB[a] denotes QDB[vars(a)].

Note that any atom a can be viewed as a one-atom query, so that aDB is the set
of all the homomorphisms from a to DB, restricted to vars(a) (i.e., projecting out
possible constants in a). For a set A of atoms, we denote by ADB the set {aDB | a ∈ A}.
A core of Q is a query Q(cid:48) such that (1) atoms(Q(cid:48)) ⊆ atoms(Q); (2) there is a
homomorphism from Q to Q(cid:48); and (3) there is no query Q(cid:48)(cid:48) satisfying (1) and (2) such
that atoms(Q(cid:48)(cid:48)) ⊂ atoms(Q(cid:48)). The set of all the cores of Q is denoted by cores(Q). In
terms of relational structures, an element Q(cid:48) ∈ cores(Q) is a minimal substructure of
Q such that (2) holds. The usefulness of the core and of its properties in the context
of query processing was pointed out in the early days of database theory [14].
In
particular, it has been observed that elements in cores(Q) are isomorphic.

3. The power of local consistency. Throughout the paper, we assume that
Q is a conjunctive query and that V is a nonempty set of views such that vars(V) =
vars(Q). Moreover, we assume that DB is a database over the vocabulary DS con4As 
usual, θ(cid:48)(ri(ui)) denotes the ground atom ri(θ(cid:48)(ui)), that is, the atom obtained by applying

the substitution θ(cid:48) to the tuple of terms in ui.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1122

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

taining the relation symbols of query atoms and views. We require, without loss of
generality (w.l.o.g.), that every available view is over a speciﬁc relation symbol, which
does not occur in the given query, and that the list of terms of every view does not
contain any constant or repeated variables. Within this setting, each view w ∈ V is
univocally associated with a relation instance in DB, whose tuples are in a one-to-one
correspondence with the homomorphisms in wDB. Therefore, this relation instance
will be simply denoted by wDB, and we freely use the term tuples interchangeably
with homomorphisms, when we refer to its elements.

Example 3.1. Consider the following query Q4, where all atoms are over the same

binary relation symbol r:

Q4 : r(A, B) ∧ r(B, C) ∧ r(A, C) ∧ r(D, C) ∧ r(D, B) ∧ r(A, E) ∧ r(F, E).

A graphical representation of this query is reported in Figure 7, where edge orientation
just reﬂects the position of the variables in query atoms. Moreover, consider the
database DB4 shown in Figure 7, by focusing on the relation instance rDB4. Then, it
can be checked that the answers of Q4 on DB4 are the homomorphisms h1, . . . , h10,
which are also reported, in tabular form, in Figure 7.
We assume the availability of the set of views V4 = {v1(A, B, C), v2(A, F ),
v3(A, B), v4(A, C), v5(A, E), v6(B, C), v7(D, B), v8(D, C), v9(F, E)}, and that the
database DB4 includes a relation instance wDB4 , for each view w ∈ V4. Note that, in
the ﬁgure, such relation instances are identiﬁed by the list of variables on which the
views are deﬁned.

Fig. 7. The (hypergraph of the) query Q4, the tuples in the database DB4, and the answers in
, in Example 3.1.

QDB4

4

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1123

3.1. Consistency properties and views.
View consistency. For a view w ∈ V, we say that wDB is view consistent w.r.t. Q
if wDB ⊇ QDB[w]. For the set of views V, we say that V DB is view consistent w.r.t. Q
if the property holds for each w ∈ V. That is, views are not more restrictive than the
query.

Note that view consistency holds in general for all views initialized from subsets
of query atoms, such as those employed in decomposition methods, for instance, in
generalized hypertree decompositions. However, we are also interested in a wider
framework where views are completely arbitrary and may be available from previous
computations, possibly unrelated to the present query Q. Accordingly, we do not
require that view consistency holds for such views, and we shall look for general
results, which will then be smoothly inherited by more speciﬁc settings.

4

Example 3.2. Consider again the setting of Example 3.1 and in particular the
view v1(A, B, C). Note that v1(A, B, C)DB4 is a set of two homomorphisms, which are
[{A, B, C}] of the answers of Q4 on DB4 projected over
precisely those in the set QDB4
the variables in {A, B, C}. Therefore, v1(A, B, C) is view consistent. Similarly, it can
be checked that the views v3(A, B), v4(A, C), v5(A, E), v6(B, C), v7(D, B), v8(D, C),
and v9(F, E) are all view consistent.
[{A, F}] does not
hold. For instance, v2(A, F )DB4 does not include the homomorphism mapping both
A and F to the constant a1. Hence, V DB4

Instead, v2(A, F ) is not view consistent, as v2(A, F )DB4 ⊇ QDB4

is not view consistent w.r.t. Q4.

4

4

Local consistency. We say that V DB is locally (also, pairwise) consistent, denoted 
by lc(V, DB), if wDB (cid:54)= ∅ and wDB = (w ∧ w(cid:48))DB[w], for each {w, w(cid:48)} ⊆ V.
From any set of views and any instance DB, we may compute a subset5 of DB
that is locally consistent. Let the reduct of DB according to V, denoted by red(V, DB),
be the (set-inclusion) maximal subset of DB such that V red(DB,V) is locally consistent,
or red(V, DB) = ∅, whenever such a maximal subset does not exist. It is well known
that the reduct can be computed as the unique ﬁxpoint of a procedure consisting of
repeatedly taking the semijoin between all pairs of relations in DB, which runs in
polynomial time. Note that such a procedure to enforce local consistency preserves
the given query—unless the used views are more restrictive than the query, of course.
Example 3.3. In the running example depicted in Figure 7, the set V4 of views
and the database DB4 are such that V DB4
is locally consistent. Consider, for instance,
 the views v1(A, B, C) and v3(A, B), and observe that both (v1(A, B, C) ∧
v3(A, B))DB4 [{A, B, C}] = v1(A, B, C)DB4 and (v3(A, B) ∧ v1(A, B, C))DB4 [{A, B}] =
v3(A, B)DB4. Indeed, every tuple in the relation associated with either view matches
with some tuple in the other view on the variables they have in common, so that
no tuple is missed by performing such semijoin operations. This is easily seen because 
v1(A, B, C)DB4[{A, B}] = v3(A, B)DB4 = {(cid:104)a1, b1(cid:105),(cid:104)a2, b2(cid:105)} (where these two
tuples also identify the homomorphisms mapping (A, B) to (a1, b1) and to (a2, b2),
respectively).

4

Query views. In the seminal paper about local and global consistency in acyclic
queries [8], local consistency is enforced directly on the relations of query atoms, while
we only consider (and possibly enforce) this property on views in this paper. This is
because that paper, as well as other related papers such as [34], uses a slightly diﬀerent
formal framework where every relation symbol may occur just once in a query, i.e.,

5Recall from section 2 that DB can be viewed either as a structure or as a set of ground atoms.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1124

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

where only simple queries are considered. In contrast with these classical papers, we
do not assume anything about the query, which may contain multiple occurrences of
the same relation symbol. This means that the same relation instance may be shared
by diﬀerent query atoms, and this feature plays a very relevant role, as ﬁrst pointed
out in [19]. In this case, a tuple may be useful for some atom and useless for another
one deﬁned over the same relation symbol. It follows that local consistency cannot be
enforced on the relations of the query atoms, because such a ﬁltering procedure would
lead to undesirable side eﬀects (possibly deleting all tuples in the database, including
the useful ones).

Therefore, we always keep the “original” database relations untouched and we
rather use suitable views, each one with its own database relation, to play the role
of query atoms in the deﬁnition of consistency properties in general queries and in
consistency enforcing procedures. Formally, we say that V is a view system (for Q) if
it contains, for each atom q ∈ atoms(Q), a view wq (over a distinct relation symbol)
with the same set of variables as q. These special views in V are called hereafter query
views and are denoted by views(Q). In the following, the set of available views V is
assumed to be a view system for the given query Q, unless otherwise speciﬁed.

Example 3.4. Consider again the setting of Example 3.1, and note that V4 is in
fact a view system for Q4. Indeed, the views in the set {v3(A, B), v4(A, C), v5(A, E),
v6(B, C), v7(D, B), v8(D, C), v9(F, E)} are in a one-to-one correspondence with the
query atoms of Q4. For instance, v3(A, C) is the query view wr(A,C), with r(A, C) being 
a query atom of Q4. Hence, views(Q4) = {v3(A, B), v4(A, C), v5(A, E), v6(B, C),
v7(D, B), v8(D, C), v9(F, E)}, and V4 = views(Q4) ∪ {v1(A, B, C), v2(A, F )}.

Observe that working with view systems instead of with arbitrary set of views is
not a restrictive assumption, for our purposes. On the practical side, if some atom
q misses its associated query view wq in the available views, one may just add a
fresh view wq to the views, with a corresponding relation in the database such that
wDB
q = qDB. On the theoretical side, recall that we are dealing with consistency
properties of Q and V, and with tree projections of (HQ,HV ). Such a tree projection
exists only if the set of variables of every atom q in Q is covered by some view w ∈ V,
i.e., vars(q) ⊆ vars(w). Therefore, whenever V is a set of “useful views,” for each
query atom q there must exist some view in V that may play the role of the query
view wq (after projecting it on vars(q)). However, requiring that query views belong
to V simpliﬁes the presentation and allows us to deﬁne consistency properties in a
clean way. In particular, the role of query views is crucial in the following deﬁnition.

Global consistency. A desirable state of the database occurs when query views
contain all and only those tuples that can be returned by query answers. In this case,
an answer of the query can be computed in polynomial time: for each query view wq,
select one tuple h in the relation wDB
that is univocally associated with wq in DB,
q = {h}, and propagate this choice by enforcing again
modify this relation so that wDB
local consistency. To formalize this state, a database DB is said globally consistent
with respect to Q and V, denoted by gc(V, DB, Q), if wDB
q = QDB[q] (which also equals
QDB[wq]), for each q ∈ atoms(Q), where wq is the query view associated with q.

q

Example 3.5. Let us focus on the query views in views(Q4). Consider, for instance,
 the view v3(A, B) ∈ views(Q4) (associated with the query atom r(A, B)), and
[{A, B}]. That is, the answers of Q4 on DB4 projected
note that v3(A, B)DB4 = QDB4
over the set {A, B} are immediately available by looking at the relation v3(A, B)DB4 .
On the other hand, for the view v8(D, C) ∈ views(Q4), the set v8(D, B)DB4 con-
[{D, C}] (identiﬁed by

tains two homomorphisms that do not belong to the set QDB4

4

4

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1125

the two tuples marked with the symbol “(cid:73)” in Figure 7). Therefore, DB4 is not
globally consistent w.r.t. Q4 and V4.

Legal database. While no special requirement is assumed for the database relations 
of the available views in V, the relations associated with the query views cannot
be arbitrary; otherwise we would lose any connection with the query Q to be solved
using V.
Indeed, these relations should reﬂect the intended initialization with the
tuples contained in the relations associated with their corresponding query atoms
(possibly ﬁltered by eliminating tuples that are irrelevant w.r.t. query answers).
q ⊆ qDB
holds for each query view wq ∈ views(Q), and (ii) views(Q)DB is view consistent.
Then, the following is immediate.

We say that DB is a legal database instance (w.r.t. Q and V) if (i) wDB

Fact 3.6. For every legal database DB,

 (cid:94)

DB

q

=

 (cid:94)

DB

wq

.

QDB =

q∈atoms(Q)

wq∈views(Q)

Example 3.7. The database DB4 is legal w.r.t. Q4 and V4. Indeed, condition (i)
is seen to hold by comparing the relations associated with the query views with the
relation instance rDB4. Moreover, in Example 3.2, we have observed that views(Q4)DB4
is view consistent, i.e., condition (ii) holds as well. Then, because of the above fact,

the answers of Q4 on DB4 are also given by the expression ((cid:86)

Remark 3.8. Only legal databases over Q and V are meaningful for the purpose of
this paper. Therefore, unless otherwise stated, we always implicitly assume hereafter
this requirement for any database instance. In particular, whenever we say “for every
database,” we actually mean “for every legal database.” Of course, whenever we deﬁne
some database instance in proofs of our results, we deal with this requirement, and
we explicitly prove that such a database is actually legal.

wq∈views(Q4) wq)DB4.

Now that the setting is clariﬁed, our next task is to provide suﬃcient and necessary

conditions to evaluate queries via local consistency.
For the sake of presentation and w.l.o.g., we assume that the given query Q is
connected, i.e., HQ is a connected hypergraph, and that vars(Q) = vars(V). Note
that, under these assumptions, whenever V DB is locally consistent, requiring that
every relation associated with some view in V is nonempty is equivalent to requiring
that there is at least one w in V with wDB (cid:54)= ∅. Indeed, the query views in the view
system V makes HV connected, and thus any empty relation in the database would
entail that all relations must be empty, at local consistency.

3.2. From tree projections to consistency . . . . The fact that local consistency 
holds for V and DB is of course unrelated to the fact that global consistency
holds for V and DB with respect to Q, in general. In this section, we show how the
existence of tree projections of some parts of the query is a suﬃcient condition to
get the implication lc(V, DB) ⇒ gc(V, DB, Q). Our analysis will consider arbitrary
conjunctive queries, with any desired set O of output variables, and tree projections
w.r.t. arbitrary view systems.

We start by observing that, when arbitrary view systems are considered, it suddenly 
emerges that it does not make sense to talk about “the” core of a query, because
diﬀerent isomorphic cores may behave diﬀerently with respect to the available views.
In fact, this phenomenon does not occur, e.g., for generalized hypertree decompositions 
where all combinations of k atoms are available as views (see section 4).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1126

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

Fig. 8. The (hypergraph of the) query Q4, the cores Q5 and Q6, the hypergraph HV4 , and the

cores of Q4 ∧ atom({F, E}) (with its tree projection) and Q4 ∧ atom({A, F}), in Example 3.9.

Example 3.9. Consider again the query
Q4 : r(A, B) ∧ r(B, C) ∧ r(A, C) ∧ r(D, C) ∧ r(D, B) ∧ r(A, E) ∧ r(F, E),

which has been discussed in Example 3.1, and which is graphically reported again in
Figure 8, for the sake of presentation. The ﬁgure also reports the hypergraph HV4
associated with the views in V4 (where, e.g., the hyperedges {A, B, C} and {A, F} are
those corresponding to the views v1(A, B, C) and v2(A, F ) and where (hyper)edges
associated with the query views are still depicted with their original orientation in
Q4, to make the correspondence clearer). Moreover, the ﬁgure reports the two queries

Q5 :
Q6 :

r(A, B) ∧ r(B, C) ∧ r(A, C),
r(D, B) ∧ r(B, C) ∧ r(D, C).

Note that Q5 and Q6 are two (isomorphic) cores of Q4, but they have diﬀerent structural 
properties. Indeed, (HQ5 ,HV4) admits a tree projection (note in the ﬁgure that
the view over {A, B, C} “absorbs” the cycle), while (HQ6,HV4) does not.

Computation problem. Armed with the observation exempliﬁed above, the
relationship between consistency and structural properties will be stated next by
considering the existence of a tree projection for some core of the query Q.

In addition, to properly deal with arbitrary sets of output variables (which may
not be included in any core of Q), we deﬁne an “output-aware” notion of covering by
tree projections, where cores are forced to contain the desired output variables.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1127
Definition 3.10. For any set of variables O occurring in some atom w ∈ V,
deﬁne atom(O) to be a fresh atom (with a fresh relation symbol) over these variables,
i.e., such that O = vars(atom(O)). Then, we say that O is tp-covered in Q (w.r.t. V)
if there exists some core Q(cid:48) of Q∧ atom(O) such that (HQ(cid:48),HV ) has a tree projection.
A ﬁrst easy observation is that the tp-covered property holds for every set of variables 
occurring in every query atom, whenever (HQ,HV ) has a tree projection.

Fact 3.11. Assume that (HQ,HV ) has a tree projection. Then, for every q ∈

atoms(Q) and every O ⊆ vars(q), O is tp-covered in Q (w.r.t. V).

Proof. Let q be any atom occurring in Q and take any O ⊆ vars(q). Let Q(cid:48) be
any core of Q ∧ atom(O). Since Q(cid:48) is a subquery of Q ∧ atom(O) and O ⊆ vars(q),
HQ(cid:48) ≤ HQ. Thus, HQ(cid:48) ≤ HQ ≤ Ha ≤ HV , where Ha is any tree projection of
(HQ,HV ), which exists by hypothesis.

We next show that the above fact may be extended to those atoms occuring in

some core of Q having a tree projection.

Lemma 3.12. Let q ∈ atoms(Q) be an atom occurring in some core Q(cid:48) of Q for
which (HQ(cid:48),HV ) has a tree projection. Then ∀O ⊆ vars(q), O is tp-covered in Q
(w.r.t. V).

Proof. Let O ⊆ vars(q), and consider the query Q∧ atom(O). We ﬁrst claim that
there is a homomorphism from Q ∧ atom(O) to Q(cid:48) ∧ atom(O). Indeed, since Q(cid:48) ∈
cores(Q), it is also a retract of Q (see, e.g., [32]); that is, there is a homomorphism
f from Q to Q(cid:48) which is the identity on its range (i.e., f (X) = X, for every term X
occurring in Q(cid:48)). Moreover, O ⊆ vars(Q(cid:48)), because q ∈ atoms(Q(cid:48)). It follows that f
is also a homomorphism from Q ∧ atom(O) to Q(cid:48) ∧ atom(O). In particular, note that
f maps the atom atom(O) to itself. We thus conclude that Q(cid:48) ∧ atom(O) is also a
core of Q∧ atom(O), because atom(O) is over a fresh relation symbol and hence must
belong to any core, and dropping atoms from Q(cid:48) would contradict the minimality of
Q(cid:48) as a core of Q. Finally, since vars(atom(O)) = O ⊆ vars(q) and q ∈ atoms(Q(cid:48)),
the hypergraph associated with Q(cid:48) ∧ atom(O), say, H(cid:48), is such that H(cid:48) ≤ HQ(cid:48). Hence,
any tree projection of HQ(cid:48) w.r.t. HV , which exists by hypothesis, is a tree projection
of H(cid:48) w.r.t. HV . That is, O is tp-covered in Q (w.r.t. V).

Example 3.13. Consider again the setting of Example 3.9. The core Q5 contains
the atoms r(A, B), r(B, C), and r(A, C), and we have noticed that Q5 admits a tree
projection. Therefore, we can apply Lemma 3.12 to conclude that the sets of variables
{A, B}, {B, C}, and {A, C} are tp-covered in Q4.
Consider now the set of variables {F, E}, which does not occur in any core of the
query, and the novel query Q4 ∧ atom({F, E}). This query has a unique core, which
is again depicted in Figure 8. Notice that this core does not coincide with any of
the two cores of the original query. Yet, it admits a tree projection, consisting of the
hyperedges {F, E}, {A, E}, and {A, B, C}, as shown in the ﬁgure. Thus, {F, E} is
tp-covered in Q4.
On the other hand, the hypergraphs for the cores of Q4 ∧ atom({D, C}) and
Q4 ∧ atom({D, B}) are precisely the same as the hypergraph HQ6 associated with
the core Q6, that is, the triangle with vertices D, B, and C, having no tree-projection
w.r.t. HV4. Hence, {D, C} and {D, B} are not tp-covered in Q4.
Finally, for an example application of Deﬁnition 3.10 with arbitrary set of variables 
(i.e., not just contained in query atoms), consider the set {A, F}. Consider then
the query Q4 ∧ atom({A, F}) and note that its core does not have a tree projection.
Thus, {A, F} is not tp-covered in Q4.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1128

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

The notion of tp-covering plays a crucial role in establishing consistency properties.
 To help the intuition, this role is next exempliﬁed.

4

is locally consistent.

Example 3.14. Consider again the setting of Example 3.1 (and Example 3.9) and
the database DB4 shown in Figure 7 over the relation symbol r (in Q4) and the symbols
for the views in V4 = views(Q4) ∪ {v1(A, B, C), v2(A, F )}. Recall from Example 3.3
that V DB4
Observe that for the query view v4(A, C), v4(A, C)DB4 consists of the two tu-
ples/homomorphisms (cid:104)a1, c1(cid:105) and (cid:104)a2, c2(cid:105). That is, this query view provides exactly
[{A, C}], i.e., the answers of Q4 projected over the
the two homomorphisms in QDB4
variables (A and C) of the view wr(A,C). Note that the same property holds for the
views over the set of variables {A, C}, {A, B}, {B, C}, {F, E}, {A, E}, and {A, B, C}.
Interestingly, each one of this set is tp-covered in Q4 (see also Example 3.13).

4

On the other hand, each one of the sets v7(D, B)DB4, v8(D, C)DB4 , and v2(A, F )DB4
contains two homomorphisms that do not correspond to any answer of the query
(suitably projected over the variables of interest), which are those identiﬁed by the
tuples marked with the symbol “(cid:73)” in Figure 7. In fact, we observe that, in this case,
{D, C}, {D, B}, and {A, F} are not tp-covered in Q4.

In the above example, the fact that homomorphisms that are not correct answers
are associated with views whose variables are not tp-covered is not by chance. Indeed,
 the intuition is now that to guarantee global consistency by just enforcing local
consistency, all the variables contained in query atoms must be tp-covered.

Note that in database queries, one is often interested in output variables that are
not covered by a single query atom. We thus prove below a slightly more general
result dealing with output variables covered by some view.6 For a set of variables O,
let covers(O) denote the set of all views w ∈ V such that O ⊆ vars(w).

Lemma 3.15. Assume that V DB is locally consistent. For each set of variables
O that is tp-covered in Q, every view w ∈ covers(O) satisﬁes wDB[O] ⊆ QDB[O].
Moreover, if there is some view ¯w ∈ covers(O) such that ¯wDB is view consistent, then
every view w ∈ covers(O) satisﬁes wDB[O] = QDB[O].

Proof. Let Qe = Q ∧ atom(O). Assume that O is tp-covered in Q, that is, there
exists Q(cid:48) ∈ cores(Qe) for which (HQ(cid:48),HV ) has a tree projection. Since Q(cid:48) is a core,
it is also a retract of Qe; that is, there is a homomorphism f from Qe to Q(cid:48) such that
f (X) = X, for every term X occurring in Q(cid:48). Clearly, f is a homomorphism from Q
to Q(cid:48), too. Then, for every (legal) database DB, Q(cid:48)DB ⊆ QDB[vars(Q(cid:48))]. Moreover,
consider the query W Q(cid:48) where we have query views in place of the original query
atoms, that is,

(cid:94)

W Q(cid:48) = atom(O) ∧

q∈atoms(Q(cid:48))\{atom(O)}

wq.

Because DB is a legal database, we immediately get W Q(cid:48)DB = Q(cid:48)DB ⊆ QDB[vars(Q(cid:48))]
and, hence, W Q(cid:48)DB[ ¯X] ⊆ QDB[ ¯X] holds as well, for any ¯X ⊆ vars(Q(cid:48)).
Now consider any (legal) database DB such that V DB is locally consistent and any
tree projection Ha of (HQ(cid:48),HV ). Assume w.l.o.g. that Ha and HQ(cid:48) are deﬁned over
the same set of nodes (otherwise, just drop possible additional variables, and you still
get a tree projection of (HQ(cid:48),HV )). Observe that O ⊆ hO, for some hyperedge hO
of Ha. Indeed, atom(O) ∈ atoms(Q(cid:48)), since atom(O) is deﬁned on a fresh relation

6For applications of our results to the general case of arbitrary sets of output variables, we refer

the interested reader to [37] and the references therein—see, also, section 5.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1129

symbol, and thus this atom must occur in every core of Qe, i.e., O is a hyperedge of
HQ(cid:48). Let H be the set of hyperedges in Ha and let us associate with Ha the query

Qa = W Q(cid:48) ∧ (cid:94)

atom(h).

h∈H

Note that QDB

For any fresh atom atom(h) ∈ atoms(Qa) (including atom(O)), let atom(h)DB =
vDB[h], where v ∈ V is any view satisfying h ⊆ vars(v), chosen according to some
ﬁxed (arbitrary) criterium. Such a view always exists because Ha is a tree projection
of (HQ(cid:48),HV ).
a ⊆ W Q(cid:48)DB, because W Q(cid:48) is a subquery of Qa. By construction 
Qa is a simple acyclic query, and atoms(Qa)DB is locally consistent because
all these relations are projections of views in the locally consistent set V DB. Thus,
by the results in [8], Qa is globally consistent and we get, for the atom atom(O),
a [O] ⊆ W Q(cid:48)DB[O] ⊆ QDB[O]. Moreover, since V DB is locally consis-
atom(O)DB = QDB
tent, this property must hold for every wDB, with w ∈ V and O ⊆ vars(w). That is,
wDB[O] ⊆ QDB[O] holds, for every w ∈ covers(O).
Assume now that the output variables O are covered by some view consistent
atom, i.e., O ⊆ vars( ¯w) for some ¯w ∈ V such that QDB[vars( ¯w)] ⊆ ¯wDB and thus
QDB[O] ⊆ ¯wDB[O]. Since V DB is locally consistent, it follows that ¯wDB[O] = atom(O)DB
and thus QDB[O] ⊆ atom(O)DB. Combined with the above relationship, we get the
desired equality QDB[O] = atom(O)DB. Again, since V DB is locally consistent, this
property must hold for every wDB, with w ∈ V and O ⊆ vars(w). That is, QDB[O] =
wDB[O], for every w ∈ covers(O).

From this result, we easily get the following suﬃcient condition for the global

consistency.

Theorem 3.16. Assume that, for every q ∈ atoms(Q), there exists a subquery Q(cid:48)
in Equiv (Q, q) such that (HQ(cid:48),HV ) has a tree projection. Then, for every database
DB, lc(V, DB) entails gc(V, DB, Q).

Proof. Let q ∈ atoms(Q). First note that there is a subquery Q(cid:48) in Equiv (Q, q)
such that (HQ(cid:48),HV ) has a tree projection if, and only if, the set of variables vars(q)
is tp-covered in Q (w.r.t. V).

Moreover, query views cover the variables of query atoms and are always view
consistent w.r.t. Q in any legal database; therefore the statement immediately follows
from Lemma 3.15.

of queries consists of the grid queries of the form GQn =(cid:86)

Having a tree projection of the full query is therefore not necessary for getting
global consistency through local consistency. For instance, an unexpectedly easy class
(e(X, Y )∧e(Y, X)),
where En is the edge set of an n × n grid. Indeed, while such grids are well-known
obstructions to the existence of tree decompositions, any of their edges is a core (and,
thus, trivially acyclic)—see Figure 9. Therefore, even the smallest possible set of
views V = views(GQn) is suﬃcient to obtain global consistency by enforcing local

X,Y ∈En

Fig. 9. Mapping an undirected grid into an edge.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1130

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

consistency. As we shall prove in section 3.3, Theorem 3.16 deﬁnes the most general
possible condition to guarantee global consistency, which is what we need to answer
the query by exploiting local consistency if the output variables are included in some
query atom.

Decision problem. The situation is rather diﬀerent if we just look for the most
general suﬃcient conditions to solve the decision problem QDB (cid:54)= ∅. In this case, the
existence of a tree projection of any structure for which there is an endomorphism of
the query is suﬃcient. Of course, any such subquery Q(cid:48) is homomorphically equivalent 
to Q, denoted by Q(cid:48) ≈hom Q in the following. In fact, the concept of tp-covering
is immaterial here, given that we are not interested in output variables (i.e., O = ∅).
Thus, as a special case of our analysis on the computation problem, we get the following 
result, which generalizes to tree projections (where cores may behave diﬀerently)
a similar suﬃcient condition known for the special cases of tree decompositions [19],
and generalized hypertree decompositions [15].

Theorem 3.17. Assume there is a subquery Q(cid:48) ≈hom Q for which (HQ(cid:48),HV ) has

a tree projection. Then, for every database DB, lc(V, DB) entails QDB (cid:54)= ∅.

Proof. Let Ha be a tree projection of (HQ(cid:48),HV ) for some Q(cid:48) ≈hom Q. Then, it
is also a tree projection of (HQ(cid:48)(cid:48) ,HV ) for any Q(cid:48)(cid:48) ∈ cores(Q(cid:48)) ⊆ cores(Q), because
HQ(cid:48)(cid:48) ≤ HQ(cid:48). From Lemma 3.12, for any (query atom) q ∈ atoms(Q(cid:48)(cid:48)), vars(q) is
q . Then, whenever
tp-covered in Q and thus, from Lemma 3.15, QDB[vars(q)] = wDB
lc(V, DB) holds, wDB

(cid:54)= ∅ and hence QDB (cid:54)= ∅.

q

Note that the above condition is more liberal than what we need for having global
consistency. In the next section we prove that it is in fact also a necessary condition
as far as the decision problem is concerned.

Moreover, we point out that, from an application perspective, either result above
may be useful only if we have some guarantee (or some eﬃcient way to check) that the
required conditions are met. Otherwise, as it happens for the decision problems in the
special cases of (generalized) (hyper)tree decompositions [15, 41], we are in a promise
setting where, in general, we are not able to actually compute any full (and thus
polynomial-time checkable) query answer (or disprove the “promise”). In particular,
it has been observed in a slightly diﬀerent setting by [37] (see, also, [58, 12]) that,
rather surprisingly, the global consistency property (and hence having a full reducer)
is not suﬃcient to actually compute a full query answer (unless P = NP). Intuitively
this is due to the fact that as soon as we ﬁx some tuple in a relation in order to extend
it to a full solution, we are changing the set of available query endomorphisms and
thus we may loose the property of some variables to be tp-covered. As a consequence,
subsequent propagations are not guaranteed to maintain the global consistency.

3.3. . . . and back to tree projections. The question of whether the cases in
which local consistency implies global consistency precisely coincide with the cases in
which there is a tree projection of the query with respect to a set of views was a longstanding 
open problem in the literature [34, 53]. We next answer this question, both
in the setting considered in those papers (where all relation symbols in the query are
distinct), with the answer being positive there, and in the unrestricted setting where
the answer is instead negative.
In fact, we precisely characterize the relationships
between local and global consistency and tree projections in the general setting too,
by showing that tree projections are still necessary, but not necessarily involving the
query as a whole.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1131

Decision problem. We start with the problem of checking whether the given
query is not empty. Theorem 3.19 below provides the counterpart of Theorem 3.17.
The proof requires some preparation.
Let DB be a database over the vocabulary DS. For the following results, we
assume that each relation symbol r ∈ DS of arity ρ is associated with a set of ρ
In this context, r
(distinct) attributes that identify the ρ positions available in r.
is also called relational schema, and DS is called database schema. An inclusion
dependency is an expression of the form r1[S] ⊆ r2[S], where r1 and r2 are two
relational symbols in DS and S is a set of attributes that r1 and r2 have in common.
A database DB over DS satisﬁes this inclusion dependency if, for each tuple t1 ∈ rDB
1 ,
there is a tuple t2 ∈ rDB
2 with t1[S] = t2[S] (where [·] is here the classical projection
relational operator applied to a set of attributes). Moreover, if DB satisﬁes each
inclusion dependency in a given set I, then we simply say that DB satisﬁes I.
Deﬁne A(DS) as the set of canonical atoms associated with the schema DS, that
is, the set containing, for each relation r of DS, the atom r(u) having as its variables
the attributes of r. A conjunctive query Q is said to be a canonical query for DS
whenever it consists of atoms from A(DS), i.e., atoms(Q) ⊆ A(DS) holds.
We are now ready to state a fundamental lemma on union of conjunctive queries,
i.e., on queries of the form Q = Q1 ∨ ··· ∨ Qn, where Qi is a conjunctive query
∀i ∈ {1, . . . , n}. We are interested in unions of Boolean queries, so that QDB (cid:54)= ∅
(cid:54)= ∅ for some query Qi in the union Q. The ingredients in the
if (and only if) QDB
lemma are a recent result on the ﬁnite controllability of unions of conjunctive queries
in the framework of databases under the open-world assumption [52], and a connection
between tree projections and the chase procedure ﬁrst observed in [53].

i

Lemma 3.18. Let DS be a database schema equipped with a set I of inclusion
dependencies. Let Q be a union of canonical queries for DS such that ∀ (ﬁnite)
DB (cid:54)= ∅ over DS, DB satisﬁes I ⇒ QDB (cid:54)= ∅. Then, there exists a conjunctive query
Q(cid:48) in the union Q such that (HQ(cid:48),HA(DS)) has a tree projection.

Proof. Unlike all other proofs in the paper, we next deal both with ﬁnite and
inﬁnite databases, and thus we always point out whether a database is (or may be)
inﬁnite. All databases are implicitly assumed to be over the database schema DS.
From the hypothesis, the following property holds for Q:

(P1) ∀ ﬁnite DB (cid:54)= ∅, DB satisﬁes I ⇒ QDB (cid:54)= ∅.
Let us start by taking an arbitrary atom rw(X1, . . . , Xm) in Q, and let DB0 =
{ rw(cX1 , . . . , cXm) }, where cX1 , . . . , cXm are fresh (distinct) constants. Trivially, P1
entails the following property:

(P2) ∀ ﬁnite DB ⊇ DB0, DB satisﬁes I ⇒ QDB (cid:54)= ∅.
Recall that the possibly inﬁnite database chase(I, DB0) is built from DB0 by
adding iteratively new tuples to satisfy inclusion dependencies in I, until no dependency 
is violated by the current database [9].
In the following, it is convenient to
represent chase(I, DB0) as a tree T of tuples rooted at rw(cX1, . . . , cXm) and where
edges are built as follows. Let DBi denote the set of all the tuples in chase(I, DB0)
associated with nodes in the ﬁrst i levels of T (the root is level 0). Let r(t) be a node
of T at level i. For each inclusion dependency r[A] ⊆ r(cid:48)[A] ∈ I such that there is no
tuple r(cid:48)(t(cid:48)) ∈ DBi that matches with r(t) over the attributes in A, a node r(cid:48)(t(cid:48)(cid:48)) is
added as a child of r(t), where r(cid:48)(t(cid:48)(cid:48)) is a fresh tuple that matches with r(t) over the
attributes in A and contains fresh constants of the form cY , for any (other) attribute
Y /∈ A in the schema of relation r(cid:48).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1132

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

A well-known property of chase(I, DB0) is that it maps via homomorphism to any
other (possibly inﬁnite) database that satisﬁes I and includes the nonempty database
chase(I,DB0) (cid:54)= ∅, the same holds for every database that
DB0. Therefore, whenever Q
satisﬁes I and includes DB0.

We now use the ﬁnite controllability result by Rosati [52] which, applied to our
Q, I, and DB0, reads as follows: the answer of ¯Q is not empty on every (possibly
inﬁnite) database that satisﬁes I and includes DB0 if, and only if, the answer of ¯Q is
not empty on every ﬁnite database that satisﬁes I and includes DB0 (by Theorem 2
in [52]).7 Therefore, P2 implies the following property:

chase(I,DB0) (cid:54)= ∅.

(P3) Q
Because Q is a union of conjunctive queries, this means that there is a query Q(cid:48)
in Q having a homomorphism h : vars(Q(cid:48)) (cid:55)→ Uc from Q(cid:48) to chase(I, DB0), where Uc
is the universe of chase(I, DB0). In particular, from a well-known result of Johnson
and Klug [43], we may assume, w.l.o.g., that the image of Q(cid:48) under h is included in
a ﬁnite subtree Tf of T —actually, they proved the stronger result that the image is
contained in some “initial portion” of T , but this is not essential to our ends, here.

Observe now that h is a bijection. Indeed, we have that DB0 contains the one
tuple rw(cX1, . . . , cXm) with a distinct constant for each attribute of rw and, by deﬁnition 
of chase(I, DB0), any constant cY can never be used for an attribute diﬀerent
from Y . In fact, either cY belongs to the starting tuple and it is then propagated
to fresh tuples by the chase generating rule or it is a fresh constant belonging to
a tuple created to satisfy some inclusion dependency (which does not involve attribute 
Y ). Moreover, recall that attributes in DS are in fact variables in Q(cid:48), because
the latter is a canonical query. Then, since h is a homomorphism, for each variable 
(attribute) Y , h(Y ) has the form cY for some constant cY occurring in tuples
of chase(I, DB0).
We now deﬁne a labeling λ, associating each node of Tf with a set of variables
in vars(Q(cid:48)). Let V = {h(X) | X ∈ vars(Q(cid:48))}. For each vertex p = r(cY1, . . . , cYn ) in
Tf , deﬁne λ(p) as the set {h−1(cYi) | cYi ∈ V }. Let p1 and p2 be two vertices of Tf
such that X ∈ λ(p1) ∩ λ(p2) is a variable in vars(Q(cid:48)). Consider the chase constant
h(X), which occurs in p1 and p2 in Tf . Let pX be the topmost vertex of Tf where
h(X) occurs. Because of the chase generating rule, each node in the path from pX
to p1 (resp., p2) contains the constant h(X). Thus, since Tf is a tree, h(X) occurs
in the path between p1 and p2. Therefore, X occurs in λ-labeling of each vertex in
this path, too. Now consider the hypergraph Ha containing exactly one hyperedge
λ(p), for each vertex p of Tf , and note that Ha is acyclic, because we have actually
just shown that the λ-labeling on Tf deﬁnes a join tree of Ha. Moreover, since h
is a homomorphism from Q(cid:48) to chase(I, DB0), for each atom q ∈ atoms(Q(cid:48)) there
exists a vertex p = h(q) in Tf for which λ(p) = vars(q); thus, HQ(cid:48) ≤ Ha. Finally, by
construction, each hyperedge λ(p) in Ha is built from a tuple p = r(cY1 , . . . , cYn ) of
chase(I, DB0), hence a tuple of (the relation of) some canonical atom ar in A(DS).
Moreover, we observed that, for each variable Yi ∈ λ(p), h−1(cYi ) = Yi ∈ vars(ar).
Then, λ(p) ⊆ vars(ar), and hence Ha ≤ HA(DS). All in all, we have shown that, for
the query Q(cid:48) in Q, there is a tree projection of HQ(cid:48) w.r.t. HA(DS).

7In particular,

it is shown that this is equivalent to the condition Qfchase(I,DB0,m)

(cid:54)= ∅,
where m is a ﬁnite natural number that depends on the given instance (including the query) and
fchase(I, DB0, m) is the so-called ﬁnite chase, that is, a nonempty ﬁnite database playing the same
role of the (possibly) inﬁnite chase, as far as the evaluation of ¯Q is concerned.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1133

We are now ready to state and prove the counterpart of Theorem 3.17. Note that,
in the statement of the result, we require that there is no tree projection for each core
of the query. Indeed, diﬀerent isomorphic cores may behave diﬀerently with respect
to the available views (see, again, Example 3.9).

Theorem 3.19. Assume there is no tree projection of (HQ(cid:48),HV ) for each core
Q(cid:48) ∈ cores(Q). Then, local consistency does not entail global consistency. In particular,
 there exists a (legal) database DB such that lc(V, DB) holds but QDB = ∅.

Proof. Recall that we assumed w.l.o.g. that no constants or repeated variables
occur in the views in V, while the query Q has no restriction. Moreover, each view
w ∈ V is over a distinct relation symbol (let us denote it by rw, in the following),
so that there is a one-to-one correspondence between relations and views. Therefore,
V identiﬁes a database schema DS consisting of such a relation rw, for each w ∈ V,
whose list of attributes is precisely the list of variables of the view w. Thus, V is by
construction the set of canonical atoms associated with DS.8
Let us equip DS with the following set I of inclusion dependencies: For each pair
of views w, w(cid:48) ∈ V such that S = vars(w)∩ vars(w(cid:48)) (cid:54)= ∅, I contains the two inclusion
dependencies rw[S] ⊆ rw(cid:48)[S] and rw(cid:48)[S] ⊆ rw[S].
Observe that, by the construction of I, for each database DB over DS, lc(V, DB)
holds if, and only if, DB satisﬁes I and DB (cid:54)= ∅ (recall that Q is connected and
vars(Q) = vars(V), hence HV is also connected because views(Q) ⊆ V).

For any set of atoms D, let us denote by (cid:86) D the Boolean conjunctive query
deﬁned as the conjunction of all atoms in D. Let Q = (cid:87)
Q(cid:48)∈cores(Q)((cid:86) views(Q(cid:48)))
((cid:86) views(Q(cid:48)))DBf = ∅. In particular, as this database satisﬁes I, lc(V, DBf ) holds.

be the union of (Boolean) canonical queries for DS obtained by considering the
cores of Q, and assume that there is no tree projection of (HQ(cid:48),HV ), and hence
of (Hviews(Q(cid:48)),HV ), for each core Q(cid:48) ∈ cores(Q). Then, by Lemma 3.18, there exists 
a (ﬁnite) database DBf (cid:54)= ∅ that satisﬁes I and such that ∀Q(cid:48) ∈ cores(Q),

From DBf , let us now build a new legal database instance DB(cid:48)

f over the vocabulary 
including both views and query atoms. This database is obtained by slightly
changing the relations in DBf in order to keep the information about the (active)
domains of the variables and by adding the relation instances for the query atoms in
Q. Recall that more query atoms may share the same database relation.
Let q ∈ atoms(Q) be any query atom deﬁned over a relation symbol r of arity ρ,
and let rwq (X1, . . . , Xn) ∈ views(Q) be the query view wq associated with q. Recall
that both constants and repeated variables may occur in q, so that ρ ≥ n. Let
f contains rwq ((cid:104)X1, c1(cid:105), . . . ,(cid:104)Xn, cn(cid:105))
rwq (c1, . . . , cn) be any tuple in DBf . Then, DB(cid:48)
in the relation instance for the query view wq ∈ V. Moreover, for the relation r,
f contains a tuple r(v1, . . . , vρ) deﬁned as follows. For each i ∈ {1, . . . , ρ}, if some
DB(cid:48)
constant term ui occurs in q at position i, then vi = ui; if some variable Xj occurs
in q at position i, then vi = (cid:104)Xj, cj(cid:105). Note that this value may occur in r(v1, . . . , vρ)
at diﬀerent positions if Xj occurs more than once in q. Moreover, if the relation r is
shared by diﬀerent query atoms, such a tuple r(v1, . . . , vρ) will be available to every
atom deﬁned over r, besides q. Finally, for any (nonquery view) w over a relation rw
and any tuple rw(c1, . . . , cn) ∈ DBf , DB(cid:48)
f contains a tuple rw((cid:104)X1, c1(cid:105), . . . ,(cid:104)Xn, cn(cid:105)).
No further tuples belong to DB(cid:48)
f .

8We remark that the assumption that no constant or repeated variables occur in views is just
for the sake of presentation. If this assumption does not hold, it is suﬃcient to deﬁne a database
schema DS(cid:48) obtained from V by removing such useless occurrences, to use its canonical atoms, and
to manage, after the described construction, the correspondence between relations in DS(cid:48) and views
in V.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1134

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

As lc(V, DBf ) holds, we immediately have that lc(V, DB(cid:48)

In particular, for any tuple r(v1, . . . , vρ) in DB(cid:48)

(cid:54)= ∅, and let h(cid:48) be a homomorphism from Q(cid:48) to DB(cid:48)

f = ∅, for each subquery Q(cid:48) ∈ cores(Q), which entails QDB

f ) holds, too. We now
claim that Q(cid:48)DB
(cid:48)
(cid:48)
f =
∅.
Indeed, assume for the sake of contradiction that there is a core Q(cid:48) such that
Q(cid:48)DB
(cid:48)
f . Deﬁne π1 and π2
f
to be the projections mapping a binary tuple (cid:104)u, c(cid:105) to its ﬁrst element u and to
its second element c, respectively; moreover, for a plain (term) element u, π1(u) =
π2(u) = u.
f , where any value vi
is either of the form (cid:104)ui, ci(cid:105) or of the form ui with ui being a constant term, we
have π1(r(v1, . . . , vρ)) = r(π1(v1), . . . , π1(vρ)) = r(u1, . . . , uρ). By construction of the
f , the composition h(cid:48) ◦ π1 is a homomorphism from Q(cid:48) to Q (if we obtain
tuples in DB(cid:48)
a certain tuple of terms after applying π1, there must exist some query atom with that
tuple of terms). But, since Q(cid:48) is a core, we have that the image Q(cid:48)(cid:48) = (h(cid:48) ◦ π1)(Q(cid:48)) is
also a core in cores(Q), and thus h(cid:48) ◦ π1 is actually an isomorphism. In particular,
h(cid:48)(cid:48) = ((h(cid:48) ◦ π1)−1 ◦ h(cid:48)) is now such that h(cid:48)(cid:48)(ui) = (cid:104)ui, ci(cid:105). In particular, whenever
ui = X, for some variable X ∈ vars(Q(cid:48)(cid:48)), h(cid:48)(cid:48)(X) = (cid:104)X, ci(cid:105).
It follows that h(cid:48)(cid:48)
f . Then, we immediately get that h(cid:48)(cid:48) ◦ π2 is a
is a homomorphism from Q(cid:48)(cid:48) to DB(cid:48)
atoms(Q(cid:48)(cid:48)) deﬁned on a relation r, if r(u1, . . . , uρ) ∈ DB(cid:48)
f , then π2(rwq (¯u1, . . . , ¯un)) ∈
DBf (with (cid:104)¯u1, . . . , ¯un(cid:105) being the tuple derived from (cid:104)u1, . . . , uρ(cid:105) by inverting the
above construction, i.e., by eliminating constants and repeated variables). However,

homomorphism from(cid:86) views(Q(cid:48)(cid:48)) to DBf . Indeed, by construction, for each atom q ∈
the existence of this homomorphism contradicts the fact that ((cid:86) views(Q(cid:48)(cid:48)))DBf = ∅

holds by the construction of DBf .

Finally, note that DB(cid:48)
(cid:48)
f

q ⊆ qDB
wDB

(cid:48)
f , and wq is trivially view consistent because QDB

f = ∅.
(cid:48)

f is legal. Indeed, for each query view wq, by construction

A consequence of the above result and Theorem 3.17 is the precise characterization 
of the power of local consistency, as far as the decision problem is concerned.
This characterization was so far only known for the special case of treewidth and for
structures of ﬁxed arity [6], where, however, all the cores enjoy the same structural
properties (and hence such results are deﬁned in terms of “the core” of the query).
The result entails Theorem 1.13 stated in the introduction.

Corollary 3.20. The following are equivalent:
(1) For every database DB, lc(V, DB) entails QDB (cid:54)= ∅.
(2) There is a subquery Q(cid:48) ≈hom Q for which (HQ(cid:48),HV ) has a tree projection.
(3) There is a core Q(cid:48)(cid:48) of Q for which (HQ(cid:48)(cid:48) ,HV ) has a tree projection.
Proof. From Theorem 3.17, we know that (2) implies (1). Theorem 3.19 entails
that (1) implies (3). Finally, (3) implies (2) because any core of Q is homomorphically
equivalent to Q.

Eventually, we can specialize Corollary 3.20 to the setting of simple queries (considered 
in many seminal papers about tree projections, such as [34]), where every relation 
symbol occurs at most once in the query—so the whole query is its (unique) core.
Corollary 3.21. Let Q be a simple query. Then, the following are equivalent:
(1) For every database DB, lc(V, DB) entails QDB (cid:54)= ∅.
(2) (HQ,HV ) has a tree projection.
Example 3.22. Consider the query

Q7 :

r1(A, B) ∧ r2(B, C) ∧ r3(C, D) ∧ r4(D, E) ∧ r5(A, E),

the set of views V7 = {v1(A, B, E), v2(B, C, E), v3(A, C, E), v4(A, C, D), v5(A, D, E)},
and the database instance DB7 depicted in Figure 10. It is easy to check that (V7 ∪

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1135

Fig. 10. The (hypergraph of the) query Q7, the nonquery views in V7, and their respective

tuples in the database DB7 of Example 3.22.

atoms(Q7))DB7 is local consistent but QDB7
(HQ7 ,HV7) does not have a tree projection.

7 = ∅.

Indeed, it can be checked that

Computation problem. We next complete the picture and give the conditions 
that precisely characterize those cases where answers of the query over output
variables covered by some view may be immediately obtained by enforcing local consistency.
 Again, we start with the problem where we are interested in query answers
over some arbitrary set of output variables.

In this case, requiring that just some view covering O is trustable is suﬃcient to

allow all such answers to be immediately obtained.

the following are equivalent:

Theorem 3.23. Let O be any set of variables occurring in some view in V. Then,
(1) For each database DB where lc(V, DB) holds, every view w ∈ covers(O) satisﬁes 
wDB[O] ⊆ QDB[O].
(2) For each database DB where lc(V, DB) holds, if there is some view ¯w ∈
covers(O) such that ¯wDB is view consistent, then every view w ∈ covers(O)
satisﬁes wDB[O] = QDB[O].

(3) The set of variables O is tp-covered in Q (w.r.t. V).
Proof. First observe that (3) entails (1) and (2), by Lemma 3.15. We now show
that when (3) does not hold, then neither (1) nor (2) holds. To this end, it suﬃces
to consider the case where there exists Q(cid:48)(cid:48) ∈ cores(Q) for which (HQ(cid:48)(cid:48),HV ) has a
tree projection. Otherwise, we immediately get that all views are incorrect for some
database (and also trivially view consistent) from Theorem 3.19. Consider the new
query Qe = Q ∧ atom(O), and assume by contradiction that O is not tp-covered in
Q. That is, for every Q(cid:48) ∈ cores(Qe), (HQ(cid:48),HV ) has no tree projections. We show
that there exists a database DB such that lc(V, DB) holds but QDB[O] ⊂ aDB[O], for
every a ∈ covers(O), where covers(O) (cid:54)= ∅, by hypothesis. In particular, the database
is deﬁned such that these views are view consistent.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1136

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

Let Ve = V ∪ {atom(O)}.

(cid:48)

Since no core of Qe has tree projections, by
Theorem 3.19 it follows that there is a (nonempty legal) database DB(cid:48) such that
lc(Ve, DB(cid:48)), but QDB
e = ∅. Now deﬁne a new database DB such that, for every
a ∈ Ve, aDB = aDB
(cid:48) ∪ QDB
[a], and where the relations in DB(cid:48) over which the original
(cid:48)
query atoms are deﬁned are just copied into DB. By construction, lc(Ve, DB) holds,
because lc(Ve, DB(cid:48)) holds and the tuples possibly added to any view are projections
of mappings over the full set of variables, as they are obtained from the total ho-
(cid:48)
momorphisms in QDB
. Moreover, note that only views are modiﬁed, as no tuple is
added to the relations over which the original atoms in the query are deﬁned. Thus,
(cid:48)
QDB = QDB
holds. In particular, by construction of DB, aDB is view consistent, for
every view a.
Observe that DB is a legal database instance w.r.t. Q. Indeed, the relations for
query views are still subsets of the relations of the original query atoms (as in DB(cid:48)).
Moreover, by construction, they include all tuples that are part of some query answer,
and thus all query views are view consistent w.r.t. Q.
Recall now that we are considering the case where some cores of Q have tree projections,
 and lc(Ve, DB) and hence lc(V, DB) hold. From Theorem 3.17, it follows that
= ∅. It follows that all homomorphisms
QDB = QDB
that are answers of Q over DB(cid:48) do not satisfy atom(O), that is, QDB
=
(cid:48) (cid:54)= ∅, because lc(Ve, DB(cid:48)) holds. Therefore, we get the
∅, and recall that atom(O)DB
proper inclusion QDB[O] ⊂ atom(O)DB. Indeed, atom(O)DB
is not empty and all its
[O] = QDB[O] (cid:54)= ∅, are kept in atom(O)DB. Finally,
tuples, which do not belong to QDB
and hence V DB are locally consistent, this also entails atom(O)DB = aDB[O]
since V DB
and thus QDB[O] ⊂ a[O]DB, for each view a ∈ covers(O).

(cid:48) (cid:54)= ∅. However, (Q ∧ atom(O))DB

[O]∩atom(O)DB

e

(cid:48)

(cid:48)

(cid:48)

(cid:48)

(cid:48)

The following result is the specialization to the case where we are interested in
those sets of output variables covered by query atoms. It follows from Theorems 3.23
and 3.16, and it is clearly equivalent to (it is a rephrasing of) Theorem 1.14 stated in
the introduction.

Corollary 3.24. The following are equivalent:
(1) For every database DB, lc(V, DB) entails gc(V, DB, Q).
(2) For each q ∈ atoms(Q), there exists a subquery Q(cid:48) in Equiv (Q, q) such that

(HQ(cid:48),HV ) has a tree projection.

The specialization of Corollary 3.24 to the setting where every relation symbol
occurs at most once in the query provides the answer to the question posed by [34].
Corollary 3.25. Let Q be a simple query. Then, the following are equivalent:
(1) For every database DB, lc(V, DB) entails gc(V, DB, Q).
(2) (HQ,HV ) has a tree projection.
Finally, we point out that Theorem 3.23 may be equivalently stated in terms
of any arbitrary (legal) database DB, by considering its reduct red(V, DB) obtained
enforcing local consistency.

Corollary 3.26. Let O be any set of variables occurring in some view in V.
(1) For each database DB, every view w ∈ covers(O) satisﬁes wDB
[O] ⊆ QDB[O],
(2) For each database DB, if there is some view ¯w ∈ covers(O) such that ¯wDB is
[O] = QDB[O],

Then, the following are equivalent:
where DB(cid:48) = red(V, DB).
view consistent, then every view w ∈ covers(O) satisﬁes wDB
where DB(cid:48) = red(V, DB).

(cid:48)

(cid:48)

(3) The set of variables O is tp-covered in Q (w.r.t. V).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1137
Proof. (1) ⇒ (3) follows from the corresponding implication (1) ⇒ (3) in Theorem 
3.23 which entails that, whenever O is not tp-covered in Q (w.r.t. V), there
exists a locally consistent legal database DB and a view w ∈ covers(O) such that
wDB[O] ⊃ QDB[O]. In fact, because it is locally consistent, DB coincides with its reduct
red(V, DB). The same line of reasoning shows (2) ⇒ (3). Finally, (3) ⇒ (1) ∧ (2) follows 
from the corresponding implication in Theorem 3.23. Just note that the only
tuples occurring in DB and deleted in its reduct DB(cid:48) do not participate in any query
answer. Therefore, DB(cid:48) is a legal locally consistent database and, regarding (2), ¯wDB
(cid:48)
is view consistent.

4. Application to structural decomposition methods. In this section, we
specialize our results about consistency properties and tree projections to the purely
structural decomposition methods described in the literature (both in the database
and in the constraint satisfaction area). Indeed, each of them can be seen as a method
to deﬁne suitable set of views to be exploited for solving the given query answering
instance. Here, views represent subproblems over subsets of variables, whose solutions
can be computed eﬃciently.

We provide further results that hold on such special cases only, such as the positive 
answer to the question in [15] about k-local consistency and generalized hypertree
decompositions, and the precise relationship between acyclic queries and local consistency,
 solved in [8] for the simple queries, only. Contrasted with the results in
section 3, where the input instance includes arbitrary views, these results refer to
scenarios where the input instance includes only the relations over the vocabulary of
the query and where further views have to be computed on top of them by some algorithm 
determined by a speciﬁc method. Both settings have their own independent
theoretical and practical interest. In particular, the precise characterization of the
power of local consistency in the more speciﬁc scenarios studied in this section does
not follow immediately from the results in section 3.

4.1. Decomposition methods and views. We start by formalizing the concept 
of the structural decomposition method in our framework. Let the pair (Q, DB)
be any query answering problem instance. For any subset of variables S ⊆ vars(Q),
let (Q|S, DB|S) be the subproblem of (Q, DB) induced by S deﬁned as follows:
for
each atom a ∈ atoms(Q) with vars(a) ∩ S (cid:54)= ∅, Q|S contains an atom a(cid:48) over a fresh
relation symbol ra(cid:48) having vars(a) ∩ S as its set of variables and whose database relation 
is such that a(cid:48)DB|S = aDB[S]. No further atom belongs to Q|S, and no further
relation belongs to DB|S. Intuitively, (Q|S, DB|S) is the most constrained subproblem 
of (Q, DB) where only variables from S occur, because all atoms involving (even
partially) those variables are considered. In particular, for each subquery Q(cid:48) whose
set of variables is S, we have Q(cid:48)DB ⊇ QDB|S

|S ⊇ QDB[S].

Definition 4.1. A structural decomposition method DM is described by a pair of
polynomial-time computable functions v-DM and d-DM that, given a conjunctive query Q
and a database DB(cid:48), compute, respectively, a view system V = v-DM(Q) and a database
DB(cid:48)(cid:48) = d-DM(Q, DB(cid:48)) over the vocabulary of V such that9
• the database DB = DB(cid:48) ∪ DB(cid:48)(cid:48) over the (disjoint) vocabularies of Q and V is

legal, and

9For the sake of presentation, we do not consider FPT decomposition methods (where functions
v-DM and d-DM are computable in ﬁxed-parameter polynomial time), but our results can be extended
easily to them.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1138

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

Fig. 11. Structures discussed in Example 4.2.

• for each w ∈ V, wDB ⊇ QDB|vars(w)

|vars(w) . That is, any view w contains at least the
solutions of the subproblem of (Q, DB) induced by its variables (subproblem
completeness).

Note that the above completeness property is a local property and clearly entails

the (global) view consistency property for V DB.

Every known purely structural decomposition method DM, where views (subprob-
lems) are only determined by the query and do not depend on the database instance,
can be recast this way, with decompositions of Q according to DM being tree projections 
of (HQ,HV ). Indeed, all such methods are in fact subproblem-based, because
any view relation wDB is instantiated with the solutions Q(cid:48)DB of some subquery Q(cid:48)
(depending on the speciﬁc method), which is not necessarily an induced subproblem.
Some exempliﬁcations of the above deﬁnition are discussed below.

Tree decompositions. For any ﬁxed natural number k, the tree decomposition
method [21, 25] (twk) is characterized by the functions v -twk and d -twk that, given
a query Q and a database DB, build the view system v -twk (Q) and the database
d -twk (Q, DB). In particular, for each subset S of at most k + 1 variables, there is a
view wS over the variables in S (i.e., vars(wS) = S) whose tuples are the solutions of
the subproblem induced by S (or, more liberally, the cartesian product of the set of
constants that variables in S may take). An illustration of the view set characterizing
treewidth is reported below.

Example 4.2. Consider the query

Q8 : r1(A, B) ∧ r2(B, C) ∧ r3(A, C) ∧ r4(C, D),

whose associated hypergraph is depicted on the left of Figure 11. Consider the application 
on Q8 of the tree decomposition method. The set of views v -tw 2 (Q8 ) deﬁned
by this method for k = 2 is graphically illustrated on the right of Figure 11. In fact,
the ﬁgure shows how Q8 can be covered via an acyclic hypergraph that consists of
two hyperedges covered by two available views, the largest of which includes three
variables. In fact, the treewidth of Q8 is 2.

Generalized hypertree decompositions. For any ﬁxed natural number k,
the generalized hypertree decomposition method [29] (hwk for short) is characterized
by the functions v -hwk and d -hwk that, given a query Q and a database DB, build
the view system v -hwk (Q) and the database d -hwk (Q, DB) where, for each subquery
Q(cid:48) of Q such that |atoms(Q(cid:48))| ≤ k, there is a view wQ(cid:48) over all variables in Q(cid:48) (i.e.,
vars(wQ(cid:48)) = vars(Q(cid:48))) and whose tuples are the answers of Q(cid:48). Note that hwk satisﬁes

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1139
the subproblem completeness property too, because Q(cid:48) is in general more liberal than
the subproblem induced by vars(Q(cid:48)). Indeed, the latter also deals with further atoms
where such variables occur (possibly together with other variables not in Q(cid:48)).

Acyclicity. Recall that a hypergraph is acyclic if, and only if, it has (generalized)
hypertree width 1 [29]. Therefore, the acyclicity method (acyc for short) is just the
specialization of the above method for the case of k = 1. In particular, v -acyc(Q) is
precisely the set of query views views(Q).

Fractional hypertree decompositions. For any ﬁxed natural number k, consider 
the subqueries characterizing the fractional hypertree decompositions [42]: they
are deﬁned precisely as in the case of the generalized hypertree decomposition method,
except that a view wQ(cid:48) is built more generally if, for a subquery Q(cid:48), its hypergraph
HQ(cid:48) has fractional edge-cover number [42] at most k. Unfortunately, these views
may be exponentially many even if k is a ﬁxed constant, and in fact there is no
known polynomial-time algorithm to decide whether the fractional hypertree width
of a hypergraph is at most k. However, we may still deﬁne the required pair of
polynomial-time functions v -fwk and d -fwk for this decomposition method, by actually 
exploiting for their computation the subproblems identiﬁed by Marx in his O(k3)
polynomial-time approximation of the fractional hypertree width [49]. Moreover, following 
the same kind of arguments used for the generalized hypertree decompositions,
it can be seen that the subproblem completeness property is satisﬁed by such a pair
of functions, too.

Submodular width. For the sake of completeness, we also mention the method
based on the notion of submodular width [50], which does not ﬁt the above framework 
and does not guarantee polynomial-time tractability, but just ﬁxed-parameter
tractability, where the number of variables ν occurring in the query (or also the size
of the query) is used as the parameter. This is an interesting notion, because the
classes of hypergraphs having bounded submodular width are the only classes of hypergraphs 
such that the queries deﬁnable over these hypergraphs can be answered
in ﬁxed-parameter polynomial time for every database (under the exponential-time
hypothesis) [50].

The algorithm proposed to exploit the submodular width computes a set of Ω(22ν
)
instances obtained by considering suitable horizontal fragments of the database relations.
 For each of these instances, the available views are all the possible views having
a polynomial number of tuples. The bound on the submodular width then guarantees
that, for any of such instances, the available views for that instance are suﬃcient
for the existence of a tree projection. It is worthwhile noting that such views are not
“view consistent” with respect to the original query. Indeed, by using more restrictive
views, the algorithm obtains the desired horizontal fragments.

Contrasted with the previous structural methods, this algorithm is not “purely”
structural, because the views are deﬁned according to the speciﬁc database associated
with each (sub)instance (while v-DM functions depend on the query only).

4.2. Decomposition methods and consistency properties. By using Theorem 
3.23, it is possible to characterize the power of local-consistency-based algorithms
in structural decomposition methods, as stated below.10 In fact, this result is not a
trivial consequence of Corollary 3.26, as it is evident by contrasting their statements:

10For completeness, we observe that a similar result has been proved in [37] in the setting of

constraint satisfaction problems by precisely exploiting Theorem 3.23.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpGIANLUIGI GRECO AND FRANCESCO SCARCELLO

1140
here, the database DB(cid:48)(cid:48) for the views is computed from a database over the vocabulary
of the query Q only, according to the speciﬁc function d-DM characterizing the method
DM, while it is an arbitrary (legal) database in Corollary 3.26.

Theorem 4.3. Let DM be a decomposition method, let Q be a conjunctive query,
let O ⊆ vars(Q) be any set of variables, and let V = v-DM(Q). Then, the following are
equivalent:
(1) For every database DB (over the vocabulary of Q) and for every view w ∈ V
[O] = QDB[O], where DB(cid:48) = red(V, DB(cid:48)(cid:48)) and DB(cid:48)(cid:48) =

with O ⊆ vars(w), wDB
(cid:48)
d-DM(Q, DB).

(2) The set of variables O is tp-covered in Q (w.r.t. V).
Proof. The fact that (2) ⇒ (1) immediately follows from Corollary 3.26. We
have to show that (1) ⇒ (2) holds as well. Observe that if O is not tp-covered in Q
w.r.t. V = v-DM(Q), by Theorem 3.23 we conclude the existence of a locally consistent
(legal) database DB = DBQ ∪ DBV , with DBQ being over the vocabulary of Q and
with DBV being over the vocabulary of V, respectively, and the existence of a view
¯w ∈ V such that ¯wDB[O] ⊃ QDB[O], with O ⊆ vars( ¯w). Let DB(cid:48)(cid:48) = d-DM(Q, DBQ) be
the database comprising the relations for the views in V built according to method
DM, and let DB(cid:48) = red(V, DB(cid:48)(cid:48)) be its reduct, obtained by enforcing local consistency.
We ﬁrst claim that the database DBV is included in DB(cid:48)(cid:48), formally, for any w ∈ V,
wDB = wDBV ⊆ wDB
. Consider such a view w ∈ V, having variables S = vars(w),
(cid:48)(cid:48)
and the subproblem (Q|S, DB|S) of (Q, DB) induced by S. By construction, only
variables from S occur in Q|S and thus, for each atom a ∈ atoms(Q|S), vars(a) ⊆ S.
It trivially follows that the pair of hypergraphs (HQ|S ,HV ) has a tree projection.
Let V +
S = V ∪ views(Q|S) be the set of views obtained by adding to V the query
views associated with the subquery induced by the chosen set S, and let DB+
S be the
database obtained by adding to DB the relations in DB|S, as well as their copies on
the relation symbols of the query views views(Q|S). Clearly, DB+
S is a legal database
(w.r.t. Q|S and V +
S is a view system for Q|S. Moreover, since we just added
new views to V, the pair (HQ|S ,HV +
) has a tree projection, too. In particular, from
Fact 3.11, S is tp-covered in Q|S w.r.t. V +
S . Moreover, observe that the database
relations for the new views in V +
S are just projections of the relations of the original
query views, which already belong to V. Therefore, their presence has no impact on
the local consistency property, and lc(V +
S , DB+
S ) holds. By Theorem 3.23, for every
O(cid:48) ⊆ S, we get wDB[O(cid:48)] = wDB
S [O(cid:48)] ⊆ QDB|S
[O(cid:48)]. That is, wDB contains only solutions
|S
of the subproblem induced by w. On the other hand, the subproblem completeness
. Hence the claim follows, as for any chosen
condition entails that wDB
w ∈ V with variables S = vars(w), wDB ⊆ QDB|S
To conclude, recall that lc(V, DBV ) holds, so that DBV is a locally consistent
database included in DB(cid:48)(cid:48), and thus all its tuples will survive after enforcing local
consistency on DB(cid:48)(cid:48), that is, all of them belong to the reduct DB(cid:48) = red(V, DB(cid:48)(cid:48)).
(cid:48) ∀w ∈ V. In particular, for the view ¯w and the set of variables
Therefore, wDB ⊆ wDB
O ⊆ vars( ¯w), we get QDB[O] ⊂ ¯wDB[O] ⊆ ¯wDB
[O], hence we get wrong solutions (over
O) using the view ¯w with the database DB(cid:48).

|S ⊆ wDB

S ) and V +

(cid:48)(cid:48) ⊇ QDB|S

|S

(cid:48)(cid:48)

.

+

S

(cid:48)

The latter result immediately entails Theorem 1.11 stated in the introduction
in terms of properties of k-local consistency.
In particular, for k = 1 it entails
Theorem 1.7, characterizing the relationship between local and global consistency
in acyclic queries. For the decision problem (O = ∅), instead, we get the following
special case.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1141

entails QDB (cid:54)= ∅.

and let V = v-DM(Q). The following are equivalent:

Corollary 4.4. Let DM be a decomposition method, let Q be a conjunctive query,
(1) For every database DB (over the vocabulary of Q), red(V, d-DM(Q, DB)) (cid:54)= ∅
(2) There is a subquery Q(cid:48) ≈hom Q for which (HQ(cid:48),HV ) has a tree projection.
(3) There is a core Q(cid:48)(cid:48) of Q for which (HQ(cid:48)(cid:48) ,HV ) has a tree projection.
If we consider decision problem instances (O = ∅) and the treewidth method
(V = v -twk (Q)), from Corollary 4.4, we (re-)obtain the nice characterization of [6] on
the relationship between k-local consistency and the treewidth of the core of Q.11
If we consider the generalized hypertree width (V = v -hwk (Q)), we next provide
the answer to the corresponding open question for the unbounded arity case. Recall
that if the core of Q has generalized hypertree width at most k, then the procedure
enforcing k-union (of constraints/atoms) consistency is always correct, i.e., the reduct
of the database is not empty if, and only if, the query has some answer [15]. We
next show that this suﬃcient condition is necessary, too. The result does not follow
immediately from Corollary 4.4. Indeed, any core Q(cid:48) of Q may be much smaller than
Q, and thus the set of views v -hwk (Q(cid:48)) available using Q(cid:48) is in general (possibly much)
smaller than the set of views v -hwk (Q) available when the whole query Q is considered.
For an extreme example, think of the undirected grid (see again Figure 9), where any
edge is a core:
in this case, the set of available views for computing a hypertree
decomposition of the core is precisely this one edge (for any k), while considering the
whole query, the available views comprise all unions of k edges.

ing are equivalent:

entails QDB (cid:54)= ∅.

This subtle issue is irrelevant for the treewidth method, because such a technique
considers all possible combinations of at most k variables, and clearly only those
variables occurring in the core are useful for computing any of its tree decompositions.
Instead, when generalized hypertree decomposition is considered, in principle using
some particular combination of variables occurring in some atom outside any core Q(cid:48)
may be necessary for getting a width-k generalized hypertree decomposition of Q(cid:48).
Theorem 4.5. Let Q be a conjunctive query, and let V = v -hwk (Q). The follow-
(1) For every database DB (over the vocabulary of Q), red(V, d -hwk (Q, DB)) (cid:54)= ∅
(2) There is a subquery Q(cid:48) ≈hom Q having generalized hypertree width at most k.
(3) There is a core Q(cid:48) of Q having generalized hypertree width at most k.
Proof. It suﬃces to show that (3) is equivalent to (3(cid:48)) below. Then, the theorem
(3(cid:48)) There is a core Q(cid:48) of Q for which (HQ(cid:48),HV ) has a tree projection, with
Let V(cid:48) = v -hwk (Q(cid:48)). Note that (3) is equivalent to saying that (HQ(cid:48),HV(cid:48)) has a
tree projection, which entails (3(cid:48)), because Q(cid:48) is a subquery of Q and thus HV(cid:48) ≤ HV .
It remains to show that (3(cid:48)) ⇒ (3). Assume by contradiction that this is not the
case, hence there is a core Q(cid:48) of Q for which (HQ(cid:48),HV ) has a tree projection Ha, but
every core of Q has generalized hypertree width greater than k. In particular, this
must hold for Q(cid:48), too.
It follows that there exists some hyperedge h that belongs
to Ha and thus is covered by some hyperedge of HV , but it is not covered by any

follows from Corollary 4.4.

V = v -hwk (Q).

11As already observed, for treewidth and (generalized) hypertree width isomorphic substructures
behave in the same way, so that all cores have equivalent properties. Thus, for these methods one
may simply say “the core” Q(cid:48) (instead of some core).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpGIANLUIGI GRECO AND FRANCESCO SCARCELLO

1142
hyperedge of HV(cid:48), where V(cid:48) = v -hwk (Q(cid:48)). That is, there is no view w in V(cid:48) such
that h ⊆ vars(w). Recall that, by deﬁnition of function v -hwk , views in V (resp., V(cid:48))
contain the union of variables from all possible sets of at most k atoms occurring in Q
(resp., Q(cid:48)). It follows that there is some atom a ∈ atoms(Q) with ¯X = vars(a)∩h (cid:54)= ∅
which does not belong to Q(cid:48) and whose role in w cannot be played by any other atom
in Q(cid:48). Formally, there is no atom a(cid:48) ∈ atoms(Q(cid:48)) such that ¯X(cid:48) ⊆ vars(a(cid:48)), where
¯X(cid:48) = ¯X ∩ vars(Q(cid:48)).
In fact, note that ¯X(cid:48) are the only possible crucial variables:
further variables of w not occurring in Q(cid:48) are never necessary in any tree projection
of HQ(cid:48) (w.r.t. any hypergraph), as it is known and easy to see that if a tree projection
exists, there always exists one that uses only nodes from HQ(cid:48) [35].
However, Q(cid:48) is a core of Q, and thus it is a retract, which means that there must
exist a homomorphism f from Q to Q(cid:48) where f (X) = X, for each term X occurring
in Q(cid:48). Therefore, the atom a should be mapped to some atom a(cid:48) ∈ atoms(Q(cid:48)) that
contains all variables f (X) for each X ∈ vars(a). In particular, this entails that all
variables in ¯X(cid:48) occur in a(cid:48), because f is the identity mapping over them. This is a
contradiction.

The above result clearly entails Theorem 1.10 stated in the introduction. Moreover,
 for the special case of k = 1, it entails Theorem 1.6 and provides the precise
characterization of the power of local consistency in Boolean acyclic queries, extending 
the classical result given in [8] for simple queries (in fact, for acyclic schemas).
Recall that for the acyclic method, the set of views v -acyc(Q) is just the set of query
views views(Q), and their database relations in d -acyc(Q, DB) are just the copies of
their corresponding query atoms.

Theorem 4.6. For any conjunctive query Q, the following are equivalent:
(1) For every database DB (over the vocabulary of Q), red(v -acyc(Q), d -acyc
(2) There is an acyclic subquery Q(cid:48) ≈hom Q.
(3) Q is semantically acyclic (equivalently, it has an acyclic core).

(Q, DB)) (cid:54)= ∅ entails QDB (cid:54)= ∅.

5. Conclusion. In this paper, we have fully characterized the power of algorithms 
for evaluating conjunctive queries (and constraint satisfaction problems) based
on enforcing local consistency. We studied both the general framework where consistency 
is enforced over arbitrary views and the more speciﬁc cases where views are
computed according to structural decomposition methods. For these settings, we
provided necessary and suﬃcient conditions for the correctness of tuples occurring
in views when local consistency holds. The results allow us to identify classes of
queries that can be answered in polynomial time whenever output variables are covered 
by views satisfying such conditions. Based on these ﬁndings, in two companion
papers [37, 38], we identiﬁed classes of queries where answers over arbitrary sets of
variables can be enumerated with polynomial delay.12 However, a precise characterization 
of the tractability frontier for answering conjunctive queries in this general
setting is still missing even for the bounded-arity case [41, 12]. Moreover, in the general 
unbounded-arity case, the frontier of tractability is not known even for Boolean
conjunctive queries. Recall that the notion of submodular width [50] allows us to identify 
the class of hypergraphs such that all possible conjunctive queries having those

12Unlike the case where variables are covered by some view, the number of query answers can
be exponential over arbitrary sets of variables. Hence, tractability means here computing the ﬁrst
answer (if any) in polynomial time and, then, computing all answers without repetitions leaving (at
most) polynomial time between two successive answers.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1143

hypergraphs as their structures are ﬁxed-parameter tractable (where the parameter
is the size of the hypergraph, and assuming the exponential-time hypothesis). As a
consequence, we now have an interesting gap to be explored between the polynomialtime 
tractability of instances having bounded fractional hypertree width [42, 49] and
the ﬁxed-parameter tractability of instances having bounded submodular width.

In addition to the questions mentioned in the Introduction, it is worthwhile recalling 
another open question that eventually ﬁnds an answer with the results described
in this paper. The question was raised in [34], where the tree projection theorem was
proved. Roughly, a query program P is a ﬁnite sequence of steps involving project,
select, and join operations. The relation computed in the ﬁnal step is the result of P .
The tree projection theorem states that a query program P solves a query Q (i.e., the
result of P always coincides with the answers of Q over its set of output variables)
if, and only if, there is a tree projection of Q w.r.t. the hypergraph associated with
the various relations/views determined by P . A crucial point here is that P is a
ﬁxed program, so that the number of its operations does not depend on the database
size. The natural question in [34] was therefore to ask what happens if P is allowed
to contain a “semijoin loop,” that is, a loop that is to be executed until nothing
changes in the involved relations/views. Is it the case that the tree projection theorem 
still holds for such programs, where the number of steps is data-dependent? The
results in the paper provide a positive answer to this question for the setting of simple
queries (implicitly) considered in [34] and, in fact, also a complete answer covering
the general conjunctive queries, which may contain more atoms over the same relation
symbol.

REFERENCES

[1] S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases. Addison-Wesley, Reading,

MA, 1995.

[2] I. Adler, Marshals, monotone marshals, and hypertree-width, J. Graph Theory, 47 (2004), pp.

275–296.

[3] I. Adler, Width Functions for Hypertree Decompositions, Ph.D. thesis, University of Freiburg,

2006.

[4] I. Adler, Tree-related widths of graphs and hypergraphs, SIAM J. Discrete Math., 22 (2008),

pp. 102–123.

[5] I. Adler, G. Gottlob, and M. Grohe, Hypertree-width and related hypergraph invariants,

European J. Combin., 28 (2007), pp. 2167–2181.

[6] A. Atserias, A. Bulatov, and V. Dalmau, On the power of k-consistency, in Proceedings of

ICALP’07, 2007, pp. 279–290.

[7] P. Barcel´o, M. Romero, and M. Y. Vardi, Semantic acyclicity on graph databases, SIAM

J. Comput., 45 (2016), pp. 1339–1376.

[8] C. Beeri, R. Fagin, D. Maier, and M. Yannakakis, On the desirability of acyclic database

schemes, J. ACM, 30 (1983), pp. 479–513.

[9] C. Beeri and M. Vardi, A proof procedure for data dependencies, J. ACM, 31 (1984), pp.

718–741.

[10] P. A. Bernstein and N. Goodman, The power of natural semijoins, SIAM J. Comput., 10

(1981), pp. 751–771.

[11] H. L. Bodlaender and F. V. Fomin, A linear-time algorithm for ﬁnding tree-decompositions

of small treewidth, SIAM J. Comput., 25 (1996), pp. 1305–1317.

[12] A. Bulatov, V. Dalmau, M. Grohe, and D. Marx, Enumerating homomorphisms, J. Comput.
 System Sci., 78 (2013), pp. 638–650.

[13] A. K. Chandra, D. C. Kozen, and L. J. Stockmeyer, Alternation, J. ACM, 26 (1981), pp.

114–133.

[14] A. K. Chandra and P. M. Merlin, Optimal implementation of conjunctive queries in relational 
data bases, in Proceedings of STOC’77, 1977, pp. 77–90.

[15] H. Chen and V. Dalmau, Beyond hypertree width: Decomposition methods without decompositions,
 in Proceedings of CP’05, 2005, pp. 167–181.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1144

GIANLUIGI GRECO AND FRANCESCO SCARCELLO

[16] D. A. Cohen and P. Jeavons, The complexity of constraint languages, in Handbook of Constraint 
Programming, F. Rossi, P. van Beek, and T. Walsh, eds., Elsevier, New York,
2006.

[17] D. A. Cohen, P. Jeavons, and M. Gyssens, A uniﬁed theory of structural tractability for

constraint satisfaction problems, J. Comput. System Sci., 74 (2008), pp. 721–743.

[18] M. C. Cooper and S. Zivny, Hybrid tractability of valued constraint problems, Artiﬁcial

Intelligence, 175 (2011), pp. 1555–1569.

[19] V. Dalmau, Ph. G. Kolaitis, and M. Y. Vardi, Constraint satisfaction, bounded treewidth,

and ﬁnite-variable logics, in Proceedings of CP’02, 2002, pp. 310–326.

[20] R. Dechter, Constraint Processing, Morgan Kaufmann, Burlington, MA, 2003.
[21] R. Dechter and J. Pearl, Tree clustering for constraint networks, Artiﬁcial Intelligence, 38

(1989), pp. 353–366.

[22] R. Fagin, Degrees of acyclicity for hypergraphs and relational database schemes, J. ACM, 30

(1983), pp. 514–550.

[23] J. Flum, M. Frick, and M. Grohe, Query evaluation via tree-decompositions, J. ACM, 49

(2002), pp. 716–752.

[24] P. Fraigniaud and N. Nisse, Connected treewidth and connected graph searching, in Proceedings 
of LATIN’06, 2006, pp. 479–490.

[25] E. C. Freuder, Complexity of K-tree structured constraint satisfaction problems, in Proceedings 
of the 8th National Conference on Artiﬁcial Intelligence, 1990, pp. 4–9.

[26] G. Gottlob, G. Greco, N. Leone, and F. Scarcello, Hypertree decompositions: Questions

and answers, in Proceedings of PODS’16, 2016, pp. 57–74.

[27] G. Gottlob, N. Leone, and F. Scarcello, A comparison of structural CSP decomposition

methods, Artiﬁcial Intelligence, 124 (2000), pp. 243–282.

[28] G. Gottlob, N. Leone, and F. Scarcello, The complexity of acyclic conjunctive queries, J.

ACM., 48 (2001), pp. 431–498.

[29] G. Gottlob, N. Leone, and F. Scarcello, Hypertree decompositions and tractable queries,

J. Comput. System Sci., 64 (2002), pp. 579–627.

[30] G. Gottlob, N. Leone, and F. Scarcello, Robbers, marshals, and guards: Game theoretic
and logical characterizations of hypertree width, J. Comput. System Sci., 66 (2003), pp.
775–808.

[31] G. Gottlob, Z. Mikl´os, and T. Schwentick, Generalized hypertree decompositions: NPhardness 
and tractable variants, J. ACM, 56 (2009).

[32] G. Gottlob and A. Nash, Eﬃcient core computation in data exchange, J. ACM, 55 (2008).
[33] N. Goodman and O. Shmueli, Syntactic characterization of tree database schemas, J. ACM,

30 (1983), pp. 767–786.

[34] N. Goodman and O. Shmueli, The tree projection theorem and relational query processing, J.

Comput. System Sci., 29 (1984), pp. 767–786.

[35] G. Greco and F. Scarcello, Tree projections and structural decomposition methods: Minimality 
and game-theoretic characterization, Theoret. Comput. Sci., 522 (2014), pp.
95–114.

[36] G. Greco and F. Scarcello, The power of tree projections: Local consistency, greedy
in Proceedings of PODS’10, 2010, pp.

algorithms, and larger islands of tractability,
327–338.

[37] G. Greco and F. Scarcello, Structural tractability of enumerating CSP solutions, Constraints,
 18 (2013), pp. 38–74.

[38] G. Greco and F. Scarcello, Structural tractability of constraint optimization, in Proceedings

of CP’11, 2011, pp. 340–355.

[39] G. Greco and F. Scarcello, Counting solutions to conjunctive queries: Structural and hybrid

tractability, in Proceedings of PODS’14, 2014, pp. 132–143.

[40] G. Greco and F. Scarcello, Greedy strategies and larger islands of tractability for conjunctive 
queries and constraint satisfaction problems, Inform. and Comput., 252, (2017), pp.
201–220.

[41] M. Grohe, The complexity of homomorphism and constraint satisfaction problems seen from

the other side, J. ACM, 54 (2007).

[42] M. Grohe and D. Marx, Constraint solving via fractional edge covers, ACM Trans. Algorithms,
 11 (2014), pp. 4:1–4:20.

[43] D. Johnson and A. Klug, Testing containment of conjunctive queries under functional and

inclusion dependencies, J. Comput. System Sci., 28 (1984), pp. 167–189.

[44] D. S. Johnson, A Catalog of Complexity Classes, in Handbook of Theoretical Computer
Science, Volume A: Algorithms and Complexity, MIT Press, Cambridge, MA, 1990, pp.
67–161.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpTHE POWER OF LOCAL CONSISTENCY

1145

[45] S. Karakashian, R. J. Woodward, C. G. Reeson, B. Y. Choueiry, and C. Bessiere, A
ﬁrst practical algorithm for high levels of relational consistency, in Proceedings of AAAI’10,
2010.

[46] Ph. G. Kolaitis, Constraint satisfaction, databases, and logic, in Proceedings of IJCAI’03,

2003, pp. 1587–1595.

[47] P. G. Kolaitis and M. Y. Vardi, Conjunctive-query containment and constraint satisfaction,

J. Comput. System Sci., 61 (2000), pp. 302–332.

[48] A. Lustig and O. Shmueli, Acyclic hypergraph projections, J. Algorithms, 30 (1999), pp.

400–422.

[49] D. Marx, Approximating fractional hypertree width, ACM Trans. Algorithms, 6 (2010).
[50] D. Marx, Tractable hypergraph properties for constraint satisfaction and conjunctive queries,

J. ACM, 60 (2013).

[51] N. Robertson and P. D. Seymour, Graph minors III: Planar tree-width, J. Combin. Theory

Ser. B, 36 (1984), pp. 49–64.

[52] R. Rosati, On the ﬁnite controllability of conjunctive query answering in databases under

open-world assumption, J. Comput. System Sci., 77 (2011), pp. 572–594.

[53] Y. Sagiv and O. Shmueli, Solving queries by tree projections, ACM Trans. Database Systems,

18 (1993), pp. 487–511.

[54] O. Reingold, Undirected ST-connectivity in log-space, J. ACM, 55 (2008).
[55] W. L. Ruzzo, Tree-size bounded alternation, J. Cumput. System Sci., 21 (1980), pp. 218–235.
[56] P. D. Seymour and R. Thomas, Graph searching and a min-max theorem for tree-width, J.

Combin. Theory Ser. B, 58 (1993), pp. 22–33.

[57] F. Scarcello, G. Greco, and N. Leone, Weighted hypertree decompositions and optimal

query plans, J. Comput. System Sci., 73 (2007), pp. 475–506.

[58] F. Scarcello, G. Gottlob, and G. Greco, Uniform constraint satisfaction problems and
in Complexity of Constraints, Lecture Notes in Comput. Sci. 5250,

database theory,
Springer-Verlag, New York, 2008, pp. 156–195.

[59] S. Subbarayan and H. Reif Andersen, Backtracking procedures for hypertree, hyperSpread
and connected hypertree decomposition of CSPs, in Proceedings of IJCAI’07, 2007, pp.
180–185.

[60] R. E. Tarjan and M. Yannakakis, Simple linear-time algorithms to test chordality of graphs,
test acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs, SIAM J. Comput.,
13 (1984), pp. 566–579.

[61] J. D. Ullman, Principles of Database and Knowledge Base Systems, Computer Science Press,

Rockville, MD, 1989.

[62] M. Yannakakis, Algorithms for acyclic database schemes, in Proceedings of VLDB’81, 1981,

pp. 82–94.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php