Theory Comput Syst (2011) 49:639–670
DOI 10.1007/s00224-010-9292-5

Regular Languages of Nested Words: Fixed Points,
Automata, and Synchronization

Marcelo Arenas · Pablo Barceló · Leonid Libkin

Published online: 16 September 2010
© Springer Science+Business Media, LLC 2010

Abstract Nested words provide a natural model of runs of programs with recursive
procedure calls. The usual connection between monadic second-order logic (MSO)
and automata extends from words to nested words and gives us a natural notion of
regular languages of nested words.

In this paper we look at some well-known aspects of regular languages—their
characterization via ﬁxed points, deterministic and alternating automata for them, and
synchronization for deﬁning regular relations—and extend them to nested words. We
show that mu-calculus is as expressive as MSO over ﬁnite and inﬁnite nested words,
and the equivalence holds, more generally, for mu-calculus with past modalities evaluated 
in arbitrary positions in a word, not only in the ﬁrst position. We introduce the
notion of alternating automata for nested words, show that they are as expressive as
the usual automata, and also prove that Muller automata can be determinized (unlike
in the case of visibly pushdown languages). Finally we look at synchronization over
nested words. We show that the usual letter-to-letter synchronization is completely
incompatible with nested words (in the sense that even the weakest form of it leads
to an undecidable formalism) and present an alternative form of synchronization that
gives us decidable notions of regular relations.

This is the full version of the extended abstract presented at the 34th Intl. Colloquium on Languages,
Automata, and Programming, ICALP’07.

M. Arenas
Departamento de Ciencia de la Computación, Pontiﬁcia Universidad Católica de Chile, Santiago,
Chile
e-mail: marenas@ing.puc.cl

P. Barceló
Departamento de Ciencia de la Computación, Universidad de Chile, Santiago, Chile
e-mail: pbarcelo@dcc.uchile.cl
L. Libkin ((cid:2))
School of Informatics, University of Edinburgh, Edinburgh, UK
e-mail: libkin@inf.ed.ac.uk

640

Theory Comput Syst (2011) 49:639–670

Keywords Automata · Nested words · Mu-calculus · Query languages · Automatic
structures

1 Introduction

Nested words, introduced by Alur and Madhusudan [6], extend ﬁnite or inﬁnite words
with a hierarchical nesting structure. The intuitive idea is that a nested word represents 
a model of execution of a program with recursive procedure calls; the nesting
relation then connects matching calls and returns, while other elements correspond to
internal operations. An example of a ﬁnite nested word is shown in the picture below,
where the ri’s are returns matching calls ci’s.

Such structures naturally appear in XML documents that are string representations of
trees using opening and closing tags [8, 32], or in software veriﬁcation of programs
with stack-based control ﬂow [2, 4]. A nested word automaton [6] runs from left
to right, similarly to a ﬁnite state automaton, but each time it encounters a “return”
position, the next state depends not only on the current state but also on the state of
the matching “call”.

A nice property of nested words and their automata is that they share logical characterizations 
with the usual (unnested) words: the ﬁnite-automaton model has the
same expressiveness as monadic second-order logic (MSO) [5, 6]. This gives us a
natural and robust notion of regular languages of nested words, with the expected
closure properties, decision procedures, and logical characterizations.

For ﬁnite or inﬁnite unnested words, an alternative way of describing regularity
logically is via the modal μ-calculus (cf. [7]). That is, μ-calculus formulae evaluated
in the ﬁrst position of a word deﬁne precisely the regular languages. Moreover, μcalculus 
formulae with past modalities evaluated in an arbitrary position of a word
have precisely the power of MSO formulae with one free ﬁrst-order variable. As
our ﬁrst result, we extend these equivalences to the case of ﬁnite and inﬁnite nested
words.

We then look at automata characterizations of regular languages of nested words.
Nondeterministic and deterministic automata have previously been considered [5, 6,
25], and [5] showed that automata can be determinized in the ﬁnite case, but in the
inﬁnite case this is impossible even for automata with a Muller acceptance condition
(unlike in the case of the usual ω-words). Then [25] introduced a different automaton
model and showed that it admits a determinization procedure over nested words. We
expand this in two ways. First we introduce alternation in the case of nested word
automata, and prove that alternating automata can still be translated into nondeterministic 
ones. Second, we reﬁne the determinization procedure for automata from
[25] to show that over inﬁnite nested words, every regular language is deﬁnable by a
deterministic Muller automaton. This also gives us some corollaries about the structure 
of regular languages of nested ω-words.

Theory Comput Syst (2011) 49:639–670

641

We ﬁnally turn our attention to the notion of regular relations. Over words or
trees, one moves from sets to relations by using letter-to-letter synchronization. For
example, over words, an automaton runs over a tuple of words viewing the tuple of
ith letters of the words as a single letter of an expanded alphabet [18]. The same
approach works for trees, ranked and unranked [11]. The notion of regular relations
also leads to a notion of automatic structures [10, 13, 15], i.e. decidable ﬁrst-order
structures over words in which all deﬁnable relations are regular.

In the case of nested words, there are two ways of synchronizing them: either by
considering their linear structure, as for words, or by considering the tree structure
imposed by the nesting relation. While in the latter case we essentially deal with the
known case of trees, we show that, in contrast, the notion of letter-to-letter synchronization 
that uses the linear structure is incompatible with nested words: the simplest
extension of nested word automata with such synchronization is undecidable. We
also show how the tree synchronization can be interpreted over the linear structure,
by presenting an alternative call-return notion of synchronization.

Related work Regular languages of nested words are a special case of visibly pushdown 
languages (VPL) [5], which are a restriction of the class of context-free languages 
that subsumes all regular properties and some non-regular properties relevant
in program analysis (e.g. stack-inspection properties and pre-post conditions). VPLs
in many ways resemble regular languages: they have the same closure properties,
and most natural problems related to them are decidable. The idea of VPLs is that
the input alphabet  is partitioned into three parts, c, r , i, of symbols viewed
as procedure calls, returns, and internal operations. A machine model for VPLs is a
special pushdown automaton that pushes a symbol onto the stack in a call, pops one
symbol in a return, and does not touch the stack when reading an internal symbol.

VPLs were introduced in [5] and regular languages of nested words in [6]. Nested
words can be viewed as special classes of trees (and we shall use this often in the
paper); such tree representations were introduced in [5, 6] as well. Applications in
program analysis are discussed, e.g., in [2, 4], and applications in processing treestructured 
data in [8, 32]. Alternating automata for nested words were introduced
independently, and at about the same time, in [14]. In this paper, we compare our
automata model with the automata model introduced in [14] and, in particular, we
use a result from [14] to prove that alternation can be eliminated in our case.

There are several related results on μ-calculus and MSO, e.g. their equality over
inﬁnite binary trees [29] or ﬁnite unranked trees [9] or expressive-completeness of
μ-calculus [21]. We explain in Sect. 3 why we cannot derive our result from those.
Another ﬁxed-point logic VPμ is deﬁned in [2] to specify properties of executions of
programs. It differs from the standard versions of μ-calculus we look at as its ﬁxed
points are evaluated not over sets of nodes but over sets of subtrees of the program;
further, its expressiveness is known to be different from MSO [3].

Nondeterministic automata for VPLs and regular languages of nested words were
deﬁned in [5, 6], and [5] observed that Muller automata for VPLs (over inﬁnite words)
are not determinizable. Then [25] noticed that this is due to VPLs having potentially
arbitrarily many unmatched calls/returns, and introduced a different automaton model
(stair automata) that can be determinized. We use them to show how to determinize

642

Theory Comput Syst (2011) 49:639–670

ﬁnite-state Muller automata over nested ω-words. None of these papers addresses
alternating automata over nested words.

Letter-to-letter synchronization for deﬁning regular relations is an old notion [18],
and the concept of universal automatic structures [13, 15] is based on it. Although
such automatic structures exist for both words and trees [10, 11], we show here that
letter-to-letter synchronization is incompatible with nesting structure. A very different 
notion of synchronization for pushdown automata (that generalizes VPLs) was
studied in [16].

Organization Basic deﬁnitions are given in Sect. 2. We describe MSO unary queries
via μ-calculus in Sect. 3. In Sect. 4 we study automata for nested words, deﬁne alternating 
automata, and describe determinization for Muller automata. In Sect. 5 we
look at synchronization and regular relations for nested words.

∗

+

+

2 Preliminaries
Words, ω-words, and automata Let  be a ﬁnite alphabet. A ﬁnite word w =
is represented as a logical structure (cid:3){1, . . . , n} , (Pa)a∈ , <(cid:5), where
a1 . . . an in 
< is the usual linear order on {1, . . . , n}, and Pa is the set of i’s such that ai = a.
We shall use w to refer to both the word and its logical representation. Inﬁnite, or ωwords,
 are sequences a1a2 ··· of symbols in  indexed by positive natural numbers,
and are represented as structures (cid:3)N
, (Pa)a∈ , <(cid:5). The length of w is denoted by
|w|.
A (nondeterministic ﬁnite-state) automaton A over  is a tuple (, Q, Q0, δ, F ),
where Q is a ﬁnite set of states, Q0 ⊆ Q is a set of initial states, F ⊆ Q is a set
of ﬁnal states and δ : Q ×  → 2Q is a transition function. For automata over ωwords 
we shall use either a Büchi acceptance condition (given by F ⊆ Q) or a
Muller acceptance condition (given by F ⊆ 2Q). A run of A over a word w of
length n is a map ρ : {1, . . . , n + 1} → Q such that ρ(1) ∈ Q0 and ρ(i + 1) ∈
δ(ρ(i), ai ), for all i ≤ n. Equivalently, a run of A over an ω-word w is a map
ρ : N
+ → Q such that ρ(1) ∈ Q0 and ρ(i + 1) ∈ δ(ρ(i), ai ), for all i. The run
ρ on a ﬁnite word w is accepting if ρ(|w| + 1) ∈ F . We let Inf (ρ) be the set of
states that occurs inﬁnitely often in a run ρ over an ω-word; that is, Inf (ρ) = {q ∈
Q | there exist inﬁnitely many i ∈ N
such that ρ(i) = q}. Then ρ is accepting for a
Büchi condition F if Inf (ρ) ∩ F (cid:10)= ∅, and it is accepting for a Muller condition F
if Inf (ρ) ∈ F. A word is accepted iff there exists an accepting run on it. Sets of
(ω-)words accepted by automata are called regular.
A is deterministic if |Q0| = 1, and |δ(q, a)| = 1 for every a ∈  and q ∈ Q. Nondeterministic 
automata over ω-words with Büchi and Muller conditions are equivalent,
 and automata with Muller acceptance conditions can be determinized, cf. [33].
Nested words A ﬁnite nested word over  is a pair ¯w = (w, η), where w ∈ 
and
η is a binary matching relation on {1, . . . ,|w|} that satisﬁes: (1) η(i, j ) implies i < j ;
(2) η(i, j ) and η(i, j
; and (3) if
η(i, j ), η(i
A nested ω-word is a pair ¯w = (w, η), where w is an ω-word and η is a match-
+
satisfying conditions (1)–(3) above. We also refer to them as inﬁnite

and η(i, j ) and η(i
< j .

, j ) imply i = i

then either j < i

(cid:12)

) imply j = j

(cid:12)

, j

), and i < i

ing on N

(cid:12)

(cid:12)

(cid:12)

(cid:12)

or j

(cid:12)

(cid:12)

∗

(cid:12)

Theory Comput Syst (2011) 49:639–670

643

nested words. We represent nested words as logical structures over the vocabulary
{(Pa)a∈, <, η}, i.e. words expanded with a matching relation. For a nested word ¯w
and two positions i < j , we let ¯w[i, j] be the substructure of ¯w induced by positions
(cid:7) such that i ≤ (cid:7) ≤ j .
A position i of a nested word ¯w is: (1) a call position if there is j such that η(i, j )
holds; (2) a return position if there is j such that η(j, i) holds; and (3) an internal
position if it is neither a call nor a return. Clearly, the sets of call, return and internal
positions of a nested word are pairwise disjoint. Whenever η(i, j ) holds we say that
i is the call of j , and j is the return of i.
Nested word automata A nested word automaton, or NWA [6], A over  is deﬁned
as a usual automaton, except that δ is a triple (δc, δι, δr ) of transition functions δc, δι :
Q ×  → 2Q, and δr : Q × Q ×  → 2Q. A run of A over ¯w = (a1 ··· , η) is a
mapping ρ : {1, . . .} → Q such that ρ(1) ∈ Q0 and for every i ∈ N
(or i ∈ [1,| ¯w|]
for ﬁnite nested words),
• if i is a call position, then ρ(i + 1) ∈ δc(ρ(i), ai );
• if i is an internal position, then ρ(i + 1) ∈ δι(ρ(i), ai );
• if i is a return position whose matching call is j , then ρ(i + 1) ∈ δr (ρ(i), ρ(j ), ai ).
Büchi and Muller acceptance conditions can then be deﬁned in exactly the same way
as for the usual automata (and are easily shown to be equivalent over nested words,
for nondeterministic automata). We refer to such automata as ω-NWAs. An NWA is
deterministic if the values of all transition functions are singletons.

+

A set of nested (ω-)words accepted by an (ω-)NWA is called regular.

Monadic second-order logic and μ-calculus Monadic second-order logic (MSO)
extends ﬁrst-order logic with quantiﬁcation over sets. Over nested words, its vocabulary 
contains predicates Pa (a ∈ ), < and η. That is, MSO over nested words is
deﬁned as:
(cid:12)

:= Pa(x) | X(x) | x ≤ y | η(x, y) | ϕ ∨ ϕ

ϕ, ϕ

(cid:12) | ¬ϕ | ∃xϕ | ∃Xϕ,

where a ranges over , x ranges over a countably inﬁnite set of ﬁrst-order variables
{x, y, . . .}, and X ranges over a countably inﬁnite set of monadic second-order variables 
{X, Y, . . .}.

Intuitively, ﬁrst-order variables in MSO formulas are interpreted as positions in a
nested word, while monadic second-order variables range over sets of positions in a
nested word. Given a nested word ¯w, a valuation σ that assigns a position in ¯w to
each ﬁrst-order variable x, and a valuation v that assigns a set of positions in ¯w to
each monadic second-order variable X, we formally deﬁne the semantics of MSO
formulas over nested words as follows (omitting the rules for Boolean connectives):
• ( ¯w, σ, v) |= Pa(x) iff σ (x) belongs to the interpretation of Pa in ¯w;
• ( ¯w, σ, v) |= x ≤ y iff σ (x) ≤ σ (y) holds in ¯w;
• ( ¯w, σ, v) |= η(x, y) iff η(σ (x), σ (y)) holds in ¯w;
• ( ¯w, σ, v) |= X(x) iff σ (x) ∈ v(X);
• ( ¯w, σ, v) |= ∃xϕ iff there exists a position i in ¯w such that ( ¯w, σ[x → i], v) |= ϕ,
where σ[x → i] extends the valuation σ by assigning position i to the variable x;
and

644

Theory Comput Syst (2011) 49:639–670

• ( ¯w, σ, v) |= ∃Xϕ iff ( ¯w, σ, v[X → I]) |= ϕ, for some set I of positions in ¯w, where
v[X → I] extends the valuation v by assigning the set I to the variable X.
Let ϕ be an MSO formula without free second-order variables. As usual, we write
ϕ(x1, . . . , xn) to denote that x1, . . . , xn are the free ﬁrst-order variables of ϕ. Further,
 if σ (xj ) = ij (1 ≤ j ≤ n) then we write ¯w |= ϕ(i1, . . . , in) instead of (w, σ ) |=
ϕ(x1, . . . , xn).

Notice that it is not necessary to extend the MSO vocabulary of nested words
with unary predicates that identify which positions are calls, returns, and internals,
since they are easily deﬁnable in the language by means of the formulas ∃yη(x, y),
∃yη(y, x), and ¬∃y(η(x, y) ∨ η(y, x)), respectively.

It follows from [5, 6] that Büchi’s theorem—showing that in the absence of nesting
a language (of words or ω-words) is regular iff it is MSO deﬁnable—extends to nested
words. That is, a set of nested words or nested ω-words is regular (accepted by an
(ω-)NWA) iff it is deﬁnable by an MSO sentence (an MSO formula without free
variables).

The μ-calculus over nested words, denoted by Lμ, is deﬁned by the grammar:

(cid:12)

:= a | X | ϕ ∨ ϕ

(cid:12) | ϕ ∧ ϕ

(cid:12) | ¬ϕ | ♦ϕ | ♦ηϕ | μX.ϕ(X)

ϕ, ϕ

with X occurring positively in ϕ(X) (i.e. X occurs in ϕ(X) under the scope of an even
number of negations), and a ∈  ∪ {call, int, ret}. Given a nested (ω-)word ¯w
(ﬁnite or inﬁnite), a position i in ¯w, and a valuation v assigning to each free variable
X a set v(X) of positions of ¯w, the semantics is as follows (omitting the rules for
Boolean connectives):
• ( ¯w, v, i) |= int iff i is an internal position; ( ¯w, v, i) |= call iff i is a call position;
 and ( ¯w, v, i) |= ret iff i is a return position.
• ( ¯w, v, i) |= a, for a ∈ , iff i is labeled a.
• ( ¯w, v, i) |= X iff i ∈ v(X).
• ( ¯w, v, i) |= ♦ϕ iff i + 1 belongs to ¯w and ( ¯w, v, i + 1) |= ϕ.
• ( ¯w, v, i) |= ♦ηϕ iff there is an (cid:7) such that η(i, (cid:7)) holds and ( ¯w, v, (cid:7)) |= ϕ.
• ( ¯w, v, i) |= μX.ϕ(X) iff i is in the least ﬁxed point of the operator deﬁned by ϕ; in
other words, if i ∈ (cid:2){P | {i
) |= ϕ} ⊆ P}, where v[P /X] extends
the valuation v by assigning to X the set of positions P .

(cid:12) | ( ¯w, v[P /X], i

(cid:12)

The μ-calculus over words mentions neither the modality ♦ηϕ nor the predicates
call, ret and int.

We include conjunction in our deﬁnition of Lμ, in addition to negation and disjunction,
 since later we will need to talk about the restriction of Lμ without negation,
but in which both disjunction and conjunction are used. Notice that the predicate
call is only syntactic sugar, as it can easily be deﬁned in the logic by ♦η(a ∨ ¬a).
On the other hand, both ret and int add expressive power, as without them the
language lacks the ability to talk about the past. In order to overcome this lack of
expressive power, we shall also work with the full μ-calculus [35] (denoted by Lfull
μ ),
which is an extension of Lμ with the past modalities ♦−
• ( ¯w, v, i) |= ♦−

ϕ iff i > 1 and ( ¯w, v, i − 1) |= ϕ.

ϕ and ♦−
η ϕ:

Theory Comput Syst (2011) 49:639–670

645

η ϕ iff there is an (cid:7) such that η((cid:7), i) holds and ( ¯w, v, (cid:7)) |= ϕ.

• ( ¯w, v, i) |= ♦−
Greatest ﬁxed-points νX.ϕ(X) are deﬁnable in Lμ as ¬μX.¬ϕ(¬X). Using greatest
ﬁxed-points and (cid:3)ϕ (deﬁned as ¬♦¬ϕ), one can push all negations to atoms in Lμ
formulae. For resulting formulae, an important parameter is the alternation-depth of
least and greatest ﬁxed-points [7]. We refer to Lk
μ as the fragment of Lμ that consists
of formulae of alternation depth at most k (e.g., the alternation-free fragment is L0
μ).
Languages and unary queries Formulae of Lμ (without free variables) are satisﬁed
in positions of a nested word, and thus they naturally give rise to classes of unary
queries that return, for ¯w, the set {i | ( ¯w, i) |= ϕ}. Every Lμ formula ϕ without free
variables also deﬁnes a language (i.e. a class of nested words) { ¯w | ( ¯w, 1) |= ϕ}.
Likewise, every MSO formula ϕ(x) with one free ﬁrst-order variable deﬁnes a unary
query, and every MSO sentence deﬁnes a language. In the absence of nesting, it is
well-known (see, e.g., [7, 29]) that a language (of words or ω-words) is deﬁnable by
a Lμ formula iff it is deﬁnable by an MSO sentence (not using the nesting relation
η).

3 Mu-Calculus over Nested Words

Since NWA generalize ﬁnite state automata, the translation from MSO over nested
words to NWAs is non-elementary. But just as for ﬁnite words or trees, one can ﬁnd
equally expressive logical formalisms with better model-checking complexity. We
show that the equivalence MSO = Lμ extends from words and trees to nested words.
It applies not only in sentences evaluated in the ﬁrst position of a nested word, but
more generally to unary queries that select a set of positions in which a temporal
formula is true. This is relevant for ﬁnite nested words viewed as streaming XML
documents: while theoretical investigations have mostly looked at the case of sentences 
[8, 32], in practical application one typically needs to evaluate unary queries
(e.g. XPath) over such streams [30]. To deal with unary queries, we look at Lμ with
the past, i.e. Lfull

μ , and prove that it is equivalent to MSO unary queries. That is:

Theorem 3.1 For ﬁnite nested words and nested ω-words, MSO and Lfull
same classes of unary queries.

μ deﬁne the

As a corollary to the proof, we obtain the fact that if we only want to deﬁne languages 
of nested words expressible in MSO then we can get rid of the past modalities:

Corollary 3.2 The languages of nested words (resp. nested ω-words) deﬁnable in
MSO and Lμ are the same.

+
We can tighten this for ﬁnite nested words. Let (Lfull
μ )

be the negation-free (and
thus alternation-free) fragment of Lfull
μ that has two additional constants “ﬁrst” and
“last” with their intuitive meanings: “ﬁrst” holds only at the ﬁrst position of a nested
+
word, and “last” holds at the last position. Likewise we deﬁne (Lμ)

from Lμ.

646

Corollary 3.3 For unary queries over ﬁnite nested words, MSO = Lfull
+
Furthermore, MSO, Lμ, and (Lμ)

.
deﬁne the same languages of ﬁnite nested words.

Theory Comput Syst (2011) 49:639–670
= (Lfull
+
μ )

μ

+
From [17], we conclude that for every (Lfull
μ )

word ¯w, the set {i | ( ¯w, i) |= ϕ} can be computed in time O(|ϕ| · | ¯w|).

formula ϕ and every ﬁnite nested

We make a couple of remarks before proving Theorem 3.1. Nested words are
naturally translated into trees, (in fact we shall use this translation in our proof), and
there is a closely related result in the literature, Niwinski’s theorem, showing that
over the full inﬁnite binary tree, MSO and Lμ, evaluated at the root of the tree, are
equally expressive [29]. Despite this, there does not seem to be any easy adaptation
of proof techniques in [29] that yields a proof of Theorem 3.1. Not only do we need
a stronger result for unary queries and an extension with the past modalities, but in
addition translations of inﬁnite nested words are not complete binary trees (in fact,
they have only one inﬁnite path).

Another natural attempt at a proof is to use the expressive-completeness result of
Janin and Walukiewicz: every bisimulation-invariant MSO property is deﬁnable in
Lμ [21]. Then we could express runs of tree automata on tree encodings of nested
words by bisimulation-invariant MSO sentences, apply [21] to get an equivalent Lμ
formula for trees, and translate it into an Lμ formula over nested words. This sketch
indeed can be turned into a proof of MSO = Lμ for languages of nested words, but it
breaks already for unary queries over ﬁnite nested words, where one needs to encode
a more complicated run of a query automaton [26, 28], and it is even harder to adapt
this argument to inﬁnite nested words for which we do not have an automaton model
capturing unary queries. Thus, we shall give a direct proof, based on the composition
method [27] and a translation from nested words ¯w into binary trees T ¯w which is a
slight modiﬁcation of the one in [5].
Let us recall the following before proving Theorem 3.1. A -labeled binary tree is
a structure T = (D,≺0,≺1, (Pa)a∈ ), where D is a preﬁx-closed subset of {0, 1}∗
,
s ≺0 s · 0 for each s · 0 ∈ D, s ≺1 s · 1 for each s · 1 ∈ D, and Pa is the set of nodes
in D that are labeled a. We say that T is ﬁnite if D is ﬁnite; otherwise it is inﬁnite.
For a binary tree T and a node s of T , we denote by Ts the subtree of T rooted at s,
and by T s the envelope of s in T , that is, the subtree of T obtained by removing all
proper descendants of s in T . Thus, Ts and T s only have the node s in common.
MSO over binary trees can be deﬁned in the usual way over the vocabulary that
contains binary relations ≺0 and ≺1 and unary relations (Pa)a∈. The μ-calculus
over binary trees is deﬁned by means of the following grammar:

(cid:12)

:= a | X | ϕ ∨ ϕ

(cid:12) | ¬ϕ | ♦(≺0)ϕ | ♦(≺1)ϕ | μX.ϕ(X)

ϕ, ϕ

with X occurring positively in ϕ(X), and a ∈ . Intuitively, the modalities ♦(≺i ), i ∈
[0, 1], check whether a node of the binary tree has an i-th child and such an i-th child
satisﬁes ϕ. The full μ-calculus over binary trees is its extension with past modalities
♦(≺−
i )ϕ, i = 0, 1, that check whether a node in a binary tree is an i-th child and
its parent satisﬁes ϕ. We denote by MSO(T ), Lμ(T ), and Lfull
μ (T ) the versions of
MSO, the μ-calculus, and the full μ-calculus over binary trees, respectively, for not
confusing them with their respective counterparts over nested words.

Theory Comput Syst (2011) 49:639–670

647

Fig. 1 A nested word and its
tree translation

It will be convenient during the proof of Theorem 3.1 to work with an extended
version of both Lμ(T ) and Lfull
μ (T ) that uses simultaneous ﬁxed points, and thus, allows 
to iterate several formulas at once. The syntax is thus enriched with the following 
rule: If ϕi (X1, . . . , Xn), 1 ≤ i ≤ n, are formulas where all Xi appear positively,
then μX1 . . . μXn. (ϕ1, . . . , ϕn)[j] is also a formula, for each 1 ≤ j ≤ n. In order to
deﬁne its semantics, let T be a binary tree, s a node in T , and P the set of all those
{P1, . . . , Pn} such that for each i ∈ [1, n],

{s

(cid:12) | (T , v[P1/X1, . . . , Pn/Xn], s

(cid:12)

) |= ϕi} ⊆ Pi .

Then

(T , v, s) |= μX1, . . . , μXn. (ϕ1, . . . , ϕn)[j] ⇔ s ∈ (cid:3)

{P1,...,Pn}∈P

Pj .

Simultaneous ﬁxed points are often convenient for expressing complex properties,
that involve several sets to be deﬁned at once, in a rather simple way. One can prove
(using Bekic’s principle) that the presence of simultaneous ﬁxed points does not enrich 
the expressiveness of the logic, and thus, that they can be used (without loss of
generality) at any point in the proofs for the sake of simplicity.
Given a binary tree T and a distinguished node s ∈ D, we deﬁne its rank-k
MSO(T ) type, for k ≥ 0, as the set of unary MSO(T ) formulas ϕ(x) of quantiﬁer
rank ≤ k such that T |= ϕ(s). It is well-known that for each k ≥ 0 there are ﬁnitely
many rank-k MSO(T ) types, that each rank-k MSO(T ) type is deﬁnable by a unary
MSO(T ) formula of quantiﬁer rank k, and that each unary MSO(T ) formula of quantiﬁer 
rank k is a ﬁnite union of rank-k MSO(T ) types. We normally associate types
with formulas that deﬁne them. In the proof we also make use of rank-k MSO types
of words and ω-words with a distinguished position i, that can be deﬁned in a similar
way.

We also deﬁne a translation from nested words to binary trees that is a slight
modiﬁcation of the translation shown in [5]. We do it for nested ω-words, but the
same deﬁnition can also be applied to ﬁnite nested words. Let ¯w = (a1 ··· , η) be a
+∪{∞}, we deﬁne
nested ω-word. Then for every pair (i, j ), where i ∈ N
a tree T [i, j] as follows. If i > j , then T [i, j] is the empty tree. If i = j , then T [i, j]
has only one node, which is labeled ai. If i < j , then we consider three cases.
• If there is no k such that i < k ≤ j and η(i, k) holds, then T [i, j] has its root labeled
ai, no 1th-child, and the subtree rooted at its 0th-child isomorphic to T [i + 1, j].
• If there is k such that i < k < j and η(i, k) holds, then T [i, j] has its root labeled
ai, the subtree rooted at its 1th-child isomorphic to T [i + 1, k], and the subtree
rooted at its 0th-child isomorphic to T [k + 1, j].

and j ∈ N

+

648

Theory Comput Syst (2011) 49:639–670

• If η(i, j ) holds, then T [i, j] has its root labeled ai, the subtree rooted at its 1thchild 
isomorphic to T [i + 1, j], and no 0th-child.
The translation T ¯w of a nested ω-word ¯w is T [1,∞]. If ¯w is a ﬁnite nested word
(a1 ··· an, η), then T ¯w is deﬁned as T [1, n]. Notice that each position i of a nested
word ¯w has a unique associated node s(i) in T ¯w and that each node s of T ¯w is of the
form s(i) for some position i of ¯w. Further, if ¯w is a nested ω-word then T ¯w will be
inﬁnite, with the property that the path going down from the root obtained by always
taking the 0th-child of a node is the only inﬁnite path in the tree. Figure 1 shows a
nested word and its tree translation.

Proof of Theorem 3.1 Translations from Lfull
a translation from MSO to Lfull
as the ﬁnite case uses the same techniques.

μ to MSO are standard. We provide here
μ over nested words. We only prove the inﬁnite case,

To translate an MSO-formula ϕ(x) into an equivalent Lfull

μ (T ). (C) Finally, we translate each Lfull

μ -formula ψ, we do
three things: (A) First, translate unary MSO queries over nested ω-words into unary
MSO(T ) queries over the class of inﬁnite binary trees of the form T ¯w, where ¯w
ranges over nested ω-words. (B) Then we show that over the class of inﬁnite binary
trees of the form T ¯w, unary MSO(T ) formulas are precisely those deﬁnable in the
μ (T ) formula over binary
full μ-calculus Lfull
trees of the form T ¯w into an equivalent Lfull
μ formula over nested words.
(A) Let us start by proving that for every unary MSO formula ϕ(x) over nested
(x) over binary trees such that ¯w |= ϕ(i) ⇔
words there is an MSO(T ) formula ϕ
(s(i)), for each nested ω-word ¯w and position i in ¯w. We ﬁrst deﬁne ≺ as
T ¯w |= ϕ
as the transitive closure of ≺. Both relations are MSO deﬁnable.
≺0 ∪ ≺1, and ≺∗
(cid:12)
(x) from ϕ(x) it is enough to do the following:
Then to construct ϕ
• Replace in ϕ(x) each subformula of the form x < y with the formula x <d y,
where <d is the linear order obtained from the tree by doing a depth-ﬁrst search
from right-to-left. That is,
x <d y ⇔ (cid:4)

y) ∨ ∃z1z2z3((z1 ≺0 z2) ∧ (z1 ≺1 z3)

(cid:12)

(cid:12)

(x ≺∗
∧ (z3 = x ∨ z3 (cid:21)∗

x) ∧ (z2 = y ∨ z2 (cid:21)∗

(cid:5)
y))

.

(cid:12)

Indeed, from the tree encoding of a nested word as stated above one immediately
) in the
sees that i < i
inﬁnite binary tree T ¯w; and
• replace each subformula η(x, y) with the formula

in a nested ω-word ¯w iff s(i) <d s(i

for two positions i, i

(cid:12)

(cid:12)

∃z (x ≺1 z ∧ ((z = y ∨ z ≺∗

0 y) ∧ ¬∃w(y ≺0 w)),

0 is the transitive closure of ≺0 (which is deﬁnable in MSO from ≺0).
where ≺∗
Indeed, j is the matching return of position i in a nested ω-word ¯w iff s(i) has a
1th-child in the binary tree T ¯w and s(j ) is the unique leaf that can be reached from
s(i) · 1 by always taking the 0th-child of a node.
(B) We prove next that over the class of inﬁnite binary trees of the form T ¯w, as ¯w
ranges over nested ω-words, unary MSO(T ) formulas are precisely those deﬁnable

Theory Comput Syst (2011) 49:639–670

649

ρ
ρ

μ (T ). Let k be the set of all rank-k MSO(T ) types of
in the full μ-calculus Lfull
binary trees with one distinguished node. Let T be a binary tree and  the maximal
path in T that satisﬁes the following:  contains the root, and for each node s that
belongs to  the node s · 0 also belongs to . Assume that  is the path s0, s1, . . .
of nodes in T . With each position si of  we associate a symbol mi in the alphabet
 × (k ∪{#}), for # a fresh symbol not in  ∪ k, such that mi = (a, τ ) iff the label
of si in T is a and the rank-k MSO type of the subtree of T rooted at si · 1, with
the root as a distinguished node, is τ (if si · 1 does not belong to T we assume that
τ = #). Further, with each position si in  we associate two words ρ
→
 (T , si ) and
 (T , si ) over alphabet  × (k ∪ {#}) such that ρ
 (T , si ) = m0m1 ··· mi−1 and
→
←
 (T , si ) = mi mi+1 ··· . Note that if si = s0, then ρ
←
→
 (T , si ) is the empty string.
(cid:12)
Let s be a node of T . If s is not in  we denote by s
the nearest ancestor of s that
is in . We deﬁne a tuple πk(T , s) composed by 4 elements as follows (assuming ⊥
is a fresh element):
• The ﬁrst component of πk(T , s) is the rank-k MSO type of ((Ts
(cid:12)·1)s , s) if s is not
in ; and it is the symbol ⊥ otherwise.
• The second component of πk(T , s) is the rank-k MSO type of (Ts , s) if s is not in
; and it is the symbol ⊥ otherwise.
• The third component of πk(T , s) is the rank-k MSO type of (ρ
→
 (T , s
not in ; and it is the rank-k MSO type of (ρ
• The fourth component of πk(T , i) is the rank-k MSO type of (ρ
is not in ; and it is the rank-k MSO type of (ρ

→
 (T , s), s) otherwise.
←
 (T , s
←
 (T , s), s) otherwise.

) if s is
(cid:12)
(cid:12)

), s
(cid:12)

) if s

), s

(cid:12)

(cid:12)

The following lemma is a standard composition argument that can be proved via

Ehrenfeucht-Fraïssé games for MSO (c.f. [24]):
Lemma 3.4 Let k ≥ 0. Let T1, T2 be binary trees, and s1 and s2 nodes in T and
, respectively. If πk(T1, s1) = πk(T2, s2) then the rank-k MSO types of (T1, s1) and
(cid:12)
T
(T2, s2) are the same.

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12) , s(i

and position i

(cid:12) |= ϕ(s(i
(cid:12)

)) ∈ S, for each nested ω-word ¯w

Let ϕ(x) be an arbitrary unary MSO(T ) formula, and assume that the depth of
quantiﬁer nesting of ϕ is k ≥ 0. From the previous lemma it follows that there
)) ⇔
is a ﬁnite set S of tuples of the form πk(T ¯w, s(i)) such that T ¯w
in ¯w
πk(T ¯w
. Fix a tuple
(χ , χ0, ξ, ξ0) ∈ S. Thus, in order to prove that for every unary MSO(T ) formula we
μ (T ) formula over inﬁnite binary trees of the form T ¯w,
can construct an equivalent Lfull
μ (T ) formula α(χ ,χ0,ξ,ξ0) over binary trees,
it is enough to show that there is an Lfull
such that (T ¯w, s(i)) |= α(χ ,χ0,ξ,ξ0) ⇔ πk(T ¯w, s(i)) = (χ , χ0, ξ, ξ0), for each nested
ω-word ¯w and position i of ¯w.
Note ﬁrst that each ﬁrst or second component of a tuple of the form πk(T ¯w, s(i)),
for a nested ω-word ¯w and position i in ¯w, is the symbol ⊥ or the rank-k MSO(T )
←
 (T ¯w, s(j )) or
type of a ﬁnite binary tree. Further, each letter in the word ρ
 (T ¯w, s(j )), for a nested ω-word ¯w and a position j of , is of the form (a, #)
→
ρ
or (a, τ ), where τ is the rank-k MSO(T ) type of a ﬁnite binary tree. Further, the only
inﬁnite path in T ¯w is  itself.

The following remarks will be important for the rest of the proof:

650

Theory Comput Syst (2011) 49:639–670

• There is an Lfull

μ (T ) formula β over binary trees of the form T ¯w, deﬁned as

∗

∗

(cid:4)

∗

(cid:5)
,

μX.

0 )X
0 )true ∧ ¬♦(≺−

root ∨ ♦(≺−
μ (T ) formula (¬♦(≺−
where root is the Lfull
1 )true) that identiﬁes 
the root of the tree, such that a node s(i) of a binary tree T ¯w satisﬁes β iff
s(i) belongs to the unique inﬁnite path  of T ¯w.
• Each rank-k MSO(T ) type τ of a ﬁnite binary tree with the root as a distinguished
node is expressible by a Lμ(T ) formula τ
does not mention any past
modalities). That is, for each ﬁnite binary tree T and node s of T it is the case that
(T , s) |= τ
iff the rank-k MSO type of (Ts , s) is τ . This can be proved by a simple
coding in Lμ(T ) of the run of a bottom-up tree automaton on a binary tree.
μ (T ) formula ψξ over binary trees, such that a node
We ﬁrst show that there is a Lfull
s(j ) of T ¯w satisﬁes ψξ iff s(j ) is in the path  of T ¯w, and the rank-k MSO type of
→
 (T ¯w, s(j )), s(j )) is ξ . Since ξ is equivalent to an MSO sentence over ﬁnite words
(ρ
with alphabet  × (k ∪ {#}), there is a deterministic automaton Aξ = (Q, q0, δ, F )
that accepts exactly those ﬁnite words over alphabet  × (k ∪ {#}) whose rank-k
MSO type is ξ . Assume Q = {q0, . . . , qp}. Consider the following Lfull
μ (T ) formula
over binary trees: μX0, . . . , μXp. (αX0 , . . . , αXp ), where the formulas αXi , for i ≤ p,
are deﬁned as follows (τ ranges over k):

(i.e. τ

(¬♦(≺−

0 )true ∧ ¬♦(≺−
(¬♦(≺−

1 )true ∧ a ∧ ♦(≺1)τ

∗

)

(cid:6)

δ(q0,(a,τ ))=qi
∨ (cid:6)
δ(q0,(a,#))=qi
∨ (cid:6)
δ(qj ,(a,τ ))=qi
∨ (cid:6)
δ(qj ,(a,#))=qi

0 )true ∧ ¬♦(≺−
1 )true ∧ a ∧ ¬♦(≺1)true)
0 )Xj ∧ a ∧ ♦(≺1)τ
∗
0 )Xj ∧ a ∧ ¬♦(≺1)true).

)

(♦(≺−

(♦(≺−

It is not hard to see that if a node s(j ) in T ¯w belongs to the least ﬁxed point of
some Xi, for i ≤ p, then s(j ) is in the unique inﬁnite path  of T ¯w. Further, if s(j )· 0
is an element in , then s(j ) is in the least ﬁxed point of Xi, where qi ∈ F , iff the
μ (T )
rank-k type of ρ
formula that computes the projection of the formula μX0, . . . , μXp. (αX0 , . . . , αXp )
over all those Xi such that qi ∈ F .

 (T ¯w, s(j ) · 0) is ξ . Therefore, ψξ can be deﬁned as the Lfull
→

In a similar way, and using the fact that over words and ω-words MSO sentences
are precisely those deﬁnable in the μ-calculus without past modalities, one can show
that there is a Lμ(T ) formula λξ0 over binary trees (that is, λξ0 does not mention any
past modalities), such that a node s(j ) of T ¯w satisﬁes λξ0 iff s(j ) is in the path 
←
of T ¯w, and the rank-k MSO type of (ρ
 (T ¯w, s(j )), s(j )) is ξ0. We can make sure
that each s(j ) that satisﬁes the formula λξ0 is in the path  by using the formula
β as deﬁned above. We actually prove a stronger result. Let ϕ( ¯X) be an arbitrary
μ-calculus formula over words over the alphabet  × (k ∪ {#}). There is an Lμ(T )

Theory Comput Syst (2011) 49:639–670

651

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

∗

), where τ

is the μ-calculus

The translation ϕ

←
 (T ¯w, s(j )), v

( ¯X) is deﬁned as follows:

( ¯X) over binary trees, such that for each nested ω-word ¯w, valuation v
( ¯X) iff s(j ) is in the
, s(j )) |= ϕ( ¯X), where for each

formula ϕ
of the free variables, and position j of ¯w, (T ¯w, v, s(j )) |= ϕ
unique inﬁnite path  of T ¯w, and (ρ
X ∈ ¯X, v
(X) is the restriction of v(X) to the elements in  that are descendants of
s(j ) (including j ). Note that this immediately implies the existence of λξ0 since ξ0 is
expressible by a formula without free variables in the μ-calculus over words.
• If ϕ is (a, τ ), τ ∈ k, then ϕ
is (β ∧ a ∧ ♦(≺1)τ
∗
formula over ﬁnite binary trees that is equivalent to τ .
• If ϕ is (a, #), then ϕ
is (β ∧ a ∧ ¬♦(≺1)true).
(cid:12)
• If ϕ is X, then ϕ
is (X ∧ β).
(cid:12)
• If ϕ is ¬ψ, then ϕ
is ¬ψ
(cid:12) ∧ β.
(cid:12)
• If ϕ is (ψ ∨ ζ ), then ϕ
(cid:12) ∨ ζ
(cid:12)
is (ψ
• If ϕ is ♦ψ, then ϕ
is ♦(≺0)ψ
(cid:12)
(cid:12)
.
• If ϕ is μY.ψ (Y ), then ϕ
(cid:12)
(cid:12)
This ﬁnishes the proof of the existence of λξ0.
Further, by adapting techniques in [9, 20, 28] one can show that there is a full
μ-calculus formula χ∗ over binary trees such that a node s(j ) of T ¯w satisﬁes χ∗ iff
s(j ) is not in the path  of T ¯w, and the rank-k MSO type of ((Ts((cid:7))·1)s(j ), s(j ))
is χ, where s((cid:7)) is the nearest ancestor of s(j ) that is in . The intuitive idea is
to run a simultaneous ﬁxed point formula downwards that starts at each node of
the form s((cid:7)) · 1, where s((cid:7)) is in , and that labels each node s(j ) not in  that
is a descendant of s((cid:7)) in the direction of s((cid:7)) · 1 with the rank-k MSO type of
((Ts((cid:7))·1)s(j ), s(j )). This can be done as it follows from [20, 28] that the rank-k MSO
type of ((Ts((cid:7))·1)s(j )·(1−p), s(j ) · (1 − p)), where p = 0, 1, is uniquely determined
from the rank-k MSO type of ((Ts((cid:7))·1)s(j ), s(j )), which is obtained in the previous
step of the evaluation of the simultaneous ﬁxed point, and the rank-k MSO type of
Ts(j )·p, which, as we mentioned earlier, is expressible in the μ-calculus over binary
trees.

is μY.ψ

(Y ).

(cid:12)

).

The deﬁnition of α(χ ,χ0,ξ,ξ0) is given by cases (here Pα is an abbreviation for
μ (T ) by the formula μX.(α ∨
0 )X ∨ ♦(≺−

“somewhere in the past α”, that is expressible in Lfull
♦(≺−
• α(χ ,χ0,ξ,ξ0) is the formula

1 )X)):

∧ ¬root ∧ ♦(≺−

0 )ψξ ))

1 )(β ∧ λξ0

∧ root))

¬β ∧ χ∗ ∧ (χ0)

∗ ∧ P (¬β ∧ ♦(≺−

1 )(β ∧ λξ0
if χ , χ0 (cid:10)= ⊥ and ξ is not the type of the empty string;
• α(χ ,χ0,ξ,ξ0) is the formula

¬β ∧ χ∗ ∧ (χ0)

∗ ∧ P (¬β ∧ ♦(≺−
if χ , χ0 (cid:10)= ⊥ and ξ is the type of the empty string;
• α(χ ,χ0,ξ,ξ0) is the formula

∧ ¬root ∧ ♦(≺−
if χ , χ0 = ⊥ and ξ is not the type of the empty string;

β ∧ λξ0

0 )ψξ

652

Theory Comput Syst (2011) 49:639–670

• and α(χ ,χ0,ξ,ξ0) is the formula

β ∧ λξ0

∧ root
if χ , χ0 = ⊥ and ξ is the type of the empty string.
(C) In order to ﬁnish the proof we show that each full μ-calculus formula over
binary trees can be translated into an equivalent Lfull
μ -formula ψ over nested ω-words.
We prove something stronger. We show by induction on the structure of formulas that
( ¯X) over nested words, such that
for each ζ ( ¯X) in Lfull
◦
μ (T ) there is an Lfull
μ -formula ζ
(T ¯w, v, s(i)) |= ζ ( ¯X) ⇔ ( ¯w, v, i) |= ζ
( ¯X), for each nested ω-word ¯w, valuation v of
◦
the variables, and position i of ¯w.
(4) ♦(≺−
(call ∧ ♦η♦ζ
respectively, where ζ
This concludes the proof of the theorem.

1 )ζ , and
)∨
◦
),
is the translation of ζ that is obtained by induction hypothesis.
(cid:3)

0 )ζ . These cases can be translated as: (1) (call∧ ♦ζ
), (2) (int∧ ♦ζ
◦
◦
(int ∧ ζ
) ∨ ♦−
(ret ∧ ♦−
◦
η ζ

The only nontrivial inductive cases are: (1) ♦(≺1)ζ , (2) ♦(≺0)ζ , (3) ♦(≺−

), and (4) ♦−

(call ∧ ζ

), (3) ♦−

◦

◦

◦

Proof of Corollary 3.2 The rank-k MSO type of a tree T ¯w with the root as a distin-
←
 (T ¯w, ε), ε), where ε is
guished node, only depends on the rank-k MSO type of (ρ
the root of T ¯w. Thus, in part (B) of the proof of Theorem 3.1 we only need to translate
μ (T ) tuples of the form (⊥,⊥, ξ, ξ0), where χ is the type of the empty string.
into Lfull
It follows from the proof that this can be done without the help of past modalities,
i.e. each one of these tuples can be expressed by a Lμ(T ) formula. From part (C) of
the proof of Theorem 3.1 it easily follows that each Lμ(T ) formula over trees can be
(cid:3)
translated into an equivalent Lμ formula over nested words.

Proof of Corollary 3.3 First, by an easy coding of a query automaton on binary trees
[28] one can show that each unary MSO(T ) formula over ﬁnite binary trees is equivμ 
(T ) formula that does not use negation but uses additional constants
alent to an Lfull
root, leaf, no − 0th − child, and no − 1th − child, interpreted in the obvious 
way (e.g. a node s satisﬁes no − 0th − child iff s · 0 does not belong to D).
+
It is then easy to translate each formula ϕ in this logic into an (Lfull
formula ψ over
μ )
nested words such that (T ¯w, s(i)) |= ϕ ⇔ ( ¯w, i) |= ψ, for each ﬁnite nested word ¯w
and position i in ¯w.
(cid:3)

Final remark Every translation from MSO over nested words into the μ-calculus
shown in this section is effective. Consider the more general case, that of unary
queries over nested ω-words. The proof of Theorem 3.1 proceeds as follows. It ﬁrst
translates each unary MSO query over nested ω-words into a unary MSO query over
the class of inﬁnite binary trees that code nested ω-words. This translation is clearly
effective. Afterwards, it translates each unary MSO query over this class of trees into
an equivalent full μ-calculus formula. The translation ﬁrst deﬁnes from the MSO formula 
ϕ(x) a ﬁnite set S of tuples of the form πk(T ¯w, s(i)) such that T ¯w
)) iff
πk(T ¯w
, and then deﬁnes
for each πk(T ¯w, s(i)) ∈ S a formula ψ in the full μ-calculus over inﬁnite binary trees
)) |= ψ. The construction of the
such that πk(T ¯w

)) ∈ S, for each nested ω-word ¯w
(cid:12)
)) = πk(T ¯w, s(i)) iff (T ¯w

(cid:12) |= ϕ(s(i

and position i

in ¯w

(cid:12) , s(i

(cid:12) , s(i

(cid:12) , s(i

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

Theory Comput Syst (2011) 49:639–670

653

set S from ϕ can be done effectively, simply because the MSO theory of the class
of labeled inﬁnite binary trees is decidable and the class of labeled inﬁnite binary
trees that code nested ω-words is MSO deﬁnable. The construction of the formula
ψ from πk(T ¯w, s(i)) is effective essentially for the same reasons. Finally, the proof
of Theorem 3.1 translates each full μ-calculus formula without free variables over
inﬁnite binary trees that code nested ω-words into a full μ-calculus formula over
nested ω-words. Again, this translation is effective, and, thus, the whole translation
is effective.

4 Automata Models for Nested ω-Words

4.1 Nested ω-Word Automata

Visibly pushdown automata (VPA), with both Büchi and Muller acceptance conditions,
 were introduced in [5]. These automata are a subclass of pushdown automata,
and accept words over a pushdown alphabet, where the nesting structure is implicit,
and there can be unmatched calls. In [5], VPAs were shown to be equivalent to MSO
extended with a binary matching predicate, but not necessarily determinizable. The
example of a visibly pushdown language (VPL) over inﬁnite words that cannot be
accepted by a deterministic automaton [5] can use arbitrarily many calls without
matching returns, something that cannot happen in nested words. Then [25] introduced 
a notion of stair visibly pushdown automata (stair VPA) to control such unmatched 
calls and showed that stair VPAs are determinizable. These models were
deﬁned for VPLs, so we ﬁrst specialize a particular class of stair VPAs [25] to nested
words, thereby obtaining a notion of combined nested word automata, that admit determinization.
 We then use such automata to show that over nested words, for every
ω-NWA (with a Büchi or a Muller acceptance condition), there exists an equivalent
deterministic Muller ω-NWA.
A combined nested word automaton (CNWA) puts together an ω-word automaton
A1 with a Muller acceptance condition and an NWA A2 over ﬁnite nested words. It
runs A1 over all positions that are not inside a call. Every time A1 ﬁnds a call position
i, it invokes A2 to process the ﬁnite nested word formed by the elements between i
and its matching return j , and then it uses its ﬁnal state to determine what state to
assign to j + 1, and continues its run from position j + 1. Formally, a CNWA A over
 is a pair (A1,A2), where:
• A2 = (, Q2, Q0
2, δ2 = (δ2
• A1 = ( ∪ Q2, Q1, Q0
1, δ1,F1) is an ω-word automaton with Muller acceptance
condition over alphabet ∪ Q2 (we assume, of course, that  and Q2 are disjoint).
Given a nested ω-word ¯w and i ≥ 1, we deﬁne the set of external positions E( ¯w)
as positions i such that there are no j, k ≥ 1 such that j < i ≤ k and η(j, k) holds.
Note that 1 ∈ E( ¯w) and E( ¯w) is inﬁnite. If i ∈ E( ¯w) is not a call, then i + 1 ∈ E( ¯w).
If i ∈ E( ¯w) is a call with j being its matching return, then the next, after i, element of
E( ¯w) is j +1. With this, we deﬁne a run of A over a nested ω-word ¯w = (a1a2 ··· , η)
as a mapping ρ : E( ¯w) → Q1 such that ρ(1) ∈ Q0

r )) is an NWA without accepting states;

1 and for every i ∈ E( ¯w):

c , δ2

ι , δ2

654

Theory Comput Syst (2011) 49:639–670

• if i is not a call (and i + 1 ∈ E( ¯w)), then ρ(i + 1) ∈ δ1(ρ(i), ai );
• if i is a call with return j (and the successor of i in E( ¯w) is j + 1), then ρ(j + 1) ∈
δ1(ρ(i), q), where q is a state in Q2 such that there exists a run ρ2 of A2 over
¯w[i, j] having q as the last state.
A CNWA A accepts ¯w if there is a run ρ of A over ¯w such that Inf (ρ) ∈ F1. We say
that CNWA A = (A1,A2) is deterministic if both A1 and A2 are deterministic. Then
results in [25] can be restated in this terminology as:

Proposition 4.1 [25] Over nested ω-words, CNWAs and deterministic CNWAs are
equivalent.

Next we extensively use the notion of combined nested word automaton to prove the
main result of this section:

Theorem 4.2 Over nested ω-words, MSO, ω-NWA with Büchi acceptance condition 
and deterministic ω-NWA with Muller acceptance condition, deﬁne precisely the
regular languages. Moreover, translations between these formalisms are effective.

Now we proceed to prove Theorem 4.2. In the proof, we use the intermediate

results presented below.
Lemma 4.3 For every ω-NWA A with n states, one can construct an CNWA B such
that B has O(n2) states and L(A) = L(B).
Proof Assume that A = (, Q, Q0, δ = (δc, δι, δr ), F ). The idea behind the deﬁnition 
of CNWA B = (B1,B2) is very simple. Let i be an external position of a nested
ω-word ¯w and assume that B has assigned state q to this position. If i is not a call,
then B uses δι to determine the successor state. If i is call position with matching
return j , then B runs B2 over ¯w[i, j] to determine the successor state. Automaton B2
works as A and has states of the form (q1, q2, x), where q1, q2 ∈ Q and x is either t
or f. In a triple (q1, q2, x), q1 is the initial state of the execution of A, q2 is the current 
state of the execution of A and x indicates whether a ﬁnal state has been visited
in the execution of automaton A (x = t if and only if q2 is a ﬁnal state or a ﬁnal state
occurred previously). Once the execution of B2 has terminated, B chooses a run ρ of
B2 over ¯w[i, j] where all the states are of the form (q, q
, x), since the state of call
position i was q. Furthermore, B uses ﬂag x to know whether a ﬁnal state of A was
visited when processing ¯w[i, j]. This is an important issue because the acceptance
condition of A depends on the states visited in any position of ¯w, while it depends
only on the external positions for the case of B. Thus, B uses ﬂag x to handle the case
where a nested ω-word is accepted by A because some ﬁnal state is visited inﬁnitely
often in the non-external positions, while ﬁnal states are visited only a ﬁnite number
of times in the external positions.
where Q2 = Q × Q × {t, f}, Q0
δ2 is deﬁned as follows:

Formally, nested word automaton B2 is deﬁned as (, Q2, Q0

r )),
= {(q, q, t) | q ∈ F} ∪ {(q, q, f) | q ∈ Q \ F} and

2

(cid:12)

2, δ2 = (δ2

c , δ2

ι , δ2

Theory Comput Syst (2011) 49:639–670

655

• For every q1, q2 ∈ Q and a ∈ :

c ((q1, q2, t), a) = {(q1, q3, t) | q3 ∈ δc(q2, a)},
δ2
c ((q1, q2, f), a) = {(q1, q3, x) | q3 ∈ δc(q2, a)
δ2

ι ((q1, q2, t), a) = {(q1, q3, t) | q3 ∈ δι(q2, a)},
δ2
ι ((q1, q2, f), a) = {(q1, q3, x) | q3 ∈ δι(q2, a)
δ2

and x = t if q3 ∈ F, and x = f otherwise},

and x = t if q3 ∈ F, and x = f otherwise}.

• For every q1, q2, q3 ∈ Q, x ∈ {t, f} and a ∈ :

r ((q1, q2, t), (q1, q3, x), a) = {(q1, q4, t) | q4 ∈ δr (q2, q3, a)},
δ2
r ((q1, q2, f), (q1, q3, x), a) = {(q1, q4, y) | q4 ∈ δr (q2, q3, a) and
δ2

y = t if q4 ∈ F, and y = f otherwise}.

Moreover, ω-word automaton B1 is deﬁned as (∪Q2, Q1, Q0
1, δ1,F1), where Q1 =
Q ∪ (Q × {int}), Q0
= Q0, F1 = {X ⊆ Q1 | X ∩ (F ∪ (Q × {int})) (cid:10)= ∅} (F1
is a Muller acceptance condition that represents Büchi acceptance condition F1 =
F ∪ (Q × {int})), and δ1 : Q1 × (Q2 ∪ ) → 2Q1 is deﬁned as follows:
• If q ∈ Q and a ∈ , then

1

δ1(q, a) = δι(q, a),
δ1((q, int), a) = δι(q, a).

• If q ∈ Q and (q1, q2, x) ∈ Q2, then

δ1(q, (q1, q2, x)) =

δ1((q, int), (q1, q2, x)) =

⎧
q (cid:10)= q1
∅
⎪⎨
q = q1 and x = f
{q2}
{(q2, int)} q = q1 and x = t
⎪⎩
⎧
q (cid:10)= q1
∅
⎪⎨
q = q1 and x = f
{q2}
{(q2, int)} q = q1 and x = t.
⎪⎩

It is not difﬁcult to prove that L(A) = L(B). This concludes the proof of the
(cid:3)
lemma.
Lemma 4.4 For every deterministic CNWA A with n states, one can construct a deterministic 
ω-NWA B with Muller acceptance condition such that B has O(n) states
and L(A) = L(B).
Proof Assume that A = (A1,A2), where A2 = (, Q2, q2, δ2 = (δ2
r )), A1 =
( ∪ Q2, Q1, q1, δ1,F1), both A1 and A2 are deterministic and Q1 ∩ Q2 = ∅. We

c , δ2

ι , δ2

656

Theory Comput Syst (2011) 49:639–670

deﬁne a deterministic ω-NWA B = (, Q, q0, δ = (δc, δι, δr ),F ) as follows. The set
of states Q, the initial state q0 and the acceptance condition F are deﬁned as (Q1 ∪
Q2 ∪{qN}), q1 and F1, respectively, where qN (cid:10)∈ (Q1 ∪ Q2). Transition function δ is
deﬁned in such a way that for every position i of an ω-word ¯w such that i ∈ E( ¯w):
(1) if i is not a call position, then B works on this position as A1, and (2) if i is a
call position with return j , then B works on the word ¯w[i, j] as the NWA A2. More
precisely, for every state q ∈ Q1 and a ∈ :

δι(q, a) = δ1(q, a),
δc(q, a) = δ2
c (q2, a).

c (q2, a) since B launches a compuIt 
should be noticed that δc(q, a) is deﬁned as δ2
tation of A2 in every call position that belongs to E( ¯w), and q2 is the initial state of
A2. For every state q ∈ Q2 and a ∈ :

δι(q, a) = δ2
δc(q, a) = δ2

ι (q, a),

c (q, a).

For every q, q

(cid:12) ∈ Q1 and a ∈ :

(cid:12)

, a) = qN .

δr (q, q

We note that the state qN is used to mark the runs of B that cannot represent a valid
run of A. For example, it could not be the case that the transition function δ2
r uses
(cid:12) ∈ Q1 and a ∈ . Furtwo 
states of A1 and, thus, δr (q, q
thermore, for every q, q

, a) = qN for every q, q

(cid:12) ∈ Q2 and a ∈ :

(cid:12)

For every q ∈ Q1, q

(cid:12)
(cid:12) ∈ Q2 and a ∈ :

δr (q, q

, a) = δ2

r (q, q

(cid:12)

, a).

(cid:12)

δr (q

δr (q, q
(cid:12)

(cid:12)

, q2, a)),

, q, a) = δ1(q, δ2
r (q
, a) = qN .
(cid:12)
, q, a) is deﬁned as δ1(q, δ2

(cid:12)

It should be noticed that δr (q
state in the run of A2 on a sub-word is obtained by executing δ2
r (q
for every q ∈ (Q1 ∪ Q2 ∪ {qN}) and a ∈ :

r (q

, q2, a)) since the last
, q2, a). Finally,

(cid:12)

δι(qN , a) = qN ,
δc(qN , a) = qN ,
δr (qN , q, a) = qN ,
δr (q, qN , a) = qN .

It is not difﬁcult to prove that L(A) = L(B). This concludes the proof of the
(cid:3)
lemma.

Theory Comput Syst (2011) 49:639–670

657

Proof of Theorem 4.2 From Lemma 4.3, Proposition 4.1, Lemma 4.4 and the fact that
every ω-NWA with Muller acceptance condition can be translated into an equivalent
ω-NWA with Büchi acceptance condition, we conclude that over nested ω-words,
all the following deﬁne precisely the class of regular languages: ω-NWA with Büchi
acceptance condition, CNWA and deterministic ω-NWA with Muller acceptance condition.
 Moreover, the equivalence of these automata models with MSO is a corollary
(cid:3)
of the results in [5] and [25], which concludes the proof of the theorem.

By using the machinery developed in this section, one can also prove that (note

that the bound is the same as for determinization of stair VPAs for VPLs [25]):

Corollary 4.5 For every ω-NWA with n states, one can construct an equivalent deterministic 
ω-NWA with a Muller acceptance condition and with 2O(n2) states.

Proof To prove the corollary, we need a more technical version of Lemma 4.3, which
can be proved by combining the idea in the proof of Lemma 4.3 with the determinization 
algorithm for NWAs proposed in [6]:
Lemma 4.6 For every ω-NWA A with n states, one can construct an CNWA B =
(B1,B2) such that B1 has O(n) states, B2 has 2O(n2) states, B2 is a deterministic
NWA and L(A) = L(B).
Now assume that A is an ω-NWA with n states. By using Lemma 4.6, one obtains an
equivalent CNWA B = (B1,B2) such that B1 has O(n) states, B2 has 2O(n2) states
and B2 is a deterministic NWA. Then a deterministic CNWA C = (C1,B2) equivalent
to B is obtained by determinizing ω-word automaton C1 using a 2O(n log n) Safra construction 
[31]. Finally, a deterministic ω-NWA D with Muller acceptance condition
is obtained from C by using Lemma 4.4. Automaton D is equivalent to A, and it has
2O(n2) states as C1 has 2O(n log n) states, B2 has 2O(n2) states, and the number of states
in D is linear in the number of states in C = (C1,B2). This concludes the proof of the
(cid:3)
corollary.

It is well known that a language of ω-words is regular (accepted by a Büchi or
a Muller automaton) iff it is a ﬁnite union of languages of the form U V ω, where
U, V ⊆ 
are regular languages. Automata characterizations imply a similar result
for nested ω-words.

∗

Corollary 4.7 A language of nested ω-words is regular iff it is a ﬁnite union of languages 
of the form U V ω, where U and V are regular languages of ﬁnite nested
words.

Proof First, it follows from any of the characterizations of regular languages of
nested ω-words that sets of the form U V ω, where U and V are regular languages
of ﬁnite nested words, are regular. For the converse, let A = (A1,A2) be a deterministic 
CNWA accepting a regular language of nested ω-words. Assume that L is
a regular language of usual ﬁnite words over  ∪ Q2, where Q2 is the set of states

658

Theory Comput Syst (2011) 49:639–670

of A2. Deﬁne W (L) as the set of ﬁnite nested words obtained from words s ∈ L as
follows: each letter q ∈ Q2 is replaced by a ﬁnite nested word whose ﬁrst position is
a call, whose last position is its matching return, and over which the unique run of
A2 ends in q. It follows immediately from the automata (or MSO) characterizations
that W (L) is a regular language of ﬁnite nested words.
Now consider the language of ω-words over  ∪ Q2 accepted by A1. Since it
(cid:12)
i , Li are regular languages of ﬁis 
regular, it is of the form
nite words. But then it follows immediately that the language accepted by A is
(cid:11)
(cid:3)
i W (L

(cid:12)
i )W (Li )ω, proving the corollary.

i , where L

(cid:11)

(cid:12)
i Lω

i L

A basic problem in automata theory, that plays a crucial role in veriﬁcation of
properties of inﬁnite computations [34], is the nonemptiness problem: is the language 
accepted by an automaton nonempty? It was shown in [5] that nonemptiness,
and more generally the reachability problem for visibly pushdown ω-automata is
polynomial. Combining this with a NLOGSPACE algorithm for nonemptiness of ωword 
automata, we get polynomial nonemptiness algorithms for ω-NWA and CNWA.
Further, a slight modiﬁcation of the PTIME-hardness reduction for emptiness for
context-free grammars in [22] gives us:

Corollary 4.8 The nonemptiness problem for both ω-NWA and CNWA is PTIMEcomplete.


Finally, by coding a deterministic automaton with an L1

μ formula, we obtain the

following:

Corollary 4.9 Over nested ω-words, Lμ collapses to L1
μ.

Proof It follows from [6] that (deterministic) NWA and MSO deﬁne the same class
of ﬁnite nested words. On the other hand, from Corollary 3.3, each language of ﬁnite
+
formula.
nested words deﬁned by an MSO sentence can also be deﬁned by an (Lμ)
+
formulas do not use negation, they can be expressed in the alternationSince 
(Lμ)
free fragment L0
μ of Lμ. We conclude that over ﬁnite nested words, acceptance by a
(deterministic) NWA can be described by an L0
μ formula. Moreover, we know that
acceptance by a Muller automaton on (unnested) ω-words can be expressed by an L1
μ
formula [7]. Using that L1
μ formula for acceptance by
(cid:3)
an NWA we can thus simulate acceptance by a CNWA in L1
μ.

μ formula and plugging in a L0

4.2 Alternating Automata for Nested ω-Words

In the context of formal veriﬁcation, alternating automata have proved to be the key
to a comprehensive automata-theoretic framework for temporal logics [34]. With the
development of temporal logics for nested words [1, 2, 4], it is natural to develop alternating 
automata for nested words, with the hope that they can simplify the process
of translating temporal logics into automata.

We now deﬁne (ﬁnite-state) alternating automata for both ﬁnite and inﬁnite nested
words, and show that they are equivalent to NWAs. We note that this is in sharp

Theory Comput Syst (2011) 49:639–670

659

contrast with the theory of alternating automata for nested trees, where alternating
automata are known to be more expressive than nondeterministic automata [3].
First recall the deﬁnition of alternating automata for usual ﬁnite and inﬁnite words.
Given a set of states Q, let B+
(Q) be the set of positive Boolean combinations of
elements from Q. Given X ⊆ Q and ϕ ∈ B+
(Q), we say that X satisﬁes ϕ if the
truth assignment σX satisﬁes ϕ, where σX is deﬁned as σX(q) = 1 iff q ∈ X. Then an
alternating (ω-)word automaton A is a tuple (, Q, Q0, δ, F ), where Q, Q0 and F
are deﬁned as for the case of word automata, and δ : Q×  → B+
(Q) is a transition
function. A run of such an automaton is a labeled tree. A -labeled tree T is a pair
(D, λ), where λ : D →  and D is a preﬁx-closed subset of N
∗
such that (1) if
x · i ∈ D and 0 ≤ j < i, then x · j ∈ D, and (2) for every x ∈ D, there exists a ﬁnite
number of strings of the form x · i in D (ﬁnite branching). For x ∈ N
∗
, its length is
denoted by |x|. The depth of a tree is maxx∈D |x|.
A run of an alternating word automaton A = (, Q, Q0, δ, F ) over a ﬁnite word
w = a1 ··· an is a ﬁnite Q-labeled tree T = (D, λ) of depth n such that λ(ε) ∈ Q0
and for every x ∈ D that has children x · 0, . . . , x · (cid:7) of length i, we have that {λ(x ·
0), . . . , λ(x · (cid:7))} satisﬁes δ(λ(x), ai ). An alternating word automaton A accepts a
word w = a1 ··· an if there is a run T = (D, λ) of A over w such that λ(x) ∈ F for
every node x in T of length n. The run of an alternating ω-word automaton A =
(, Q, Q0, δ, F ) over an ω-word w = a1a2 ··· is deﬁned in exactly the same way
as an inﬁnite Q-labeled tree T = (D, λ). Then A accepts ω-word w if there is an
accepting run T = (D, λ) of A over w, i.e. such that every inﬁnite branch of T visits
inﬁnitely often nodes labeled by states in F .

(Q), and δr : Q × Q ×  → B+

An alternating nested word automaton (or alternating NWA, or ANWA) is an
NWA that admits alternation in call, return, and internal transitions. Formally, an
ANWA A is a tuple (, Q, Q0, δ, F ), where Q, Q0 and F are deﬁned as for the
case of alternating word automata, and δ is a triple (δc, δι, δr ) of transition functions
δc, δι : Q ×  → B+
(Q). A run of A over ¯w =
(a1 ··· an, η) is a Q-labeled ﬁnite tree T = (D, λ) of depth n such that λ(ε) ∈ Q0 and
for every x ∈ D with children x · 0, . . . , x · (cid:7) of length i ≤ n:
• if i is a call position, then {λ(x · 0), . . . , λ(x · (cid:7))} satisﬁes δc(λ(x), ai );
• if i is an internal position, then {λ(x · 0), . . . , λ(x · (cid:7))} satisﬁes δι(λ(x), ai );
• if i is a return position with matching call j and y is the preﬁx of x with |y| = j −1,
then {λ(x · 0), . . . , λ(x · (cid:7))} satisﬁes δr (λ(x), λ(y), ai ).
An alternating nested word automaton A accepts a nested word ¯w = (a1 ··· an, η) if
there is a run T = (D, λ) of A over ¯w such that λ(x) ∈ F for every node x in T of
length n.

As for the case of nested word automata, alternating automata can also be considered 
for the case of nested ω-words. More precisely, an alternating nested ω-word
automaton (ω-ANWA) A is a tuple (, Q, Q0, δ, F ), where Q, Q0, δ and F are
deﬁned exactly as for ANWA. A run is deﬁned in the same way as above, and the
acceptance condition again states that along each inﬁnite branch, states from F are
seen inﬁnitely often.

We now show that alternating nested word automata, for both ﬁnite and inﬁnite
nested words, are equivalent to nested word automata. We start with the inﬁnite case.

660

Theory Comput Syst (2011) 49:639–670

Theorem 4.10 For every ω-ANWA of size n, there exists (and can be effectively con-
structed) an equivalent ω-NWA with a Büchi acceptance condition and of size 22nO(1)
.

Proof We start by introducing the necessary terminology to state a result in [14] that
is used to prove the theorem. In particular, we introduce the notions of nondeterministic 
visibly pushdown automaton with Büchi acceptance condition and alternating
visibly pushdown automaton with Büchi acceptance condition.1

A visibly pushdown alphabet  is an alphabet which is partitioned into three pairwise 
disjoint sets c (call symbols), r (return symbols) and ι (internal symbols).
Given a visibly pushdown alphabet  = c ∪ r ∪ ι, a nondeterministic visibly
pushdown automaton with Büchi acceptance condition (Büchi NVPA) on ω-words
over  is a tuple A = (, Q, Q0, , , F ), where Q is a ﬁnite set of states, Q0 ⊆ Q
is a ﬁnite set of initial states, F ⊆ Q is a ﬁnite set of accepting states,  is the alphabet
of the stack and

 ⊆ (cid:4)

Q × c × Q × 

(cid:5) ∪ (cid:4)

Q × r × ( ∪ {⊥}) × Q

(cid:5) ∪ (cid:4)

Q × ι × Q

(cid:5)
,

(†)
with ⊥ a special stack bottom symbol not contained in  [14]. A run ρ of A over an
ω-word w = a1a2 ··· is a function that indicates what the state and the content of the
+
stack are in each step of the execution of A. More precisely, ρ is a function from N
into Q × (
∗ · {⊥}) such that ρ(1) = (q,⊥), where q ∈ Q0, and for every i ≥ 1:
• If ρ(i) = (q, α) and ai ∈ c, then there exist B ∈  and q
(cid:12) ∈ Q such that
, B) ∈  and ρ(i + 1) = (q
• If ρ(i) = (q, α) and ai ∈ r , then there exist B ∈ ( ∪ {⊥}) and q
(cid:12) ∈ Q such that
(cid:12)

, B · α);

(q, ai , q

(cid:12)

(cid:12)

(q, ai , B, q

) ∈  and

ρ(i + 1) =

(cid:12)

(cid:12)
(cid:12)

,⊥) B = ⊥ and α = ⊥,
, β) B ∈  and α = B · β;

(q

(q

(cid:12)

(cid:12)

, α).

) ∈  and

(cid:12) ∈ Q such that (q, ai , q

• If ρ(i) = (q, α) and ai ∈ ι, then there exists q
ρ(i + 1) = (q
Given a run ρ of A over w, deﬁne Inf (ρ) as the set of states from Q that occur
inﬁnitely often in ρ. Then A accepts w if and only if there exists a run ρ of A over
w such that Inf (ρ) ∩ F (cid:10)= ∅.
Now assume given a visibly pushdown alphabet  = c ∪ r ∪ ι. Then an alternating 
visibly pushdown automaton with Büchi acceptance condition (Büchi AVPA)
on ω-words over  is a tuple A = (, Q, Q0, , δ, F ), where Q, Q0, F and  are
deﬁned as for the case of Büchi NVPAs and

δ : Q ×  × ( ∪ {⊥}) → B+

(Q) ∪ B+

(Q × ),

1It is important to notice that alternating visibly pushdown automata were introduced in [14] by considering 
a parity acceptance condition. We reformulate here some of the results of [14] for alternating visibly
pushdown automata with a Büchi acceptance condition.

Theory Comput Syst (2011) 49:639–670

661

(cid:12)

where (1) for every q ∈ Q, a ∈ c and B ∈ ( ∪ {⊥}), δ(q, a, B) ∈ B+
(Q × ),
(2) for every q ∈ Q, a ∈ r ∪ ι and B ∈ ( ∪{⊥}), δ(q, a, B) ∈ B+
(Q), and (3) for
every q ∈ Q, a ∈ c ∪ ι and B, B
(cid:12) ∈ (∪{⊥}), δ(q, a, B) = δ(q, a, B
) [14]. A run
ρ of A over an ω-word w = a1a2 ··· is a Q × (
∗ · {⊥})-labeled tree T = (D, λ)
satisfying the following properties. Given X ⊆ Q and ϕ ∈ B+
(Q), X is said to exactly
satisfy ϕ if X satisﬁes ϕ and no proper subset of X satisﬁes ϕ, and likewise for a
(Q × ). Then λ(ε) = (q,⊥), where q ∈ Q0, and for every i ≥ 1 and
subset Y of B+
x ∈ D with children x · 0, . . . , x · (cid:7) of length i:
• If λ(x) = (q, B · α) and ai ∈ c, then there exists a set {(q0, B0), . . . , (q(cid:7), B(cid:7))}
exactly satisfying δ(q, ai , B) and such that λ(x · i) = (qi , Bi · B · α), for every
i ∈ {0, . . . , (cid:7)}.
• If λ(x) = (q, B · α) and ai ∈ r , then there exists a set {q0, . . . , q(cid:7)} exactly satisfying 
δ(q, ai , B) and such that for every i ∈ {0, . . . , (cid:7)}:
(qi ,⊥) B = ⊥,
(qi , α) B ∈ .

λ(x · i) =

(cid:12)

• If λ(x) = (q, B · α) and ai ∈ ι, then there exists a set {q0, . . . , q(cid:7)} exactly satisfying 
δ(q, ai , B) and such that λ(x · i) = (qi , B · α), for every i ∈ {0, . . . , (cid:7)}.
It should be noticed that every inﬁnite path ρ of T starting at the root corresponds
to a run of a Büchi NVPA. Then Büchi AVPA A is said to accept an ω-word w if
and only if there exists a run T of A over w such that for every inﬁnite path ρ in T
starting at the root, Inf (ρ) ∩ F (cid:10)= ∅.

In [14], it is proved that:

Theorem 4.11 [14] For every Büchi AVPA A of size n, there exists (and can be
effectively constructed) an equivalent Büchi NVPA B of size 22nO(1)

.

Next we use this result to prove our theorem. More precisely, given an alphabet ,
deﬁne (cid:3) as {(cid:3)a | a ∈ } and (cid:5) as {a(cid:5) | a ∈ }, and then deﬁne a visibly pushdown
alphabet (cid:13) = (cid:13)c ∪ (cid:13)r ∪ (cid:13)ι as (cid:13)c = (cid:3), (cid:13)r = (cid:5) and (cid:13)ι =  [6]. Moreover, given
a nested ω-word ¯w = (a1a2 ··· , η) over an alphabet , deﬁne (cid:3) ¯w(cid:5) as the ω-word
b1b2 ··· over (cid:13) such that for every i ≥ 1:

bi =

ai

⎧
⎪⎨
(cid:3)ai
ai(cid:5)
⎪⎩

i is an internal position in ¯w,
i is a call position in ¯w,
i is a return position in ¯w.

Thus, a symbol (cid:3)a is used to indicate a call in a nested word, while a symbol b(cid:5) is
used to indicate a return in a nested word. In particular, if ¯w is a nested ω-word, then
the angular brackets in (cid:3) ¯w(cid:5) are balanced.

As a ﬁrst step in the proof of the theorem, we show in the following lemma that
an ω-ANWA over an alphabet  can be translated in polynomial time into a Büchi
AVPA over the alphabet (cid:13).

662

Theory Comput Syst (2011) 49:639–670

(cid:12)

(q1, a, q2) = δι(q1, a).
(q1,(cid:3)a, q2) = τ (δc(q1, a), q1).
(cid:12)
(q1, a(cid:5), q2) = δr (q1, q2, a).

(Q). Then let B = ((cid:13), Q, Q0, , δ
is deﬁned as follows. First, deﬁne a function τ : B+

Lemma 4.12 There exists a polynomial time algorithm that, given an ω-ANWA A
over an alphabet , constructs a Büchi AVPA B over (cid:13) such that for every nested
ω-word ¯w over , it holds that ¯w ∈ L(A) if and only if (cid:3) ¯w(cid:5) ∈ L(B).
Proof Assume that A = (, Q, Q0, δ, F ), where δ = (δc, δι, δr ), δc, δι : Q ×  →
(Q) and δr : Q × Q ×  → B+
B+
(cid:12)
, F ), where
 = Q and δ
(Q) × Q →
(Q × Q) by using the following recursive rules: (a) τ (q1, q) = (q1, q) for every
B+
q1, q ∈ Q, (b) τ (ϕ ∨ ψ, q) = τ (ϕ, q) ∨ τ (ψ, q), and (c) τ (ϕ ∧ ψ, q) = τ (ϕ, q) ∧
τ (ψ, q). For example, of ϕ = (q1 ∨ q2) ∧ q3, then τ (ϕ, q) = ((q1, q) ∨ (q2, q)) ∧
by considering the following three cases:
(q3, q). Then deﬁne transition function δ
• If q1 ∈ Q, a ∈  and q2 ∈ (Q ∪ {⊥}), then δ
(cid:12)
• If q1 ∈ Q, (cid:3)a ∈ (cid:3) and q2 ∈ (Q ∪ {⊥}), then δ
• If q1 ∈ Q, a(cid:5) ∈ (cid:5) and q2 ∈ Q, then δ
Thus, given a nested ω-word ¯w, automaton B uses its stack to store the nested
¯w. In particular, if B is in a state q reading a symbol (cid:3)a, then it
structure of
knows that automaton A has reached a call position, and so B stores state q in its
stack and moves into a set of states that exactly satisﬁes δc(q, a). For example, if
δc(q, a) = (q1 ∨ q2) ∧ q3, then τ (δc(q, a), q) = ((q1, q) ∨ (q2, q)) ∧ (q3, q), which
indicates that q should be stored in the stack of B and the automaton should move
to a set of states that exactly satisﬁes (q1 ∨ q2) ∧ q3. Moreover, if B is in a state q
reading a symbol a(cid:5), then it knows that automaton A has reached a return position,
and so B uses q and the state q
at the top of the stack to continue with its execution.
In particular, q
corresponds to the state of the matching call of the return position,
so B moves to a set of states that exactly satisﬁes δr (q, q
, a) to continue simulating
automaton A.
The ideas in the previous paragraph can be used to prove that for every nested ωword 
¯w over , one can construct an accepting run of B over (cid:3) ¯w(cid:5) from an accepting
run of A over ¯w, and vice-versa. Thus, it is possible to prove that for every nested
ω-word ¯w over , it holds that ¯w ∈ L(A) if and only if (cid:3) ¯w(cid:5) ∈ L(B).
(cid:3)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

(cid:12)

As a second step in our proof, we need to show that Büchi NVPA can be translated

in polynomial time into ω-NWA.

Lemma 4.13 There exists a polynomial time algorithm that, given a Büchi NVPA
A over an alphabet (cid:13), constructs an ω-NWA B over  such that for every nested
ω-word ¯w over , it holds that (cid:3) ¯w(cid:5) ∈ L(A) if and only if ¯w ∈ L(B).
Proof Assume that A = ((cid:13), Q, Q0, , , F ), where  is as in (†). Then deﬁne an
ω-NWA B = (, Q
= Q0 × {⊥},
(cid:12)
(cid:12)
) as follows: Q
, Q
0, δ, F
(cid:12) = F × ( ∪ {⊥}) and
• for every (q, B) ∈ Q × ( ∪ {⊥}) and a ∈ :

(cid:12) = Q × ( ∪ {⊥}), Q
(cid:12)
0

F

(cid:12)

δc((q, B), a) = {(q
δι((q, B), a) = {(q

(cid:12)
(cid:12)

(cid:12)

, B

) | (q,(cid:3)a, q
, B) | (q, a, q
(cid:12)

(cid:12)
(cid:12)
) ∈ },

, B

) ∈ },

Theory Comput Syst (2011) 49:639–670

663

• for every (q1, B1) ∈ Q × ( ∪ {⊥}), (q2, B2) ∈ Q × ( ∪ {⊥}) and a ∈ :

δr ((q1, B1), (q2, B2), a) = {(q, B2) | (q1, a(cid:5), B1, q) ∈ }.

(cid:12)

Thus, automaton B uses its nested structure to store the content of the stack of A: B
is in state (q, B) at the position i of a nested ω-word ¯w if and only if A is in state
q and has symbol B at the top of its stack at the position i of (cid:3) ¯w(cid:5). To see why this
is the case, notice ﬁrst that if i is a call position in a nested ω-word ¯w, and B is in
state (q, B) reading symbol a at that position, then B moves into a state (q
) such
) ∈ , which simulates the fact that A at position i moves to state q
that (q,(cid:3)a, q
(cid:12)
(cid:12)
, B
(cid:12)
and places B
at the top of its stack. Moreover, if i is a return position with matching
call j in the nested ω-word ¯w, and B is in state (q1, B1) reading symbol a at position
i, then B uses (q1, B1), a and its state (q2, B2) at position j to determine where to
move. More precisely, B knows in this case that A will remove B1 from the top of its
stack, leaving B2 at the top of it. Thus, B moves in this case to a state (q, B2) such
that (q1, a(cid:5), B1, q) ∈ .
The ideas in the previous paragraph can be used to prove that for every nested
ω-word ¯w over , one can construct an accepting run of B over ¯w from an accepting
run of A over (cid:3) ¯w(cid:5), and vice-versa. Thus, it is possible to prove that for every nested
ω-word ¯w over , it holds that (cid:3) ¯w(cid:5) ∈ L(A) if and only if ¯w ∈ L(B).
(cid:3)

, B

(cid:12)

(cid:12)

As a ﬁnal step of the proof, we just notice that our theorem is a corollary of Theo-
(cid:3)

rem 4.11, and Lemmas 4.12 and 4.13.

We conclude this section by showing that Theorem 4.10 also holds in the ﬁnite
case, that is, by proving that every alternating NWA can be translated into an NWA.

Proposition 4.14 For every alternating NWA of size n, there exists (and can be effectively 
constructed) an equivalent NWA of size 22nO(1)

.

Proof This proposition can be proved by using Theorem 4.10 and a standard padding
argument, where an extra symbol # is used to encode (ﬁnite) nested words as nested
ω-words (a nested word ¯w = (a1 ··· an, η) is represented as a nested ω-word ¯w =
(a1 ··· an#ω, η)).
(cid:3)

5 Synchronization of Nested Words

Synchronization of words and trees leads to a concept of regular relations. The idea
is that positions in several words or trees are tied together (synchronized) according 
to some criterion, and then an automaton runs over such synchronized words
and trees [18, 19]. To be concrete, we describe the word model. Let w1, . . . , wk be
. Assume that # is a letter that is not in . Let n = maxi |wi|, and let
words from 
[(w1, . . . , wk)] be a word of length n constructed as follows. It is over the alphabet
( ∪ {#})k, and its ith letter is a k-tuple (cid:25)ai = (ai
j is the ith
letter of wj if i ≤ |wj|, and # if i > |wj|. That is, we pad words shorter than n with

k), where each ai

1, . . . , ai

∗

664

Theory Comput Syst (2011) 49:639–670

Then regular k-ary relations over  are deﬁned as sets R ⊆ (

#’s to make them all of length n, and then take the ith letter of [(w1, . . . , wk)] to be
the tuple of the ith letters of these padded words.
)k such that the set
{[(w1, . . . , wk)] | (w1, . . . , wk) ∈ R} is accepted by an automaton over the alphabet
( ∪ {#})k [13, 15, 19]. Such automata are called letter-to-letter automata. Regular
relations are closed under Boolean combinations, product, and projection. This makes
with decidable ﬁrst-order theories whose
it possible to ﬁnd inﬁnite structures over 
deﬁnable sets are precisely the regular relations (these are universal automatic struc-
,≺, (Pa)a∈ , el(cid:5),
tures, cf. [13, 15]). The most commonly used such structure is (cid:3)
where ≺ is the preﬁx relation, Pa(w) is true iff the last letter of w is a, and el(w, w
(cid:12)
(the equal-length predicate) holds iff |w| = |w

(cid:12)| [10, 13, 15].

∗

∗

∗

)

We now study synchronization for nested words. There are two ways to apply synchronization 
to them. One, as in words, is to use the linear structure of nested words
to synchronize positions. We show that such linear letter-to-letter synchronization for
words is completely incompatible with the nesting structure because even the simplest 
nested extension of letter-to-letter automata is undecidable. An alternative is to
use synchronization based on the tree representation of nested words. This, as follows
from [11], leads to a decidable model. We present it as well, and explain it in terms
of the linear structure of nested words.

5.1 Letter-to-Letter Nested Word Automata
Assume that we have k nested words ¯w1, . . . , ¯wk, and we again pad the shorter words
with a special symbol # so that all of them are of the same length n. By [( ¯w1, . . . , ¯wk)]
we denote the structure obtained by tying together ¯w1, . . . , ¯wk. Technically, this is a
word over the alphabet ( ∪ {#})k, with k nesting relations, one from each of the
¯wi’s. Let (cid:25)ai be the ith letter of it. The letter-to-letter automaton runs from left to right
on [( ¯w1, . . . , ¯wk)], as an NWA. The main difference with NWAs is that each position
i may now be a return position in several of the ¯wj ’s, and thus states in several call
positions determine the next state.

: Q × Q

return transitions δX
r

That is, in a k-letter-to-letter NWA over k-tuples of nested words, we have multiple
|X| × ( ∪ {#})k → 2Q, indexed by nonempty X ⊆
{1, . . . , k}. Suppose i is a return position in ¯wl1 , . . . , ¯wlm, where 1 ≤ l1 < ··· < lm ≤ k
and m > 0. In the deﬁnition of a run ρ, we require that if j1, . . . , jm are the matching
calls, i.e. ηl1 (j1, i), . . . , ηlm (jm, i) hold, then ρ(i + 1) must depend on ρ(i), (cid:25)ai, and
the states in positions j1, . . . , jm:
ρ(i + 1) ∈ δ

(ρ(i), ρ(j1), . . . , ρ(jm), (cid:25)ai ).

{l1,...,lm}

r

For positions without returns, we have one transition δ : Q × ( ∪ {#})k → 2Q.

We show that even a much simpler automaton is undecidable. We call this model a
simpliﬁed k-letter-to-letter NWA. Syntactically, this is just an NWA, with an internal
transition and one return transition δr : Q × Q × ( ∪ {#})k → 2Q. The internal
transitions are handled exactly as in NWAs. The condition on the runs ρ for return
transitions is as follows: if i is a return position in words ¯wl1 , . . . , ¯wlm, for 1 ≤ l1 <
··· < lm ≤ k, then ρ(i + 1) ∈ δr (ρ(i), ρ(j1), (cid:25)ai ), where j1 is the call of i in ¯wl1.

In other words, we look at the state of only one call position, corresponding to the

Theory Comput Syst (2011) 49:639–670

665

word with the smallest index. For all other positions we have a single transition δ :
Q × ( ∪ {#})k → 2Q.
If k = 1, these are the usual NWAs. But, as one might expect, even if k = 2, they

are undecidable.2

Theorem 5.1 The nonemptiness problem is undecidable for simpliﬁed 2-letter-toletter 
NWAs (and thus for k-letter-to-letter NWAs for k > 1).

Proof We reduce Post’s Correspondence Problem (PCP) to our problem. Given an
alphabet , an instance of PCP is a pair of sequences of words u1, . . . , u(cid:7) and
v1, . . . , v(cid:7) over . Then the problem is to ﬁnd a sequence of integers i1, i2, . . . , in
in the interval [1, (cid:7)] such that ui1 ui2
··· vin. PCP is known to be unde-

= vi1 vi2

··· uin

cidable.
Let u1, . . . , u(cid:7) and v1, . . . , v(cid:7) be an instance of PCP over an alphabet . Next we
deﬁne a simpliﬁed letter-to-letter NWA A such that L(A) is not empty iff there is
a sequence of integers i1, i2, . . . , in from the interval [1, (cid:7)] such that ui1 ui2
=
··· uin

We now explain how A works. The alphabet of A is 4, where

··· vin.

vi1 vi2

 = ( × {c, i, r}) ∪ {#, 1, . . . , (cid:7)}

(assuming that {1, . . . , (cid:7)}∩  = ∅). Thus, A is a synchronized automaton that works
over 4 nested words. Intuitively, on two of these words A will guess a solution to PCP,
and on the other words it will guess a sequence of indices of words, and then will use
··· uin
matching relations to relate indices of words with their start positions in ui1 ui2
and vi1 vi2
More precisely, in the ﬁrst nested word, A stores a sequence of words ui1 , . . . , uin,
where each ik ∈ [1, (cid:7)] (1 ≤ k ≤ n), and in its third nested word, A stores a sequence of
words vj1 , . . . , vjm, where each jk ∈ [1, (cid:7)] (1 ≤ k ≤ m). In these two nested words, A

··· vin.

uses a symbol c to indicate the starting point of a word, r to indicate the end point of
a word and i to indicate that a position is neither the starting point nor the end point
of a word. Thus, for example, if u1 = aba and u2 = aaab, and A decides to store
u2u1, then the ﬁrst nested word of A will be (a, c)(a, i)(a, i)(b, r)(a, c), (b, i)(a, r).
In the ﬁrst and third nested word, A is trying to guess sequences that satisfy the
··· vjm, and then
condition for PCP. Thus, A ﬁrst checks whether ui1
uses its second and fourth nested word to verify whether for the previous sequences,
it is the case that n = m and ik = jk for every k ∈ [1, n]. Next we show how this is
done for the following example: u1 = aba, u2 = aaab, v1 = aaa and v2 = baba.
Assume that i2 = j1 = 1 and i1 = j2 = 2. Then the following is the letter-by-letter

··· uin

= vj1

2In fact, a closely related result is proved in a technical report [12] which appeared at the same time as the
ﬁrst version of this paper.

666

Theory Comput Syst (2011) 49:639–670

word accepted by A that represents these sequences:

= vj1 vj2 and that ui1 ui2, vj1 vj2 have been stored in the ﬁrst and
We note that ui1 ui2
third nested word of A, respectively. The nesting structure of the second nested word
is used to store the sequence of indexes used in the ﬁrst nested word. More precisely,
 every position p in the ﬁrst nested word with label (x, c) corresponds to a call
position in the second nested word, whose matching return is a position with label
y ∈ {1, . . . , (cid:7)}, which indicates what is the index associated with the word with starting 
point p. The fourth nested word is constructed in the same way but considering
the third nested word. Since A is a simpliﬁed letter-to-letter NWA, the return positions 
in the fourth nested word are displaced by one letter to the right, so that return
positions in different nested words do not coincide. Let p be the ﬁrst position in the
ﬁrst nested word with label #, and let w2 and w4 be the sufﬁxes from position p of
the words in the second and fourth nested word, respectively. Then to check whether
i1 = j1 and i2 = j2, automaton A just has to check whether w2 and w4 are of the
form i1#i2# and #i1#i2, respectively.
Automaton A is constructed as the product of several simpliﬁed letter-to-letter
NWA that verify the conditions described above. Each of these automata is straightforward 
to construct. Note also that simpliﬁed k-letter-to-letter automata are closed
under product. In the construction above, we deﬁned A as a synchronized automaton
that works over four nested words. It easy to see that the ﬁrst and the second nested
word can combined into a single one, as well as the third and the fourth nested word.
This show that the emptiness problem is undecidable even for simpliﬁed letter-to-
(cid:3)
letter NWA working over 2 nested words.

Theory Comput Syst (2011) 49:639–670

667

iff ¯w = ¯w

nw, (cid:5) (where 
∗
iff ¯w = ¯w

Thus, there is no hope to use even the simplest possible form of letter-to-letter
synchronization in nested words. As another example of such incompatibility, we
show that there are no natural decidable extensions of universal automatic structures
on words to nested words. We look at structures M = (cid:3)
∗
nw is the
set of all ﬁnite nested words over ) of a vocabulary . We assume that  includes
some basic relations. One is a preﬁx relation ¯w (cid:21)nw ¯w
(cid:12)[1, m] for some
(cid:12)
m ≤ | ¯w
(cid:12)| (so we can refer to the linear structure of nested words). The other allows
us to refer to the nesting structure: we relate a preﬁx ¯w of ¯w
, there is a
call-return edge from the last position of ¯w to the last position of ¯w
. That is, ¯w (cid:21)η
¯w
(cid:12)
. We say that M deﬁnes all regular
languages of nested words if for each such language L, there is a formula ϕL(x) such
that L = { ¯w ∈ 
| M |= ϕ( ¯w)}. We say that M deﬁnes all regular relations over
words if for each regular relation R ⊆ (
)k, there is a formula ψR(x1, . . . , xk) such
that M |= ψR( ¯w1, . . . , ¯wk) iff (w1, . . . , wk) ∈ R (recall that wi is a word from 
∗
obtained by removing the nesting structure from ¯wi).
Proposition 5.2 There is no structure M = (cid:3)
ular languages of nested words, all regular relations over words, and has a decidable
ﬁrst-order theory.

nw,(cid:21)nw,(cid:21)η, . . .(cid:5) that deﬁnes all reg-
∗

(cid:12)[1, m], and η(m,| ¯w

(cid:12)|) holds in ¯w

so that in ¯w

∗
nw

∗

(cid:12)

(cid:12)

(cid:12)

(cid:12)

Proof By the assumption that every regular relation is deﬁnable in M, there is a

formula ψel(x, y) such that M |= ψel( ¯w1, ¯w2) iff |w1| = |w2|, and a formula ψLa (x),
for each a ∈ , such that M |= ψLa ( ¯w) iff the last element of w is labeled a.
It is known [23] that for every context-free language L, one can effectively construct 
a second-order sentence αL = QM1 . . .QMkβ(M1, . . . , Mk) where each Q is
∃ or ∀, Mi’s range over binary matching relations, and β is a ﬁrst-order formula of
the vocabulary of words (i.e., < and the Pa’s unary predicates) such that a word w
satisﬁes αL iff it belongs to L. Thus, it sufﬁces to model such a sentence over M (i.e.
deﬁne a formula α
(x)
will encode the intersection of two context-free languages.
replace each second-order quantiﬁer ∃Mi in αL by

Assume x is a variable not mentioned in αL. To construct α

L( ¯w) iff w ∈ L) – then ∃x α
(cid:12)

L(x) such that M |= α
(cid:12)

(cid:12)
L(x) from αL, we ﬁrst

(x) ∧ α

(cid:12)
L1

(cid:12)
L2

∃mi

(cid:4)

ψel(x, mi ) ∧ ··· (cid:5)

and each ﬁrst-order quantiﬁer ∃y in αL with

∃y

(cid:4)

y (cid:21)nw x ∧ ··· (cid:5)

.

That is, each matching relation is modeled by a nested word of the same length as x
(whose labeling is irrelevant; we shall only look at the matching relation), and each
(cid:12)
ﬁrst-order quantiﬁer (i.e. a position) is modeled by a preﬁx of x. Then, to obtain α
L,
we replace each atom of the form Pa(y) in β by ψLa (y), and each atom of the form
y < z with y (cid:21)nw z. Finally, we replace each atom of the form Mi (y, z) with
(cid:12) (cid:21)nw x ∧ u (cid:21)η u
(cid:12)(cid:5)
.

ψel(u, y) ∧ ψel(u
∃u∃u
(cid:12)
(cid:12) (cid:4)

, z) ∧ u (cid:21)nw x ∧ u

This concludes the proof of the proposition.

(cid:3)

668

Theory Comput Syst (2011) 49:639–670

5.2 Call-Return Synchronization

As the usual letter-to-letter synchronization over the linear structure is incompatible
with nested words, we propose a different model, that is based on viewing nested
words as trees. Then known results on tree-automatic structures will imply decidability 
[11]. In line with the previous notion of this section, we shall present this notion
using the linear structure as well (although the synchronization procedure will behave
differently in internal and call positions).

The idea of this call-return synchronization is that, instead of synchronizing positions 
with the same index i in different words, we synchronize positions for which
the shortest paths to them (from the ﬁrst position) are the same. To formalize this, we
use a notion of a summary path introduced recently in connection with the study of
LTL-like logics on nested ω-words [1]. A summary path to a position i in a nested
word ¯w = (w, η) is the shortest path from 1 to i that combines both successor and
matching edges. That is, it is a sequence 1 = i0 < i1 < ··· < ik = i such that, if il is
a call with η(il, j ) and i ≥ j , then η(il , il+1) holds, and otherwise il+1 = il + 1. We
represent this summary path as a word a1 . . . ak over the alphabet  = {i, c, m}:
1. if il = il−1 + 1 and il−1 is not a call, then al = i (path goes via an internal edge);
2. if il = il−1 + 1 and il−1 is a call, then al = c (path goes via a call edge);
3. if η(il−1, il) holds, then al = m (path goes via a matching edge).
If both i1 = il−1 + 1 and η(il−1, il) hold, we let al be m. The unique summary path to
position i will be denoted by π ¯w(i) ∈ 
, and the set of all summary paths by ( ¯w).
The label of π ¯w(i) is the label of i in ¯w. Note that ( ¯w) is closed under preﬁx.
The idea of the call-return synchronization is that now with each position i, we
keep its summary paths π ¯w(i), to remember how it was reached in different nested
words. That is, a call-return synchronization of nested words ¯w1, . . . , ¯wk is a pair
(( ¯w1, . . . , ¯wk), λ) where ( ¯w1, . . . , ¯wk) = (cid:11)
l ( ¯wl), and λ : ( ¯w1, . . . , ¯wk) →
( ∪ {#})k is a labeling function that labels each summary path with its label in ¯wi
if it occurs in ¯wi, and with # otherwise, for each i ≤ k. This synchronization can
naturally be viewed as a tree.
As an example, consider two nested words below, ¯w1 (on the left) and ¯w2 (on the

∗

right), with summary paths shown above positions.

The synchronization occurs in the ﬁrst and the second position, and we recursively
synchronize the calls (from i) and what follows their returns (from im). Intuitively,
this results in adding a dummy internal node ici inside the call for ¯w2, and adding
a dummy last internal position imii for ¯w2. Note that position 4 (i.e. ici) in ¯w1 is
in no way related to position 4 (im) in ¯w2, as it would have been in letter-to-letter
synchronization.
∗
nw)k is a regular k-ary relation of nested words iff
there is a tree automaton on ternary trees over ( ∪ {#})k that accepts precisely

We now say that R ⊆ (

Theory Comput Syst (2011) 49:639–670

669

(( ¯w1, . . . , ¯wk), λ), for ( ¯w1, . . . , ¯wk) ∈ R. The following is an immediate consequence 
of coding tree representations in MSO, and of the work on automatic structures 
over trees [11]:

Proposition 5.3
• Regular relations of nested words are closed under union, intersection, complementation,
 product, and projection.
• Regular 1-ary relations of nested words are precisely the regular nested languages.
• There is a ﬁnite collection  of unary and binary predicates on 
∗
nw such that
nw, (cid:5) is a universal automatic structure for nested words, i.e. its deﬁnable re-
(cid:3)
∗
lations are precisely the regular relations of nested words, and its theory is decidable.


Acknowledgements We thank Rajeev Alur, Kousha Etessami, and Neil Immerman for helpful discussions.
 We are very grateful to the anonymous referees for their careful reading of the paper and numerous
suggestions. Arenas was supported by FONDECYT grants 1050701, 7060172 and 1070732; Barceló by
Fondecyt grant 11080011; Libkin by EPSRC grants E005039 and G049165 and FET-Open project FoX
(grant agreement 233599).

References

1. Alur, R., Arenas, M., Barceló, P., Etessami, K., Immerman, N., Libkin, L.: First-order and temporal

logics for nested words. Log. Methods Comput. Sci. 4(4), (2008)

2. Alur, R., Chaudhuri, S., Madhusudan, P.: A ﬁxpoint calculus for local and global program ﬂows. In:

POPL 2006, pp. 153–165

3. Alur, R., Chaudhuri, S., Madhusudan, P.: Languages of nested trees. In: CAV 2006, pp. 329–342
4. Alur, R., Etessami, K., Madhusudan, P.: A temporal logic of nested calls and returns. In: TACAS’04,

pp. 467–481

5. Alur, R., Madhusudan, P.: Visibly pushdown languages. In: STOC’04, pp. 202–211
6. Alur, R., Madhusudan, P.: Adding nesting structure to words. J. ACM 56(3) (2009). Extended version

of DLT’06, pp. 1–13

7. Arnold, A., Niwinski, D.: Rudiments of μ-Calculus. North-Holland, Amsterdam (2001)
8. Bárány, V., Löding, C., Serre, O.: Regularity problems for visibly pushdown languages. In:

STACS’06, pp. 420–431

9. Barceló, P., Libkin, L.: Temporal logics over unranked trees. In: LICS’05, pp. 31–40
10. Benedikt, M., Libkin, L., Schwentick, T., Segouﬁn, L.: Deﬁnable relations and ﬁrst-order query languages 
over strings. J. ACM 50(5), 694–751 (2003)

11. Benedikt, M., Libkin, L., Neven, F.: Logical deﬁnability and query languages over ranked and unranked 
trees. ACM Trans. Comput. Log. 8(2) (2007)

12. Blass, A., Gurevich, Y.: A note on nested words. Technical report MSR-TR-2006-139, Microsoft

Research, October 2006

13. Blumensath, A., Grädel, E.: Automatic structures. In: LICS’00, pp. 51–62
14. Bozzelli, L.: Alternating automata and a temporal ﬁxpoint calculus for visibly pushdown languages.

In: CONCUR 2007, pp. 476–491

15. Bruyère, V., Hansel, G., Michaux, C., Villemaire, R.: Logic and p-recognizable sets of integers. Bull.

Belg. Math. Soc. 1, 191–238 (1994)

16. Caucal, D.: Synchronization of pushdown automata. In: DLT’06, pp. 120–132
17. Cleaveland, R., Steffen, B.: A linear-time model-checking algorithm for the alternation-free modal

mu-calculus. In: CAV’91, pp. 48–58

18. Elgot, C., Mezei, J.: On relations deﬁned by generalized ﬁnite automata. IBM J. Res. Develop. 9,

47–68 (1965)

19. Frougny, C., Sakarovitch, J.: Synchronized rational relations of ﬁnite and inﬁnite words. Theor. Comp.

Sci. 108, 45–82 (1993)

670

Theory Comput Syst (2011) 49:639–670

20. Gottlob, G., Koch, C.: Monadic datalog and the expressive power of languages for web information

extraction. J. ACM 51, 74–113 (2004)

21. Janin, D., Walukiewicz, I.: On the expressive completeness of the propositional mu-calculus with

respect to monadic second order logic. In: CONCUR 1996, pp. 263–277

22. Jones, N.D., Laaser, W.T.: Complete problems for deterministic polynomial time. Theor. Comput. Sci.

3(1), 105–117 (1977)

23. Lautemann, C., Schwentick, T., Thérien, D.: Logics for context-free languages. In: CSL’94, pp. 205–

216

24. Libkin, L.: Elements of Finite Model Theory. Springer, Berlin (2004)
25. Löding, C., Madhusudan, P., Serre, O.: Visibly pushdown games. In: FSTTCS 2004, pp. 408–420
26. Madhusudan, P., Viswanathan, M.: Query automata for nested words. In: MFCS 2009, pp. 561–573
27. Makowsky, J.: Algorithmic aspects of the Feferman-Vaught theorem. Ann. Pure Appl. Log. 126, 159–

213 (2004)

28. Neven, F., Schwentick, Th.: Query automata over ﬁnite trees. Theor. Comp. Sci. 275, 633–674 (2002)
29. Niwinski, D.: Fixed points vs. inﬁnite generation. In: LICS 1988, pp. 402–409
30. Peng, F., Chawathe, S.: Xpath queries on streaming data. In: SIGMOD’03, pp. 431–442
31. Safra, S.: On the complexity of omega-automata. In: FOCS 1988, pp. 319–327
32. Segouﬁn, L., Vianu, V.: Validating streaming XML documents. In: PODS’02, pp. 53–64
33. Thomas, W.: Languages, automata, and logic. In: Handbook of Formal Languages, vol. 3, pp. 389–

455. Springer, Berlin (1997)

34. Vardi, M.Y.: An automata-theoretic approach to linear temporal logic. Banff Higher Order Workshop,

pp. 238–266 (1995)

35. Vardi, M.Y.: Reasoning about the past with two-way automata. In: ICALP 1998, pp. 628–641

