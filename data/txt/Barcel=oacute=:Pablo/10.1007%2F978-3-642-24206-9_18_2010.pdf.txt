Datalog as a Query Language for

Data Exchange Systems

Marcelo Arenas1, Pablo Barcel´o2, and Juan L. Reutter3

1 Dept. of Computer Science, Pontiﬁcia Universidad Cat´olica de Chile

2 Dept. of Computer Science, University of Chile
3 School of Informatics, University of Edinburgh

Abstract. The class of unions of conjunctive queries (UCQ) has been shown to
be particularly well-behaved for data exchange; its certain answers can be computed 
in polynomial time (in terms of data complexity). However, this is not the
only class with this property; the certain answers to any DATALOG program can
also can be computed in polynomial time. The problem is that both UCQ and
DATALOG do not allow for negated atoms, while most database query languages
are equipped with negation. Unfortunately, adding an unrestricted form of negation 
to these languages yields to intractability of the problem of computing certain
answers.

In order to face this challenge, we have recently proposed a language, called
C((cid:2)=) [5], that extends DATALOG with a restricted form of negation
DATALOG
while keeping the good properties of DATALOG, and UCQ, for data exchange. In
C((cid:2)=) as a query
this article, we provide evidence in favor of the use of DATALOG
language for data exchange systems. More precisely, we introduce the syntax
C((cid:2)=), we present some of the fundamental results
and semantics of DATALOG
about this language shown in [5], and we extend those results to the case of data
exchange settings that allow for constraints in the target schema. All of these
results provide justiﬁcation for the use of DATALOG

C((cid:2)=) in practice.

1 Introduction

Data exchange is the problem of computing an instance of a target schema, given an
instance of a source schema and a speciﬁcation of the relationship between source and
target data. Although data exchange is considered to be an old database problem, its theoretical 
foundations have only been laid out very recently by the seminal work of Fagin,
Kolaitis, Miller and Popa [10]. Both the study of data exchange and schema mappings
have become an active area of research during the last few years in the database community 
(see e.g. [10,11,4,9,17,13,18,12]).
In its simplest form, a data exchange setting is a triple M = (S, T, Σst), where S is
a source schema, T is a target schema, and Σst is a mapping deﬁned as a set of source-
to-target dependencies of the form ∀¯x∀¯y (φS(¯x, ¯y) → ∃¯z ψT(¯x, ¯z)), where φS and ψT
are conjunctions of relational atoms over S and T, respectively. Given a source instance
I, the goal in data exchange is to materialize a target instance J that is a solution for I,
that is, J together with I satisﬁes each dependency in Σst.

An important issue in data exchange is that the existing speciﬁcation languages usually 
do not completely determine the relationship between source and target data and,

O. de Moor et al. (Eds.): Datalog 2010, LNCS 6702, pp. 302–320, 2011.
© Springer-Verlag Berlin Heidelberg 2011

Datalog as a Query Language for Data Exchange Systems

303

thus, each source instance has an inﬁnite number of solutions. This immediately raises
the question of which solution should be materialized. Initial work on data exchange
[10] has identiﬁed a class of “good” solutions, called universal solutions. In formal
terms, a solution is universal if it can be homomorphically embedded into every other
solution. It was proved in [10] that for the class of data exchange settings deﬁned above,
a particular universal solution – called the canonical universal solution – can be computed 
in polynomial time.

A second important issue in data exchange is query answering. Queries in the data
exchange context are posed over the target schema, and –given that there may be many
solutions for a source instance– there is a general agreement in the literature that their
semantics should be deﬁned in terms of certain answers [14,1,15,10]. More formally,
given a data exchange setting M = (S, T, Σst) and a query Q over T, a tuple ¯t is said
to be a certain answer to Q over I under M, if ¯t belongs to the evaluation of Q over
every possible solution J for I under M.

The deﬁnition of certain answers is highly non-effective, as it involves computing
the intersection of inﬁnitely many sets. Thus, it becomes particularly important to understand 
for which classes of relevant queries, the certain answers can be computed
efﬁciently. In particular, it becomes relevant to understand whether it is possible to
compute the certain answers to any of these classes by using some materialized solution.
 Fagin, Kolaitis, Miller, and Popa [10] have shown that this is the case for the class
of union of conjunctive queries (UCQ); the certain answers to each union of conjunctive 
queries Q over a source instance I can be computed in polynomial time by directly
posing Q over the canonical universal solution for I. It is important to notice that in this
result the complexity is measured only in terms of the size of the source instances (in
particular, the data exchange setting and the query are assumed to be ﬁxed). Thus, the
previous result is stated in terms of data complexity [20].

The good properties of UCQ for data exchange can be completely explained by the
fact that unions of conjunctive queries are preserved under homomorphisms. But this is
not the only language that satisﬁes this condition, as queries deﬁnable in DATALOG,
the recursive extension of UCQ, are also preserved under homomorphisms. Thus,
DATALOG retains several of the good properties of UCQ for data exchange. In particular,
 the certain answers to a DATALOG program Π over a source instance I can be
computed efﬁciently by ﬁrst materializing the canonical universal solution J for I, and
then evaluating Π over J (since DATALOG programs can be evaluated in polynomial
time in the size of the data).

Unfortunately, both UCQ and DATALOG keeps us in the realm of the positive, while
most database query languages are equipped with negation. However, adding an unrestricted 
form of negation to DATALOG (and even to the class of conjunctive queries)
leads to intractability of the problem of computing certain answers. Thus, extending
DATALOG with some form of negation that, on the one hand, allows to express interesting 
data exchange queries, and, on the other hand, retains the good properties of
DATALOG for data exchange, is a nontrivial task that must be handled carefully.

In order to face this challenge, we have recently proposed a language, called
C((cid:2)=) [5], that extends DATALOG with a restricted form of negation while
DATALOG
keeping the good properties of DATALOG, and UCQ, for data exchange. In this article,

304

M. Arenas, P. Barcel´o, and J.L. Reutter

C((cid:2)=) as a query language for data
we provide evidence in favor of the use of DATALOG
exchange systems. More precisely, we start by introducing the syntax and semantics of
C((cid:2)=). Then we continue by presenting some of the fundamental results about
DATALOG
C((cid:2)=) in
this language shown in [5], which provide justiﬁcation for the use of DATALOG
C((cid:2)=) program
practice. In particular, we show that the certain answers to a DATALOG
C((cid:2)=) can be used
can be computed in polynomial time, and that the language DATALOG
to express interesting queries in the data exchange context, as every union of conjunctive 
queries with at most one inequality or negated relational atom per disjunct can be
C((cid:2)=) program in the context of data exchange. We
efﬁciently expressed as a DATALOG
ﬁnish the paper by extending these results to the case of data exchange settings with
constraints in the target, as explained below.

In addition to the data exchange scenario we have seen so far, it is common in the
literature to assume that target schemas come with its own set of dependencies; i.e. each
data exchange setting M = (S, T, Σst) is extended with a set Σt of dependencies over
the schema T, which are called target constraints. In that case, a target instance J is
said to be a solution for the source instance I under the setting M = (S, T, Σst, Σt),
if not only the pair (I, J) satisﬁes each dependency in Σst, but also J satisﬁes each
dependency in Σt.

As it is to be expected, the addition of target dependencies makes the fundamental
data exchange tasks more difﬁcult, starting from the fact that it is no longer true that
solutions exist for each source instance. Even worst, it follows from [13] that even for
simple data exchange settings with target dependencies, the problem of checking for
the existence of solutions may be undecidable. In order to solve this problem, the data
exchange literature has identiﬁed a relevant class of target dependencies – those that
consist of a set of equality-generating dependencies (that subsume keys) and a weaklyacyclic 
set of tuple-generating dependencies – that have the following good properties
for data exchange [10]: Checking the existence of solutions is a tractable problem;
and for every source instance that has a solution, a canonical universal solution can
be computed in polynomial time. The latter implies that, for the class of data exchange
settings extended with a set of target dependencies that consists of a set of equalitygenerating 
dependencies and a weakly-acyclic set of tuple-generating dependencies,
the certain answers to each union of conjunctive queries Q can still be computed in
polynomial time (by simply posing Q over the canonical universal solution J for a
given source instance I, in case such J exists).
C((cid:2)=) as a query language 
for data exchange settings extended with equality-generating target dependencies
and weakly-acyclic sets of tuple-generating target dependencies. In particular, we prove
C((cid:2)=)
that for this class of data exchange settings, the certain answers to each DATALOG
program can be computed in polynomial time. Also, we study the expressiveness of
C((cid:2)=) in this context, and show that every union of conjunctive queries with at
DATALOG
most one inequality or negated relational atom per disjunct can be efﬁciently expressed
C((cid:2)=) program if only equality-generating target dependencies are considas 
a DATALOG
ered. We also show that this result fails if, in addition, target constraints are allowed to
contain weakly-acyclic sets of tuple-generating target dependencies; indeed, we prove
in the paper that there exist a data exchange setting M = (S, T, Σst, Σt), where Σt

In this paper, we investigate the feasibility of using DATALOG

Datalog as a Query Language for Data Exchange Systems

305

is the union of a set of equality-generating dependencies and a weakly-acyclic set of
tuple-generating dependencies, and a conjunctive query Q over T with one negated
relational atom such that the problem of computing certain answers to Q under M is
undecidable.

Organization of the paper. In Section 2, we introduce the terminology used in the pa-
C((cid:2)=) programs,
per. Then, in Section 3, we deﬁne the syntax and semantics of DATALOG
and show their good properties for data exchange. In Section 4 we study the expressive
power of DATALOG

C((cid:2)=) programs. Concluding remarks are given in Section 5.

2 Background
A schema R is a ﬁnite set {R1, . . . , Rk} of relation symbols, with each Ri having a
ﬁxed arity ni > 0. Let D be a countably inﬁnite domain. An instance I of R assigns to
i ⊆ Dni. The domain dom(I) of
each relation symbol Ri of R a ﬁnite ni-ary relation RI
instance I is the set of all elements that occur in any of the relations RI
i . We often deﬁne
instances by simply listing the tuples attached to the corresponding relation symbols.

We assume familiarity with ﬁrst-order logic (FO) and DATALOG. In this paper, CQ is
the class of conjunctive queries and UCQ is the class of unions of conjunctive queries.
If we extend these classes by allowing inequalities or negation (of relational atoms),
then we use superscripts (cid:6)= and ¬, respectively. Thus, for example, CQ
(cid:2)= is the class of
conjunctive queries with inequalities, and UCQ
is the class of unions of conjunctive
queries with negation. As usual in the database literature, we assume that every query
is safe: (1) if Q1 and Q2 are disjuncts of Q, then Q1 and Q2 have the
Q in UCQ
same free variables, (2) if Q1 is a disjunct of Q and x (cid:6)= y is a conjunct of Q1, then
x and y appear in some non-negated relational atoms of Q1, (3) if Q1 is a disjunct of
Q and ¬R(¯x) is a conjunct of Q1, then every variable in ¯x appears in a non-negated
relational atom of Q1.

(cid:2)=,¬

¬

2.1 Data Exchange Settings and Solutions

As is customary in the data exchange literature, we consider instances with two types of
values: constants and nulls [10,11]. More precisely, let C and N be inﬁnite and disjoint
sets of constants and nulls, respectively, and assume that D = C ∪ N. If we refer
to a schema S as a source schema, then we will assume that for every instance I of
S, it holds that dom(I) ⊆ C. On the other hand, if we refer to a schema T as a target
schema, then for every instance J of T, it holds that dom(J) ⊆ C∪N. Slightly abusing
notation, we also use C to denote a built-in unary predicate such that C(a) holds if and
only if a is a constant, that is a ∈ C.
A data exchange setting is a tuple M = (S, T, Σst), where S is a source schema, T
is a target schema, S and T do not have predicate symbols in common and Σst is a set
of FO-dependencies over S∪ T (in [10] and [11] a more general class of data exchange
settings is presented, that also includes target dependencies; we consider these settings
in Section 4.1). As usual in the data exchange literature (e.g., [10,11]), we restrict the
study to data exchange settings in which Σst consists of a set of source-to-target tuplegenerating 
dependencies. A source-to-target tuple-generating dependency (st-tgd) is an

M. Arenas, P. Barcel´o, and J.L. Reutter

306
FO-sentence of the form ∀¯x∀¯y (φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z)), where φ(¯x, ¯y) is a conjunction
of relational atoms over S and ψ(¯x, ¯z) is a conjunction of relational atoms over T.1 A
source (resp. target) instance K for M is an instance of S (resp. T). We usually denote
source instances by I, I(cid:3), I1, . . . , and target instances by J, J(cid:3), J1, . . . .

The class of data exchange settings considered in this paper is usually called GLAV
(global-&-local-as-view) in the database literature [15]. One of the restricted forms of
this class that has been extensively studied for data integration and exchange is the class
of LAV settings. Formally, a LAV setting (local-as-view) [15] is a data exchange setting
M = (S, T, Σst), in which every st-tgd in Σst is of the form ∀¯x (S(¯x) → ∃¯z ψ(¯x, ¯z)),
for some S ∈ S.
An instance J of T is said to be a solution for an instance I under M = (S, T, Σst),
if the instance K = (I, J) of S ∪ T satisﬁes Σst, where SK = SI for every S ∈ S
and T K = T J for every T ∈ T. If M is clear from the context, we shall say that J is a
solution for I.
Example 1. Let M = (S, T, Σst) be a data exchange setting. Assume that S consists
of one binary relation symbol P , and T consists of two binary relation symbols Q and
R. Further, assume that Σst consists of st-tgds P (x, y) → Q(x, y) and P (x, y) →
∃zR(x, z). Then M is also a LAV setting.
Let I = {P (a, b), P (a, c)} be a source instance. Then J1 = {Q(a, b), Q(a, c),
R(a, b)} and J2 = {Q(a, b), Q(a, c), R(a, n)}, where n ∈ N, are solutions for I. In
fact, I has inﬁnitely many solutions.

2

2.2 Universal Solutions and Canonical Universal Solution

It has been argued in [10] that the preferred solutions in data exchange are the universal
solutions. In order to deﬁne this notion, we ﬁrst have to revise the concept of homomorphism 
in data exchange. Let K1 and K2 be instances of the same schema R. A
homomorphism h from K1 to K2 is a function h : dom(K1) → dom(K2) such that:
(1) h(c) = c for every c ∈ C ∩ dom(K1), and (2) for every R ∈ R and every tuple
¯a = (a1, . . . , ak) ∈ RK1, it holds that h(¯a) = (h(a1), . . . , h(ak)) ∈ RK2. Notice that
this deﬁnition of homomorphism slightly differs from the usual one, as the additional
constraint that homomorphisms are the identity on the constants is imposed.
Let M be a data exchange setting, I a source instance and J a solution for I under
M. Then J is a universal solution for I under M, if for every solution J(cid:3)
for I under
M, there exists a homomorphism from J to J(cid:3)
Example 2 (Example 1 continued). Solution J2 is a universal solution for I, while J1
is not since there is no homomorphism from J1 to J2.
2

.

It follows from [10] that for the class of data exchange settings studied in this paper,
every source instance has universal solutions. In particular, one of these solutions -
called the canonical universal solution - can be constructed in polynomial time from
the given source instance (assuming the setting to be ﬁxed), using the chase procedure
[6] (see e.g. [10]).

1 We usually omit universal quantiﬁcation in front of st-tgds and express them simply as
φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z).

Datalog as a Query Language for Data Exchange Systems

307

Remark: Notice that each target instance J(cid:3)
that contains the canonical universal solution 
J of a source instance I, is also a solution for I. Thus, each source instance has
inﬁnitely many solutions.

2.3 Certain Answers
Queries in a data exchange setting M = (S, T, Σst) are posed over the target schema
T. Given that there are inﬁnitely many solutions for a given source instance I with
respect to M, the standard approach in the data exchange literature is to deﬁne the
semantics of the query based on the notion of certain answers [14,1,15,10].
Let I be a source instance. For a query Q of arity n ≥ 0, in any of our logical
formalisms, we denote by certainM(Q, I) the set of certain answers of Q over I under
M, that is, the set of n-tuples ¯t such that ¯t ∈ Q(J), for every J that is a solution
for I under M. If n = 0, then we say that Q is Boolean, and certainM(Q, I) =
true if and only if Q holds for every J that is a solution for I under M. We write
certainM(Q, I) = false if it is not the case that certainM(Q, I) = true.
Let M = (S, T, Σst) be a data exchange setting and Q a query over T. The main

problem studied in this paper is:

PROBLEM : CERTAIN-ANSWERS(M, Q).
INPUT
QUESTION : Does ¯t ∈ certainM(Q, I)?

: A source instance I and a tuple ¯t of constants from I.

3 Extending Query Languages for Data Exchange: DATALOG

C((cid:2)=)

Programs

The class of unions of conjunctive queries is particularly well-behaved for data exchange;
 the certain answers of each union of conjunctive queries Q can be computed by
directly posing Q over an arbitrary universal solution [10]. More formally, given a data
exchange setting M, a source instance I, a universal solution J for I under M, and
a tuple ¯t of constants, ¯t ∈ certainM(Q, I) if and only if ¯t ∈ Q(J). This implies that
for each data exchange setting M, the problem CERTAIN-ANSWERS(M, Q) can be
solved in polynomial time if Q is a union of conjunctive queries (because the canonical
universal solution for I can be computed in polynomial time and Q can be evaluated in
polynomial time in the size of the data).

The fact that the certain answers of a union of conjunctive queries Q can be computed 
by posing Q over a universal solution, can be fully explained by the fact that Q is
preserved under homomorphisms, that is, for every pair of instances J, J(cid:3)
, homomor-
, and tuple ¯a of elements in J, if ¯a ∈ Q(J), then h(¯a) ∈ Q(J(cid:3)).
phism h from J to J(cid:3)
But UCQ is not the only class of queries that is preserved under homomorphisms; also
DATALOG, the recursive extension of the class UCQ, has this property. Since each
DATALOG program can be evaluated in polynomial time in the size of the data, we
have that the certain answers to each DATALOG query Q can be obtained efﬁciently by
ﬁrst computing a universal solution J, and then evaluating Q over J. Thus, DATALOG
preserves the good properties of UCQ for data exchange.

308

M. Arenas, P. Barcel´o, and J.L. Reutter

Unfortunately, both UCQ and DATALOG keep us in the realm of the positive (i.e.
negated atoms are not allowed in queries), while most database query languages are
equipped with negation. It seems then natural to extend UCQ (or DATALOG) in the
context of data exchange with some form of negation. Indeed, query languages with
different forms of negation have been considered in the data exchange context [3,8], as
they can be used to express interesting queries. Next, we show an example of this fact.
Example 3. Consider a data exchange setting with S = {E(·,·), A(·), B(·)}, T =
{G(·,·), P (·), R(·)} and

Σst = {E(x, y) → G(x, y), A(x) → P (x), B(x) → R(x)}.

Notice that if I is a source instance, then the canonical universal solution CAN(I) for I
is such that EI = GCAN(I), AI = P CAN(I) and BI = RCAN(I).

Let Q(x) be the following UCQ
∃x∃y (P (x) ∧ R(y) ∧ G(x, y)) ∨ ∃x∃y∃z (G(x, z) ∧ G(z, y) ∧ ¬G(x, y)).

query over T:

¬

It is not hard to prove that for every source instance I, certainM(Q, I) = true if and
only if there exist elements a, b ∈ dom(CAN(I)) such that a belongs to P CAN(I), b
belongs to RCAN(I) and (a, b) belongs to the transitive closure of the relation GCAN(I).
That is, certainM(Q, I) = true if and only if there exist elements a, b ∈ dom(I) such
that a belongs to AI, b belongs to BI and (a, b) belongs to the transitive closure of the
relation EI.
2

It is well-known (see e.g. [16]) that there is no union of conjunctive queries (indeed,
not even an FO-query) that deﬁnes the transitive closure of a graph. Thus, if Q and M
are as in the previous example, then there is no union of conjunctive queries Q(cid:3)
such
that Q(cid:3)(CAN(I)) = certainM(Q(cid:3), I) = certainM(Q, I), for every source instance I.
It immediately follows that negated relational atoms add expressive power to the class
UCQ in the context of data exchange (see also [4]). And not only that, it follows from
[10] that inequalities also add expressive power to UCQ in the context of data exchange.
Unfortunately, adding an unrestricted form of negation to DATALOG (or even to
CQ) not only destroys preservation under homomorphisms, but also easily leads to intractability 
of the problem of computing certain answers [1,10]. More precisely, there is
(cid:2)= such that the problem CERTAIN-ANSWERS(M, Q)
a setting M and a query Q in CQ
cannot be solved in polynomial time (unless PTIME = NP). In particular, the set of
certain answers of Q cannot be computed by evaluating Q over a polynomial-time computable 
universal solution.

3.1 DATALOG

C((cid:2)=) Programs

C((cid:2)=) [5] that adds negation in a natural
We have recently proposed a language DATALOG
way to DATALOG, while keeping the good properties of this language for data exchange.
We deﬁne this language below.

C((cid:2)=) programs). A constant-inequality Datalog rule is a rule

Deﬁnition 1 (DATALOG
of the form:

S(¯x) ← S1(¯x1), . . . , S(cid:2)(¯x(cid:2)), C(y1), . . . , C(ym), u1 (cid:6)= v1, . . . , un (cid:6)= vn,

(1)

Datalog as a Query Language for Data Exchange Systems

309

where
(a) S, S1, . . ., S(cid:2) are (non necessarily distinct) predicate symbols,
(b) every variable in ¯x is mentioned in some tuple ¯xi (i ∈ [1, (cid:6)]),
(c) every variable yj (j ∈ [1, m]) is mentioned in some tuple ¯xi (i ∈ [1, (cid:6)]), and
(d) every variable uj (j ∈ [1, n]), and every variable vj, is equal to some variable yi

(i ∈ [1, m]).

Further, a constant-inequality Datalog program (DATALOG
set of constant-inequality Datalog rules.

C((cid:2)=) program) Π is a ﬁnite

For example, the following is a constant-inequality Datalog program:

R(x, y) ← T (x, z), S(z, y), C(x), C(z), x (cid:6)= z

S(x) ← U(x, u, v, w), C(x), C(u), C(v), C(w), u (cid:6)= v, u (cid:6)= w

Assume that Π is a DATALOG

For a rule of the form (1), we say that S(¯x) is its head. The set of predicates of a
C((cid:2)=) program Π, denoted by Pred(Π), is the set of predicate symbols menDATALOG

tioned in Π, while the set of intensional predicates of Π, denoted by IPred(Π), is the
set of predicates symbols R ∈ Pred(Π) such that R(¯x) appears as the head of some
rule of Π.
C((cid:2)=) program and I is a database instance of the
relational schema Pred(Π). Then T (I) is an instance of Pred(Π) such that for every
R ∈ Pred(Π) and every tuple ¯t, it holds that ¯t ∈ RT (I) if and only if there exists a rule
R(¯x) ← R1(¯x1), . . . , R(cid:2)(¯x(cid:2)), C(y1), . . . , C(ym), u1 (cid:6)= v1, . . . , un (cid:6)= vn in Π and a
variable assignment σ such that (a) σ(¯x) = ¯t, (b) σ(¯xi) ∈ RI
i , for every i ∈ [1, (cid:6)], (c)
σ(yi) is a constant, for every i ∈ [1, m], and (d) σ(ui) (cid:6)= σ(vi), for every i ∈ [1, n].
Operator T is used to deﬁne the semantics of constant-inequality Datalog programs.
More precisely, deﬁne T 0
Π (I), for every
n ≥ 0. Then the evaluation of Π over I is deﬁned as T ∞
Π (I).
A constant-inequality Datalog program Π is said to be deﬁned over a relational
schema R if R = Pred(Π) (cid:2) IPred(Π) and ANSWER ∈ IPred(Π). Given an instance 
I of R and a tuple ¯t in dom(I)n, where n is the arity of ANSWER, we say that
¯t ∈ Π(I) if ¯t ∈ ANSWER
T ∞
Π (I0), where I0 is an extension of I deﬁned as: RI0 = RI
for R ∈ R and RI0 = ∅ for R ∈ IPred(Π).

Π (I) to be T (T n
Π (I) =

Π(I) to be I and T n+1

Π (I)) ∪ T n
n≥0 T n

(cid:2)

3.2 Certain Answers for DATALOG

C((cid:2)=) Programs

As we mentioned before, the homomorphisms in data exchange are not arbitrary; they
are the identity on the constants. Thus, given that inequalities are witnessed by con-
C((cid:2)=) programs, we have that these programs are preserved under
stants in DATALOG
C((cid:2)=)
homomorphisms. From this we conclude that the certain answers to a DATALOG
program Π can be computed by directly evaluating Π over a universal solution. Thus,
C((cid:2)=) programs preserve the good properties of DATALOG, and UCQ, for data
DATALOG
exchange.
Proposition 1 ([5]). Let M = (S, T, Σst) be a data exchange setting, I a source
instance, J a universal solution for I under M, and Π a DATALOG
C((cid:2)=) program over
T. Then for every tuple ¯t of constants, ¯t ∈ certainM(Π, I) iff ¯t ∈ Π(J).

310

M. Arenas, P. Barcel´o, and J.L. Reutter

C((cid:2)=) program Π over I can be computed by
Thus, the certain answers of a DATALOG
directly posing Π over CAN(I) and discarding tuples that contain nulls. This implies
that for each data exchange setting M, the problem CERTAIN-ANSWERS(M, Π) can
C((cid:2)=) program (since CAN(I) can be
be solved in polynomial time if Π is a DATALOG
computed in polynomial time and Π can be evaluated in polynomial time in the size of
the data).
Corollary 1. The problem CERTAIN-ANSWERS(M, Π) can be solved in polynomial
time, for every data exchange setting M and DATALOG

C((cid:2)=) program Π.
C((cid:2)=) Programs

(2)
(3)
(4)

4 On the Expressive Power of DATALOG

C((cid:2)=) programs are capable of expressing relevant
We have shown in [5] that DATALOG
data exchange properties. In particular, these programs are expressive enough to capture
the class of unions of conjunctive queries with at most one negated atom per disjunct.
This class has proved to be relevant for data exchange, as its restriction with inequalities
(cid:2)= with at most one inequality per disjunct) not only
(that is, the class of queries in UCQ
can express relevant queries but also is one of the few known extensions of the class
UCQ for which the problem of computing certain answers is tractable [10].

(cid:2)=,¬

query over a schema T, with at most one inTheorem 
1 ([5]). Let Q be a UCQ
C((cid:2)=)
equality or negated relational atom per disjunct. Then there exists a DATALOG
program ΠQ over T such that for every data exchange setting M = (S, T, Σst) and
instance I of S, certainM(Q, I) = certainM(ΠQ, I). Moreover, ΠQ can be effectively
constructed from Q in polynomial time.

We sketch the proof of this theorem by means of an example, since we prove a stronger
result later (Theorem 4).
Example 4. Let M be a data exchange setting such that S = {E(·,·), A(·)}, T =
{G(·,·), P (·)} and

Σst = {E(x, y) → ∃z(G(x, z) ∧ G(z, y)), A(x) → P (x)}.

(cid:2)=,¬

:

Also, let Q(x) be the following query in UCQ
(P (x) ∧ G(x, x)) ∨ ∃y (G(x, y) ∧ x (cid:6)= y) ∨ ∃y∃z (G(x, z) ∧ G(z, y) ∧ ¬G(x, y)).
C((cid:2)=) program ΠQ such that certainM(Q, I) =
We construct a DATALOG
C((cid:2)=) program ΠQ
certainM(ΠQ, I). The set of intensional predicates of the DATALOG
is {U1(·,·,·), U2(·,·), DOM(·), EQUAL(·,·,·), ANSWER(·)}. The program ΠQ over T
is deﬁned as follows.
First, the program collects in DOM(x) all the elements that belong to the active

domain of the instance of T where ΠQ is evaluated:
DOM(x) ← G(x, z)
DOM(x) ← G(z, x)
DOM(x) ← P (x)

Datalog as a Query Language for Data Exchange Systems

311

Second, the program ΠQ includes the following rules that formalize the idea that
EQUAL(x, y, z) holds if x and y are the same elements:
EQUAL(x, x, z) ← DOM(x), DOM(z)
EQUAL(x, y, z) ← EQUAL(y, x, z)
EQUAL(x, y, z) ← EQUAL(x, w, z), EQUAL(w, y, z)

(5)
(6)
(7)

Predicate EQUAL includes an extra argument that keeps track of the element z where the
query is being evaluated. Notice that we cannot simply use the rule EQUAL(x, x, z) ←
C((cid:2)=) programs are safe, i.e. every variable
to say that EQUAL is reﬂexive, as DATALOG
that appears in the head of a rule also has to appear in its body.

Third, ΠQ includes the rules:

U1(x, y, z) ← G(x, y), DOM(z)
U2(x, z) ← P (x), DOM(z)
U1(x, y, z) ← U1(u, v, z), EQUAL(u, x, z), EQUAL(v, y, z)
U2(x, z) ← U2(u, z), EQUAL(u, x, z)

(8)
(9)
(10)
(11)

Intuitively, the ﬁrst two rules create in U1 and U2 a copy of G and P , respectively,
but again with an extra argument for keeping track of the element where ΠQ is being
evaluated. The last two rules allow to replace equal elements in the interpretation of U1
and U2.

Fourth, ΠQ includes the following rule for the third disjunct of Q(x):

U1(x, y, x) ← U1(x, z, x), U1(z, y, x)

(12)

Intuitively, this rule expresses that if a is an element that does not belong to the set of
certain answers to Q(x), then for every pair of elements b and c such that (a, b) and
(b, c) belong to the interpretation of G, it must be the case that (a, c) also belongs to it.

Fifth, ΠQ includes the following rule for the second disjunct of Q(x):

EQUAL(x, y, x) ← U1(x, y, x)

(13)

Intuitively, this rule expresses that if a is an element that does not belong to the set of
certain answers to Q(x), then for every element b such that the pair (a, b) belongs to
the interpretation of G, it must be the case that a = b.

Finally, ΠQ includes two rules for collecting the certain answers to Q(x):

ANSWER(x) ← U2(x, x), U1(x, x, x), C(x)
ANSWER(x) ← EQUAL(y, z, x), C(x), C(y), C(z), y (cid:6)= z

(14)
(15)

Intuitively, rule (14) says that if a constant a belongs to the interpretation of P and
(a, a) belongs to the interpretation of G, then a belongs to the set of certain answers to
Q(x). Indeed, this means that if J is an arbitrary solution where the program is being
evaluated, then a belongs to the evaluation of the ﬁrst disjunct of Q(x) over J.

Rule (15) says that if in the process of evaluating ΠQ with parameter a, two distinct
constants b and c are declared to be equal (EQUAL(b, c, a) holds), then a belongs to

312

M. Arenas, P. Barcel´o, and J.L. Reutter

the set of certain answers to Q(x). We show the application of this rule with an example.
 Let I be a source instance, and assume that (a, n) and (n, b) belong to G in
the canonical universal solution for I, where n is a null value. By applying rule (2),
we have that DOM(a) holds in CAN(I). Thus, we conclude by applying rule (8) that
U1(a, n, a) and U1(n, b, a) hold in CAN(I) and, therefore, we obtain by using rule (13)
that EQUAL(a, n, a) holds in CAN(I). Notice that this rule is trying to prove that a
is not in the certain answers to Q(x) and, hence, it forces n to be equal to a. Now
by using rule (6), we obtain that EQUAL(n, a, a) holds in CAN(I). But we also have
that EQUAL(b, b, a) holds in CAN(I) (by applying rules (3) and (5)). Thus, by applying 
rule (10), we obtain that U1(a, b, a) holds in CAN(I). Therefore, by applying rule
(13) again, we obtain that EQUAL(a, b, a) holds in CAN(I). This time, rule (13) tries to
prove that a is not in the certain answers to Q(x) by forcing constants a and b to be the
same value. But this cannot be the case since a and b are distinct constants and, thus,
rule (15) is used to conclude that a is in the certain answers to Q(x). It is important to
notice that this conclusion is correct. If J is an arbitrary solution for I, then we have
that there exists a homomorphism h : CAN(I) → J. Given that a and b are distinct
constants, we have that a (cid:6)= h(n) or b (cid:6)= h(n). It follows that there is an element c in J
such that a (cid:6)= c and the pair (a, c) belongs to the interpretation of G. Thus, we conclude
that a belongs to the evaluation of the second disjunct of Q(x) over J.
It is now an easy exercise to show that the set of certain answers to Q(x) coincide
2

with the set of certain answers to ΠQ, for every source instance I.

As an immediate corollary to Theorem 1 and Corollary 1 we obtain the following:
Corollary 2. The problem CERTAIN-ANSWERS(M, Q) can be solved in polynomial
time, for every data exchange setting M and every union of conjunctive queries Q with
at most one inequality or negated relational atom per disjunct.

We note that this slightly generalizes one of the polynomial time results in [10], which
is stated for the class of unions of conjunctive queries with at most one inequality per
disjunct. The proof of the result in [10] uses different techniques, based on the chase
procedure.
It is important to notice that Corollary 2 is, in a sense, optimal, as there is a LAV
data exchange setting M and a conjunctive query with two inequalities, such that
CERTAIN-ANSWERS(M, Q) is CONP-complete [19]. This shows that Theorem 1 cannot 
be further extended to deal with arbitrary conjunctive queries with negated atoms.
A natural question at this point is whether the problem CERTAIN-ANSWERS(M, Q)
is PTIME-complete for some data exchange setting M and union of conjunctive queries
Q with at most one negated atom per disjunct. The following proposition shows that
this is indeed the case.
Proposition 2 ([5]). There exist a LAV data exchange setting M and a Boolean conjunctive 
query Q with one inequality such that CERTAIN-ANSWERS(M, Q) is PTIMEcomplete,
 under LOGSPACE reductions.

The previous result establishes a difference with the class of unions of conjunctive
queries (UCQ), for which the problem of computing certain answers under a setting
M can be solved in LOGSPACE.

Datalog as a Query Language for Data Exchange Systems

313

4.1 Adding Target Dependencies

In addition to the simple data exchange scenario we have seen so far, it is common in
the literature to assume that target schemas come with its own set of dependencies Σt.
Formally, data exchange settings with target dependencies (as presented, for instance,
in [10,11]) are tuples of the form M = (S, T, Σst, Σt), where S, T and Σst are as
before, and Σt is the union of (1) a set of tuple-generating dependencies (tgds), i.e.
dependencies of the form ∀¯x∀¯y (φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z)), where φ(¯x, ¯y) and ψ(¯x, ¯z) are
conjunctions of atomic formulas in T, and (2) a set of equality-generating dependencies
(egds), i.e. dependencies of the form∀¯x (φ(¯x) → xi = xj), where φ(¯x) is a conjunction
of atomic formulas in T, and xi, xj are variables among those in ¯x.2
For settings with target dependencies, the solutions also have to satisfy the dependencies 
in Σt. That is, if M = (S, T, Σst, Σt) is a data exchange setting and I is an
instance of S, then an instance J of T is a solution for I if not only the pair (I, J)
satisﬁes each dependency in Σst, but also J satisﬁes each dependency in Σt.

As it is to be expected, the addition of target dependencies makes the fundamental
data exchange tasks more difﬁcult, starting from the fact that it is no longer true that
solutions exist for each source instance. Even worst, it follows from [13] that there
exists a data exchange setting M = (S, T, Σst, Σt) with target dependencies such that
the problem of checking for the existence of solutions under M is undecidable.

In order to overcome the aforementioned limitations, the data exchange community
has identiﬁed a relevant class of target dependencies that has good properties for data
exchange. To deﬁne this class, we need to introduce some terminology. Assume that Σ
is a set of tgds over a schema T. Then the dependency graph GΣ of Σ is deﬁned as
follows:
(1) add a node (R, i) to GΣ for every relation R ∈ T and i ∈ {1, . . . , n}, where n is
(2) add an edge (R, i) → (T, j) to GΣ if there exist a tgd φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z) in Σ
and a variable x such that x is mentioned in ¯x, x occurs in the i-th attribute of R in
φ and x occurs in the j-th attribute of T in ψ;
(3) add a special edge (R, i) →∗ (T, j) to GΣ if there exists a tgd φ(¯x, ¯y) →
∃¯z ψ(¯x, ¯z) in Σ such that a variable x occurs in the i-th attribute of R in φ and
an existentially quantiﬁed variable z occurs in the j-th attribute of T in ψ.

the arity of R;

Moreover, Σ is said to be weakly acyclic if the dependency graph GΣ of Σ does not
have a cycle going through an edge labeled ∗ [10]. Next theorem shows that the class
of settings with weakly acyclic sets of tgds has good properties for data exchange.
Theorem 2 ([10]). Let M = (S, T, Σst, Σt) be a data exchange setting, where Σt is
the union of a set of egds and a weakly-acyclic set of tgds. Then there is a polynomial
time algorithm such that for every source instance I, it ﬁrst decides whether a solution
for I exists, and if that is the case, it computes a canonical universal solution for I in
polynomial time.

2 As usual, we omit universal quantiﬁers in front of tgds and egds.

314

M. Arenas, P. Barcel´o, and J.L. Reutter

The latter implies that for the class of data exchange settings whose target dependencies
consist of a set of equality-generating dependencies and a weakly-acyclic set of tuplegenerating 
dependencies, the certain answers to each union of conjunctive queries Q for
a source instance I, can be computed in polynomial time by simply posing Q over the
canonical universal solution J for I and then discarding the tuples that contain nulls (in
case such a solution J exists). Notice, however, that using exactly the same argument
C((cid:2)=) programs can be
one can prove the stronger result that certain answers to DATALOG
computed in polynomial time under the class of settings speciﬁed in Theorem 2. This is
C((cid:2)=) programs are preserved under data exchange homomorphisms
because DATALOG
and can be evaluated in polynomial time in the size of the data. Indeed,
Corollary 3. Let M = (S, T, Σst, Σt) be a data exchange setting, where Σt is the
C((cid:2)=)
union of a set of egds and a weakly acyclic set of tgds, and let Π be a DATALOG
program over T. Then the problem CERTAIN-ANSWERS(M, Π) can be solved in polynomial 
time.

Let us recall Corollary 2. It says that the certain answers to a union of conjunctive
queries with at most one negated atom per disjunct, can be computed in polynomial
time for settings without target dependencies. A natural question at this point is whether
this positive result continues to hold if target schemas are allowed to contain dependencies 
of the form speciﬁed in Theorem 2. The following result shows that not only this
is not the case, but also that the problem of computing certain answers to unions of
conjunctive queries with at most one negated atom per disjunct is undecidable for this
class of settings
Theorem 3. There exists a data exchange setting M = (S, T, Σst, Σt), where Σt is
the union of a set of egds and a weakly-acyclic set of tgds, and a Boolean CQ
query
Q over T with a single negated relational atom such that CERTAIN-ANSWERS(M, Q)
is undecidable.

¬

Proof. Let S(cid:5) be a source schema consisting of a ternary relation P , T (cid:5) a target schema
consisting of a ternary relation R and M(cid:5) = (S(cid:5), T (cid:5), Σ(cid:5)
t ) a data exchange setting,
where Σ(cid:5)

st consists of the following dependency:

st, Σ(cid:5)

P (x, y, x) → R(x, y, z),

and Σ(cid:5)

t consists of the egd:

R(x, y, z) ∧ R(x, y, w) → z = w,

and the following tgds:
R(x, y, u)∧ R(y, z, v) ∧ R(u, z, w) → R(x, v, w),
R(x, y, z)∧ R(x(cid:3), y(cid:3), z(cid:3)) → ∃w1∃w2∃w3∃w4∃w5∃w6∃w7∃w8∃w9 (R(x, x(cid:3), w1) ∧

R(x, y(cid:3), w2) ∧ R(x, z(cid:3), w3) ∧ R(y, x(cid:3), w4) ∧ R(y, y(cid:3), w5) ∧
R(y, z(cid:3), w6) ∧ R(z, x(cid:3), w7) ∧ R(z, y(cid:3), w8) ∧ R(z, z(cid:3), w9)).

Datalog as a Query Language for Data Exchange Systems

315

In [13], it was proved that the problem of verifying, given an instance I of S(cid:5), whether
there exists at least one solution for I under M(cid:5) is undecidable. Next we show how
to reduce this problem to the complement of our problem. More precisely, we deﬁne a
data exchange setting M = (S, T, Σst, Σt), where S = S(cid:5) and Σt is the union of a set
query Q over T with a
of egds and a weakly-acyclic set of tgds, and a Boolean CQ
single negated relational atom such that for every instance I of S(cid:5): There exists at least
one solution for I under M(cid:5) if and only if certainM(Q, I) = false. From this, we
conclude that CERTAIN-ANSWERS(M, Q) is undecidable.

Let S = S(cid:5), T = T(cid:5) ∪ {S}, where S is a ternary predicate, Σst = Σ(cid:5)

st and Σt be a

¬

set of target dependencies consisting of the egd:

R(x, y, z) ∧ R(x, y, w) → z = w,

and the following tgds:
R(x, y, u)∧ R(y, z, v) ∧ R(u, z, w) → R(x, v, w),
R(x, y, z)∧ R(x(cid:3), y(cid:3), z(cid:3)) → ∃w1∃w2∃w3∃w4∃w5∃w6∃w7∃w8∃w9 (S(x, x(cid:3), w1) ∧

S(x, y(cid:3), w2) ∧ S(x, z(cid:3), w3) ∧ S(y, x(cid:3), w4) ∧ S(y, y(cid:3), w5) ∧
S(y, z(cid:3), w6) ∧ S(z, x(cid:3), w7) ∧ S(z, y(cid:3), w8) ∧ S(z, z(cid:3), w9)).

Moreover, let Q be the following Boolean query:

∃x∃y∃z (S(x, y, z) ∧ ¬R(x, y, z)).

It is important to notice that the set of tgds in Σ(cid:5)
t is not weakly acyclic, while the set
of tgds in Σt is weakly acyclic. Next we show that for every instance I of S(cid:5), it holds
that there exists at least one solution for I under M(cid:5) if and only if certainM(Q, I) =
false.
(⇒) Let I be an instance of S(cid:5) and J (cid:5) a solution for I under M(cid:5). Deﬁne J as the
. Given that (I, J (cid:5)) satisﬁes Σ(cid:5)
following instance of T: RT = RT (cid:3)
t , we have that (I, J) satisﬁes Σst and J satisﬁes Σt and, therefore,
and J (cid:5) satisﬁes Σ(cid:5)
J is a solution for I under M. Thus, given that Q does not hold in J (since RT = ST ),
we conclude that certainM(Q, I) = false.
(⇐) Assume that I is an instance of S(cid:5) such that certainM(Q, I) = false. Then
let J be a solution of I under M such that Q does not hold in J, and J (cid:5) an instance of
T(cid:5) deﬁned as RT (cid:3) = RT . Given that (I, J) satisﬁes Σst, we have that (I, J (cid:5)) satisﬁes
Σ(cid:5)
st. Furthermore, given that Q does not hold in J, we have that J satisﬁes dependency:

and ST = RT (cid:3)

st

∀x∀y∀z (S(x, y, z) → R(x, y, z)).

Thus, given that J satisﬁes Σt, we conclude that J (cid:5) satisﬁes Σ(cid:5)
t . Hence, we have that
J (cid:5) is a solution for I under M(cid:5), from which we deduce that there exists at least one
solution for I under M(cid:5). This concludes the proof of the theorem.
A natural way to ensure that the problem of computing certain answers to unions of
conjunctive queries with at most one negated atom per disjunct remains tractable, in

2

316

M. Arenas, P. Barcel´o, and J.L. Reutter

C((cid:2)=) programs.

the presence of target dependencies, is by restricting the class of target dependencies
allowed. Indeed, we prove below that this is the case for the class of data exchange
settings that only allow egds in the target. The interesting part of this is not the result
itself – which is a slight extension of a result in [10] – but the fact that our proof relies
again on the translation of the problem of computing certain answers for this class
of queries, under the settings described above, into the problem of computing certain
answers to DATALOG
A na¨ıve approach to prove this result would be the following. Let M =
(S, T, Σst, Σt) be a data exchange setting, where Σt consists of a set of equalitygenerating 
dependencies, and let M(cid:3)
be the setting obtained from M by removing Σt.
As we have mentioned above, for each union of conjunctive queries Q, with at most one
C((cid:2)=)
inequality or negated relational atom per disjunct, one can construct a DATALOG
program ΠQ such that the certain answers to Q under M(cid:3)
coincide with the certain
answers to ΠQ under M(cid:3)
. Then one could implement the following algorithm for computing 
certain answers to Q under M: Given a source instance I, compute the canonical
universal solution J for I under M (in case such a solution exists); evaluate ΠQ over
J; discard tuples that contain nulls.

Unfortunately, this simple algorithm is not correct for the following reason. Evaluating 
the program ΠQ over J may force some elements in J to be equal, which, in turn,
may imply some of the dependencies in Σt to be triggered in the process. This suggests
that if one wants to compute the certain answers to Q (under M) with a DATALOG
C((cid:2)=)
program ΠQ, then ΠQ must take into consideration not only Q but also Σt. Indeed, we
show next that for each union of conjunctive queries, with at most one negated atom
C((cid:2)=) program ΠQ,Σt such that the
per disjunct, it is possible to construct a DATALOG
certain answers to Q and to ΠQ,Σt (under M) coincide. Formally,
(cid:2)=,¬ k-ary query over a schema T (k ≥ 0), with at most
Theorem 4. Let Q be a UCQ
one inequality or negated relational atom per disjunct. Further, let Σt be a set of egds
C((cid:2)=) program ΠQ,Σt over T such that for every
over T. Then there exists a DATALOG
data exchange setting M = (S, T, Σst, Σt), instance I of S and tuple ¯a ∈ dom(I)k:

¯a ∈ certainM(Q, I) if and only if ¯a ∈ certainM(ΠQ,Σt, I).

Moreover, ΠQ,Σt can be effectively constructed from Q and Σt in polynomial time.
Proof. Assume that T = {T1, . . . , Tk}, where each Ti has arity ni > 0, that Q(¯x) =
Q1(¯x) ∨ ··· ∨ Q(cid:2)(¯x), where ¯x = (x1, . . . , xm) and each Qi(¯x) is a conjunctive query
with at most one inequality or negated relational atom, and that Σt = {α1, . . . , αq} is
a set of egds.

Then the set of intensional predicates of DATALOG

C((cid:2)=) program ΠQ,Σt is

{U1, . . . , Uk, DOM, EQUAL, ANSWER},

where each Ui (i ∈ [1, k]) has arity ni + m, DOM has arity 1, EQUAL has arity 2 + m
and ANSWER has arity m. Moreover, the set of rules of ΠQ,Σt is deﬁned as follows.

Datalog as a Query Language for Data Exchange Systems

317

– For every predicate Ti ∈ T, ΠQ,Σt includes the following k rules:

DOM(x) ← Ti(x, y2, y3, . . . , yni−1, yni)
DOM(x) ← Ti(y1, x, y3, . . . , yni−1, yni)

DOM(x) ← Ti(y1, y2, y3, . . . , yni−1, x)

···

– ΠQ,Σt includes the following rules for predicate EQUAL:

EQUAL(x, x, z1, . . . , zm) ← DOM(x), DOM(z1), . . . , DOM(zm)
EQUAL(x, y, z1, . . . , zm) ← EQUAL(y, x, z1, . . . , zm)
EQUAL(x, y, z1, . . . , zm) ← EQUAL(x, w, z1, . . . , zm), EQUAL(w, y, z1, . . . , zm)

– For every predicate Ui, ΠQ,Σt includes the following rules:

Ui(y1, . . . , yni, z1, . . . , zm) ← Ti(y1, . . . , yni), DOM(z1), . . . , DOM(zm)
Ui(y1, . . . , yni, z1, . . . , zm) ← Ui(w1, . . . , wni , z1, . . . , zm),

EQUAL(w1, y1, z1, . . . , zm), . . . ,
EQUAL(wni , yni, z1, . . . , zm)

– Let i ∈ [1, (cid:6)]. First, assume that Qi(¯x) does not contain any negated atom. Then
Qi(¯x) is equal to ∃¯u (Tp1(¯u1)∧···∧Tpn(¯un)), where pj ∈ [1, k] and every variable
in ¯uj is mentioned in either ¯u or ¯x, for every j ∈ [1, n]. In this case, program ΠQ,Σt
includes the following rule:

ANSWER(¯x) ← Up1(¯u1, ¯x), . . . , Upn(¯un, ¯x), C(x1), . . . , C(xm)

(16)

Notice that this rule is well deﬁned since the set ¯x is the set of free variables of
∃¯u (Tp1(¯u1) ∧ ··· ∧ Tpn(¯un)). Second, assume that Qi(¯x) contains a negated relational 
atom. Then Qi(¯x) is equal to ∃¯u (Tp1(¯u1)∧···∧ Tpn(¯un)∧¬Tpn+1(¯un+1)),
where pj ∈ [1, k] and every variable in ¯uj is mentioned in either ¯u or ¯x, for every
j ∈ [1, n + 1]. In this case, program ΠQ,Σt includes the following rule:

Upn+1(¯un+1, ¯x) ← Up1(¯u1, ¯x), . . . , Upn(¯un, ¯x).

(17)
This rule is well deﬁned since ∃¯u (Tp1(¯u1) ∧ ··· ∧ Tpn(¯un) ∧ ¬Tpn+1(¯un+1)) is a
safe query. Finally, assume that Qi(¯x) contains an inequality. Then Qi(¯x) is equal
to ∃¯u (Tp1(¯u1) ∧ ··· ∧ Tpn(¯un) ∧ v1 (cid:6)= v2), where pj ∈ [1, k] and every variable
in ¯uj is mentioned in either ¯u or ¯x, for every j ∈ [1, n], and v1, v2 are mentioned
in ¯u or ¯x. In this case, program ΠQ,Σt includes the following rule:
EQUAL(v1, v2, ¯x) ← Up1(¯u1, ¯x), . . . , Upn(¯un, ¯x)

(18)
We note that the rule above is well deﬁned since ∃¯u (Tp1(¯u1)∧···∧Tpn(¯un)∧v1 (cid:6)=
v2) is a safe query.

M. Arenas, P. Barcel´o, and J.L. Reutter

318
– For each i ∈ [1, q], assume that dependency αi is of form (Tp1(¯x1) ∧ ··· ∧
Tpn(¯xn) → u = v), where each pj ∈ [1, k] and variables u and v are mentioned in
¯x1, . . . , ¯xn. Then the program ΠQ,Σt includes the following rule:
EQUAL(u, v, ¯x) ← Up1(¯x1, ¯x), . . . , Upn(¯xn, ¯x)

(19)

– Finally, if Q has at least one inequality, or if Σt is nonempty, program ΠQ,Σt

includes the rule:
ANSWER(¯x) ← EQUAL(u, v, ¯x), C(u), C(v), u (cid:6)= v, C(x1), . . . , C(xm)

(20)

Let ¯a be a tuple of elements from the domain of a source instance I. Each predicate Ui
in ΠQ,Σt is used as a copy of Ti but with m extra arguments that store tuple ¯a. These
predicates are used when testing whether ¯a is a certain answer for Q over I. More
speciﬁcally, the rules of ΠQ,Σt try to construct from the canonical universal solution
CAN(I) a solution J for I such that ¯a (cid:6)∈ Q(J). Thus, if in a solution J for I, it holds that
¯a ∈ Q(J) because ¯a ∈ Qi(J), where Qi(¯x) is equal to ∃¯u (Tp1(¯u1) ∧ ··· ∧ Tpn(¯un) ∧
¬Tpn+1(¯un+1)), then ΠQ,Σt uses rule (17) to create a new solution where the negative
atom of Qi does not hold. In the same way, if in a solution J for I, it holds that ¯a ∈ Q(J)
because ¯a ∈ Qi(J), where Qi(¯x) is equal to ∃¯u (Tp1(¯u1) ∧ ··· ∧ Tpn(¯un) ∧ v1 (cid:6)= v2),
then ΠQ,Σt uses rule (18) to create a new solution where the values assigned to v1
and v2 are equal (predicate EQUAL is used to store this fact). If v1 or v2 is assigned
a null value, then it is possible to create a solution where the values assigned to these
variables are the same. But this is not possible if both v1 and v2 are assigned different
constant values. In fact, it follows from [10] that this implies that it is not possible to
for I where ¯a (cid:6)∈ Q(J(cid:3)), and in this case rule (20) is used to indicate
ﬁnd a solution J(cid:3)
that ¯a is a certain answer for Q over I. Notice, however, that every solution for I must
satisfy the dependencies in Σt. Thus, if for some Qi the program uses rules (17) or
(18) to create an instance J such that ¯a (cid:6)∈ Qi(J), but J does not satisﬁes a dependency
φ(¯x) → xi = xj in Σt, then rule (19) must be used to repair that instance, obtaining
a solution J(cid:3)
for I in which the values assigned to xi and xj are the same, but still
holds that ¯a (cid:6)∈ Qi(J). This will not be possible if both xi and xj are assigned different
constant values; in this case, it can be proved using results in [10] that it is not possible
to create a solution such that ¯a (cid:6)∈ Qi(J), and thus rule (20) is used to indicate that ¯a is
a certain answer for Q over I.

By using the above observations, it is not difﬁcult to prove that the statement of the
2

theorem holds, which was to be shown.

As a corollary of Theorem 4 and Corollary 1, we immediately obtain the following
desired result:

(cid:2)=,¬

query over a schema T, with at most one inCorollary 
4. Let Q be a UCQ
equality or negated relational atom per disjunct, and let M = (S, T, Σst, Σt) be
a data exchange setting such that Σt consists of a set of egds. Then the problem
CERTAIN-ANSWERS(M, Q) can be solved in polynomial time.

Datalog as a Query Language for Data Exchange Systems

319
Another possible way to retain tractability of the problem CERTAIN-ANSWERS(M, Q),
where Q is a union of conjunctive queries with at most one negated atom per disjunct
and M is a setting with target dependencies, is by restricting the class of queries allowed.
 Indeed, it has been proved in [10] that for the class of settings whose sets of
target dependencies consist of egds and weakly-acyclic sets of tgds, the certain answers
to a union of conjunctive queries with at most one inequality per disjunct can be computed 
in polynomial time by using an algorithm based on the chase procedure. It is
an interesting open problem whether this result can also be proved with the help of
DATALOG

C((cid:2)=) programs, in the style of Theorem 4 and Corollary 4.

5 Concluding Remarks

C((cid:2)=) that extends DATALOG with a
In this paper, we presented the language DATALOG
restricted form of negation, and studied some of its fundamental properties. In particu-
C((cid:2)=) program can be computed
lar, we showed that the certain answers to a DATALOG
in polynomial time, and we used this property to ﬁnd tractable fragments of the class
of unions of conjunctive queries with inequalities (even in the presence of target depen-
dencies).

Both the problem of the existence of solutions and the computation of certain answers 
are deﬁned in the paper assuming settings to be ﬁxed. That is, in terms of Vardi’s
taxonomy [20], we study the data complexity of these problems. This makes sense in
the database context, as usually speciﬁcations and queries are much smaller than source
instances. However, a more reﬁned complexity analysis of these problems should not
consider any of their parameters to be ﬁxed. This corresponds to the combined complexity 
of the problems mentioned above. The combined complexity of the problem
of existence of solutions was studied in [13,7], while the combined complexity of the
problem of computing certain answers was studied in [5].
C((cid:2)=) programs remain open. In particular, it
would be interesting to know if it is decidable whether the certain answers to a query
C((cid:2)=) program ΠQ,
Q in UCQ
and whether there exist a setting M and a query Q in UCQ
(cid:2)= such that the problem
CERTAIN-ANSWERS(M, Q) is in PTIME, but the certain answers to Q cannot be com-
C((cid:2)=) program ΠQ.
puted as the certain answers to a DATALOG

(cid:2)= can be computed as the certain answers to a DATALOG

Many problems related to DATALOG

Acknowledgments. We are very grateful to Jorge P´erez for many helpful discussions.
 The authors were supported by: Arenas - FONDECYT grant 1090565; Barcel´o -
FONDECYT grant 11080011; Reutter - EPSRC grant G049165.

References

1. Abiteboul, S., Duschka, O.: Answering queries using materialized views. Gemo report 383
2. Abiteboul, S., Hull, R., Vianu, V.: Foundations of databases. Addison-Wesley, Reading

(1995)

3. Afrati, F.N., Li, C., Pavlaki, V.: Data exchange in the presence of arithmetic comparisons. In:

EDBT, pp. 487–498 (2008)

320

M. Arenas, P. Barcel´o, and J.L. Reutter

4. Arenas, M., Barcel´o, P., Fagin, R., Libkin, L.: Locally consistent transformations and query

answering in data exchange. In: PODS, pp. 229–240 (2004)

5. Arenas, M., Barcel´o, P., Reutter, J.: Query languages for data exchange: Beyond unions
of conjunctive queries. Accepted for publication in Theory of Computing Systems, ToCS
(2010); Preliminary version in Proceedings 12th International Conference on Database Theory 
(ICDT 2009), pp. 73–83 (2009)

6. Beeri, C., Vardi, M.Y.: A proof procedure for data dependencies. Journal of the ACM 31(4),

718–741 (1984)

7. Cal`ı, A., Gottlob, G., Pieris, A.: Query answering under non-guarded rules in datalog+/-. In:
Hitzler, P., Lukasiewicz, T. (eds.) RR 2010. LNCS, vol. 6333, pp. 1–17. Springer, Heidelberg
(2010)

8. Deutsch, A., Nash, A., Remmel, J.B.: The chase revisited. In: PODS, pp. 149–158 (2008)
9. Fagin, R., Kolaitis, P., Popa, L., Tan, W.C.: Composing schema mappings: Second-order

dependencies to the rescue. In: PODS, pp. 83–94 (2004)

10. Fagin, R., Kolaitis, P.G., Miller, R.J., Popa, L.: Data exchange: semantics and query answering.
 Theoretical Computer Science 336(1), 89–124 (2005)

11. Fagin, R., Kolaitis, P.G., Popa, L.: Data exchange: getting to the core. ACM Transactions on

Database Systems 30(1), 174–210 (2005)

12. Kolaitis, P.: Schema mappings, data exchange, and metadata management. In: PODS, pp.

61–75 (2005)

13. Kolaitis, P., Panttaja, J., Tan, W.-C.: The complexity of data exchange. In: PODS, pp. 30–39

(2006)

14. Imielinski, T., Lipski, W.: Incomplete information in relational databases. Journal of the

ACM 31, 761–791 (1984)

15. Lenzerini, M.: Data integration: A theoretical perspective. In: PODS, pp. 233–246 (2002)
16. Libkin, L.: Elements of Finite Model Theory. Springer, Heidelberg (2004)
17. Libkin, L.: Data exchange and incomplete information. In: PODS, pp. 60–69 (2006)
18. Libkin, L., Sirangelo, C.: Data exchange and schema mappings in open and closed worlds.

In: PODS, pp. 139–148 (2008)

19. Ma¸dry, A.: Data exchange: On the complexity of answering queries with inequalities. Information 
Processing Letters 94(6), 253–257 (2005)

20. Vardi, M.Y.: The complexity of relational query languages. In: STOC, pp. 137–146 (1982)

