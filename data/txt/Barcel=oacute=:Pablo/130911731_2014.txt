SIAM J. COMPUT.
Vol. 43, No. 3, pp. 1085–1130

c(cid:2) 2014 Society for Industrial and Applied Mathematics

∗
EFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

PABLO BARCEL ´O

†

, LEONID LIBKIN

‡

, AND MIGUEL ROMERO

†

Abstract. When ﬁnding exact answers to a query over a large database is infeasible, it is natural
to approximate the query by a more eﬃcient one that comes from a class with good bounds on the
complexity of query evaluation. In this paper we study such approximations for conjunctive queries.
These queries are of special importance in databases, and we have a very good understanding of the
classes that admit fast query evaluation, such as acyclic, or bounded (hyper)treewidth queries. We
deﬁne approximations of a given query Q as queries from one of those classes that disagree with Q as
little as possible. We concentrate on approximations that are guaranteed to return correct answers.
We prove that for the above classes of tractable conjunctive queries, approximations always exist and
are at most polynomial in the size of the original query. This follows from general results we establish
that relate closure properties of classes of conjunctive queries to the existence of approximations. We
also show that in many cases the size of approximations is bounded by the size of the query they
approximate. We establish a number of results showing how combinatorial properties of queries aﬀect
properties of their approximations, study bounds on the number of approximations, as well as the
complexity of ﬁnding and identifying approximations. The technical toolkit of the paper comes from
the theory of graph homomorphisms, as we mainly work with tableaux of queries and characterize
approximations via preorders based on the existence of homomorphisms. In particular, most of our
results can also be interpreted as approximation or complexity results for directed graphs.

Key words. conjunctive queries, approximation, graphs, homomorphisms, hypergraphs

AMS subject classiﬁcations. 68P15, 05C60, 05C65, 68Q17

DOI. 10.1137/130911731

1. Introduction. The idea of ﬁnding approximate solutions to problems for
which computing exact solutions is impossible or infeasible is ubiquitous in computer
science. It is common in databases too: approximate query answering techniques help
evaluate queries over extremely large databases or queries with very high inherent
complexity; see, e.g., [14, 15, 18, 28, 33]. By analyzing the structure of both the
database and the query one often ﬁnds a reasonable approximation of the answer,
sometimes with performance guarantees. Approximate techniques are relevant even
for problems whose complexity is viewed as acceptable for regular-size databases, since
ﬁnding precise answers may become impossible for the large data sets we often deal
with these days.

To approximate a query, we must have a good understanding of the complexity of
query evaluation in order to ﬁnd an approximation that is guaranteed to be eﬃcient.
For one very common class of queries—conjunctive, or select-project-join queries—we
do have a very good understanding of their complexity. In fact, we know which classes
of conjunctive queries (CQs) are easy to evaluate [11, 19, 20, 23, 29, 41]. Given the
importance of CQs, and our good understanding of them, we would like to initiate a

∗

Received by the editors March 4, 2013; accepted for publication (in revised form) February 20,
2014; published electronically May 13, 2014. Partial support provided by Fondecyt grant 1130104,
EPSRC grants G049165 and F028288, and FET-Open Project FoX, grant agreement 233599. Part
of this work was done while the ﬁrst and the third authors visited Edinburgh and the second author
visited Santiago.

†

http://www.siam.org/journals/sicomp/43-3/91173.html
Department of Computer Science, Universidad de Chile, Santiago, Chile (pbarcelo@dcc.uchile.cl,

miromero@ing.uchile.cl).

‡

School of Informatics, University of Edinburgh, Edinburgh, EH8 9AB, Scotland (libkin@inf.ed.

ac.uk).

1085

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1086

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

(cid:4)

study of their approximations. We do it from the static analysis point of view, i.e.,
independently of the input database: for a query Q, we want to ﬁnd another query
that will be much faster than Q, and whose output would be close to the output
Q
of Q on all databases. Such analysis is essential when a query is repeatedly evaluated
on a very large database (say, in response to frequent updates), and when producing
approximations based on both data and queries may be infeasible.
The complexity of checking whether a tuple ¯a belongs to the output of a CQ Q
on a database D is of the order |D|O(|Q|), where | · | measures the size of a database
or a query [3, 39]. In fact, the problem is known to be NP-complete, when its input
consists of D as well as Q (even for Boolean CQs).
In other words, the combined
complexity of CQs is intractable [10]. Of course the data complexity of CQs is low
(more precisely, it belongs to the circuit complexity class AC0), but having O(|Q|)

as the exponent may be prohibitively high for very large data sets. This observation
led to an extensive study of classes of CQs for which the combined complexity is
tractable. The ﬁrst result of this kind by Yannakakis [41] showed tractability for
acyclic CQs. That was later extended to queries of bounded treewidth [11, 16, 29];
this notion captures tractability for classes of CQs deﬁned in terms of their graphs [23].
For classes of CQs deﬁned in terms of their hypergraphs, the corresponding notions
guaranteeing tractability are bounded hypertree width [20] and bounded generalized
hypertree width [21], which include acyclicity as a special case. All these conditions
can be tested in polynomial time [8, 17, 20], except for bounded generalized hypertree
width [22].

The question we address is whether we can approximate a CQ Q by a CQ Q

one of such classes so that Q and Q
example, that we manage to ﬁnd an approximation of Q by an acyclic CQ Q
which checking whether ¯a ∈ Q
the original problem of complexity |D|O(|Q|) with that of complexity

from
would disagree as little as possible. Assume, for
, for
(cid:4)|) [41]. Then we replaced

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(D) is done in time O(|D|·|Q
(cid:2)
(cid:3)
f (|Q|) + |D| · s(|Q|)

,

O

where s(·) measures the size of the resulting approximation, and f (·) is the complexity
of ﬁnding one.

(cid:4)

Thus, assuming that the complexity measures f and s are acceptable, the combined 
complexity of running Q
is much better than for Q. Hence, if the quality of
(cid:4)
the approximation Q is good too, then we may prefer to run the much faster query Q
instead of Q, especially in the case of very large databases. Thus, we need to answer
the following questions:
• What are the acceptable bounds for constructing approximations, i.e., the
• What types of guarantees do we expect from approximations?

functions f and s above?

is of the same size as Q, or even if it polynomially increases
For the ﬁrst question, if Q
the size, this is completely acceptable, as the exponent O(|Q|) is now replaced by the
factor s(|Q|). For the complexity f of static computation (i.e., transforming Q to Q
(cid:4)
),
a single exponential is typically acceptable. Indeed, this is the norm in many static
analysis and veriﬁcation questions [34, 37], and modest exponential functions (like the
2O(|Q|) or 2O(|Q| log |Q|) we shall mainly encounter) are signiﬁcantly smaller than |D||Q|
if |D| is large. Thus, in terms of their complexity, our desiderata for approximations
are as follows:

(cid:4)

1. the approximating query should be at most polynomially larger than Q—and

ideally, bounded by the size of Q; and

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1087

2. the complexity of ﬁnding an approximating query should not exceed singleexponential.


As for the guarantees we expect from approximations, in general they can be
formulated in two diﬀerent ways. By doing it qualitatively we state that an approximation 
is a query that cannot be improved in terms of how much it disagrees with
the query it approximates. Alternatively, to do it quantitatively, we deﬁne a measure
of disagreement between two queries and look for approximations whose measure of
disagreement with the query they approximate is below a certain threshold.
Here we develop the qualitative approach to approximating CQs. For a given Q,
we compare queries from some good (tractable) class C by how much they disagree
with Q: to do so, we deﬁne an ordering Q1 (cid:3)Q Q2 saying, intuitively, that Q2 disagrees
with Q less often than Q1 does. Then the best queries with respect to the ordering
are our approximations from the class C.

Furthermore, we require the approximations to return correct results. This is
standard in databases; for instance, the standard approximation of query results in
the settings of query answering using views and data integration is the notion of
maximally contained rewriting [2, 24, 31].

Our goal is to explore approximations of arbitrary CQs by tractable CQs. We
shall see that approximations are guaranteed to exist for all the tractable classes of
CQs mentioned earlier, which makes the notion worth studying.

The structure of approximations depends heavily on combinatorial properties of
the (tableau of the) query Q we approximate. Consider, for instance, a Boolean
query Q1() :– E(x, y), E(y, z), E(z, x) over graphs. Its best acyclic approximation is
(cid:4)
1() :– E(x, x), which is contained in every Boolean graph query and thus provides
Q
us with little information. It turns out that this will be the case whenever the tableau
of the query is not bipartite. Let Pm(x0, . . . , xm) be the CQ stating that x0, . . . , xm
form a path of length m, i.e., E(x0, x1), . . . , E(xm−1, xm). If we now look at

(cid:4)
Q2() :– P3(x, y, z, u), P3(x

(cid:4)

(cid:4)

, z

, u

(cid:4)

), E(x, z

(cid:4)

), E(y, u

(cid:4)

),

which has a cycle with variables x, y, z
mation

(cid:4)

, u

, y
(cid:4)

, then it has a nontrivial acyclic approxi-

(cid:4)
(cid:4)
2() :– P4(x

Q

, x, y, z, u).

What changed is that the tableau of Q2 is bipartite, which guarantees the existence
of nontrivial approximations.

Going beyond graph vocabularies allows us to ﬁnd more approximations. Consider 
again Q1 above, replace binary relation E with a ternary relation R, and introduce 
fresh variables in the middle positions, i.e., look at the query Q() :– R(x, u, y),
R(y, v, z), R(z, w, x). This query does have several nontrivial acyclic approximations:
for instance, Q

() :– R(x, u, y), R(y, v, u), R(u, w, x) is one.

(cid:4)

These examples provides a ﬂavor of the results we establish. We now provide
a quick summary of the results of the paper. Recall that there are two ways of
getting tractable classes of CQs over arbitrary vocabularies, depending on whether
one formulates conditions in terms of the graph of a query Q or its hypergraph. We
ﬁrst study approximations in tractable classes of CQs deﬁned in terms of its graph,
and then in those deﬁned in terms of its hypergraph.

Results for classes of CQs in terms of its graph. For a query Q, we are
from a good class C deﬁned in terms of its underlying

interested in approximations Q

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1088

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

Summary of results on approximations for conjunctive queries Q.

Table 1

Class of
queries

CQs in terms of
underlying graph
CQs in terms of

underlying hypergraph Hypertree width k

Type of

Existence of

Size of

Time to compute

approximation

approximation

approximation

approximation

Treewidth 1
Treewidth k

Acyclic

always
exists

at most

|Q|

polynomial

in |Q|

singleexponential


in |Q|

graph. The classes we consider are queries of bounded treewidth k, which capture the
notion of tractability of CQs in the case of graph-based classes [23]. The ﬁrst two rows
in Table 1 summarize some of our results: approximations exist for all queries (this
will follow from a general existence result that relates closure properties of classes of
graphs to the existence of approximations), they do not increase the complexity of
the query, and they can be constructed in single-exponential time (Corollaries 4.2 and
4.3), thus satisfying all our desiderata for approximating queries.

We also show that there are at most exponentially many nonequivalent approximations 
of treewidth k for a CQ Q, and that the exponential number of approximations 
can be witnessed even for CQs over graphs (Proposition 4.4).

We then provide further complexity analysis, showing that if the problem of
computing a treewidth-k approximation can be solved in polynomial time, then P =
NP (Proposition 4.11). We also study the decision problem of checking whether Q
is
a treewidth-k approximation of Q. We show that this problem is complete for the class
DP (this class, deﬁned formally later, is “slightly” above both NP and coNP [36]),
and that DP-hardness holds even for treewidth 1 and queries over graphs (Theorem
4.12). DP-completeness results appeared in the database literature in connection with
computing cores of structures [13]; our result is of a diﬀerent nature because it holds
even when both Q and Q

are minimized (i.e., their tableaux are cores).

(cid:4)

(cid:4)

Finally, in section 5, we study the structure of approximations over graphs. We
show a close relationship between (k + 1)-colorability of the tableau and the existence
of interesting treewidth-k approximations. For Boolean queries, we prove a ﬁner trichotomy 
result for acyclic approximations (recall that for CQs over graphs, acyclicity
and treewidth-1 coincide), which also shows that such approximations are guaranteed
to reduce the number of joins.

Results for classes of CQs in terms of its hypergraph. For hypergraphbased 
notions, we have the original notion of acyclicity from [41] and its more recent
extensions to the notions of bounded hypertree width [20] and bounded generalized
hypertree width [21]. It is known that hypertree width 1 coincides with acyclicity,
and that both are contained in generalized hypertree width 1. We again prove a
general existence result for approximations. However, the closure conditions imposed
on classes of hypergraphs are becoming more involved, and it actually requires an
eﬀort to prove that they hold for classes of bounded hypertree width. We show that
it is still possible to ﬁnd approximations in single exponential time. As for their sizes,
they need not be bounded by |Q|, but they remain polynomial in |Q|, with polynomial
depending only on the vocabulary (Corollary 6.5). Thus, as the summary table in
Table 1 shows, in this case too, our desiderata for approximations are met.

Regarding techniques required to prove these results, we mainly work with
tableaux of queries and characterize approximations via preorders based on the exisCopyright 
© by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1089

tence of homomorphisms. Thus, we make a heavy use of techniques from the theory
of graphs and homomorphisms [25]. In particular we heavily use the notion of core:
a graph G that cannot be homomorphically mapped into a proper subgraph. Besides
graph theory and combinatorics, techniques from graph homomorphisms are commonly 
used in constraint satisfaction [30], but recently they were applied in database
theory as well [9, 13, 32].

Many of our results therefore can be interpreted as results about directed graphs
(digraphs) and their homomorphisms. We say that an acyclic digraph T is an acyclic
approximation of a digraph G if there is a homomorphism from G to T , but whenever
this homomorphism goes via another acyclic digraph T
(i.e., we have homomorphisms
(cid:4)
from G to T
.
Our results then imply the following, which might be of independent interest in graph

to T ), then there is also a homomorphism from T to T

and from T

(cid:4)

(cid:4)

(cid:4)

theory:• Every digraph G has an acyclic approximation.

phic cores of acyclic approximations.

G (hence there could be at most exponentially many of those).

• The size of the core of an acyclic approximation does not exceed the size of
• There are examples of digraphs witnessing exponential number of nonisomor-
• Testing whether T is an acyclic approximation of G is DP-complete (even if
• In fact, even checking for the existence of an exact homomorphism from G to
T (i.e., such that there is no homomorphism from G to a proper subgraph of
T ) is DP-complete.

both T and G are cores).

Organization. Basic notation is given in section 2. In section 3 we deﬁne the
notion of approximations. Section 4 studies approximations in graph-based classes of
queries, concentrating on bounded treewidth CQs. Section 5 concentrates on queries
on graphs and studies important structural properties of approximations in such scenarios.
 In section 6 we look at approximations in hypergraph-based classes of queries,
concentrating on acyclic and bounded (generalized) hypertree width CQs. Conclusions 
are in section 7. This paper is a full version based on two conference papers [6]
and [7].

2. Notation.

Graphs and digraphs. Both graphs and digraphs are deﬁned as pairs G =
(cid:4)V, E(cid:5), where V is a set of nodes (nodes) and E is a set of edges. For graphs, an edge
is a set {u, v}, where u, v ∈ V ; for digraphs, an edge is a pair (u, v); i.e., it has an
orientation from u to v. If u = v, we have a (undirected or directed) loop.
If G = (cid:4)V, E(cid:5) is a directed graph, then Gu is the underlying undirected graph:
Gu = (cid:4)V,{{u, v} | (u, v) ∈ E}(cid:5). We denote by Km the complete graph on m nodes,
Km = (cid:4){u1, . . . , um},{{ui, uj} | i (cid:6)= j, i, j ≤ m}(cid:5), and by K
(cid:2)
m the complete digraph
m = (cid:4){u1, . . . , um},{(ui, uj) | i (cid:6)= j, i, j ≤ m}(cid:5), so that edges go
(cid:2)

on m nodes, i.e., K
in both directions. Note that (K

(cid:2)
m )u = Km.

Databases (relational structures). A vocabulary (often called a schema in the
database context) is a set σ of relation names R1, . . . , Rl, each relation Ri having an
(cid:5),
arity ni. A relational structure, or a database, of vocabulary σ is D = (cid:4)U, R
D
is an ni-ary relation over U , i.e., a subset of U ni.
where U is a ﬁnite set, and each R
D
i
We usually omit the superscript
if it is clear from the context. We also assume (as
is normal in database theory) that U is the active domain of D, i.e., the set of all
elements that occur in relations R

D
D
1 , . . . , R
l

D
i ’s.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1090

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

Both directed and undirected graphs, for example, are relational structures of
the vocabulary that contains a single binary relation E. For digraphs, it is the edge
relation; for graphs, it contains pairs (u, v) and (v, u) for each edge {u, v}. We usually
do not distinguish between a (di)graph and the structure that it represents it.
We often deal with databases together with a tuple of distinguished elements,
i.e., (D, ¯a), where ¯a is a k-tuple of elements of the active domain for some k > 0.
Technically, these are structures of vocabulary σ expanded with k extra constant
symbols, interpreted as ¯a.

D1
i

D1
i

The database D1 is contained in D2 if R

Homomorphisms and cores. Given databases D1 = (cid:4)U1, (R

)i≤l(cid:5) and D2 =
)i≤l(cid:5), a homomorphism h : D1 → D2 is a map from U1 to U2 so that
(cid:4)U2, (R
D2
for every ni-ary tuple ¯t ∈ R
for all i ≤ l. The image of h is the
h(¯t) ∈ R
D1
D2
i
} for each i ≤ l. If
i)i≤l(cid:5), where R
i = {h(¯t) | ¯t ∈ R
structure Im(h) = (cid:4)h(U1), (R
i
i
(cid:4)
(cid:4)
h−→ D2. For
there is a homomorphism h from D1 to D2, we write D1 → D2 or D1
databases with tuples of distinguished elements we have (D1, ¯a1) → (D2, ¯a2) if the
homomorphism h in addition satisﬁes h(¯a1) = ¯a2.
for each i ≤ (cid:3). It is strictly
⊂ R
for some i ≤ (cid:3). A database D is a core if there is no
D2
D1
contained if R
homomorphism D → D(cid:4)
into a database D(cid:4)
that is strictly contained in D. A database
i
i
D(cid:4)
. It is well
known that all cores of a database are isomorphic [25], and hence we can speak of
the core of a database D, denoted by core(D). We say that two databases D and D(cid:4)
are homomorphically equivalent if both D → D(cid:4)
and D(cid:4) → D hold. Homomorphically
equivalent databases have the same core; i.e., core(D) and core(D(cid:4)
) are isomorphic.
D and D(cid:4)

that is strictly contained in D is a core of D if D(cid:4)

, but D(cid:4) → D does not hold. (i.e., when D → D(cid:4)

is a core and D → D(cid:4)

are not homomorphically equivalent).

We write D (cid:2)(cid:2) D(cid:4)

if D → D(cid:4)

⊆ R

D2
i

D1
i

but

Conjunctive queries and tableaux. A conjunctive query (CQ) over a rela-
(cid:4)
tional vocabulary σ is a logical formula in the ∃,∧-fragment of ﬁrst-order logic, i.e.,
a formula of the form Q(¯x) = ∃¯y
m
j=1 Rij (¯xij ), where each Rij is a symbol from σ,
and ¯xij a tuple of variables among ¯x, ¯y whose length is the arity of Rij . These are
often written in a rule-based notation,

Q(¯x) :– Ri1 (¯xi1 ), . . . , Rim (¯xim ).

, written as Q ⊆ Q
(cid:4)
are equivalent, denoted by Q ≡ Q
(cid:4)

(1)
The number of joins in the CQ (1) is m − 1. Given a database D, the answer Q(D)
to Q is {¯a | D |= Q(¯a)}. If Q is a Boolean query (a sentence), the answer true is, as
usual, modeled by the set containing the empty tuple, and the answer false by the
empty set.
(D) for every
(cid:4)
A CQ Q is contained in a CQ Q
(cid:4) ⊆ Q.
database D. As usual, we write Q ⊂ Q
(cid:4) ⊆ Q.
(cid:4)
The queries Q and Q
With each CQ Q(¯x) of the form (1) we associate its tableau (TQ, ¯x), where TQ is
the body of Q viewed as a σ-database; i.e., it contains tuples ¯xij ’s in relations Rij ’s
for j ≤ m. If Q is a Boolean CQ, then its tableau is just the σ-structure TQ.
For example, ¯a ∈ Q(D) iﬀ (TQ, ¯x) → (D, ¯a). For CQs Q(¯x) and Q
same number of free variables, Q ⊆ Q
) → (TQ, ¯x). Hence, the combined
complexity of CQ evaluation and the complexity of CQ containment are in NP (in
fact, both are NP-complete [10]).

Many key properties of CQs can be stated in terms of homomorphisms of tableaux.
) with the

, if Q(D) ⊆ Q
, if both Q ⊆ Q

but it is not the case that Q
and Q

(cid:4)
iﬀ (TQ(cid:2), ¯x

if Q ⊆ Q

(cid:4)
(¯x

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1091

Q

Q1

Q2 Q3
C

C-approximations
a query view

C
TQ1 TQ2

TQ3

TQ

C-approximations
a tableau view

Fig. 1. C-approximations: an illustration.

3. The notion of approximation. We now explain the main idea of approximations.
 Suppose C is a class of conjunctive queries (e.g., acyclic, or of bounded
(hyper)treewidth). We are given a query Q not in this class, and we want to approximate 
it within C. As explained earlier, we are interested in queries that are guaranteed
to return correct results only. Thus, we are looking for a CQ in C that is maximally
contained in Q.
Definition 3.1 (approximations). Given a class C of CQs and a query Q, a
(cid:4) ⊆ Q is a C-approximation of Q if there is no Q
(cid:4)(cid:4) ∈ C such
is an approximation of Q in C if it is guaranteed to return
. It can be
(cid:4)(cid:4) ∈ C
does [6]. The latter means that for every database D

query Q
that Q
correct results and no other query in C approximates Q better than Q
equivalently proved that Q
“agrees” with Q more than Q
and tuple ¯a of elements of D, if ¯a ∈ Q(D) but ¯a /∈ Q

(cid:4) ⊆ Q and no query Q
(D).

is a C-approximation of Q if Q
(cid:4)

(cid:4) ∈ C such that Q
(cid:4) ⊂ Q
(cid:4)

(cid:4)(cid:4) ⊆ Q.

In other words, Q

(cid:4)

(cid:4)

(cid:4)

(D), then also ¯a /∈ Q

(cid:4)(cid:4)

Before describing the classes in which we shall try to approximate CQs, we present

a useful view of approximations via orderings on queries and tableaux.

Approximations via ordering. Both CQs and their tableaux come naturally 
equipped with two preorders: containment of CQs, and the existence of homomorphisms 
between tableaux. These preorders are dual to each other [10]:
Q ⊆ Q
symmetric (as we may have diﬀerent equivalent queries), hence they are preorders.
They become partial orders when restricted to cores, or minimized CQs. Indeed, if

(cid:4) ⇔ TQ(cid:2) → TQ. These relations are reﬂexive and transitive but not antiboth 
TQ(cid:2) → TQ and TQ → TQ(cid:2) hold, then TQ(cid:2) and TQ are homomorphically equivalent 
and thus have the same core (which happens to be the tableau of the minimized
version of Q). The preorder → and its restriction to cores have been actively studied
over graphs, digraphs, and relational structures [25], and we shall rely heavily on their
properties in our proofs.
With this view, we can visualize Deﬁnition 3.1 as shown in Figure 1. The Capproximations 
of Q are the “closest” elements of class C that are below Q in the
⊆ ordering. If we switch to the tableau view, then approximations are the closest
elements of C which are above the tableau of Q in the → ordering.

Good classes of queries. We look for approximations within tractable classes
of CQs, which include acyclic queries, as well as queries of bounded treewidth and
(generalized) hypertree width [11, 16, 20, 21, 23, 29, 41]. We now deﬁne the ﬁrst two
(hypertree width is deﬁned in section 6).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1092

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

We ﬁrst need the notion of tree decompositions of hypergraphs of queries. Recall
that a hypergraph H = (cid:4)V,E(cid:5) has a set of nodes V and a set of hyperedges E; each
hyperedge is a subset of V . For a CQ Q, its hypergraph H(Q) has all the variables
used in Q as nodes; the hyperedges are sets of variables that appear in the same atom.
For example, for the query with the body R(x, y, z), R(x, v, v), E(v, z), the hyperedges
are {x, y, z}, {x, v}, and {v, z}.
A tree decomposition of a hypergraph H = (cid:4)V,E(cid:5) is a tree T together with a map
f : T → 2V that associates a set of nodes in V with each node of T such that
1. each hyperedge from E is contained in one of the sets f (u) for u ∈ T ; and
2. for every v ∈ V , the set {u ∈ T | v ∈ f (u)} is a connected subset of T .

The width of a decomposition is maxu∈T |f (u)| − 1, and the treewidth of H is the
minimum width of its tree decompositions. If H is a tree (or a forest) to start with,
then its treewidth is 1. We refer to the classes of hypergraphs of treewidth at most k
as TW(k), and, slightly abusing notation, we use TW(k) to also denote the classes of
CQs (and their tableaux) whose hypergraphs have treewidth at most k.

A hypergraph is acyclic if there is a tree decomposition (T, f ) of it such that
every f (u) is a hyperedge. A CQ is acyclic if its hypergraph is acyclic. We use AC
to denote the class of acyclic hypergraphs (and also acyclic CQs and their tableaux).
For queries over graphs, we have AC = TW(1). In general the notions of bounded
treewidth and acyclicity are incompatible (see, e.g., [16]).

4. Graph-based approximations. We start by looking for approximations
within classes of CQs deﬁned in terms of its graph, which include queries of bounded
treewidth [11, 16, 23]. This condition fully characterizes tractability of CQ answering 
with respect to graph-based classes of queries [23] (under a certain complexitytheoretic 
assumption): given a class C, query answering for graph-based C-queries is
tractable iﬀ C ⊆ TW(k) for some k.

For the graph-based notions, one deals with the graph of query Q, denoted by
G(Q). The nodes of G(Q) are variables used in Q. If there is an atom R(x1, . . . , xn)
in Q, then G(Q) has undirected edges {xi, xj} for all 1 ≤ i < j ≤ n. We deﬁne classes
of queries in terms of classes C of graphs: a CQ Q is a graph-based C-query iﬀ G(Q)
is in C.
The standard tractable classes of treewidth-k CQs do arise in this way. Indeed,
TW(k) is the class of queries deﬁned by the class C of graphs that have treewidth
a graph-based Cat 
most k (when viewed as a hypergraph). We call a CQ Q
approximation of Q if it is an approximation of Q in the class of graph-based C-queries.
Several results from this section apply even for queries over graphs and treewidth
1 (e.g., size and complexity lower bounds). Recall that in such a context it is the case
that AC = TW(1), and hence those results apply as well for the hypergraph-based
notion of acyclicity.

(cid:4)

4.1. Existence of approximations. We prove a very general result on the
existence of approximations, which shows good behavior of those for many classes of
queries. For this, we shall need two mild conditions only: The class C of graphs is
closed under taking subgraphs, and there is at least one graph-based C-query that is
contained in the query Q that is being approximated.

Theorem 4.1.
1. Let C be a class of graphs closed under taking subgraphs. Then every CQ Q
that has at least one graph-based C-query contained in it also has a graph-based
C-approximation.
2. Moreover, the number of nonequivalent graph-based C-approximations of Q is

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpProof. Given a query Q(¯x), let H

C

EFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

(cid:4)
) for some h (thus h(¯x) = ¯x

1093
at most exponential in the size of Q, and every graph-based C-approximation
of Q is equivalent to one which has at most as many joins as Q.
(Q) be the set of all graph-based C-queries
whose tableaux are of the form (Im(h), h(¯x)), where h is a homomorphism deﬁned on
(TQ, ¯x). All such queries are contained in Q. Up to equivalence there are ﬁnitely many
(Q). Moreover, it is nonempty. Indeed, there is a graph-based C-query
C
elements in H
(cid:4) ⊆ Q and hence (TQ, ¯x) h−→ (T
Q
) with Q
). By
(cid:4)
the closure under subgraphs we know that (Im(h), ¯x
) is a tableau of a graph-based
C-query.
Now consider minimal elements, with respect to the preorder →, in the (tableaux
(Q). We claim that they are graph-based C-approximations of Q. Indeed let
of) set H
(cid:4)
(cid:4)
(Im(h0), ¯x
= h0(¯x). If it is not a graph-
) be the tableau of one such element, with ¯x
based C-approximation, then there exists a graph-based C-query, whose tableau is
g−→ (T, ¯x
g1−→ (Im(h0), ¯x
(cid:4)(cid:4)
(cid:4)(cid:4)
(cid:4)
) for some homomorphisms g
(T, ¯x
)
g1−→
) (cid:6)→ (T, ¯x
g−→ (Im(g), ¯x
(cid:4)
(cid:4)(cid:4)
(cid:4)(cid:4)
and g1 such that (Im(h0), ¯x
). Hence we have (TQ, ¯x)
)
(cid:4)(cid:4)
(cid:4)
), and (Im(g), ¯x
(Im(h0), ¯x
) is the tableau of a
graph-based C-query since C is closed under taking subgraphs. Hence, (Im(g), ¯x
(cid:4)(cid:4)
) is
the tableau of a CQ in H
), which contradicts the
(cid:4)
minimality of (Im(h0), ¯x
).
) and thus
(TQ, ¯x) h−→ (Im(h), ¯x
(cid:4)
) the
tableau of a graph-based C-query.
(cid:4)
) and (TQ(cid:2), ¯x
) are ho-
) is a graph-based C-
(cid:4)
momorphically equivalent, and the CQ with tableau (Im(h), ¯x
. Hence, all graph-based C-approximations can be
approximation equivalent to Q
(cid:4)
chosen to have a tableau of the form (Im(h), ¯x
), which shows that there are at most
exponentially many of them, and that they need not have more joins than Q.

) is a graph-based C-approximation, then (TQ, ¯x) h−→ (TQ(cid:2) , ¯x
(cid:4)

(cid:4)
), with Im(h) being a substructure of TQ(cid:2) , and (Im(h), ¯x

) (cid:6)→ (Im(g), ¯x
(cid:4)(cid:4)
(cid:4)(cid:4)
(Q) and (Im(g), ¯x

(cid:4)
It follows that (Im(h), ¯x

(cid:4)
), as well as (Im(h0), ¯x

C

(cid:4)
) (cid:2)(cid:2) (Im(h0), ¯x

), such that (TQ, ¯x)

(cid:4)

(cid:4)
(¯x

C

(cid:4)

(cid:4)
(¯x

If Q

(cid:4)
(cid:4)
Q, ¯x

(cid:4)

Approximations for treewidth-k queries. There is a trivial query that
belongs to all TW(k)’s that every other CQ Q contains.
let Qtrivial be
the query on a single variable x that is obtained by taking the conjunction of all
atoms of the form R(x, . . . , x) for R a relation symbol in the vocabulary. Then,
for each query Q(¯x) with m free variables, we have via a constant homomorphism

(TQ, ¯x) → (TQtrivial , (x, . . . , x)), and thus Qtrivial is contained in Q.

Indeed,

This, together with Theorem 4.1 and the closure of TW(k) under taking subgraphs,
 gives us the following.

Corollary 4.2. Every CQ Q has a TW(k)-approximation for each k > 0.
4.2. Size and number of approximations. Let C-APPR(Q) be the set of all
graph-based C-approximations of Q. For each k ≥ 1, this set is nonempty when C
is TW(k). It is also inﬁnite, but for a simple reason: each CQ has inﬁnitely many
equivalent CQs.

It is well known though [10] that each CQ Q(¯x) has a unique (up to renaming
in fact, this is the query whose tableau
It is obtained by the standard process of minimization of CQs.

of variables) equivalent minimal query:
is core(TQ, ¯x).
We thus denote by C-APPRmin(Q) the set of all minimizations of graph-based
C-approximations of Q.

From Corollary 4.2 and Theorem 4.1 we obtain the following.

Corollary 4.3. For every CQ Q and k ≥ 1, TW(k)-APPRmin(Q) is a ﬁnite

nonempty set of queries. The number of queries in those sets is at most exponential
in the size of Q, and each one has at most as many joins as Q. Moreover, a query

from TW(k)-APPRmin(Q) can be constructed in single-exponential time in |Q|.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1094

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

Hence, treewidth-k approximations fulﬁll the criteria from the introduction: they
always exist, they are not more complex than the original query, and they can be
found with reasonable complexity.

Note that the exponential bound in Corollary 4.3 is not due to the minimization
procedure, which actually happens to be polynomial for queries of ﬁxed treewidth.
In general, there is a simple algorithm for ﬁnding approximations that just checks
homomorphisms on TQ and selects one whose image is minimal with respect to → ;
it runs in time 2O(n·log n), where n is the number of variables in Q. We shall discuss
the complexity in more detail in subsection 4.3.
As for the number of elements of C-APPRmin(Q), a simple upper bound is 2n·log n

(a better bound is the nth Bell number [4]). This raises the question of whether the
exponential number of approximating queries can be witnessed. We prove that this
is the case even for queries over graphs and treewidth 1.

Proposition 4.4. There is a family (Qn)n>0 of Boolean CQs over graphs
such that the number of variables and joins in Qn’s grows linearly with n, and
|TW(1)-APPRmin(Qn)| ≥ 2n for all n > 0.

Proof. We need some deﬁnitions and results from [25]. An oriented path P =
(u0, . . . , un) is a digraph with nodes u0, . . . , un and n edges such that either (ui, ui+1)
or (ui+1, ui) is an edge for each 0 ≤ i < n. We shall refer to edges (ui, ui+1) as forward
edges and to edges (ui+1, ui) as backward edges. The node u0 is the initial node of
the oriented path and un the terminal one. Typically, we depict an oriented path P
as an edge uv labeled with P , representing that the initial node of P is u and the
terminal node is v. An oriented cycle is an oriented path whose initial and terminal
nodes coincide.
We deﬁne the net length of P to be the number of forward edges minus the number
of backward edges of P . Often we write oriented paths as strings in {0, 1}∗
, where 0
represents a forward edge and 1 represents a backward edge. For example, P = 001
means that P is the oriented path with two forward edges followed by a backward edge.
A digraph G is balanced if each one of its oriented cycles has net length 0, that is,
the number of forward edges equals the number of backward edges. For a balanced
digraph G and a node v in G, we deﬁne the level of v to be

max{net length of P | P is an oriented path in G with terminal node v}.
It can be proved that the level of v is ﬁnite since G is balanced [25]. We deﬁne

the height of G, denoted hg(G), to be the maximum level of a node in G.

The following is an important lemma from [25].
Lemma 4.5. Let G and H be two balanced digraphs of the same height. Then

any homomorphism from G to H preserves the levels of nodes.

We now prove Proposition 4.4. Consider the oriented paths P1 = 001000 and
P2 = 000100. It is straightforward to check that P1 and P2 are incomparable cores
(i.e., P1 (cid:6)→ P2 and P2 (cid:6)→ P1). We deﬁne the digraph D as follows: Consider the
digraph (cid:4)V, E(cid:5) such that V = {a, b, c, d} and E = {(a, b), (a, d), (c, b), (c, d)}. Add
disjoint copies of P1 and P2 and identify the initial node of the copy of P1 and P2,
with b and d, respectively. Then add two new disjoint copies of P1 and P2, and identify
the terminal node of the copy of P1 and P2 with a and c, respectively. The resulting
digraph D is depicted in Figure 2.

We also deﬁne Dac and Dbd as the digraphs obtained from D by identifying a
with c, and b with d, respectively. This is shown in Figure 3. Note that both Dac and
Dbd are balanced, and have height 9.

Claim 4.6. Dac and Dbd are incomparable cores.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1095

P1

a

c

P2

b

d

P1

P2

Fig. 2. The digraph D.

x2

b

x1
0

P1 e
4
d

x4

9

P1
5

5
P2

9

y2

9

P2

x3
0

y1
0

P1

a

4

e

5

P1

P2

c

4

P2

y3
0

y4

9

Fig. 3. Dac and Dbd, and some of its levels.

Proof. We ﬁrst prove that Dac is a core. Assume otherwise. Then Dac

h−→ Dac,
where h is not surjective. Since Dac is balanced, Lemma 4.5 tells us that h preserves
levels. Figure 3 shows the diﬀerent levels. Observe that the only node in Dac with
level 4 is e, thus h(e) = e. Note also that h(x1) is either x1 or x3. But h(x1) = x3
implies P1 → P2, which is impossible. It follows that h(x1) = x1. Similarly, we have
h(x3) = x3. Using the same argument, we have h(b) = b; otherwise h(b) = d and
P1 → P2. Similarly, h(d) = d. Finally, we must have h(x2) = x2 and h(x4) = x4. It
follows that h is surjective, which is a contradiction. Analogously, we have that Dbd
is a core.

We prove next that Dac and Dbd are incomparable. Assume otherwise. Suppose
h−→ Dbd. Observe that h preserves levels, since Dac and Dbd have the
ﬁrst that Dac
same height. It follows that h(e) is either a or c. If h(e) = a, then h(x3) = y1. It
follows that P2 → P1. Similarly, if h(e) = c, it follows that P1 → P2. In any case,
we have a contradiction with the fact that P1 and P2 are incomparable. The case
Dbd (cid:6)→ Dac is analogous.
For n ≥ 1, we deﬁne Gn to be the digraph constructed as follows: Take the union
of n disjoint copies of the digraph D. For each 1 ≤ i < n, add an edge from the
terminal node of the copy of P2 which starts in d in the ith copy of D to the initial
node of the copy of P1 which ends in a in the (i + 1)th copy of D. Figure 4 shows a
graphical depiction of G3.
n to be the digraph obtained
from Gn by identifying in the ith copy of D, 1 ≤ i ≤ n, the nodes a and c if si = V

Consider a string s ∈ {V, H}n for n ≥ 1. We deﬁne Gs

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1096

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

9
P1

5

19

P1

15

29

P1
25

P1

P2

P1

P2

P1

P2

0

4

4

0

10

14

14

10

20

24

24

20

5
P2

9

15
P2

19

25
P2

29

Fig. 4. The digraph G3 and some of its levels.

(that is, turning the ith copy of D in Gn into Dac) and b and d if si = H (that is,
turning the ith copy of D in Gn into Dbd).

(cid:4) ∈ {V, H}n for n ≥ 1 and assume that s (cid:6)= s

(cid:4)

. Then Gs

Claim 4.7. Let s, s

h−→ Gs

Proof. We ﬁrst prove that Gs

(cid:2)
Gs
n are incomparable cores.

n and
n is a core for each s ∈ {V, H}n. Assume otherwise.
Then Gs
n is balanced and no two
n
nodes in diﬀerent copies of Dac or Dbd in Gs
n can share a level, as shown in Figure
4. It follows from Lemma 4.5 that h maps the ith copy of Dac or Dbd in Gs
n to itself.
Thus, h is surjective in such a copy (because from Claim 4.6 both Dac and Dbd are
cores), and, therefore, h itself is surjective. This is a contradiction.

n, where h is not surjective. Observe that Gs

(cid:2)
n . Since Gs

Now, assume that Gs
n

(cid:2)
n and Gs
n have the same height, we have
from Lemma 4.5 that h preserves levels. Again, we have that h maps the ith copy
(cid:2)
n to the ith copy of Dac or Dbd in Gs
of Dac or Dbd in Gs
n , respectively. Since there
exists 1 ≤ j ≤ n such that the jth components of s and s
(cid:4)
are diﬀerent, we have that
h maps Dac to Dbd, or vice versa. This contradicts Claim 4.6, which states that Dac
and Dbd are incomparable.

h−→ Gs

We state a claim about databases that will be useful in this proof and in other
Claim 4.8. Let D and D(cid:4)
be two databases over the same schema. If D h−→ D(cid:4)
is the database obtained

proofs as well.
and h(a) = h(b) for a and b in D, then D∗ → D(cid:4)
from D by identifying a and b with a new element c.

, where D∗

n

n has treewidth 1.

the CQ whose tableau is Gs

n. Observe that each Qs

Proof. Just map c to h(a) = h(b) and all other elements to themselves.

Claim 4.9. Qs
Proof. By contradiction, suppose that there exists a CQ Q
h−→ TQ(cid:2)(cid:2) (cid:2)(cid:2) Gs

For each n ≥ 1 and s ∈ {V, H}n, let Qn be the CQ whose tableau is Gn and Qs
n is a TW(1)-approximation of Qn for each n ≥ 1 and s ∈ {V, H}n.
(cid:4)(cid:4) ∈ TW(1) such that
Gn
n. Consider the ith copy of D in Gn. If we restrict h to such a
copy, it must be the case that h(a) = h(c) or h(b) = h(d). Otherwise h(a), h(b),
h(c), and h(d) forms an oriented cycle in TQ(cid:2)(cid:2). With each i such that 1 ≤ i ≤ n we
associate a label ti ∈ {V, H} in the following way: If the restriction of h to the ith
copy of D in Gn satisﬁes h(a) = h(c), then ti = V ; otherwise ti = H. We then deﬁne
a word t in {V, H}n as t1t2 . . . tn. Using Claim 4.8 we have that Gt
→ TQ(cid:2)(cid:2), and, by
→ TQ(cid:2)(cid:2) , which
n
composition, Gt
n. Using Claim 4.7 we have t = s, and then Gs
n
n
is a contradiction.
We conclude the proof of the proposition now. Observe that for each n ≥ 1 and
s ∈ {V, H}n it is the case that Qs
n is a core).

∈ TW(1)-APPRmin(Qn) (because Gs

→ Gs

n

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1097

Therefore, |TW(1)-APPRmin(Qn)| ≥ 2n for all n ≥ 1. Furthermore, observe that the
number of variables in Qn is 28n and the number of joins is the number of edges in
Gn minus 1, that is, 29n − 2. Therefore, the family (Qn)n≥0 satisﬁes the required

conditions.

Reinterpretation of results for graphs. Let G be an arbitrary digraph and
T an acyclic digraph. We say that T is an acyclic approximation of G if G → T and
there is no acyclic T

such that G → T

(cid:4) (cid:2)(cid:2) T .

and T

(cid:4)

(cid:4)

Then our results imply the following.
Corollary 4.10.
• Every digraph G has an acyclic approximation.
• The number of nonisomorphic cores of acyclic approximations of G is at most
2n·log n, where n is the number of vertices of G.
• There exists a family Gn, n > 0, of cyclic digraphs so that the number of
edges and vertices in Gn’s grows linearly with n, and each Gn has at least 2n
nonisomorphic cores of acyclic approximations.

4.3. Complexity of computation and identiﬁcation. We have seen that a
(minimized) treewidth-k approximation can be found in single-exponential time. Of
course this is expected given NP-hardness of most static analysis tasks related to
CQs.
It is also in accordance with the following proposition, which states that if
treewidth-k approximations could be computed in polynomial time, then P = NP.
Proposition 4.11. Assume there exists a polynomial time algorithm that, given
a CQ Q, computes a TW(k)-approximation of Q for a ﬁxed k ≥ 1. Then P = NP.
Proof. For each ﬁxed k ≥ 1, the following problem is NP-complete [12]: Given a
Boolean CQ Q over graphs, check if Q is equivalent to a CQ in TW(k). We prove next
that, for each ﬁxed k ≥ 1, this problem can be decided in polynomial time if we assume
the existence of a polynomial time algorithm A that computes TW(k)-approximations
for CQs over graphs.
Let A(Q) be the output of A on input a CQ Q. We claim that Q ⊆ A(Q) iﬀ Q
). Assume ﬁrst that Q ≡ Q
is equivalent to a CQ Q
for some
(cid:4) ∈ TW(k). Since A(Q) is a TW(k)-approximation of Q (and, thus, of Q
(cid:4)
Q
), it is the
case that A(Q) ⊆ Q
(cid:4) ≡ A(Q). It follows that Q ⊆ A(Q), which
was to be proved. On the other hand, if Q ⊆ A(Q), then Q ≡ A(Q) (because A(Q)
is a TW(k)-approximation of Q, and hence it is contained in Q). We conclude that Q
is equivalent to a CQ Q
Since checking whether Q ⊆ A(Q) corresponds to evaluating the bounded treewidth 
query A(Q) in the tableau of Q, which can be done in polynomial time, we
conclude that the whole procedure can be done in polynomial time. This ﬁnishes the
proof of the proposition.

in TW(k) (i.e., Q ≡ Q

(cid:4) ⊆ Q, and hence Q

that belongs to TW(k).

(cid:4)

(cid:4)

(cid:4)

(cid:4)

To do a more detailed analysis of complexity for approximations, we study the

following associated decision problem:

Problem: Treewidth-k Approximation
Input:
Question:

a CQ Q, a treewidth-k CQ Q
Is Q

a treewidth-k approximation of Q?

(cid:4)

(cid:4)

.

To solve Treewidth-k Approximation, we need to check two things:

(cid:4) ⊆ Q; and
1. Q
2. there is no Q

(cid:4) ⊂ Q
The ﬁrst subproblem is solvable in NP. Checking whether there is a query
(cid:4)(cid:4) ⊆ Q is solvable in NP too. This means
(cid:4)(cid:4) ∈ TW(k) not equivalent to Q
Q

(cid:4)(cid:4) ∈ TW(k) such that Q
(cid:4) ⊆ Q

(cid:4)(cid:4) ⊆ Q.

with Q

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1098

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

(cid:4)(cid:4)

TQ → TQ(cid:2)(cid:2) (cid:2)(cid:2) TQ(cid:2) , and hence such Q
, if it exists, can always be chosen not to exceed
the size of Q. Therefore, one can guess TQ(cid:2)(cid:2) and all homomorphisms in NP. Further-
(cid:6)→ TQ(cid:2)(cid:2)
more, since both TQ(cid:2)(cid:2) and TQ(cid:2) have treewidth at most k, checking that TQ(cid:2)
can be done in polynomial time. Thus, the second subproblem is solvable in coNP.
Hence, to solve Treewidth-k Approximation, we need to solve an NP subproblem 
and a coNP subproblem. This means that the problem is in the complexity
class DP: this is the class of problems (languages) which are intersections of an NP
language and a coNP language [36]. It turns out that the problem is also hard for
the class, even when k = 1.

Theorem 4.12. The problem Treewidth-1 Approximation is DP-complete.
is ﬁxed, and both

are CQs over graphs, Q

(cid:4)

(cid:4)

It remains DP-complete even if Q and Q
Q and Q

(cid:4)

are Boolean and minimized (i.e., their tableaux are cores).

(cid:4)
= core(G), for two graphs G and G

DP-completeness appeared in database literature in connections with cores:
(cid:4)
, is known to be DP-complete
checking whether G
[13]. The source of DP-completeness in our case is completely diﬀerent, as hardness
applies even if the tableaux of queries are cores to start with, and the proof, which is
quite involved, uses techniques diﬀerent from those in [13]. We only sketch the main
ideas behind the proof here, since the complete proof is technical and lengthy. The
complete proof can be found in the appendix.

Proof (sketch) of Theorem 4.12. The class TW(1) over the vocabulary of graphs
i.e., the directed graphs whose underlying
It thus suﬃces to show that the following

contains all acyclic directed graphs,
undirected graph contains no cycles.
problem is DP-complete:

Problem: Graph Acyclic Approximation
Input:
a digraph G, an acyclic digraph T .
Is G → T, and is there no acyclic digraph A such that G → A (cid:2)(cid:2) T ?
Question:

In order to prove this, we consider the Exact Four Colorability problem:
Given a graph G, decide if G is 4-colorable but not 3-colorable. It is known that this
problem is DP-complete [38]. We provide a polynomial time reduction from Exact
Four Colorability to Graph Acyclic Approximation.

Using techniques from [26], we construct two digraphs T and ˜T . As Figure 5
shows, T consists of digraphs Z1, Z2, Z3, and Z4, whose only vertex in common is v.
Each of the distinguished vertices t1, t2, t3, and t4 represents a possible color. The
digraph ˜T has two distinguished vertices, p and q.

The key properties of T and ˜T are the following:
(1) If h : ˜T → T is an homomorphism, then h(p), h(q) ∈ {t1, t2, t3, t4} and

h(p) (cid:6)= h(q).
) of elements of {t1, t2, t3, t4} with t (cid:6)= t
homomorphism h : ˜T → T such that h(p) = t and h(q) = t
(cid:4)

(2) For any pair (t, t

(cid:4)

.

(3) If h : ˜T → T is an homomorphism and h(p) = ti or h(q) = ti for 1 ≤ i ≤ 4,

(cid:4)

, there exists a

(4) For any pair (t, t

then the subgraph Zi is contained in the homomorphic image of h.
homomorphism h : ˜T → T such that h(p) = t, h(q) = t
image of h is contained in Z1 ∪ Z2 ∪ Z3.

) of elements of {t1, t2, t3} with t (cid:6)= t

, there exists an
and the homomorphic

(cid:4)

(cid:4)

(cid:4)

Now, given a graph G we deﬁne ϕ(G) to be the digraph obtained from G by
replacing each edge {a, b} with a fresh copy of ˜T , where we identify p with a and
q with b. This is the ﬁrst step of our construction. Using properties (1)–(4) it is
straightforward to prove the following.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1099

Z4

Z3

t4

t3

t1

t2

v

Fig. 5. The structure of T .

Z1

Z2

Claim 4.13. G is 4-colorable but not 3-colorable iﬀ ϕ(G) → T and there is no
homomorphism from ϕ(G) to a proper subgraph of T .
Indeed, if G is 4-colorable, we can consider the set {t1, t2, t3, t4} to be the colors.
Using property (2) it follows that ϕ(G) → T . If there is a homomorphism h from ϕ(G)
∗ ∈ {t1, t2, t3, t4} such that h(a) (cid:6)= t
∗
to a proper subgraph of T , then there exists t
for all a ∈ G (notice that each vertex of G can be viewed as a vertex of ϕ(G));
otherwise, by property (3), h would be surjective. Therefore, since the image of h over
G contains at most 3 elements from {t1, t2, t3, t4}, using property (1) it follows that G
is 3-colorable. This proves the forward direction. For the backward direction, notice
that ϕ(G) → T implies that G is 4-colorable, again using property (1). Finally, if G
is 3-colorable, we can consider the set {t1, t2, t3} to be the colors. Using property (4),
deﬁne the standard homomorphism h from ϕ(G) → T . Observe that h is not surjective
as it is contained in Z1 ∪ Z2 ∪ Z3.

As a corollary we obtain that the following problem is also DP-complete:

Problem: Exact Acyclic Homomorphism
Input:
a digraph G, an acyclic digraph T .
Is G → T and G (cid:6)→ S for every proper subgraph S of T ?
Question:

At this point, ϕ(G) does not provide a reduction from Exact Four Colorability 
to Graph Acyclic Approximation:
It could be possible that there is no
homomorphism from ϕ(G) to a proper subgraph of T , but still there is an acyclic
digraph A such that ϕ(G) → A (cid:2)(cid:2) T . In other words, it is possible that the instance
(ϕ(G), T ) belongs to Exact Acyclic Homomorphism but not to Graph Acyclic
Approximation. We explain next how this problem can be avoided.
We modify ϕ(G) in order to have the following two properties: (†) (ϕ(G), T )
is still a reduction from Exact Four Colorability to Exact Acyclic Homomorphism,
 and (††) (ϕ(G), T ) ∈ Exact Acyclic Homomorphism iﬀ (ϕ(G), T ) ∈
Graph Acyclic Approximation. This immediately implies DP-completeness of
Graph Acyclic Approximation. Our modiﬁcation of ϕ(G) satisﬁes the following
property:

(P) Suppose that A is an acyclic digraph, h is an homomorphism from ϕ(G) to
A, g is a surjective homomorphism from A to T , and for each t ∈ {t1, t2, t3, t4} there
exists a vertex u of G such that g ◦ h(u) = t. Then there exists an homomorphism r
from T to A.
Observe that property (P) implies property (††): For the forward implication,

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpPABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

1100
assume that (ϕ(G), T ) ∈ Exact Acyclic Homomorphism and, by contradiction,
suppose that there exists an acyclic digraph A such that ϕ(G) → A (cid:2)(cid:2) T . Let h be
a homomorphism from ϕ(G) to A and g a homomorphism from A to T . Notice that
g must to be surjective; otherwise g ◦ h would be a homomorphism from ϕ(G) to a
proper subgraph of T . Moreover, it must be the case that for each t ∈ {t1, t2, t3, t4}
there exists a vertex u of G such that g ◦ h(u) = t. Assume otherwise. Then using
property (1) we can conclude that G is 3-colorable, and therefore that there exists a
homomorphism from ϕ(G) to a proper subgraph T (considering {t1, t2, t3} to be the
colors and then using property (4)). Thus, using property (P) it follows that T → A,
which is a contradiction. The backward direction is trivially true, as the existence of
a homomorphism h from ϕ(G) to a proper subgraph of T implies the existence of an
acyclic digraph A such that ϕ(G) → A (cid:2)(cid:2) T : it suﬃces to consider the homomorphic
image Im(h) of ϕ(G) in T . Notice that Im(h) is acyclic, ϕ(G) → Im(h) → T, and
T (cid:6)→ Im(h), since T is a core.

The idea of the construction is to consider a digraph Q

such that Z1, Z2, Z3,
and Z4 are acyclic approximations of Q
has an “initial vertex” x and
a “terminal vertex” y. Now, we add to ϕ(G) a fresh node v0, and for each vertex u in
ϕ(G) that corresponds to a vertex of G we add a fresh copy of Q
, identifying x with
v0 and y with u.

. Moreover, Q

∗

∗

∗

∗

∗

Using the structure of Q

it can be shown that ϕ(G) is still a reduction from
Exact Four Colorability, i.e., that satisﬁes property (a). Moreover, it can be
shown that it satisﬁes property (P). The intuition behind this is as follows: if A is an
acyclic digraph as in property (P), we can choose u1, u2, u3, and u4 from G such that
g◦h(ui) = ti for each 1 ≤ i ≤ 4. Each ui has an associated copy Q
. Each of the
∗
Q
i ’s must be mapped via h to an acyclic subgraph Ai of A. At the same time, each
Ai must be mapped via g to Zi. Thus, since Zi is actually an acyclic approximation
, there exists a homomorphism ri from Zi to Ai for each 1 ≤ i ≤ 4. These
of Q
homomorphisms can be combined to deﬁne a homomorphism r from T to A.

∗
i of Q

∗

∗

Our construction of ϕ(G) does not necessarily yield a digraph that is a core.
However, by applying a more involved construction we can force ϕ(G) also to be a
core. The technical details can be found in the appendix.

5. Queries over graphs. In this section we look more closely at queries over
graphs. That is, the vocabulary σ has a single binary relation E(·,·), interpreted as a
directed graph. In this restricted scenario we prove several results about the structure
of approximations in graph-based classes.

5.1. Acyclic approximations. We study acyclic (or, equivalently, treewidth-1)
approximations in detail for graph queries. We begin with the case of Boolean queries,
when the tableau of a query is just a graph, and show a trichotomy theorem for them,
classifying approximations based on graph-theoretic properties of the tableau. Note
that a query is acyclic iﬀ its tableau has no oriented cycles of length 3 or more.

5.1.1. Boolean queries. These queries are of the form Q() :– . . . and thus produce 
yes/no answers; their tableaux are simply directed graphs TQ. We have already
discussed them in the introduction, and mentioned that for nontrivial approximations,
the tableau must be bipartite. Recall that a digraph G is bipartite if G → K
(cid:2)
2 , i.e.,
G is 2-colorable: its nodes can be split into two disjoint subsets, A and B, so that all
edges have endpoints in diﬀerent subsets.

Recall the example from the introduction:

the cyclic query Q1() :– E(x, y),
E(y, z), E(z, x) had a trivial acyclic approximation Qtriv() :– E(x, x) (which is conCopyright 
© by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1101

tained in every Boolean graph query). The reason for that was TQ1 was not bipartite.
In the introduction, we saw an example of a query with a bipartite tableaux that
had a nontrivial approximation stating the existence of a path of length 4. Note
that every query whose tableau is bipartite will contain the trivial bipartite query
(cid:2)
Qtriv
2 . For some bipartite queries, e.g.,
Q3() :– E(x, y), E(y, z), E(z, u), E(x, u), this trivial query is the only acyclic approximation.
 This behavior is caused by the cycle being unbalanced. We next deﬁne this
concept [25], and then state the trichotomy result.

() :– E(x, y), E(y, x), whose tableau is K

2

We now recall several notions from [25] that have already been introduced in
the proof of Proposition 4.4. An oriented cycle is a digraph with nodes u1, . . . , un
and n edges such that either (ui, ui+1) or (ui+1, ui) is an edge, for each i < n, and
either (u1, un) or (un, u1) is an edge. Edges (ui, ui+1) and (un, u1) are forward edges
and edges (ui+1, ui) and (u1, un) are backward edges. An oriented cycle is balanced if
the number of forward edges equals the number of backward edges, and a digraph is
balanced if every oriented cycle in it is balanced.

Now we can state a trichotomy result for acyclic approximations of Boolean CQs

over graphs.

to equivalence);

Theorem 5.1. Let Q be a Boolean CQ over graphs. Then if its tableau TQ
• is not bipartite, then Q has only the trivial acyclic approximation Qtriv (up
• is bipartite but not balanced, then Q’s only acyclic approximation (up to equiv-
• is bipartite and balanced, then none of Q’s acyclic approximations is trivial,

alence) is the trivial bipartite query Qtriv

;

2

and none contains two subgoals of the form E(x, y), E(y, x).

(cid:4)

(cid:4)

Proof. Suppose the tableau TQ is not bipartite, and let Q

be an acyclic apIf 
TQ(cid:2) has no loops, then, by acyclicity, it is bipartite; hence
proximation of Q.
(cid:2)
2 , which contradicts the nonbipartiteness of TQ. Hence TQ(cid:2) has a

TQ → TQ(cid:2) → K

loop, and Q

is equivalent to Qtriv.

(cid:4)

Let TQ be bipartite and not balanced, and let Q

be an acyclic approximation
(cid:2)
of Q. We prove that TQ(cid:2) is homomorphically equivalent to K
2 . Note that TQ(cid:2) has
no loops: otherwise TQ → K
is not an approximation. Thus, TQ(cid:2)
is bipartite and TQ(cid:2) → K
(cid:6)→ TQ(cid:2). Then K
(cid:2)
2 . For the converse, assume K
is
not a subgraph of TQ(cid:2). Since Q
is acyclic, this implies that TQ(cid:2) is balanced, and
the following claim shows that TQ → TQ(cid:2) implies that TQ is balanced too, which is a

(cid:2)(cid:2) TQ(cid:2), and Q
(cid:4)

(cid:2)
2

(cid:2)
2

(cid:2)
2

(cid:4)

Claim 5.2. Balanced digraphs are closed under inverse homomorphisms. That

contradiction.
is, if G → H and H is balanced, then G is balanced.
Proof. We use the following characterization of balanced digraphs from [25]: G is
balanced iﬀ G → (cid:5)Pk for some k ≥ 1, where (cid:5)Pk denotes the directed path of length k.
Now, suppose G → H and H is balanced. Then H is homomorphic to a directed path,
and, by composition, G is homomorphic to such a directed path as well. Therefore,
G is balanced.

Finally, let TQ be bipartite and balanced, and let Q

of Q. As above, we see that Q
that K

be an acyclic approximation
is not equivalent to the trivial CQ. We now prove
is not a subgraph of TQ(cid:2) , implying the result. Assume otherwise; since
(cid:2)
2 , we have

TQ is balanced, we have that TQ → (cid:5)Pk for some k [25]. Since (cid:5)Pk (cid:2)(cid:2) K
TQ → (cid:5)Pk (cid:2)(cid:2) TQ(cid:2) , which contradicts the minimality of TQ(cid:2) .

(cid:2)
2

(cid:4)

Note that the conditions used in the theorem—being bipartite and balanced—can

be checked in polynomial time [25, 40].

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1102

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

As a corollary to the proof of the previous theorem, we obtain the following.
Corollary 5.3. Let Q be a Boolean cyclic CQ over graphs. Then all minimized

acyclic approximations of Q have strictly fewer joins than Q.

(cid:4)

Proof. Let Q

be a minimized acyclic approximation of Q. It suﬃces to show that

the tableau TQ(cid:2) has strictly fewer edges than the tableau TQ. We denote by |E(TQ(cid:2) )|
and |TQ(cid:2)| the numbers of edges and nodes in TQ(cid:2), respectively.

If TQ is not bipartite, or if is bipartite but not balanced, using Theorem 5.1 and

the fact that TQ has at least 3 edges (TQ is cyclic), we have the result.

Now, if TQ is bipartite and balanced, we know that K

(cid:2) TQ(cid:2) (Theorem 5.1),
and since TQ(cid:2) is a core (Q
is a minimized CQ), we know that TQ(cid:2) is a homomorphic
h−→ TQ(cid:2), where Im(h) = TQ(cid:2) . It suﬃces to show
image of TQ, via some h, that is, TQ
that there are two edges in TQ which are mapped via h to the same edge in TQ(cid:2).
Since TQ is cyclic there exists a connected component of TQ which is cyclic, namely,
H (connected in the sense that H u is connected). Let h
be the restriction of h to
H. Note that Im(h
), it follows
that |E(Im(h
)| − 1 ≤ |H| − 1. Finally, observe that |E(H)| > |H| − 1;
otherwise, since H is connected, then H would be acyclic, which is a contradiction.
Thus, |E(Im(h
maps two edges to one edge in TQ(cid:2) . In particular,
h maps two edges to one edge in TQ(cid:2).

))| = |Im(h
))| < |E(H)| and h
(cid:4)

) is connected and acyclic, and since K

(cid:2) Im(h

(cid:2)
2

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:2)
2

(cid:4)

(cid:4)

(cid:4)

Reformulating our results in terms of graphs, we obtain the following.
Corollary 5.4. For every cyclic digraph G and its acyclic approximation T ,
the core of T has strictly fewer edges than G. Moreover, T is not homomorphically
equivalent to a single loop iﬀ G is bipartite.

Theorem 5.1 says that the most interesting case, for graph queries, is when the
tableau is bipartite and balanced (as we already mentioned in the introduction, for
relations of higher arity, such restrictions need not be imposed). A natural question
is whether CQs with such tableaux are still intractable (i.e., whether it still makes
sense to approximate them). We prove next that this is the case.

Proposition 5.5. The combined complexity of evaluating Boolean CQs over

graphs whose tableaux are bipartite and balanced is NP-complete.

Proof. Note that any balanced digraph is bipartite; thus bipartite and balanced
digraphs are exactly balanced digraphs. It suﬃces to prove (due to the correspondence
between CQs and tableaux) that the following equivalent problem is NP-complete:
Given a balanced digraph G and a digraph H, check if G → H.

It is known that there exists an oriented tree T (undirected tree plus orientation
in the edges) such that the following problem is NP-complete [25]: Given a digraph
G, decide if G → T . This problem remains NP-complete even for G balanced, since
a digraph homomorphic to T must be balanced (using Claim 5.2 and the fact that
any oriented tree is balanced). Thus the result follows and, in fact, the problem is
NP-complete even if H is a ﬁxed oriented tree.

We conclude our investigation of Boolean CQs with a remark on a subclass of
is a tight C-approximation
(cid:4)
acyclic approximations with special properties. A query Q
of Q if it is a C-approximation of Q and there is no query Q
(cid:4)(cid:4) ⊂ Q.
(cid:4)(cid:4)
such that Q
It is not clear a priori whether such approximations exist, and for which classes C they
might exist. The results of [35] (reformulated in terms of tableaux of queries) imply
that if a tight C-approximation Q
is
acyclic. Hence, tightness forces the approximating query to be acyclic. The next question 
is whether acyclic tight approximations exist. We can show that this is the case.
Proposition 5.6. There is an inﬁnite family of nonequivalent Boolean CQs

of a query Q is minimized and connected, then Q

(cid:4) ⊂ Q

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1103

Qn, Q

(cid:4)
n for n > 0 such that Q

(cid:4)
n is a tight acyclic approximation of Qn.

Proof. Let Gk be the digraph constructed as follows. Take two disjoint copies
of a directed path of length k, the ﬁrst on nodes x0, x1, . . . , xk, and the second on
nodes y0, y1, . . . , yk. Then add edges (x0, y2), (x1, y3), . . . , (xi, yi+2), . . . , (xk−2, yk).
The picture is shown below.
•
/ •

/ •
@@@@
/ •

@@@@ •
/ •

/ •
@@@@
/ •

 BBBB ...
/ •

•
•

/ •

•

...

...

long as k ≥ 3:

It can then be shown that (cid:5)Pk+1, the path of length k + 1, has two properties, as
1. Gk → (cid:5)Pk+1; and
2. there is no digraph G such that Gk (cid:2)(cid:2) G (cid:2)(cid:2) (cid:5)Pk+1.
The ﬁrst property is immediate. To show the second, we use the standard construction 
for gaps in the lattice of digraphs [35]: we take (cid:5)Pk+1 and compute its dual
Fk (following the procedure in [35] or in Theorem 3.35 in [25]), which has the following 
property: for every digraph H, either H → Fk or (cid:5)Pk+1 → H holds. Then we
take the digraph Fk × (cid:5)Pk+1. Of course Fk × (cid:5)Pk+1 → (cid:5)Pk+1; the results of [35] further
tell us that there is no digraph between Fk × (cid:5)Pk+1 and (cid:5)Pk+1 in the → ordering. We
then compute the core of Fk × (cid:5)Pk+1, which happens to be Gk. We omit the tedious

calculations.

With properties 1 and 2 above established, we simply take Qn to be the query
whose tableau is Gn+2 (as the properties above are guaranteed starting with G3) and
Q

(cid:4)
n to be the CQ whose tableau is (cid:5)Pn+3.

Example 5.7. Consider a Boolean query Q whose tableau is the digraph below,

in which number k above an edge represents a path of length k:

•

2

?~~~~
@@@@

3

•

•

•

•

3

@@@@
?~~~~

2

•

This digraph is bipartite and balanced, so Theorem 5.1 tells us that it has nontrivial 
acyclic approximations. In fact it can be shown that Q has a unique (up to
equivalence) acyclic approximation Q
, whose tableau is the path of length 4 (i.e., the
query Q

, x, y, z, u) mentioned in the introduction).

(cid:4)
() :– P4(x

(cid:4)

(cid:4)

(cid:4)

The same Q

is

serves as a tight acyclic approximation to the query, whose tableau

•
/ •

•
@@@@
/ •

•
@@@@
/ •

•

/ •

This is exactly the query Q2 from the introduction, for which, as stated there, Q

(cid:4)

is an acyclic approximation.

5.1.2. Non-Boolean queries. For CQs with free variables, it is still true that
those whose tableaux are bipartite have nontrivial acyclic approximations. However,
now some queries with nonbipartite tableaux may have approximations whose bodies
do not trivialize to just E(x, x). For example, consider a query Q(x, y) :– E(x, y),

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php/
/

 

/

/
/
/
/
/
/
/
o
o

?

o
o
?
/
/

/
/

/
/
/
/
1104

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

(x, y) :– E(x, y), E(y, x), E(x, x) is an
E(y, z), E(z, x). It can be shown easily that Q
(cid:2)
acyclic approximation of it; the tableau of Q
2 with a loop on one of the nodes
(recall that the deﬁnition of query acyclicity refers to tree decompositions of the query
hypergraphs, so Q

is indeed acyclic).

is K

(cid:4)

(cid:4)

(cid:4)

What distinguishes the case of bipartite tableaux now when we look at queries
with free variables is that they do not have subgoals of the form E(x, x) in approximations.
 That is, we have the following dichotomy.

Theorem 5.8. Let Q(¯x) be a cyclic CQ over graphs. If its tableau TQ
• is not bipartite, then all of Q’s acyclic approximations have a subgoal of the
• is bipartite, then Q has an acyclic approximation without a subgoal of the

form E(x, x);

form E(x, x).

(cid:4)

Proof. Suppose that the tableau TQ of Q is not bipartite and let Q

be an acyclic
approximation of Q. Suppose that TQ(cid:2) has no loops. Then TQ(cid:2) is bipartite (since T u
Q(cid:2)
is acyclic), implying that TQ(cid:2) → K
(cid:2)
2 as
well. It follows that TQ is bipartite, which is impossible. Therefore, TQ(cid:2) has loops,
i.e., Q

2 . Since TQ → TQ(cid:2) , we have that TQ → K
(cid:2)

has a subgoal of the form E(x, x).

(cid:4)

Now, suppose that the tableau TQ of Q is bipartite. Using an argument similar to
the proof of Theorem 4.1 we shall prove that there exists an acyclic approximation of
Q without a subgoal of the form E(x, x), i.e., whose tableau has no loops. Let AQ be
the set of all digraphs with distinguished elements (H, ¯u) such that H u is acyclic and
has no loops, (TQ, ¯x) → (H, ¯u), and |H| ≤ |TQ| + 1 (where |G| is the number of nodes
of the digraph G). Clearly, AQ is ﬁnite. Moreover, it is not empty, since there exists
a homomorphism h from TQ to K
(this follows from the fact that TQ is bipartite),
2 , h(¯x)) is contained in AQ. We can pick a minimal element
(cid:2)
and this implies that (K
(with respect to →) (H
(cid:4)
tableau is (H
an acyclic CQ Q
(cid:4)(cid:4)
(Im(g), ¯x

), the CQ whose
), is an acyclic approximation of Q. Suppose not; then there exists
(cid:4)(cid:4)
). Observe that
)), Im(g)u is acyclic (since
), and |Im(g)| ≤ |TQ|. Therefore,

) from AQ. We shall show that Q
) (cid:2)(cid:2) (H
(cid:4)
, ¯u

g−→ (TQ(cid:2)(cid:2) , ¯x
(cid:4)(cid:4)
) (cid:6)→ (H
(cid:4)
(cid:4)(cid:4)
) has no loops (otherwise, (TQ(cid:2)(cid:2) , ¯x
) is contained in AQ. Finally, note that (Im(g), ¯x
(cid:4)(cid:4)

Im(g) is subgraph of TQ(cid:2)(cid:2) ), (TQ, ¯x) → (Im(g), ¯x
(cid:4)(cid:4)

) such that (TQ, ¯x)

) (cid:2)(cid:2) (H

(cid:4)(cid:4)
(¯x

(cid:2)
2

, ¯u

, ¯u

, ¯u

(¯u

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)(cid:4)
(Im(g), ¯x
contradicts the minimality of (H
Q, and since TQ(cid:2) = H

(cid:4)

(cid:4)

, ¯u

(cid:4)

) in AQ. Thus, Q

(cid:4)

), which
is an acyclic approximation of

, ¯u

has no loops, we have the result.

Notice that the previous theorem actually generalizes Theorem 5.1, since a
Boolean CQ is trivial iﬀ its tableau has a loop. However, when the query is not
Boolean the latter is not necessarily true.

For Boolean queries we saw that acyclic approximations also have strictly fewer
joins than Q. With free variables, the number of joins may sometimes be the same
as for Q itself.

Proposition 5.9. There is a non-Boolean cyclic CQ over graphs such that all

of its minimized acyclic approximations have exactly as many joins as Q.

Proof. Consider the following query:

Q(x1, x2, x3) :– E(x1, x2), E(x2, x3), E(x3, x4), E(x4, x1).

(cid:4)
Let G

This query is minimized. Its tableau, which we denote by (G, x1, x2, x3), contains an
oriented cycle on nodes x1, x2, x3, x4, with x1, x2, x3 being distinguished nodes.

= (cid:4)V
(cid:4)(cid:5) be a digraph containing nodes x
(cid:4)
(cid:4)
(cid:4)
(cid:4)
, E
2, x
1, x
3 (not necessarily dis-
(cid:4)
(cid:4)
(cid:4)
(cid:4)
2, x
1, x
, x
3) is a tableau of an acyclic approximation of Q. We know
tinct) so that (G
(cid:4)
(cid:4)
(cid:4)
(cid:4)
that (G
3) is an image of some homomorphism h deﬁned on G. Note that if
2, x
1, x
, x

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1105

(cid:4)| ≤ 3.

assumption.

would be cyclic. Hence, |V

(cid:4)
the homomorphism h were one-to-one, then all the edges of G would be present in G
(cid:4)
and thus G
i for 1 ≤ i ≤ 3. Consider ﬁrst a homomorphism h so that
(cid:4)
By deﬁnition, h(xi) = x
i’s, for 1 ≤ i ≤ 3, are distinct. Then there are three possibilities where x4 could be
(cid:4)
x
mapped:• If h(x4) = x
(cid:4)
(cid:4)
1 or h(x4) = x
3, then Im(h) is a cyclic digraph, contradicting the
• If h(x4) = x
(cid:2)
(cid:4)
2, we get a digraph consisting of two copies of K
2 ,
i.e., a
i, 1 ≤ i ≤ 3, and edges (x
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
graph G0 with nodes x
2), (x
1, x
2, x
1) as well
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
as (x
2),
2). The corresponding query Q0(x
3, x
3), (x
2, x
1, x
3) :– E(x
1, x
2, x
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
3, x
1), E(x
2, x
3), E(x
2, x
E(x
2) has the same 3 joins as the original query.
Next we see what happens when h collapses some of xi’s for 1 ≤ i ≤ 3. First we
look at the cases when h collapses two of those. Suppose we collapse x1 and x2, i.e.,
(cid:4)
(cid:4)
(cid:4)
1 = x
h(x1) = h(x2) (and thus x
2) and x
• If h(x4) = x
(cid:4)
(cid:4)
(cid:4)
(cid:4)
3
1, x
2, then Im(h) is the digraph G1 with nodes x
1 = x
3 and edges
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
1, x
1), with distinguished nodes (x
3, x
3), (x
1, x
1, x
1), (x
1, x
(x
3). It is routine
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
3) (cid:2)(cid:2) (G1, x
to check that (G0, x
1, x
1, x
2, x
1, x
3), and hence the result of this
homomorphism is not an acyclic approximation.
• If h(x4) = x
(cid:4)
3, then the image of h is a digraph with 4 edges, hence corresponding 
to a query with 3 joins, same as in the original Q.
• If h(x4) is diﬀerent from x
(cid:4)
(cid:4)
(cid:4)
3, then Im(h) has a cycle.
2, x
1, x
The case when x2 and x3 are collapsed to the same node by h is completely
(cid:4)
(cid:4)
symmetric. Now assume that h collapses x1 and x3, i.e., x
1 = x
3. Again there are
three cases.
• If h(x4) = x
(cid:2)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
1) where G2 is a copy of K
2, x
1, x
2, then the image of h is (G2, x
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
2
3) (cid:2)(cid:2) (G2, x
on x
1, x
2, x
1, x
1, x
2. In this case again we easily verify (G0, x
2, x
1),
meaning that the latter cannot be an acyclic approximation.

(cid:6)= x
(cid:4)
1. There are three possibilities for x4:

copies of K

• If h(x4) = x
(cid:4)
1, then the image of the original tableau is the same digraph as
(cid:4)
in the previous case, plus a loop on x
1. Hence, the same argument as above
shows that it cannot be an acyclic approximation.
• Otherwise, if h(x4) is diﬀerent from x
(cid:4)
(cid:4)
(cid:4)
2, x
1, x
3, then Im(h) is a union of two
(cid:4)
Finally, if h collapses all nodes (say to x
1), there are two possibilities.

(cid:2)
2 , and thus it has the same 3 joins as the original query.

• If h(x4) = x
(cid:4)
1, then we end up with a trivial query with the tableau
(cid:3)
(cid:3)
(cid:4)
(cid:4)
(cid:4)
1), where K
1, x
1, x
1 , x
(K
1 is the digraph that consists of a directed loop
(cid:3)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
3) (cid:2)(cid:2) (K
on a single element, and clearly (G0, x
1 , x
2, x
1, x
1, x
1, x
1).
(cid:6)= x
• If h(x4) = x
(cid:2)
(cid:4)
(cid:4)
(cid:4)
(cid:4)
1, then Im(h) consists of a copy of K
1 and x
2 on x
4, as
(cid:4)
(cid:4)
(cid:4)
(cid:4)
4
well as a loop on x
1. In this case we again easily verify that (G0, x
2, x
1, x
3)
(cid:4)
(cid:4)
(cid:4)
(cid:2)(cid:2) (Im(h), x
1, x
1, x
1).

Hence, in all the cases when the number of joins is reduced, the resulting query

is not an acyclic approximation, which proves the proposition.

5.2. Bounded treewidth queries. We have already seen that treewidth-k approximations 
of a CQ Q always exist, that they cannot exceed the size of Q, and that
they can be constructed in single-exponential time. There is an analogue of the dichotomy 
for acyclic queries, in which bipartiteness (i.e., being 2-colorable) is replaced
by (k + 1)-colorability for TW(k).

Theorem 5.10. Let Q be a CQ over graphs. If its tableau TQ
• is not (k + 1)-colorable, then all of its TW(k)-approximations have a subgoal

of the form E(x, x);

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php(cid:4)

1106

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

• is (k + 1)-colorable, then Q has a TW(k)-approximation without a subgoal of

the form E(x, x).

Proof. We use arguments similar to the proof of Theorem 5.8. We also use the
well-known result that each digraph without loops of treewidth at most k is (k + 1)-
colorable, or, equivalently, is homomorphic to K

(cid:2)
k+1.

Assume ﬁrst that the tableau TQ of Q is not (k + 1)-colorable and let Q

be a
TW(k)-approximation of Q. Assume for the sake of contradiction that TQ(cid:2) has no
loops. Then TQ(cid:2) is (k + 1)-colorable, implying that TQ(cid:2) → K
k+1. Since TQ → TQ(cid:2),
(cid:2)
we have that TQ → K
(cid:2)
k+1 as well. It follows that TQ is (k + 1)-colorable, which is a
contradiction. Therefore, TQ(cid:2) has loops, i.e., TQ(cid:2) has a subgoal of the form E(x, x).
Assume, on the other hand, that the tableau TQ of Q is (k + 1)-colorable and let
AQ be the set of all digraphs with distinguished elements (H, ¯u) such that H u has
treewidth at most k and has no loops, (TQ, ¯x) → (H, ¯u), and |H| ≤ |TQ| + k. Clearly,
AQ is ﬁnite. Moreover, it is not empty, since there exists a homomorphism h from
(cid:2)
TQ to K
k+1, h(¯x)) is contained
in AQ. We pick a minimal element (with respect to →) (H
) from AQ. We shall
(cid:4)
), is a TW(k)-approximation of
show that Q
) with treewidth at most k such that
Q. Suppose not; then there exists a CQ Q
g−→ (TQ(cid:2)(cid:2) , ¯x
(cid:4)(cid:4)
) (cid:2)(cid:2) (H
(TQ, ¯x)
) has no loops (otherwise,
) (cid:6)→ (H
(cid:4)
(cid:4)(cid:4)
(cid:4)
)), Im(g)u has treewidth at most k (since Im(g) is subgraph of
(TQ(cid:2)(cid:2) , ¯x
TQ(cid:2)(cid:2) ), (TQ, ¯x) → (Im(g), ¯x
(cid:4)(cid:4)
) is contained
in AQ. Finally, note that (Im(g), ¯x
(cid:4)(cid:4)
), which is a contradiction with the
is a TW(k)-approximation of Q, and since

(cid:2)
k+1 (TQ is (k + 1)-colorable), and this implies that (K
, ¯u

), and |Im(g)| ≤ |TQ|. Therefore, (Im(g), ¯x
(cid:4)(cid:4)

(cid:4)(cid:4)
). Observe that (Im(g), ¯x

), the CQ whose tableau is (H
(cid:4)(cid:4)
(¯x

(cid:4)(cid:4)

) in AQ. Thus, Q

) (cid:2)(cid:2) (H

, ¯u

, ¯u

(cid:4)

(cid:4)

(¯u

, ¯u

(cid:4)

(cid:4)

, ¯u

(cid:4)

(cid:4)

(cid:4)

, ¯u

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

minimality of (H
TQ(cid:2) = H

(cid:4)

has no loops, we have the result.

Proof. Let k > 1. We shall prove that there is a polynomial reduction from the

Recall that a Boolean CQ Qtriv() :– E(x, x) is a trivial (acyclic, or treewidth-k)
approximation of every Boolean CQ. In the acyclic case, 2-colorability (or bipartite-
ness) of TQ was equivalent to the existence of nontrivial approximations. This result
extends to treewidth-k.

Corollary 5.11. A Boolean CQ Q over graphs has a nontrivial TW(k)-approximation 
iﬀ its tableau TQ is (k + 1)-colorable.

(cid:4)

(cid:4)

Proof. Let Q

be a TW(k)-approximation of Q. Assume ﬁrst that the tableau
TQ of Q is not (k + 1)-colorable. Using Theorem 5.10 we know that TQ(cid:2) has loops.
is equivalent to Qtriv. Now, assume that the tableau TQ of Q is (k + 1)-
Therefore, Q
colorable. If TQ(cid:2) has loops, we have that TQ → K
(cid:2)(cid:2) TQ(cid:2) , which is a contradiction
(cid:2)
with the minimality of TQ(cid:2) because K
k+1 is of treewidth k. Then TQ(cid:2) has no loops,
i.e., is not equivalent to Qtriv.

(cid:2)
k+1

Note the big diﬀerence in the complexity of testing for the existence of nontrivial
approximations: while it is in Ptime in the acyclic case, the problem is already
NP-complete for TW(2).

If a Boolean CQ Q has a nontrivial TW(k)-approximation, then the query Qtriv
k+1
(cid:2)
with the tableau K
k+1 is contained in Q. For k = 1, we had a necessary and suﬃcient 
condition for such a query to be an approximation (it was the Ptime-testable
condition of not being balanced; see Theorem 5.1). For TW(k), we do not have such
a characterization, but we do know that even for TW(2), the criterion will be much
harder than for the acyclic case due to the following.

Proposition 5.12. For every k > 1, testing, for a Boolean CQ Q over graphs,

whether Qtriv

k+1 is a TW(k)-approximation of Q is NP-hard.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1107

(k + 1)-coloring problem to our problem. Let G be a graph. The reduction returns
(cid:2)
the CQ ϕ(G) whose tableau is (cid:5)G + K
k+1, where + denotes disjoint union, and (cid:5)G
is the directed version of G obtained by replacing each undirected edge {a, b} in G
with both (a, b) and (b, a). We prove next that G is (k + 1)-colorable iﬀ Qtriv
k+1 is a
TW(k)-approximation of ϕ(G).

Suppose that G is (k + 1)-colorable; then (cid:5)G → K

(cid:2)
k+1, the tableau of Qtriv

(cid:2)
k+1, implying that the tableau of
k+1. Therefore, ϕ(G)

ϕ(G) is homomorphically equivalent to K
is equivalent to Qtriv
particular, we have that Tϕ(G) → TQtriv

Suppose, on the other hand, that Qtriv

k+1, and thus Qtriv

k+1

k+1 is a TW(k)-approximation of ϕ(G).

k+1 is a TW(k)-approximation of ϕ(G). In
, implying that (cid:5)G → K
(cid:2)
k+1. Therefore, G is

(k + 1)-colorable.

Thus, while the behavior of acyclic and treewidth-k approximations for k > 1 is in
general similar, testing conditions that guarantee certain properties of approximations
is harder even for treewidth 2, compared to the acyclic case.

5.3. Graphs vs. higher-arity relations. We now contrast graph queries with
those that use relations of higher arity to demonstrate that higher arity gives a lot
more freedom for ﬁnding interesting approximations. Since we deal with graph-based
classes of queries, we shall be looking for the strongest, i.e., TW(1)-approximations.
Suppose we have an arbitrary query Q with n variables. Then the maximum possible
treewidth of Q is n− 1. We look for approximation that decrease the treewidth in the
is a strong treewidth approximation of
strongest possible way. That is, we say that Q
is a TW(1)-approximation of Q, and Q has the maximum possible treewidth
Q if Q
> 1 (i.e., its treewidth is the number of variables minus 1).

(cid:4)

(cid:4)

For this subsection we deal with Boolean queries and assume that the vocabulary
consists of one m-ary relation R; when m = 2, we deal with graphs. In fact, in the
is a
case of graphs the notion of strong treewidth approximation trivializes:
is equivalent to the trivial query Qtriv.
strong treewidth approximation of Q, then Q
Indeed, if Q is of maximum possible treewidth > 1, then G(Q) is Kn (perhaps with
some loops), and hence for n > 2 it is not bipartite, implying triviality of TW(1)-
approximation.

if Q

(cid:4)

(cid:4)

However, when m > 2, there are many possible strong treewidth approximations,
even in cases that appear to be close to the cases of graphs admitting only trivial
approximations. So for now ﬁx m > 2 and assume that Q
is a strong treewidth
approximation of Q. First observe that Q
can have at most 2 variables: indeed, since
G(Q) is a Kn (perhaps with loops), then if G(Q
) has at least 3 nodes, it would have
a triangle and hence be of treewidth at least 2. So we call a Boolean query Q
over
an m-ary relation R a potential strong treewidth approximation if G(Q
) has at most
2 nodes.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Proposition 5.13. Let Q

be a potential strong treewidth approximation. Asis 
nontrivial. Then, for every n > m, there is a CQ Q with n variables
is a strong treewidth approximation of Q. Moreover, if the query Q
has

sume that Q
(cid:4)
such that Q
k atoms, then Q can be chosen to have at most k + n(n−1)

− 1 atoms.

(cid:4)

Proof. Observe that in every atom in Q

one variable occurs at least twice. Assume
ﬁrst that there is an atom in which some variable occurs exactly twice, say, an atom

R(x, . . . , x, y, y). Then in Q we put atoms R(x1, . . . , x1, xi, xj) for all 2 ≤ i ≤ j ≤ n,
assuming Q has variables x1, . . . , xn. For every other atom R(x, . . . , x, y, . . . , y) with r
occurrences of y we put in Q the atom R(x1, . . . , x1, x2, . . . , xr+1) (of course variables
can occur in an arbitrary order; we simply replace all the occurrences of x with x1

(cid:4)

2

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1108

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

and r occurrences of y with x2, . . . , xr+1, in the same order in which the y’s occur in
the atom). The construction ensures that G(Q) is Kn, and it is easy to verify that
− 1 atoms, as only one atom in
Q has at most k + n − 2 + (n−1)(n−2)
(cid:4)
generates multiple atoms in Q. The mapping sending x1 to x and every xi with
Q
(cid:4) ⊆ Q. If there were TW(1)-approximation
i > 1 to y is a homomorphism showing Q
(cid:4)(cid:4) ⊂ Q, then G(Q
(cid:4)(cid:4)
) would be K2 (perhaps with loops), so a
Q
homomorphism of the tableau of Q
can only be the identity,
or swapping the roles of variables x and y. Using this one easily veriﬁes that Q
is an
approximation.

= k + n(n−1)

into the tableau of Q

of Q with Q

(cid:4) ⊂ Q

(cid:4)(cid:4)

(cid:4)(cid:4)

(cid:4)

2

2

(cid:4)

If we do not have an atom with exactly two occurrences of a variable, then pick
an atom with a minimum number p of repetitions of a variable, say, R(x, . . . , x,
y, . . . , y), where y occurs p times. Then we replace it by putting in Q atoms R(x1, . . . ,
x1, x2, . . . , xp−1, xi, xj ) with p ≤ i < j ≤ n (where x1’s correspond to the positions of
x). In addition, we put in Q atoms R(x1, . . . , x1, xi, . . . , xi, xi, xi) whenever 2 ≤ i ≤

n. The proof then is the same (only the number of atoms in Q gets smaller).

decrease the number of joins. Beyond graphs, however, this need not be the case.

Recall that for Boolean graph queries (m = 2), TW(1)-approximations strictly
Proposition 5.14. For every k ≥ 3, one can ﬁnd a relation symbol R of arity
over R with the same number

m > 2, and two minimized conjunctive queries Q and Q
of joins such that Q

is a strong treewidth approximation of Q.

(cid:4)

(cid:4)

Proof. We take m, the arity of R, to be equal to k. In Q, the ﬁrst three atoms are
R(x1, x2, x3, x4, . . . , xk), R(x2, x1, xk+1, x4, . . . , xk), and R(x3, xk+1, x1, x4, . . . , xk).
The next k − 3 atoms are of the form R(xj , xj, . . . , xj , x1, xj , . . . , xj ), where x1 appears 
in the jth position; here 4 ≤ j ≤ k.
, we have k atoms of the form
R(x, y, . . . , y), R(y, x, y, . . . , y), . . . , R(y, . . . , y, x), i.e., x appears once, every time in
a diﬀerent position. It is straightforward to verify all three conditions of the proposition.


In Q

(cid:4)

A slight drawback of the previous result is that it requires relations of high arity.
But we can show that already for ternary relations, the behavior of strong treewidth
approximations is drastically diﬀerent from the graph case.

Consider the query Qtr() :– R(x, y), R(y, z), R(z, x); it states that a graph contains 
a triangle. Its graph is not bipartite, since G(Q) = K3, and hence it only has
trivial TW(1)-approximation.

We now look at ternary relations R. We call an instance R of a ternary relation
an almost-triangle if there is an element that belongs to every triple of R, and when
it is removed from every triple, the resulting pairs form a triangle. For instance,
(4, 1, 2), (4, 2, 3), (4, 3, 1) is an almost-triangle: when we remove 4 for each of the
triples, we end up with the pairs (1, 2), (2, 3), (3, 1), which form a triangle.

relation R that uses 4 variables, has maximum treewidth 3, such that

Proposition 5.15. There is a minimized conjunctive query Q over a ternary
• the tableau TQ of Q is an almost-triangle; and
• Q has a strong treewidth approximation Q
(cid:4)

with the same number of joins

as Q.

Proof. We deﬁne Q over variables x1, x2, x3, x4 as follows:

Q() :– R(x1, x2, x3), R(x2, x1, x4), R(x4, x3, x1).

Its tableau is an almost-triangle (just remove x1). Furthermore G(Q) = K4, and thus
it has treewidth 3. It is also minimized.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1109

We then look at

(cid:4)

Q

() :– R(x, y, y), R(y, x, y), R(y, y, x).

It is routine to verify that Q
conditions of the proposition.

(cid:4)

is a strong treewidth approximation of Q satisfying all

Thus, indeed, the behavior of treewidth approximations is already drastically

diﬀerent for the case of ternary relations, compared to graphs.

6. Hypergraph-based approximations. We now switch to study approximations 
in tractable classes deﬁned by restricting the hypergraph H(Q) of a CQ Q:
The nodes of H(Q) again are variables used in Q, and its hyperedges correspond
i.e., for each atom R(x1, . . . , xn) in Q, we have a hyperedge
to the atoms of Q;
{x1, . . . , xn}.
If C is a class of hypergraphs, then a query Q is a hypergraph-based
C-query if H(Q) ∈ C. In general, graph-based and hypergraph-based classes of CQs
are incompatible: there are graph-based classes that are not hypergraph-based, and
vice versa [16].

The oldest tractability criterion for CQs, acyclicity [41], is a hypergraph-based
notion (see the deﬁnition in section 3). It corresponds to the class of CQs Q such
that H(Q) belongs to the class AC of acyclic hypergraphs, or, in other words, Q is a
hypergraph-based AC-query. Analogues of bounded treewidth for hypergraphs were
deﬁned in [20, 21]; those notions of bounded hypertree width and generalized hypertree
width properly extended acyclicity and led to tractable classes of CQs over arbitrary
vocabularies.
We look at hypergraph-based C-approximations, i.e., approximations in the class of
hypergraph-based C-queries. Our ﬁrst goal is to have a general result about the existence 
of approximations that will apply to both acyclicity and bounded (generalized)
hypertree width (to be deﬁned formally shortly).

Note we cannot trivially lift the closure condition used in Theorem 4.1 for hypergraphs,
 since even acyclic hypergraphs are not closed under taking subhypergraphs.
 Indeed, take a hypergraph H with hyperedges {a, b, c},{a, b},{b, c},{a, c}.
It is acyclic: the decomposition has {a, b, c} associated with the root of the tree, and
two-element edges with the children of the root. However, it has cyclic subhypergraphs,
 for instance, the one that contains its two-element edges.

The closure conditions we use instead are the following:
• Closure under induced subhypergraphs.
(cid:4) | e ∈ E}(cid:5).

is an
induced subhypergraph, then H(cid:4) ∈ C. Recall that an induced subhypergraph
is one of the form (cid:4)V
For instance, take again the hypergraph H with hyperedges {a, b, c},{a, b},
{b, c},{a, c}. Then the only induced subhypergraph of H that contains all of
its two-element edges is H itself.

If H = (cid:4)V,E(cid:5) is in C and H(cid:4)

• Closure under edge extensions. If H = (cid:4)V,E(cid:5) is in C and H(cid:4)

(cid:4)

,{e ∩ V

adding new nodes V
then H(cid:4) ∈ C.

(cid:4)

to one hyperedge e ∈ E, where V

(cid:4)

is obtained by
is disjoint from V ,

We shall see that these will be satisﬁed by the classes of hypergraphs of interest
to us. The analogue of the previous existence results can now be stated as follows.
Theorem 6.1. Let C be a class of hypergraphs closed under induced subhypergraphs 
and edge extensions. Then every CQ Q that has at least one hypergraph-based
C-query contained in it has a hypergraph-based C-approximation.
Moreover, the number of nonequivalent hypergraph-based C-approximations of Q
is at most exponential in the size of Q, and every such approximation is equivalent to

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php(cid:4)

(cid:4)
(¯x

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

1110
one which has at most O(nm−1) variables and at most O(nm) joins, where n is the
number of variables in Q, and m is the maximum arity of a relation in the vocabulary.
Proof. We make use of the following claim.
Claim 6.2. Let C be a class of hypergraphs closed under induced subhypergraphs
) be a hypergraph-based C-query, both
and edge extensions. Let Q(¯x) be a CQ and Q
(cid:4) ⊆ Q. Let us denote by n the number of variables in Q,
over vocabulary σ, such that Q
by (cid:3) the number of relation symbols in σ, and by m the maximum arity of a symbol in
, with at most n + (m − 1)2nm−1
σ. Then there exists a hypergraph-based C-query Q
(cid:4)(cid:4)
variables and at most (cid:3) · nm joins, such that Q
(cid:4) ⊆ Q
(cid:4)(cid:4) ⊆ Q.

(cid:4) ⊆ Q it is the case that (TQ, ¯x) h−→ (TQ(cid:2), ¯x
(cid:4)

Proof. Since Q

). Consider the
database T over σ constructed as follows: Let U be the active domain of Im(h).

For each relation symbol R ∈ σ, add to RT all tuples ¯t ∈ RTQ(cid:2) such that U¯t ⊆ U ,
where U¯t is the set of elements that occur in ¯t. Notice that H(T ) is not necessarily
an induced subhypergraph of H(TQ(cid:2) ), as there might be hyperedges e in H(TQ(cid:2) ) that
contain elements in U, but e ∩ U is not a hyperedge in H(T ). As such, it is not possible 
to apply the ﬁrst closure condition of C in order to infer that H(T ) belongs to
C. A straightforward alternative seems to consider the subhypergraph HU of H(TQ(cid:2) )
induced by U . The problem then is that there might be hyperedges in HU that do
not belong to H(TQ(cid:2)), and thus it is not clear how to deﬁne from HU a query Q
(cid:4)(cid:4)
that contains Q
, which is one of the properties we are looking for. We will have to
follow a diﬀerent strategy based on the second closure property of C—closure under
edge extensions—to build the desired query Q

(cid:4)(cid:4)

(cid:4)

.

A nonempty subset X of U is an extended subset if (1) there is no tuple ¯t in some
relation of T such that U¯t = X, and (2) there exists a tuple ¯s in some relation of TQ(cid:2)
such that U¯s (cid:2) U and U¯s∩ U = X. That is, the extended subsets X of U are precisely
the hyperedges of HU that are not hyperedges of H(TQ(cid:2)), and thus of H(T ). Using

this notion we deﬁne a database T
that is obtained by extending T as follows: For
each extended subset X of U , choose an arbitrary tuple ¯sX and an arbitrary symbol
SX in σ such that (i) ¯sX belongs to the interpretation of SX in TQ(cid:2), (ii) U¯sX (cid:2) U, and
(iii) U¯sX ∩ U = X (we know this tuple exists by deﬁnition of extended subset). Add
(cid:4)
the tuple ¯s
X that is obtained from ¯sX by renaming
to the interpretation of SX in T
all elements in U¯sX \ U = {z1, z2, . . . , zr} by new elements {z
) is in C since it is obtained from H(TQ(cid:2) ) in
the following way: Take the induced subhypergraph HU of H(TQ(cid:2)) whose node set is
U , and then for each extended subset X ⊆ U do an edge extension in X (recall that
each extended subset X of U is a hyperedge of HU ). Using the closure properties of
C and the fact that H(TQ(cid:2) ) ∈ C, it follows that H(T

Observe that the hypergraph H(T

(cid:4)
2, . . . , z

(cid:4)
1, z

}.

(cid:4)
r

(cid:4)

(cid:4)

(cid:4)

(cid:4)

) ∈ C.
(cid:4)

(cid:4)

(cid:4)
, ¯x
) → (TQ(cid:2) , ¯x
(cid:4)
(cid:4)
, ¯x

(cid:4)

(cid:4)

∗

(cid:4)
, ¯x

. Thus, (TQ, ¯x) → (T

Notice that h is a homomorphism from (TQ, ¯x) to (T

, h(¯x)) = (T
(cid:4)
). We prove next that (T

) since Im(h)
is contained in T
).
In fact, let T
be the database that is obtained from T by adding, for each extended
subset X of U , the tuple ¯sX to the interpretation of SX , where SX and ¯sX are as
is contained in TQ(cid:2), and hence the identity
deﬁned before for X. By deﬁnition, T
(cid:4)
mapping is a homomorphism from (T
, ¯x
is (up to
isomorphism) the database that is obtained from T
by taking each tuple of the form
and replacing each element z in ¯sX that does not belong to U with a fresh
¯sX in T
(cid:4)
element z
. In particular, two diﬀerent facts of T
can only share elements that belong
(cid:4) → TQ(cid:2), deﬁned as the identity
to U . It can then be easily seen that the mapping h : T
(cid:4)
on U and as h(z
∗
element z in T

that does not belong to U and replaced
belongs to T , and thus to U , and

) = z for each element z
(cid:4)
, is a homomorphism. Further, ¯x

(cid:4)
) to (TQ(cid:2) , ¯x

). Notice that T

in T

∗
∗

∗

∗

(cid:4)

(cid:4)

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1111

(cid:4)
hence h is the identity on ¯x

. We conclude that (TQ, ¯x) → (T

(cid:4)

(cid:4)
, ¯x

) → (TQ(cid:2) , ¯x
(cid:4)

).

Recall that for each extended subset X of U it is the case that there exists a tuple

¯s in some relation of TQ(cid:2) such that U¯s (cid:2) U and U¯s ∩ U = X. Thus, |U¯s \ X| ≥ 1.
Since |U¯s| ≤ m (because |U¯s| is bounded by the maximum arity of a tuple in TQ(cid:2), and
thus by the maximum arity m of a symbol in σ), we conclude that for each extended
subset X of U it is the case that |X| ≤ m− 1. Furthermore, for each extended subset
X of size i ≥ 1 we add at most m − i fresh elements to the domain of T to construct
(cid:4)
that do not belong to T is at most
T

. It follows that the number of elements in T

(cid:4)

(cid:6)|U|

(cid:7)
(m − i) ≤ (m − 1)2 · |U|m−1.

m−1(cid:5)

i=1

i

Therefore, it is the case that T

has at most |U| + (m − 1)2 · |U|m−1 elements.
Since |U| is bounded by n (which is the number of variables in Q) the number of
elements of T

is bounded by n + (m − 1)2nm−1.

(cid:4)

(cid:4)

In addition, the number of facts in T

equals the number of facts of T plus one
fact for each extended subset X of U . Since for each such X there is no tuple ¯t in a
relation of T with U¯t = X, the number of facts in T
is bounded by the number of
facts of the form R(¯t), where R ∈ σ and ¯t is a tuple of elements in U . This number
is bounded by l · |U|m, that is, by (cid:3) · nm.

(cid:4)

(cid:4)

We conclude that the CQ Q

whose tableau is (T

) satisﬁes all the required

(cid:4)

(cid:4)
, ¯x

(cid:4)(cid:4)

(cid:4)

C

C

(cid:4)
(¯x

conditions of the claim.
We continue now with the proof of Theorem 6.1. We start with the ﬁrst part
of it. Let Q(¯x) be a CQ over σ that has at least one hypergraph-based C-query
). Let l be the number of relations and m the maximum
contained in it, namely, Q
arity of a relation in σ, respectively. Deﬁne H
(Q) as the set of all CQs that are
hypergraph-based C-queries contained in Q and have at most |Q| + (m − 1)2 · |Q|m−1
variables and at most l · |Q|m joins, where |Q| denotes the number of variables of Q.
Clearly, H
(Q) is ﬁnite (up to renaming of variables). From Claim 6.2, it follows that
(Q) (with respect to ⊆). We
C
H
claim that ˜Q is a hypergraph-based C-approximation of Q. Assume for the sake of
contradiction that this is not the case. Then there exists a hypergraph-based C-query
P such that ˜Q ⊂ P ⊆ Q. Using Claim 6.2, there exists a hypergraph-based C-query
(cid:4)
(Q),
P
we have a contradiction with the maximality of ˜Q. Thus, ˜Q is a hypergraph-based
C-approximation of Q.
It easily follows from Claim 6.2 that each hypergraph-based C-approximation of
(Q). The second part of Theorem 6.1 follows directly

(Q) is not empty. Take a maximal element ˜Q in H

such that ˜Q ⊂ P ⊆ P

(Q). Since ˜Q ⊂ P

(cid:4) ⊆ Q and P

(cid:4) ∈ H

is in H

and P

C

C

C

C

(cid:4)

(cid:4)

Q is equivalent to a CQ in H
from this observation.

It is straightforward to check that the class of acyclic hypergraphs satisﬁes both
closure conditions, and that any constant homomorphism on a query Q produces an
acyclic query. Thus, we have the following.

Corollary 6.3. For every vocabulary σ, there exist two polynomials pσ and rσ
such that every CQ Q over σ has a hypergraph-based acyclic approximation of size at

most pσ(|Q|) that can be found in time 2rσ(|Q|).

In the speciﬁc case of acyclicity, this result (in fact with linear bounds) can also
be derived from the results of [5]. The general closure-based approach we have here
allows us to extend it further, to both hypertree width and generalized hypertree
width. First we recall the deﬁnitions [21]. A generalized hypertree decomposition of a
hypergraph H = (cid:4)V,E(cid:5) is a triple (cid:4)T, f, c(cid:5), where T is a rooted tree, f is a map from

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1112

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

E

, such that

T to 2V , and c is a map from T to 2

the subtree of T rooted at u.

• f (u) ⊆ (cid:8)
• (T, f ) is a tree decomposition of H;
c(u) holds for every u ∈ T .
A hypertree decomposition of H [20] is a generalized hypertree decomposition that
c(u) ∩ (cid:8){f (t) | t ∈ Tu} ⊆ f (u) holds for every u ∈ T , where Tu refers to
• (cid:8)
satisﬁes, in addition, the following property:
The width of a (generalized) hypertree decomposition (cid:4)T, f, c(cid:5) is maxu∈T |c(u)|.
The (generalized) hypertree width of H is the minimum width over all its (generalized)
hypertree decompositions. We denote by HTW(k) the class of hypergraphs with
hypertree width at most k, and slightly abusing notation, the class of CQs or tableaux
whose hypergraphs have hypertree width at most k. Similarly, we denote by GHTW(k)
the class of hypergraphs, CQs, and tableaux of generalized hyper treewidth at most
k. Obviously, HTW(k) ⊆ GHTW(k) for each k ≥ 1.
It is shown in [20] that a
hypergraph H is acyclic iﬀ its hypertree width is 1. That is, AC = HTW(1), and thus
AC ⊆ GHTW(1).

The key result of [20] is that for each ﬁxed k, CQs from HTW(k) can be evaluated
in polynomial time with respect to combined complexity. Notably, the same holds
for the class GHTW(k) for each ﬁxed k [21]. There is, however, a crucial diﬀerence
between the two notions: Verifying whether HTW(H) ≤ k, for a given hypergraph
H and a ﬁxed k ≥ 1, can be solved in polynomial time [20], while verifying whether
GHTW(H) ≤ k, for any k ≥ 3, is NP-complete [22].

To apply the existence result, we need to check the closure conditions for hypergraphs 
of ﬁxed hypertree width. It turns out they are satisﬁed.

Lemma 6.4. For each k, the class HTW(k) is closed under induced subhypergraphs

(cid:4)

(cid:4)

(cid:4)

(u) = f (u) for each node u in T
(cid:4)

(ue) = f (ue) ∪ V

We consider edge extensions ﬁrst. Let H(cid:4)

and edge extensions. The same holds for the class GHTW(k).
Proof. We only prove it for HTW(k). It will be clear from the proof that the same
argument applies to GHTW(k). Let H = (cid:4)V,E(cid:5) be a hypergraph of hypertree width
at most k and (cid:4)T, f, c(cid:5) a hypertree decomposition of H of width at most k.
be a hypergraph obtained from H by
. Thus, the set of nodes of H(cid:4)
is V ∪ V
(cid:4)
(cid:4)
extending hyperedge e with new nodes V
and its set of hyperedges is (E \ {e}) ∪ {e
(cid:4)}. First, pick an arbitrary node ue in T
that satisﬁes e ⊆ f (ue) and is at minimal distance to the root (such element ue exists
because (cid:4)T, f(cid:5) is a tree decomposition of H). Let T
be the tree that is obtained from
(cid:4) → 2(V ∪V
(cid:2)
)
T by adding a new child z to ue in T . We then deﬁne a function f
(cid:4)
(z) = e
as follows: f
,
if e ∈ c(ue), and f
(cid:4)
and, ﬁnally, f
(ue) = f (ue) otherwise. We also
(cid:4)}, and for each u ∈ T
(z) = {e
(cid:4) → 2(E\{e})∪{e
(cid:2)}) such that c
(cid:4)
(cid:4)
deﬁne a function c
(u) = c(u) if e /∈ c(u), and c
(u) = (c(u) \ {e})∪ {e
(cid:4)}
(cid:4)
(cid:4)
that is not z it is the case that c
(cid:4)(cid:5)
(cid:4)(cid:5) is at most k. We prove next that (cid:4)T
otherwise. Clearly, the width of (cid:4)T
(cid:4)
(cid:4)
(cid:4)
, f
, c
is a hypertree decomposition of H(cid:4)
.
First, we shall prove that (cid:4)T
(cid:4)
, f
. Consider a
, then there exists a node u in T such that d ⊆ f (u)
hyperedge d in H(cid:4)
(because (cid:4)T, f(cid:5) is a tree decomposition of H). By deﬁnition, d also belongs to f
(u).
(z). This shows that each hyperedge of H(cid:4)
(cid:4)
If d = e
is contained in
, i.e., v ∈ V ∪ V
(cid:4)
(cid:4)
(cid:4)
(u
in T
f
If
v /∈ e
such that v ∈ f
(u) belongs to
(u). Thus, since (cid:4)T, f(cid:5) is a tree decomposition
T and satisﬁes that v ∈ f (u) iﬀ v ∈ f
(cid:4)
of H, we conclude that {u ∈ T
(cid:4) | v ∈ f
(u)} is a connected subset of T
. If v ∈ e, then
(cid:4)
(cid:4)

, c
(cid:4)(cid:5) is a tree decomposition of H(cid:4)

, then d ⊆ f
) for some node u
= e ∪ V
(cid:4)

. Consider now a node v of H(cid:4)

, then, by deﬁnition, each node u of T

that is neither z nor ue, f

. If d (cid:6)= e

(cid:4)

: T

(cid:4)

, f

(cid:4)

(cid:4)

.

(cid:4)

: T

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1113

a similar argument shows that {u ∈ T

(cid:4) | v ∈ f

(cid:4)

(u)} is exactly

{u ∈ T | v ∈ f (u)} ∪ {z}.

.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

c

c

f

. We

(z) = e

(cid:4) | v ∈ f

(u) for each node u in T

. Finally, if v ∈ V

not in c(ue)). For u diﬀerent from z and ue, we have by deﬁnition that f

(cid:4)(cid:5) is a tree decomposition of H(cid:4)
(ue) ⊆ (cid:8)

Since z is a leaf of ue and, by deﬁnition, v ∈ f (ue), we conclude from the fact that
(cid:4)T, f(cid:5) is a tree decomposition of H that {u ∈ T
(cid:4) | v ∈ f
(u)} is a connected subset
, then {u ∈ T
(u)} is the single node z if e /∈ c(ue),
(cid:4)
of T
or the single edge {ue, z} if e ∈ c(ue), both of which are connected subsets of T
(u) ⊆ (cid:8)
conclude that (cid:4)T
, f
(cid:4) ⊆ (cid:8)
(cid:4)
We prove next that f
. First of all, by deﬁnition
have that f (ue) ⊆ (cid:8)
(z) = {e
(cid:4)}. Also, since (cid:4)T, f, c(cid:5) is a hypertree decomposition of H, we
(cid:4)
(cid:4)
(ue) (regardless of whether e is or is
and, by hypothesis, f (u) ⊆ (cid:8)
(u) = f (u),
(u) ⊆ (cid:8)
c(u) ⊆ (cid:8)
c(u). But for each u in T
that is neither z nor ue we
(cid:8)
(u)∩(cid:8){f
(cid:4)
(u) holds for every u ∈ T
} ⊆ f
(cid:4)
(cid:4)
(cid:4)
c
We prove ﬁnally that
.
such that ue /∈ T
(cid:4)
(cid:4)
Consider ﬁrst a node u in T
u. If u = z, then the property holds
(t) | t ∈ T
, and {f
(z) = {e
(cid:4)}, f
} = {f
(z)}. Suppose then
(cid:4)
(cid:4)
(cid:4)
(cid:4)
(z) = e
trivially since c
that u (cid:6)= z. By deﬁnition, f (x) = f
(x) for each x ∈ T
(cid:4)
(cid:4)
(cid:4)
z
u, and thus no element in V
(cid:9)
(cid:9)
(cid:9)
belongs to f
{f (t) | t ∈ Tu}.
{f

(x) for some x ∈ T
(cid:4)
(cid:9)

(u), and thus f
(t) | t ∈ T
(cid:4)
u

(cid:4)
u. It follows that

have by deﬁnition that

(t) | t ∈ T

c(ue), and thus f

c(u) ∩

(u) ∩

} =

(cid:8)

(u).

c

c

c

c

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)
u

(cid:4)

(u), because f (u) = f

But the latter is contained in f (u) because (cid:4)T, f, c(cid:5) is a hypertree decomposition of
H, and thus in f
e ∈ c(ue), we have by deﬁnition that
(t) | t ∈ T
(cid:4)
u

such that ue ∈ T
(cid:4) ∪(cid:2)(cid:9)

(cid:9)
{f (t) | t ∈ Tu}(cid:3)

(cid:4)
u. Assume ﬁrst that u = ue. If

Consider now a node u in T

(cid:9)
{f

} = V

c(u) ∩

(u) ∩

(cid:9)

(u).

c

(cid:4)

(cid:4)

(cid:4)

(cid:4)

.

But since (cid:4)T, f, c(cid:5) is a hypertree decomposition of H we have that the latter is contained 
in V
c(u)
and thus

(cid:4) ∪ f (u), which by deﬁnition is f
(cid:4)
(cid:9)
(u) does not contain any element in V
c

(u). If e /∈ c(ue), then
(cid:4)
(cid:9)

c
. We conclude that

(cid:9)

(u) =

(cid:8)

(cid:4)

(cid:8)

(cid:8)

(cid:9)
{f

(cid:4)

(u) ∩

c

(cid:4)

(t) | t ∈ T

} =

(cid:4)
u

{f (t) | t ∈ Tu}.

(cid:4)
c(u) ∩

(cid:4)

(u), because f (ue) = f

But the latter is contained in f (u) because (cid:4)T, f, c(cid:5) is a hypertree decomposition of
H, and therefore in f
(ue). Finally, assume that u (cid:6)= ue.
c(u) ∩ (cid:8){f (t) | t ∈ Tu}. But (cid:4)T, f, c(cid:5) is a
that e ⊆ (cid:8)
Then necessarily e /∈ c(u). Assume otherwise. Then since e ⊆ f (ue) we would have
hypertree decomposition of H, and thus e ⊆ f (u), which is a contradiction with the
(cid:4) ∩(cid:8)
minimality of ue with respect to distance to the root of T . Then e /∈ c(u), implying

c(u) ∩ f (ue), and thus in

(cid:8)

(cid:4)

that V

c

(u) = ∅. Therefore,
(cid:4)
(cid:9)

(cid:9)
{f

(cid:4)

(u) ∩

c

(cid:4)

(t) | t ∈ T

} =

(cid:4)
u

c(u) ∩

(cid:9)

(cid:9)
{f (t) | t ∈ Tu}.

But the latter is contained in f (u) because (cid:4)T, f, c(cid:5) is a hypertree decomposition of
H, and therefore in f
(cid:4)(cid:5) is
a hypertree decomposition of H(cid:4)
(cid:4) |
e ∈ E}(cid:5) be an induced subhypergraph of H for V
be

We now consider closure under induced subhypergraphs. Let H(cid:4)
(cid:4) ⊆ V . Let also T

(u). We conclude then that (cid:4)T
= (cid:4)V
(cid:4)
(cid:4)
(cid:4)
, f

, f
, c
,{e ∩ V
(cid:4)
, and c

(u), because f (u) = f

(cid:4)

(cid:4)

(cid:4)

(cid:4)

.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1114

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

, c

it is the case that f

(u) = f (u) ∩ V
(cid:4)
,
(cid:4)(cid:5) is at most k. We

= T , and for each u ∈ T
(cid:4)
(cid:4) | e ∈ c(u)}. Clearly, the width of (cid:4)T
(cid:4)
, f

deﬁned as follows: T
(u) = {e ∩ V
(cid:4)
and c
, f
(cid:4)(cid:5) is a hypertree decomposition of H(cid:4)
prove next that (cid:4)T
(cid:4)
, c
.
We prove ﬁrst that (cid:4)T
(cid:4)(cid:5) is a tree decomposition of H(cid:4)
(cid:4)
, f
. Consider a hyperedge
d in H(cid:4)
for some e ∈ E. Since (cid:4)T, f(cid:5) is a tree decomposition of H
. Then d = e ∩ V
(cid:4)
there is u ∈ T such that e ⊆ f (u). It follows that d = e∩ V
(cid:4)
(u). Let
= f
v be a node in H(cid:4)
(u)} is exactly
. It is easy to see that {u ∈ T
the same set as {u ∈ T | v ∈ f (u)}. Since (cid:4)T, f(cid:5) is a tree decomposition of H we
(u)} is a connected subset of T
conclude that {u ∈ T
(u) ⊆ (cid:8)
For each u ∈ T
(u) = f (u) ∩ V
we have by deﬁnition that f
(cid:8)
c(u) ∩ V
(cid:4)
(cid:4)
f
(u) ⊆ (cid:8)
(u) ∩ (cid:8){f
tree decomposition of H). But the latter is precisely
c(u) ∩ (cid:8){f (t) | t ∈ Tu} ∩ V
(u) for each u ∈ T
(cid:4)
(cid:4)
f
(cid:4)
nition equal to the set
decomposition of H the latter is contained in f (u) ∩ V
(cid:4)(cid:5) is a hypertree decomposition of H(cid:4)
We conclude that (cid:4)T

, and thus
c(u) from the fact that (cid:4)T, f, c(cid:5) is a hyper-
(u), which implies that
} is by deﬁ-
(t) | t ∈ T
(cid:4)
. Since (cid:4)T, f, c(cid:5) is a hypertree
(cid:4)
(u) by deﬁnition.
, which is f

(cid:4)

, i.e., v ∈ V
(cid:4) | v ∈ f
(cid:4)
(because f (u) ⊆ (cid:8)
(cid:4)
(cid:8)

(cid:4)

(cid:4) ⊆ f (u)∩ V
(cid:4) | v ∈ f
(cid:4)
(cid:4)

. In addition,

, f

, c

(cid:8)

(cid:4)

(cid:4)

(cid:4)

(cid:4)
u

(cid:4)

.

(cid:4)

c

.

(cid:4)

(cid:4)

c

c

Note that the query Qtrivial from section 4.1 is in HTW(k) and GHTW(k). This
gives the desired result about the existence of approximations within HTW(k) for
every k.

Corollary 6.5. For every vocabulary σ, there exist two polynomials pσ and
rσ such that every CQ Q over σ has a hypergraph-based HTW(k)-approximation or
GHTW(k)-approximation of size at most pσ(|Q|) that can be found in time 2rσ(|Q|) for
every k ≥ 1.

Example 6.6. Consider a Boolean query

Q() :– R(x1, x2, x3), R(x3, x4, x5), R(x5, x6, x1)

over a schema with one ternary relation.
If we had a binary relation instead and
omitted the middle attribute, we would obtain a query whose tableau is a cycle of
length 3, thus having only trivial approximations. However, going beyond graphs
lets us ﬁnd nontrivial acyclic approximations. In fact this query has 3 nonequivalent
acyclic approximations (all queries below are minimized):

• With fewer joins than Q:

• With as many joins as Q:

(cid:4)
1() :– R(x, y, x).

Q

(cid:4)
2() :– R(x1, x2, x3), R(x3, x4, x2), R(x2, x6, x1).

Q

• With more joins than Q:

(cid:4)
3() :– R(x1, x2, x3), R(x3, x4, x5), R(x5, x6, x1), R(x1, x3, x5).

Q

7. Conclusions. We have concentrated on approximations of conjunctive
queries that are guaranteed to return correct answers. Given the importance of acyclic
CQs and very good complexity bounds for them, we have focused on acyclic approximations,
 but we also provided results on approximations within classes of bounded
treewidth and bounded hypertree width. We have proved the existence of approximations 
and showed they can be found with an acceptable computational overhead, and
that their sizes are at most polynomial in the size of the original query and sometimes
are bounded by the size of the original query.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1115

In this work we only dealt with the qualitative approach to approximations; in the
future we would like to study quantitative guarantees as well by deﬁning measures
showing how diﬀerent from the original query approximations are. One approach
is to ﬁnd probabilistic guarantees for approximations. Note that such guarantees
have been studied for queries from expressive languages (e.g., with ﬁxed points or
inﬁnitary connectives) [1, 27], with typical results showing that queries are equivalent
to those from simpler logics (e.g., ﬁrst-order logic) almost everywhere. One possibility
is to specialize these results to much weaker logics, e.g., to CQs and their tractable
subclasses.

We also plan to study other notions of approximations that are not constrained
to return correct results only. These include overapproximations, which return all
correct results, and arbitrary approximations that simply look for maximal elements

in the preorder (cid:3)Q. Even the most basic problems related to those notions of approximations,
 such as existence and complexity, seem challenging.

8. Appendix: Proof of Theorem 4.12. The class TW(1) over graphs contains
all acyclic directed graphs, i.e., directed graphs whose underlying undirected graph
contains no cycles. It thus suﬃces to show that the following problem is DP-complete:

Problem: Graph Acyclic Approximation
Input:
a digraph G, an acyclic digraph T .
Question: Is G → T, and is there no acyclic digraph T

(cid:4)

such that G → T

(cid:4) (cid:2)(cid:2) T ?

The Exact Four Colorability problem is deﬁned as follows: Given a graph
G, decide if G is 4-colorable but not 3-colorable.
It is known that this problem
is DP-complete [38]. We deﬁne a polynomial time reduction from Exact Four
Colorability to Graph Acyclic Approximation.

We use several notions, such as oriented paths, cycles, heights, and levels, that
were deﬁned in the proof of Proposition 4.4. The proof requires some preparation.

Consider the oriented paths Pi = 0i+11011−i for each 1 ≤ i ≤ 9. Observe that all

these oriented paths are incomparable cores and have net length 11. We have the
following.

Pij → Pi, Pij → Pj, and Pij (cid:6)→ Pk for each 1 ≤ k ≤ 9 with k (cid:6)= i and k (cid:6)= j.

Claim 8.1. For each 1 ≤ i < j ≤ 9, there exists an oriented path Pij such that
Proof. We take Pij = 0i+1100j−i1011−j. Using Lemma 4.5 it can be veriﬁed that
Claim 8.2. For each 1 ≤ i < j < k ≤ 9, there exists an oriented path Pijk such
that Pijk → Pi, Pijk → Pj, Pijk → Pk, and Pijk (cid:6)→ P(cid:4) for each 1 ≤ (cid:3) ≤ 9 with (cid:3) (cid:6)= i,
(cid:3) (cid:6)= j, and (cid:3) (cid:6)= k.
Proof. We take Pijk = 0i+1100j−i100k−j1011−k. Using Lemma 4.5 it can be

the conditions are satisﬁed.

veriﬁed that the conditions are satisﬁed.

Next we deﬁne a digraph Q

∗

(depicted in Figure 6) as follows: Consider the

balanced cycle (a1, a2, . . . , a8, a1) deﬁned by the string 01010101. For each 1 ≤ i ≤ 8,
we add a disjoint copy of Pi. If i is odd, we identify ai with the terminal node of Pi;
otherwise, we identify ai with the initial node of Pi. Finally, we add two new nodes
x and y and two new edges: one from x to the initial node of the copy of P1, and
∗
another one from the terminal node of the copy of P8 to y. The resulting digraph Q
and its levels are depicted in Figure 7. Notice that Q
is balanced and that its height,
hg(Q
with level 0 and
25, respectively.

), is 25. Moreover, the nodes x and y are the only ones in Q

∗

∗

∗

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1116

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

x

P1

P3

P2

a1

P8

a3

P4

a2

a4

a5

P5

a8

a6

a7

P6

y

P7

Fig. 6. The digraph Q∗

.

1

P3

12

13

13

24

P4

1

12

P5

13

13

12

P6

24

P2

12

P8

x

0

P1

1

24

y

25

24

P7

1

Fig. 7. The digraph Q∗

and some of its levels.

∗

We also deﬁne acyclic digraphs T1, T2, T3, and T4 as follows: Each Ti, for 1 ≤ i ≤
4, is obtained from Q
by identifying some speciﬁc nodes. For T1 we identify a1, a2,
and a3 with a7, a6, and a5, respectively. In the case of T2 we identify a8, a1, and a2
with a6, a5, and a4, respectively. For T3 we identify a7, a8, and a1 with a5, a4, and
a3, respectively. Finally, for T4 we identify a6, a7, and a8 with a4, a3, and a2. Note
that for each 1 ≤ i ≤ 4, hg(Ti) = 25 and the nodes xi and yi are the only ones in Ti

with level 0 and 25, respectively, as depicted in Figures 8 and 9.

Since the Ti’s are acyclic, they are by deﬁnition balanced. Using Lemma 4.5
and the incomparability of the Pi’s, it easily follows that T1, T2, T3, and T4 are
∗ hi−→ Ti for all 1 ≤ i ≤ 4, where
incomparable cores. Furthermore, observe that Q

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1117

x1

0

1

1

1

1

P1

P7

P3

P5

y1

25

P8

24

13

z1

12

13

12

z2

z3

z4

13
z5

P4

24

P2

P6

24

24

Fig. 8. The digraph T1 and some of its levels.

0

x2

1

1

P5

P1
13

P7

12

13

1

P8

12

P6

P2

24

24

24

25

y2

The digraph T2

1

12

P3

1

24

P4

24

1

P3

1

P7

0

x3

1

1

1

1

P5
13

P6

P7

P3

P1

13

13

P2

24

12

P8

12
P4

24

24

25

y3
The digraph T3

x4
0

P5

12

13

13

12

P1

1

P4

24

12
P6

P8

24

25

24

y4

P2

24

The digraph T4

Fig. 9. The digraphs T2, T3, and T4 and some of its levels.

hi is the homomorphism naturally deﬁned by the identiﬁcation of nodes we used to
construct the Ti’s. Note that for each 1 ≤ i ≤ 4, hi is a surjective homomorphism,
i.e., Im(hi) = Ti. Even more, we have the following.

Claim 8.3. For each 1 ≤ i ≤ 4, hi is the unique homomorphism from Q

∗

In particular, any homomorphism from Q

Proof. Let h be a homomorphism that witnesses Q

to Ti.
∗ → T1. We shall prove that
h = h1. Since Q
and T1 are balanced, we have that h preserves levels (Lemma 4.5).
Thus, either h(a8) = z1, h(a8) = z3, or h(a8) = z5. If h(a8) = z3, then P8 → P2 or
P8 → P6, which is impossible since the Pi’s are incomparable. Similarly, if h(a8) = z5,
then P8 → P4, which is also not possible. It follows that h(a8) = z1 = h1(a8). Using

to Ti is surjective for each 1 ≤ i ≤ 4.

∗

∗

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1118

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

P9

P9

x5

P1

P8

Fig. 10. The digraph T5.

Xij

p1

P1

P8

Fig. 11. The structure of the Tij ’s.

y5

p2

the same argument, we can prove that h(c) = h1(c) for each other element c of Q
For T2, T3, and T4 the argument is analogous.
A key property of the Ti’s is the following.
Claim 8.4. For each 1 ≤ i ≤ 4, Q

∗ → Ti and there is no acyclic T

such that

(cid:4)

∗

.

∗ → T

Q

(cid:4) (cid:2)(cid:2) Ti.

(cid:4)

(cid:4)

g−→ T1 and T1 (cid:6)→ T

Proof. We only prove the claim for i = 1. For i = 2, 3, 4 the proof is analogous.
 By contradiction, assume that there exists an acyclic digraph T
such that
∗ h−→ T
Q
. If h(a1) = h(a7), h(a2) = h(a6), and h(a3) = h(a5),
using Claim 4.8, it follows that T1 → T
, which is a contradiction. Thus, we have
that either h(a1) (cid:6)= h(a7), h(a2) (cid:6)= h(a6), or h(a3) (cid:6)= h(a5). Using Claim 8.3, we
have that g ◦ h = h1. Notice by deﬁnition that the sets {h1(a8)}, {h1(a1), h1(a7)},
{h1(a2), h1(a6)}, {h1(a3), h1(a5)}, and {h1(a4)} are mutually disjoint, and hence the
sets {h(a8)}, {h(a1), h(a7)}, {h(a2), h(a6)}, {h(a3), h(a5)}, and {h(a4)} must be mutually 
disjoint as well. Since h(a1) (cid:6)= h(a7), h(a2) (cid:6)= h(a6), or h(a3) (cid:6)= h(a5), neces-

(cid:4)

(cid:4)

sarily T

has an oriented cycle, which is a contradiction.

(cid:4)

We deﬁne an acyclic directed graph T5 as follows: Consider the disjoint union
of P1 and P8. Add two new nodes x5 and y5 and three new edges: from x5 to the
initial node of P1, from the terminal node of P1 to the initial node of P8, and from
the terminal node of P8 to y5. Finally, add two disjoint copies of P9 and identify the
terminal node of one copy with the terminal node of P1, and the initial node of the
other copy with the initial node of P8. The resulting graph T5 is depicted in Figure 10.
Since T5 is acyclic, it is also balanced. Using Lemma 4.5 and the incomparability
of the Pi’s, it easily follows that T5 is incomparable with T1, T2, T3, T4, and Q
Claim 8.5. For each (i, j) ∈ {(1, 5), (2, 5), (3, 5), (1, 2), (1, 3), (2, 3)}, there exists
an acyclic digraph Tij such that Tij → Ti, Tij → Tj, and Tij (cid:6)→ Tk for 1 ≤ k ≤ 5 with
k (cid:6)= i and k (cid:6)= j.

∗

.

Proof. Consider the oriented path P constructed as follows: Take the disjoint
union of P1 and P8. Add two new nodes p1 and p2, and three new edges: from p1 to
the initial node of P1, from the terminal node of P1 to the initial node of P8, and from
the terminal node of P8 to p2. Each Tij is obtained from P by adding a disjoint copy
of a speciﬁc path Xij and identifying the terminal node of Xij with the terminal node
of P1, as depicted in Figure 11. The Xij’s are X15 = P79, X25 = P59, X35 = P39,
X12 = P57, X13 = P37, and X23 = P35. Using Lemma 4.5 and Claim 8.1 it can be
proved that these Tij’s satisfy the required conditions.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1119

p1

P1

P8

p2

Xijk

Fig. 12. The structure of T245 and T345.

Claim 8.6. For each (i, j, k) ∈ {(1, 2, 5), (2, 4, 5), (3, 4, 5)}, there exists an acyclic
digraph Tijk such that Tijk → Ti, Tijk → Tj, Tijk → Tk, and Tijk (cid:6)→ T(cid:4) for 1 ≤ (cid:3) ≤ 5,
(cid:3) (cid:6)= i, (cid:3) (cid:6)= j, and (cid:3) (cid:6)= k.

Proof. Consider the oriented path P as in the proof of Claim 8.5. The digraph
T125 is obtained from P by adding a disjoint copy of P579 and identifying the terminal
node of P579 with the terminal node of P1. The others Tijk’s are obtained from P
by adding a disjoint copy of a path Xijk and identifying the initial node of Xijk with
the initial node of P8. The Xijk’s are X245 = P269 and X345 = P249; see Figure
12. From Lemma 4.5 and Claim 8.2, it follows that these Tijk’s satisfy the required
conditions.

We introduce some notation. We work with digraphs that have an initial and a
terminal node, which are simply two distinct distinguished elements in the digraph.
Consider a digraph G with two distinguished nodes i1 and t1, which are its initial
node and terminal node, respectively. Similarly, consider a digraph H with nodes i2
and t2 distinguished as initial node and terminal node, respectively. We deﬁne the
concatenation of G and H, denoted G·H, to be the digraph obtained from the disjoint
union of G and H identifying t1 with i2. The initial and terminal nodes of G · H are
−1 to be the digraph obtained from G by
i1 and t2, respectively. Finally, we deﬁne G
switching the roles of the initial and terminal nodes, that is, the initial node of G is
t1 and the terminal one is i1.
For each 1 ≤ i ≤ 5, we also assume that xi and yi are the initial node and terminal
node of Ti, respectively. Similarly, for each Tij and Tijk deﬁned as in Claims 8.5 and
8.6, respectively, we assume its initial and terminal nodes to be the only nodes in the
respective graphs with level 0 and 25, respectively. In all ﬁgures, an edge uv labeled
with a digraph G with initial node i and terminal node t represents the digraph
constructed as follows: delete the arc uv, add a disjoint copy of G, and identify i with
u and t with v.

Let us assume now that the initial node of Q

is x and its terminal node is y.

∗

−1
5

, T3 · T

−1
5

−1
5

−1
5

, T2 · T

of T1 · T

Let T be the acyclic digraph constructed as follows: Consider the disjoint union
and identify all of their initial nodes into
a single new node v. Observe that hg(T ) = 25, that the only nodes of T with level 0
are v, u1, u2, u3, and u4, and that the only nodes of T with level 25 are t1, t2, t3, and
t4. This is shown in Figure 13.

, and T4 · T

digraph T

∗

with two distinguished nodes a and b such that the following hold:

Now we recall the notion of (i, j)-chooser from [26].
Definition 8.7. Let X = {1, 2, 3} and i, j ∈ X be indices. An (i, j)-chooser is a
• For every homomorphism h : T
∗ → T , we have h(a) = t1 and h(b) (cid:6)= ti, or
h(a) = t2 and h(b) (cid:6)= tj.
∗ → T such that
• For every k ∈ X with k (cid:6)= i, there is a homomorphism h : T
∗ → T such that
• For every k ∈ X with k (cid:6)= j, there is a homomorphism h : T

h(a) = t1 and h(b) = tk.

h(a) = t2 and h(b) = tk.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1120

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

0

u4

T5

25

t4

0

u1

T5

25

t1

T4

T3

25

0

v

T1

T2

25

t2

T5

t3

T5

S13

S21

S32

0

u3

0

u2

Fig. 13. The digraph T and some of its levels.

T12

T15

T35

T25

T15

T35

T25

T23

a

a

a

T12

T12

T15

T35

T25

T35

b

T13

T25

T35

T15

T25

T35

T15

b

b

Fig. 14. The choosers S13, S21, and S32.

An extended (i, j)-chooser is deﬁned exactly as in Deﬁnition 8.7, but this time we

consider X = {1, 2, 3, 4}.

Claim 8.8. There exists a (1, 3)-chooser S13, a (2, 1)-chooser S21, and a (3, 2)-

chooser S32.

Proof. The digraphs S13, S21, and S32 are shown in Figure 14. Proving that they
are indeed the corresponding choosers is not hard (and one can in fact mimic the
proof of Lemma 4 in [26]).

We rename the nodes a and b in S13, S21, and S32 to a1, b1, a2, b2, and a3, b3,

respectively.

chooser ˜S34.

Claim 8.9. There exists an extended (2, 1)-chooser ˜S21 and an extended (3, 4)-
·T15.
Proof. We deﬁne ˜S21 = T12·T
For ˜S21 and ˜S34, we denote by a the terminal node of their respective copies of T12,
and by b their respective terminal nodes, as illustrated in Figures 15 and 16.
Consider ﬁrst a homomorphism h : ˜S21 → T . It is not hard to see that either
h(a) = t1 or h(a) = t2. Assume ﬁrst that h(a) = t1. Then either h(x1) = u1 or

·T345 and ˜S34 = T12·T

·T245·T

−1
125

−1
25

·T35·T

−1
15

−1
35

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1121

T12

T125

T345

a

x1

b

Fig. 15. The extended (2, 1)-chooser ˜S21.

T12

T25

T35

T15

T245

T35

T15

a

x1

x2

x3

x4

x5

b

Fig. 16. The extended (3, 4)-chooser ˜S34.

h(x1) = v.
If h(x1) = u1, then h(b) = t1. If h(x1) = v, then either h(b) = t3 or
h(b) = t4. Thus, if h(a) = t1, then h(b) (cid:6)= t2, and all the following combinations are

possible:

(i) h(a) = t1, h(b) = t1;

(ii) h(a) = t1, h(b) = t3;

and

(iii) h(a) = t1, h(b) = t4.

Assume, on the other hand, that h(a) = t2. Then either h(x1) = u2 or h(x1) = v. If
h(x1) = u2, then h(b) = t2. If h(x1) = v, then either h(b) = t3 or h(b) = t4. Thus, if
h(a) = t2, then h(b) (cid:6)= t1, and all the following combinations are possible:

(i) h(a) = t2, h(b) = t2;

(ii) h(a) = t2, h(b) = t3;

and

(iii) h(a) = t2, h(b) = t4.

Therefore, ˜S21 is an extended (2, 1)-chooser.

Consider now a homomorphism h : ˜S34 → T . Again, either h(a) = t1 or h(a) = t2.
Assume ﬁrst that h(a) = t1. Then h(x1) = u1 and h(x2) = t1, and we have either
h(x3) = u1 or h(x3) = v. If h(x3) = u1, then h(x4) = t1, h(x5) = u1, and h(b) = t1.
If h(x3) = v, then h(x4) = t2 or h(x4) = t4. If h(x4) = t2, then h(x5) = u2 and
h(b) = t2. If h(x4) = t4, then h(x5) = u4 and h(b) = t4. Thus, if h(a) = t1, then
h(b) (cid:6)= t3, and all the following combinations are possible:

(i) h(a) = t1, h(b) = t1;

(ii) h(a) = t1, h(b) = t2;

and

(iii) h(a) = t1, h(b) = t4.

Assume, on the other hand, that h(a) = t2. Then we have either h(x1) = u2 or
h(x1) = v. If h(x1) = u2, then h(x2) = t2, h(x3) = u2, h(x4) = t2, h(x5) = u2, and
h(b) = t2. If h(x1) = v, then h(x2) = t3, h(x3) = u3, and h(x4) = t3, and we have
either h(x5) = u3 or h(x5) = v. If h(x5) = u3, then h(b) = t3. If h(x5) = v, then
h(b) = t1. Thus, if h(a) = t2, then h(b) (cid:6)= t4, and all the following combinations are

possible:

(i) h(a) = t2, h(b) = t1;

(ii) h(a) = t2, h(b) = t2;

and

(iii) h(a) = t2, h(b) = t3.

We conclude that ˜S34 is an extended (3, 4)-chooser.

(cid:4)

Next we borrow techniques from [26] and deﬁne an acyclic graph T

as follows:
We take the disjoint union of S13, S21, and S32 and identify their respective terminal
nodes b1, b2, and b3 into a new node b (see Figure 17). The following claim will be
useful.
(cid:4) → T such that h(a1) = h(a2) =
h(a3). Furthermore, for any triple (ti, tj, tk) ∈ {t1, t2}3 \ {(t1, t1, t1), (t2, t2, t2)} there
(cid:4) → T such that h(a1) = ti, h(a2) = tj, and h(a3) = tk.

Claim 8.10. There is no homomorphism h : T

exists a homomorphism h : T

Proof. The proof is exactly that of Lemma 5 in [26].

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1122

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

a1

a3

S13

S32

b

a2

S21

Fig. 17. The digraph T (cid:3)

.

(cid:4)

, namely, T

1, a1

2, a1

21 and b2

(cid:4)
1 and T

34, ˜S2
34 and bi
(cid:4)

34 with p, and b3
i . The resulting digraph T

3, and b1, respectively, and the nodes a1, a2, a3, and b in T

Next, we construct our main gadget ˜T : Let p and q be two fresh nodes. We add
(cid:4)
two disjoint copies of T
2. We rename the nodes a1, a2, a3, and b in
(cid:4)
(cid:4)
1 to a1
1, a2
2, a2
2 to a2
3,
T
and b2, respectively. We then add three disjoint copies of ˜S21, namely, ˜S1
21, ˜S2
21, and
21, and for each 1 ≤ i ≤ 3 we rename the nodes a and b in ˜Si
˜S3
21 to ai
21 and bi
21,
respectively. Afterwards, we identify the nodes b1
21 with p, and b3
21 with q.
We also identify, for each 1 ≤ i ≤ 3, the node ai
21 with a1
i . Analogously, we add three
34, and for each 1 ≤ i ≤ 3 we rename
disjoint copies of ˜S34, namely, ˜S1
34, and ˜S3
the nodes a and b in ˜Si
34 to ai
34, respectively. We then identify the vertices
34 with q. Finally, for each 1 ≤ i ≤ 3, we identify the node
34 and b2
b1
ai
34 with a2
Claim 8.11. There is no homomorphism h : ˜T → T such that h(p) = h(q).
Furthermore, for any pair (ti, tj) ∈ {t1, t2, t3, t4}2 \ {(t1, t1), (t2, t2), (t3, t3), (t4, t4)}
there exists a homomorphism h : ˜T → T such that h(p) = ti and h(q) = tj.
Proof. Assume, for the sake of contradiction, that there exists h : ˜T → T such that
h(p) = h(q). Since ˜S21 and ˜S34 are extended choosers, either h(a1
3) or
h(a2
3), which contradicts Claim 8.10. We only prove the second part
of the claim for the pair (t1, t2), all other cases being similar. We deﬁne h : ˜T → T
in such a way that h(p) = t1 and h(q) = t2. We start by deﬁning h(a1
1) = t1,
3) = t2. We then extend h to the disjoint copies of ˜S21 in ˜T using
h(a1
(cid:4)
the deﬁnition of extended chooser. Also, we extend h to T
1 using Claim 8.10. If we
3)) to be any triple in {t1, t2}3 \ {(t1, t1, t1), (t2, t2, t2)}, then
choose (h(a2
it is easy to extend h to the disjoint copies of ˜S34 in ˜T . Finally, using Claim 8.10 we
extend h to T

is shown in Figure 18.

2) = t1, and h(a1

1) = h(a1

1 ≤ i ≤ 4. Abusing notation, we will say that Ti · T
Ti · T
T1 · T

for each
is a subgraph of T , or write
⊆ T for 1 ≤ i ≤ 4. Let Z be the subgraph of T , deﬁned by the union of
, T2 · T
. From the proofs of Claims 8.11 and 8.9, we obtain

Note that the digraph T contains as a subgraph a copy of Ti · T
−1
−1
5
5
Corollary 8.12. For each pair (ti, tj) ∈ {t1, t2, t3}2 \ {(t1, t1), (t2, t2), (t3, t3)}
there exists a homomorphism h : ˜T → T such that h(p) = ti, h(q) = tj, and the image

, and T3 · T

the next corollary.

−1
5

−1
5

−1
5

−1
5

1), h(a2

2), h(a2

2) = h(a1

1) = h(a2

2) = h(a2

(cid:4)
2.

of h is contained in Z.
We can now deﬁne the reduction from Exact Four Colorability to Graph
Acyclic Approximation: Given an undirected graph G = (cid:4)V, E(cid:5), the output of our
reduction is the instance (ϕ(G), T ), where ϕ(G) is a digraph and T is the directed

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1123

p

˜S21

˜S21

˜S34

˜S34

a1
1

a1
3

S13

S32

b1

S21

a1
2

a2
1

a2
3

S13

S32

b2

S21

a2
2

Fig. 18. The gadget ˜T .

˜S21

q

˜S34

∗

with v0, the terminal node of Q

∗

acyclic graph we deﬁned before. The digraph ϕ(G) is constructed as follows: The
node set of ϕ(G) is V . For each edge {u, u
(cid:4)} ∈ E, we add a new disjoint copy of ˜T
(cid:4)
and identify the node p in ˜T with u and the node q in ˜T with u
. We then add a new
node v0. For each node u ∈ V we add new disjoint copies of Q
∗
and T5 (as deﬁned
before) and identify the initial node of Q
with u,
and the terminal node of the copy of T5 with u. Figure 19 shows the graph ϕ(G) for
a particular graph G. Clearly, the reduction can be computed in polynomial time in
the size of G. We prove next that G is 4-colorable but not 3-colorable iﬀ ϕ(G) → T,
but there is no proper subgraph S of T such that ϕ(G) → S.
First, suppose that G = (cid:4)V, E(cid:5) is 4-colorable but not 3-colorable. Since G is
4-colorable, there exists a 4-coloring c : V → {1, 2, 3, 4} of G. We shall deﬁne a
homomorphism h : ϕ(G) → T . For each u ∈ V let h(u) = tc(u). Then for each
{u, u
) (because c is a coloring). Using Claim 8.11 we
can extend h to all disjoint copies of ˜T in ϕ(G). Finally, we deﬁne h(v0) = v. Notice
that the images of the copies of Q
and T5 in ϕ(G) are completely determined. For
example, if u ∈ V satisﬁes h(u) = t1, then the copy of Q
associated with u has to
be mapped to T1 in T and the copy of T5 associated with u has to be mapped to the
copy of T5 in T whose initial node is u1. We conclude that ϕ(G) → T .

(cid:4)} ∈ E it holds that h(u) (cid:6)= h(u
∗

∗

(cid:4)

g−→ S. Then there exists i

Assume, for the sake of contradiction, that there exists a proper subgraph S of
∗ ∈ {1, 2, 3, 4} such that g(u) (cid:6)= ti∗
T such that ϕ(G)
for all u ∈ V . Assume this is not the case, i.e., for all i ∈ {1, 2, 3, 4} there exists
u ∈ V such that g(u) = ti. Consider i = 1 and take u ∈ V with g(u) = t1. Since
hg(ϕ(G)) = hg(S) = 25 we have that g preserves levels, implying that g(v0) is either

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1124

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

u4

u2

u1

u3

u1

ϕ

T5

T5

˜T

Q∗

Q∗

u4

˜T

T5

u3

Q∗

u2

T5

˜T

Q∗

v0

Fig. 19. The digraph ϕ(G) for the graph G = ({u1, u2, u3, u4},{{u1, u2}, {u2, u3}, {u2, u4}}).

∗
∗

∗

∗

v, u1, u2, u3, or u4. Because Q
and T5 are incomparable, it follows that g(v0) = v.
associated to u is mapped via g to the copy of T1 in
This implies that the copy of Q
T . Using Lemma 8.3, Q
is mapped via g in a surjective manner. Also, using again
the incomparability between Q
and T5, it follows that the copy of T5 associated with
u is mapped via g to the copy of T5 in T whose initial node is u1. Furthermore,
since T5 is a core, this mapping is surjective as well. Then we conclude that T1 · T
−1
5
is contained in the homomorphic image of g. The same argument can be mimicked
for each i ∈ {2, 3, 4}, and thus g is surjective, which implies that S = T , which is
∗ ∈ {1, 2, 3, 4}, such that g(u) (cid:6)= ti∗
a contradiction. Thus, eﬀectively there exists i
for all u ∈ V . Using Claim 8.11 we have that g(u) (cid:6)= g(u
(cid:4)} ∈ E. This
implies that G is 3-colorable, which is a contradiction.
Assume now that ϕ(G) → T but there is no proper subgraph S of T such that
ϕ(G) → S. Since ϕ(G) h−→ T , using Claim 8.11 we can deduce that h(u) (cid:6)= h(u
) for
all {u, u
(cid:4)} ∈ E. Furthermore, we can deﬁne a 4-coloring for G. In fact, we can just
take c : V → {1, 2, 3, 4} such that c(u) = i iﬀ h(u) = ti for each u ∈ V .
Assume, for the sake of contradiction, that there exists a 3-coloring c : V →
{1, 2, 3} of G. We then deﬁne a homomorphism g : ϕ(G) → T as follows: First, for
each u ∈ V we deﬁne g(u) = tc(u). Since c is a coloring we have that g(u) (cid:6)= g(u
) for
all {u, u
(cid:4)} ∈ E. Using Corollary 8.12, we can extend g to all ϕ(G) in a way that the
homomorphic image of g is contained in Z. But this is a contradiction since Z is a
proper subgraph of T .

) for all {u, u

(cid:4)

(cid:4)

(cid:4)

Note that as a corollary, we obtain that the following problem is also DP-complete:

Problem: Exact Acyclic Homomorphism
Input:
a digraph G, an acyclic digraph T .
Is G → T and G (cid:6)→ S for every proper subgraph S of T ?
Question:

Before proceeding with the proof, we recall the following lemma from [25].
Lemma 8.13.
hg(G) ≤ hg(H).

If G and H are two balanced digraphs such that G → H, then

We conclude the DP-hardness result proving the following proposition, which
tell us that (ϕ(G), T ) is actually a reduction from Exact Four Colorability to
Graph Acyclic Approximation.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1125
Proposition 8.14. Let G = (cid:4)V, E(cid:5) be a graph. Then ϕ(G) → T, but there is
no proper subgraph S of T such that ϕ(G) → S iﬀ ϕ(G) → T, but there is no acyclic
digraph S such that ϕ(G) → S (cid:2)(cid:2) T .

Proof. The backward direction is trivial using the easily veriﬁable fact that T is a
core. For the forward direction, assume by contradiction that there exists an acyclic
digraph A such that ϕ(G) h−→ A
g−→ T and T (cid:6)→ A. Suppose ﬁrst that there exists
∗ ∈ {1, 2, 3, 4}, such that g ◦ h(u) (cid:6)= ti∗ for all u ∈ V . Using similar arguments as
i
before, we have that G is 3-colorable and then there exists a proper subgraph S of T
such that ϕ(G) → S (in fact, we can take S = Z), which is a contradiction. Thus,
necessarily for each i ∈ {1, 2, 3, 4} there exists u ∈ V such that g ◦ h(u) = ti.
∗

Consider i = 1 and take u ∈ V with g ◦ h(u) = t1. Let Q

(cid:4)
associated with u, and let A
∗
Q
1. Using the incomparability of Q
it follows that the homomorphic image of the restriction of g ◦ h to Q
∗
(cid:4)
This implies that the homomorphic image of A
(cid:4)
1
the fact that A
exists a homomorphism g

∗
1 be the copy of Q
be the homomorphic image of the restriction of h to
and T5, and the fact that g ◦ h preserves levels,
∗
1 is exactly T1.
(cid:4)→T1. Using
→A

is acyclic (it is a subgraph of A) and Claim 8.4, we have that there
. Let h5 be the restriction of h to the copy of
T5 associated with u. We deﬁne a homomorphism r1 from T1 · T
⊆ T to A. For
each z in the copy of T1 we deﬁne r1(z) = g
(z), and for each z in the copy of T5 we
deﬁne r1(z) = h5(z). We prove that r1 is well deﬁned, i.e., g
(t1) = h5(t1). Using
Lemma 8.13, we know that hg(A) = 25, so h preserves levels. Thus, h(u) and h(v0)
(cid:4)
are the only nodes in A
) = 25
(t1) = h(u) = h5(u) = h5(t1). Notice
we have that g
also that g
(v) = h(v0). Thus, r1 is well deﬁned. Moreover, it is a homomorphism
(v) = h(v0). We can apply the same argument for each i ∈ {2, 3, 4},
and r1(v) = g
⊆ T to A, such that
obtaining for each 1 ≤ i ≤ 4 a homomorphism ri from Ti · T
ri(v) = h(v0). Finally, we can deﬁne a homomorphism r : T → A as follows: First, if u
is in Ti · T
for 1 ≤ i ≤ 4, then r(u) = ri(u). Since v is the only common node of the
, with i ∈ {1, 2, 3, 4}, and r1(v) = r2(v) = r3(v) = r4(v) = h(v0), r
subgraphs Ti · T

(cid:4)
with level 25 and 0, respectively. Again, since hg(A

preserves levels, implying that g

(cid:4)

: T1 → A
(cid:4)

via g is T1. Thus Q

−1
5

(cid:4)

−1
5

−1
5

(cid:4)

(cid:4)

(cid:4)

∗

(cid:4)

(cid:4)

−1
5

is well deﬁned and it is a homomorphism, which is a contradiction.

Finally, we show that Graph Acyclic Approximation is DP-hard even when
G and T are cores and T is ﬁxed. We deﬁne a new function ˜ϕ from ϕ, such that for
each undirected graph G it is the case that ˜ϕ(G) is a core and G is 4-colorable but
not 3-colorable iﬀ ˜ϕ(G) → T and there is no acyclic S such that ˜ϕ(G) → S (cid:2)(cid:2) T .
Since T is already a ﬁxed core, this is enough to prove the result.

First, note that ˜T is not a core, since for each ai

T12 whose terminal nodes are identiﬁed with ai
S13, S21, and S32). We modify ˜T and leave only one copy of T12 for each ai
that Claim 8.11 is still valid.

j there are two distinct copies of
j (due to the structure of the choosers
j. Observe
Next we introduce some notation. For a set of indices X ⊆ {1, 2, 3, 4, 5}, we denote
by TX the corresponding digraph from Claims 8.5 and 8.6. For example, for X = {3, 5}
and X = {1, 2, 5}, TX denotes T35 and T125 from Claims 8.5 and 8.6, respectively. If
X = {k}, then TX = Tk. Notice that TX (cid:6)→ TY for each X, Y ⊆ {1, 2, 3, 4, 5} such
that Y (cid:2) X.

Claim 8.15.

If h is a homomorphism from ˜T to ˜T such that h(p) = p and
h(q) = q, then h is the identity mapping.
Proof. Using Lemma 4.5, Claims 8.5 and 8.6, and the fact that TX (cid:6)→ TY for each
X, Y ⊆ {1, 2, 3, 4, 5} such that Y (cid:2) X, the claim follows by a straightforward case
analysis.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1126

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

d

c

b

a

d

c

b

a

y1

y2

y3

x1

x2

x3

......

e

yn

xn

3

2

3

2

3

2

......

3

2

1

0

Fig. 20. The digraph Wn and its levels.

e

y5

x5

y1

y2

y3

y4

x1

x2

x3

x4

z2

y1

y2

y3

y4

x1

x2

x3

x4

d

c

b

a

Fig. 21. The digraphs W 2

5 and W 5
5 .

4

3

2

e

y5

x5

z5

n ) = 4 as well.
Claim 8.16. For each n ≥ 1 the digraphs W k

For each n ≥ 1, consider the oriented path Wn = 000(10)n0, illustrated in Figure
20. Notice that hg(Wn) = 4. For each 1 ≤ k ≤ n we deﬁne W k
n to be Wn plus an
edge from a new element zk to xk (an example is depicted in Figure 21). Notice that
hg(W k
n (k ∈ {1, . . . , n}) are incomparable
n is not a core for some 1 ≤ k ≤ n. Then there exists
W k
n , where h is not surjective. Necessarily, h(a) = a, h(b) = b, h(c) = c,
n
h(d) = d, and h(e) = e (since h preserves levels). This implies that h(xi) = xi and
h(yi) = yi for each 1 ≤ i ≤ n (see Figure 21). Since h(xk) = xk, it must be the case
that h(zk) = zk. This implies that h is surjective, which is a contradiction.

Proof. Suppose that W k
h−→ W k

cores.

(cid:2)
n via h, which is a contradiction.

and P8 = 09103. The oriented path P135 is from Claim 8.2.

(cid:4)
Consider the digraph S as deﬁned in Figure 22. Recall that (cid:5)Pk = 0k, P6 = 07105,
For each n ≥ 1 and 1 ≤ k ≤ n, we deﬁne the digraph Sk
n as follows: Take S
(cid:4)
and replace the directed path of length 4 in S that starts at z
and ends at z by a
copy of W k
and renaming e to z (see Figure 23). Observe that
W k
n

→ (cid:5)P4, thus Sk
Claim 8.17. For each n ≥ 1 the digraphs Sk

n (k ∈ {1, . . . , n}) are incomparable

n , identifying a with z

→ S.

n

(cid:4)

cores.

Now, suppose that W k
n

n for k (cid:6)= k
h maps a, b, c, d, and e in W k
h maps, for each 1 ≤ i ≤ n, xi and yi in W k
k (cid:6)= k

h−→ W k
n to a, b, c, d, and e in W k

, we have that zk cannot be mapped in W k

(cid:4)

(cid:2)

. Since h preserves levels, we have that
(cid:2)
n , respectively. This implies that
(cid:2)
n , respectively. Since

n to xi and yi in W k

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1127

P8

(cid:3)P3

z(cid:21)

(cid:3)P4

(cid:3)P9

w

w(cid:21)

P6

P135

Fig. 22. The digraph S.

W k
n

z(cid:21)

(cid:3)P9

w

w(cid:21)

P6

P135

z

z

Fig. 23. The digraph Sk
n.

Proof. The proof follows easily from Lemma 4.5, Claim 8.16, and the fact that

P6 and P8 are incomparable.

Now we deﬁne our main construction. Consider an undirected graph G and let
u1, u2, . . . , un be an arbitrary enumeration of its nodes. We deﬁne ˜ϕ(G) to be ϕ(G),
where, in addition, for each 1 ≤ k ≤ n we add a disjoint copy of Sk
n and identify z in
Sk
n with uk. Clearly, ˜ϕ(G) can be computed in polynomial time in the size of G. To
conclude, we prove the following proposition.
Proposition 8.18. For every undirected graph G, the digraph ˜ϕ(G) is a core.
Furthermore, G is 4-colorable but not 3-colorable iﬀ ˜ϕ(G) → T and there is no acyclic
S such that ˜ϕ(G) → S (cid:2)(cid:2) T .

Proof. Let G be an undirected graph and h a homomorphism from ˜ϕ(G) to ˜ϕ(G).
We shall prove that h is surjective, implying that ˜ϕ(G) is a core. Recall that u1, . . . , un
is an enumeration of the nodes of G, which are by deﬁnition contained in ˜ϕ(G). We
have that h(uk) = uk for each 1 ≤ k ≤ n. Indeed, since h preserves levels, we know
that h maps uk to ul for some 1 ≤ l ≤ n, or maps uk to some node in a copy of ˜T
∗ (cid:6)→ TX for some X that contains element 5
∗ (cid:6)→ T5) and TX (cid:6)→ TY for Y (cid:2) X, we can easily show that the second case is

with level 25. Using the facts that Q
(since Q
not possible, since we have copies of T345 (from ˜S21), T15 (from ˜S34), and Q
whose
terminal nodes are identiﬁed with uk, as shown in Figure 24. For example, h cannot
1; otherwise T345 → T12, T345 → T15, or T345 → T125. Similarly, h cannot
map uk to a1
∗ → T35 (see Figure 24). For the
map uk to b1; otherwise Q
other nodes in ˜T with level 25, we have similar contradictions.
Thus, h maps uk to ul for some 1 ≤ l ≤ n. We shall show that l = k. Indeed,
suppose that l (cid:6)= k. Since h preserves levels and the only node with level 25 in the
copy of Sk
n whose terminal node is uk is precisely uk, we have that h maps this copy
, T345, T15, T5, or Sl
of Sk
n, whose terminal node is ul. Suppose
∗
that h maps the copy of Sk
. Necessarily, h maps w in Sk
n to the copy of Q
n to a7
(see Figures 23 and 6). This implies that P135 → P7, which is a contradiction
in Q
with Claim 8.2. Now, suppose that h maps the copy of Sk
follows that h maps w

n either to a copy of Q
∗

It
n to the initial node of the copy of P8 in T5, implying

n to the copy of T5.

∗ → T15, Q

∗ → T25, or Q

∗

∗

(cid:4)

in Sk

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1128

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

T12

T15

a1
1

T125

b1

T15

T25

T35

T345

Sk
n

T5

uk

T15

Q∗

Fig. 24. The node uk and a copy of ˜T .

that P6 → P8 or P6 → P9 (Figures 23 and 10), which is a contradiction. The cases
when the copy of Sk
n is mapped to T345 or T15 lead to a contradiction as well, since
T345 → T5 and T15 → T5. Finally, suppose that h maps the copy of Sk
n to the copy
of Sl
n, which contradicts Claim
8.17. In any case we have a contradiction, and thus l = k and h(uk) = uk for each
1 ≤ k ≤ n.

n whose terminal node is ul. It follows that Sk
n

Now, observe that for each 1 ≤ k ≤ n, the copies of T5 and Sk

→ Sl

∗ → T5, Q

∗ → T15, or Q
∗

n whose terminal
node is uk have to be mapped via h to themselves in a surjective manner. Moreover,
∗ → T345, which is a contradiction.
h(v0) = v0; otherwise Q
This implies that h maps all disjoint copies of Q
to themselves, in a surjective manner
as well. Finally, observe that h maps all the copies of ˜T to themselves too. Indeed,
using the facts that h preserves levels, TX (cid:6)→ TY for Y (cid:2) X, and h(uk) = uk for each
1 ≤ k ≤ n, we can easily show that h maps each node in a copy of ˜T to a node inside
the same copy of ˜T . Thus, we can use Claim 8.15 to conclude that h maps all copies
of ˜T to themselves in a surjective manner, implying that h is actually surjective. This
proves that ˜ϕ(G) is a core.
Finally, observe that for each 1 ≤ i ≤ 4 and 1 ≤ k ≤ n, there is a homomorphism
gi from Sk
n to the terminal node of Ti.
Thus, if we are constructing a homomorphism from ˜ϕ(G) to T for any values of the
images of the uk’s, we can always deﬁne images for the copies of the Sk
n’s. Therefore,
we can use exactly the same arguments as in the proofs of the correctness of ϕ and
Proposition 8.14.

n to Ti such that gi maps the node z in Sk

This ﬁnishes the proof of Theorem 4.12.

Acknowledgments. We thank Wenfei Fan, Claudio Gutierrez, Luc Segouﬁn,
Thomas Schwentick, and the referees of conference versions [6, 7] for their comments.

REFERENCES

[1] S. Abiteboul, K. Compton, and V. Vianu, Queries are easier than you thought (probably),
in Proceedings of the 11th ACM Symposium on Principles of Database Systems, PODS’92,
1992, pp. 23–32.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpEFFICIENT APPROXIMATIONS OF CONJUNCTIVE QUERIES

1129

[2] S. Abiteboul and O. Duschka, Complexity of answering queries using materialized views, in
Proceedings of the 17th ACM Symposium on Principles of Database Systems, PODS’98,
1998, pp. 254–263.

[3] S. Abiteboul, R. Hull, and V. Vianu, Foundations of Databases, Addison-Wesley, 1995.
[4] M. Aigner, Combinatorial Theory, Springer, 1997.
[5] V. B´ar´any, G. Gottlob, and M. Otto, Querying the guarded fragment, in Proceedings of

IEEE Logic in Computer Science, LICS’10, 2010, pp. 1–10.

[6] P. Barcel´o, L. Libkin, and M. Romero, Eﬃcient approximations of conjunctive queries, in
Proceedings of the 31st ACM Symposium on Principles of Database Systems, PODS’12,
2012, pp. 249–260.

[7] P. Barcel´o, L. Libkin, and M. Romero, On low treewidth approximations of conjunctive
queries, in Proceedings of 6th Alberto Mendelzon International Workshop on Foundations
of Data Management, AMW’12, CEUR Workshop Proceedings 866, 2012, pp. 91–101.

[8] H. L. Bodlaender, A linear-time algorithm for ﬁnding tree-decompositions of small treewidth,

SIAM J. Comput., 25 (1996), pp. 1305–1317.

[9] B. ten Cate, Ph. Kolaitis, and W.-C. Tan, Database constraints and homomorphism dualities,
 in Proceedings of the 16th International Conference on Principles and Practice of
Constraint Programming, CP’10, 2010, pp. 475–490.

[10] A. Chandra and P. Merlin, Optimal implementation of conjunctive queries in relational data
bases, in Proceedings of the 9th ACM Symposium on Theory of Computing, STOC’77,
1977, pp. 77–90.

[11] C. Chekuri and A. Rajaraman, Conjunctive query containment revisited, Theoret. Comput.

Sci., 239 (2000), pp. 211–229.

[12] V. Dalmau, P. G. Kolaitis, and M. Y. Vardi, Constraint satisfaction, bounded treewidth,
and ﬁnite-variable logics, in Proceedings of the 8th International Conference on Principles
and Practice of Constraint Programming, CP 2002, pp. 310–326.

[13] R. Fagin, Ph. Kolaitis, and L. Popa, Data exchange: Getting to the core, ACM Trans.

Database Syst., 30 (2005), pp. 90–101.

[14] W. Fan, J. Li, S. Ma, N. Tang, and Y. Wu, Graph pattern matching: From intractable to

polynomial time, Proc. VLDB, 3 (2010), pp. 264–275.

[15] R. Fink and D. Olteanu, On the optimal approximation of queries using tractable propositional 
languages, in Proceedings of the 14th International Conference on Database Theory,
ICDT’11, 2011, pp. 174–185.

[16] J. Flum, M. Frick, and M. Grohe, Query evaluation via tree-decompositions, J. ACM, 49

(2002), pp. 716–752.

[17] J. Flum and M. Grohe, Parameterized Complexity Theory, Springer, 2006.
[18] M. Garofalakis and P. Gibbons, Approximate query processing: Taming the terabytes, in

Proceedings of the 27th International Conference on Very Large Data Bases, VLDB’01.

[19] G. Gottlob, N. Leone, and F. Scarcello, The complexity of acyclic conjunctive queries, J.

ACM, 48 (2001), pp. 431–498.

[20] G. Gottlob, N. Leone, and F. Scarcello, Hypertree decompositions and tractable queries,

J. Comput. System Sci., 64 (2002), pp. 579–627.

[21] G. Gottlob, N. Leone, and F. Scarcello, Robbers, marshals, and guards: Game theoretic 
and logical characterizations of hypertree width, J. Comput. System Sci., 66 (2003),
pp. 775–808.

[22] G. Gottlob, Z. Miklos, and T. Schwentick, Generalized hypertree decompositions: NPhardness 
and tractable variants, J. ACM, 56 (2009).

[23] M. Grohe, T. Schwentick, and L. Segoufin, When is the evaluation of conjunctive queries
tractable?, in Proceedings on 33rd ACM Symposium on Theory of Computing, STOC’01,
2001, pp. 657–666.

[24] A. Halevy, Answering queries using views: A survey, VLDB J., 10 (2001), pp. 270–294.
[25] P. Hell and J. Neˇsetˇril, Graphs and Homomorphisms, Oxford University Press, 2004.
[26] P. Hell, J. Neˇsetˇril, and X. Zhu, Complexity of tree homomorphisms, Discrete Appl. Math.,

70 (1996), pp. 23–36.

[27] L. Hella, Ph. Kolaitis, and K. Luosto, Almost everywhere equivalence of logics in ﬁnite

model theory, Bull. Symbolic Logic, 2 (1996), pp. 422–443.

[28] Y. Ioannidis, Approximations in database systems, in Proceedings of the 9th International

Conference on Database Theory, ICDT’03, 2003, pp. 16–30.

[29] Ph. Kolaitis and M. Vardi, Conjunctive-query containment and constraint satisfaction, J.

Comput. System Sci., 61 (2000), pp. 302–332.

[30] Ph. Kolaitis and M. Vardi, A logical approach to constraint satisfaction, in Finite Model

Theory and Its Applications, Springer, 2007, pp. 339–370.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1130

PABLO BARCEL ´O, LEONID LIBKIN, AND MIGUEL ROMERO

[31] M. Lenzerini, Data integration: A theoretical perspective, in Proceedings of the 21st Symposium 
on Principles of Database Systems, PODS’02, 2002, pp. 233–246.

[32] L. Libkin, Incomplete information and certain answers in general data models, in Proceedings

of the 30th Symposium on Principles of Database Systems, PODS’11, 2011, pp. 59–70.

[33] Q. Liu, Approximate query processing, in Encyclopedia of Database Systems, 2009, pp. 113–

119.

[34] S. Malik and L. Zhang, Boolean satisﬁability: From theoretical hardness to practical success,

Comm. ACM, 52 (2009), pp. 76–82.

[35] J. Neˇsetˇril and C. Tardif, Duality theorems for ﬁnite structures (characterising gaps and

good characterisations), J. Combin. Theory Ser. B, 80 (2000), pp. 80–97.

[36] C. H. Papadimitriou and M. Yannakakis, The complexity of facets (and some facets of

complexity), J. Comput. System Sci., 28 (1996), pp. 244–259.

[37] A. Robinson and A. Voronkov, eds., Handbook of Automated Reasoning, The MIT Press,

2001.

[38] J. Rothe, Exact complexity of exact-four-colorability, Inform. Process. Lett., 87 (2003), pp. 7–

12.

[39] M. Vardi, On the complexity of bounded-variable queries, in Proceedings of the 14th ACM

Symposium on Principles of Database Systems, PODS’95, 1995, pp. 266–276.

[40] D. West, Introduction to Graph Theory, Prentice-Hall, 2001.
[41] M. Yannakakis, Algorithms for acyclic database schemes, in Proceedings of 7th International

Conference on Very Large Databases, VLDB’81, 1981, pp. 82–94.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php