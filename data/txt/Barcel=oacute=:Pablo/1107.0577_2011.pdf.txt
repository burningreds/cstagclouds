1
1
0
2

 
l
u
J
 

4

 
 
]
L
F
.
s
c
[
 
 

1
v
7
7
5
0

.

7
0
1
1
:
v
i
X
r
a

Parameterized Regular Expressions and

Their Languages

Pablo Barcel´o

U. de Chile

Leonid Libkin

Juan Reutter

U. of Edinburgh

U. of Edinburgh

Abstract

We study regular expressions that use variables, or parameters, which are interpreted as
alphabet letters. We consider two classes of languages denoted by such expressions: under the
possibility semantics, a word belongs to the language if it is denoted by some regular expression
obtained by replacing variables with letters; under the certainly semantics, the word must be
denoted by every such expression. Such languages are regular, and we show that they naturally
arise in several applications such as querying graph databases and program analysis. As the main
contribution of the paper, we provide a complete characterization of the complexity of the main
computational problems related to such languages: nonemptiness, universality, containment,
membership, as well as the problem of constructing NFAs capturing such languages. We also
look at the extension when domains of variables could be arbitrary regular languages, and show
that under the certainty semantics, languages remain regular and the complexity of the main
computational problems does not change.

1

Introduction

In this paper we study parameterized regular expressions like (0x)∗1(xy)∗ that combine letters from
a ﬁnite alphabet Σ, such as 0 and 1, and variables, such as x and y. These variables are interpreted
as letters from Σ. This gives two ways of deﬁning the language of words over Σ denoted by a
parameterized regular expression e. Under the ﬁrst – possibility – semantics, a word w ∈ Σ∗ is in
the language L✸(e) if w is in the language of some regular expression e′ obtained by substituting
alphabet letters for variables. Under the second – certainty – semantics, w ∈ L✷(e) if w is in
the language of all regular expressions obtained by substituting alphabet letters for variables. For
example, if e = (0x)∗1(xy)∗, then 01110 ∈ L✸(e), as witnessed by the substitution x 7→ 1, y 7→ 0.
The word 1 is in L✷(e), since the starred subexpressions can be replaced by the empty word. As a
more involved example of the certainty semantics, the reader can verify that for e′ = (0|1)∗xy(0|1)∗,
the word 10011 is in L✷(e′), although no word of length less than 5 can be in L✷(e′).

These semantics of parameterized regular expressions arise in a variety of applications. In fact,
the possibility semantics has already been studied in the case of inﬁnite alphabets [11], with the
motivation coming from the study of inﬁnite-state systems with ﬁnite control (e.g., software with
integer parameters). We, on the other hand, are interested in the classical case of ﬁnite alphabets,
typically considered in connection with formal languages, and both the possibility and the certainty
semantics. These are motivated by several applications, in particular in the ﬁelds of querying graphstructured 
data, and static analysis of programs. We now explain these connections.

1

Applications in graph databases Graph databases, that describe both data and its topology,
have been actively studied over the past few years in connection with such diverse topics as social
networks, biological data, semantic Web and RDF, crime detection and analyzing network traﬃc;
see [2] for a survey. The abstract data model is essentially an edge-labeled graph, with edge labels
coming from a ﬁnite alphabet. This ﬁnite alphabet can contain, for example, types of relationships
in a social network or a list of RDF properties. In this setting one concentrates on various types of
reachability queries, e.g., queries that ask for the existence of a path between nodes with certain
properties so that the label of the path forms a word in a given regular language [3, 6, 7, 9].

As in most data management applications, it is common that some information is missing,
typically due to using data that is the result of another query or transformation [1, 4, 8]. For
x7−→ b′, saying that the relationship
example, in a social network we may have edges a x7−→ b and a′
between a and b is the same as that between a′ and b′. However, the precise nature of such a
relationship is unknown, and this is represented by a variable x. Such graphs G whose edges are
labeled by letters from Σ and variables from a set W can be viewed as automata over Σ ∪ W. In
checking the existence of paths between nodes, one normally looks for certain answers [14], i.e.,
answers independent of a particular interpretation of variables.

In the case of graph databases such certain answers can be found as follows. Let a, b be two
nodes of G. One can view (G, a, b) as an automaton, with a as the initial state, and b as the ﬁnal
state; its language, over Σ ∪ W is given by some regular expression e(G, a, b). Then we can be
certain about the existence of a word w from some language L that is the label of a path from a
to b iﬀ w also belongs to L✷(e(G, a, b)), i.e., iﬀ L ∩ L✷(e(G, a, b)) is nonempty. Hence, computing
L✷(e) is essential for answering queries over graph databases with missing information.

Applications in program analysis That regular expressions with variables appear naturally
in program analysis tasks was noticed, for instance, in [18, 19, 20]. One uses the alphabet that
consists of symbols related to operations on variables, pointers, or ﬁles, e.g., def for deﬁning a
variable, use for using it, open for opening a ﬁle, or malloc for allocating a pointer. A variable
then follows: def(x) means deﬁning variable x. While variables and alphabet symbols do not mix
freely any more, it is easy to enforce correct syntax with an automaton. An example of a regular
condition with parameters is searching for uninitialized variables: (¬def(x))∗use(x).

Expressions like this are evaluated on a graph that serves as an abstraction of a program.
One considers two evaluation problems: whether under some evaluation of variables, either some
path, or every path between two nodes satisﬁes it. This amounts to computing L✸(e) and checking
whether all paths, or some path between nodes is in that language. In case of uninitialized variables
one would be using ‘some path’ semantics; the need for the ‘all paths’ semantics arises when one
analyzes locking disciplines or constant folding optimizations [18, 20]. So in this case the language
of interest for us is L✸(e), as one wants to check whether there is an evaluation of variables for
which some property of a program is true.

Parameterized regular expressions appeared in other applications as well, e.g., in phase-sequence
prediction for dynamic memory allocation [22], or as a compact way to express a family of legal behaviors 
in hardware veriﬁcation [5], or as a tool to state regular constraints in constraint satisfaction
problems [21].

At the same time, however, very little is known about the basic properties of the languages
L✷(e) and L✸(e). As we mentioned, the L✸(e) semantics has been studied in the context of
inﬁnite alphabets [11].
It was shown that it deﬁnes languages that can also accepted by non2


deterministic register automata of [16]. Language-theoretic issues are quite diﬀerent over ﬁnite and
inﬁnite alphabets.
In the case of inﬁnite alphabets getting closure properties is nontrivial, and
some problems, such universality and containment, are even undecidable [11]. In contrast, in the
classical language-theoretic framework of ﬁnite alphabets, closure and decidability are guaranteed,
and the key question is to pinpoint the precise complexity of the main decision problems.

Thus, our main goal is to determine the exact complexity of the key problems related to languages 
L✷(e) and L✸(e). We consider the standard language-theoretic decision problems, such
as membership of a word in the language, language nonemptiness, universality, and containment.
Since the languages L✷(e) and L✸(e) are regular, we also consider the complexity of constructing
NFAs, over the ﬁnite alphabet Σ, that deﬁne them.

For all the decision problems, we ﬁnd complexity classes they belong to. In fact, all the problems 
end up being complete for various complexity classes, from NLogspace to Expspace. We
establish upper bounds on the running time of algorithms for constructing NFAs, and then prove
matching lower bounds for the sizes of NFAs representing L✷(e) and L✸(e). Finally, we look at
some extensions where the range of variables need not be just Σ. Under the possibility semantics,
such languages subsume pattern (and even multi-pattern [15]) languages, but under the certainty
semantics they remain regular, and we establish complexity bounds on the main problems.

Parameterized regular expressions and their languages are formally deﬁned in
Organization
Section 2. In Section 3 we deﬁne the main problems we study. Complexity of the main decision
problems is analyzed in Section 4, and complexity of automata construction in Section 5. In Section
6 we study extensions when domains of variables need not be single letters. In the ﬁrst 10 pages of
the paper we state the main results and provide quick sketches of the proofs; detailed proofs of all
the results are in the appendix.

2 Preliminaries

Let Σ be a ﬁnite alphabet, and V a countably inﬁnite set of variables, disjoint from Σ. Regular
expressions over Σ ∪ V will be called parameterized regular expressions. Regular expressions, as
usual, are built from ∅, the empty word ε, symbols in Σ and V, by operations of concatenation (·),
union (|), and the Kleene star (∗). Of course each such expression only uses ﬁnitely many symbols
in V. The size of a regular expression is measured as the total number of symbols needed to write
it down (or as the size of its parse tree).

We write L(e) for the language deﬁned by a regular expression e. If e is a parameterized regular
expression that uses variables from a ﬁnite set W ⊂ V, then L(e) ⊆ (Σ ∪ W)∗. We are interested
in languages L✷(e) and L✸(e), which are subsets of Σ∗. To deﬁne them, we need the notion of
a valuation ν which is a mapping from W to Σ, where W is the set of variables mentioned in e.
By ν(e) we mean the regular expression over Σ obtained from e by simultaneously replacing each
variable x ∈ W by ν(x). For example, if e = (0x)∗1(xy)∗ and ν is given by x 7→ 1, y 7→ 0, then
ν(e) = (01)∗1(10)∗.

We now formally deﬁne the certainty and possibility semantics for parameterized regular expressions.


3

Deﬁnition 1 (Acceptance) Let e be a parameterized regular expression. Then

L✷(e)
L✸(e)

:= T{L(ν(e)) | ν is a valuation for e}
:= S{L(ν(e)) | ν is a valuation for e}

(certainty semantics)
(possibility semantics)

Since each parameterized regular expression uses ﬁnitely many variables, the number of possible

valuations is ﬁnite as well, and thus both L✷(e) and L✸(e) are regular languages over Σ∗.

The usual connection between regular expressions and automata extends to the parameterized
case. Each parameterized regular expression e over Σ ∪ W, where W is a ﬁnite set of variables in V,
can of course be translated, in polynomial time, into an NFA Ae over Σ ∪ W so that L(Ae) = L(e).
Such equivalences extend to L✷ and L✸. Namely, for an NFA A over Σ ∪ W, and a valuation
ν : W → Σ, deﬁne ν(A) as the NFA over Σ that is obtained from A by replacing each transition
of the form (q, x, q′) in A (for q, q′ states of A and x ∈ W) with the transition (q, ν(x), q′). The
following is just an easy observation:

Lemma 1 Let e be a parameterized regular expression, and Ae be an NFA over Σ ∪ V such that
L(Ae) = L(e). Then, for every valuation ν, we have L(ν(e)) = L(ν(Ae)).

Hence, if we deﬁne L✷(A) as Tν L(ν(A)), and L✸(A) as Sν L(ν(A)), then the lemma implies that

L✷(e) = L✷(Ae) and L✸(e) = L✸(Ae). Since one can go from regular expressions to NFAs in
polynomial time, this will allow us to use both automata and regular expressions interchangeably
to establish our results.

3 Basic Problems

We now describe the main problems we study here. For each problem we shall have two versions,
depending on which semantics – L✷ or L✸ is used. So each problem will have a subscript ∗ that
can be interpreted as ✷ or ✸.

We start with decision problems:

Nonemptiness∗ Given a parameterized regular expression e, is L∗(e) 6= ∅?

Membership∗ Given a parameterized regular expression e and a word w ∈ Σ∗, is w ∈ L∗(e)?

Universality∗ Given a parameterized regular expression e, is L∗(e) = Σ∗?

Containment∗ Given parameterized regular expressions e1 and e2, is L∗(e1) ⊆ L∗(e2)?

A special version of nonemptiness is the problem of intersection with a regular language (used

in the database querying example in the introduction):

NonemptyIntReg∗ Given a parameterized regular expression e, and a regular expression e′ over

Σ, is L(e′) ∩ L∗(e) 6= ∅?

The last problem is computational rather than a decision problem:

ConstructNFA∗ Given a parameterized regular expression e, construct an NFA A over Σ such

that L∗(e) = L(A).

4

4 Decision problems

In this section we consider the ﬁve decision problems – nonemptiness, membership, universality,
containment, as well as nonemptiness of intersection with a regular language – and provide precise
complexity for them.

We shall also consider two restrictions on regular expressions; these will indicate when the
problems are inherently very hard or when their complexity can be lowered in some cases. One
source of complexity is the repetition of variables in expressions like (0x)∗1(xy)∗. When no variable
appears more than once in a parameterized regular expression, we call it simple. Another source
of complexity is inﬁnite languages, so we consider a restriction to expressions of star-height 0, in
which no Kleene star is used: these denote ﬁnite languages, and each ﬁnite language is denoted by
such an expression.

4.1 Nonemptiness

The problem Nonemptiness✸ has a trivial solution, since L✸(e) 6= ∅ for every parameterized
regular expression e (except e = ∅). So we study this problem for the certainty semantics; for the
possibility semantics, we look at the related problem Nonemptiness-Automata✸, which, for a
given NFA A over Σ ∪ V asks whether L✸(A) 6= ∅.

Theorem 1

• The problem Nonemptiness✷ is Expspace-complete.

• The problem Nonemptiness-Automata✸ is NLogspace-complete.

The result for the possibility semantics is by a standard reachability argument. Note that the
bound is the same here as in the case of inﬁnite alphabets studied in [11]. To see the upper bound
for Nonemptiness✷, note that there are exponentially many valuations ν, and each automaton
ν(Ae) is of polynomial size, so we can use the standard algorithm for checking nonemptiness of the
intersection of a family of regular languages which can be solved in polynomial space in terms of
the size of its input; since the input to this problem is of exponential size in terms of the original
input, the Expspace bound follows. The hardness is by a generic (Turing machine) reduction; the
proof is in the appendix.

In the proof we use the following property of the certainty semantics, which shows a striking

diﬀerence with the case of standard regular expressions:

Lemma 2 Given a set e1, . . . , ek of parameterized expressions of size at most n ≥ k, it is possible to
build, in time O(k · n) an expression e′ such that L✷(e′) is empty if and only if L✷(e1) ∩ · · · ∩ L✷(ek)
is empty.

The reason the case of the L✷(e) semantics is so diﬀerent from the usual semantics of regular
languages is as follows. It is well known that checking whether the intersection of the languages
deﬁned by a ﬁnite set S of regular expressions is nonempty is Pspace-complete [17], and hence
under widely held complexity-theoretical assumptions no regular expression r can be constructed in

polynomial time from S such that L(r) is nonempty if and only if Ts∈S L(s) is nonempty. Lemma

3, on the other hand, says that such a construction is possible for parameterized regular expressions
under the certainty semantics.

The generic reduction used in the proof of Expspace-hardness of Nonemptiness✷ also provides
lower bounds on the minimal sizes of words in languages L✷(e) (note that the language L✸(e) always
contains a word of the size linear in the size of e).

5

Corollary 1 There exists a polynomial p : N → N and a sequence of parameterized regular expressions 
{en}n∈N such that each en is of size at most p(n), and every word in the language L✷(en) has
size at least 22n.

The construction is somewhat involved, but it is easy to see the single-exponential bound
(which was hinted at in the ﬁrst paragraph of the introduction, and which was in fact used in
connection with querying incomplete graph data in [4]). For each n, consider an expression en =
(0|1)∗x1 . . . xn(0|1)∗. If a word w is in L✷(en), then w must contain every word in {0, 1}n as a
subword, which implies that its length must be at least 2n + 1.

We can also show that the use of Kleene star has a huge impact on complexity, which is not at

the same time aﬀected by variable repetitions.

Proposition 1 The problem Nonemptiness✷ remains Expspace-hard over the class of simple
regular expressions, but it is Σp

2-complete over the class of expressions of star-height 0.

4.2 Membership

It is easy to see that Membership✷ can be solved in coNP, and Membership✸ in NP: one just
guesses a valuation witnessing w ∈ L(v(e)) or w 6∈ L(v(e)). These bounds turn out to be tight.

Theorem 2

• The problem Membership✷ is coNP-complete.

• The problem Membership✸ is NP-complete.

Note that for the case of the possibility semantics, the bound is the same as for languages over
the inﬁnite alphabets [11] (for all problems other than nonemptiness and membership, the bounds
will be diﬀerent). The hardness proof in [11] relies on the inﬁnite size of the alphabet, but one can
ﬁnd an alternative proof that uses only ﬁnitely many symbols. Both proofs are by variations of
3-SAT or its complement; the reductions are somewhat involved and are presented in the appendix.

The restrictions to expressions without repetitions, or to ﬁnite languages, by themselves do not

lower the complexity, but together they make it polynomial.

Proposition 2 The complexity of the membership problem remains as in Theorem 2 over the
classes of simple expressions, and expressions of star-height 0. Over the class of simple expressions
of star-height 0, Membership✸ can be solved in time O(nm · log2 n), where n is the size of the
expression and m is the size of the word.

The log2 n factor appears due to the complexity of the algorithm for converting regular expressions 
into ε-free NFAs [13]; it appears as one of the steps of the algorithm, which is described in
the appendix.

Membership for ﬁxed words We next consider a variation of the membership problem:
Membership∗(w) asks, for a parameterized regular expression e, whether w ∈ L∗(e).
In other
words, w is ﬁxed. It turns out that for the ✸-semantics, this version is eﬃciently solvable, but for
the ✷-semantics, it remains intractable unless restricted to simple expressions.

Theorem 3

• There is a word w ∈ Σ∗ such that the problem Membership✷(w) is coNP-hard

(even over the class of expressions of star-height 0).

6

• For each word w ∈ Σ∗, the problem Membership✷(w) is solvable in O(n) time, if restricted

to the class of simple expressions.

• For each word w ∈ Σ∗, the problem Membership✸(w) is solvable in time O(n log2 n).

4.3 Universality

Somewhat curiously, the universality problem is more complex for the possibility semantics L✸.
Indeed, consider a parameterized expression e over Σ, with variables in W. For the certainty
semantics, it suﬃces to guess a word w and a valuation ν : W → Σ such that w 6∈ L(ν(e)). This
gives a Pspace upper bound for this problem, which is the best that we can do, as the universality
problem is Pspace-hard even for complete regular expressions. On the other hand, when solving
this problem for the possibility semantics, one can expect that all possible valuations for e will need
to be analyzed, which increases the complexity by one exponential. (In fact, when one moves to
inﬁnite alphabets, this problem becomes undecidable [11]). The lower bound proof, which is again
by a generic reduction, is in the appendix.

Theorem 4

• The problem Universality✷ is Pspace-complete.

• The problem Universality✸ is Expspace-complete.

Similarly to the nonemptiness problem, the Expspace bound for Universality✸ is quite
resilient, as it holds even if for simple expressions (note that it makes no sense to study expressions
of star-height 0, as they denote ﬁnite languages and thus cannot be universal).

Proposition 3 The problem Universality✸ remains Expspace-hard over the class of simple
parameterized regular expressions.

4.4 Containment

The bounds for the containment problem are easily obtained from the fact that both nonemptiness
and universality can be cast as its versions. Since Σ∗ ⊆ L✸(e) iﬀ Universality✸(e) is true, and
L✷(e) ⊆ ∅ iﬀ Nonemptiness✷(e) is false, we get Expspace lower bounds for both containment
problems. The matching upper bounds are by straightforward enumeration of valuations. Hence,
we get:

Theorem 5 Both Containment✷ and Containment✸ are Expspace-complete.

Containment with one ﬁxed expression We look at two variations of the containment problem,
 when one of the expressions is ﬁxed: Containment∗(e1, ·) asks, for a parameterized regular
expression e2, whether L∗(e1) ⊆ L∗(e2); and Containment∗(·, e2) is deﬁned similarly. Theorem 5
show that Containment✷(·, e2) and Containment✸(e1, ·) remain Expspace-complete. For the
other two versions of the problem, the proposition below (proved in the appendix) shows that the
complexity is lowered by at least one exponential.

Proposition 4

• Containment✷(e1, ·) is Pspace-complete.

• Containment✸(·, e2) is coNP-complete.

7

5 Computing automata

In this section, we ﬁrst provide upper bounds for algorithms for building NFAs over Σ capturing
L✸(e) and L✷(e), and then prove their optimality, by showing matching lower bounds on the sizes of
such NFAs. Recall that we are dealing with the problem ConstructNFA∗: given a parameterized
regular expression e, construct an NFA A over Σ so that L(A) = L∗(e).

Proposition 5 The problem ConstructNFA✸ can be solved in single-exponential time, and the
problem ConstructNFA✷ can be solved in double-exponential time.

These bounds are achieved by using naive algorithms for constructing automata: namely, one
converts a parameterized regular expression e over variables in a ﬁnite set W into an automaton
Ae, and then for |Σ||W| valuations ν computes the automata ν(Ae). This takes exponential time.
To obtain an NFA for L✸(e) one simply combines them with a nondeterministic choice; for L✷(e)
one takes the product of them, resulting in double-exponential time.

We now show that these complexities are unavoidable, as the smallest NFAs capturing L✸(e)
or L✷(e) can be of single or double-exponential size, respectively. We say that the sizes of minimal
NFAs for L∗ are necessarily exponential (resp., double-exponential) if there exists a family {en}n∈N
of parameterized regular expressions such that:

• the size of each en is O(n), and
• every NFA A satisfying L(A) = L∗(en) has at least 2n (resp., 22n) states.

Theorem 6 The sizes of minimal NFAs are necessarily double-exponential for L✷, and necessarily
exponential for L✸.

Proof sketch: We begin with the double exponential bound for L✷. For each n ∈ N, let en be the
following parameterized regular expression over alphabet Σ = {0, 1} and variables x1, . . . , xn+1:

en = ((0 | 1)n+1)∗ · x1 · · · xn · xn+1 · ((0 | 1)n+1)∗.

Notice that each en uses n + 1 variables, and is of linear size in n.

In order to show that
every NFA deciding L✷(en) has 22n
if L ⊂ Σ∗ is a
regular language, and there exists a set of pairs P = {(ui, vi) | 1 ≤ i ≤ m} ⊆ Σ∗ × Σ∗ such that
(1) uivi ∈ L, for every 1 ≤ i ≤ m, and (2) ujvi /∈ L, for every 1 ≤ i, j ≤ m and i 6= j, then every
NFA accepting L has at least m states.

states, we use the following result from [10]:

Given a collection S of words over {0, 1}, let wS denote the concatenation, in lexicographical
order, of all the words that belong to S, and let w ¯S,n denote the concatenation of all words in
{0, 1}n+1 that are not in S.

Then, deﬁne a set of pairs Pn = {(wS, w ¯S,n) | S ⊂ {0, 1}n+1 and |S| = 2n}. Since there are 2n+1
2n (cid:1) diﬀerent subsets of {0, 1}n+1 of size 2n, and thus Pn

pairs. Moreover, one can show (details in the appendix) that L✷(en) and Pn

binary words of length n + 1, there are (cid:0)2n+1
contains (cid:0)2n+1

2n (cid:1) ≥ 22n

satisfy properties (1) and (2) above, which proves the double exponential lower bound.

To show the exponential lower bound for L✸, deﬁne en = (x1 · · · xn)∗, and let Pn = {(w, w) |
w ∈ {0, 1}n}. Clearly, Pn contains 2n pairs. All that is left to do is to show that L✸(en) and Pn
satisfy properties (1) and (2) above. Details are in the appendix.
✷

Note that the bounds of Theorem 6 apply to simple regular expressions.
The table in Fig. 1 summarizes the main results in Sections 4 and 5.

8

Problem
Nonemptiness

Membership

Containment

Universality

NonemptyIntReg

ConstructNFA

Semantics

Certainty ✷

Possibility ✸

Expspace-complete NLogspace-complete

coNP-complete

Expspace-complete

Pspace-complete

Expspace-complete
double-exponential

(for automata)
NP-complete

Expspace-complete
Expspace-complete

NP-complete

single-exponential

Figure 1: Summary of complexity results

6 Extending domains of variables

So far we assumed that variables take values in Σ: our valuations were partial maps ν : V → Σ.
We now consider a more general case when the range of each variable is a regular subset of Σ∗.

Let e be a parameterized regular expression with variables x1, . . . , xn, and let L1, . . . , Ln ⊆ Σ∗
be nonempty regular languages. We shall write ¯L for (L1, . . . , Ln). A valuation in ¯L is a map
ν : ¯x → ¯L such that ν(xi) ∈ Li for each i ≤ n. Under such a valuation, each parameterized regular
expression e is mapped into a usual regular expression ν(e) over Σ, in which each variable xi is
replaced by the word ν(xi). Hence we can still deﬁne

L✷(e; ¯L) = T{L(ν(e)) | ν is a valuation over ¯L}
L✸(e; ¯L) = S{L(ν(e)) | ν is a valuation over ¯L}

According to this notation, L✷(e) = L✷(e; (Σ, . . . , Σ)), and likewise for L✸.

Note however that intersections and unions are now inﬁnite, if some of the languages Li’s are
inﬁnite, so we cannot conclude, as before, that we deal with regular languages. And indeed they
are not: for example, L✸(xx; Σ∗) is the set of square words, and thus not regular.

We now consider two cases. If each Li is a ﬁnite language, we show that all the complexity
results in Fig. 1 remain true. Then we look at the case of arbitrary regular Li’s. Languages L✸(e; ¯L)
need not be regular anymore, but languages L✷(e; ¯L) still are, and we prove that the complexity
bounds from the certainty column of Fig. 1 remain true. For complexity results, we assume that
in the input (e; ¯L), each domain Li is given either as a regular expression or an NFA over Σ.

6.1 The case of ﬁnite domains

If all domain languages Li’s are ﬁnite, all the lower bounds apply (they were shown when each
Li = Σ). For upper bounds, note that each ﬁnite Li contains at most exponentially many words in
the size of either a regular expression or an NFA that gives it, and each such word is polynomial
size. Thus, the number of valuations is at most exponential in the size of the input, and each
valuation can be represented in polynomial time. The following is then straightforward.

Proposition 6 If domains Li’s of all variables are ﬁnite nonempty subsets of Σ∗, then both
L✷(e; ¯L) and L✸(e; ¯L) are regular languages, and all the complexity bounds on the problems related 
to them are exactly the same as stated in Fig. 1.

9

6.2 The case of inﬁnite domains

We have already seen that if just one of the domains is inﬁnite, then L✸(e; ¯L) need not be regular
(the L✸(xx; Σ∗) example). Somewhat surprisingly, however, in the case of the certainty semantics,
we recover not only regularity but also all the complexity bounds.

Theorem 7 For each parameterized regular expression e using variables x1, . . . , xn and for each
an n-tuple ¯L of regular languages over Σ, the language L✷(e; ¯L) ⊆ Σ∗ is regular. Moreover, the
complexity bounds are exactly the same as in the ✷ column of the table in Fig. 1.

Proof sketch: We only need to be concerned about regularity of L✷(e; ¯L) and upper complexity
bounds, as the proofs of lower bounds apply for the case when all Li = Σ. For this, it suﬃces to

prove that there is a ﬁnite set U of NFAs so that L✷(e; ¯L) = TA∈U L(A). Moreover, it follows from

analyzing the proofs of upper complexity bounds, that the complexity results will remain the same
if the following can be shown about the set U :

• its size is at most exponential in the size of the input;

• checking whether A ∈ U can be done in time polynomial in the size of A;
• each A ∈ U is of size polynomial in the size of the input (e; ¯L).

To show these, take Ae and from it construct a reduced automaton A′
e in which all transitions
(q, xi, q′) are eliminated whenever Li is inﬁnite. We then show that L✷(Ae; ¯L) = L✷(A′
e; ¯L) (the
deﬁnition of L✷ extends naturally from regular expressions to automata for arbitrary domains).
This observation generates a ﬁnite set U of NFAs which result from applying valuations with ﬁnite
codomains to A′
e. We prove in the appendix that these automata satisfy the required properties.

7 Future work

For most bounds (except universality and containment), the complexity under the possibility semantics 
is reasonable, while for the certainty semantics it is quite high (i.e., double-exponential in
practice). At the same time, the concept of L✷(e) captures many query answering scenarios over
graph databases with incomplete information [4]. One of the future directions of this work is to
devise better algorithms for problems related to the certainty semantics under restrictions arising
in the context of querying graph databases.

Another line of work has to do with closure properties: we know that results of Boolean operations 
on languages L✷(e) and L✸(e) are regular and can be represented by NFAs; the bounds
on sizes of such NFAs follow from the results shown here. However, it is conceivable that such
NFAs can be succinctly represented by parameterized regular expressions. To be concrete, one
can easily derive from results in Section 5 that there is a doubly-exponential size NFA A so that
L(A) = L✷(e1) ∩ L✷(e2), and that this bound is optimal. However, it leaves open a possibility that
there is a much more succinct parameterized regular expression e so that L✷(e) = L✷(e1) ∩ L✷(e2);
in fact, nothing that we have shown contradicts the existence of a polynomial-size expression with
this property. We plan to study bounds on such regular expressions in the future.

10

References

[1] S. Abiteboul, S. Cluet, T. Milo. Correspondence and translation for heterogeneous data. TCS 275

(2002), 179–213.

[2] R. Angles, C. Guti´errez. Survey of graph database models. ACM Comput. Surv. 40(1): (2008).

[3] P. Barcel´o, C. Hurtado, L. Libkin, P. Wood. Expressive languages for path queries over graph-structured

data. In PODS’10, pages 3-14.

[4] P. Barcel´o, L. Libkin, J. Reutter. Querying graph patterns. In PODS’11.

[5] J. Bhadra, A. Martin, J. Abraham. A formal framework for veriﬁcation of embedded custom memories
of the Motorola MPC7450 microprocessor. Formal Methods in System Design 27(1-2): 67-112 (2005).

[6] D. Calvanese, G. de Giacomo, M. Lenzerini, M. Y. Vardi. Containment of conjunctive regular path

queries with inverse. In KR’00, pages 176–185.

[7] D. Calvanese, G. de Giacomo, M. Lenzerini, M. Y. Vardi. Rewriting of regular expressions and regular

path queries. JCSS, 64(3):443–465, 2002.

[8] D. Calvanese, G. de Giacomo, M. Lenzerini, M. Y. Vardi. Simplifying schema mappings. In ICDT 2011.

[9] M. P. Consens, A. O. Mendelzon. Low complexity aggregation in GraphLog and Datalog. TCS 116

(1993), 95–116.

[10] I. Glaister, J. Shallit. A lower bound technique for the size of nondeterministic ﬁnite automata. IPL

59:75-77, 1996.

[11] O. Grumberg, O. Kupferman, S. Sheinvald. Variable automata over inﬁnite alphabets. In LATA’10,

pages 561–572.

[12] C. Gutierrez, C. Hurtado, A. Mendelzon. Foundations of semantic web databases. In PODS’04, pages

95–106.

[13] C. Hagenah, A. Muscholl. Computing epsilon-free NFA from regular expressions in O(n log2(n)) time.

In MFCS’98, pages 277–285.

[14] T. Imielinski, W. Lipski. Incomplete information in relational databases. J. ACM 31 (1984), 761–791.

[15] L. Kari, A. Mateescu, G. Paun, A. Salomaa. Multi-pattern languages. TCS 141 (1995), 253-268.
[16] M. Kaminsky, D. Zeitlin. Finite-memory automata with non-deterministic reassignment. IJFCS 21

(2010), 741-760.

[17] D. Kozen. Lower bounds for natural proof systems. In FOCS’77, pages 254-266.
[18] Y. Liu, T. Rothamel, F. Yu, S. Stoller, N. Hu. Parametric regular path queries. In PLDI’04, pages

219–230.

[19] Y. Liu, S. Stoller. Querying complex graphs. In PADL’06, pages 199–214.

[20] O. de Moor, D. Lacey, E. Van Wyk. Universal regular path queries. Higher-Order and Symbolic

Computation 16(1-2): 15-35 (2003).

[21] G. Pesant. A regular language membership constraint for ﬁnite sequences of variables. In CP’04, pages

482–295.

[22] X. Shen, Y. Zhong, C. Ding. Predicting locality phases for dynamic memory optimization. J. Parallel

Distrib. Comput. 67(7): 783-796 (2007).

11

8 APPENDIX: COMPLETE PROOFS

Proof of Theorem 1:

(Part 1) We begin with the upper bound. Let e be a parameterized regular expression, and as
usual assume that W is the set of variables mentioned in e. By deﬁnition, L✷ is deﬁned as the
intersection of each L(v(e)), for all possible valuations ν : W → Σ for e. Clearly, the total number of
those valuations is |Σ||W|. Thus, since there are only exponentially many valuations, an Expspace
algorithm can guess, symbol by symbol, a word w ∈ L✷(e), while checking, in parallel, that w
belongs to each L(ν(e)), for every such valuation ν : W → Σ.

The proof for the lower bound relies heavily on the following lemma:

Lemma 3 Given a set e1, . . . , ek of parameterized expressions over an alphabet Σ that contains at
least two symbols, it is possible to build, in polynomial time with respect to e1, . . . , ek, an expression
e′ such that L✷(e′) is empty if and only if L✷(e1) ∩ · · · ∩ L✷(ek) is empty.

Proof: Let e1, . . . , ek as stated in the Lemma, and let a, b ∈ Σ. We use (Σ − a) as a shorthand
for the expression whose language is the union of every symbol in Σ diﬀerent from a, and deﬁne
Ai = [(Σ − a)∗ · a · (Σ − a)∗]i, for 1 ≤ i ≤ k − 1. Finally, let x1, . . . , xk−1 be fresh variables. We
deﬁne e′ as

(Σ − a)∗ · x1 · (Σ − a)∗ · x2 · (Σ − a)∗ · · · xk−1 · (Σ − a)∗·

(bakb · e1 | b · A1 · bakb · e2 | b · A2 · bakb · e3 | · · · | b · Ak−1 · bakb · ek).

To prove the lemma, consider ﬁrst that a word w that belongs to L✷(e1) ∩ · · · ∩ L✷(ek). Then, it
can be proved that the word (¯ckab)k−1bakbw belongs to L✷(e′) where ¯c is the concatenation (say,
in lexicographical order) of all the symbols in Σ diﬀerent from a. On the other hand, assume that
a word w belongs to L✷(e′). We need the following claim:

Claim 1 The word w can be decomposed into u·bakb·v, where u contains exactly k − 1 appearances
of a.

Proof: By the inspection of e′, we conclude that w must contain the substring bakb. Now, let
w = u · bakb · v, where u does not contain substring bakb. Assume ﬁrst that u contains less than
k − 1 appearances of the symbol a. Then, consider a valuation ν that maps each variable in e′ to
the symbol a. Since ν(e′) is of form

((Σ−a)∗a)k−1(Σ−a)∗·(bakb·ν(e1) | b·A1·bakb·ν(e2) | b·A2·bakb·ν(e3) | · · · | b·Ak−1·bakb·ν(ek)).

we conclude that the language of ν(e′) cannot contain any word that starts with ubakb, since all
the words in L(ν(e′)) must start with a preﬁx in the language

((Σ − a)∗a)k−1(Σ − a)∗ · b.

Next, assume that u contains more than k − 1 appearances of the symbol a, an consider a valuation
ν′ that maps each variable in e′ to the symbol b. Then again, ν′(e′) is of form

((Σ−a)∗b)k−1(Σ−a)∗(bakb·ν′(e1) | b·A1·bakb·ν′(e2) | b·A2·bakb·ν′(e3) | · · · | b·Ak−1·bakb·ν′(ek)).

12

Then, notice that any word in L(ν′(e′)) is such that the symbol a cannot appear more than k − 1
times before the substring bakb. We conclude that L(ν′(e′)) cannot contain a word starting with
u · bakb · v.
✷
Using this Claim, It is now straightforward to show that, if a valuation ν assigns the symbol a to
exactly j variables in {x1, . . . , xk−1} (1 ≤ j ≤ k − 1), then v must belong to L✷(ek−j−1). This
shows that v belongs to L✷(e1) ∩ · · · ∩ L✷(ek), which ﬁnishes the proof of the Lemma.
✷.

Next we continue with the proof of the theorem, speciﬁcally, we show the Expspace lower
bound for the problem Nonemptiness✷. The proof is by a reduction from the acceptance problem
of Turing machines. Let L be a language that belongs to Expspace, and let M be a Turing
machine that decides L in Expspace. Given an input ¯a = a0, . . . , ak−1, we construct in polynomial
time with respect to M and ¯a a parameterized regular expression eM,¯a such that L✷(eM,¯a) 6= ∅ if
and only if M accepts ¯a.

Assume that M = {QM, ΣM, ΣM ∪ {B}, q0, {qm}, δM}; that is, the states of M are QM =
{q0, . . . , qm}, the initial state is q0, the alphabet of the input M is ΣM, and the alphabet of M is
ΓM = ΣM ∪ {B}, that is, M uses an additional blank symbol B; and that the set of transitions
of M is δM. Without loss of generality, we assume that M has only one tape, starts with the
input copied on the ﬁrst |¯a| cells of its tape, that M has only one ﬁnal state qm, and that no
transition is deﬁned for that state. Moreover, it will be easier for us to assume that the machine
always end after an odd number of steps (although the reduction can be improved to work without
this assumption). Since M decides L in Expspace, there is a polynomial S() such that, for every
input ¯a over ΣM, M decides ¯a using space of order 2S(|¯a|). Assume for notation convenience that
S(|¯a|) = n.

Due to Lemma 3, it suﬃces to construct in polynomial time a set E containing a polynomial

number of parameterized regular expressions, such that Te∈E L✷(e) is empty of and only if M

accepts on input ¯a. But before we describe the set E, we need some notation. We use the shorthand
[i] to denote the binary representation of the number i as a string of n characters. For example, [0]
corresponds to the word 0n, and [2] corresponds to the word 0n−210. Roughly speaking, any word
accepted by all the expressions in E should represent a valid run of the Turing machine. In order

to do so, E is constructed so that all words that belong to Te∈E L✷(e) represent a sequence

[even] · L0 · [even] · [odd] · L1 · [odd] · [even] · L2 · [even] · · · ,

where each of the L’s represent a conﬁguration of M, coded as

(action · stateb · [0] · statea · action · stateb · [1] · statea · · · action · stateb · [2n − 1] · statea)∗.

Each construct action·state·[i]·state represents the content of the i-th cell of the Turing machine
before and after one given point of the computation, plus the action that was performed in that
cell in the given step step. More precisely, the word action is a three bit string that codes either
nothing, read/write, or advance head, stateb is a binary word coding ΣM ∪ ΣM × QM, representing
the content of the i-th cell before a given step in the computation of M (if stateb codes a pair in
ΣM × QM this represents that M was pointing at that cell), [i] is the binary representation of the
number i (0 ≤ i ≤ 2n − 1) that represents the cell’s position, and statea is a binary word coding
ΣM ∪ ΣM × QM that represents the content of the i-th cell after the computation.

Thus, intuitively, each of this words can be seen as a sequence of descriptions of M , each
description consisting of a sequence of tuples that encode, for each cell, the construct action, state

13

before the action, position and state after the action. The idea behind the reduction is that E
should only accept those words representing a valid computation, that ends in a ﬁnal state. The
rest of the reduction is devoted to construct such set E. We divide the set E into sets Ef orm, Ei,
Ef , Eorder and Estate. But let us ﬁrst show our coding scheme.

Let p = log(Γ + |Γ||Q|). We code each content of a cell (that is, strings corresponding to
statea and stateb coding Γ ∪ Γ × QM as a p-bit string. Moreover, we code the actions as 3-bit
strings. For simplicity, we denote this strings by [even], [odd], [nothing], [read] and [head]; where
[even] = 000, [odd] = 001, [nothing] = 100, [read] = 101 and [head] = 111. Finally, we use [action]
as a shorthand for [nothing] | [read] | [head] (or, equivalently, 100 | 101 | 111).

We now deﬁne the expressions in E. First, Ef orm contains the expression

(cid:0)[even][action](0 | 1)p(0 | 1)n(0 | 1)p[even][odd][action](0 | 1)p(0 | 1)n(0 | 1)p[odd](cid:1)∗

was explained in the previous paragraphs.

The intuition behind Ef orm is that it deﬁnes that each word in Te∈E L✷(e) is of the form that
Next, we deﬁne Eorder, that intuitively forces each of the description of the L’s in Te∈E L✷(e)
(action · stateb · [0] · statea · action · stateb · [1] · statea · · · action · stateb · [2n − 1] · statea)∗.

to be of form

That is, the slots used to code the position of the cell in each description have to be arranged in
numerical order. We split Eorder into Eeven
order contains
the expression

order. The sets are as follows: Eeven

order and Eodd

(cid:18)(cid:0)[even] | [odd][action](0 | 1)p[0](0 | 1)p[even] + [odd](cid:1)·

(cid:0)[even] | [odd][action](0 | 1)p(0 | 1)n(0 | 1)p[even] + [odd](cid:1)∗(cid:19)∗

stating, intuitively, that each portion of the words belonging to Eorder start with a [0] in the
order contains the

slot corresponding to the cell position. In addition, for each 1 ≤ m ≤ n − 1, Eeven
expression

(cid:0)[even] | [odd]
(cid:18)(cid:0)[action](0 | 1)p(0 | 1)n−m−10(0 | 1)m−10(0 | 1)p[action](0 | 1)p(0 | 1)n−m−10(0 | 1)m−11(0 | 1)p(cid:1)|
(cid:0)[action](0 | 1)p(0 | 1)n−m−11(0 | 1)m−10(0 | 1)p[action](0 | 1)p(0 | 1)n−m−11(0 | 1)m−11(0 | 1)p(cid:1)(cid:19)∗
[even] | [odd](cid:1)∗

The idea is that each substring [i] marking an even position in the tape has to be followed 
by it’s successor [i], by forcing the word to be a concatenation of consecutive constructs
actionstatea[i]stateb actionstatea[j]stateb in which (1) [i] ends in 0 and [j] ends in 1, and (2) the
t-th bit of [i] and [j] are equal, for every 1 ≤ t ≤ n − 1 (where the last bit of [i] is the n-th one). In
the same fashion, Eodd
order ensures that each string representing an odd position is to be followed by

14

it’s successor, and that the last of these substrings has to be [2n − 1], or 1n. We omit the description
since it follows the same lines of Eeven
order.

Next, Ei ensures that the ﬁrst description corresponds to the initial conﬁguration of M:

it

contains the expression

[even][nothing][q, a0][0][q, a0][nothing][a1][1][a1][nothing][ak−1][k − 1][ak−1]

Here we abuse the notation, and put [a] instead of the string coding the content a ∈ Σ, and [q, a]
instead of the string coding the content a ∈ ΣM, and stating that the head is in the corresponding
position, in a state q ∈ QM.

(cid:0)[nothing][B](0 | 1)n[B](cid:1) ∗ [even]Σ∗

M

Furthermore, the expressions in Ef ensure that the last description ends in a ﬁnal state:

it

contains only the expression

Σ∗[even] | [odd]

[q∈Q,a∈Γ
(cid:0)[action](0 | 1)p(0 | 1)n(0 | 1)p)∗[head](0 | 1)p(0 | 1)n[q, a]([action](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)∗

[even] | [odd]

Next, we ensure that the state is carried along the descriptions: the state after the action in
the j-th description has to coincide with the state carried along the j + 1-th description. This is
accomplished with parameterized expressions Eeven
state requires that, for all i,
0 ≤ i ≤ 2n − 1, the state after an even computation in the i-th cell of the tape corresponds exactly
to the state before the next computation.

state, where Eeven

state and Eodd

Eeven

state = (cid:18) [state∈Γ∪Γ×Q(cid:0)[even]([action](0 | 1)p(0 | 1)n(0 | 1)p)∗

([action](0 | 1)px1 · · · xn[state]([action](0 | 1)p(0 | 1)n(0 | 1)p)∗[even]
[odd]([action](0 | 1)p(0 | 1)n(0 | 1)p)∗([action][state]x1 · · · xn(0 | 1)p

([action](0 | 1)p(0 | 1)n(0 | 1)p)∗[odd](cid:1)(cid:19)∗

,

Expression Eodd

state is deﬁned accordingly, simply by interchanging strings [even] and [odd], but
carefully allowing for the possibility that a word representing a computation might end in an odd
conﬁguration (that is, an odd conﬁguration may be followed by an even conﬁguration with the
aforementioned properties, or may be the last conﬁguration of the computation).

Finally, we describe the set Eaction. Intuitively, the expressions in this set ensure that in each
conﬁguration a step is taken that is valid w.r.t. the transitions in δM. Roughly speaking, it forces
each conﬁguration to be of form Lδ, for some transition δ ∈ δM. The formal description is as
follows. For each transition in δM of form δ(q, a) = (q′, a′, {→, ←}), let Ldelta be the language

15

(cid:18)[even] | [odd](cid:0)[nothing](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)∗
[b∈Γ
[read][q, a](0 | 1)n[a′][head][b](0 | 1)n[q′, b](cid:0)[nothing](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)∗[even] | [odd](cid:19),

if δ advances to the right, or the language

(cid:18)[even] | [odd](cid:18)[nothing](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)∗
[b∈Γ
[head][b](0 | 1)n[q′, b][read][q, a](0 | 1)n[a′](cid:0)[nothing](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)∗[even] | [odd](cid:19),

if δ moves to the left. Then, Eaction includes the expression

[even](cid:0)[nothing](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)∗[even]( [δ∈δM

Lδ)∗.

Moreover, it also includes the expression

([even] | [odd](cid:18)(cid:0) [state∈Γ∪Γ×Q

[nothing][state](0 | 1)n[state](cid:1)|

(cid:0)[read](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)|

(cid:0)[head](0 | 1)p(0 | 1)n(0 | 1)p(cid:1)(cid:19)∗

[even] | [odd])∗,

which ensures that the content of a cell does not change if no action is perceived on it.

It follows immediately from the construction that Te∈E L✷(e) is empty if and only if M accepts

on input ¯a.

(Part 2) Let A be an NFA over Σ ∪ W, where W is a set of variables. Then, for every two
valuations ν1 and ν2, we have L(ν1(A)) 6= ∅ iﬀ L(ν2(A)) 6= ∅. Indeed, a path from an initial to a
ﬁnal state in one automaton guarantees the existence of such a path in the other one. Hence to
check L✸(A) 6= ∅ one can take an arbitrary valuation ν and check whether L(ν(A)) 6= ∅; this of
course is reachability and can be done in NLogspace. Hardness is already known for automata
that do not use variables.

Proof of Lemma 2 :

Consider ﬁrst the case when Σ has at least two symbols. Then, by using the construction of Lemma
3 it is easy to see that the resulting expression e′ is of size O(|Σ| · k + k · (|Σ| + n + k)). We have
assumed than k ≤ n, and it is reasonable to assume that |Σ| ≤ k ≤ n, thus the resulting expression
is of size O(k · n).

If Σ contains a single symbol, then for 1 ≤ i ≤ k we have that L✷(ei) = L(e′

i is the
expression resulting from replacing all parameters in ei with the symbol from Σ. Afterwards, Σ
can be augmented with an extra symbol and the construction of Lemma 3 can be used just as we
have previously explained, except this time on input e′

i), where e′

1, . . . , e′
k.

16

Te∈EM,¯a
smallest word w′ ∈ Te∈EM,¯a

L✷(e).

Proof of Corollary 1 :

We begin the proof with some observations. Given a Turing machine M that decides on input ¯a
using exponential space, the reduction of Theorem 1 essentially constructs a set of parameterized
L✷(e) represents a run (or, more

regular expressions EM,¯a such that every word w ∈ Te∈EM,¯a

precisely, a sequence of conﬁgurations) of M on input a.

Moreover, the same proof also shows how to construct a regular expression eM,¯a such that
L✷(e) is empty if and only if L✷(eM,¯a) is empty. Notice as well that from the proof of
Lemma 3 it is easy to see that the size of every word w ∈ L✷(eM,¯a) is at least the size of the

Next, we deﬁne the sequence {en}n∈N of parameterized regular expressions as stated in the
corollary. Clearly, for each n ∈ N, it is possible to construct a deterministic Turing machine Mn
over alphabet Σ = {0, 1} that on input 1n works for exactly 22n steps, using at most 2n cells.

Thus, for each n, we deﬁne en as the expression such that L✷(en) is empty if and only if

Te∈EMn,1n L✷(e) is empty, constructed as in the proof of Lemma 3.
According to the reduction in the proof of Theorem 1, Te∈EMn,1n L✷(e) contains a single word,
of length greater than 22n, representing the single run of Mn on input 1n. Then, by our above
observations, we conclude that all words in L✷(en) are of size at least 22n.

Proof of Proposition 1 :

(Part 1) The Expspace reduction on Theorem 1 can be modiﬁed so that all the expressions in
E are simple. In order to do this, we shall modify the coding scheme of the previous reduction.
Basically, the new reduction should include one preceding bit in each of the slots corresponding
to action, stateb (content of the cell before the action), position and statea (content of the cell
after the action). This extra bit is set to 0 if these are part of an even conﬁguration (that is, a
conﬁguration between two strings [even]), or 1 if they are part of an odd conﬁguration.

Under this modiﬁed coding, all that is left to do is to modify the set E according to the new
state, the rest being straightforward.

state and Eodd

coding. The only substantial change is in the sets Eeven
Thus, we only state these expressions. Deﬁne Eeven

state as follows:

(cid:18) [state∈Γ∪Γ×Q(cid:0)[even]((0 | 1)4(0 | 1)p+1(0 | 1)n+1(0 | 1)p+1)∗((0 | 1)4(0 | 1)p+1
(cid:18)x1 · · · xn(cid:0)0[state](0(0 | 1)30(0 | 1)p(0 | 1)n0(0 | 1)p)∗[even]
[odd](1(0 | 1)31(0 | 1)p(0 | 1)n1(0 | 1)p)∗1(0 | 1)31[state](cid:1) |

(cid:0)1(0 | 1)p1(0 | 1)31(0 | 1)p(0 | 1)n1(0 | 1)p)∗[odd](cid:1)(cid:19)∗(cid:19)∗

.

And, Eodd

state is deﬁned accordingly, by mutually interchanging all appearances of [even] and [odd].
state) that

Notice that, from the form of the rest expressions in E, the only words w ∈ L✷(Eeven

belongs toTe∈E L✷(e) are those in which after every string of form ν(x1) · · · ν(xn) for some valuation

17

ν : Σ → {x1, . . . , xn} we follow with a string in

0[state](0(0 | 1)30(0 | 1)p(0 | 1)n0(0 | 1)p)∗[even]

[odd](1(0 | 1)31(0 | 1)p(0 | 1)n1(0 | 1)p)∗
1(0 | 1)31[state]ν(x1) · · · ν(xn)1(0 | 1)p

1(0 | 1)31(0 | 1)p(0 | 1)n1(0 | 1)p)∗[odd]

(1)

Thus, under this modiﬁed coding, expressions Eeven

state have the same intended behavior
as in the reduction of Theorem 1. We omit the rest of the reduction since it goes along the same
lines as the previous version.

state and Eodd

(Part 2): It is easy to see that, if e does not use Kleene star, then all the words w ∈ L✷(e) are
of size polynomial with respect to the size of e. This immediately gives a ΣP
2 algorithm for the
emptiness problem: Given a a parameterized regular expression e not using Kleene star, guess a
word w and a valuation ν for e, and check that w /∈ L✷(e) (which, from Theorem 2, can be performed
using an NP oracle). The ΣP
2 hardness is established via a reduction from the compliment of the
∀∃ 3-SAT satisﬁability problem. This problem is deﬁned as follows: formula ϕ is the conjunction
of clauses {C1, . . . , Cp}, each of which has 3 variables from the disjoint union of {x1, . . . , xm} and
{y1, . . . , yt}. The problem asks whether there exists an assignment σ¯x for {x1, . . . , xm} such that
for every assignment σ¯y for {y1, . . . , yt} it is the case that ϕ is not satisﬁable.

Let ϕ := ∀x1 · · · ∀xm∃y1 . . . ∃yt C1 ∧ · · · ∧ Cp be an instance of ∀∃ 3-SAT. From ϕ we construct
in polynomial time a parameterized regular expression e over alphabet Σ = {0, 1} such that there
exists an assignment σ¯x for {x1, . . . , xm} such that for every assignment σ¯y for {y1, . . . , yt} it is the
case that ϕ is not satisﬁable if and only if L✷(e) is not empty.

Let each Cj (1 ≤ j ≤ p) be of form (ℓ1

j, for 1 ≤ j ≤ p and
1 ≤ i ≤ 3, is either a variable in {x1, . . . , xm} or {y1, . . . , yt}, or its negation. We associate with each
propositional variable xk, 1 ≤ k ≤ m, a fresh variable Xk (representing the positive literal) and a
fresh variable ˆXk (representing the negation of such literal). Also, with each propositional variable
yk , 1 ≤ k ≤ t, we associate fresh variables Yk and ˆYk. Then let W = {X1, . . . , Xm, ˆX1, . . . , ˆXm} ∪
{Y1, . . . , Yt, , ˆY1, . . . , ˆYt} ∪ {Z}, where Z is a fresh variable as well.

j ), where each literal ℓi

j ∨ ℓ2

j ∨ ℓ3

Next we deﬁne expression e over Σ = {0, 1} and W. We ﬁnd it useful to split the deﬁnition in

two parts. First, deﬁne

e = (Z · 0 · e1) | (1Ze2),

e1 = 1100(0 | 1)m000

e2 = e2,2,1 | · · · | e2,2,m | e2,2,1 | · · · | e2,2,m | e2,3,1 | · · · | e2,3,t e2,3 | e2,4,

with

and

where

• for each 1 ≤ k ≤ m, deﬁne e2,1,k = 1100(0 | 1)k−1Xk(0 | 1)m−k000

• for each 1 ≤ k ≤ m, deﬁne e2,2,k = (cid:0)Xk ˆXk00(0 | 1)m000(cid:1) | (cid:0)11Xk ˆXk(0 | 1)m000(cid:1);
• for each 1 ≤ k ≤ t, e2,3,k = (cid:0)Yk ˆYk00(0 | 1)m000(cid:1) | (cid:0)11Yk ˆYk(0 | 1)m000(cid:1);

18

• Let h be a function that maps each literal ℓi

to ˆXk, if ℓi
corresponds to yk or to ˆYk, if ℓi
p) · h(ℓ2
h(ℓ2

j corresponds to xk or
j corresponds to ¬xk (1 ≤ j ≤ p, 1 ≤ i ≤ 3 and 1 ≤ k ≤ m); or to Yk, if ℓi
j
j corresponds to ¬yk. Then deﬁne e2,4 = 1100(0 | 1)m(cid:0)h(ℓ1
1) ·
p) · h(ℓ3
p)(cid:1).

j to the variable Xk, if ℓi

1) · h(ℓ3

1) | · · · | h(ℓ1

We now prove that L✷(e) 6= ∅ if and only if there exists an assignment σ¯x for {x1, . . . , xm} such

that for every assignment σ¯y for {y1, . . . , yt} it is the case that ϕ is not satisﬁable.

(⇐): Assume ﬁrst that there exists an assignment σ¯x for {x1, . . . , xm} such that for every
assignment σ¯y for {y1, . . . , yt} it is the case that ϕ is not satisﬁable. Deﬁne a1, . . . , am as follows:
for each 1 ≤ k ≤ m, ak = 0 if and only iﬀ σ¯x assigns the value 1 to the variable xk. Let then
w = 101100a1 · · · am000 be a word in Σ∗. We claim that w ∈ L✷(e). To prove this claim, let
ν : W → Σ be a valuation. We show that w ∈ L(ν(e)). The proof is done via a case by case
analysis:

• Assume ﬁrst that ν(Z) = 1. Then, since 1100a1 · · · am000 is clearly denoted by e1, we have

that w ∈ L(ν(e)).

• Next, assume that ν(Z) = 0, and for some 1 ≤ k ≤ m it is the case that ν(Xk) = ν( ˆXk).

Then, it is easy to see that 1100a1 · · · am000 is denoted by expression

ν(e2,2,k) = (cid:0)ν(Xk)ν( ˆXk)00(0 | 1)m000(cid:1) | (cid:0)11ν(Xk)ν( ˆXk)(0 | 1)m000(cid:1).

And thus we have that w ∈ L(ν(e)).

• Assume now that ν(Z) = 0, and for some 1 ≤ k ≤ t it is the case that ν(Yk) = ν( ˆYk). Then,

it is easy to see that 1100a1a1 · · · amam000 is denoted by expression

ν(e2,3,k) = (cid:0)ν(Yk)ν( ˆYk)00(0 | 1)m000(cid:1) | (cid:0)11ν(Yk)ν( ˆYk)(0 | 1)m000(cid:1).

And thus we have that w ∈ L(ν(e)).

The remaining valuations are such that ν(Z) = 0, ν(Xk) 6= ν( ˆXk) for each 1 ≤ k ≤ m, and for each
1 ≤ k ≤ t we have that ν(Yk) 6= ν( ˆYk). Let us continue.

• Assume now that for some 1 ≤ k ≤ m it is the case that ν(Xk) = 1 but σ¯x(xk) = 0. Then,
ak = 1, and thus it is easy to see that the word 1100a1 · · · am000 is denoted by ν(e2,1,k),
that corresponds to the expression 1100(0 | 1)k−1ν(Xk)(0 | 1)m−k000 which entails that w is
denoted by ν(e).

• Assume now that that ν(Z) = 0, ν(Xk) 6= ν( ˆXk) for each 1 ≤ k ≤ m, for each 1 ≤ k ≤ t
we have that ν(Yk) 6= ν( ˆYk), and for some 1 ≤ k ≤ m it is the case that ν(Xk) = 0 but
σ¯x(xk) = 1. Then, ak = 0, and thus it is easy to see that the word 1100a1 · · · am000 is
denoted by ν(e2,1,k), that corresponds to the expression 1100(0 | 1)k−1ν(Xk)(0 | 1)m−k000
which entails that w is denoted by ν(e).

• Finally, assume that ν(Z) = 0, ν(Xk) 6= ν( ˆXk) for each 1 ≤ k ≤ m, for each 1 ≤ k ≤ t
we have that ν(Yk) 6= ν( ˆYk), and for each 1 ≤ k ≤ m it is the case that ν(Xk) = σ¯x(xk).
Deﬁne the following valuation σ¯y for the variables in {y1, . . . , yt}: σ¯y(yk) = ν(Yk), for each
1 ≤ k ≤ t. From our initial assumption, there exists at least a clause Cj, 1 ≤ j ≤ p, that is

19

falsiﬁed under the assignment σ¯x, σ¯y. From the fact that ν(Xk) 6= ν( ˆXk) for each 1 ≤ k ≤ m,
for each 1 ≤ k ≤ t we have that ν(Yk) 6= ν( ˆYk), and for each 1 ≤ k ≤ m it is the case that
ν(Xk) = σ¯x(xk), we conclude that ν(h(ℓ1
1)) corresponds to the string 000,
which proves that 1100a1 · · · am000 belongs to L(ν(e2,4)), and thus w is denoted by ν(e).

1)) · ν(h(ℓ3

1)) · ν(h(ℓ2

(⇒): Assume now that there exists a word w in L✷(e).

It is straightforward to show that
w must begin with the preﬁx 10:
if w begins with either 00 or 01 then it cannot be denoted by
ν1(e), where ν1 assigns a letter 1 to all variables in W. Moreover, if it begins with 11 then it
cannot be accepted by the valuation that assigns the letter 0 to all variables. Let then w = 10v.
Furthermore, let ν be an arbitrary valuation such that ν(Z) = 1. since w belongs to L(ν(e)), then
v must be denoted by e1, and so it must be that v is of form 1100(0 | 1)m000. Let σ¯x be a valuation
for {x1, . . . , xm} deﬁned as follows: σ¯x(xk) = 1 if v is of form 1100(0 | 1)k−10(0 | 1)m−k000, and
σ¯x(xk) = 0 if v is of form 1100(0 | 1)k−11(0 | 1)m−k000. Next, we show that for each valuation σ¯y
for {y1, . . . , yt} it is the case that ϕ is not satisﬁed with valuation σ¯x, σ¯y. Assume for the sake of
contradiction that there is a valuation σ¯y for {y1, . . . , yt} such that σ¯x, σ¯y satisﬁes ϕ. Deﬁne the
following valuation ν : W → Σ:

• ν(Z) = 0

• ν(Xk) = σ¯x(xk), for each 1 ≤ k ≤ m,

• ν(Yk) = σ¯y(yk), for each 1 ≤ k ≤ t,

• ν( ˆXk) = 1 if and only if ν(Xk) = 0,

• ν( ˆYk) = 1 if and only if ν(Yk) = 0

Let us now show that 10v /∈ L(ν(e)), contradicting our initial assumption that L✷(e) = ∅. Since
ν(Z) = 0, we have then that v must be denoted by e2. Since ν(Xk) 6= ν( ˆXk) for each 1 ≤ k ≤ m and
for each 1 ≤ k ≤ t we have that ν(Yk) 6= ν( ˆYk), it is easy to see that word v cannot be in L(ν(e2,2,k))
for 1 ≤ k ≤ m or in L(ν(e2,3,k)) for 1 ≤ k ≤ t. Moreover, since σ¯x(xk) = 1 = ν(Xk) if v is of form
1100(0 | 1)k−10(0 | 1)m−k000, and σ¯x(xk) = 1 = ν(Yk) if v is of form 1100(0 | 1)k−10(0 | 1)m−k000, we
have that v cannot be in L(ν(e2,1,k)) for 1 ≤ k ≤ m. The only remaining possibility is that the word
v belongs to ν(e4). This implies that for some 1 ≤ j ≤ p, it is the case that ν(h(ℓ1
1))
corresponds to the string 000 But we know from the deﬁnition of ν that that cannot be true, as we
have assumed that σ¯x, σ¯y satisﬁes ϕ. We conclude that 10v /∈ L(ν(e)), which was to be shown.

1))·ν(h(ℓ3

1))·ν(h(ℓ2

Proof of Theorem 2:

The ﬁrst part follows from the ﬁrst part of Theorem 3. We prove the second part here. We use a
reduction from Positive 1-3 3-SAT, which is the following NP-hard decision problem: Given a
conjunction ϕ of clauses, with exactly three literals each, and in which no negated variable occurs,
is there a truth assignment to the variables so that each clause has exactly one true variable?

The reduction is as follows. Let ϕ = C1 ∧ · · · ∧ Cm be a formula in CNF, where each Ci
(1 ≤ i ≤ m) is a clause consisting of exactly tree positive literals. Let {p1, . . . , pn} be the variables
that appear in ϕ. With each propositional variable pi (1 ≤ i ≤ n) we associate a diﬀerent variable
xi ∈ V. We show next how to construct, in polynomial time from ϕ, a parameterized regular
expression e over alphabet Σ = {a, 0, 1} and a word w over the same alphabet, such that there is

20

an assignment to the variables of ϕ for which each clause has exactly one true variable if and only
if w ∈ L✸(e).

The parameterized regular expression e is deﬁned as ae1ae2a · · · aema, where the regular expression 
ei, for 1 ≤ i ≤ m, is deﬁned as follows: Assume that Ci = (pj ∨ pk ∨ pℓ), where 1 ≤ j, k, ℓ ≤ n.
Then ei is deﬁned as (xjxkxℓ | xjxℓxk | xkxjxℓ | xkxℓxj | xℓxjxk | xℓxkxj). That is, ei is just the union
of all the possible forms in which the variables in V that correspond to the propositional variables
that appear in Ci can be ordered. Further, the word w is deﬁned as (a100)ma. Clearly, e and w can
be constructed in polynomial time from ϕ. Next we show that there is an assignment for variables
{p1, . . . , pn} for which each clause has exactly one true variable if and only if w ∈ L✸(e).

Assume ﬁrst that w ∈ L✸(e). Then there exists a valuation ν : {x1, . . . , xn} → Σ such that
w ∈ L(ν(e)). Thus, it must be the case that the word a100 belongs to ν(aei), for each 1 ≤ i ≤ m.
But this implies that if Ci = (xj ∨xk∨xℓ), then ν assigns value 1 to exactly one of the variables in the
set {xj, xk, xℓ} and it assigns value 0 to the other two variables. Let us deﬁne now a propositional
assignment σ : {p1, . . . , pn} → {0, 1} such that σ(pi) = ν(xi), for each 1 ≤ i ≤ n. It is not hard to
see then that for each clause Cj, 1 ≤ j ≤ m, σ assigns value 1 to exactly one of its propositional
variables.

Assume, on the other hand, that there is a propositional assignment σ : {p1, . . . , pn} → {0, 1}
that assigns value 1 to exactly one variable in each clause Ci, 1 ≤ i ≤ m. Let us deﬁne ν as a
valuation from {x1, . . . , xn} into {0, 1} such that ν(xi) = 1 if and only if σ(pi) = 1. Clearly then
100 ∈ L(ν(ei)), for each 1 ≤ i ≤ m. Thus, (a100)ma ∈ L(ν(e)). We conclude that w ∈ L✸(e).

Proof of Proposition 2:

For the sake of readability, in this proof we use ∪ – instead of | – for representing the operation of
union between regular expressions.

We ﬁrst consider the ✸-semantics. Notice that the reduction used in the proof of Theorem 2, to
show NP-hardness of Membership✸, constructs a regular expression that is of star-height 0. This
shows NP-hardness of Membership✸ for expressions of star height 0. We prove NP-hardness of
Membership✸ for simple expressions here.

We use a reduction from 3-SAT. Let ϕ = V1≤i≤n(ℓ1
i ) be a propositional formula in
3-CNF over variables {p1, . . . , pm}. That is, each literal ℓj
i , for 1 ≤ i ≤ n and 1 ≤ j ≤ 3, is either
pk or ¬pk, for 1 ≤ k ≤ m. Next, we show how to construct in polynomial time from ϕ, a simple
regular expression e over alphabet Σ = {a, b, c, d, 0, 1} and a word w over the same alphabet such
that ϕ is satisﬁable if and only if w ∈ L✸(e).

i ∨ ℓ2

i ∨ ℓ3

The regular expression e is deﬁned as f ∗, where f := a(f1 ∪ g1 ∪ · · · ∪ fm ∪ gm)b, and the regular

expressions fi and gi are deﬁned as follows.

Formally, we deﬁne fi (1 ≤ i ≤ m) as ((ci ∪S{1≤j≤n|pi = ℓ1
fresh variable in V. In the same way we deﬁne gi as ((ci∪S{1≤j≤n|¬pi = ℓ1

Intuitively, fi (resp. gi) codiﬁes pi (resp. ¬pi) and the clauses in which pi (resp. ¬pi) appears.
j } dj) · xi), where xi is a
j } dj)·¯xi),
where ¯xi is a fresh variable in V. The variable xi (resp. ¯xi) is said to be associated with pi (resp.
¬pi) in e.

j or ¬pi = ℓ3

j or ¬pi = ℓ2

j or pi = ℓ2

j or pi = ℓ3

Clearly, e is a simple regular expression and can be constructed in polynomial time from ϕ.
The word w is deﬁned as:

ac1b ac0b acc1b acc0b · · · acm1b acm0b ad1b add1b · · · adn1b.

21

Clearly, w can be constructed in polynomial time from ϕ. Next we show that ϕ is satisﬁable if and
only if w ∈ L✸(e).

Assume ﬁrst that w ∈ L✸(e). That is, there is a valuation ν for the variables {x1, ¯x1, . . . , xm, ¯xm}
over Σ such that w ∈ L(ν(e)). But then, given the form of w, it is clear that aci1b and aci0b belong
to L(ν(f )), for each 1 ≤ i ≤ m. Notice that the only way for this happen is that both ν(xi)
and ν(¯xi) take its value in the set {0, 1}, and, further, ν(xi) 6= ν(¯xi). For the same reasons,
adj1b ∈ L(ν(f )), for each 1 ≤ j ≤ n. But the only way for this to happen is that for each 1 ≤ j ≤ n
it is the case that either the variable associated with ℓ1
j in e is assigned value
1 by ν. Thus, the propositional assignment σ : {p1, . . . , pm} → {0, 1}, deﬁned as σ(pi) = 1 if and
only if ν(xi) = 1, is well-deﬁned and satisﬁes ϕ.

j or with ℓ2

j or with ℓ3

Assume, on the other hand,

that there is a satisfying propositional assignment σ :
{p1, . . . , pm} → {0, 1} for ϕ. Consider the following valuation ν : {x1, ¯x1, . . . , xm, ¯xm} for e:
ν(xi) = σ(pi) and ν(¯xi) = 1 − σ(xi). Using essentially the same techniques than in the previous 
paragraph it is possible to show that w ∈ L(ν(e)), and, therefore, that w ∈ L✸(e).

Next we show that Membership✸ can be solved in time O(mn · log2 n) for simple expressions
of star-height 0. Given a regular expression e ∈ REG(Σ, V) that is simple and of star-height 0, one
can construct in time O(n · log2 n) [13] an ε-free NFA A over Σ ∪ V that accepts precisely L(e), and
satisﬁes the following two properties: (1) Its underlying directed graph is simple and acyclic (this is
because e does not mention the Kleene star), and (2) for each x ∈ V that is mentioned in e there is
at most one pair (q, q′) of states of A such that A contains a transition from q to q′ labeled x (this
is because e is simple). From Lemma 1, checking whether w ∈ L✸(e), for a given word w ∈ Σ∗, is
equivalent to checking whether w ∈ L(ν(A)), for some valuation ν for A. We show how the latter
can be done in polynomial time.

First, construct in time O(m) a DFA B over Σ such that L(B) = {w}. We assume without
loss of generality that the set Q of states of A is disjoint from the set P of states of B. Next we
construct, the following NFA A′ over alphabet Σ ∪ (V × Σ) as follows: The set of states of A′ is
Q × P . The initial state of A′ is the pair (q0, p0), where q0 is the initial state of A and p0 is the
initial state of B. The ﬁnal states of A′ are precisely the pairs (q, p) ∈ Q × P such that q is a ﬁnal
state of A and p is a ﬁnal state of B. Finally, there is a transition in A′ from state (q, p) to state
(q′, p′) labeled a ∈ Σ if and only there is a transition in A from q to q′ labeled a and there is a
transition in B from p to p′ labeled a. There is a transition in A′ from state (q, p) to state (q′, p′)
labeled (x, a) ∈ V × Σ if and only there is a transition in A from q to q′ labeled x and there is a
transition in B from p to p′ labeled a. Clearly, such construction can be performed by checking all
combinations of transitions of both A and B, and thus it can be performed in time O(mn · log2 n).
Checking whether L(A′) 6= ∅ can easily be done in linear time w.r.t. the size of A′, thus obtaining
the O(mn · log2 n) bound. We prove next that checking this is equivalent to checking whether
w ∈ L(ν(A)), for some valuation ν for A, which ﬁnishes the proof of the proposition in terms of
the ✸-semantics.

Assume ﬁrst that L(A′) 6= ∅. Let (q0, p0)

un−→ (qn, pn)
be an accepting run of A′. That is, u1u2 · · · un ∈ (Σ ∪ (V × Σ))∗ and (qn, pn) is a ﬁnal state
of A′. Since the underlying directed graph of A is acyclic, and each variable x mentioned in e
appears in at most one transition of A, it must be the case that for each 1 ≤ i < j ≤ n, if
ui = (xi, ai) ∈ V × Σ and uj = (xj, aj) ∈ V × Σ then xi 6= xj. This implies that we can deﬁne a
mapping ν : W → Σ, where W is the set of variables used in transitions of A, such that ν(x) = a,
if ui = (x, a) for some 1 ≤ i ≤ n, and ν(x) is an arbitrary element a′ ∈ Σ, otherwise.
It is

un−1−−−→ (qn−1, pn−1)

u1−→ (q1, p1)

u2−→ · · ·

22

an−→ qn is also an accepting run of L(ν(A))
not hard to see that q0
and that a1a2 · · · an = w. The latter can be proved as follows: Let f : {u1, . . . , un} → Σ be the
mapping such that f (ui) = ui, if ui = a ∈ Σ, and f (ui) = a, if ui = (x, a) ∈ V × Σ. Then

a2−→ · · ·

a1−→ q1

an−1−−−→ qn−1

f (u1)
−−−→ p1

f (un)
−−−→ pn is an accepting run of B, and, therefore,
clearly p0
w = f (u1) · · · f (un). Further, let g : {u1, . . . , un} → Σ be the mapping such that g(ui) = ui, if
ui = a ∈ Σ, and g(ui) = ν(x) = a, if ui = (x, a) ∈ V × Σ. Then clearly f (ui) = g(ui), for each

f (un−1)
−−−−−→ pn−1

f (u2)
−−−→ · · ·

1 ≤ i ≤ n, and, further, q0
We conclude that w ∈ L(ν(A)).

g(u1)
−−−→ q1

g(u2)
−−−→ · · ·

g(un−1)
−−−−−→ qn−1

g(un)
−−−→ qn is an accepting run of L(ν(A)).

Assume, on the other hand, that w ∈ L(ν(A)), for some valuation ν for A. Suppose that
an−→ qn be an
w = a1a2 · · · an, where each ai ∈ Σ (1 ≤ i ≤ n), and let q0
accepting run of L(ν(A)); i.e. qn is a ﬁnal state of A. Assume that i1 < i2 < · · · < im are the only
indexes in the set {0, 1, . . . , n − 1} such that, for each 1 ≤ j ≤ m, there is no transition labeled
aij +1 from qij to qij+1 in A. Then there must be a transition in A from qij to qij+1 labeled xij ∈ V.
an−→ pn of B; i.e. pn is a ﬁnal state
Consider an arbitrary accepting run p0
of B. Then it is clear that

an−1−−−→ pn−1

an−1−−−→ qn−1

a2−→ · · ·

a2−→ · · ·

a1−→ q1

a1−→ p1

(q0, p0)

a1−→ (q1, p1) · · · (qi1, pi1)

(xi1 ,ai1+1)
−−−−−−−→ (qi1+1, pi1+1) · · ·

(qim, pim)

(xim ,aim+1)
−−−−−−−−→ (qim+1, pim+1) · · · (qn−1, pn−1) → an(qn, pn)

is an accepting run of A′. Thus, L(A′) 6= ∅.

Now we deal with the ✷-semantics. That Membership✷ is coNP-hard, even over the class
of expressions of star-height 0, follows from Theorem 3. Next we prove that Membership✷ is
coNP-hard, even over the class of simple regular expressions.

We use a reduction from 3-SAT to the complement of Membership✷ over the class of simple
i ∨ ℓ3
i ∨ ℓ2
expressions. Let ϕ = V1≤i≤n(ℓ1
i ) be a propositional formula in 3-CNF over variables
{p1, . . . , pm}. That is, each literal ℓj
i , for 1 ≤ i ≤ n and 1 ≤ j ≤ 3, is either pk or ¬pk, for
1 ≤ k ≤ m. Next, we show how to construct in polynomial time from ϕ, a simple regular expression
e over alphabet Σ = {a, b, 0, 1} and a word w over the same alphabet such that ϕ is satisﬁable if
and only if w 6∈ L✷(e).

We start by deﬁning the word w as follows:

w := 1111a 11111a b 1110a 11110a b 111111a 1111111a b 111110a 1111110a b · · ·

12i+11a 12i+21a b 12i+10a 12i+20a b · · · 12m+11a 12m+21a b 12m+10a 12m+20a b

13(m+1)+10a 13(m+1)+20a 13(m+1)+30a b 16(m+1)+10a 16(m+1)+20a 16(m+1)+30a b · · ·

· · · 13j(m+1)+10a 13j(m+1)+20a 13j(m+1)+30a b · · ·

13n(m+1)+10a 13n(m+1)+20a 13n(m+1)+30a b baa.

We denote by w′ the preﬁx of w such that w = w′aa and by w′′ the preﬁx of w such that w = w′baa.
Clearly, w can be constructed in polynomial time from ϕ. Next we show that ϕ is satisﬁable if and
only if w 6∈ L✷(e).

The regular expression e is deﬁned as (Σ∗b ∪ ǫ)f (bΣ∗ ∪ ǫ), where f is deﬁned as: (cid:0)(f1 ∪ g1 ∪
· · · fm ∪ gm)(a ∪ ǫ)(cid:1)∗. Intuitively fi (resp. gi) codiﬁes pi (resp. ¬pi) and the clauses in which pi

23

(resp. ¬pi) appears. Formally, we deﬁne fi (1 ≤ i ≤ m) as

(cid:0)({w′} ∪ {w′′} ∪ 12i+1∪
[{1≤j≤n|pi = ℓ1

j }

13j(m+1)+1 ∪

[{1≤j≤n|pi = ℓ2

j }

13j(m+1)+2 ∪

[{1≤j≤n|pi = ℓ3

j }

13j(m+1)+3) · xia(cid:1),

where xi is a fresh variable in V. In the same way we deﬁne gi as

(cid:0)({w′} ∪ {w′′} ∪ 12i+2∪

[

{1≤j≤n|¬pi = ℓ1
j }

13j(m+1)+1 ∪

[

{1≤j≤n|¬pi = ℓ2
j }

13j(m+1)+2 ∪

[

{1≤j≤n|¬pi = ℓ3
j }

13j(m+1)+3) · ¯xia(cid:1),

where ¯xi is a fresh variable in V. The variable xi (resp. ¯xi) is said to be associated with pi (resp.
¬pi) in e. Clearly, e is a simple regular expression and can be constructed in polynomial time from
ϕ.

We prove ﬁrst that if w 6∈ L✷(e) then ϕ is satisﬁable. Assume that w 6∈ L✷(e). Then there exists
a valuation ν : {x1, ¯x1, . . . , xm, ¯xm} → Σ such that w 6∈ L(ν(e)). First of all, we prove that for each
1 ≤ i ≤ m both ν(xi) and ν(¯xi) belong to the set {0, 1}. Assume, for the sake of contradiction,
that this is not the case. Suppose ﬁrst that ν(xi) = a, for some 1 ≤ i ≤ m. Then it is clear that
L(w′aa) ⊆ L(ν(e)) (because L(w′ν(xi)a) ⊆ L(ν(e))). But w = w′′aa, and, therefore, w ∈ L(ν(e)),
which is a contradiction. Suppose now that ν(xi) = b, for some 1 ≤ i ≤ m. Then, again, it is clear
that L(w′′baa) ⊆ L(ν(e)) (because L(w′′ν(xi)aa) ⊆ L(ν(e))). As in the previous case, w = w′′baa,
and, therefore, w ∈ L(ν(e)), which is a contradiction. The other case, when σ(¯xi) ∈ {a, b}, for
some 1 ≤ i ≤ m, is completely analogous.

Next we prove that for each 1 ≤ i ≤ m it is the case that σ(xi) = 1 − σ(¯xi). Assume otherwise.
Then for some 1 ≤ i ≤ m it is the case that σ(xi) = σ(¯xi). Suppose ﬁrst that σ(xi) = σ(¯xi) = 1.
Consider the unique preﬁx w1 of w that is of the form u12i+11a12i+21a, for u ∈ Σ∗. Then w is of the
form w1w2, where w2 ∈ bΣ∗. Since w 6∈ L(ν(e)), it must be the case that w 6∈ L((Σ∗b ∪ ǫ)ν(f )bΣ∗).
It follows that w1 6∈ L((Σ∗b ∪ ǫ)ν(f )). But since w1 is of the form u12i+11a12i+21a, it follows that
u = ǫ or u = u′b, for some u′ ∈ Σ∗. In any case it must hold that 12i+11a12i+21a 6∈ L(ν(f )). Notice,
however, that L(12i+1ν(xi)a12i+2ν(¯xi)a) ⊆ L(ν(f )). Hence, 12i+11a12i+21a ∈ L(ν(f )), which is a
contradiction. Suppose, on the other hand, that σ(xi) = σ(¯xi) = 0. Consider the unique preﬁx
w1 of w that is of the form u12i+10a12i+20a, for u ∈ Σ∗. Then w is of the form w1w2, where
w2 ∈ bΣ∗. Since w 6∈ L(ν(e)), it must be the case that w 6∈ L((Σ∗b ∪ ǫ)ν(f )bΣ∗). It follows that
w1 6∈ L((Σ∗b ∪ ǫ)ν(f )). But since w1 is of the form u12i+10a12i+20a, it follows that u = ǫ or u = u′b,
for some u′ ∈ Σ∗. In any case it must hold that 12i+10a12i+20a 6∈ L(ν(f )). Notice, however, that
L(12i+1ν(xi)a12i+2ν(¯xi)a) ⊆ L(ν(f )). Hence, 12i+10a12i+20a ∈ L(ν(f )), which is a contradiction.
We can then deﬁne a propositional assignment σ : {p1, . . . , pm} → {0, 1} such that σ(pi) = ν(xi),
for each 1 ≤ i ≤ m. Notice, from our previous remarks, that σ(¬pi) = 1 − ν(xi) = ν(¯xi), for each
1 ≤ i ≤ m. We prove next that σ satisﬁes ϕ. Assume this is not the case. Then for some 1 ≤ j ≤ n it
is the case that σ(ℓ1
j ) = 0. Consider now the unique preﬁx w1 of w such that w1 is of
the form ub13j(m+1)+10a13j(m+1)+20a13j(m+1)+30a, for u ∈ Σ∗. Then w is of the form w1w2, where
w2 ∈ bΣ∗. Since w 6∈ L(ν(e)), it must be the case that w 6∈ L(Σ∗bν(f )bΣ∗). It follows that w1 6∈
L(Σ∗bν(f )). But since w1 is of the form ub13j(m+1)+10a13j(m+1)+20a13j(m+1)+30a, it follows that
13j(m+1)+10a13j(m+1)+20a13j(m+1)+30a 6∈ L(ν(f )). Let q1, q2 and q3 be the variables in e associated

j ) = σ(ℓ2

j ) = σ(ℓ3

24

j and ℓ3

with ℓ1
j , ℓ2
j , respectively. Then it cannot be the case that ν(q1) = ν(q2) = ν(q3) = 0. Assume
It is clear that L(13j(m+1)+1ν(q1)a13j(m+1)+2ν(q2)a13j(m+1)+3ν(q3)a) ⊆ L(ν(f ), and,
otherwise.
therefore, 13j(m+1)+10a13j(m+1)+20a13j(m+1)+30a ∈ L(ν(f )), which is a contradiction. Thus, either
ν(q1) = σ(ℓ1

j ) = 1. This is our desired contradiction.

j ) = 1 or ν(q2) = σ(ℓ2

j ) = 1 or ν(q3) = σ(ℓ3

We prove second that if ϕ is satisﬁable then w 6∈ L✷(e). Assume that ϕ is satisﬁable. Then
there exists a propositional assignment σ : {p1, . . . , pm} → {0, 1} that satisﬁes ϕ. We deﬁne a
valuation ν : {x1, ¯x1, . . . , xm, ¯xm} → {0, 1} for e as follows: For each 1 ≤ i ≤ m it is the case that
ν(xi) = σ(pi) and ν(¯xi) = 1 − σ(pi). We prove next that w 6∈ L(ν(e)).

Clearly, w 6∈ L(ν(e)) if and only if for each words w1, w2, w3 ∈ Σ∗ such that w = w1w2w3 it is
the case that w1 6∈ L(Σ∗b ∪ ǫ) or w2 6∈ L(ν(f )) or w3 6∈ L(bΣ∗ ∪ ǫ). Thus, in order to prove that
w 6∈ L(ν(e)) it is enough to prove that for each words w1, w2, w3 ∈ Σ∗ such that w = w1w2w3,

(*) if w1 ∈ L(Σ∗b ∪ ǫ) and w3 ∈ L(bΣ∗ ∪ ǫ) then w2 6∈ L(ν(f )).

Take arbitrary words w1, w2, w3 ∈ Σ∗ such that w = w1w2w3. We consider several cases:

1. Either w1 6∈ L(Σ∗b ∪ ǫ) or w3 6∈ L(bΣ∗ ∪ ǫ). Then (*) is trivially true.

2. It is the case that w1 ∈ L(Σ∗b ∪ ǫ), w3 ∈ L(bΣ∗ ∪ ǫ), and w2 is of the form 12i+11a12i+21au,
for some 1 ≤ i ≤ m and u ∈ Σ∗. Assume, for the sake of contradiction, that w2 ∈ L(ν(f )).
Since clearly there is no word accepted by L(ν(f )) with preﬁx baa, it must be the case that
w3 is not the empty word, and, therefore, that w3 ∈ L(Σ∗b). Thus, the only possibility for
w2 to belong to L(ν(f )) is that 12i+11a ∈ L(ν(fi)) and 12i+21a ∈ L(ν(gi)). But this can only
happen if ν(xi) = 1 and ν(¯xi) = 1, which is our desired contradiction (since ν(xi) = 1−ν(¯xi)).

3. It holds that w1 ∈ L(Σ∗b ∪ ǫ), w3 ∈ L(bΣ∗ ∪ ǫ), and w2 is of the form 12i+10a12i+20au, for

some 1 ≤ i ≤ m and u ∈ Σ∗. This case is completely analogous to the previous one.

4. It is the case that w1 ∈ L(Σ∗b ∪ ǫ), w3 ∈ L(bΣ∗ ∪ ǫ), and w2 is of the form
13j(m+1)+10a13j(m+1)+20a13j(m+1)+30au, for some 1 ≤ i ≤ m and u ∈ Σ∗. Assume, for
the sake of contradiction, that w2 ∈ L(ν(f )). It is easy to see that the only way in which this
can happen is that ν(q1) = ν(q2) = ν(q3) = 0, where q1, q2 and q3 are the variables in e that
are associated with ℓ1
j ) = 0, which is or
desired contradiction.

j , respectively. Thus, σ(ℓ1

j ) = σ(ℓ2

j ) = σ(ℓ3

j and ℓ3

j , ℓ2

This ﬁnishes the proof of the proposition.

Proof of Theorem 3:

The hardness is established via a reduction from the complement 3-SAT, that is based on the
ΣP

2 -hardness proof of Proposition 1.

Let ϕ := C1 ∧ · · · ∧ Cp be an instance of 3-SAT, that uses variables {y1, . . . , yt}.
Let w be the word 0011000. From ϕ we construct in polynomial time a parameterized regular
expression e over alphabet Σ = {0, 1} such that ϕ is not satisﬁable if and only if L✷(e) contains w.
j, for 1 ≤ j ≤ p

Assume that each Cj (1 ≤ j ≤ p) is of form (ℓ1

j ), where each literal ℓi

j ∨ ℓ2

j ∨ ℓ3

and 1 ≤ i ≤ 3, is either a variable in {y1, . . . , yt}, or its negation.

25

With each propositional variable yk , 1 ≤ k ≤ t, we associate fresh variables Yk and ˆYk. Let
j corresponds to yk or to ˆYk, if ℓi

j to the variable Yk, if ℓi

j

h be a function that maps each literal ℓi
corresponds to ¬yk. Expression e is deﬁned as

e = e1 | e2,1 | · · · | e2,t,

1) · h(ℓ3

1) |

· · ·

| h(ℓ1

p) · h(ℓ2

p) · h(ℓ3

p)(cid:1), and for each 1 ≤ k ≤ t,

where e1 = 0011(cid:0)h(ℓ1

1) · h(ℓ2
e2,k = (cid:0)Yk ˆYk11000(cid:1) | (cid:0)00Yk ˆYk000(cid:1).

The proof that w ∈ L✷(e) if and only if ϕ is not satisﬁable goes along the same lines as the ΣP
2

hardness proof of Proposition 1.

Second, we prove that, for each word w ∈ Σ∗, the problem Membership✷(w) can be solved in

polynomial time (actually, in linear time with respect to the size of the expression).

In order to do this, we ﬁrst deﬁne a high-level procedure CheckSimpleMemb✷, that takes as input
a simple parameterized regular expression e over Σ and a ﬁnite set W ⊂ Σ∗, and checks whether
there exists an assignment ν for e such that no word from W belongs to L(ν(e)). Then the answer
to Membership✷(w) for an expression e is ¬CheckSimpleMemb✷(e, {w}).

The procedure CheckSimpleMemb✷ works recursively on input e and W. For each internal node
of the parse tree of e it iterates over some sets W1 (or pairs of sets (W1, W2) respectively), and for
each such set (or pair) calls itself recursively on the children of the analyzed node. If the returned
answers in case of one of the sets (or pairs) satisfy a given condition, the call accepts.

The details of the deﬁnition of CheckSimpleMemb✷ are following:

1. If e = a, for a ∈ Σ, then CheckSimpleMemb✷(e, W) accepts iﬀ a /∈ W.

2. If e = x, for x ∈ V, then CheckSimpleMemb✷(e, W) accepts iﬀ W does not contain all one-letter

words.

3. If e is of the form e1∪e2, then CheckSimpleMemb✷(e, W) accepts iﬀ CheckSimpleMemb✷(e1, W)

accepts and CheckSimpleMemb✷(e2, W) accepts.

4. If e is of the form e1e2, then CheckSimpleMemb✷(e, W) accepts iﬀ there exist sets W1 ⊂ Σ∗,
W2 ⊂ Σ∗ such that: (1) For each word w1w2 ∈ W either w1 ∈ W1 or w2 ∈ W2, and (2)
CheckSimpleMemb✷(e1, W1) accepts and (3) CheckSimpleMemb✷(e2, W2) accepts.

5. If e is of the form (e1)∗, then CheckSimpleMemb✷(e, W) accepts iﬀ there is a set W1 ⊂ Σ∗
such that: (1) For each word w1w2 · · · wk ∈ W at least one wi (1 ≤ i ≤ k) belongs to W1, and
(2) CheckSimpleMemb✷(e1, W1) accepts.

It is good to see, why CheckSimpleMemb✷ needs to operate on sets of words instead of single
words. The above procedure may construct non-singleton sets in case of concatenation and Kleene
star and we cannot analyse their elements separately, because in each case we must judge existence
of a valuation ν, which would simultaneously prevent all possible runs of w on ν(e) from being
accepting.

Now, we prove that the procedure descibed above is sound and complete; that is, we prove that
for each simple expression e over Σ and W ⊂ Σ∗, CheckSimpleMemb✷ accepts input e and W iﬀ
there exists a valuation ν for e such that no word in W belongs to L(ν(e)). We do this by induction:

26

1. The basis cases – when e = a, for a ∈ Σ, or e = x, for x ∈ V – are trivial.

2. Assume e is of the form e1 ∪ e2. Then there is a valuation ν for e such that no word in
W belongs to L(ν(e)) iﬀ there is a valuation ν for e such that for each w ∈ W we have
w 6∈ L(ν(e1)) and w 6∈ L(ν(e2)). But since we consider only simple expressions here, the
latter holds iﬀ there are valuations ν1 for e1 and ν2 for e2 such that (a) no word w ∈ W
belongs to L(ν1(e1)), and (b) no word w ∈ W belongs to L(ν2(e2)). By induction hypothesis,
the latter holds iﬀ CheckSimpleMemb✷(e1, W) accepts and CheckSimpleMemb✷(e2, W) accepts,
which, by deﬁnition, is equivalent to the fact that CheckSimpleMemb✷(e, W) accepts.

3. Assume e is of the form e1e2. Then there is a valuation ν for e such that no word w ∈ W
belongs to L(ν(e)) iﬀ there is a valuation ν for e such that for each word w1w2 ∈ W either
w1 6∈ L(ν(e1)) or w2 6∈ L(ν(e2)). But since we consider only simple expressions here, the
latter holds iﬀ there are valuations ν1 for e1 and ν2 for e2 such that for each w1w2 ∈ W either
w1 6∈ L(ν1(e1)) or w2 6∈ L(ν2(e2)).
Clearly, the latter holds iﬀ there are valuations ν1 for e1 and ν2 for e2 and there are ﬁnite
sets W1, W2 ⊂ Σ∗ such that: (1) For each w1w2 ∈ W either w1 ∈ W1 or w2 ∈ W2, and
(2) no word w1 ∈ W1 belongs to L(ν1(e1)), and (3) no word w2 ∈ W2 belongs to L(ν2(e2)).
By induction hypothesis, the latter holds iﬀ there are ﬁnite sets W1, W2 ⊂ Σ∗ such that for
each word w1w2 ∈ W either w1 ∈ W1 or w2 ∈ W2, and both CheckSimpleMemb✷(e1, W1) and
CheckSimpleMemb✷(e2, W2) accept. By deﬁnition, the latter is equivalent to the fact that
CheckSimpleMemb✷(e, W) accepts.

4. Assume e is of the form (e1)∗. Then there is a valuation ν for e such that no word w ∈ W
belongs to L(ν(e)) iﬀ there is a valuation ν1 for e1 such that for each w1w2 . . . wk ∈ W some
wi (1 ≤ i ≤ k) does not belong to L(ν1(e1)). Clearly, the latter holds iﬀ there is a valuation
ν1 for e1 and there is a ﬁnite set W1 ⊂ Σ∗ such that: (1) For each word w ∈ W and each its
decomposition w = w1w2 . . . wk some wi (1 ≤ i ≤ k) belongs to W1, and (2) no word from W1
belongs to L(ν1(e1)). By induction hypothesis, the latter holds iﬀ CheckSimpleMemb✷(e1, W1)
accepts for some set W1 ⊂ Σ∗ satisfying condition (1), which, by deﬁnition, is equivalent to
the fact that CheckSimpleMemb✷(e, W) accepts.

Next we show that there is an implementation of the procedure CheckSimpleMemb✷ that works
in O(|e|) time, if we assume that the input consists of a simple parameterized regular expression e
and a ﬁxed set of words W.

First, for technical reasons, we remove all subexpressions ǫ from e obtaining e′. Then the
implementation works recursively as follows: If e′ is of the form a, for a ∈ Σ, or x ∈ V, or e1 ∪ e2,
then we implement recursively in the same way as it is described in CheckSimpleMemb✷. If, on the
other hand, e′ is of the form e1e2 or (e1)∗, then we have to be slightly more careful since we have
to deﬁne how to search for sets W1 and W2. We do this as follows:

1. Assume ﬁrst that e is of the form e1e2. Then CheckSimpleMemb✷ accepts e′ and W iﬀ
there are sets W1, W2 ⊂ Σ∗ such that: (1) If w1w2 ∈ W, then w1 ∈ W1 or w2 ∈ W2, and
(2) CheckSimpleMemb✷(e1, W1) accepts, and (3) CheckSimpleMemb✷(e2, W2) accepts. Our
implementation, however, does not look over arbitrary sets W1 and W2, but only over the
sets which can be constructed as follows: For each w ∈ W and for each w1, w2 ∈ Σ+ (that
is, both w1 and w2 are nonempty) such that w = w1w2, either pick up w1 and place it in

27

W1 or pick up w2 and place it in W2. If for some pair (W1, W2) constructed in this way it
is the case that CheckSimpleMemb✷(e1, W1) accepts and CheckSimpleMemb✷(e2, W2) accepts,
then CheckSimpleMemb✷(e′, W) accepts. The reason why we can restrict ourselves to the
case of nonempty words is that neither e1 nor e2 equals ǫ in e′, and, thus, the empty word
trivially does not match any of them. Clearly our implementation continues being sound and
complete.

2. Assume second that e′ is of the form (e1)∗. Then CheckSimpleMemb✷ accepts iﬀ there is a set
W1 ⊂ Σ∗ such that: (1) For each word w ∈ W and each its decomposition w = w1w2 . . . wk
some wi (1 ≤ i ≤ k) belongs to W1, and (2) CheckSimpleMemb✷(e1, W1) accepts. Again,
our implementation does not look over arbitrary sets W1, but only over the sets which can
be constructed as follows: For each decomposition w1w2 · · · wk of each word in W pick up
an arbitrary 1 ≤ i ≤ k and place wi in W1.
If for some set W1 constructed in this way
CheckSimpleMemb✷(e1, W1) accepts, then CheckSimpleMemb✷(e′, W) accepts. Clearly, our
implementation continues being sound and complete.

Too estimate the time complexity of the above implementation, ﬁrst we need to see that all
elements of all W encountered in the algorithm are subwords of w and thus all W ∈ W, where W is
the powerset of all subwords of w. Clearly the size of W is dependent only on |w|. Also the number
of cases tried by each subcall of CheckSimpleMemb✷ and the number of steps needed to construct
each W1 (and W2 respectively) is dependent only on |w|. Hence all these values are constant.

If along the algorithm we memoize the answers to subcalls, then our complexity will be upperbounded 
by the complexity of a dynamic version of the above algorithm, which would calculate
CheckSimpleMemb✷(e1, W1) for all subexpressions e1 of e′ and all W1 ∈ W in a bottom-up order. In
this approach, the computation of CheckSimpleMemb✷(e1, W1) would take constant time, because
answers to subcalls would have been precomputed. Thus the total complexity of CheckSimpleMemb✷
is linear with respect to the size of the parse tree of e′ and thus with respect to e as well.

We can strive for accelerating the above algorithm, by replacing all subexpressions of the form
i ∪ · · · fn)∗ with (f1 ∪ · · · ∪ fi ∪ · · · fn)∗, which does not change the semantics of
It will not lower the asymptotic

(f1 ∪ · · · ∪ f ∗
the expression, but avoids unnecessary computational eﬀort.
complexity, but will help lower the constant.

We ﬁnally prove that, for each word w ∈ Σ∗, the problem Membership✸(w) can be solved in
time O(n log2 n). Obviously, we can concern all labels a ∈ Σ, which do not occur in w as equal.
This simple observation makes the alphabet size ﬁxed: |Σ| ≤ |w| + 1. Now, let w be a word over
Σ. Next we construct an algorithm that, given a parameterized regular expression e over Σ, checks
whether w ∈ L✸(e). Using techniques from [13] the algorithm ﬁrst constructs an NFA A over
Σ ∪ W that is equivalent to e, with O(n) states and O(n log2 n) transitions, and then performs a
nondeterministic logarithmic space algorithm on A.

Assume that W ⊂ V is the set of variables that appear in e. Construct, in polynomial time,
an NFA A (with set of states Q) over Σ ∪ W such that L(A) = L(e). Let us assume, without loss
of generality, that q0 is the unique initial state of A. Further, assume that w = a1a2 · · · am, where
each ai (1 ≤ i ≤ m) is a symbol in Σ. Then we perform the following nondeterministic algorithm
over A: The algorithm works in at most m + 1 steps. At each step 0 ≤ i ≤ m the state of the
algorithm consists of a pair (qi, µi), where qi ∈ Q and µi is a mapping from some subset Wi of W
into Σ. The initial state of the algorithm is (q0, µ0), where µ0 : ∅ → Σ (recall that q0 is the initial

28

state of A). Assume that the state of the algorithm in step i < m is (qi, µi). Then in step i + 1
the algorithm nondeterministically picks up a pair (qi+1, µi+1) and checks that at least one of the
following conditions holds:

• There exists a transition labeled ai ∈ Σ from qi to qi+1 in A and µi = µi+1; that is, both µi

and µi+1 are mappings from Wi into Σ, and µi+1(x) = µi(x), for each x ∈ Wi.

• There exists a transition labeled x ∈ V from qi to qi+1 in A, x 6∈ Wi and µi+1 : Wi ∪ {x} → Σ

is deﬁned as follows: µi+1(y) = µi(y), for each y ∈ Wi, and µi+1(x) = ai.

• There exists a transition labeled x ∈ V from qi to qi+1 in A, x ∈ Wi, µi(x) = ai and µi = µi+1.

The procedure accepts if it reaches step n in state (qn, µn), for some accepting state qn of A.
Notice that, since w is ﬁxed, the size of each mapping µ from a subset of W into Σ is also ﬁxed:
|µ| ≤ min{|w|, |W|}. That is because the initial mapping is empty and in each step of the algorithm
it can grow only by one. This means that the nondeterministic procedure described above works
in NLogspace.

It is not hard to prove (esentially using the same techniques than in the second part of the proof
of Proposition 2) that the procedure described above accepts the parameterized regular expression
e if and only if w ∈ L✸(e).

Now let M be the set of all mappings µ from subsets of W to Σ, which can occur in the algorithm
presented above, and V be the number of all states (q, µ), which can occur therein. To see the

precise time complexity, we need to estimate |M | and |V |. First, |M | = O(cid:0)|Σ|min{|w|,|W|}(cid:1), which

is ﬁxed in our case. Then, V = O(n · |M |), which is linear in the number of states of A.

Now let us imagine a directed graph G with the set of vertices V , in which there is an edge
from state (q, µ) to state (q′, µ′) iﬀ the pair (q′, µ′) can be picked up from pair (q, µ) according to
the algorithm presented above. Each edge (q, µ) → (q′, µ′) corresponds to an edge q → q′ in A
and for each edge q → q′ in A there are at most |M | edges (q, µ) → (q′, µ′) (one for each µ ∈ M ).
Therefore, G has O(n log2 n) edges, since |M | is ﬁxed. We can also construct G in O(n log2 n) time
and space.

Finally, it suﬃces to perform a reachability search in G to see whether an accepting state can
be reached from node (q0, µ0) in G, which can clearly be done in linear time with respect to the size
of G, which gives us an algorithm with O(n log2 n) time complexity or, by dropping the assumption

of w being ﬁxed — O(cid:0)|w| · |Σ|min{|w|,|W|} · n log2 n(cid:1) time complexity. Moreover, we can spare space

by not constructing G and by computing it “on the ﬂy”, because standard graph search algorithms
run in O(V ) space. It might be also useful in terms of time, because a ﬁxed word w either attains
an accepting state within a short path or does not do so at all, so usually most part of G would
not by touched by the search algorithm at all.

It is worth analysing the gain in performance, which the above method gives in comparison
to the direct approach. The straightforward algorithm calculates an NFA accepting L✸(e) and
runs reachability search on it. The size of such NFA is O(|Σ||W|), so the time complexity becomes
O(|w| · |Σ||W| · n log2 n). Hence, the only gain, that the former algorithm gives is lowering the
exponent over Σ from |W| to min{|w|, |W|} and this is because we it takes into advantage a smaller
class of mappings, conﬁned by the length of the run of w on A. In fact, this gain is very large if
we speak of problem instances with a relatively small w and a huge e.

29

Proof of Theorem 4

(Part 1) We begin with the proof for the ﬁrst part. The lower bound follows directly from the fact
that checking universality is Pspace-hard even for complete regular expressions. For the upper
bound, we need the following easy claim from the deﬁnition of certain acceptance:

Claim 2 Let e be a paramterized regular expression over an alphabet Σ. Then, L✷(e) = Σ∗ if and
only if L(v(e)) = Σ∗, for every valuation v for e.

Then, a Pspace algorithm to solve the complement of the Universality✷ problem (wether
L✷(e) 6= Σ∗) just guesses a valuation v for e, and then checks wether L(v(e)) 6= Σ∗. Since v(e) is
a complete regular expression, it is well known that this decision procedure can be performed in
Pspace. This ﬁnishes the proof of the ﬁrst part of the theorem.

(Part 2) Next, we prove the second part, that is, we show that Universality✸ is Expspacecomplete.
 We begin with the upper bound. Given a parameterized regular expression e, it is easy to
see that an equivalent, complete regular expression e′ such that L✸(e) = L(e′) can be constructed

in exponential time: just take Sv is a valuation for e v(e) (the number of possible valuations is |Σ||W|)

. Combining this fact with the well known result that there is an algorithm to check wether the
language of a (complete) regular expression e′ is universal that require only polynomial space w.r.t.
e′, we obtain our Expspace algorithm: First obtain a complete regular expression e′ such that
L✸(e) = L(e′), and then decide wether L(e′) = Σ∗.

For the upper bound we present a reduction from the complement of the acceptance problem of
a Turing machine. Let L be a language that belongs to Expspace, and let M be a Turing machine
that decides L in Expspace. Given an input ¯a = a0, . . . , ak−1, we construct in polynomial time
with respect to M and ¯a a parameterized regular expression eM,¯a such that L✸(eM,¯a) = Σ∗ if and
only if M does not accepts ¯a.

Assume that M = {Q, Σ, Γ, q0, {qm}, δ}; that is, the states of M are Q = {q0, . . . , qm}, the initial
state is s0, the input alphabet is Σ, and Γ is the union of Σ plus a number of symbols reserved
for the Turing machine, and that the set of transitions of M is δ. Without loss of generality, we
assume that M has only one tape, starts with the input copied on the ﬁrst |¯a| cells of this tape, has
only one ﬁnal state sm, and that no transition is deﬁned for that state. Moreover, since M decides
L in Expspace, there is a polynomial S() such that, for every input ¯a over Σ, M decides ¯a using
space of order 2S(|¯a|). Assume for notation convenience that S(|¯a|) = n, and as usual Γ = Σ ∪ {B}.
Let ∆ = {0, 1, $, %, #, &}∪Γ∪(Γ×Q). Assume that Σ = {b1, . . . , bp}. For the sake of readability,
for a set B = {b1, . . . , bn} of symbols we denote by B the regular expression bp | · · ·
| bp. Thus,
for example, assume that Γ = Σ ∪ {B}. Then, when we write (Γ ∪ (Γ × Q)) we represent the
language given by (b1 | · · · | bp | B | (b1, s0) | · · · | (bp, sm)). Using the alphabet ∆, we represent
a conﬁguration of the Turing machine by a word in the language

#($[0]%(Γ ∪ (Γ × Q))) · · · ($[2n − 1]%(Γ ∪ (Γ × Q)))&

Next we construct a parameterized regular expression eM,¯a such that L✸(e) 6= Σ∗ if and only if

M accepts on input ¯a. Deﬁne eM,¯a = eform | ei | ef | etrans, where

• eform describes all the words that do not represent a concatenation of conﬁgurations of M.

• ei describes words that do not start with the initial conﬁguration of M over input a.

30

• ef describes words that do not end in a ﬁnal conﬁguration for M

• etrans describes words that contains two consecutive conﬁgurations α and β such that α and

β do not agree on δ.

We now describe these expressions. Expression ef orm is the union of the following expressions,

describing that:

• The ﬁrst symbol of the word is not #:

eform
1 = (ǫ | (∆ − {#}))∆∗

• The last symbol of the word is not &:

eform
2 = ∆∗(∆ − {&})

• After a # we do not have the symbol $:

eform
3 = ∆∗#(∆ − {$})∆∗

• Between the symbols $ and % there are less than n symbols:

eform
4 = ∆∗$(ǫ | ∆)n−1%∆∗

• Between the symbols $ and % there are more than n symbols:

eform
5 = ∆∗$(∆ − {%})n+1(∆ − {%})∗%∆∗

• Between the symbols $ and % there is symbol not in {0, 1}:

eform
6 = ∆∗$(0 | 1)∗(∆ − {0, 1, %})∆∗

• After a word in (0|1)n we do not have the symbol %:

eform
7 = ∆∗(0 | 1)n(∆ − {%})∆∗

• After the symbol % we do not have a symbol in (Γ ∪ (Γ × Q))

8 = ∆∗%(∆ − (Γ ∪ (Γ × Q)))∆∗
eform

• After a word in [i]%(Γ ∪ (Γ × Q)) we do not have the symbol $, for 0 ≤ i ≤ 2n − 2:

eform
91
eform
92

= ∆∗0(0 | 1)n−1%(Γ ∪ (Γ × Q))(∆ − {$})∆∗
= ∆∗(0 | 1)0(0 | 1)n−2%(Γ ∪ (Γ × Q))(∆ − {$})∆∗

... =

...

eform
9n

= ∆∗(0 | 1)n−10%(Γ ∪ (Γ × Q))(∆ − {$})∆∗

31

• After a word in [2n − 1]%(Γ ∪ (Γ × Q)) we do not have the symbol &:

eform
10 = ∆∗1n%(Γ ∪ (Γ × Q))(∆ − {&})∆∗

• After the symbol & we do not have the symbol #:

eform
11 = ∆∗&(∆ − {#})∆∗

• Between a symbol # and & there is no symbol in Γ × Q (a conﬁguration does not have a

reading position):

eform
12 = ∆∗#(∆ − {&} − (Γ × Q))∗&∆∗

• Between a symbol # and & there is more than one symbol in Γ × Q (a conﬁguration features

two positions being read by the machine):

eform
13 = ∆∗#(∆ − {&})∗(Γ × Q)(∆ − {&})∗(Γ × Q)(∆ − {&})∗&∆∗

• After the word #$ we do not have the word [0]:

eform
141 = ∆∗#$1(0 | 1)n−1∆∗
eform
142 = ∆∗#$(0 | 1)1(0 | 1)n−2∆∗

... =

...

eform
14n = ∆∗#$(0 | 1)n−11∆∗

• After a word $[i]%(Γ ∪ (Γ × Q)) we do not follow with [i + 1]%(Γ ∪ (Γ × Q)), where i is even:

eform
151 = ∆∗(0 | 1)n−10%(Γ ∪ (Γ × Q))$(0 | 1)n−10∆∗
eform
152,1 = ∆∗(0 | 1)n−200%(Γ ∪ (Γ × Q))$(0 | 1)n−211∆∗
eform
152,2 = ∆∗(0 | 1)n−210%(Γ ∪ (Γ × Q))$(0 | 1)n−201∆∗
eform
153,1 = ∆∗(0 | 1)n−30(0 | 1)0%(Γ ∪ (Γ × Q))$(0 | 1)n−31(0 | 1)1∆∗
eform
153,2 = ∆∗(0 | 1)n−31(0 | 1)0%(Γ ∪ (Γ × Q))$(0 | 1)n−30(0 | 1)1∆∗

... =

...

eform
15n,1 = ∆∗0(0 | 1)n−20%(Γ ∪ (Γ × Q))$1(0 | 1)n−21∆∗
eform
15n,2 = ∆∗1(0 | 1)n−20%(Γ ∪ (Γ × Q))$0(0 | 1)n−21∆∗

• After a word $[i]%(Γ ∪ (Γ × Q)) we do not follow with [i + 1]%(Γ ∪ (Γ × Q)), where i is odd

32

and i < 2n − 1:

eform
161 = ∆∗(0 | 1)n−11%(Γ ∪ (Γ × Q))$(0 | 1)n−11∆∗
eform
162,1 = ∆∗(0 | 1)n−201%(Γ ∪ (Γ × Q))$(0 | 1)n−200∆∗
eform
162,2,1 = ∆∗(0 | 1)n−3001%(Γ ∪ (Γ × Q))$(0 | 1)n−3110∆∗
eform
162,2,2 = ∆∗(0 | 1)n−3101%(Γ ∪ (Γ × Q))$(0 | 1)n−3010∆∗
eform
162,3,1 = ∆∗(0 | 1)n−40(0 | 1)01%(Γ ∪ (Γ × Q))$(0 | 1)n−41(0 | 1)10∆∗
eform
162,3,2 = ∆∗(0 | 1)n−41(0 | 1)01%(Γ ∪ (Γ × Q))$(0 | 1)n−40(0 | 1)10∆∗

... =

...

eform
162,n−2,1 = ∆∗0(0 | 1)n−301%(Γ ∪ (Γ × Q))$1(0 | 1)n−310∆∗
eform
162,n−2,2 = ∆∗1(0 | 1)n−301%(Γ ∪ (Γ × Q))$0(0 | 1)n−310∆∗

eform
163,1 = ∆∗(0 | 1)n−3011%(Γ ∪ (Γ × Q))$(0 | 1)n−3(000 | 110 | 010)∆∗
eform
163,2,1 = ∆∗(0 | 1)n−40011%(Γ ∪ (Γ × Q))$(0 | 1)n−31100∆∗
eform
163,2,2 = ∆∗(0 | 1)n−41011%(Γ ∪ (Γ × Q))$(0 | 1)n−40100∆∗
eform
163,3,1 = ∆∗(0 | 1)n−50(0 | 1)011%(Γ ∪ (Γ × Q))$(0 | 1)n−51(0 | 1)100∆∗
eform
163,3,2 = ∆∗(0 | 1)n−51(0 | 1)011%(Γ ∪ (Γ × Q))$(0 | 1)n−50(0 | 1)100∆∗

... =

...

eform
163,n−3,1 = ∆∗0(0 | 1)n−4011%(Γ ∪ (Γ × Q))$1(0 | 1)n−4100∆∗
eform
173,n−3,2 = ∆∗1(0 | 1)n−4011%(Γ ∪ (Γ × Q))$0(0 | 1)n−4100∆∗

eform
16n,1 = ∆∗01n−1%(Γ ∪ (Γ × Q))$({(0 | 1)n} − {1n})∆∗

Notice that expression eform is of polynomial size. In particular, the language ({(0 | 1)n} −
{1n}) can be described with the expression

0(0 | 1)n−1 | (0 | 1)0(0 | 1)n−3 | · · · | (0 | 1)n−10

.

Next, expression ei is the union of the following expressions, describing that:

• The ﬁrst conﬁguration does not contain the initial state:

1 = #($(0 | 1)n%(Γ ∪ (Γ × (Q − q0))))∗&∆∗
ei

• The ﬁrst conﬁguration does not contain the head in the initial position:

2 = #$0n%Γ∆∗
ei

33

• The ﬁrst conﬁguration does not have the word ¯a in its ﬁrst |¯a| = k symbols:

3,1 = #$0n%(Γ × Q − {(q0, a0})∆∗
ei
... =
3,k = #$[0]%(Γ ∪ (Γ × Q))$[1]%(Γ ∪ (Γ × Q)) · · · $[k − 1]%(Γ × Q − {(ak−1})∆∗
ei

...

• The rest of the symbols of the ﬁrst conﬁguration are not blank symbols:

4 = #$[0]%(Γ ∪ (Γ × Q))$[1]%(Γ ∪ (Γ × Q)) · · · $[k − 1]%(∆ − {&})∗(Γ ∪ (Γ × Q) − {B})∆∗
ei

Furthermore, expression ef describes words whose ﬁnal conﬁguration does not end in a ﬁnal

state:

ef = ∆∗#(∆ − &)∗((Γ × Q) − {(a, sm) | a ∈ Γ})(∆ − &)∗&

Finally, expression etrans is the union of the following expressions, describing that:

• A cell not pointed by the head changed it’s content:

etrans
1

= [a∈Γ

∆∗#($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1 · · · xn%a($(0|1)n%(Γ ∪ (Γ × Q)))∗&

#($(0|1)n%(Γ∪(Γ×Q)))∗$x1 · · · xn%(Γ−{a}∪(Γ×Q)−({a}×Q))($(0|1)n%(Γ∪(Γ×Q)))∗&∆∗

• A conﬁguration that is not ﬁnal features a pair in Q × Σ for which no transition is deﬁned

(the last # states the conﬁguration is not ﬁnal):

etrans
2

=

[

a∈Γ,s∈Q|δ(s,a) is not deﬁned

∆∗#($(0|1)n%(Γ ∪ (Γ × Q)))∗

$(0|1)n%(a, s)($(0|1)n%(Γ ∪ (Γ × Q)))∗&#∆∗

• The change of state does not agree with δ:

etrans
3

=

[

A∈Γ,s∈Q|δ(s,a)=(s′,a′,{→,←})

∆∗#(∆ − {&})∗(s, a)(∆ − {&})∗&

#(∆ − {&})∗(Γ × (Q − {s′}))(∆ − {&})∗&∆∗

• The symbol written in a given step does not agree with δ:

etrans
3

=

[

a∈Γ,s∈Q|δ(s,a)=(s′,a′,→)
∆∗#($(0|1)n%(Γ ∪ (Γ × Q)))∗$y1, . . . , yn%(a, s)($(0|1)n%(Γ ∪ (Γ × Q)))∗&

#($(0|1)n%(Γ ∪ (Γ × Q)))∗$y1, . . . , yn%(Γ − {a′})($(0|1)n%(Γ ∪ (Γ × Q)))∗&∆∗

34

• The movement of the head does not agree with δ:

etrans
4,1 =

[

a∈Γ,s∈Q|δ(s,a)=(s′,a′,→)

∆∗#($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1, . . . , xn%(a, s)($(0|1)n%(Γ ∪ (Γ × Q)))∗&

#($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1, . . . , xn%(a′)ǫ|(cid:0)$(0|1)n%Γ($(0|1)n%(Γ ∪ (Γ × Q)))∗(cid:1)&∆∗

etrans
4,2 =

[

a∈Γ,s∈Q|δ(s,a)=(s′,a′,←)

∆∗#($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1, . . . , xn%(a, s)($(0|1)n%(Γ ∪ (Γ × Q)))∗&

#ǫ|(cid:0)($(0|1)n%(Γ ∪ (Γ × Q)))∗$(0|1)n%Γ(cid:1)$x1, . . . , xn%(a′)($(0|1)n%(Γ ∪ (Γ × Q)))∗&∆∗

It is now straightforward to show that L✸(eM,¯a) = Σ∗ if and only if M does not accept on
✷

input ¯a. This ﬁnishes the proof of the Expspace lower bound.

Proof of Proposition 3:

We show explain how to adapt the reduction of Theorem 4 so that it does not longer uses parameterized 
expressions that are not simple.

Recall that the previous reduction used alphabet ∆ = {0, 1, $, %, #, &} ∪ Γ ∪ (Γ × Q).
For the simple case, we need a slightly bigger alphabet. Let ∆ = {0, 1, $, %, #e, &e, #o, &o} ∪
Γ ∪ (Γ × Q). The idea is to modify the way conﬁgurations are represented. Previously, we had that
each conﬁguration was represented by a word in

#($[0]%(Γ ∪ (Γ × Q))) · · · ($[2n − 1]%(Γ ∪ (Γ × Q)))&.

In the modiﬁed reduction, however, conﬁgurations can be represented by either one of this

expressions:

#e($[0]%(Γ ∪ (Γ × Q))) · · · ($[2n − 1]%(Γ ∪ (Γ × Q)))&o, or

#e($[0]%(Γ ∪ (Γ × Q))) · · · ($[2n − 1]%(Γ ∪ (Γ × Q)))&o.

The intuition is that conﬁgurations using #e and &e represent an even stop of the computation

of the Turing machine, whereas conﬁgurations using #o and &o represent an odd step.

It is now straightforward to modify expressions eform, ei and ef to work under this codiﬁcation

of conﬁgurations: We just have to make sure that

• eform describes all the words that do not represent a concatenation of conﬁgurations of M,
where now valid conﬁgurations will have the form #eu&e#ou′&o#eu′′&e · · · , that is, valid
conﬁgurations start in an even step, and then follow an even - odd - even - odd - ... pattern.

• ei describes words that do not start with the initial conﬁguration of M over input a.

• ef describes words that do not end in a ﬁnal conﬁguration for M

35

The descriptions of this expressions is omitted, since their extension is straightforward. Next,
we show how one of the expressions in etrans is to be modiﬁed, the other remaining being analogous.
, that intuitively accepts all words describing two conﬁgurations in

Consider expression etrans

1

which a cell not pointed by the head changed it’s content. It was deﬁned previously as

etrans
1

= [a∈Γ

∆∗#($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1 · · · xn%a($(0|1)n%(Γ ∪ (Γ × Q)))∗&

#($(0|1)n%(Γ∪ (Γ× Q)))∗$x1 · · · xn%(Γ− {a}∪ (Γ× Q)− ({a}× Q))($(0|1)n %(Γ∪ (Γ× Q)))∗&∆∗

Then, we redeﬁne it as etrans

1,e

| etrans

1,0

, where

1,e = [a∈Γ
etrans

∆∗#e($(0|1)n%(Γ ∪ (Γ × Q)))∗$

(cid:18)x1 · · · xn(cid:0)%a($(0|1)n%(Γ ∪ (Γ × Q)))∗&e#o($(0|1)n%(Γ ∪ (Γ × Q)))∗$(cid:1) |
(cid:0)%(Γ − {a} ∪ (Γ × Q) − ({a} × Q))($(0|1)n%(Γ ∪ (Γ × Q)))∗&o(cid:1)(cid:19)∗

(#e∆∗ + ǫ)

1,o = [a∈Γ
etrans

∆∗#o($(0|1)n%(Γ ∪ (Γ × Q)))∗$

(cid:18)x1 · · · xn(cid:0)%a($(0|1)n%(Γ ∪ (Γ × Q)))∗&o#e($(0|1)n%(Γ ∪ (Γ × Q)))∗$(cid:1) |
(cid:0)%(Γ − {a} ∪ (Γ × Q) − ({a} × Q))($(0|1)n%(Γ ∪ (Γ × Q)))∗&e(cid:1)(cid:19)∗

(#o∆∗ + ǫ)

And such that every appearance of x1, . . . , xn represents a new set of n fresh variables. Notice
then that these expressions are simple parameterized regular expressions. In order to see that the
intended meaning of these expressions remains untouched, consider expressions

1,e = [a∈Γ
e′trans

∆∗#e($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1 · · · xn%a($(0|1)n%(Γ ∪ (Γ × Q)))∗&e

#o($(0|1)n%(Γ∪(Γ×Q)))∗$x1 · · · xn%(Γ−{a}∪(Γ×Q)−({a}×Q))($(0|1)n %(Γ∪(Γ×Q)))∗&o∆∗

1,o = [a∈Γ
e′trans

∆∗#o($(0|1)n%(Γ ∪ (Γ × Q)))∗$x1 · · · xn%a($(0|1)n%(Γ ∪ (Γ × Q)))∗&o

#e($(0|1)n%(Γ∪(Γ×Q)))∗$x1 · · · xn%(Γ−{a}∪(Γ×Q)−({a}×Q))($(0|1)n %(Γ∪(Γ×Q)))∗&e∆∗

It is now easy to see that L(e′trans

). Moreover, it is easy
to check that none of the words in L(etrans
) represent a valid sequence of
conﬁgurations, and neither does any word in L(etrans
). Using this observation,
it is possible to modify all expressions in L(etrans) so that they are simple. We have omitted the
rest of the proof since it goes along the same lines as the reduction of Theorem 4

1,e
) but not in L(e′trans

) but not in L(e′trans

1,o

1,o

1,o

1,e

) ⊆ L(etrans

) and L(e′trans

) ⊆ L(etrans

1,o

1,e

1,e

36

Proof of Proposition 4:

(Part 1) It is well known that Containment✷(e1, ·) is Pspace-hard even for complete regular
expressions. For the upper bound, let e′
1) = L✷(e1). Notice that,
since e1 is ﬁxed and by Proposition 5, expression e′
1 can be computed in constant time. Then, it
suﬃces to guess a valuation ν and a word w such that w ∈ L(e′
1), but w /∈ L(ν(e2)), which can
clearly be done in Pspace.

1 be an expression such that L(e′

(Part 2) We begin with the upper bound for the problem Containment✷(·, e2). Assume that
the input is a parameterized regular expression e1, using variables in W, and let Σ be the alphabet
of e1. The coNP algorithm is as follows. First, construct a DFA Ae2 such that L(Ae2) = L✸(e2),
and then construct AC
e2, the automaton that accepts the complement of L(Ae2) (since e2 is ﬁxed,
and by Proposition 5, this construction can be done in constant time). Next, guess a valuation ν
from W to Σ, and, from ν(e1), construct an automaton Aν(e1) such that Aν(e1) = L(ν(e1)) (It is
a standard observation that this automaton can be constructed in polynomial time from ν(e1)).
Finally, check that Aν(e1) ∩ AC
e2 6= ∅, which can be performed in polynomial time using a standard
reachability test over the product of Aν(e1) and AC
e2. Let us show that this algorithm is sound and
e2 6= ∅, then there is a word w ∈ L(ν(e1)), and thus in
complete.
L✸(e1), that does not belong to L✸(e2), or, in other words, that L✸(e1) is not contained in L✸(e2).
On the other hand, it is clear that if Aν(e1) ∩ AC
e2 = ∅ for all possible valuations ν from W to Σ,
then L✸(e1) is contained in L✸(e2)

If the intersection Aν(e1) ∩ AC

The hardness

is

established via a reduction from 3-SAT to the

complement of

Containment✷(·, e2). Let e2 be the following regular expression over alphabet Σ = {0, 1, #}:

e2 = (cid:0)(10 | 01)∗#((0 | 1)3)∗000((0 | 1)3)∗(cid:1) | (cid:0)((0 | 1)2)∗(00 | 11)Σ∗(cid:1) | (cid:0)Σ∗#Σ∗#Σ∗(cid:1),

i ∨ℓ2

and let ϕ = V1≤i≤n(ℓ1

i ) be a propositional formula in 3-CNF over variables {p1, . . . , pm}.
That is, each literal ℓj
i , for 1 ≤ i ≤ n and 1 ≤ j ≤ 3, is either pk or ¬pk, for 1 ≤ k ≤ m. Next
we show how to construct in polynomial time from ϕ a parameterized regular expression e1 over
alphabet Σ = {0, 1, #} such that ϕ is satisﬁable if and only if L✸(e1) 6⊆ L(e2).

i ∨ℓ3

Let W = {xi, ˆxi | 1 ≤ i ≤ m}. Intuitively, each xi represents the value assigned to pi, and ˆxi
i (1 ≤ i ≤ n
is pk, for some 1 ≤ k ≤ m, and

represents the value of ¬pi. Moreover, assume that h is a mapping from the literals ℓj
and 1 ≤ j ≤ 3) to W, deﬁned as expected: h(ℓj
h(ℓj

i ) = xk if ℓj

i

i ) = ˆxk if ℓj
i is ¬pk.
Deﬁne e1 as follows:

e1 = x1 ˆx1 · · · xm ˆxm#h(ℓ1

n).

1)h(ℓ2

1)h(ℓ3

1) · · · h(ℓ1

n)h(ℓ2

n)h(ℓ3

We show that ϕ is satisﬁable if and only if L✸(e1) 6⊆ L(e2).
(⇒): Assume that ϕ is satisﬁable by valuation σ. Let ν be a valuation from W to Σ, deﬁned

as follows:

• For each 1 ≤ k ≤ m, ν(xk) = 1 if σ(pk) = 1, and ν(xk) = 0 otherwise.

• For each 1 ≤ k ≤ m, ν(ˆxk) = 0 if σ(pk) = 1, and ν(xk) = 1 otherwise.

Notice that L(ν(e1)) contains a single word. We shall abuse the notation and denote with ν(e1)
both this word and the aforementioned expression. It is clear that ν(e1) contains a single symbol
#, and starts with a preﬁx in (01 | 10)∗#. Thus, if L✸(e1) ⊆ L(e2) it must be that ν(e1) is denoted

37

i , for some 1 ≤ i ≤ n, such that ν assigns the word 000 to h(ℓ1

i , ℓ2
by the expression (10 | 01)∗#((0 | 1)3)∗000((0 | 1)3)∗. But this implies that there are literals ℓ1
i
and ℓ3
i ). By construction
of ν, it must then be that σ falsiﬁes the i-th clause of ϕ, which contradicts the fact that σ is a
satisfying assignment.

i )h(ℓ2

i )h(ℓ3

(⇐): Assume now that L✸(e1) 6⊆ L(e2). By the deﬁnition of the ✸-semantics, there is at least
one valuation ν from W to Σ such that L(ν(e1)) 6⊆ L(e2). Notice again that, by the construction
of e1, ν(e1) contains a single word. Again, we shall denote this word also by ν(e1). Then if
L(ν(e1)) 6⊆ L(e2) it must be that ν(e1) is not in L(e2). This immediately entails that ν(e1) cannot
have two or more copies of the symbol #, and thus we conclude that ν assigns to each variable
W a symbol in {0, 1}. From the above observation, notice that the following valuation σ for the
variables in ϕ is well deﬁned:

• σ(pi) = 1 if ν(xi) = 1, and σ(pi) = 0 if ν(xi) = 0

Next, we show for all 1 ≤ i ≤ m, it is the case that ν(xi) 6= ν(ˆxi). Assume for the sake of
contradiction that for some i ≤ i ≤ n, we have that ν(xi) = ν(ˆxi). From the construction of e1,
we then have that ν(e1) is denoted by the expression ((0 | 1)2)∗(00 | 11)Σ∗, which contradicts the
fact that ν(e1) is not in L(e2). Finally, we claim that ϕ is satisﬁable by valuation σ. Assume the
contrary. Then there is a clause of form (ℓ1
i ), for some 1 ≤ i ≤ n, such that, for each
1 ≤ j ≤ 3, if ℓj
i is
the literal ¬pk, for some 1 ≤ k ≤ m, then σ assigns the value 1 to pk. It is now straightforward to
conclude that this fact contradicts the assumption that ν(e1) is not in L(e2), by studying all of the
8 possible cases.

i is the literal pk, for some 1 ≤ k ≤ m, then σ assigns the value 0 to pk, and if ℓj

i ∨ ℓ2

i ∨ ℓ3

Proof of Proposition 5

Let e be a parameterized regular expression over alphabet Σ, using variables in W. Through this
proof we heavily rely on the fact that there are |Σ||W| possible valuations ν : W → Σ for e.

First we show how to construct in double exponential time an NFA A✷ such that L✷(e) =
L(A✷). For each valuation ν : W → Σ, we denote by Anu(e) the NFA such that L(Aν(e)))L(e) (This
can be performed in Ptime by doing any standard regular expression to automata translation).

Then, notice that L✷(e) = Tν:W→Σ L(Aν(e)), and thus we can just take the product of them. Given
that there exists |Σ||W| possible valuations from W to Σ, and that each Aν(e) can be constructed
in time O(|e| log2 |e|) [13], the NFA for the product Qν:W→Σ Aν(e) can be constructed in time
|e|O(|Σ||W|).

Next, in order to construct an automaton A✸ such that L✸(e) = L(Adm), one computes an NFA

that represents Tν:W→Σ Aν(e) by combining all the automata with a nondeterministic choice at the
beginning. Given that there exists |Σ||W| possible valuations from W to Σ, and that each Aν(e) can
be constructed in time O(|e| log2 |e|) [13], we have that the automaton A✸ can be constructed in
time |Σ|O(|W|) · |e| · log2 |e|.

Proof of Theorem 6

(Part 1) We begin with the double exponential bound for L✷. For each n ∈ N, let en be the
following parameterized regular expression over alphabet Σ = {0, 1} and variables x1, . . . , xn:

en = ((0 | 1)n+1)∗ · x1 · · · xn · xn+1 · ((0 | 1)n+1)∗.

38

Notice that each en uses n + 1 variables, and is of linear size in n. In order to show that every
NFA deciding L✷(en) has 22n states, we use the following result from [10]: if L ⊂ Σ∗ is a regular
language, and there exists a set of pairs P = {(ui, vi) | 1 ≤ i ≤ m} ⊆ Σ∗ × Σ∗ such that

1. uivi ∈ L, for every 1 ≤ i ≤ m,

2. ujvi /∈ L, for every 1 ≤ i, j ≤ m and i 6= j,

then every NFA accepting L has at least m states.

Given a collection S of words over {0, 1}, let wS denote the concatenation, in lexicographical
order, of all the words that belong to S, and let w ¯S,n denote the concatenation of all words in
{0, 1}n+1 that are not in S.

Then, deﬁne a set of pairs Pn = {(wS , w ¯S,n) | S ⊂ {0, 1}n+1 and |S| = 2n}. Since there are
2n (cid:1) diﬀerent subsets of {0, 1}n+1 of size 2n, and thus

2n+1 binary words of length n + 1, the are (cid:0)2n+1
Pn contains (cid:0)2n+1

Next, we show that L✷(en) and Pn satisfy properties (1) and (2) above, which proves the double

2n (cid:1) ≥ 22n

pairs.

exponential lower bound.

1. We need to show that for every set S ⊂ {0, 1}n+1 of size 2n, the word wS, w ¯S,n belongs to
L(ν(en)), for every possible valuation ν : Σ → {x1, . . . xn+1}. Let then S be an arbitrary
subset of {0, 1}n+1 of size 2n, and let ν be an arbitrary valuation from Σ to {x1, . . . , xn+1}.
Deﬁne u = ν(x1) · · · ν(xn+1). Then u is a substring of either wS or w ¯S,n. Assume the former is
true (the other case is analogous). Then the word wS, w ¯S,n can be decomposed in v·u·v′ ·w ¯S,n,
with v′.v′′ ∈ L((0 | 1)n+1). This shows that wS, w ¯S,n belongs to L(ν(en)).

2. Assume for the sake of contradiction that there are distinct subsets S1, S2 of {0, 1}n+1 of size
2n such that wS1w ¯S2,n belongs to L✷(en). Since S1 and S2 are distinct, proper subsets of
{0, 1}n+1 (they are of size 2n), there must be a word in {0, 1}n+1 that belongs to S2 but not
to S1. Let s be such word. Moreover, let ν be a valuation from Σ to {x1, . . . , xn+1} such that
ν(x1) · · · ν(xn+1) = s. It is straightforward to show the following:

Claim 3 Let u ∈ {0, 1}n+1 be a word of size n + 1. Then u is a subword of every word w ∈
L✷(en). Moreover, there is a match for u in w that starts in a position j of w (1 ≤ j ≤ |w|),
and such that j = 1 mod n + 1.

Since we have assumed that the word wS1w ¯S2,n belongs to L✷(en), by the above claim we
have that s must be a subword of wS1w ¯S2,n that matches wS1w ¯S2,n in a position j such that
j = 1 mod n + 1. Then, from the construction of wS1 and w ¯S2,n, it must be that s either
belongs to S1 or does not belong to S2. This is a contradiction.

We use essentially the same technique to address the ✸-semantics. To show the exponential
lower bound for L✸, deﬁne en = (x1 · · · xn)∗, and let Pn = {(w, w) | w ∈ {0, 1}n}. Clearly, Pn
contains 2n pairs. All that is left to do is to show that L✸(en) and Pn satisfy properties (1) and
(2) above.

1. From the fact that L✸(en) = Tw∈{0,1}n w∗, we have that for each u ∈ {0, 1}n the word uu

belongs to L✸(en).

39

2. The same fact shows that for every u, v ∈ {0, 1}n, if u 6= v, then uv /∈ Tw∈{0,1}n w∗, and thus

uv /∈ L✸(en).

This ﬁnishes the proof of the theorem.

Proof of Theorem 7:

It will be more convenient for us to work with automata than with regular expressions. We deal
with NFAs with extended transitions, which can be not just of the form (q, a, q′), where q and
q′ are states, and a ∈ Σ, but also (q, w, q′), where w ∈ Σ∗. Such an automaton accepts a word
s ∈ Σ∗ in the standard way:
in a run, in state q, if the subword starting in the current position
is w, it can skip w and move to q′ if there is a transition (q, w, q′). Note that such automata are
a mere syntactic convenience (they will appear as the results of applying valuations), as any such
automaton A can be transformed, in polynomial time, into a usual NFA A′ so that L(A) = L(A′).
Indeed, for each transition t = (q, w, q′) with w = a1 . . . am, introduce new states q1
and
, an, q′) to A′. Thus, we shall work with automata
add transitions (q, a1, q1
with extended transitions.

t ), . . . , (qm−1

t , . . . , qm−1

t

t ), (q1

t , a2, q2

t

Let e be a parameterized regular expression with variables x1, . . . , xn, whose domains are regular
languages L1, . . . , Ln. Let Ae be an NFA equivalent to e, over the alphabet Σ ∪ {x1, . . . , xn}. If we
have a valuation ν so that ν(xi) ∈ Li for each i ≤ n, then ν(Ae) is an automaton with extended
transitions: in it, each transition (q, xi, q′) is replaced by (q, ν(xi), q′). It is then immediate from
the construction that L(ν(e)) = L(ν(Ae)) and thus L✷(e) = Tν L(ν(Ae)).

Next, consider ﬁnitary valuations ν, which are partial functions deﬁned on variables xi such
that Li is a ﬁnite languag of course ν(xi) ∈ Li. On variables xj with inﬁnite Lj such valuations
are undeﬁned. By ν(Ae) we mean the automaton (with extended transition) resulting from Ae
as follows. First, all transitions (q, a, q′), where a is a letter, are kept. Second, if (q, xi, q′) is a
transition, then ν(Ae) contains (q, ν(xi), q′) only if ν(xi) is deﬁned. In other words, transitions
using variables whose domains are inﬁnite, are dropped.

Let ν1, . . . , νM enumerate all the ﬁnitary valuations (clearly there are ﬁnitely many of them).

Let Ai = νi(Ae), for i ≤ M . We now show that L✷(Ae) = Ti≤M L(Ai).

First, if νi is a ﬁnitary valuation and ν is any extension of νi to a valuation on all the variables
x1, . . . , xn, then clearly L(νi(Ae)) ⊆ L(ν(Ae)). Note that every valuation ν is an extension of

some ﬁnitary valuation νi, and thus L✷(Ae) = Tall valuations ν L(ν(Ae)) ⊇ Ti≤M L(νi(Ae)). For

the reverse inclusion, let w ∈ L✷(Ae); in particular, w ∈ L(ν(Ae)) for every valuation ν. Take an
arbitrary ﬁnitary valuation νi and let Vi be the (inﬁnite) set of all the valuations ν that extend
νi. Let Vi(w) be the subset of Vi that contains valuations ν with the property that for each
variable xj with an inﬁnite domain Lj, we have |ν(xj)| > |w|; clearly Vi(w) is an inﬁnite set as
well. Take any ν ∈ Vi(w); we know from w ∈ L✷(Ae) that w ∈ L(ν(Ae)). In particular, there
is an accepting run of ν(Ae) that never uses any transition (q, ν(xj), q′) with Lj inﬁnite, since
|ν(xj)| > |w|. Thus, such an accepting run may only use transitions resulting from valuations of
variables with ﬁnite domains, and hence it is also an accepting run of νi(Ae). This shows that

w ∈ L(νi(Ai)); since νi was chosen arbitrarily, it means that w ∈ Ti≤M L(νi(Ae)), and thus proves
L✷(Ae) = Ti≤M L(νi(Ae)) = Ti≤M L(Ai).

This immediately shows that L✷(e) = L✷(Ae) is regular, as a ﬁnite intersection of regular
languages. Lower bounds on complexity apply immediately as they were all established for the case
when each Li = Σ. So we need to prove upper bounds. To do so, one can see, by analyzing the

40

proofs for the case when all domains are Σ, that it suﬃces to establish the following facts on the
set of automata Ai, for i < M :

• M is at most exponential in the size of the input;

• checking whether a given automaton A is one of the Ai’s can be done in time polynomial in

the size of A; and

• for each Ai, for i < M , its size it at most polynomial in the size of the input.

(To give a couple of examples, to see the Expspace-bound on Nonemptiness✷, we construct
exponentially many automata of polynomial size and check nonemptiness of their intersection. To
see the NP upper bound on Membership✸, one guesses a polynomial-size Ai, checks in polynomial
time that it is indeed a correct automaton, and then checks again in polynomial time whether a
given word is accepted by it.)

Recall that the input to the problem we are considering is (e; ¯L), or (Ae; ¯L), and we can assume
that each Li is given by an NFA Bi (if part of the input is a regular expression, we can convert it
into an NFA in O(n log2 n) time [13]).

To show the bounds, assume without loss of generality that from each Bi all nonreachable states,
and states from which ﬁnal states cannot be reached, are removed (this can be done in polynomial
time). Then L(Bi) is ﬁnite iﬀ Bi does not have cycles. Thus, if ni is the number of states of Bi,
then the longest word accepted by Bi is of length ni, and hence the size of each ﬁnite Li = L(Bi) is
at most |Σ|ni+1. Hence, the total number of all the words in ﬁnite languages Li’s is less than |Σ|N ,
where N = n +P ni, with the sum taken over indexes i such that Li is ﬁnite. This means that in

turn the number of ﬁnitary valuations M , i.e. mappings from some of the variables xi’s into words
in these ﬁnite languages is at most |Σ|N n, which is thus exponential in the size of the input.

The remaining two properties are easy. Since the length of each word accepted by one of the
Bi’s is at most the number of states in Bi, the size of all the automata νi(Ae) is bounded by
a polynomial in the size of the input; changing extended transitions in those to the usual NFA
transitions involves only a linear increase of size. To check whether an automaton A is one of the
Ai’s, we check whether all its transitions involving both states from Ae come from Ae or from a
single-letter valuation. Every other transition must be on a path between two states from Ae. One
reads words on these paths, and checks if they form a ﬁnitary valuation. This can easily be done
in polynomial time.

41

