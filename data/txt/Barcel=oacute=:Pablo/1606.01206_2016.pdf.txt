The Complexity of Reverse Engineering Problems
for Conjunctive Queries
Pablo Barceló and Miguel Romero

Center for Semantic Web Research &
Department of Computer Science, University of Chile
pbarcelo@dcc.uchile.cl, mromero@dcc.uchile.cl

Abstract

Reverse engineering problems for conjunctive queries (CQs), such as query by example (QBE) or
deﬁnability, take a set of user examples and convert them into an explanatory CQ. Despite their
importance, the complexity of these problems is prohibitively high (coNEXPTIME-complete).
We isolate their two main sources of complexity and propose relaxations of them that reduce the
complexity while having meaningful theoretical interpretations. The ﬁrst relaxation is based on
the idea of using existential pebble games for approximating homomorphism tests. We show that
this characterizes QBE/deﬁnability for CQs up to treewidth k, while reducing the complexity to
EXPTIME. As a side result, we obtain that the complexity of the QBE/deﬁnability problems
for CQs of treewidth k is EXPTIME-complete for each k ≥ 1. The second relaxation is based on
the idea of “desynchronizing” direct products, which characterizes QBE/deﬁnability for unions
of CQs and reduces the complexity to coNP. The combination of these two relaxations yields
tractability for QBE and characterizes it in terms of unions of CQs of treewidth at most k.
We also study the complexity of these problems for conjunctive regular path queries over graph
databases, showing them to be no more diﬃcult than for CQs.

1998 ACM Subject Classiﬁcation H.2.3 Database Management - Query Languages

Keywords and phrases reverse engineering, conjunctive queries, query by example, deﬁnability,
treewidth, complexity of pebble games

Digital Object Identiﬁer 10.4230/LIPIcs...

Introduction

1
Reverse engineering is the general problem of abstracting user examples into an explanatory
query. An important instance of this problem corresponds to query-by-example (QBE) for a
query language L. In QBE, the system is presented with a database D and n-ary relations
S+ and S− over D of positive and negative examples, respectively. The question is whether
there exists a query q in L such that its evaluation q(D) over D contains all the positive
examples (i.e., S+ ⊆ q(D)) but none of the negative ones (i.e., q(D) ∩ S− = ∅). In case
such q exists, it is also desirable to return its result q(D). Another version of this problem
assumes that the system is given the set S+ of positive examples only, and the question is
whether there is a query q in L that precisely deﬁnes S+, i.e., q(D) = S+. This is often
known as the deﬁnability problem for L. As of late, QBE and deﬁnability have received quite
some attention in diﬀerent contexts; e.g., for ﬁrst-order logic and the class of conjunctive
queries over relational databases [2, 7, 19, 22–24, 26]; for regular path queries over graph
databases [1,6]; for SPARQL queries over RDF [3]; and for tree patterns over XML [10,20].
In data management, a particularly important instance of QBE and deﬁnability corresponds 
to the case when L is the class of conjunctive queries (CQs). Nevertheless, the relevance
of such instance is counterbalanced by its inherent complexity: Both QBE and deﬁnability

© Pablo Barceló and Miguel Romero;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

6
1
0
2

 
l
u
J
 

7

 
 
]

B
D
.
s
c
[
 
 

2
v
6
0
2
1
0

.

6
0
6
1
:
v
i
X
r
a

XX:2

The Complexity of Reverse Engineering Problems for Conjunctive Queries

for CQs are coNEXPTIME-complete [22,24]. Moreover, in case that a CQ-explanation q for
S+ and S− over D exists (i.e., a CQ q such that S+ ⊆ q(D) and q(D) ∩ S− = ∅ for QBE), it
might take double exponential time to compute its result q(D). While several heuristics have
been proposed that alleviate this complexity in practice [7,19,23,26], up to date there has
been (essentially) no theoretical investigation identifying the sources of complexity of these
problems and proposing principled solutions for them. The general objective of this article is
to make a ﬁrst step in such direction.
A semantic characterization of QBE for CQs has been known for a long time in the
community. Formally, there exists a CQ q such that S+ ⊆ q(D) and q(D) ∩ S− = ∅ (i.e., a
CQ-explanation) if and only if (essentially) the following QBE test for CQs succeds:

QBE test for CQs: For each tuple ¯b in S− it is the case thatQ
Q
¯a∈S+(D, ¯a) does not homomorphically map to (D,¯b). (Here,Q denotes the usual direct

¯a∈S+(D, ¯a) 6→ (D,¯b), i.e.,

product of databases with distinguished tuples of constants).

is a canonical such explanation given by the CQ whose body corresponds toQ

(A similar test characterizes CQ-deﬁnability, save that now ¯b is an arbitrary tuple over D
outside S+). Moreover, in case there is a CQ-explanation q for S+ and S− over D, then there
¯a∈S+(D, ¯a).
As shown by Willard [24], the QBE test for CQs yields optimal bounds for determining (a)
the existence of a CQ-explanation q for S+ and S− over D (namely, coNEXPTIME), and
(b) the size of such q (i.e., exponential). More important, it allows to identify the two main
sources of complexity of the problem, each one of which increases its complexity by one
exponential:
¯a∈S+(D, ¯a), which takes exponential time
¯a∈S+(D, ¯a) → (D,¯b) for each tuple ¯b ∈ S−. Since, in general,
checking for the existence of a homomorphism is an NP-complete problem, this step
involves an extra exponential blow up.

1. The construction of the canonical explanationQ
2. The homomorphism testQ

in the combined size of D and S+.

morphism tests of the formQ

Our contributions: We propose relaxations of the QBE test for CQs that alleviate one
or both sources of complexity and have meaningful theoretical interpretations in terms of
Q
the QBE problem (our results also apply to deﬁnability). They are based on standard
approximation notions for the homomorphism test and the construction of the direct product
¯a∈S+(D, ¯a), as found in the context of constraint satisfaction and deﬁnability, respectively.
1. We start by relaxing the second source of complexity, i.e., the one given by the homo-
¯a∈S+(D, ¯a) → (D,¯b), for ¯b ∈ S−. In order to approximate
the notion of homomorphism, we use the strong consistency tests often applied in the area
of constraint satisfaction [13]. As observed by Kolaitis and Vardi [18], such consistency
tests can be recast in terms of the existential pebble game [17], ﬁrst deﬁned in the context
of database theory as a tool for studying the expressive power of Datalog, and also used
to show that CQs of bounded treewidth can be evaluated eﬃciently [12].
As opposed to the homomorphism test, checking for the existence of a winning duplicator
strategy in the existential k-pebble game on (D, ¯a) and (D0,¯b), denoted (D, ¯a) →k (D0,¯b),
can be solved in polynomial time for each ﬁxed k > 1 [17]. Therefore, replacing the
¯a∈S+(D, ¯a) →k
(D,¯b) reduces the complexity of the QBE test for CQs to EXPTIME. Furthermore, this
approximation has a neat theoretical interpretation: The relaxed version of the QBE
test accepts the input given by (D, S+, S−) if and only if there is a CQ-explanation q for
S+ and S− over D such that q is of treewidth at most (k − 1). While the latter is not

¯a∈S+(D, ¯a) → (D,¯b) with its “approximation”Q

homomorphism testQ

P. Barceló and M. Romero

XX:3

particularly surprising in light of the strong existing connections between the existential
k-pebble game and the evaluation of CQs of treewidth at most (k − 1) [12], we believe
our characterization to be of conceptual importance.
Interestingly, when this relaxed version of the QBE test yields a CQ-explanation q of
treewidth at most (k − 1), its result q(D) can be evaluated in exponential time (recall
that for general CQs this might require double exponential time).

2. We then prove that the previous bound is optimal, i.e., checking whether the relaxed
version of the QBE test accepts the input given by (D, S+, S−), or, equivalently, if there
is a CQ-explanation q for S+ and S− over D of treewidth at most k, for each k ≥ 1, is
EXPTIME-complete. (This also holds for the deﬁnability problem for CQs of treewidth
at most k). Intuitively, this states that relaxing the second source of complexity of the
test by using existential pebble games does not eliminate the ﬁrst one.

size canonical explanationQ
the context of deﬁnability: Instead of constructing the synchronized productQ

3. Finally, we look at the second source of complexity, i.e., the construction of the exponential
¯a∈S+(D, ¯a). While it is not clear which techniques are better
suited for approximating this construction, we look at a particular one that appears in
¯a∈S+(D, ¯a)
with respect to all tuples in S, we look at them one by one. That is, we check whether
for each tuples ¯a ∈ S+ and ¯b ∈ S− it is the case that (D, ¯a) 6→ (D,¯b). By using a
characterization developed in the context of deﬁnability [1], we observe that this relaxed
version of the QBE test is coNP-complete and has a meaningful interpretation: It
corresponds to ﬁnding explanations based on unions of CQs. Moreover, when combined
with the previous relaxation (i.e., replacing the homomorphism test (D, ¯a) → (D,¯b) with
(D, ¯a) →k (D,¯b)) we obtain tractability. This further relaxed test corresponds to ﬁnding
explanations over the set of unions of CQs of treewidth at most (k − 1).

We then switch to study QBE in the context of graph databases, where CQs are often
extended with the ability to check whether two nodes are linked by a path whose label satisﬁes
a given regular expression. This gives rise to the class of conjunctive regular path queries,
or CRPQs (see, e.g., [5,8,11,25]). CRPQ-deﬁnability was ﬁrst studied by Antonopulos et
al. [1]. In particular, it is shown that CRPQ-deﬁnability is in EXPSPACE by exploting
automata-based techniques, in special, pumping arguments. Our contributions in this context
are the following:

1. We ﬁrst provide a QBE test for CRPQs in the spirit of the one for CQs given above. With
such characterization we prove that QBE and deﬁnability for CRPQs are in coNEXPTIME,
improving the EXPSPACE upper bound of Antonopoulos et al. This tells us that these
problems are at least not more diﬃcult than for CQs.

game and the “desynchronization” of the direct product Q

2. We also develop relaxations of the QBE test for CRPQs based on the existential pebble
¯a∈S+(D, ¯a). As before, we
show that they reduce the complexity of the test and have meaningful interpretations in
terms of the class of queries we use to construct explanations.

Organization: Preliminaries are in Section 2. A review of QBE/deﬁnability for CQs is
provided in Section 3. Relaxations of the homomorphism tests are studied in Section 4
and the desynchronization of the direct product in Section 5. In Section 6 we consider
QBE/deﬁnability for CRPQs. Future work is presented in Section 7.

XX:4

The Complexity of Reverse Engineering Problems for Conjunctive Queries

Preliminaries

2
Databases, homomorphisms, and direct products. A schema is a ﬁnite set of relation
symbols, each one of which has an associated arity n > 0. A database over schema σ is a
ﬁnite set of atoms of the form R(¯a), where R is a relation symbol in σ of arity n > 0 and ¯a
is an n-ary tuple of constants. We slightly abuse notation, and sometimes write D also for
the set of elements mentioned in D.
Let D and D0 be databases over the same schema σ. A homomorphism from D to D0 is a
mapping h from the elements of D to the elements of D0 such that for every atom R(¯a) in D
it is the case that R(h(¯a)) ∈ D0. We often need to talk about distinguished tuples of elements
in databases. We then write (D, ¯a) to deﬁne the pair that corresponds to the database D
and the tuple ¯a of elements in D. Let ¯a and ¯b be n-ary (n ≥ 0) tuples of elements in D and
D0, respectively. A homomorphism from (D, ¯a) to (D0,¯b) is a homomorphism from D to D0
such that h(¯a) = ¯b. We write (D, ¯a) → (D0,¯b) if there is a homomorphism from (D, ¯a) to
(D0,¯b). Checking if (D, ¯a) → (D0,¯b) is a well-known NP-complete problem.

In this work, the notion of direct product of databases is particularly important. Let
¯a = (a1, . . . , an) and ¯b = (b1, . . . , bn) be n-ary tuples of elements over A and B, respectively.
Their direct product ¯a ⊗ ¯b is the n-ary tuple ((a1, b1), . . . , (an, bn)) over A × B. If D and D0
are databases over the same schema σ, we deﬁne D ⊗ D0 to be the following database over σ:

{R(¯a ⊗ ¯b) | R ∈ σ, R(¯a) ∈ D, and R(¯b) ∈ D0}.

(1)
such that (a) each Ri(¯xi) is an atom over σ, for 1 ≤ i ≤ m, and (b) ¯y is a sequence of
variables taken from the ¯xi’s. In order to ensure domain-independence for queries, we only
consider CQs without constants. We often write q(¯x) to denote that ¯x is the sequence of free
variables of q, i.e., the ones that do not appear existentially quantiﬁed in ¯y.
Let D be a database over σ. We deﬁne the evaluation of a CQ q(¯x) of the form (1)
over D in terms of the homomorphisms from Dq to D, where Dq is the canonical database
of q, that is, Dq is the database {R1(¯x1), . . . , Rm(¯xm)} that contains all atoms in q. The
evaluation of q(¯x) over D, denoted q(D), contains exactly those tuples h(¯x) such that h is a
homomorphism from Dq to D.

1≤i≤m(Di, ¯ai) as
a shorthand for (D1, ¯a1)⊗···⊗ (Dm, ¯am). This is allowed since ⊗ is an associative operation.
1≤i≤m Di. If they do
1≤i≤m(Di, ¯ai) safe. The notion of safeness is important in our work for

Further, we use (D, ¯a)⊗(D0,¯b) to denote the pair (D⊗D0, ¯a⊗¯b), and writeQ
The elements in the tupleQ
1≤i≤m ¯ai may or may not appear inQ
appear, we callQ
unsafe. In fact, ¯a1 ⊗ ¯a2 =(cid:0)(a, c), (b, d)(cid:1) and D ⊗D = {R((a, a), (b, b)), S((c, c), (d, d))}. That
1. Q
if (D, ¯a) → (Di, ¯ai) for each 1 ≤ i ≤ m, then (D, ¯a) →Q
∃¯y(cid:0)R1(¯x1) ∧ ··· ∧ Rm(¯xm)(cid:1),

reasons that will become apparent later. The next example better explains this notion:
(cid:73) Example 1. If D = {R(a, b), S(c, d)}, ¯a1 = (a, b), and ¯a2 = (c, d), then (D, ¯a1) ⊗ (D, ¯a2) is
is, none of the elements in ¯a1 ⊗ ¯a2 belongs to D ⊗ D.
(cid:74)
It is worth remarking that the direct product ⊗ deﬁnes the least upper bound in the
1≤i≤m(Di, ¯ai) → (Di, ¯ai) for each 1 ≤ i ≤ m, and

Conjunctive queries. A conjunctive query (CQ) q over relational schema σ is an FO
formula of the form:

lattice of databases deﬁned by the notion of homomorphism. In particular:
1≤i≤m(Di, ¯ai).

2.

P. Barceló and M. Romero

XX:5

CQs of bounded treewidth. The evaluation problem for CQs (i.e., determining whether
q(D) 6= ∅, given a database D and a CQ q) is NP-complete, but becomes tractable for several
syntactically deﬁned classes. One of the most prominent such classes corresponds to the CQs
of bounded treewidth [9]. Recall that treewidth is a graph-theoretical concept that measures
how much a graph resembles a tree (see, e.g., [14]). For instance, trees have treewidth one,
cycles treewidth two, and Kk, the clique on k elements, treewidth k − 1.

Formally, let G = (V, E) be an undirected graph. A tree decomposition of G is a pair
(T, λ), where T is a tree and λ is a mapping that assigns a nonempty set of nodes in V to
each node t in T, for which the following holds:
1. For each v ∈ V it is the case that the set of nodes t ∈ T such that v ∈ λ(t) is connected.
2. For each edge {u, v} ∈ E there exists a node t ∈ T such that {u, v} ⊆ λ(t).
The width of (T, λ) corresponds to (max {|λ(t)| | t ∈ T}) − 1. The treewidth of G is then
deﬁned as the minimum width of its tree decompositions.

We deﬁne the treewidth of a CQ q = ∃¯yV

1≤i≤m Ri(¯xi) as the treewidth of the Gaifman
graph of its existentially quantiﬁed variables. Recall that this is the undirected graph whose
vertices are the existentially quantiﬁed variables of q (i.e., those in ¯y) and there is an edge
between distinct existentially quantiﬁed variables y and y0 if and only they appear together
in some atom of q, that is, they both appear in a tuple ¯xi for 1 ≤ i ≤ m. For k ≥ 1, we
denote by TW(k) the class of CQs of treewidth at most k. It is known that the evaluation
problem for the class TW(k) (for each ﬁxed k ≥ 1) can be solved in polynomial time [9,12].
The QBE and deﬁnability problems. Let C be a class of queries (e.g., the class CQ
of all conjunctive queries, or TW(k) of CQs of treewidth at most k). Suppose that D is
a database and S+ and S− are n-ary relations over D of positive and negative examples,
respectively. A C-explanation for S+ and S− over D is a query q in C such that S+ ⊆ q(D)
and q(D) ∩ S− = ∅. Analogously, a C-deﬁnition of S+ over D is a query q in C such that
q(D) = S+. The query by example and deﬁnability problems for C are as follows:

PROBLEM :
INPUT :

QUESTION :

C-query-by-example (resp., C-definability)
A database D and n-ary relations S+ and S− over D
(resp., a database D and an n-ary relation S+ over D)
Is there a C-explanation for S+ and S− over D?
(resp., is there a C-deﬁnition of S+ over D?)

3 Query by example and deﬁnability for CQs

Let us start by recalling what is known about these problems for CQs. We ﬁrst establish
characterizations of the notions of CQ-explanations/deﬁnitions based on the following tests:
QBE test for CQs: Takes as input a database D and n-ary relations S+ and S− over D.
It accepts if and only if:

¯a∈S+(D, ¯a) is safe, and
¯a∈S+(D, ¯a) 6→ (D,¯b) for each tuple ¯b ∈ S−.

1.Q
2.Q
1.Q
2.Q

Deﬁnability test for CQs: Takes as input a database D and an n-ary relation S+ over D.
It accepts if and only if:

¯a∈S+(D, ¯a) is safe, and
¯a∈S+(D, ¯a) 6→ (D,¯b) for each n-ary tuple ¯b over D that is not in S+.

The following characterizations are considered to be folklore in the literature:

XX:6

The Complexity of Reverse Engineering Problems for Conjunctive Queries

(cid:73) Proposition 1. The following statements hold:
1. Let D be a database and S+, S− relations over D. There is a CQ-explanation for S+ and

S− over D if and only if the QBE test for CQs accepts D, S+, and S−.

2. Let D be a database and S+ a relation over D. There is a CQ-deﬁnition for S+ over D

if and only if the deﬁnability test for CQs accepts D and S+.

Q
¯a∈S+(D, ¯a) is unsafe or guess a tuple ¯b ∈ S− and a homomorphism h fromQ
to (D,¯b). SinceQ
checking that h is indeed a homomorphism fromQ

This provides us with a simple method for obtaining a coNEXPTIME upper bound for
CQ-query-by-example and CQ-definability. Let us concentrate on the ﬁrst problem
(a similar argument works for the second one). Assume that S+ and S− are relations of
positive and negative examples over a database D. It follows from Proposition 1 that to
check that there is not CQ-explanation for S+ and S− over D, we need to either show that
¯a∈S+(D, ¯a)
¯a∈S+(D, ¯a) is of exponential size, checking its safety can be carried out in
exponential time. On the other hand, the guess of h is also of exponential size, and therefore
¯a∈S+(D, ¯a) to (D,¯b) can be performed in
exponential time. The whole procedure can then be carried out in NEXPTIME. As it turns
out, this bound is also optimal:
(cid:73) Theorem 2.
coNEXPTIME-complete.

[22,24] The problems CQ-query-by-example and CQ-definability are

¯a∈S+(D, ¯a) is safe, i.e., that the free variables in Q

S+ and S− over D, then we can assume such CQ to beQ
set of atoms is D|S+| and whose tuple of free variables isQ
here the assumption that Q
in fact appear in the atoms in D|S+|). The CQ Q
time sinceQ

The lower bound for CQ-definability was established by Willard using a complicated
reduction from the complement of a tiling problem. A simpler proof was then obtained by
ten Cate and Dalmau [22]. Their techniques also establish a lower bound for CQ-query-byexample.
 Notably, these lower bounds hold even when S+ and S− are unary relations.
The cost of evaluating CQ-explanations. Recall that in query by example not only we
want to ﬁnd a CQ-explanation q for S+ and S− over D, but also compute its result q(D) if
possible. It follows from the proof of Proposition 1 that in case there is a CQ-explanation for
¯a∈S+(D, ¯a), i.e., the CQ whose
¯a∈S+ ¯a (notice that we are using
¯a∈S+ ¯a do
¯a∈S+(D, ¯a) is known as the canonical
CQ-explanation. We could then simply evaluate this canonical CQ-explanation over D in
order to meet the requirements of query by example. This, however, takes double exponential
¯a∈S+(D, ¯a) itself is of exponential size. It is not known whether there are better
algorithms for computing the result of some CQ-explanation, but the results in this section
suggest that this is unlikely.
Size of CQ explanations and deﬁnitions. It follows from the previous observations that
CQ-explanations are of at most exponential size (by taking the canonical CQ-explanation as
witness). The same holds for CQ-deﬁnitions. Interestingly, these bounds are optimal:
(cid:73) Proposition 2.
1. If there is a CQ-explanation for S+ and S− over D, then there is a CQ-explanation of at

[22,24] The following statements hold:

most exponential size; namely,Q

¯a∈S+(D, ¯a). Similarly, for CQ-deﬁnitions.

2. There is a family (Dn, S+

over Dn, such that (a) the combined size of Dn, S+
there is a CQ-explanation for S+
CQ-explanation is at least 2n. Similarly, for CQ-deﬁnitions.

n )n≥0 of tuples of databases Dn and relations S+

n and S−
n is polynomial in n, (b)
n over Dn, and (c) the size of the smallest such

n , and S−

n and S−

n , S−

n

P. Barceló and M. Romero

XX:7

¯a∈S+(D, ¯a), and (2) it checks whetherQ

(1) It computesQ
case thatQ
(a) The construction ofQ

Sources of complexity. The QBE test performs the following steps on input (D, S+, S−):
¯a∈S+(D, ¯a) is unsafe or it is the
¯a∈S+(D, ¯a) → (D,¯b) for some ¯b ∈ S−. The deﬁnability test is equivalent, but the
homomorphism test is then extended to each tuple over D but outside S+. Two sources of
complexity are involved in these tests, each one of which incurs in one exponential blow up:
¯a∈S+(D, ¯a) → (D,¯b).
In order to alleviate the high complexity of the tests we thus propose relaxations of these two
sources of complexity. The proposed relaxations are based on well-studied approximation
notions with strong theoretical support. As such, they give rise to clean reformulations of
the notions of CQ-explanations/deﬁnitions. We start with the homomorphism test in the
following section.

¯a∈S+(D, ¯a), and (b) the homomorphism testsQ

4

A relaxation of the homomorphism test

We use an approximation technique for the homomorphism test based on the existential
pebble game. This technique ﬁnds several applications in database theory [12,17] and can be
shown to be equivalent to the strong consistency tests for homomorphism approximation
used in the area of constraint satisfaction [18]. The complexity of the (existential) pebble
game is by now well-understood [15,16]. We borrow several techniques used in such analysis
to understand the complexity of our problems. We also prove some results on the complexity
of such games that are of independent interest. We deﬁne the existential pebble game below.
The existential pebble game. Let k > 1. The existential k-pebble game is played by the
spoiler and the duplicator on pairs (D, ¯a) and (D0,¯b), where D and D0 are databases over
the same schema and ¯a and ¯b are n-ary (n ≥ 0) tuples over D and D0, respectively. The
spoiler plays on D only, and the duplicator responds on D0. In the ﬁrst round the spoiler
places his pebbles p1, . . . , pk on (not necessarily distinct) elements c1, . . . , ck in D, and the
duplicator responds by placing his pebbles q1, . . . , qk on elements d1, . . . , dk in D0. In every
further round, the spoiler removes one of his pebbles, say pi, for 1 ≤ i ≤ k, and places it
on an element of D, and the duplicator responds by placing his corresponding pebble qi on
some element of D0. The duplicator wins if he has a winning strategy, i.e., he can indeﬁnitely
continue playing the game in such way that at each round, if c1, . . . , ck and d1, . . . , dk are
the elements covered by pebbles p1, . . . , pk and q1, . . . , qk on D and D0, respectively, then

(cid:0)(c1, . . . , ck, ¯a), (d1, . . . , dk,¯b)(cid:1)

is a partial homomorphism from D to D0. Recall that this means that for every atom of
the form R(¯c) ∈ D, where each element c of ¯c appears in (c1, . . . , ck, ¯a), it is the case that
R( ¯d) ∈ D0, where ¯d is the tuple that is obtained from ¯c by replacing each element c of ¯c by
its corresponding element d in (d1, . . . , dk,¯b). If such winning strategy for the duplicator
exists, we write (D, ¯a) →k (D0,¯b).
It is easy to see that the relations →k, for k > 1, provide an approximation of the notion

of homomorphism in the following sense:

→ (cid:40) . . . (cid:40) →k+1 (cid:40) →k (cid:40) ··· (cid:40) →2 .

Furthermore, these approximations are convenient from a complexity point of view: While
checking for the existence of a homomorphism from (D, ¯a) to (D0,¯b) is NP-complete, checking
for the existence of a winning strategy for the duplicator in the existential k-pebble game
can be solved eﬃciently:

XX:8

The Complexity of Reverse Engineering Problems for Conjunctive Queries

(cid:73) Proposition 3.
and n-ary tuples ¯a and ¯b over D and D0, respectively, can be solved in polynomial time.

[17] Fix k > 1. Checking if (D, ¯a) →k (D0,¯b), given databases D and D0

Furthermore, there is an interesting connection between the existential pebble game and

the evaluation of CQs of bounded treewidth as established in the following proposition:
[4] Fix k ≥ 1. Consider databases D and D0 over the same schema and
(cid:73) Proposition 4.
n-ary tuples ¯a and ¯b over D and D0, respectively. Then (D, ¯a) →k+1 (D0,¯b) if and only if for
each CQ q(¯x) in TW(k) such that |¯x| = n the following holds:

¯a ∈ q(D) =⇒ ¯b ∈ q(D0),

or, equivalently, (Dq, ¯x) → (D, ¯a) implies (Dq, ¯x) → (D0,¯b), where as before Dq is the database
that contains all the atoms of q.
Moreover, in case that (D, ¯a) 6→k+1 (D0,¯b) there exists an exponential size CQ q(¯x) in

TW(k) such that ¯a ∈ q(D) but ¯b 6∈ q(D0).

The relaxed test. We study the following relaxed version of the QBE test for CQs that
replaces the notion of homomoprhism → with its approximation →k, for a ﬁxed k > 1:

k-pebble QBE test for CQs: Takes as input a database D and n-ary relations S+ and S−
over D. It accepts if and only if:

1.Q
2.Q

¯a∈S+(D, ¯a) is safe, and
¯a∈S+(D, ¯a) 6→k (D,¯b) for each tuple ¯b ∈ S−.

Analogously, we deﬁne the k-pebble deﬁnability test for CQs. It immediately follows
from the fact that the relation →k can be decided in polynomial time (Proposition 3) that
the k-pebble tests for CQs reduce the complexity of the general test from coNEXPTIME to
EXPTIME. Later, in Section 4.2, we show that this is optimal.

4.1 A characterization of the k-pebble tests for CQs
Using Proposition 4 we can now establish the theoretical meaningfulness of the relaxed tests:
They admit a clean characterization in terms of the CQs of bounded treewidth. In fact,
recall that the QBE (resp., deﬁnability) test for CQs precisely characterizes the existence of
CQ-explanations (resp., CQ-deﬁnitions). As we show next, their relaxed versions based on
the existential (k + 1)-pebble game preserve these characterizations up to treewidth k:
(cid:73) Theorem 3. Fix k ≥ 1. Consider a database D and n-ary relations S+ and S− over D.
1. There is a TW(k)-explanation for S+ and S− over D if and only if the (k + 1)-pebble

QBE test for CQs accepts D, S+, and S−.

2. There is a TW(k)-deﬁnition for S+ over D if and only if the (k + 1)-pebble deﬁnability

test for CQs accepts D and S+.

Proof. We concentrate on explanations (the proof for deﬁnitions is analogous). From left to
right, assume for the sake of contradiction that q is a TW(k)-explanation for S+ and S−
over D, yet the (k + 1)-pebble QBE test for CQs fails over D, S+, and S−. Since there is a
¯a∈S+(D, ¯a) is
¯a∈S+(D, ¯a) →k+1 (D,¯b) for some ¯b ∈ S−. Since
S+ ⊆ q(D) it is the case that ¯a ∈ q(D) for each ¯a ∈ S+. That is, (Dq, ¯x) → (D, ¯a) for each
¯a∈S+(D, ¯a).

TW(k)-explanation for S+ and S− over D, we have from Proposition 1 thatQ
safe. Therefore, it must be the case thatQ
¯a ∈ S+. Due to basic properties of direct products, this implies that (Dq, ¯x) →Q

P. Barceló and M. Romero

XX:9

From Proposition 4 we conclude that (Dq, ¯x) → (D,¯b), i.e., ¯b ∈ q(D). This is a contradiction
since ¯b ∈ S− and q(D) ∩ S− = ∅.
From right to left, assume that the (k + 1)-pebble QBE test for CQs accepts D, S+, and
¯a∈S+(D, ¯a) 6→k+1
¯a∈S+(D, ¯a) is safe we can apply Proposition 4, which tells us that for each
, ¯x) 6→ (D,¯b). Suppose

¯a∈S+(D, ¯a) is safe and for every tuple ¯b ∈ S− it is the case thatQ

S−, i.e.,Q
(D,¯b). SinceQ

¯b ∈ S− there is a CQ q¯b(¯x) such that (Dq¯b
ﬁrst that S− 6= ∅ and let:

¯a∈S+(D, ¯a) but (Dq¯b
q¯b(¯x).

, ¯x) →Q
q(¯x) := ^

¯b∈S−

CQ q¯b such that ¯b ∈ S− and then move all existentially quantiﬁed variables inV¯b∈S− q¯b(¯x)
easily follows that (Dq, ¯x) →Q

It is easy to see that q(¯x) is well-deﬁned (since S− is nonempty) and can be expressed as a
CQ in TW(k). For the latter we simply use fresh existentially quantiﬁed variables for each
to the front. We now prove that q(¯x) is a TW(k)-explanation for S+ and S− over D. It
¯a∈S+(D, ¯a) for
each ¯b ∈ S−. But then (Dq, ¯x) → (D, ¯a) for each ¯a ∈ S+. This means that ¯a ∈ q(D) for each
¯a ∈ S+, i.e., S+ ⊆ q(D). Assume now for the sake of contradiction that q(D) ∩ S− 6= ∅, that
is, there is a tuple ¯b ∈ q(D)∩S−. Then (Dq, ¯x) → (D,¯b), which implies that (Dq¯b
, ¯x) → (D,¯b).
This is a contradiction. The case when S− = ∅ can be proved using similar techniques. (cid:74)

¯a∈S+(D, ¯a) from the fact that (Dq¯b

, ¯x) →Q

4.2 The complexity of the k-pebble tests for CQs
As mentioned before, the k-pebble tests for CQs can be evaluated in exponential time. We
show here that such bounds are also optimal:
(cid:73) Theorem 4. Deciding whether the k-pebble QBE test for CQs accepts (D, S+, S−) is
EXPTIME-complete for each k > 1. Similarly, for the k-pebble deﬁnability test for CQs.
This holds even if restricted to the case when S+ and S− are unary relations.

As a corollary to Theorems 3 and 4, we obtain the following interesting result:

(cid:73) Corollary 5. The problems TW(k)-query-by-example and TW(k)-definability are
EXPTIME-complete for each ﬁxed k ≥ 1. This holds even if restricted to the case when the
relations to be explained/deﬁned are unary.

We now provide a brief outline of the main ideas used for proving the lower bounds in
Theorem 4. Let us ﬁrst notice that in the case of the general QBE/deﬁnability tests for CQs,
a coNEXPTIME lower bound is obtained in [22] as follows:
1.

hard: Given databases D1, . . . ,Dm and D, is it the case thatQ

It is ﬁrst shown that the following product homomorphism problem (PHP) is NEXPTIMEIt 
is then shown that there is an easy polynomial-time reduction from PHP to the problem
of checking whether the QBE/deﬁnability test fails on its input.
The ideas used for proving (2) can be easily adapted to show that there is a polynomialtime 
reduction from the following relaxed version of PHP to the problem of checking whether
the k-pebble QBE/deﬁnability test fails on its input:

1≤i≤m Di → D?

2.

PROBLEM :
INPUT :
QUESTION :

k-pebble PHP (for k > 1)
Databases D1, . . . ,Dm and D over the same schema

Is it the case thatQ

1≤i≤m Di →k D?

We establish that this relaxed version of PHP is EXPTIME-complete for each ﬁxed k > 1:

XX:10 The Complexity of Reverse Engineering Problems for Conjunctive Queries

(cid:73) Theorem 6. The problem k-pebble PHP is EXPTIME-complete for each ﬁxed k > 1.
To prove this result, we exploit techniques from [15, 16] that study the complexity of
pebble games. In particular, it is shown in [16] that for each ﬁxed k > 1, checking whether
D →k D0 is P-complete. The proof uses an involved reduction from the monotone circuit
value problem, that is, given a monotone circuit C, it constructs two databases DC and D0
such that the value of C is 1 if and only if DC →k D0
C.

C

Di →k D ⇐⇒ DCM,n →k D0

In our case, to show that k-pebble PHP is EXPTIME-hard for each ﬁxed k > 1, we
reduce from the following well-known EXPTIME-complete problem: Given an alternating
Turing machine M and a positive integer n, decide whether M accepts the empty tape using
n space. The latter problem can be easily recast as a circuit value problem: We can construct
a circuit CM,n such that the value of CM,n is 1 if and only if M accepts the empty tape
using n space. The main idea of our reduction is to construct databases D1, . . . ,Dm and D,

given M and n, such that:Y
A natural approach then is to construct D1, . . . ,Dm,D such that Q

where DCM,n and D0
1≤i≤m Di and D
roughly coincide with DCM,n and D0
. However, there is a problem with this: the
databases DCM,n and D0
closely resemble the circuit CM,n, but the size of CM,n is
exponential in |M| and n, and so are the sizes of DCM,n and D0
. Although it is possible
to codify the exponential size database DCM,n using a product of polynomial size databases
D1, . . . ,Dm, we cannot do the same with the exponential size D0
using D only. To
overcome this, we need to extend the techniques in [16] and show that the complexity of the
existential k-pebble game is P-complete even over a ﬁxed template:
(cid:73) Lemma 7. For each ﬁxed k > 1, there is a database Dk that only depends on k, such that
the following problem is P-complete: Given a database D, decide whether D →k Dk.

1≤i≤m

are deﬁned as in [16].

CM,n

CM,n

CM,n

,

CM,n

CM,n

CM,n

To prove this, we again use a reduction from the circuit value problem that given a circuit
C constructs a database ˜DC such that C takes value 1 if and only if ˜DC →k Dk. We then
use the following idea to prove that k-pebble PHP is EXPTIME-complete: Given M and
1≤i≤m Di and

n, we construct in polynomial time databases D1, . . . ,Dm and D such thatQ
Y
D roughly coincide with ˜DCM,n and Dk, respectively. It then follows that:

Di →k D ⇐⇒ ˜DCM,n →k Dk ⇐⇒ M accepts the empty tape using n space.

1≤i≤m

4.3 Evaluating the result of TW(k)-explanations
Recall that computing the result of CQ-explanations might require double exponential time.
For TW(k)-explanations, instead, we can do this in single exponential time.
(cid:73) Theorem 8. Fix k ≥ 1. There is a single exponential time algorithm that, given a database
D and n-ary relations S+ and S− over D, does the following:
1. It checks whether there is a TW(k)-explanation for S+ and S− over D, and
2.
Proof. We ﬁrst check in exponential time the existence of one such TW(k)-explanation for
S+ and S− over D using the (k + 1)-pebble QBE test for CQs. If such TW(k)-explanation

if the latter holds, it computes the evaluation q(D) of one such TW(k)-explanation q.

P. Barceló and M. Romero

XX:11

Q
exists, we compute in exponential time the set Se of all n-ary tuples ¯b over D such that
¯a∈S+(D, ¯a) →k+1 (D,¯b). Notice, in particular, that S+ ⊆ Se and Se ∩ S− = ∅. Moreover,
it can be shown that Se = q(D) for some TW(k)-explanation q for S+ and S− over D. (cid:74)
Notably, the previous result computes the result of a TW(k)-explanation q for S+ and
S− over D without explicitly computing q. One might wonder whether it is possible to also
include q in the output of the algorithm. The answer is negative, and the reason is that
TW(k)-explanations/deﬁnitions can be double exponentially large in the worst case:
(cid:73) Proposition 5. Fix k ≥ 1. The following holds:
1. Assume that there is a TW(k)-explanation for S+ and S− over D. Then there is one
2. There is a family (Dn, S+

such TW(k)-explanation of at most double exponential size.
over Dn, such that (a) the combined size of Dn, S+
is a TW(k)-explanation for S+
TW(k)-explanation is at least 22n.
The same holds for TW(k)-deﬁnitions.
Proof. From the proof of Theorem 3, whenever there is a TW(k)-explanation for S+ and
¯a∈S+(D, ¯a) and (D,¯b), i.e., double
exponential in the size of D, S+ and S−. Thus, the size of q is at most double exponential in
that of D, S+ and S−. The lower bound follows by inspection of the proof of Theorem 4. (cid:74)
Notice that this establishes a diﬀerence with CQ-explanations/deﬁnitions, which are at

S− over D this can be assumed to be the CQ q =V¯b∈S− q¯b(¯x). From Proposition 4, each
such q¯b is of exponential size in the combined size ofQ

n )n≥0 of tuples of databases Dn and relations S+
n and S−

n and S−
n is polynomial in n, (b) there
n over Dn, and (c) the size of the smallest such

n , S−

n , and S−

n

most of exponential size (see Proposition 2).

The construction of the direct productQ

5 Desynchronizing the direct product
We now look at the other source of complexity for the QBE and deﬁnability tests for CQs:
¯a∈S+(D, ¯a). It is a priori not obvious how to deﬁne
reasonable approximations of this construction with a meaningful theoretical interpretation.
As a ﬁrst step in this direction, we look at a simple idea that has been applied in the study
of CQ-deﬁnability: We “desynchronize” this direct product and consider each tuple ¯a ∈ S+
in isolation. This leads to the following relaxed test:

Desynchronized QBE test for CQs: Takes as input a database D and n-ary relations
S+, S− over D. It accepts iﬀ for each ¯a ∈ S+ and ¯b ∈ S− it is the case that (D, ¯a) 6→ (D,¯b).
Similarly, we deﬁne the desynchronized deﬁnability test for CQs. Notice that, unlike the
previous tests we have presented in the paper, the desynchronized tests do not require any
safeness condition (for reasons we explain below).

class of unions of CQs (UCQs). Recall that a UCQ is a formula Q of the formW
D corresponds toS

It follows from [1] that these tests capture the notion of explanations/deﬁnitions for the
1≤i≤m qi(¯x),
where the qi(¯x)’s are CQs over the same schema. The evaluation Q(D) of Q over database
1≤i≤m qi(D). We denote by UCQ the class of UCQs. We then obtain the

following:
(cid:73) Theorem 9 (implicit in [1]). Consider a database D and n-ary relations S+ and S− over
D. There is a UCQ-explanation for S+ and S− over D if and only if the desynchronized
QBE test for CQs accepts D, S+, and S−. Similarly, for the UCQ-deﬁnitions of S+ and the
desynchronized deﬁnability test for CQs.

XX:12 The Complexity of Reverse Engineering Problems for Conjunctive Queries

In this case, the canonical UCQ-explanation/deﬁnition corresponds to Q =S

¯a∈S+(D, ¯a).
This explains why no safeness condition is required on the desynchronized tests, as each pair
of the form (D, ¯a), for ¯a ∈ S+, is safe by deﬁnition. Notice that Q consists of polynomially
many CQs of polynomial size. Its evaluation Q(D) over a database D can thus be computed
in single exponential time (as opposed to the double exponential time needed to evaluate the

canonical CQ-explanationQ

¯a∈S+(D, ¯a)).

It is easy to see that the desynchronization of the direct product reduces the complexity
of the general tests from coNEXPTIME to coNP. It follows from [1] that this bound is
optimal. As a corollary to Theorem 9 we thus obtain that QBE/deﬁnability for UCQs are
coNP-complete:
(cid:73) Proposition 6.
1. Deciding whether the desynchronized QBE test for CQs accepts (D, S+, S−) is coNP-

[1] The following statements hold:

complete. Similarly, for the desynchronized deﬁnability test for CQs.

2. UCQ-query-by-example and UCQ-definability are coNP-complete.

5.1 Combining both relaxations
By combining both relaxations (replacing homomorphism tests with relations →k, for k > 1,
and desynchronizing direct products) we obtain the desynchronized k-pebble QBE (resp.,
deﬁnability) test for CQs. Its deﬁnition coincides with that of the desynchronized QBE (resp.,
deﬁnability) test for CQs given above, save that now the homomorphism test (D, ¯a) → (D,¯b)
is replaced by (D, ¯a) →k (D,¯b). As is to be expected from the previous charaterizations, this
test captures deﬁnability by the class of UCQs of bounded treewidth. Formally, let UTW(k)
be the class of unions of CQs in TW(k) (for k ≥ 1). Then:
(cid:73) Theorem 10. Fix k ≥ 1. Consider a database D and n-ary relations S+ and S− over
D. There is a UTW(k)-explanation for S+ and S− over D if and only if the desynchronized
(k+1)-pebble QBE test for CQs accepts D, S+, and S−. Similarly, for the UTW(k)-deﬁnitions
of S+ and the desynchronized (k + 1)-pebble deﬁnability test for CQs.

Furthermore, in case there is a UTW(k)-explanation for S+ and S− over D (resp., a
UTW(k)-deﬁnition of S+ over D), then there is one such explanation/deﬁnition given by a
union of polynomially many CQs in TW(k), each one of which is of at most exponential size.
Interestingly, the combination of both relaxations yields tractability for the QBE test. In
contrast, the deﬁnability test remains coNP-complete. The diﬀerence lies on the fact that the
QBE test only needs to perform a polynomial number of tests of the form (D, ¯a) →k (D,¯b)
for each ¯a ∈ S+ (one for each tuple ¯b ∈ S−), while the deﬁnability test needs to perform
exponentially many such tests (one for each tuple ¯b outside S+). Then:
(cid:73) Proposition 7. The following statements hold:
1. Deciding whether the desynchronized k-pebble QBE test for CQs accepts (D, S+, S−) can
be solved in polynomial time for each ﬁxed k > 1. As a consequence, UTW(k)-query-byexample 
is in polynomial time for each ﬁxed k ≥ 1.

2. If a UTW(k)-explanation for S+ and S− over D exists, we can compute the evaluation

Q(D) of one such explanation Q in exponential time.

3. Deciding whether the desynchronized k-pebble deﬁnability test for CQs accepts (D, S+)
is coNP-complete for each ﬁxed k > 1. As a consequence, UTW(k)-definability is
coNP-complete for each k ≥ 1.

P. Barceló and M. Romero

XX:13

6

Conjunctive regular path queries

We now switch to study the QBE and deﬁnability problems in the context of graph databases.
Let Σ be a ﬁnite alphabet. Recall that a graph database G = (V, E) over Σ consists of a ﬁnite
set V of nodes and a set E ⊆ V × Σ × V of directed edges labeled in Σ (i.e., (v, a, v0) ∈ E
represents the fact that there is an a-labeled edge from node v to node v0 in G). A path in G
is a sequence

η = v0a1v1a2v2 . . . vk−1akvk,

for k ≥ 0,

such that (vi−1, ai, vi) ∈ E for each 1 ≤ i ≤ k. The label of η, denoted label(η), is the word
a1a2 . . . ak in Σ∗. Notice that v is a path for each node v ∈ V . The label of such path is the
empty word ε.

The basic navigational mechanism for querying graph databases is the class of regular
path queries, or RPQs (see, e.g., [5,25]). An RPQ L over alphabet Σ is a regular expression
over Σ. The evaluation L(G) of L over graph database G consists of those pairs (v, v0) of
nodes in G such that there is a path η in G from v to v0 whose label label(η) satisﬁes L.
The analogue of CQs in the context of graph databases is the class of conjunctive RPQs, or
CRPQs [8]. Formally, a CRPQ γ over Σ is an expression of the form:

∃¯z(L1(x1, y1) ∧ ··· ∧ Lm(xm, ym)),

where each Li is a RPQ over Σ, for 1 ≤ i ≤ m, and ¯z is a tuple of variables among
{x1, y1, . . . , xm, ym}. We write γ(¯x) to denote that ¯x is the tuple of free variables of γ. A
homomorphism from γ to the graph database G is a mapping h from {x1, y1, . . . , xm, ym} to
the nodes of G, such that (h(xi), h(yi)) ∈ Li(G) for each 1 ≤ i ≤ m. The evaluation γ(G) of
γ(¯x) over G is the set of tuples h(¯x) such that h a homomorphism from γ to G. We denote
the class of CRPQs by CRPQ.

that we now use a notion of strong homomorphism from a productQ
the languages deﬁned by pairs of nodes in Q

6.1 The QBE and deﬁnability tests for CRPQs
We present QBE/deﬁnability tests for CRPQs in the same spirit than the tests for CQs, save
1≤i≤n Gi of directed
graphs to a single directed graph G. This notion preserves, in a precise sense deﬁned below,
Interestingly, these tests yield a
coNEXPTIME upper bound for the QBE/deﬁnability problems for CRPQs, which improves
the EXPSPACE upper bound from [1]. In conclusion, QBE/deﬁnability for CRPQs is no
more diﬃcult than for CQs.

We start with some notation. Let v and v0 be nodes in a graph database G. We deﬁne

1≤i≤n Gi.

the following language in Σ∗:

LG
v,v0

:= {label(η) | η is a path in G from v to v0}.

1, v0

1, a, v0

Moreover, if G1 = (V1, E1) and G2 = (V2, E2) are graph databases over Σ, their direct product
G1 ⊗ G2 is the graph database (V, E) such that V = V1 × V2 and there is an a-labeled edge
2) ∈ E2.
in E from node (v1, v2) to node (v0
Let then G1, . . . ,Gn and G be graph databases over Σ. A strong homomorphism from
1≤i≤n Gi to the nodes of G such that for
1≤i≤n Gi, it is the case that:

1≤i≤n Gi to G is a mapping h from the nodes ofQ
Q

2) if and only if (v1, a, v2) ∈ E1 and (v0

n) of nodes inQ

each pair ¯v = (v1, . . . , vn) and ¯v0 = (v0

1, . . . , v0
for some coordinate i with 1 ≤ i ≤ n.

L

Gi
vi,v0

i

⊆ LG

h(¯v),h(¯v0),

XX:14 The Complexity of Reverse Engineering Problems for Conjunctive Queries

We write Q
1≤i≤n Gi ⇒ G when there is a strong homomorphism h from Q
Note that in this case, h must also be a (usual) homomorphism fromQ
Q
1≤i≤n Gi ⇒ G impliesQ

1≤i≤n Gi to G.
1≤i≤n Gi to G, i.e.,
1≤i≤n Gi → G. The next example shows that the converse does not

hold in general:
(cid:73) Example 11. Let ~Cn be the directed cycle of length n over {1, 2, . . . , n}. We assume ~Cn
to be represented as a graph database over the unary alphabet Σ = {a}. We then have that
~C2 ⊗ ~C3 → ~C6, since ~C2 ⊗ ~C3 is isomorphic to ~C6 as shown below (we omit the labels):

On the other hand, ~C2 ⊗ ~C3 6⇒ ~C6. To see this, take e.g. the homomorphism h deﬁned as

{(1, 1) 7→ 1, (2, 2) 7→ 2, (1, 3) 7→ 3, (2, 1) 7→ 4, (1, 2) 7→ 5, (2, 3) 7→ 6}.

This is not a strong homomorphism as witnessed by the pair (1, 1) and (2, 2). Indeed, we

have that: (cid:0)h(1, 1) = 1 and h(2, 2) = 2(cid:1) but (cid:0)L

~C2

1,2 6⊆ L

1,2 6⊆ L
1,2, but none of these words is in L
~C3

1,2 and L
~C6

~C3

1,2.(cid:1)

~C6

then we writeQ
over G. It accepts if and only ifQ
S+ over G. It accepts if and only ifQ

~C2

1,2, aaaa ∈ L

The reason is that aaa ∈ L
holds for any homomorphism h : ~C2 ⊗ ~C3 → ~C6.

1,2. The same
~C6
(cid:74)
If (G1, ¯a1), . . . , (Gn, ¯an) and (G,¯b) are graph databases with distinguished tuple of elements,
1≤i≤n Gi

1≤i≤n(Gi, ¯ai) ⇒ (G,¯b) if there is a strong homomorphism h fromQ

to G such that h(¯a1 ⊗ ··· ⊗ ¯an) = ¯b. Next we present our tests for CRPQs:

¯a∈S+(G, ¯a) 6⇒ (G,¯b) for each tuple ¯b ∈ S−.

QBE test for CRPQs: Takes as input a graph database G and n-ary relations S+ and S−
Deﬁnability test for CRPQs: Takes as input a graph database G and an n-ary relation
¯a∈S+(G, ¯a) 6⇒ (G,¯b) for each n-ary tuple ¯b /∈ S+.
As it turns out, our tests characterize the non-existence of CRPQ-explanations/deﬁnitions.
(Notice that unlike Proposition 1, we need no safety conditions on QBE/deﬁnability tests for
CRPQs for this characterization to hold).
(cid:73) Theorem 12. The following hold:
1. Let G be a database and S+, S− relations over G. There is a CRPQ-explanation for S+
2. Let G be a database and S+ a relation over G. There is a CRPQ-deﬁnition for S+ over G

and S− over G if and only if the QBE test for CRPQs accepts G, S+, and S−.
if and only if the deﬁnability test for CRPQs accepts G and S+.
Since containment of regular languages can be checked in polynomial space [21], it is

straightforward to check that both tests can be carried out in coNEXPTIME. Thus:
(cid:73) Theorem 13. CRPQ-query-by-example and CRPQ-definibility are in coNEXPTIME.

Whether these problems are complete for coNEXPTIME is left as an open question.

CRPQ vs UCQ explanations. It is easy to see that if there is a CRPQ-explanation for
S+ and S− over G, then there is also a UCQ-explanation [1]. One may wonder then if QBE

(2,3)(1,1)(1,2)(1,3)(2,1)(2,2)Figure4:ThegraphD′.wherehandh′areidentiﬁedwithwandw′respectively;xofOandisconnectedwithiandjofHand,andx′withi′andj′;yandy′ofOandareconnectedwithzandz′respectively.Additionally,thereisacopyofOkD,calledInitD,whereyandy′isconnectedtozandz′respectively,andthenodex′iscoloredwiththecolorinit.Also,therearetwocopiesofOkD,calledO0andO1,wherexandx′inbothO0andO1areconnectedtowandw′,respectively.Thenodey′inO0iscoloredwithafreshcolorfail.AllthenodesinO0andO1areadditionallycoloredwithzeroandone,respectively.NotethatDCandD′canbeconstructedfromC,α,vusinglogarithmicspace.Weconcludebyshowingthecorrectnessoftheconstruction.Claim1.5.valCα(v)=1ifandonlyifDC→kD′.Proof:SupposeﬁrstthatvalCα(v)=0.Inthiscase,theintuitionisthatthespoilercantraverseDCinatop-downfashionfromthegadgetsrepresentingtheoutputnodevtoagadgetrepresentinganinputnodeawithvalue0.Atthispointspoilercanreachtheposition{yy′}betweenOaandO0.Sincethecolorsofyandy′aredistinct(y′iscoloredwiththespecialcolorfail),thisisawinningpositionforthespoiler.Formally,thestrategyofthespoilerisasfollows.HestartsplayingonepebbleonthenodexofInitS.Sincethisnodeiscoloredwithinit,duplicatormustrespondwiththeonlyinit-colorednode,thatis,withx′inInitD.ByLemma1.4,spoilercanreachposition{yy′}onInitSandInitDandthenposition{vz′}.Theinvariantisthatspoilercanalwaysreachapositionoftheform{au′},whereacorrespondstoanodeinCwithvalue0,andu′=z′ifacorrespondstoanOr-node,oru′=w′otherwise.Tomaintaintheinvariantspoilerproceedasfollows.SupposeacorrespondstoanOr-nodeinCwithchildrenbandc.Sincethevalueofais0,soarethevaluesofbandc.ByLemma1.3,whenplayingoverIaandIor,spoilercanreacheitherii′orjj′.Assumehereachesii′(thecasejj′isanalogous).Thenhecanreachxx′onOabandOor,andbyLemma1.4,hecanreachposition{bw′}andthensatisﬁestheinvariant.Similarly,supposeacorrespondstoanAnd-nodeinCwithchildrenbandc.Sincethevalueofais0,oneofthevaluesofbandcis0.Assumethevalueofbis0(theothercaseisanalogous).ByLemma1.3,whenplayingoverHaandHand,spoilercanreachii′andthenxx′onOabandOand.ByLemma1.4,hecanreachposition{bz′}andthensatisﬁestheinvariant.Withthisstrategythespoilereventuallyreachaposition{aw′}whereacorrespondstoaninputnodewithvalue0.ThenspoilerplacesapebbleonxinOa.SinceOaiscoloredwithzero,andtheonlyzero-colorednodesinD′arethoseinO0,duplicatormustrespondwithx′inO0.ByLemma1.4,hecanreachposition{yy′}onOaandO0.Thisisawinningpositionforthespoilerasthecolorsofyandy′aredistinct.SupposenowthatvalCα(v)=1.LetTbeatreewitnessingthefactthatvalCα(v)=1,thatis,TisasubgraphofCsuchthat(i)itsunderlyinggraphisatreerootedatv,(ii)ifaisanOr-nodeinT,thenthereisonlyonechildofainCthatisalsoinT(togetherwiththeedgefromthischildtoa),(iii)ifaisanAnd-nodeinT,thenthetwochildrenofainCareinT(togetherwith4P. Barceló and M. Romero

XX:15

Figure 1 The graph database G from Example 14.

for CRPQs and UCQs coincide. If this was the case, we would directly obtain a coNP
upper bound for CRPQ-query-by-example from Proposition 6 (which establishes that
UCQ-query-by-example is in coNP). The next example shows that this is not the case:
(cid:73) Example 14. Consider the graph database G over Σ = {a} given by the three connected
components depicted in Figure 1 (we omit the labels). Let S+ = {1, 10} and S− = {100}.
Clearly, (G, 1) 6→ (G, 100) and (G, 10) 6→ (G, 100), since the underlying graph of each component
on the left-hand side is a clique of size 4, while the one on the right-hand side is a clique
of size 3. It follows that there is a UCQ-explanation for S+ and S− over G. On the other
hand, a straightforward construction shows that (G, 1) ⊗ (G, 10) ⇒ (G, 100). The intuition is
that, since (40, 10) and (1, 4) have opposite direction, they do not synchronize in the product
and, thus, the product does not contain a clique of size 4. We conclude that there is no
CRPQ-explanation for S+ and S− over G.
(cid:74)

6.2 Relaxing the QBE and deﬁnability tests for CRPQs
In this section, we develop relaxations of the tests for CRPQs based on the ones we studied
for CQs in the previous sections. Let us start by observing that desynchronizing the
direct product trivializes the problem in this case: In fact, as expected the desynchronized
QBE/deﬁnability tests for CRPQs characterize QBE/deﬁnability for the unions of CRPQs
(UCRPQ). It is known, on the other hand, that QBE/deﬁnability for UCRPQ and UCQ
coincide [1]. The results then follow directly from the ones obtained in Section 5 for UCQs.
In particular, UCRPQ-query-by-example and UCRPQ-definability are coNP-complete.
We thus concentrate on the most interesting case, which is the relaxation of the homomorphism 
tests. In order to approximate the strong homomorphism test, we consider a
variant of the existential pebble game. Fix k > 1. Let (G1, ¯a1), . . . , (Gn, ¯an) and (G,¯b) be
The strong existential k-pebble game onQ
graph databases over Σ with distinguished tuples of elements. We deﬁne ¯a := ¯a1 ⊗ ··· ⊗ ¯an.
pebble game onQ
1≤i≤n(Gi, ¯ai) and (G,¯b) is played as the existential kare 
the elements covered by pebbles onQ
1≤i≤n(Gi, ¯ai) and (G,¯b), but now, at each round, if c1, . . . , ck and d1, . . . , dk
1≤i≤n Gi and G, respectively, then the duplicator
Q
needs to ensure that ((c1, . . . , ck, ¯a), (d1, . . . , dk,¯b)) is a strong partial homomorphism from
nodes inQ
1≤i≤n Gi and G. This means that for every pair ¯v = (v1, . . . , vn) and ¯v0 = (v0
n) of
1≤i≤n Gi that appear in (c1, . . . , ck, ¯a), if u and u0 are the elements in (d1, . . . , dk,¯b)
that correspond to ¯v and ¯v0, respectively, then:

1, . . . , v0

Gi
vi,v0

i

u,u0,

⊆ LG

L

We write Q
existential k-pebble game onQ

for some coordinate i with 1 ≤ i ≤ n.

1≤i≤n(Gi, ¯ai) ⇒k (G,¯b) if the duplicator has a winning strategy in the strong

1≤i≤n(Gi, ¯ai) and (G,¯b).

−12341′2′3′4′3′′2′′1′′++Figure4:ThegraphD′.wherehandh′areidentiﬁedwithwandw′respectively;xofOandisconnectedwithiandjofHand,andx′withi′andj′;yandy′ofOandareconnectedwithzandz′respectively.Additionally,thereisacopyofOkD,calledInitD,whereyandy′isconnectedtozandz′respectively,andthenodex′iscoloredwiththecolorinit.Also,therearetwocopiesofOkD,calledO0andO1,wherexandx′inbothO0andO1areconnectedtowandw′,respectively.Thenodey′inO0iscoloredwithafreshcolorfail.AllthenodesinO0andO1areadditionallycoloredwithzeroandone,respectively.NotethatDCandD′canbeconstructedfromC,α,vusinglogarithmicspace.Weconcludebyshowingthecorrectnessoftheconstruction.Claim1.5.valCα(v)=1ifandonlyifDC→kD′.Proof:SupposeﬁrstthatvalCα(v)=0.Inthiscase,theintuitionisthatthespoilercantraverseDCinatop-downfashionfromthegadgetsrepresentingtheoutputnodevtoagadgetrepresentinganinputnodeawithvalue0.Atthispointspoilercanreachtheposition{yy′}betweenOaandO0.Sincethecolorsofyandy′aredistinct(y′iscoloredwiththespecialcolorfail),thisisawinningpositionforthespoiler.Formally,thestrategyofthespoilerisasfollows.HestartsplayingonepebbleonthenodexofInitS.Sincethisnodeiscoloredwithinit,duplicatormustrespondwiththeonlyinit-colorednode,thatis,withx′inInitD.ByLemma1.4,spoilercanreachposition{yy′}onInitSandInitDandthenposition{vz′}.Theinvariantisthatspoilercanalwaysreachapositionoftheform{au′},whereacorrespondstoanodeinCwithvalue0,andu′=z′ifacorrespondstoanOr-node,oru′=w′otherwise.Tomaintaintheinvariantspoilerproceedasfollows.SupposeacorrespondstoanOr-nodeinCwithchildrenbandc.Sincethevalueofais0,soarethevaluesofbandc.ByLemma1.3,whenplayingoverIaandIor,spoilercanreacheitherii′orjj′.Assumehereachesii′(thecasejj′isanalogous).Thenhecanreachxx′onOabandOor,andbyLemma1.4,hecanreachposition{bw′}andthensatisﬁestheinvariant.Similarly,supposeacorrespondstoanAnd-nodeinCwithchildrenbandc.Sincethevalueofais0,oneofthevaluesofbandcis0.Assumethevalueofbis0(theothercaseisanalogous).ByLemma1.3,whenplayingoverHaandHand,spoilercanreachii′andthenxx′onOabandOand.ByLemma1.4,hecanreachposition{bz′}andthensatisﬁestheinvariant.Withthisstrategythespoilereventuallyreachaposition{aw′}whereacorrespondstoaninputnodewithvalue0.ThenspoilerplacesapebbleonxinOa.SinceOaiscoloredwithzero,andtheonlyzero-colorednodesinD′arethoseinO0,duplicatormustrespondwithx′inO0.ByLemma1.4,hecanreachposition{yy′}onOaandO0.Thisisawinningpositionforthespoilerasthecolorsofyandy′aredistinct.SupposenowthatvalCα(v)=1.LetTbeatreewitnessingthefactthatvalCα(v)=1,thatis,TisasubgraphofCsuchthat(i)itsunderlyinggraphisatreerootedatv,(ii)ifaisanOr-nodeinT,thenthereisonlyonechildofainCthatisalsoinT(togetherwiththeedgefromthischildtoa),(iii)ifaisanAnd-nodeinT,thenthetwochildrenofainCareinT(togetherwiththeedgesfromthechildrentoa),(iv)thevalueofeachnodeinTis1.Notethatinparticular,alltheleavesofTareinputnodeswithvalue1(notnecessarilyalltheinputnodeswithvalue1fromC).UsingTwecanshowthatthereisanhomomorphismhTfromDCtoD′.Inparticular,4XX:16 The Complexity of Reverse Engineering Problems for Conjunctive Queries

By replacing the notion of strong homomorphism ⇒ with its approximation ⇒k, for a

ﬁxed k > 1, we can then deﬁne the following relaxed test:

¯a∈S+(G, ¯a) 6⇒k (G,¯b) for each tuple ¯b ∈ S−.

k-pebble QBE test for CRPQs: Takes as input a graph database G and n-ary relations

S+ and S− over G. It accepts iﬀQ
most k. Formally, the treewidth of a CRPQ γ = ∃¯yV

The k-pebble deﬁnability test for CRPQs is deﬁned analogously. As in the case of CQs,
these tests characterize the existence of CRPQs-explanations/deﬁnitions of treewidth at
1≤i≤m Li(xi, yi) is the treewidth of the
undirected graph that contains as nodes the existentially quantiﬁed variables of γ, i.e., those
in ¯y, and whose set of edges is {{xi, yi} | 1 ≤ i ≤ m, xi 6= yi}. We denote by TWcrpq(k) the
class of CRPQs of treewidth at most k (for k ≥ 1). Then:
(cid:73) Theorem 15. Fix k ≥ 1. Consider a database G and n-ary relations S+ and S− over G.
1. There is a TWcrpq(k)-explanation for S+ and S− over G if and only if the (k + 1)-pebble

QBE test for CRPQs accepts G, S+ and S−.

2. There is a TWcrpq(k)-deﬁnition for S+ over G if and only if the (k + 1)-pebble deﬁnability

test for CRPQs accepts G and S+.

the problem of checking whetherQ

Using similar ideas as for the existential k-pebble game, it is possible to prove that
1≤i≤n(Gi, ¯ai) ⇒k (G,¯b), given (G1, ¯a1), . . . , (Gn, ¯an) and
(G,¯b), can be solved in exponential time for each ﬁxed k > 1. We then obtain that the
k-pebble QBE/deﬁnability tests for CRPQs take exponential time, and from Theorem 15
that TWcrpq(k)-query-by-example and TWcrpq(k)-definability are in EXPTIME (same
than for TW(k) as stated in Corollary 5). We also obtain an exponential upper bound on
the cost of evaluating a TWcrpq(k)-explanation (in case it exists):
(cid:73) Proposition 8. Fix k ≥ 1. The following statements hold:
1. TWcrpq(k)-query-by-example and TWcrpq(k)-definability are in EXPTIME.
2. Moreover, in case that there is a TWcrpq(k)-explanation of S+ and S− over G, the
evaluation γ(G) of one such explanation γ over G can be computed in exponential time.

7

Future work

We have left some problems open. The most notable one is determining the precise complexity
of QBE/deﬁnability for CRPQs (resp., CRPQs of bounded treewidth). We have only obtained
upper bounds for these problems that show that they are no more diﬃcult than for CQs,
but proving matching lower bounds seems challenging.

An interesting line for future research is studying what to do when no explanation/deﬁnition 
exists for a set of examples. In such cases one might want to compute a query that
minimizes the “error”, e.g., the number of misclassiﬁed examples. We plan to study whether
the techniques presented in this paper can be extended to deal with such problems.

Acknowledgements: We are grateful to Leonid Libkin for their helpful comments in earlier versions of
the paper and to Timos Antonopoulos for enlightening discussions about the notion of deﬁnability. We are
also indebted to the reviewers of this article who helped us improving the presentation. In particular, one
of the revieweres identiﬁed a subtle but important issue with the QBE tests presented in the paper that
would have gone unnoticed otherwise. Barceló and Romero are funded by the Millennium Nucleus Center
for Semantic Web Research under Grant NC120004. Romero is also funded by a Conicyt PhD scholarship.

P. Barceló and M. Romero

XX:17

References

1 Timos Antonopoulos, Frank Neven, and Frédéric Servais. Deﬁnability problems for graph

query languages. In ICDT, pages 141–152, 2013.

2 Marcelo Arenas and Gonzalo I. Díaz. The exact complexity of the ﬁrst-order logic deﬁnability 
problem. ACM TODS, to appear.

3 Marcelo Arenas, Gonzalo I. Díaz, and Egor V. Kostylev. Reverse engineering sparql queries.

In WWW, 2016.

4 Albert Atserias, Phokion G. Kolaitis, and Moshe Y. Vardi. Constraint propagation as a

proof system. In CP, pages 77–91, 2004.
Pablo Barceló. Querying graph databases. In PODS, pages 175–188, 2013.

5
6 Angela Bonifati, Radu Ciucanu, and Aurélien Lemay. Learning path queries on graph

databases. In EDBT, pages 109–120, 2015.

7 Angela Bonifati, Radu Ciucanu, and Slawek Staworko. Learning join queries from user

examples. ACM Trans. Database Syst., 40(4):24, 2016.

8 Diego Calvanese, Giuseppe De Giacomo, Maurizio Lenzerini, and Moshe Y. Vardi. Containment 
of conjunctive regular path queries with inverse. In KR, pages 176–185, 2000.

9 Chandra Chekuri and Anand Rajaraman. Conjunctive query containment revisited. Theor.

Comput. Sci., 239(2):211–229, 2000.
Sara Cohen and Yaacov Y. Weiss. Learning tree patterns from example graphs. In ICDT,
pages 127–143, 2015.

11 Mariano P. Consens and Alberto O. Mendelzon. Graphlog: a visual formalism for real life

recursion. In PODS, pages 404–416, 1990.

12 Víctor Dalmau, Phokion G. Kolaitis, and Moshe Y. Vardi. Constraint satisfaction, bounded

treewidth, and ﬁnite-variable logics. In CP, pages 310–326, 2002.

13 Rina Dechter. From local to global consistency. Artif. Intell., 55(1):87–108, 1992.
14 Reinhard Diestel. Graph Theory, 4th Edition, volume 173 of Graduate texts in mathematics.

Springer, 2012.

10

16

17

18

20

21

15 Martin Grohe. Equivalence in ﬁnite-variable logics is complete for polynomial time. Combinatorica,
 19(4):507–532, 1999.
Phokion G. Kolaitis and Jonathan Panttaja. On the complexity of existential pebble games.
In CSL, pages 314–329, 2003.
Phokion G. Kolaitis and Moshe Y. Vardi. On the expressive power of datalog: Tools and
a case study. J. Comput. Syst. Sci., 51(1):110–134, 1995.
Phokion G. Kolaitis and Moshe Y. Vardi. A game-theoretic approach to constraint satisfaction.
 In AAAI, pages 175–181, 2000.

19 Hao Li, Chee-Yong Chan, and David Maier. Query from examples: An iterative, datadriven 
approach to query construction. PVLDB, 8(13):2158–2169, 2015.
Slawek Staworko and Piotr Wieczorek. Characterizing XML twig queries with examples.
In ICDT, pages 144–160, 2015.
Larry J. Stockmeyer and Albert R. Meyer. Word problems requiring exponential time:
Preliminary report. In Proceedings of the 5th Annual ACM Symposium on Theory of Computing,
 April 30 - May 2, 1973, Austin, Texas, USA, pages 1–9, 1973.

22 Balder ten Cate and Víctor Dalmau. The product homomorphism problem and applications.

23 Quoc Trung Tran, Chee Yong Chan, and Srinivasan Parthasarathy. Query reverse enginIn 
ICDT, pages 161–176, 2015.

eering. VLDB J., 23(5):721–746, 2014.

24 Ross Willard. Testing expressibility is hard. In CP, pages 9–23, 2010.
25
Peter T. Wood. Query languages for graph databases. SIGMOD Record, 41(1):50–60, 2012.
26 Meihui Zhang, Hazem Elmeleegy, Cecilia M. Procopiuc, and Divesh Srivastava. Reverse

engineering complex join queries. In SIGMOD, pages 809–820, 2013.

