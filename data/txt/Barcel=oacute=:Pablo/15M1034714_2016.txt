SIAM J. COMPUT.
Vol. 45, No. 4, pp. 1339–1376

c(cid:2) 2016 Society for Industrial and Applied Mathematics

SEMANTIC ACYCLICITY ON GRAPH DATABASES
‡
, AND MOSHE Y. VARDI

PABLO BARCEL ´O

, MIGUEL ROMERO

†

†

∗

Abstract. It is known that unions of acyclic conjunctive queries (CQs) can be evaluated in linear
time, as opposed to arbitrary CQs, for which the evaluation problem is NP-complete. It follows from
techniques in the area of constraint-satisfaction problems that semantically acyclic unions of CQs—
i.e., unions of CQs that are equivalent to a union of acyclic ones—can be evaluated in polynomial
time, though testing membership in the class of semantically acyclic CQs is NP-complete. We
study here the fundamental notion of semantic acyclicity in the context of graph databases and
unions of conjunctive regular path queries with inverse (UC2RPQs).
It is known that unions of
acyclic C2RPQs can be evaluated eﬃciently, but it is by no means obvious whether similarly good
evaluation properties hold for the class of UC2RPQs that are semantically acyclic. We prove that
checking whether a UC2RPQ is semantically acyclic is Expspace-complete and obtain as a corollary
that evaluation of semantically acyclic UC2RPQs is ﬁxed-parameter tractable. In addition, our tools
yield a strong theory of approximations for UC2RPQs when no equivalent acyclic UC2RPQ exists.

Key words. graph databases, conjunctive regular path queries, conjunctive queries, acyclicity,

query evaluation, query approximation, constraint satisfaction problems

AMS subject classiﬁcation. 68P15

DOI. 10.1137/15M1034714

1. Introduction. Conjunctive queries (CQs) are the most fundamental class
of database queries and also the most intensively studied in the database theory
community. The evaluation problem for CQs is as follows: Given a CQ θ, a database
D, and a tuple ¯a of elements in D, does ¯a belong to the result θ(D) of applying θ to
D? Notice that the cost of evaluation is thus measured in terms of the size |D| of the
database D and |θ| of the query θ, which in database terminology corresponds to the
combined complexity of the problem [41].

The evaluation problem for CQs is NP-complete [12]; this motivated a ﬂurry
of activity for ﬁnding tractable cases of the problem. One of the oldest and most
important such restrictions is acyclicity. Acyclic CQs can in fact be evaluated in
linear time in both data and query size—O(|D|·|θ|) [44]. This good behavior extends
to unions of CQs (UCQs), each one of which is acyclic (the so-called acyclic UCQs).
Acyclicity is a syntactic property of queries that is by now well-understood [25].
On the other hand, the space of UCQs that is deﬁned by the notion of semantic
acyclicity—that is, the UCQs that are equivalent to an acyclic one—has not received
much attention. We call this the space of semantically acyclic UCQs. Two questions
naturally arise in this context:

1. Is the evaluation problem for semantically acyclic UCQs still tractable?
2. What is the cost of verifying whether a UCQ is semantically acyclic?

Answers to these questions can be found by applying known techniques in the area
of constraint satisfaction problems (CSP). This is based on the fact that CQ evalua-

∗

Received by the editors August 12, 2015; accepted for publication (in revised form) May 4, 2016;

published electronically August 2, 2016. This paper is the full version of the conference article [7].

†

http://www.siam.org/journals/sicomp/45-4/M103471.html
Center for Semantic Web Research & Department of Computer Science, University of Chile,
Santiago, Chile (pbarcelo@dcc.uchile.cl, mromero@dcc.uchile.cl). These authors were funded by the
Millennium Nucleus Center for Semantic Web Research under grant NC120004. The second author
was also funded by a CONICYT Ph.D. Scholarship.

Department of Computer Science, Rice University, Houston, TX 77251 (vardi@cs.rice.edu).

1339

‡

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1340

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

tion and CSP have a common root—they are both equivalent to the homomorphism
problem [33]. CSP techniques establish the following:

1. Semantically acyclic UCQs can be evaluated in polynomial time.
2. Verifying whether a UCQ is semantically acyclic is NP-complete [14, 17].
In this paper we extend the concept of semantic acyclicity from the classical
setting of relational databases to the newer setting of graph databases [2], which
has been the focus of much research in the last few years [4, 19, 20, 5, 22].
In
fact, acyclicity has been identiﬁed as a fundamental tool for obtaining tractable—
and even linear time—query evaluation in such a context [28, 4, 5, 35].
It is thus
of theoretical importance to understand what is the space of queries deﬁned by the
notion of acyclicity over graph databases.

Graph databases are typically modeled as edge-labeled directed graphs. In this
context, query languages are navigational, in the sense that they allow one to recursively 
traverse the edges of the graph while checking for some regular condition
[16, 1, 10, 43, 3]. Navigation is often performed by traversing edges in both directions,
which allows one to express important properties about the inverse of the relations
deﬁned by the labels of those edges [9, 10]. When this is combined with the expressive
power of CQs, it yields a powerful class of queries—the so-called conjunctive regular
path queries with inverse, or C2RPQs—that lies at the core of many query languages
for graph databases (see, e.g., [16, 15, 9, 4]).

Evaluation of unions of C2RPQs (UC2RPQs) is not more expensive than evaluation 
of CQs, i.e., NP-complete. Recent works have studied the class of acyclic
UC2RPQs—where acyclicity is deﬁned in terms of the underlying CQ of each element
of the union—and proved that queries in this class preserve the good properties of
acyclic UCQs for evaluation, i.e., they can be evaluated in polynomial time, and even
linearly for suitable restrictions [4, 5].

In this work we study the notion of semantic acyclicity for UC2RPQs, that is, we
study the class of UC2RPQs that are equivalent to an acyclic one, and try to answer
the same questions that we posed before for the class of semantically acyclic UCQs:

1. What is the cost of evaluating queries in this class?
2. How hard is it to recognize whether a UC2RPQ Γ is semantically acyclic,
and, if so, what is the cost of computing an equivalent acyclic UC2RPQ for
Γ?

The ﬁrst question is important since we want to understand whether semantic acyclicity 
leads to larger classes of UC2RPQs with good evaluation properties. The second
question is relevant for static optimization, as a positive answer would allow us to construct 
an equivalent query in a well-behaved fragment for each semantically acyclic
UC2RPQ. We present answers to both questions in the paper, in a way that our
answer to the ﬁrst question crucially depends on our answer to the second one.

As mentioned before, the evaluation problem for semantically acyclic UCQs is
tractable, and this is proved by applying known techniques from CSP. Those techniques 
are speciﬁcally tailored for checking the existence of a homomorphism from a
relational structure into another one, which ﬁts the semantics of CQs well. On the
other hand, the semantics of C2RPQs is based on a richer notion of homomorphism,
which maps the atoms of a query into pairs of nodes in a graph database linked by a
path satisfying some regular condition. Such a notion of homomorphism does not ﬁt
well in the current landscape of CSP techniques, and, in fact, CSP theory does not
yield answers to our questions about semantically acyclic UC2RPQs.

Example 1. To illustrate the usefulness of semantic acyclicity, consider an alphaCopyright 
© by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1341

p

f +

p

f +

f +

f +

f +

p

f +

p

p

p

p

p

f +

f +

f +

Fig. 1.1. The query from Example 1 and its equivalent acyclic query.

bet {p, f} modeling social networks. Labels p and f stand for “person” and “friend”,
respectively. An object in a graph database is a person if it has an outgoing p-labeled
edge (e.g., to its id). Two persons are friends if there is an f -labeled edge between
them. Suppose we want to know whether there is a group of persons of size n ≥ 2
in the graph database G that forms a clique. This means that there is an f -labeled
edge between each pair of persons in the group. Evaluating this query basically corresponds 
to the well-known clique problem, which is NP-complete. Typical algorithms
for this problem take |G|O(n) time.

On the other hand, in the context of graph databases it is sometimes more interesting 
knowing whether two persons are linked by a path labeled in the friendship
relationship than in checking whether they are actual friends. This means that there
is a sequence of mutual friends that connects these two persons, or, more formally,
that there is a path between them labeled by the regular expression f +. Our clique
query can thus also be relaxed by using this condition. The left-hand side ﬁgure in
Figure 1.1 depicts the result for n = 4 (dots represent variables and arrows represent
labeled atoms). Notice that this query is nonacyclic, and by applying standard algorithms 
we can still evaluate it in |G|O(n) time. However, it is not hard to prove that
the query is semantically acyclic. Indeed, it is equivalent to a path of n persons that
are consecutively linked by paths of mutual friends. This query is depicted in the
right-hand side of Figure 1.1 (for n = 4 again). The existence of such a path can be
checked in time O(n · |G|2). Therefore, evaluating a semantically acyclic query via its
equivalent acyclic query can signiﬁcantly improve the running time.

(cid:4)

(cid:4)

is an approximation of a UCQ Θ if Θ

To attack our questions about evaluation of semantically acyclic UC2RPQs, we
consider ﬁrst the problem of UC2RPQ approximations, which is motivated by recent
work on approximations of UCQs [6]. Typical algorithms require |D|O(|θ|) time to
evaluate a CQ θ on a database D, which might be prohibitively expensive for a large
dataset D even if θ is small. This led the idea of ﬁnding approximations of (U)CQs
in tractable classes [6], in particular, in the class of acyclic (U)CQs. Intuitively, an
is contained in Θ and it is “as
acyclic UCQ Θ
is a
close as possible” to Θ in the class of acyclic UCQs. The latter means that Θ
maximal acyclic UCQ that is contained in Θ. It follows from techniques in [6] that
UCQs have good properties in terms of acyclic approximations: Each UCQ Θ has
a unique acyclic approximation (up to equivalence), and this approximation can be
computed in single-exponential time. These good properties imply that computing
and running the acyclic approximation of a UCQ Θ on a database D takes time
O(|D| · 2p(|Θ|)), for some polynomial p : N → N. This is much faster than |D|O(|Θ|) on
large databases. Thus, if the quality of the approximation is good, we may prefer to
run this faster query instead of Θ.

(cid:4)

We show here that the good properties of UCQs in terms of acyclic approximations 
extend to UC2RPQs. In particular, we show that each UC2RPQ Γ has a unique

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1342

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

acyclic approximation (up to equivalence) and that an approximation of exponential
size can be computed in Expspace. The data complexity of evaluating this approximation 
is then quadratic in the size of the data, just as the data complexity of 2RPQs.
This shows that acyclic approximations might be useful when evaluating whether the
original query is infeasible, though the cost of computing the approximation is quite
high. We also show that UC2RPQs behave provably worse than UCQs in terms of
is the approximation of the
approximations: Verifying whether an acyclic UCQ Θ
UCQ Θ is in the second-level of the polynomial hierarchy, but it becomes Expspacecomplete 
in the case of UC2RPQs. This is not surprising, as it is known that testing
containment of UC2RPQs is Expspace-complete [9].

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Finally, we apply the machinery of acyclic approximation of UC2RPQs to address
semantic acyclicity of this class of queries. As noted above, we can construct in
Expspace an exponential-sized acyclic approximation Γ
of a given UC2RPQ Γ. By
is contained in Γ. To check whether Γ is semantically acyclic we just
construction, Γ
have to check whether Γ is contained in Γ
is exponentially large, we
trivially get a 2Expspace upper bound for the complexity of this step. Surprisingly,
we show that this can actually be improved to Expspace. In order to prove this, we
show that checking containment of a UC2RPQ Γ1 in an acyclic UC2RPQ Γ2 can be
solved using exponential space but in such a way that the exponent only depends on
the width of Γ2, which is the maximum number of atoms in some disjunct of Γ2 that
mention the same pair of variables. As it turns out, this parameter is polynomial
in |Γ| for the acyclic approximation Γ
(cid:4)
. Thus, applying this reﬁned algorithm for
containment we can check whether Γ ⊆ Γ
(cid:4)
in Expspace. We also provide a matching
lower bound for this problem.

. Because Γ

This machinery allows us to get answers to the two questions we posed above:

1. First, query evaluation for semantically acyclic UC2RPQ is ﬁxed-parameter
tractable, when we consider the size of the query as the parameter. Recall
that this means that there exist a computable function f : N → N and a
constant k ≥ 1 such that evaluating a UC2RPQ Θ over a database D can be
done in time O(|D|k·f (|Θ|)). This shows that the class of semantically acyclic
UC2RPQs is well-behaved in terms of evaluation, as in general evaluation of
UC2RPQs (and even CQs) is not ﬁxed-parameter tractable [37] (under widely
held complexity theoretical assumptions).

2. Second, testing semantic acyclicity for UC2RPQs is Expspace-complete.

The question of whether semantically acyclic UC2RPQs can be evaluated in polynomial 
time is left as an interesting open problem.

Organization. The rest of the paper is organized as follows. In section 2, we
study semantic acyclicity for UCQs and show that the answers to the most basic questions 
follow from known CSP techniques. In section 3, we introduce graph databases
and UC2RPQs. Section 4 is devoted to presenting the main techniques and results
related to containment of UC2RPQs. In section 5, we study acyclic approximations
of UC2RPQs and show some of their good properties. Then in section 6, we study semantic 
acyclicity of UC2RPQs. We provide upper and lower bounds for the problem
of verifying whether a UC2RPQ is semantically acyclic and show that this implies
that evaluation of semantically acyclic UC2RPQs is ﬁxed-parameter tractable.
In
section 7 we provide concluding remarks and a list of open problems. Finally, the
appendix contains the proofs of some technical results in the paper.

2. Interlude on unions of CQs. We start by considering semantic acyclicity
in the context of traditional relational databases and unions of conjunctive queries.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1343

Although the results in this section follow from known techniques, we state them for
the sake of completeness and because they will help us develop the necessary intuitions
for the more complicated case of graph databases and unions of conjunctive regular
path queries.

2.1. Basic concepts. We ﬁrst provide the necessary terminology. A schema
is a set σ of relation names R1, . . . , R(cid:3), each relation Ri having an arity ni > 0. A
database of schema σ is a function D that maps each relation symbol Ri in σ into a
i ⊆ domni ).
D
ﬁnite ni-ary relation R
A conjunctive query (CQ) over σ is a logical formula in the ∃,∧-fragment of

D
i over a countably inﬁnite domain dom (i.e., R

ﬁrst-order logic, i.e., a formula of the form
θ(¯x) = ∃¯y

(2.1)

m(cid:2)

i=1

Pi(¯ui),

where each Pi is a symbol from σ and ¯ui is a tuple of variables among ¯x, ¯y whose
length is the arity of Pi. As usual, we assume that ¯x are the free variables of θ, i.e.,
the variables mentioned in θ that are not existentially quantiﬁed. Each Pi(¯ui) is an
atom of θ(¯x).
As customary, we deﬁne the semantics of CQs in terms of homomorphisms. Let
θ(¯x) be a CQ of the form (2.1) and let D be a database over schema σ. A homomorphism 
h from θ(¯x) to D is a mapping from the variables that appear in the atoms
of θ(¯x) to the elements of D such that Pi(h(¯ui)) ∈ D for each 1 ≤ i ≤ m. The
evaluation of θ over D, denoted by θ(D), is the set of all tuples of the form h(¯x), for h
a homomorphism from θ(¯x) to D. If θ is a Boolean query (i.e., ¯x is the empty tuple),
the answer true is, as usual, modeled by the set containing the empty tuple, and the
answer false by the empty set.

A union of conjunctive queries (UCQ) is a ﬁrst-order formula of the form

where θi(¯x) is a CQ for each 1 ≤ i ≤ m. Note that every disjunct in Θ(¯x) has the
same tuple of free variables, namely, ¯x. We deﬁne Θ(D) to be

(cid:4)
1≤i≤m θi(D).

As it is common in database theory [3, 25, 37, 41], we formalize query evaluation as
a decision problem. The evaluation problem for UCQs is as follows: Given a database
D, a UCQ Θ(¯x), and a tuple ¯a in D, is ¯a ∈ Θ(D)?

It is well known that the evaluation of CQs is NP-complete [12]. On the other
hand, tractability of (U)CQ evaluation can be obtained by restricting the syntactic
shape of CQs. The oldest and most common of such restrictions is α-acyclicity (or,
simply, acyclicity) [18], that can be deﬁned in terms of the existence of a well-behaved
tree decomposition of the hypergraph of a CQ [26]. We review such notions below.
Recall that a hypergraph is a tuple H = (V, E), where V is its ﬁnite set of vertices
and E ⊆ 2V is its set of hyperedges. With each CQ θ we associate its hypergraph
H(θ) = (V, E) such that V is the set of variables of θ and E consists of all sets of
variables that appear in the same atom of θ. Consider, for instance, the CQ

θ(x) = ∃y∃z∃u∃v

(cid:5)
(cid:6)
R(x, y, z) ∧ T (y, u, u) ∧ S(y, v)

.

Then H(θ) = (V, E), where V = {x, y, z, u, v} and E consists of the hyperedges
{x, y, z}, {y, u}, and {y, v}.
A tree decomposition of a hypergraph H = (V, E) is a pair (T, λ), where T is a

tree and λ is a mapping from the nodes of T to 2V , that satisﬁes the following:

(cid:3)
1≤i≤m

Θ(¯x) =

θi(¯x),

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1344

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

• For each v ∈ V the set {t ∈ T | v ∈ λ(t)} is a connected subset of T .
• Each hyperedge in E is contained in one of the sets λ(t), for t ∈ T .

Then H is acyclic if there is a tree decomposition (T, λ) of it such that λ(t) is a
hyperedge in E, for each t ∈ T .
acyclic if each θi(¯x) is acyclic (1 ≤ i ≤ m). For instance, the CQ

A CQ θ is acyclic if its hypergraph H(θ) is acyclic. A UCQ

(cid:7)
1≤i≤m θi(¯x) is

θ(x) = ∃y∃z∃u∃v R(x, y, z) ∧ T (y, u, u) ∧ S(y, v)

presented above is acyclic, as witnessed by the following tree decomposition (T, λ) of
H(θ): T consists of vertices {1, 2, 3} and edges {(1, 2), (1, 3)}, and λ(1) = {x, y, z},
λ(2) = {y, u}, and λ(3) = {y, v}.

It follows from the seminal work of Yannakakis that acyclic UCQs have good

properties in terms of evaluation.

Proposition 2.1 (see [44]). The evaluation problem for acyclic UCQs can be

solved in linear time O(|D| · |Θ|).

2.2. Semantically acyclic UCQs. Acyclicity is a syntactic property of UCQs.
On the other hand, a nonacyclic UCQ can still be equivalent to an acyclic one. For-
(¯x) such
mally, a UCQ Θ(¯x) is semantically acyclic if there exists an acyclic UCQ Θ
(D) for each database D. Recall that we are interested in two questhat 
Θ(D) = Θ
tions regarding semantic acyclicity:

(cid:4)

(cid:4)

1. Is the evaluation problem for semantically acyclic UCQs tractable?
2. What is the cost of verifying semantic acyclicity for UCQs?

As pointed out in [33], there is a close connection between CQ evaluation and
constraint satisfaction: Both can be recast as the problem of determining whether
there is a homomorphism from one relational structure into another one. This tight
connection allows us to export tools from CSP [33, 14] and prove that semantically
acyclic UCQs can be evaluated in polynomial time.

Theorem 2.2. The evaluation problem for semantically acyclic UCQs can be

solved in polynomial time.

The CSP techniques that imply Theorem 2.2 ﬁrst establish a sophisticated equivalence 
between the problems of query evaluation for semantically acyclic CQs and
the existence of winning strategies for the duplicator in some reﬁned version of the
existential pebble game, and then prove that the required condition on games can
be checked eﬃciently. Since the proof of Theorem 2.2 is not essential to our main
argumentation line we relegate it to the appendix.

Notice that the class of acyclic UCQs is remarkably well behaved for evaluation:
Queries in the class are not only tractable, but also verifying whether a given UCQ
belongs to the class can be done in polynomial (in fact, linear) time [40]. On the other
hand, using techniques similar to those in [17], one can prove that this good behavior
does not extend to the class of semantically acyclic UCQs, as the problem of verifying
whether a query is semantically acyclic is computationally hard (again, we relegate
the proof of this fact to the appendix).

Proposition 2.3. The problem of verifying whether a UCQ Θ(¯x) is semantically
acyclic is NP-complete.
It remains NP-hard even when the input is restricted to
Boolean CQs whose schema consists of a single binary relation (i.e., directed graphs).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1345

3. Graph databases and conjunctive regular path queries.

3.1. Graph databases and C2RPQs. A graph database [2, 10, 16] is just a
ﬁnite edge-labeled graph. Let Σ be a ﬁnite alphabet, and let N be a countably inﬁnite
set of node ids. Then a graph database over Σ is a pair G = (N, E), where N is the
set of nodes (a ﬁnite subset of N ), and E is the set of edges, i.e., E ⊆ N × Σ × N .
That is, we view each edge as a triple (n, a, n
), whose interpretation, of course, is an
a-labeled edge from n to n
. When Σ is clear from the context, we shall simply speak
of a graph database.

(cid:4)

(cid:4)

−

for each a ∈ Σ. Intuitively, a

As mentioned before, in this work we consider navigational queries that traverse
edges in both directions. The building block of these languages is the class of regular
path queries with inverse, or 2RPQs [9, 10]. A 2RPQ over ﬁnite alphabet Σ is a
that extends Σ with
nondeterministic ﬁnite automaton (NFA) over the alphabet Σ
the symbol a
Intuitively, the evaluation of a 2RPQ A without inverses over a graph database
G consists of all those pairs (n, n
can be reached from
n in G by following a path whose label is accepted by A. In order to accommodate
of G, which is the
inverses one interprets A not over G but over the completion G±
, n), for
graph database over Σ
each edge (n, a, n
in G is a sequence

Let G = (N, E) be a graph database. A path ρ from node n to n

that is obtained from G by adding the edge (n

) ∈ E. We formalize this below.

) of nodes in G such that n

represents the inverse of a.

, a

±

(cid:4)

−

±

(cid:4)

−

(cid:4)

(cid:4)

(cid:4)

ρ = n0a1n1a2n2 . . . nk−1aknk,

such that each ui and vi is a variable among ¯x, ¯y and each Ai is a 2RPQ over Σ, for
1 ≤ i ≤ m. A CRPQ is a C2RPQ without inverses, i.e., a C2RPQ of the form (3.1) in
which each Ai (1 ≤ i ≤ m) is an NFA over Σ. As usual, we assume that ¯x are the free
variables of γ, i.e., the variables mentioned in γ that are not existentially quantiﬁed.
Each (ui,Ai, vi) is an atom of γ.

We formally deﬁne the semantics of C2RPQs by using a notion of homomorphism
that maps atoms of γ into pairs that satisfy the corresponding 2RPQs. Given γ(¯x) of
(cid:4)
the form (3.1) and a graph database G = (N, E), a homomorphism from γ(¯x) to G is
1≤i≤m{ui, vi} → N such that (h(ui), h(vi)) ∈ Ai(G) for every 1 ≤ i ≤ m.
a map h :
We then deﬁne the evaluation γ(G) of γ over G to be the set of all tuples h(¯x) such
that h is a homomorphism from γ(¯x) to G.

(cid:4)

∗

where k ≥ 0, n0 = n, nk = n
, and for each 1 ≤ i ≤ k it is the case that (ni−1, ai, ni)
is an edge in E. Notice that when k = 0 this path consists of the single node n0. The
label of ρ, denoted by label(ρ), is the word a1a2 . . . ak ∈ Σ
. The evaluation A(G) of
the 2RPQ A over the graph database G is the set of all pairs (n, n
) ∈ N × N such
that there is a path ρ in G±
for which it is the case that the word label(ρ)
is accepted by A.
A folklore result (see, e.g., [3]) establishes that the problem of computing A(G), for
a given graph database G and 2RPQ A, can be solved in polynomial time O(|G|2·|A|).
When the expressive power of 2RPQs is combined with the ability of CQs to
express arbitrary joins and existential quantiﬁcation, it yields a powerful class of
queries—namely, the conjunctive regular path queries with inverses, or C2RPQs [9]—
that we deﬁne next.

from n to n

(cid:4)

(cid:4)

Formally, a C2RPQ over a ﬁnite alphabet Σ is an expression of the form

(3.1)

γ(¯x) = ∃¯y

(ui,Ai, vi),

(cid:2)
1≤i≤m

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1346

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

A union of C2RPQs (UC2RPQ) is a formula of the form

(cid:3)
1≤i≤m

Γ(¯x) =

γi(¯x),

(cid:4)
where each γi(¯x) is a C2RPQ (1 ≤ i ≤ m). We deﬁne Γ(G) as
1≤i≤m γi(G), for each
graph database G. As before, the UC2RPQ Γ is Boolean if ¯x is the empty tuple. In
such a case the evaluation of Γ over G corresponds to either true or false.

Remark. While we use NFAs in order to specify regular languages in UC2RPQs, it
is sometimes more convenient (especially in practice) to specify such languages using
regular expressions. In fact, this is the approach often followed in the graph database
literature (see, e.g., [3, 43]). Each regular expression can be easily translated into an
NFA in polynomial time, and, therefore, all the evaluation upper bounds obtained
in the paper continue to hold in the case when UC2RPQs are speciﬁed using regular
expressions. The reason why we use NFA instead is that they allow one to express
regular languages more succinctly than the latter (which is crucial for some of our
results). For the sake of readability though, all the examples we present in the paper
are speciﬁed using regular expressions.
Example 2. Consider a graph database G = (N, E) of researchers, papers, conferences,
 and journals over the alphabet Σ = {creator, inJournal, inConf}. The set of
edges E consists of the following:
• All tuples (r, creator, p) such that r is a researcher that (co-)authors paper p.
• Each tuple (p, inJournal, j) such that paper p appeared in journal j.
• All tuples (p, inConf, c) such that paper p was published in conference c.
Consider the C2RPQ γ(x, y) deﬁned as

(cid:5)
(x, creator, z) ∧ (z, inConf, w) ∧ (z, creator−

∃z∃w

(cid:6)

, y)

.

Its evaluation γ(G) over the graph database G consists of the set of pairs (r, r
that researchers r and r

have a joint conference paper.

(cid:4)

The evaluation over G of the C2RPQ γ

(cid:4)

(cid:5)
(x, (creator · creator−

(x, y) deﬁned as

(cid:6)
, y) ∧ (y, creator, z) ∧ (z, inJournal, w)

∗
)

∃z∃w

(cid:4)

) such

(cid:4)

(cid:4)

(cid:4)

(cid:4)

If Γ and Γ

(cid:4)

, if Γ ⊆ Γ

(cid:4)

has at least one journal paper.

are UC2RPQs, then Γ is contained in Γ

) of researchers that are linked by a co-authorhsip

(G) for each graph database G.

consists of the set of pairs (r, r
sequence and such that r
Γ(G) ⊆ Γ
denoted by Γ ≡ Γ
graph database G.
The evaluation problem for UC 2RPQs is deﬁned in the same way as for UCQs;
i.e., this is the problem of checking whether ¯n belong to Γ(G), given a UC2RPQ Γ(¯x),
a graph database G, and a tuple ¯n of nodes in G such that |¯n| = |¯x|. It is folklore that
evaluating UC2RPQs is not more expensive than evaluating CQs, i.e., NP-complete
(see, e.g., [4, 3]).

(cid:4) ⊆ Γ, or, equivalently, Γ(G) = Γ

, if
are equivalent,
(G) for each

, denoted by Γ ⊆ Γ

(cid:4)

In addition, Γ and Γ

and Γ

(cid:4)

(cid:4)

(cid:4)

Acyclic UC2RPQs. Acyclicity of C2RPQs has been studied in several recent
papers that deﬁne it in terms of the acyclicity of its underlying conjunctive query
[4, 5]. Let γ(¯x) = ∃¯y
over the schema of binary relation symbols T1, . . . , Tm deﬁned as ∃¯y

(cid:8)
(cid:8)
1≤i≤m(ui,Ai, vi) be a C2RPQ. Its underlying CQ is the query
1≤i≤m Ti(ui, vi).

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1347

Intuitively, this underlying conjunctive query represents the structure of γ when the
regular languages that label the atoms of γ are turned into relation symbols.

A C2RPQ is acyclic if its underlying CQ is acyclic. A UC2RPQ is acyclic if each
one of its C2RPQs is acyclic. By combining techniques for UC2RPQ evaluation and
polynomial time evaluation of acyclic CQs, it is possible to prove that the evaluation
problem for acyclic UC2RPQs can be solved in polynomial time [44, 4]. We present
the simple proof of this fact for the sake of completeness.

Theorem 3.1. The evaluation problem for acyclic UC 2RPQs can be solved in

time O(|G|2 · |Γ|2).

Proof. Let G be a graph database, and let Γ be a UC2RPQ. Let us denote by Θ
the UCQ that is obtained from Γ by replacing each C2RPQ γ in Γ by its underlying
CQ. Let T1(u1, v1), . . . , Tn(un, vn) be an enumeration of all the relational atoms in
Θ, and assume that for each i with 1 ≤ i ≤ n the atom Ti(ui, vi) is introduced in Θ
as a replacement for the 2RPQ (ui,Ai, vi). Further, let D be a relational database
over schema {T1, . . . , Tn} such that the interpretation of the binary relation symbol
Ti over D, for each 1 ≤ i ≤ n, is precisely Ai(G). Notice that D can be constructed
in time O(|G|2 ·|Γ|) from G and Γ, using the aforementioned fact that each Ai(G) can
be computed in time O(|G|2 · |Ai|) and |A1| + ··· + |An| is O(|Γ|).
It is clear then that checking whether a tuple ¯n of nodes in G belongs to Γ(G)
reduces to checking whether ¯n ∈ Θ(D). Since Θ is acyclic, it follows from Proposition
2.1 that the latter can be done in time O(|D| · |Θ|), that is, in time O(|G|2 · |Γ|2).

Recall that a CQ θ is acyclic if its hypergraph H(θ) admits a tree decomposition
(T, λ) such that each set of the form λ(t), for t ∈ T , is a hyperdge of H(θ). The fact
that acyclicity of C2RPQs is deﬁned in terms of the acyclicity of its underlying CQ—
and the latter is speciﬁed in a schema of binary arity—allows us to provide a simple
characterization of the class of acyclic C2RPQs that will be useful in our proofs. We
(cid:8)
explain this below.
1≤i≤m(ui,Ai, vi),
which is denoted by U(γ), is the graph whose vertices are the variables of γ and its
set of edges is {{ui, vi} | 1 ≤ i ≤ m and ui (cid:10)= vi}. Notice that U(γ) is indeed simple
(it contains neither loops nor multiedges) and undirected. The following self-evident
proposition provides a simple reformulation of the notion of acyclicity of C2RPQs in
terms of the acyclicity of their simple undirected underlying graph.

The simple undirected underlying graph of C2RPQ γ(¯x) = ∃¯y

Proposition 3.2. A C 2RPQ γ is acyclic if and only if U(γ) is acyclic.
(cid:6)
Example 3. Let us consider again the C2RPQ:

(x, creator, z) ∧ (z, inConf, w) ∧ (z, creator−

γ(x, y) = ∃z∃w

, y)

(cid:5)

in Example 2. The graph U(γ) consists of nodes x, z, w, y and edges {x, z}, {z, w},
and {z, y}. Clearly, U(γ) is acyclic, and, therefore, γ(x, y) is acyclic. Similarly, it can
be proved that the C2RPQ γ

(x, y) in Example 2 is acyclic.

(cid:4)

Notice that this deﬁnition of acyclicity allows for the existence of loops and multiedges 
in the structure of a C2RPQ, that is, in its underlying CQ, as shown in the
following example.

CRPQs γ = ∃x(x, L1, x) and γ

Example 4. Let L1, L2, and L3 be arbitrary regular expressions over Σ. The
are acyclic. Notice that
contains edges

the underlying CQ of γ contains a loop, while the underlying CQ of γ

= ∃x∃y

(cid:4)

(cid:4)

(cid:5)

(cid:6)
(x, L1, y)∧(y, L2, x)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1348

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI
= ∃x∃y∃z

from x to y and from y to x. On the other hand, the CRPQ γ

(cid:4)(cid:4)

(cid:5)
(x, L1, y)∧

(cid:6)
(y, L2, z) ∧ (z, L3, x)

is not acyclic.

Our goal is to study the notion of semantic acyclicity for UC2RPQs. To attack the
problem of evaluation for UC2RPQs that are semantically acyclic we make a necessary
detour in the next section to study the containment problem for UC2RPQs, and then
in section 5 to study approximations of UC2RPQs.

(cid:4)

4. Containment of UC2RPQs. To prove our results, it is essential having
a good understanding of the machinery used to study the containment problem for
UC2RPQs. We develop such machinery in this section.
Calvanese et al. proved that the containment problem for C2RPQs is in Expspace
[9]. More speciﬁcally, it follows from [9] that checking whether γ ⊆ γ
, when γ
and γ
are C2RPQs, can be solved using exponential space in such a way that the
exponent only depends on |γ
(cid:4)| and the number of variables in γ. For a UC2RPQ Γ,
we deﬁne maxvar(Γ) to be the maximum number of variables over all disjuncts of Γ.
A straightforward extension of the techniques in [9] shows that containment of Γ in
(cid:4)
are UC2RPQs, can also be solved in exponential space, but now
, when Γ and Γ
Γ
(cid:4)| and maxvar(Γ). It is also shown in [9] that the
the exponent depends only on |Γ
containment problem for C2RPQs is Expspace-hard even when both γ and γ
are
acyclic CRPQs [9]. In summary, we have the following proposition.

(cid:4)

(cid:4)

(cid:4)

Proposition 4.1. The following hold:
1. Checking whether Γ ⊆ Γ
2. The problem of checking whether γ ⊆ γ

nential space where the exponent only depends on |Γ

, for UC 2RPQs Γ and Γ

(cid:4)

(cid:4)

(cid:4)

(cid:4)

, can be solved using expo-
(cid:4)| and maxvar(Γ).

(cid:4)

, for C 2RPQs γ and γ

, is Expspacehard.
 It remains hard even if both γ and γ

are acyclic CRPQs.

(cid:4)
When Γ
(cid:4)

(cid:4)

(cid:4)

, speciﬁcally, on the width of Γ

is an acyclic UC2RPQ it is possible to show that the containment of Γ
in Γ
can be checked in exponential space, but where the exponent only depends on
(deﬁned below). This result will be crucial to later
Γ
prove in section 6 that the problem of checking whether a UC2RPQ is semantically
acyclic (i.e., equivalent to an acyclic UC2RPQ) is in Expspace.
Let γ be a C2RPQ over Σ. For two distinct variables x, y in γ we deﬁne Atoms(x, y)
to be the set of atoms in γ that are of the form (x,A, y) or (y,A, x), where A is an
NFA over Σ

. The width w(γ) of γ is deﬁned as follows:

±

w(γ) = max{ |Atoms(x, y)| | x, y are distinct variables appearing in γ}.

If Γ = γ1 ∨ ··· ∨ γm is a UC2RPQ, then the width of Γ is w(Γ) = max{w(γi) | 1 ≤
i ≤ m}. We devote the rest of this section to proving the following theorem.
Theorem 4.2. Containment of a UC 2RPQ Γ in an acyclic UC 2RPQ Γ
)) space, for some constant C ≥ 1.
solved in deterministic O((|Γ| + |Γ

(cid:4)|)C·w(Γ

can be

(cid:4)

(cid:2)

The proof exploits automata techniques as in [9, 11, 38]. It follows from [38] that
checking containment of two UC2RPQs can be reduced to checking containment of a
Boolean single-atom C2RPQ (i.e., a C2RPQ of the form ∃x∃y(x,A, y), for A an NFA)
in a Boolean UC2RPQ (Boolean single-atoms C2RPQs are called Boolean 2RPQs in
(cid:4) ≥ 1 and a polynomial time
[38]). In particular, it is shown that there are integers c, c
algorithm that, given UC2RPQs Γ and Γ
, constructs a Boolean single-atom C2RPQ
˜E and a Boolean UC2RPQ ˜Γ such that the following hold:

(cid:4)

(cid:4)

1. Γ ⊆ Γ
2. | ˜E| = O(|Γ|c) and |˜Γ| = O((|Γ| + |Γ

if and only if ˜E ⊆ ˜Γ,

(cid:4)|)c(cid:2)

),

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1349

(cid:4)
3. w(Γ
(cid:4)
4. if Γ

) = w(˜Γ), and
is acyclic, then ˜Γ also is.

Our proof is based on the following lemma.

Lemma 4.3. There are integers d, d

(cid:4) ≥ 1 such that the problem of checking concan 
be solved

(cid:4)

tainment of a Boolean single-atom C 2RPQ Γ in an acyclic UC 2RPQ Γ
in deterministic O(|Γ

) · |Γ|d(cid:2)

(cid:4)|d·w(Γ

) space.

(cid:2)

Lemma 4.3 directly implies Theorem 4.2. Indeed, in order to check containment
(cid:4)
we ﬁrst construct the single-atom C2RPQ
of a UC2RPQ Γ in an acyclic UC2RPQ Γ
˜E and the acyclic UC2RPQ ˜Γ, and then apply the algorithm from Lemma 4.3. The
space used is

which is O((|Γ| + |Γ

O(|˜Γ|d·w(˜Γ)| ˜E|d(cid:2)
(cid:4)|)Cw(Γ

(cid:2)

)), for C ≥ c

(cid:4)

(cid:4)
d + cd

.

) = O((|Γ| + |Γ

(cid:4)|)c(cid:2)d·w(Γ

(cid:2)

)|Γ|cd(cid:2)

),

Before proving Lemma 4.3 we make a necessary detour through the notions of
canonical graph database and foldings, which are important components of several
containment algorithms for UC2RPQs and its extensions [23, 9, 38].

4.1. Canonical databases and foldings. A semipath is a graph database
whose underlying graph is a path. Formally, the graph database G = (N, E) over
Σ is a semipath if N = {n0, . . . , nk}, E = {e1, . . . , ek}, and for each 1 ≤ i ≤ k it is
the case that ei is of the form (ni−1, ai, ni) or (ni, ai, ni−1) (for ai ∈ Σ). The internal
nodes of G are {n1, . . . , nk−1}. If k = 0, we call G the empty semipath.
of the semipath G contains a single path ρ from n0
to nk. The label of ρ is b1b2 . . . bk, where for each 1 ≤ i ≤ k it is the case that bi = ai,
−
if ei is of the form (ni−1, ai, ni), and bi = a
i , otherwise. We slightly abuse notation
and write label(G) in order to denote label(ρ) whenever G is a semipath. Notice that
if G is an empty semipath, then label(G) = ε.

Notice that the completion G±

Containment of UC2RPQs can be recast in terms of the notion of canonical
database [23, 9], which we describe below. Let γ(¯x) be a C2RPQ of the form γ(¯x) =
∃¯y
ν from the variables of γ to the nodes of G such that the following hold:

(cid:8)
1≤i≤m(ui,Ai, vi). A graph database G is canonical for γ if there exists a mapping
1. G consists of m semipaths, one for each conjunct of γ. Formally, for each
1 ≤ i ≤ m there is a semipath κi in G from ν(ui) to ν(vi). These semipaths
are node and edge disjoint, save for the start and end nodes that can be
shared between diﬀerent κi’s. For example, if ui = vj , for 1 ≤ i, j ≤ m, then
ν(ui) = ν(vj ) and, thus, the start node of κi coincides with the end node of
κj.

2. For each 1 ≤ i ≤ m it is the case that label(κi) is accepted by Ai.
3. For every two distinct variables z and z

) if
and only if there is a sequence z0, z1, . . . , z(cid:3) of variables in γ such that z0 = z,
and for each 1 ≤ j ≤ (cid:11) there is an 1 ≤ i ≤ m such that (i) the atom
z(cid:3) = z
(ui,Ai, vi) in γ corresponds to either (zj−1,Ai, zj) or (zj,Ai, zj−1), and (ii)

in γ it is the case that ν(z) = ν(z

(cid:4)

(cid:4)

(cid:4)

κi is an empty semipath.

We say that mapping ν is associated with the canonical database G.
The intuition is that a canonical database G is obtained from γ(¯x) as follows. We
view each variable in γ as a node in G. For each atom (ui,Ai, vi) in γ, we add to G a
semipath κi from ui to vi with fresh internal nodes that is accepted by Ai. We then
identify nodes ui and vi each time κi is chosen as an empty semipath. Condition 3.
in the deﬁnition of canonical database ensures that the identiﬁcation of nodes only
occurs due to those empty paths.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1350

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

(cid:4)

(cid:4)

(cid:4)

(cid:4)

, for UC2RPQs Γ and Γ

Proposition 4.4. Let Γ(¯x) and Γ

can be found in the set of canonical databases for Γ.

A canonical database for a UC2RPQ Γ(¯x) is a canonical database for some disjunct 
of Γ(¯x). A slight extension of the techniques used in [9] yields the following
proposition, which states that if Γ (cid:10)⊆ Γ
, then a counterexample 
to Γ ⊆ Γ
if and
only if for each canonical database G for Γ with associated mapping ν, it is the case
(G).1
that ν(¯x) ∈ Γ
the alphabet Σ ∪ {a
denotes
for a ∈ Σ, then p
−
−
a
. On the other hand, if p = a
denotes a. Let s = s1 . . . sk
±
and t = t1 . . . t(cid:3) be words over Σ
. We say that t folds into s [10] from j1 to j2, for
j1, j2 ∈ {0, . . . , k}, if there is a sequence i0, . . . , i(cid:3) of positions in the set {0, . . . , k}

We now deﬁne foldings. Let Σ be a ﬁnite alphabet. Recall that we denote by Σ

(¯x) be two UC 2RPQs. Then Γ ⊆ Γ

and p = a for some a ∈ Σ, then p

− | a ∈ Σ}. If p ∈ Σ

±

±

−

−

(cid:4)

(cid:4)

such that the following hold:

• i0 = j1 and i(cid:3) = j2.
• For each 1 ≤ j ≤ (cid:11), it is the case that ij = ij−1+1 and tj = sij , or ij = ij−1−1

and tj = s

−
ij−1 .

Intuitively, t folds into s if t can be read in s by a two-way automaton that outputs
, each time p is read
c from 0 to 5.

symbol p, each time p is read from left-to-right, and symbol p
from right-to-left. For instance, the word abb

c folds into abb

abb

−

−

−

−

−

a

4.2. Proof of Lemma 4.3. We need to introduce some concepts from automata
theory. Recall that two-way alternating automata generalize NFAs with the ability
to move on the input word in both directions, and with the possibility to perform
universal or existential moves (actually a combination of both). We deﬁne them
following [11]. Given a set X, let B(X) be the set of positive Boolean formulae over
X, built inductively by applying ∧ and ∨ starting from true, false, and elements of
X. For a set Y ⊆ X and a formula ϕ ∈ B(X), we say that Y satisﬁes ϕ if and only
if assigning true to the elements in Y and false to those in X \ Y makes ϕ true. A
two-way alternating ﬁnite automaton (2AFA) is a tuple A = (Σ, Q, δ, Q0, F ), where
Σ is a ﬁnite alphabet, Q is a ﬁnite set of states, Q0 ⊆ Q is the set of initial states,
F ⊆ Q is the set of ﬁnal states, and δ : Q × Σ → B({−1, 0, 1} × Q) is the transition
function. Intuitively, a transition δ(q, a) spawns several copies of A, each one starting
in a certain state and with the head on the symbol to the left of a (−1), to the right
of a (1), or on a itself (0), and speciﬁes by means of a positive Boolean formula how
to combine acceptance or nonacceptance of the spawned copies.
A run of A on a word w = a0 . . . a(cid:3)−1, for (cid:11) ≥ 0, is a pair (T, λ), where T is a
ﬁnite rooted tree and λ is a labeling of the nodes of T by elements in Q × {0, . . . , (cid:11)}
such that the following hold:

1. λ(r) = (q0, 0), for some q0 ∈ Q0, where r is the root of T .
2. For each node u in T with λ(u) = (q, i) and δ(q, ai) = ϕ, where q ∈ Q,
0 ≤ i ≤ (cid:11) − 1, and ϕ ∈ B({−1, 0, 1} × Q), there is a (possible empty) set
X = {(d1, q1), . . . , (dn, qn)} ⊆ {−1, 0, 1} × Q such that (i) X satisﬁes ϕ, and
(ii) for all j ∈ {1, . . . , n} there is a child of u in T labeled (qi, i + dj ).

The run is accepting if for each leaf u of T it is the case that λ(u) is of the form
(q, (cid:11)), for q ∈ F . The 2AFA A accepts w if it has an accepting run on it. It is known

1The original deﬁnition of canonical database in [9] only considers conditions 1. and 2. Condition
3. is innocuous in terms of the characterization of containment we provide here (i.e., Proposition 4.4
continues to hold if we remove such condition). As we shall see, on the other hand, condition 3. is
important for our proof.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpwhere TΓ(cid:2) is the set
{(A, q, q

(cid:4)

Then Δ := Σ

) | A is an NFA mentioned in some atom of Γ

(cid:4)
± ∪ Loops. Note that the size of Δ is bounded by O(2

and q, q

(cid:4)

are states of A}.
|Γ

(cid:2)|2

Let us start by deﬁning the NFA Acd as the product of the following two NFAs:
1. Aformat, which accepts all words over Δ satisfying the regular expression

).

.

(Here we are slightly abusing notation by writing
for the regular expression that represents the union of all

± · Loops)
∗

Loops · (Σ
Loops and Σ
symbols in Loops and Σ

±

±

SEMANTIC ACYCLICITY ON GRAPH DATABASES

1351

that 2AFAs deﬁne regular languages [34]. The following fact was shown in [11].
states that accepts precisely those words which are not accepted by A.

Lemma 4.5. Given a 2AFA A with n states, one can construct an NFA with 2O(n)

We now start with the proof of the lemma. Given a Boolean single-atom C2RPQ

over Σ, we deﬁne an NFA AΓ,Γ(cid:2) (over an extended
(cid:4)
Γ and an acyclic UC2RPQ Γ
alphabet) such that Γ (cid:10)⊆ Γ
if and only if the language accepted by AΓ,Γ(cid:2)
(cid:4)
is not
empty. Assume that Γ is of the form ∃x∃y(x,AΓ, y), where AΓ is an NFA over Σ
±
.
The deﬁnition of AΓ,Γ(cid:2) is based on NFAs Acd and Aloops, and on a 2AFA AΓ(cid:2) , all of
TΓ(cid:2) ,

All these automata are deﬁned over a suitable alphabet Δ. Let Loops be 2

which are introduced below.

, respectively).

±

±

word in Σ

accepted by AΓ.

2. Aacc, which accepts all words a1 . . . am over Δ such that a2a4 . . . a2(cid:6)m/2(cid:7) is a
It is easy to see that the number of states of Acd can be bounded by O(|Γ|).
Since Γ is a single-atom C2RPQ, it is the case that if G is a canonical database
of Γ with associated mapping ν, then G is simply a semipath from ν(x) to ν(y)
such that label(G) is accepted by AΓ. Thus we can naturally associate the canonical
databases of Γ with the words accepted by AΓ. The NFA Acd then accepts all the
(labels of) canonical databases of Γ “adorned” with some additional information from
Loops. More formally, Acd accepts words of the form L0a1L1 . . . Lm−1amLm, where
Li ∈ Loops and ai ∈ Σ
for each 0 ≤ i ≤ m, such that (i) a1a2 . . . am is the label
of some canonical database of Γ, and (ii) L0L1 . . . Lm represents an “adornment” of
a1a2 . . . am over Loops.
Let us now deﬁne the NFA Aloops over alphabet Δ. This NFA will help us restrict
the possible adornments of the words L0a1L1 . . . Lm−1amLm accepted by Acd in such
a way that the following holds for each 0 ≤ i ≤ m:

(†) (A, q, q
If the word L0a1L1 . . . Lm−1amLm satisﬁes (†) for each 0 ≤ i ≤ m, then we say
that it is correct. The NFA Aloops then satisﬁes that the intersection of Acd and
Aloops accepts precisely those words accepted by Acd which are correct. We explain
next how Aloops is deﬁned.
We start by deﬁning a function ξ : Loops × Loops → Loops as follows. Given
(L1, L2) ∈ Loops×Loops, the set ξ(L1, L2) contains exactly all those triples (A, q, q
) ∈
TΓ(cid:2) such that either (i) q = q

) belongs to Li if and only if there is a word w over Σ

A over w from state q to q

such that w folds into a1 . . . am from i to i.

, or (ii) there is a sequence

and a run of

±

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(A, q0, q1), (A, q1, q2), . . . , (A, qk−1, qk)

(cid:4)

for which (a) q0 = q, qk = q
(A, qj , qj+1) ∈ L1 ∪ L2, for each 0 ≤ j ≤ k − 1.
Loops and a ∈ Σ

and the states q0, . . . , qk are all distinct, and (b)
to Loops. Given L ∈
) ∈ TΓ(cid:2)

, the set ξ(cid:3)(L, a) contains exactly all those triples (A, q, q

We also deﬁne two functions ξ(cid:3) and ξr from Loops × Σ

±

±

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php−

We deﬁne ξr(L, a) analogously, but switching a for a

j ≤ k − 1 there is a run of A over aa
Consider a word a1 . . . am, where ai ∈ Σ
±
i ∈ Loops as follows:
we deﬁne sets T (cid:3)
i , T r
• The set T (cid:3)
i contains precisely those triples (A, q, q
and a run of A over w from state q to q
±
w over Σ
a1 . . . ai from i to i. If i = 0, then T (cid:3)
(A, q, q).
i
• The set T r
i contains precisely those triples (A, q, q
and a run of A over w from state q to q
±
w over Σ
ai+1 . . . am from 0 to 0. If i = m, then T r
form (A, q, q).
i

(cid:4)

(cid:4)

−

from q2j+1 to q2j+2.
for each 1 ≤ i ≤ m. For each 0 ≤ i ≤ m

, and vice versa.

) such that there is a word
such that w folds into
is just the set of all triples of the form

(cid:4)

) such that there is a word
such that w folds into
is just the set of all triples of the

(cid:4)

1352

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

such that either (i) q = q

(cid:4)

, or (ii) there is a sequence

(A, q0, q1), (A, q2, q3), . . . , (A, q2k, q2k+1),

where all the qi’s are distinct and the following hold:

-labeled transition in A from q to q0,

1. There is an a
2. there is an a-labeled transition from q2k+1 to q
3. for each 0 ≤ j ≤ k the tuple (A, q2j , q2j+1) belongs to L, and for each 0 ≤

in A, and

(cid:4)

−

i , T r

i+1, ai+1)).

i = ξr(T r

i+1 = ξ(cid:3)(T (cid:3)

i ’s (resp., T r

i , ai+1) (resp., T r

i ). Furthermore, consecutive T (cid:3)

As it turns out, the fact that Li satisﬁes (†) can be stated in terms of T (cid:3)

i and T r
i ,
for each 0 ≤ i ≤ m. Indeed, it is not hard to see that Li satisﬁes (†) if and only if
Li = ξ(T (cid:3)
i ’s) can be expressed in terms
of the function ξ(cid:3) (resp., ξr). In fact, it is easy to see that for each 0 ≤ i ≤ m it is
the case that T (cid:3)
Now we construct the NFA Aloops. The set of states is Loops× Loops. The initial
states are the pairs of the form (L1, L2), where L1 is the set of triples in TΓ(cid:2) of the
form (A, q, q). Similarly, the ﬁnal states are the pairs of the form (L1, L2), where now
L2 is the set of all triples in TΓ(cid:2) of the form (A, q, q). The transition function δ is
1. Let L1, L2, L be elements in Loops. Then (L1, L2) ∈ δ((L1, L2), L) whenever
±

2) ∈ δ((L1, L2), a) whenever L
(cid:4)
Notice that the size of Aloops is bounded by 2O(|Γ

(cid:4)
2 are elements in Loops and a is a symbol in Σ
(cid:4)
2, a).
Therefore, an accepting run of Aloops over L0a1L1 . . . Lm−1amLm is a sequence

(cid:4)
1 = ξ(cid:3)(L1, a) and L2 = ξr(L
(cid:2)|2).

2. Assume that L1, L2, L

deﬁned as follows:

L = ξ(L1, L2).

Then (L

(cid:4)
1, L

(cid:4)
1, L

.

of the form

(L0

1, L0

2), (L0

1, L0

2), (L1

1, L1

2), (L1

1, L1

2), . . . , (Lm

1 , Lm

2 ), (Lm

1 , Lm
2 ),

1

where the following hold by the deﬁnition of the transition function δ:

2) = (ξ(cid:3)(Li
1, Li

1. (Li+1
1, ai+1), ξr(Li+1
, Li
2), for each 0 ≤ i ≤ m.
2. Li = ξ(Li
2 ) are an initial and ﬁnal state of Aloops, respectively.
We prove now that Aloops has an accepting run over L0a1L1 . . . Lm−1amLm if

, ai+1)), for each 0 ≤ i ≤ m − 1, and

2) and (Lm

Further, (L0

1 , Lm

1, L0

2

i , T r

i ) for each 0 ≤ i ≤ m. But since we know that Li = ξ(Li

and only if this word is correct. From our previous remarks, it is suﬃcient to prove
that Li = ξ(T (cid:3)
1, Li
2),
for each 0 ≤ i ≤ m. We prove the
we need only prove that Li
former ﬁrst by induction on 0 ≤ i ≤ m. For the base case i = 0, notice that L0
1 is
the set of all triples in TΓ(cid:2) of the form (A, q, q) (because (L0
2) is an initial state of
Aloops). But this set is precisely T (cid:3)
0 by deﬁnition. Consider now the inductive case

i and Li

2 = T r

1 = T (cid:3)

1, L0

i

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1353

1

i

(cid:4)

(cid:4)

2 = T r

i+1 = ξ(cid:3)(Li

i+1 = ξ(cid:3)(T (cid:3)

i = Li
. Proving that Li

m−i for each 0 ≤ i ≤ m).

1, and, therefore, T (cid:3)
2 = T r

i + 1, for 0 ≤ i < m. We know from our previous remarks that T (cid:3)
i , ai+1).
By inductive hypothesis, T (cid:3)
1, ai+1). But the latter
for each 0 ≤ i ≤ m is completely analogous,
is precisely Li+1
but this time we do it by induction on i from m to 0 (more formally, we prove by
induction on i that Lm−i
Given a canonical database G of Γ, we denote by wG the unique word L0a1L1 . . .
amLm over Δ such that label(G) = a1 ··· am and the Li’s satisfy (†). In particular,
L0a1L1 . . . amLm is correct. We now deﬁne the 2AFA AΓ(cid:2) . This 2AFA satisﬁes the
following for each canonical database G of Γ: The word wG is accepted by AΓ(cid:2) if and
evaluates to true over G. In order to do this, we deﬁne for each disjunct γ
(cid:4)
a 2AFA Aγ(cid:2) such that the following holds for each canonical database G of Γ:
(G) = true. Then AΓ(cid:2) is obtained

only if Γ
of Γ
The word wG is accepted by Aγ(cid:2) if and only if γ
by simply taking the union of all the Aγ(cid:2) ’s.
(cid:4)(cid:4)

(cid:4)
be a disjunct of Γ
such that its underlying undirected graph U(γ

is a maximal subquery
γ
is
acyclic, we can naturally interpret (the underlying undirected graph of) each conas 
a rooted tree. This allows us to talk about the parent or a
nected component of γ
(cid:4)
child of a variable in γ
, we deﬁne
of the form (x,A, x), for A an NFA over Σ
±
Loops(x) to be the set of atoms of γ
.
(cid:4)
, then Atoms(x, y) denotes the set of atoms in
Recall that if x and y are variables in γ
(cid:4)
γ
that mention both x and y. Without loss of generality, we assume that each atom
in Atoms(x, y) is of the form (x,A, y) (otherwise, we simply “reverse” A).

, with the obvious meaning. Given a variable x in γ

. A connected component of γ

) is connected. Since γ

Let γ
of γ

(cid:4)

(cid:4)(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Let x and y be variables in γ
the proof, we ﬁx an enumeration

(cid:4)

such that x is the parent of y in γ

. For the rest of

(cid:4)

(x,A1, y), . . . , (x,Ap, y)

(cid:4)

(cid:4)

(cid:4)

±

= (q

(cid:4)
1, . . . , q

, we say that C

is L-reachable from C, if (Ai, qi, q

p) in Cuts(x, y), and a symbol a ∈ Σ
(cid:4)

of the elements in Atoms(x, y). We then deﬁne Cuts(x, y) to be the set of all tuples
of the form (q1, . . . , qp), where qi is a state of Ai for each 1 ≤ i ≤ p. A tuple
(q1, . . . , qp) ∈ Cuts(x, y) is an initial cut (respectively, a ﬁnal cut) if qi is an initial
state (respectively, a ﬁnal state) of Ai for each 1 ≤ i ≤ p. Given cuts C = (q1, . . . , qp)
is a-reachable
and C
from C, if there is an a-transition in Ai from qi to q
i for each 1 ≤ i ≤ p. For a symbol
(cid:4)
i) ∈ L for each 1 ≤ i ≤ p.
L ∈ Loops we say that C
(cid:4)
Intuitively, while reading word wG = L0a1L1 . . . amLm, for G a canonical database
of Γ, the 2AFA Aγ(cid:2) looks for a homomorphism from γ
to G. The positions of the
Li’s represent the nodes of G and the ai’s represent the edges. At any particular
moment, Aγ(cid:2) is trying to map a particular variable x in γ
. Once Aγ(cid:2) maps x, a
universal transition takes place to ensure that all the children of x can be mapped
too. Suppose x is mapped to the node i, for 0 ≤ i ≤ m. Then, while reading the
symbol Li, each copy of the 2AFA Aγ(cid:2) guesses a mapping position 0 ≤ j ≤ m for
a particular child y of x. This copy then moves from position i to j while it veriﬁes
that all the atoms in Atoms(x, y) can be correctly mapped to wG.
Consider an atom of the form (x,A, y) in Atoms(x, y). The 2AFA Aγ(cid:2) then has to
that can be read in A from an initial state qI
verify that there is a a word w over Σ
to a ﬁnal state qF , such that w folds into a1 . . . am from i to j. Let us assume without
loss of generality that i < j (any other case is analogous). Observe that the word w
can always be decomposed in the form

±

(cid:4)

(cid:4)

w = wiai+1wi+1 . . . ajwj ,

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1354

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

±

(cid:4)

(cid:4)

(cid:4)

such that (A, q, q

where wh is a word over Σ
that can be folded into a1 . . . am from h to h for each
i ≤ h ≤ j. Then Aγ(cid:2) guesses the run on A over w from qI to qF , while it reads
Liai+1Li+1 . . . ajLj from left-to-right. If Aγ(cid:2) reads ah, with h ∈ {i + 1, . . . , j}, and
the current guessed state is q, then it guesses q
such that there is an ah-transition in
A from q to q
. If Aγ(cid:2) reads Lh, with h ∈ {i, . . . , j}, and the current guessed state is
) ∈ Lh. However, there is a slight complication
q, then it guesses q
as the automaton has to do this simultaneously for all atoms in Atoms(x, y). Thus
Aγ(cid:2) actually guesses a sequence of cuts C0, . . . , C2(j−i)+1 from Cuts(x, y), where C0
is an initial cut, C2(j−i)+1 is a ﬁnal cut, and Ch is αh-reachable from Ch−1, for each
h ∈ {1, . . . , 2(j − 1) + 1}, where αh is the hth symbol in Liai+1Li+1 . . . ajLj. The
2AFA Aγ(cid:2) is formally deﬁned below.
tively. Then the set of states of Aγ(cid:2) is

has K connected components with roots r1, . . . , rK, respecLet 
us assume that γ

(cid:4)

(cid:4)

(cid:4)

Q = Cuts × {−1, 1} ∪ {r1, . . . , rK , start, accept},

(cid:4){Cuts(x, y) | x is the parent of y in γ

(q, a) = ϕ1 ∨ ··· ∨ ϕn, we write ϕi ∈ δ

(cid:4)}. The initial state is
where Cuts is the set
of Aγ(cid:2).
start and the ﬁnal state is accept. Next we deﬁne the transition function δ
For readability, whenever δ
(q, a) for each
i ∈ {1, . . . , n}. We also assume that whenever Aγ(cid:2) reaches the ﬁnal state accept, it
(cid:4)
stays in the same state and moves its head all the way to the right. The function δ
is deﬁned as follows:
(start, L), for each
L ∈ Loops.
(ri, α), for each i ∈ {1, . . . , K} and α ∈
± ∪ Loops. These transitions look for the position where the root ri is
Σ
mapped.
3. For each i ∈ {1, . . . , K} and L ∈ Loops, we have a “root mapping” transition:

1. There is an initial transition (0, r1) ∧ ··· ∧ (0, rK) ∈ δ
2. There is a transition (1, ri) ∈ δ

(cid:4)

(cid:4)

(cid:4)

(cid:4)

[(0, (I1,−1)) ∨ (0, (I1, 1))] ∧ ··· ∧ [(0, (It,−1)) ∨ (0, (It, 1))] ∈ δ

(cid:4)

(ri, L),

(cid:4)

, (b) for each 1 ≤ j ≤ t it is the
where (a) u1, . . . , ut are the children of ri in γ
case that Ij is an initial cut from Cuts(ri, uj), and (c) Loops(ri) is compatible
with L, i.e., for each atom (ri,A, ri) ∈ Loops(ri) there are initial and ﬁnal
states qI and qF of A such that (A, qI , qF ) ∈ L.
Intuitively, a “root mapping” transition maps ri to the current position h,
and for each child uj it guesses an initial cut and the fact whether uj will
be mapped to the right of h (indicated by the symbol 1) or to the left of h
(indicated by the symbol −1).
4. For each C ∈ Cuts(x, y), with x the parent of y, each D ∈ {−1, 1}, and each
a ∈ Σ

, we have an “atom mapping” transition:

±

(D, (C

(cid:4)

, D)) ∈ δ

(cid:4)

((C, D), a),

(cid:4) ∈ Cuts(x, y) is a-reachable from C if D = 1 or a

-reachable from
5. For each C ∈ Cuts(x, y), with x the parent of y, each D ∈ {−1, 1}, and each

where C
C if D = −1.
L ∈ Loops, we have a “loop guessing” transition:

−

(D, (C

(cid:4)

, D)) ∈ δ

(cid:4)

((C, D), L),

where C

(cid:4) ∈ Cuts(x, y) is L-reachable from C.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1355

We also have a “variable mapping” transition:

[(0, (I1,−1)) ∨ (0, (I1, 1))] ∧ ··· ∧ [(0, (It,−1)) ∨ (0, (It, 1))] ∈ δ
((C, D), L),
, (b) for each 1 ≤ j ≤ t we have
where (a) u1, . . . , ut are the children of y in γ
that Ij is an initial cut from Cuts(y, uj), (c) Loops(y) is compatible with L,
and (d) there is a ﬁnal cut C
Finally, we have a “leaf mapping” transition:

(cid:4) ∈ Cuts(x, y) which is L-reachable from C.

(cid:4)

(cid:4)

(0, accept) ∈ δ

(cid:4)

((C, D), L),

(cid:4)

(cid:4)

(cid:2)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

be a disjunct of Γ

. Recall that the width w(γ

whenever (a) y is a leaf in γ
there is a ﬁnal cut C

(cid:4) ∈ Cuts(x, y) which is L-reachable from C.
(G) = true.

, (b) Loops(y) is compatible with L, and (c)
It is not hard to see that Aγ(cid:2) is sound and complete, i.e., that for each canonical
Recall that AΓ(cid:2) is the union of the Aγ(cid:2)s, for γ

database G of Γ the 2AFA Aγ(cid:2) accepts wG if and only if γ
a disjunct of Γ
. We now analyze
the size of AΓ(cid:2) . Let γ
is the
maximum value of |Atoms(x, y)|, for x and y distinct variables in γ
. The number of
(cid:4){Cuts(x, y) | x is the parent of y in γ
states of Aγ(cid:2) is 2|Cuts|+K +2 (where K is the number of connected components of γ
(cid:4)
).
(cid:4)}. Notice for each
Recall that Cuts is the set
it is the case that |Cuts(x, y)| is bounded by O(|γ
(cid:4)|w(γ(cid:2)
)),
distinct variable x and y in γ
and, therefore, |Cuts| is bounded by O(|γ
)) = O(|γ
(cid:4)|w(γ(cid:2)
)+1). Further, clearly
(cid:4)|w(γ(cid:2)
(cid:4)|. Thus, the number of states of Aγ(cid:2) is O(|γ
K is bounded by |γ
)+1). Since the
(cid:4)
(cid:4)
width w(Γ
is deﬁned as the maximum value of w(γ
), for γ
, it
a disjunct of Γ
follows that the number of states of AΓ(cid:2) is at most O(|Γ
)+1) = O(|Γ
(cid:4)|w(Γ
(cid:4)|·|Γ
(cid:4)|w(Γ
)+2).
Now we are ready to deﬁne the NFA AΓ,Γ(cid:2). This NFA is the product of Acd,
Aloops, and AΓ(cid:2) , where AΓ(cid:2) is the NFA from Lemma 4.5 that accepts the complement
of the language accepted by AΓ(cid:2) . From our previous remarks, Γ (cid:10)⊆ Γ
the language accepted by AΓ,Γ(cid:2) is not empty. Furthermore, notice that the number
of states of AΓ,Γ(cid:2) is bounded by 2O(log |Γ|+|Γ

(cid:2)|w(Γ(cid:2) )+2).

if and only if

(cid:4)|w(γ(cid:2)

(cid:4)|·|γ

) of γ

) of Γ

(cid:4)

(cid:4)

(cid:4)

(cid:2)

(cid:4)

(cid:2)

It is well known that nonemptiness of an NFA with n states can be checked in
nondetermistic O(log n) space. Following this approach, our algorithm simply checks
that the language accepted by AΓ,Γ(cid:2) is nonemtpy using nondeterministic O(log |Γ| +
|Γ
(cid:4)|w(Γ
)+2) space. Of course we cannot construct explicitly AΓ,Γ(cid:2) , as it might be of
double exponential size. Instead, we use a standard “on the ﬂy” implementation: We
generate the states of AΓ,Γ(cid:2) on the ﬂy and whenever is needed, we check whether
there is a transition from one state to another. It is straightforward to check that,
given two states, we can decide if there is a transition in AΓ,Γ(cid:2) from one state to the
other using only polynomial space in |Γ| and |Γ
(cid:4)|. Thus the on the ﬂy implementation
actually uses only O(log |Γ| + |Γ
)+2) space. By Savitch’s theorem, we conclude
)+2)2) =
that containment of Γ in Γ
O(|Γ
) space, for suitable constants
d, d

(cid:4)|d·w(Γ
(cid:4)|2w(Γ
(cid:4) ≥ 1. This concludes the proof of the lemma.
5. Approximations of UC2RPQs. Acyclic UC2RPQs form a good class in
terms of complexity of evaluation: They are tractable as opposed to arbitrary C2RPQs
(and even CQs) for which the evaluation problem is NP-complete and even hard
in parameterized complexity [37]. This motivates our study of approximations of
UC2RPQs in the class of acyclic UC2RPQs, which is inspired by recent research on
approximations of UCQs. We explain this below.

can be solved in deterministic O((log |Γ|+|Γ

)+4·log2 |Γ|) space, which is O(|Γ

)·|Γ|d(cid:2)

(cid:4)|w(Γ
(cid:2)

(cid:4)|w(Γ
(cid:2)

(cid:4)

(cid:2)

(cid:2)

Evaluating an arbitrary CQ on a big database might be prohibitively expensive.
This has led to the recent study of (U)CQ approximations in tractable classes [6],

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1356

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

in particular, in the class of acyclic (U)CQs. Intuitively, an acyclic UCQ Θ
approximation of a UCQ Θ if the following holds: (1) Θ
returns no false positives with respect to Θ) and (2) Θ
among all acyclic UCQs.

is an
(cid:4)
is contained in Θ (i.e., Θ
is “as close as possible” to Θ

(cid:4)

(cid:4)

(cid:4)

It follows from results and techniques in [6] that approximations of UCQs have

good properties.

1. First of all, they always exist, that is, each UCQ has at least one acyclic
approximation, and, in addition, such an approximation is unique (up to
equivalence) and of at most exponential size.

2. Second, for each UCQ Θ, its acyclic approximation Θ

can be computed in

(cid:4)

single-exponential time.

3. Third, verifying whether an acyclic UCQ Θ

(cid:4)

is an approximation of a UCQ

Θ is decidable in the second-level of the polynomial hierarchy.

These good properties imply that computing and running the acyclic approximation 
of a UCQ Θ on a database D takes time O(2p(|θ|) + |D| · 2r(|Θ|)), for polynomials
p, r : N → N, which is O(|D|·2s(|Θ|)), for a polynomial s : N → N. On large databases,
this is much better than the general |D|O(|Θ|) cost of evaluating Θ over D. Thus, if
evaluation of Θ is infeasible or too slow and the quality of its acyclic approximation
is good, we may prefer to run this faster approximation instead of Θ.

Here we study acyclic approximations for UC2RPQs, and show that several of
the good properties mentioned above for acyclic approximations of UCQs extend to
the class of UC2RPQs.

5.1. Approximations: Existence and computation. Suppose we want to
approximate a UC2RPQ Γ in the class AC of acyclic UC2RPQs. As explained earlier,
we are interested in approximations that are guaranteed to return correct results only.
Thus, we are looking for an acyclic UC2RPQ that is maximally contained in Γ.
be UC 2RPQs such that Γ
(cid:4)(cid:4) ∈ AC with Γ

Definition 5.1 (approximations). Let Γ and Γ
(cid:4) ⊆ Γ. Then Γ
(cid:4)
(cid:4)(cid:4) ⊆ Γ

is an approximation of Γ if for every query Γ
.

and Γ
we have that Γ

(cid:4) ∈ AC
(cid:4)(cid:4) ⊆ Γ

(cid:4)

(cid:4)

It is worth noticing that the deﬁnition of approximations in [6] is diﬀerent, but

equivalent to this one.

An important property of UCQs is that each query in the class has an acyclic
approximation, and that such an approximation is unique. We can prove that this is
also true for the class of UC2RPQs.

Theorem 5.2. Each UC 2RPQ has a unique acyclic approximation (up to equiv-

alence).

As a corollary to the proof of Theorem 5.2 we get the following important result

about the computation and size of approximations.

Corollary 5.3. There exists an Expspace algorithm that takes as input a UC 2
of Γ. This approximation is of at most

(cid:4)

RPQ Γ and computes the approximation Γ
exponential size.

It follows from Corollary 5.3 that approximations of UC2RPQs are meaningful.
In fact, computing and running the acyclic approximation of a UC2RPQ Γ on a graph
database G takes time

(cid:9)
22p(|Γ|)
for polynomials p, r : N → N, which is O

(cid:10)
+ |G|2 · 2r(|Γ|)
(cid:5)|G|2 · 22p(|Γ|)(cid:6)

. In terms of data complexity

O

,

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1357
this is only O(|G|2), such like the data complexity of 2RPQs. This is much faster than
|G|O(|Γ|)—the order of the evaluation problem for Γ on G—on large datasets.

We ﬁnish by proving that there is an important aspect of approximations that
is harder for UC2RPQs than for UCQs: the identiﬁcation problem, i.e., verifying
whether a query is an approximation of another. We mentioned above that checking
is an approximation of a UCQ Θ can be solved in the
whether an acyclic UCQ Θ
second-level of the polynomial hierarchy [6]; more precisely, it is complete for the
class DP, that consists of all those languages that are the intersection of an NP and
a coNP problem [36]. This problem is considerably harder for UC2RPQs.

(cid:4)

Proposition 5.4. Let Γ and Γ

be UC 2RPQs such that Γ

of verifying whether Γ

is an acyclic approximation of Γ is Expspace-complete.

(cid:4) ∈ AC. The problem

(cid:4)

(cid:4)

We prove Theorem 5.2, Corollary 5.3, and Proposition 5.4 in the following section.

5.2. Proofs of results. All results in section 5.1 follow from an important
lemma that states that there exists an Expspace algorithm that, on input a UC2RPQ
Γ, computes an acyclic UC2RPQ Γapp—of at most exponential size—which is a maximum 
for the class of acyclic UC2RPQs that are contained in Γ. This lemma will also
be crucial for proving decidability of the notion of semantic acyclicity for UC2RPQs
in section 6.

putes an acyclic UC 2RPQ Γapp such that the following hold:

Lemma 5.5. There exists an Expspace algorithm that given a UC 2RPQ Γ com1.
 Γapp ⊆ Γ.

(cid:4) ⊆ Γapp.
2. For every acyclic UC 2RPQ Γ
3. The number of atoms and variables in each disjunct of Γapp is at most poly-

(cid:4) ⊆ Γ it is the case that Γ

such that Γ

(cid:4)

nomial in |Γ|.
most exponential in |Γ|.

4. The number of disjuncts and the size of each NFA appearing in Γapp is at

In particular, the size of Γapp is at most exponential in |Γ|.

Before proving Lemma 5.5 we show how the results in section 5.1 follow from it.

Proofs of Theorem 5.2, Corollary 5.3, and Proposition 5.4. The

algorithm in
Lemma 5.5 computes for each UC2RPQ Γ a query Γapp which is the maximum for
the class of acyclic UC2RPQs that are contained in Γ. In other words, Γapp is an
approximation of Γ. This approximation must be unique (up to equivalence) by deﬁnition.


(cid:4)

. Indeed, if this is the case, then Γ

Finally, we prove Proposition 5.4. Checking whether the acyclic UC2RPQ Γ

In order to prove Corollary 5.3, we use the algorithm in Lemma 5.5 to compute
the approximation Γapp of a UC2RPQ Γ. The algorithm runs in Expspace, and its
output Γapp is of at most exponential size in |Γ|.
is
an approximation of the UC2RPQ Γ is equivalent to checking whether (†) Γ
(cid:4) ⊆ Γ and
(††) Γapp ⊆ Γ
(cid:4) ≡ Γapp, and, therefore, Γ
(cid:4)
is the
approximation of Γ. We prove that (†) and (††) can be checked in Expspace.
It directly follows from the ﬁrst part of Proposition 4.1 that (†) can be veriﬁed in
Expspace. Furthermore, checking (††) requires computing Γapp and then checking
whether Γapp ⊆ Γ
. The ﬁrst step can be done in Expspace from Lemma 5.5, while
the second one can be carried out in exponential space, where the exponent depends
(cid:4)| and maxvar(Γapp) (again from the ﬁrst part of Proposition 4.1). Part
only on |Γ
3. of Lemma 5.5 implies that maxvar(Γapp) is at most polynomial in the size of |Γ|.
Therefore, the second step can also be done in Expspace. We conclude that checking

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1358

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

(cid:4)

For the lower bound, observe that Γ

whether Γ
mation of Γ∧ Γ
of CRPQs is Expspace-hard even when Γ

(cid:4)

(cid:4) ⊆ Γ if and only if Γ
(cid:4)

(cid:4)

is acyclic.

is an approximation of Γ can be carried out in Expspace.

is an acyclic approxi-
. The result now follows since Proposition 4.1 states that containment

We devote the rest of this section to proving Lemma 5.5. We start by presenting
some deﬁnitions and a technical lemma which is crucial for our proof. We conclude
by explaining the construction of the acyclic approximation Γapp for a UC2RPQ Γ.

5.2.1. A technical lemma. The lemma requires some terminology which we

deﬁne next.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

= (N

in G±

in G there is a path from n to n
(cid:4) ⊆ N and E

Pseudoacyclic graph databases. A graph database G is connected if for each
pair of nodes n, n
(that is, if the underlying
undirected graph of G is connected). A subgraph database of G = (N, E) is a graph
(cid:4) ⊆ E. A connected component of
database G(cid:4)
G is a maximal connected subgraph database of G. We call G pseudoacyclic if each
connected component of G can be obtained from a tree T as follows:
(cid:4)} in T is replaced by a ﬁnite number of semipaths from n
whose internal nodes are “fresh”; i.e., they are disjoint from any other
• For some (maybe none) nodes n in T we add a ﬁnite number of semipaths

• Each edge {n, n

to n
nodes in G.

) such that N

, E

(cid:4)

from n to n, again with fresh internal nodes.

The fresh internal nodes of the paths in the previous deﬁnition are the internal
nodes of the pseudoacyclic database G. The rest of the nodes (that is, the nodes that
are inherited from T ) are called external nodes.
We will slightly abuse notation and talk about the parent (respectively, ancestor)
of an external node n in the pseudoacyclic graph database G. By this we refer to the
external node in G that corresponds to the parent (respectively, an ancestor) of n in
the tree T . Similarly, we talk about the least common ancestor of two external nodes
in G, which refers to the external node in G that corresponds to their least common
ancestor in T .

The following proposition is straightforward.
Proposition 5.6. Let Γ be an acyclic UC 2RPQ. Then each canonical database

of Γ is pseudoacyclic.

We also deﬁne pseudoacyclicity for graphs in the obvious way: instead of adding
semipaths to T we add undirected paths. For pseudoacyclic graphs we deﬁne the
concepts of external/internal node and parent of a node as before.

(cid:4)

(cid:4)

Types for UC2RPQs. Let Γ be UC2RPQ over Σ. Recall that TΓ denotes the
), where A is an NFA mentioned in some atom of
set of all triples of the form (A, q, q
are states of A. A Γ-type is a 4-tuple π = (τ1, τ2, τ3, τ4), where τi is a
Γ and q and q
subset of TΓ, for each 1 ≤ i ≤ 4. Let w be a word over Σ
of length (cid:11) ≥ 0. The Γ-type
±
of w is the Γ-type πw = (τit, τti, τii, τtt) such that (A, q, q
(cid:4)
) belongs to τ
if and only
if there is a word u over Σ
, and u can be
folded into w from (i) 0 to (cid:11), if ∗ = it, (ii) from (cid:11) to 0, when ∗ = ti, (iii) from 0 to 0,
if ∗ = ii, and (iv) from (cid:11) to (cid:11), when ∗ = tt.

and a run of A over u from state q to q

Given a Γ-type π = (τ1, τ2, τ3, τ4), we deﬁne L⊆

(π) to be the language of words
such that π is coordinatewise contained in the Γ-type πw of w. The proof

w over Σ
of the following lemma is given in the appendix.

±

±

∗

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1359

Lemma 5.7. Let Γ be a UC 2RPQ and π a Γ-type. Then the language L⊆

regular and can be deﬁned by an NFA Aπ over Σ

±

(π) is
of at most exponential size in |Γ|.

The technical lemma. We are now ready to state the main lemma of this

section.

Lemma 5.8. Let G be a pseudoacyclic graph database, and let ¯n be a tuple of
external nodes in G. Let Γ(¯x) be a UC 2RPQ with |¯n| = |¯x| such that ¯n ∈ Γ(G). There
exists an acyclic C 2RPQ α(¯x) and a ﬁnite set RΓ of NFAs over Σ
such that the

±

following hold:

whose label is accepted by Ai.

1. RΓ can be constructed from Γ in single exponential time.
2. ¯n ∈ α(G) and α ⊆ Γ.
3. The number of atoms in α is at most polynomial in |Γ|.
4. Each NFA mentioned in α belongs to RΓ.
(cid:8)m
Proof. Since ¯n ∈ Γ(G), there is a disjunct γ of Γ such that ¯n ∈ γ(G). Assume that
i=1(ui,Ai, vi). Since ¯n ∈ γ(G), there is a mapping h from the variables
γ(¯x) = ∃¯y
of γ to the nodes of G that satisﬁes h(¯x) = ¯n and a path ρi from h(ui) to h(vi) in G±
such that label(ρi) is accepted by Ai, for each 1 ≤ i ≤ m. We assume without loss of
generality that for each 1 ≤ i ≤ m it is the case that ρi is of minimal length among
the set of paths from h(ui) to h(vi) in G±
We deﬁne a subset V of the nodes of G that will help us deﬁne the variable set of
the C2RPQ α(¯x). Let I be the set {h(z) | z is a variable in γ}. We deﬁne I(cid:4)
to be
the set of nodes obtained from I by adding, for each node u in I that is an internal
node of G, its associated external nodes in G (that is, the external nodes that are at
the beginning and at the end of the semipath where u belongs). We then deﬁne V
as the set of nodes which is obtained from I(cid:4)
by adding the least common ancestor
of external nodes from I(cid:4)
in G of each pair n, n
in the same connected component of
G. Observe that each node in ¯n belongs to I (since h(¯x) = ¯n), and thus to V. Also
notice that |V| is O(|γ|2). Indeed, |I| ≤ var, where var is the number of variables in
γ. Moreover, we have that |I(cid:4)| ≤ 3|I| and |V| ≤ |I(cid:4)| + |I(cid:4)|2, as the number of least
common ancestors we add to V is bounded by the number of pairs in |I(cid:4)|.
For each 1 ≤ i ≤ m, we decompose the path ρi according to V in the natural way.
i , . . . , ρki
That is, the path ρi is decomposed as the concatenation ρ1
i starts and ends at a node in V and each internal node of ρ
such that each path ρ
is not in V. As ρi itself starts and ends at h(ui) and h(vi), respectively, which are
nodes in V, this decomposition is always possible. The decomposition is also unique
j
(assuming that no ρ
i is the empty path, except in the case when ρi itself is empty).
i be the decomposition of the path ρi, for 1 ≤ i ≤ m. By the
minimality of ρi, it follows that ki ≤ |Qi| · |V| − 1, where Qi is the set of states of
the NFA Ai. Assume for the sake of contradiction that ki ≥ |Qi| · |V|. We ﬁx an
accepting run q0 ··· q(cid:3) of Ai over label(ρi) (i.e., each qj is a state in Qi, q0 and q(cid:3) are
an initial and ﬁnal state of Ai, respectively, and qj+1 is obtained from qj according to
the transition function of Ai). For each 1 ≤ j ≤ ki, let nj be the last node of ρ
j
i (which
belongs to V), and let qj be the state of the run q0 ··· q(cid:3) which is associated with the
i ). In particular, nki = h(vi) and qki = q(cid:3). We
preﬁx label(ρ1
also deﬁne n0 = h(ui) and q0 = q0. Since ki + 1 > |V| · |Qi|, there are two positions
0 ≤ (cid:11)1 < (cid:11)2 ≤ ki such that n(cid:3)1 = n(cid:3)2 and q(cid:3)1 = q(cid:3)2 . It is clear then that we can
ignore the subpath ρ(cid:3)1+1
i . This contradicts the minimality of ρi. We conclude
that the number of paths involved in all the decompositions of the ρi’s is at most
(|Q1| + ··· + |Qm|) · |V|. Clearly, |Q1| + ··· + |Qm| is polynomially bounded by |γ|.

j
i ) of label(ρ1

i of paths ρ1

i ··· ρki

i ··· ρki

i . . . ρki

··· ρ(cid:3)2

i

(cid:4)

j

i

j
i

Let ρ1

i . . . ρ

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpj

Let ρ

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

1360
Further, we know that |V| is O(|γ|2) and |γ| ≤ |Γ|. We then conclude that the number
of paths involved in all the decompositions of the ρi’s is polynomial in |Γ|.
i be a path in the decomposition of ρi, for 1 ≤ i ≤ m and 1 ≤ j ≤ ki. We
(cid:11)j
t=1 (cid:11)(i, t),
t=1 (cid:11)(i, t) (we set c(1) to be 0). Let q0 ··· q(cid:3) be an accepting run
i is an NFA obtained from Ai by setting qc(j) and qd(j)
j
i ) is accepted by

denote by (cid:11)(i, j) the length of the word label(ρ
and (ii) d(j) :=
of Ai over label(ρi). Then E
as the unique initial and ﬁnal state, respectively. Notice that label(ρ
E

i is of at most polynomial size in |Ai|, and, therefore, in |Γ|.

j
i ), and deﬁne (i) c(j) :=

j
i . Furthermore, E

(cid:11)j−1

j

j

(cid:4)
We now deﬁne a C2RPQ α

(cid:4)
First, α

(G) and α

(¯x), which will be the basis for constructing the
is {zn | n ∈ V}.
(cid:4)
C2RPQ α(¯x) from the statement of the lemma. The variable set of α
The free variables are ¯x = (zp1, . . . , zpr ), assuming that ¯n = (p1, . . . , pr). Finally, for
each 1 ≤ i ≤ m and 1 ≤ j ≤ ki, the atom (zn, E
(cid:4)
j
i , zn(cid:2)) is in α
, where n and n
are
(cid:4)
j
i , respectively. The C2RPQ α
(¯x) is not necessarily
the initial and terminal nodes of ρ
acyclic, but it can be turned into an acyclic C2RPQ α(¯x) satisfying conditions 2. and
3.
in the statement of the lemma as we shall see later. But before explaining how
(cid:4)
(¯x) satisﬁes conditions 2. and 3. in
to turn α
(cid:4) ⊆ Γ, while 3.
the statement of the lemma (recall that 2. states that ¯n ∈ α
(cid:4)
(cid:4)
states that the number of atoms in α

(cid:4)
into α, it is important to show that α

is at most polynomial in |Γ|).

(cid:4)
satisﬁes condition 3. of the lemma. In fact, the number of atoms in α

i , this mapping is actually a homomorphism. It follows that ¯n ∈ α
(cid:4)

is
j
i ’s involved in the decompositions of the ρi’s, which is
satisﬁes condition 2. First, consider
to G that maps each zn to n. Since label(ρ
j
i )
(G). In
be a canonical database
with associated mapping ν. Consider the mapping f from the variables of
that maps each variable y to ν(zh(y)). The mapping f is well-deﬁned since
. Now we show that for each 1 ≤ i ≤ m,
whose label is accepted by Ai. We
±
)
, where
that is associated with the atom of
j
i from qc(j) to
i ) is accepted by Ai since it can be read in Ai from q0

at most the number of paths ρ
at most polynomial in |Γ|. Now we prove that α
(cid:4)
(cid:4)
the mapping g from the variables of α
satisﬁes E
order to show that α ⊆ Γ, we use Proposition 4.4. Let G(cid:4)
(cid:4)
for α
γ to G(cid:4)
h(y) ∈ I ⊆ V, and thus zh(y) is a variable of α
(cid:4)
there is a path from ν(zh(ui)) to ν(zh(vi)) in (G(cid:4)
in G±
can simulate the path ρi = ρ1
i is the semipath in the canonical database G(cid:4)
j
χ
(cid:4)
which is labeled E
α
qd(j), and thus label(χ1
to q(cid:3). Therefore, f is a homomorphism. Moreover, f (¯x) = ν(¯x).
ν(¯x) ∈ γ(G(cid:4)
). By Proposition 4.4, we conclude that α ⊆ Γ.
is that it is not necessarily acyclic.
In fact, since G is pseudoacyclic, the underlying graph U(α
(cid:4)
could be pseudoacyclic 
as opposed to acyclic. (Here we assume that the rooted tree used to construct 
the pseudoacyclic graph U(α
(cid:4)
) is the natural one, that is, the sets of external 
and internal nodes of U(α
) are precisely {zt | t is an external node in V} and
(cid:4)
{zt | t is an internal node in V}, respectively). For this to happen, the homomorphism 
h from γ to G must map two distinct variables in γ to internal nodes u and
(cid:4)
u
connect exactly the
(cid:4)
same pair (n, n
) might contain a cycle
n → u → n
(cid:4) → u

i . By construction, there is a run of Ai over χ
i . . . χki

) of external nodes of G. In such case, U(α
(cid:4)
(cid:4) → n.

(cid:4)
As mentioned before, the problem with α

in G, such that π and π

in two diﬀerent semipaths π and π

by the path χ1

) ⊆ Γ(G(cid:4)

i ··· χki

It follows that

i ··· ρki

(cid:4)
) of α

in (G(cid:4)

±
)

(cid:4)

i

i

Therefore, in order for U(α
(cid:4)

bad paths, which are simple paths of the form uu1 . . . uku
external nodes of U(α
(cid:4)
least one internal node belongs to a bad path).

) and u1, . . . , uk are internal ones (notice that k ≥ 1, i.e., at

, where u and u
In other words, if U(α
(cid:4)

) to be pseudoacyclic but not acyclic, it must contain
are distinct

) does not

(cid:4)

(cid:4)

j

j

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1361

contain bad paths, then it is actually acyclic. Thus, to obtain our desired acyclic
(cid:4)
query α we can modify α
in such a way that we eliminate all the bad paths from
U(α
(cid:4)
). This is what we do next.
Let us consider a bad path b in U(α
) of the form zn0 ··· znp+1, where (i) p ≥ 1, (ii)
(cid:4)
zn1, . . . , znp are internal nodes of U(α
(cid:4)
), and (iii) zn0 and znp+1 are distinct external
nodes of U(α
(cid:4)
). We assume without loss of generality that zn0 is the parent of znp+1
in U(α
). Therefore, we have that n0 and np+1 are external nodes in G such that n0 is
(cid:4)
the parent of np+1, and there is a semipath ζ from n0 to np+1 such that n1, . . . , np are
precisely the internal nodes of ζ that belong to V (since ζ is a semipath, it does not
repeat nodes by deﬁnition). For k ∈ {0, . . . , p}, let ζk be the subpath of ζ that starts
(cid:4) ∈ {0, . . . , p + 1}, let Pathsk,k(cid:2) be the set
at nk and ends at nk+1. Further, for k, k
of paths in some decomposition of some ρi that starts at nk and end at nk(cid:2) . Notice
that each path in Pathsk,k, with k ∈ {1, . . . , p}, satisﬁes that all its internal nodes
are contained either in ζk−1 or in ζk. For each k ∈ {1, . . . , p}, we deﬁne Paths↑
k,k
to be the set of paths in Pathsk,k whose internal nodes are in ζk−1. Analogously,
k,k = Pathsk,k \ Paths↑
Paths↓
k,k contains all the paths in Pathsk,k with
internal nodes in ζk. For convenience, we deﬁne Paths↓
In addition, for each k ∈ {0, . . . , p} we deﬁne a Γ-type πk = (τit, τti, τii, τtt)
as follows. The set τit contains the triple (A, q, q
) if and only if there is a path
i ∈ Pathsk,k+1 such that A = Ai and there is a run of Ai over label(ρ
j
ρ
i ) from state q
. We deﬁne τti, τii, and τtt analogously, but this time replacing Pathsk,k+1 with
to q
Pathsk+1,k, Paths↓
0,0 =
p+1p+1 = ∅, we have that τii = ∅ for π0 and τtt = ∅ for πp.
Paths↑
We then deﬁne Aπk to be the NFA from Lemma 5.7; i.e., Aπk deﬁnes the language
L⊆
(πk). Notice that label(ζk) is accepted by Aπk . Furthermore, πk, and, therefore,
Aπk , is completely determined by ζk. For the sake of presentation we thus denote
Aπk by Aζk from now on. Finally, we deﬁne Ib to be the set of atoms
{(zn0,Aζ0 , zn1), (zn1 ,Aζ1 , zn2), . . . , (znp ,Aζp , znp+1)}

k+1,k+1, respectively. Observe that, since Paths↓

k,k, i.e., Paths↓

k,k, and Paths↑

p+1,p+1 = ∅.

0,0 = Paths↑

(cid:4)

(cid:4)

j

of the form (zt, E

j
i , zt(cid:2) ), where (t, t

(cid:4)
as the C2RPQ which is obtained from α

and Ob to be the set of atoms in α
(cid:4)
{n0, . . . , np+1} × {n0, . . . , np+1} \ {(n0, n0), (np+1, np+1)}.
(cid:4)(cid:4)
We deﬁne an auxiliary query α
by
simultaneously replacing all atoms in Ob with those in Ib, for each bad path b in
). Since Ob and Ob(cid:2) are disjoint for diﬀerent bad paths b and b
U(α
(cid:4)
(cid:4)(cid:4)
, the query α
(cid:4)(cid:4)
is well deﬁned. We claim that α
satisﬁes conditions 2. and 3. of the lemma. For
condition 3., note that for each bad path b = zn0 ··· znp+1 in U(α
(cid:4)
) the number of
internal nodes p is bounded by the number of variables of γ, and in particular, by |Γ|.
It follows that |Ib| ≤ |Γ| + 1. Since the number of bad paths is also polynomial in |Γ|,
(cid:4)(cid:4)
we conclude that the number of atoms in α
satisﬁes condition 2. As noticed before, for an atom of the
form (·,Aζi ,·) in α
, we have that label(ζi) is accepted by Aζi . Putting this together
(cid:4)(cid:4)
(cid:4)
to the node n
with (i) the fact that the function that maps the variable zn in α
in G is a homomorphism, and (ii) the way in which α
(cid:4)(cid:4)
, we
conclude that ¯n ∈ α
(cid:4)(cid:4)
be
(cid:4)(cid:4)
with associated mapping ν, and assume that f is the
a canonical database for α
mapping that sends each variable y in γ to ν(zh(y)) (as before, f is well-deﬁned).
Clearly, f (¯x) = ν(¯x). We prove next that (f (ui), f (vi)) belongs to the evaluation
Ai(G(cid:4)
), and,
therefore, that α

(cid:4)
is constructed from α
(cid:4)(cid:4) ⊆ Γ using Proposition 4.4. Let G(cid:4)

, for each 1 ≤ i ≤ m. This implies that ν(¯x) ∈ γ(G(cid:4)

is still polynomial in |Γ|.

(G). We prove that α

(cid:4)(cid:4)
Now we show that α

) of Ai over G(cid:4)

(cid:4)(cid:4) ⊆ γ ⊆ Γ.

(cid:4)

) is a pair in

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php(cid:4)

1362

j

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

in (G(cid:4)

±
)

i

±
)

.

, and when t or t

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI
in G±

As before, one would like to simulate the path ρi = ρ1

i ··· ρki

i

. Let t and t
j
i goes from t to t

(cid:4)(cid:4)
By construction, we have that α

be external nodes in V such that n is the parent of n

is the semipath in the canonical database G(cid:4)
which is labeled E

by the path
i ··· χki
j
χ1
, where χ
that is
i
(cid:4)(cid:4)
j
associated with the atom of α
i . The only problem is that some of
(cid:4)
such atoms may have disappeared from α
and been replaced by atoms labeled with
an NFA Aζl which accepts the semipath ζl in G. Nevertheless, this could have only
i is an internal node of V.
happened if one of the endpoints of a path of the form ρ
Let n and n
, and let ζ be a
semipath in G from n to n
be internal nodes of ζ (t is closer to n than
(cid:4)
) and suppose that ρ
t
. (All other cases are analogous, i.e., when
j
i goes from t
to t, when t = t
is an external node). Further, let η
ρ
j
. We now explain how to simulate ρ
be the subpath of ζ that goes from t to t
i by a
path from ν(zt) to ν(zt(cid:2) ) in (G(cid:4)
contains the atom (zt,Aη, zt(cid:2)). Let π =
(τit, τti, τii, τtt) be the Γ-type such that Aη = Aπ. Then we have that (Ai, qc(j), qd(j))
is in τit. Let κ be the semipath from ν(zt) to ν(zt(cid:2) ) in G(cid:4)
that is naturally associated
with the atom (zt,Aη, zt(cid:2)). By deﬁnition, the ﬁrst coordinate of the Γ-type of label(κ)
contains (Ai, qc(j), qd(j)). Therefore, there is a word u such that Ai has a run over
u from qc(j) to qd(j) and u can be folded into label(κ) from the initial to the ﬁnal
from ν(zt) to ν(zt(cid:2) ) that can be
position. It follows that there is a path 
read in Ai from qc(j) to qd(j). This is the path that simulates ρ
j
i . From this reasoning
it is easy to conclude that there must be a path in (G(cid:4)
from ν(zh(ui)) to ν(zh(vi))
whose label is accepted by Ai, for each 1 ≤ i ≤ m. Therefore, (f (ui), f (vi)) ∈ Ai(G(cid:4)
)
for each 1 ≤ i ≤ m, which ﬁnishes the proof that α
(cid:4)(cid:4)
in the
statement of the lemma.
by simultaneously replacing
all atoms in Ib with the atom (zn0,Aζ0 · Aζ1 ···Aζp , znp+1), for all bad paths b =
zn0 ··· znp+1 in U(α
(cid:4)(cid:4)
(cid:4)(cid:4)
). Notice that this does not remove any free variables from α
,
). By construction, U(α) does not contain bad
as they are external nodes of U(α
(cid:4)(cid:4)
(cid:4)(cid:4)
paths, and thus it is acyclic. Further, α contains less atoms than α
which implies
(cid:4)(cid:4)
, and, therefore, α also
that condition 3. still holds. Clearly, α is equivalent to α
satisﬁes condition 2.
) be
the NFA obtained from A by setting q as the initial state and q
as the only ﬁnal state.
Let BΓ = {A(q, q
are states of A}. Further, let CΓ be the
set of all NFAs of the form Aπ, where π is a Γ-type (according to Lemma 5.7), and
let DΓ be the set of all NFAs that accept the concatenation of the languages accepted
by at most p NFAs in CΓ, where p ≤ |Γ| + 1. Then we deﬁne RΓ = BΓ ∪ DΓ. It is
easy to see that RΓ can be constructed from Γ in single exponential time. Moreover,
it is clear that all NFAs mentioned in α belong to RΓ. Therefore, conditions 1. and

It remains to deﬁne the set RΓ. For an NFA A and states q, q
(cid:4)

(cid:4)(cid:4)
Now we deﬁne α. The query α is obtained from α

) | A appear in Γ and q, q

in A, let A(q, q

(cid:4)

satisﬁes condition 2.

j

i in (G(cid:4)

±
)

(cid:4)

(cid:4)

±
)

(cid:4)

4. are satisﬁed, which concludes the proof of the lemma.

5.2.2. Construction of Γapp. We now present the proof of Lemma 5.5. That
is, we provide an Expspace algorithm that, given a UC2RPQ Γ, constructs an acyclic
UC2RPQ Γapp such that the following hold:

(cid:4) ⊆ Γapp.
(cid:4)
2. For every acyclic UC2RPQ Γ
3. The number of atoms and variables in each disjunct of Γapp is at most poly-

(cid:4) ⊆ Γ it is the case that Γ

such that Γ

1. Γapp ⊆ Γ.

nomial in |Γ|.

4. The number of disjuncts and the size of each NFA appearing in Γapp is at

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1363

most exponential in |Γ|.

Recall that Lemma 5.8 tells us that if G is a pseudoacyclic graph database, ¯n
is a tuple of external nodes in G, and Γ(¯x) is a UC2RPQ with |¯n| = |¯x| such that
¯n ∈ Γ(G), then there is an acyclic C2RPQ α(¯x) and a ﬁnite set RΓ of NFAs over Σ
±

such that the following hold:
, for d ≥ 1.
1. RΓ can be constructed from Γ in time 2
2. ¯n ∈ α(G) and α ⊆ Γ.
3. The number of atoms in α is at most |Γ|c, for c ≥ 1.
4. Each NFA mentioned in α belongs to RΓ.
a. We construct the ﬁnite set RΓ of NFAs over Σ

Given a UC2RPQ Γ(¯x) over Σ our algorithm proceed as follows:

|Γ|d

±

(cid:4)
b. We iterate through every acyclic C2RPQ α

of them labeled with NFAs in RΓ. If the C2RPQ α
(cid:4)
then we add it as a disjunct to the output Γapp.

from Lemma 5.8.

(¯x) with at most |Γ|c atoms, all
(¯x) is contained in Γ(¯x),

|Γ|d

(cid:4)
). But maxvar(α

(cid:4)
. This implies that the size of every acyclic C2RPQ α

First, observe that our algorithm is actually in Expspace. In fact, step a. can be
carried out in exponential time. Furthermore, the size of each NFA in RΓ is at most
|Γ|d
2
that we need to consider in
, i.e., it is exponentially bounded by |Γ|. We
the loop of step b. is bounded by |Γ|c·2
can thus iterate over all such queries using no more than exponential space. Further,
(cid:4) ⊆ Γ can be done
from item 1. of Proposition 4.1 it follows that checking whether α
using space which is at most exponential in |Γ| and maxvar(α
(cid:4)
) is at
most 2|Γ|c, and thus checking α
(cid:4) ⊆ Γ can be carried out in exponential space in |Γ|.
Therefore, the whole procedure can be performed in Expspace.
Notice that Γapp is nonempty. Indeed, assume that x1, . . . , xn are the free variables 
of Γ, i.e., those in ¯x. We assume without loss of generality that RΓ contains
the NFAs that deﬁne the empty word ε and the symbol a, for each a ∈ Σ. (If not,
we simply extend RΓ with those NFAs. The resulting set continues to satisfy all the
desired conditions for RΓ). We also assume that the codiﬁcation of Γ has size at
least n + |Σ|. In particular, we have that n + |Σ| ≤ |Γ|c. Consider now the C2RPQ
∗
α
is acyclic and
its number of atoms is at most n +|Σ| ≤ |Γ|c. By the previous observations, it follows
∗
that α
is one of the C2RPQs visited in step b. of the procedure. Moreover, it is
easy to verify that α
consists of
a single node u (which represents all the free variables x1, . . . , xn) and a self-loop on
u labeled a, for each a ∈ Σ. It is easy to see that ¯x ∈ Γ(G). This is because if γ(¯x)
is an arbitrary C2RPQ in Γ, then the mapping h that sends every variable y of γ to
∗
u is a homomorphism which satisﬁes h(¯x) = ¯x. We conclude that α
is a disjunct of
Γapp and, therefore, that Γapp is not empty.

(cid:8)
1≤i≤n−1(xi, ε, xi+1) ∧ (cid:8)
∗ ⊆ Γ. In fact, the only canonical database G of α
∗

∗
a∈Σ(x1, a, x1). Clearly, α

(x1, . . . , xn) :=

For condition 2., let Γ

we conclude that Γapp ⊆ Γ.
(cid:4)

We now prove that Γapp satisﬁes conditions 1., 2., 3., and 4. in the statement of
Lemma 5.5. Conditions 3. and 4. are trivially satisﬁed by construction. For condition
(cid:4)
1., we have by deﬁnition that each disjunct α
of Γapp is contained in Γ, from which
(cid:4) ⊆ Γ. We need to
with associated mapping
show that Γ
ν. By Proposition 4.4, it suﬃces to show that ν(¯x) ∈ Γapp(G). Since Γ
is acyclic,
we have from Proposition 5.6 that G is pseudoacyclic. We also have that the tuple
(cid:4) ⊆ Γ it is the case that
ν(¯x) only contains external nodes of G. Moreover, since Γ
ν(¯x) ∈ Γ(G). Therefore, we can apply Lemma 5.8 to UC2RPQ Γ, graph database
G, and tuple of nodes ν(¯x). This ensures the existence of an acyclic C2RPQ α(¯x)

(cid:4) ⊆ Γapp. Let G be a canonical database of Γ

(¯x) be an acyclic UC2RPQ such that Γ

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1364

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

satisfying conditions 1.–4.
in the statement of Lemma 5.8. Conditions 3. and 4.
ensure that α is visited by our algorithm in step b. On the other hand, the second
statement in condition 2. ensures that α ⊆ Γ, from which we have that α is a disjunct
of Γapp. Finally, the ﬁrst statement of condition 2. tells us that ν(¯x) ∈ α(G), and,
therefore, ν(¯x) ∈ Γapp(G). This completes the proof of Lemma 5.5.

6. Semantic acyclicity of UC2RPQs. We ﬁnish the paper by studying the
notion of semantic acyclicity in the context of graph databases and conjunctive regular
path queries. As opposed to the case of CQs, the results in this section do not
follow from known results in the literature and require new techniques. We start
by deﬁning the terminology and providing some basic insights about the nature of
semantic acyclicity for UC2RPQs.

6.1. Basic terminology and insights. A UC2RPQ Γ is semantically acyclic
. As we mentioned before, we
if there exists an acyclic UC2RPQ Γ
want to answer two basic questions about semantically acyclic UC2RPQs: (1) What
is the cost of evaluating queries in this class? (2) What is the cost of checking whether
a UC2RPQ is semantically acyclic? We will see that an answer to the second question
will provide us with an answer for the ﬁrst one.

such that Γ ≡ Γ

(cid:4)

(cid:4)

Since acyclicity of C2RPQs is deﬁned in terms of the acyclicity of its underlying
CQ, one may be tempted to think that the two notions coincide. Clearly, if the
underlying CQ of a C2RPQ γ is semantically acyclic, then γ is also semantically
acyclic. The following example shows that the opposite does not hold.

Example 5. Consider again the nonacyclic CRPQ

(cid:5)
(cid:6)
(x, L1, y) ∧ (y, L2, z) ∧ (z, L3, x)

(cid:4)(cid:4)

(cid:4)(cid:4)

γ

= ∃x∃y∃z

(cid:5)

(cid:4)(cid:4)

is ∃x∃y∃z

(cid:4)(cid:4)

in Example 4.

∃x(x, L1 · L2 · L3, x), and, thus, it is semantically acyclic. On the other hand, the

is equivalent to the acyclic CRPQ

It is not hard to prove that γ

(cid:6)

T1(x, y), T2(y, z), T3(z, x)

, which is not semantically

underlying CQ of γ
acyclic.

Intuitively, the query γ

is semantically acyclic because it can be “simpliﬁed” by
concatenating the regular languages that label its atoms. A more interesting example

is given by the Boolean CRPQ γsa over alphabet Σ = {a, $1, $2, $3} shown in Figure

6.1. (Dots represent variables and arrows represent labeled atoms.)

$2
∗

a

$1

∗

a

∗

a

$3

Fig. 6.1. The CRPQ γsa.

$1

a∗
a∗

$2

a∗
a∗

$3

Fig. 6.2. The acyclic CRPQ that is equivalent to γsa.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1365

$2

a

$1

a

a

$3

Fig. 6.3. The CRPQ γna from Example 6.

It is easy to see that the underlying CQ of γsa is not semantically acyclic. On
the other hand, it can be proved that γsa is equivalent to the acyclic CRPQ shown
in Figure 6.2. In this case, semantic acyclicity is obtained by the way in which the
regular languages that label the atoms of γsa interact with each other.

The previous example shows that the notion of semantic acyclicity of C2RPQs is
richer than the notion of semantic acyclicity of its underlying CQs, as many queries
fall in the former category but not in the latter. Not only that, the ﬁrst notion is
also theoretically more challenging: While the same techniques used in section 2 can
be applied to prove that the evaluation problem is tractable for UC2RPQs whose
underlying CQ is semantically acyclic, it is by no means clear whether the same is
true for the class of semantically acyclic UC2RPQs (and even for semantically acyclic
CRPQs). We delve into this issue below.

As is mentioned in the introduction, the CSP techniques used in section 2 to prove
that the evaluation of semantically acyclic UCQs is tractable do not yield answers to
our questions about semantically acyclic UC2RPQs. The results in section 6.2 help
us prove, on the other hand, that the problem is ﬁxed-parameter tractable (Theorem
6.3), which was not known to date. We leave as an open question whether the class
of semantically acyclic UC2RPQs can be evaluated in polynomial time.

Before ﬁnishing the section we explore the limits of the notion of semantic acyclicity.
 The next example shows a simple CQ over graph databases that is not equivalent
to any acyclic UC2RPQ.

Example 6. Let Σ = {a, $1, $2, $3} be a ﬁnite alphabet and consider the Boolean
CRPQ γna over Σ that is graphically depicted in Figure 6.3. Notice that the underlying
CQ of γna coincides with that of the semantically acyclic CRPQ γsa from Figure 6.1.
However, a simple case-by-case analysis shows that γna is not semantically acyclic.
The reason is that γna forbids the interaction between the diﬀerent RPQs that label
its atoms by replacing each RPQ of the form a

∗

in γsa with a.

6.2. Veriﬁcation of semantic acyclicity. We start by considering our second
question above: Is the notion of semantic acyclicity for UC2RPQs decidable? In this
section we show that this is indeed the case and provide matching upper and lower
bounds for its computational cost.

We start by proving that the notion of semantic acyclicity for UC2RPQs is decidable,
 and provide an Expspace upper bound for the problem. The algorithm
(cid:4)
of exponential size for a semantically acyclic
also yields an equivalent UC2RPQ Γ
UC2RPQ Γ.

Theorem 6.1. There exists an Expspace algorithm that on input a UC 2RPQ

Γ does the following:

1. It checks whether Γ is semantically acyclic.
2. If the latter holds, it outputs an acyclic UC 2RPQ Γ

(cid:4)

of single-exponential size

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1366

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

such that Γ ≡ Γ

(cid:4)

.

Proof. The algorithm in Lemma 5.5 computes on input Γ an acyclic UC2RPQ
Γapp such that Γapp is the maximum among all acyclic UC2RPQs that are contained
in Γ. It follows that Γ is semantically acyclic if and only if Γ ⊆ Γapp. Thus, in order to
check semantic acyclicity of Γ we can compute Γapp, which can be done in Expspace,
and then check whether Γ ⊆ Γapp. It follows from item (1) of Proposition 4.1 that
the latter can be done using space exponential in maxvar(Γ) and |Γapp|, and hence
double-exponential in |Γ| (since Γapp can be of exponential size in |Γ|). This provides
us with an easy 2Expspace procedure for checking semantic acyclicity of UC2RPQs.
To obtain an Expspace procedure we exploit Theorem 4.2. Observe ﬁrst that the
width w(Γapp) of Γapp is at most the maximum number of atoms over its disjuncts,
is at most polynomial in |Γ|. Since Γapp is acyclic,
which by Lemma 5.5 item 3.
Theorem 4.2 tells us that the problem of checking Γ ⊆ Γapp can be decided using
O((|Γ| + |Γapp|)C·w(Γapp)) space, for some constant C ≥ 1. Hence, from the fact that
w(Γapp) is polynomially bounded by |Γ| we obtain that checking Γ ⊆ Γapp can be
solved in Expspace. This gives an Expspace algorithm for checking whether Γ is
semantically acyclic. For the second part of the theorem, we output the query Γapp
if Γ ⊆ Γapp; otherwise, we reject the input.

We now provide a lower bound for the problem that shows that checking semantic

acyclicity of (U)C(2)RPQs is considerably harder than for UCQs.

Proposition 6.2. It is Expspace-hard to check whether a UC 2RPQ Γ is semantically 
acyclic. The problem remains Expspace-hard even if the input is restricted to
Boolean CRPQs.

Proof. First, we claim that checking containment of γ1 in γ2, where γ1 and γ2
are UC2RPQs, is Expspace-hard even when γ1 is a Boolean acyclic CRPQ, γ2 is a
Boolean CRPQ with U(γ2) connected, and γ2 is not semantically acyclic.

Indeed, it follows from [9] (also stated in item 2. of Proposition 4.1) that containment 
is Expspace-hard, even for γ1 and γ2 acyclic CRPQs. Moreover, the reduction
in [9] yields CRPQs γ1 and γ2 of the following form:

γ1(x1, x2) = (x1, E, x2),
γ2(x1, x2) = ∃y1∃y2

(cid:9)
(x1, E1, y1) ∧

(cid:9) (cid:2)

(cid:10)

(y1, Fi, y2)

0≤i≤n

(cid:10)
∧ (y2, E1, x2)

,

where E, E1, F0, . . . , Fn are RPQs over an alphabet Δ. We then construct Boolean
CRPQs γ

(cid:4)
1 and γ
1() = ∃x1∃x2
(cid:4)
2() = ∃x1∃x2∃y1∃y2∃z2∃z3∃w1∃w2∃w3
(cid:4)

(cid:4)
(cid:9)
2 from γ1, γ2 as follows:
(x1, E, x2) ∧ (x1, #1, x1) ∧ (x2, #2, x2) ∧
(cid:9) (cid:2)

(x1, #1, x1) ∧ (x2, #2, x2) ∧ (x1, E1, y1) ∧

(cid:9)

γ

γ

(cid:9) (cid:2)

b∈Σ

(y1, Fi, y2)

0≤i≤n

∧ (y2, E1, x2)
(cid:10)

(cid:10)(cid:10)

(x2, b, x2)

,

(cid:10)

∧ (x2, a, z2) ∧ (z2, a, z3) ∧ (z3, a, x2) ∧ (w1, $1, x2) ∧ (w2, $2, z2) ∧ (w3, $3, z3)

,

where Σ = {a, $1, $2, $3} is disjoint from Δ and #1, #2 are fresh symbols not in Δ∪Σ.
(cid:4)
1 is the Boolean version of γ1, where we have marked the free variables

Intuitively, γ

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1367

⊆ γ

(cid:4)
1

x1 and x2 of γ1 with special symbols #1 and #2, respectively, and appended a loop
labeled b to x2, for each b ∈ Σ. Similarly, γ
(cid:4)
2 is the Boolean version of γ2, where we
have again marked the free variables x1 and x2 of γ2 with special symbols #1 and
#2, respectively, and appended to x2 a copy of the (nonsemantically acyclic) query
γna from Example 6.

2 is a Boolean CRPQ such that U(γ
(cid:4)

On the other hand, assume that γ1 ∧ γ2 ≡ α, where α =

It is straightforward to show that γ1 ⊆ γ2 if and only if γ
(cid:4)
1 is a Boolean acyclic CRPQ and γ

(cid:4)
2. Note also
(cid:4)
that γ
2) is
(cid:4)
connected. Moreover, since γna is not semantically acyclic, it is easy to show that γ
2
is not semantically acyclic either. Thus containment is Expspace-hard even for these
kinds of queries. Next, we reduce this Expspace-hard restriction of the containment
problem to our problem of checking whether a query is semantically acyclic.
Let γ1 and γ2 be Boolean CRPQs such that γ1 is acyclic, U(γ2) is connected,
and γ2 is not semantically acyclic. We claim that γ1 is contained in γ2 if and only if
the CRPQ γ1 ∧ γ2 is semantically acyclic (we rename the variables of γ1 and γ2 so
they are disjoint in γ1 ∧ γ2). Assume ﬁrst that γ1 is contained in γ2. Then γ1 ∧ γ2 is
(cid:7)
equivalent to γ1, which is acyclic, and thus γ1 ∧ γ2 is semantically acyclic.
1≤i≤m αi and each αi
is an acyclic C2RPQ. Since γ1 ∧ γ2 ⊆ γ2, it follows that α ⊆ γ2. Also, since αi ⊆ α it
follows that αi ⊆ γ2, for each 1 ≤ i ≤ m. Let α1
i , . . . , αki
i be the C2RPQs associated
with each connected component of U(αi). Thus αi ≡ α1
i ∧···∧ αki
i . We show that for
i ⊆ γ2. Assume to the contrary.
each 1 ≤ i ≤ m, there exists 1 ≤ ji ≤ ki such that α
Then, by Proposition 4.4, there exist for each 1 ≤ j ≤ ki a canonical graph database
Gj for α
i ) is connected, then Gj also
is. Consider the disjoint union G of G1, . . . ,Gki . Clearly this is a canonical database
for αi. Since αi ⊆ γ2, it follows that γ2(G) = true. But U(γ2) is connected, which
implies that γ2(Gj ) = true, for some 1 ≤ j ≤ ki. This is a contradiction.
i . Notice that α ⊆ α
(cid:4)
. Hence there is a canonical database G∗

i such that γ2(Gj) = false. Note that since U(α

) = false. We now prove that γ1 ⊆ α
(cid:4)

(cid:4) ⊆ γ2. Note also that since γ2 is not semantically acyclic, it
for γ2 such
, which implies γ1 ⊆ γ2. Let G be a

nition, we have that α
(cid:4)
must be the case that γ2 (cid:2) α
(cid:4)
that α
canonical database for γ1. Consider the disjoint union G(cid:4)
is a
canonical database for γ1 ∧ γ2. Since γ1 ∧ γ2 ≡ α ⊆ α
(cid:4)
) = true.
) = true, for some 1 ≤ i ≤ m. Since U(α
ji
i ) is connected, it follows that
(G∗
(cid:4)
) = true. But α
) = false.
i (G) = true, and thus α
(G) = true. By Proposition 4.4, we
(cid:4)
ji
conclude that γ1 ⊆ α
(cid:4)

Then α
either α
We conclude that α

i (G(cid:4)
i (G) = true or α

(cid:4)
, it follows that α

(cid:4)
Consider the acyclic UC2RPQ α

(cid:7)
ji
1≤i≤m α

ji
) = false, and thus α

. This proves the proposition.

of G and G∗

. Clearly G(cid:4)

(G(cid:4)
i (G∗

(G∗

ji

ji

ji

j

=

. By deﬁj


ji

i (G∗

6.3. Evaluation of semantically acyclic UC2RPQs. With the help of Theorem 
6.1 we can provide an answer to our ﬁrst question regarding semantically acyclic
UC2RPQs: Its evaluation is ﬁxed-parameter tractable.

Theorem 6.3. The problem of checking whether ¯n ∈ Γ(G), for a given graph
database G, semantically acyclic UC 2RPQ Γ, and tuple ¯n of node ids in G, is ﬁxedparameter 
tractable.

Proof. Using the algorithm in Theorem 6.1 it is possible to compute in Expspace
. Clearly,
(i.e., in double-exponential time) an acyclic UC2RPQ Γ
¯n ∈ Γ(G) if and only if ¯n ∈ Γ
(G). From Theorem 3.1 the latter can be checked in time
(cid:4)|2), and hence in time O(|G|2 · 2p(|Γ|)), where p : N → N is a polynomial.
O(|G|2 · |Γ
Thus, semantically acyclic UC2RPQs can be evaluated in time O(f (|Γ|)+|G|2·2p(|Γ|)),
where p : N → N is a polynomial and f : N → N is a double-exponential function.

such that Γ ≡ Γ

(cid:4)

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1368

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

a

a

$

b

Fig. 6.4. The query γ from Proposition 6.4.

6.4. Features of the language: Inverses. The algorithm in Theorem 6.1
introduces inverses in the construction of an equivalent acyclic query, even if we start
from a semantically acyclic UCRPQ (i.e., a UC2RPQ without inverses). A natural
question is whether this is necessary, that is, whether there are semantically acyclic
UCRPQs that ﬁnd an equivalent query in the class of acyclic UC2RPQs, but not in
the class of acyclic UCRPQs. We prove that this is the case.

Proposition 6.4. There is a semantically acyclic CRPQ that is not equivalent

to any acyclic UCRPQ.

(cid:4)

−

Proof. The Boolean query γ = ∃w, x, y, z((w, $, x), (x, b, y), (z, a, y), (z, a, x)) that
is graphically depicted in Figure 6.4 is semantically acyclic. In fact, it is equivalent
to the acyclic C2RPQ ∃x∃y((x, $, y) ∧ (y, ba
a, y)). For the sake of contradiction,
suppose there is an acyclic UCRPQ γ
equivalent to γ. It follows from Proposition
4.4 that there exists a canonical database Gγ(cid:2) , and homomorphisms h and g from Gγ
to Gγ(cid:2), and from Gγ(cid:2) to Gγ, respectively, where Gγ is the canonical database of γ.
Observe that Gγ(cid:2) is pseudoacyclic (recall the deﬁnitions from section 5.2.1), and since
is a UCRPQ, each internal node in Gγ(cid:2) has in-degree and out-degree 1. Suppose
(cid:4)
γ
ﬁrst that h(x), h(y), h(z) are distinct elements in Gγ(cid:2) . It follows that the in-degree of
h(x) and h(y) is 2, and the out-degree of h(z) is 2. By the observation above, we have
that h(x), h(y), h(z) must be external nodes in Gγ(cid:2) , which contradicts the acyclicity
. Then, h(x), h(y), h(z) are not distinct in Gγ(cid:2). This is also a contradiction, as
of γ
it implies that there is an a-labeled or b-labeled loop in Gγ(cid:2) , and thus g cannot be an
homomorphism.

(cid:4)

(cid:4)

(cid:4)

(cid:4)

6.5. Features of the language: Unions. The algorithm that constructs an
equivalent acyclic UC2RPQ Γ
for a semantically acyclic UC2RPQ Γ (Theorem 6.1)
even if Γ is a C2RPQ. But is this necessary? That
outputs a union of C2RPQs Γ
is, is there a C2RPQ Γ that is semantically acyclic, but yet it is not equivalent to a
single acyclic C2RPQ Γ
? We currently do not have an answer to this question. But
as the following example shows, ﬁnding such an answer might not be as simple as one
thinks beforehand. This is due to the interplay of regular expressions in C2RPQs,
which allows for intricate ways of expressing unions of C2RPQs as single C2RPQs.
Example 7. Let γ be the CRPQ over Σ = {a, b} shown in Figure 6.5, where aε
and bε are abbreviations for (a + ε) and (b + ε), respectively. This query has four
nonequivalent canonical databases, which are depicted in Figure 6.6. Notice that each
one of these canonical databases is acyclic, and, therefore, γ is semantically acyclic
(as a C2RPQ is always equivalent to the union of CQs represented by its canonical
databases).

Somewhat surprisingly, γ is also equivalent to the single CRPQ γ

shown in Figure
6.7. In fact, it is tedious but not diﬃcult to verify that each one of the canonical
databases of γ shown in Figure 6.6 satisﬁes γ
and, conversely, that each canonical
database of γ

satisﬁes γ. From this we conclude that γ ≡ γ

(cid:4)

(cid:4)

(cid:4)

(cid:4)

.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1369

a

aε

bε

b

a

a

aε

bε

b

b

Fig. 6.5. The CRPQ γ from Example 7.

a

a

b

a

b

b

a

a

a

b

b

b

a

a

b

b

a

b

a

a

a

b

b

b

Fig. 6.6. The four canonical databases of γ.

aa

a
aa + ε

b
bb + ε

a

b

bb

Fig. 6.7. The acyclic CRPQ γ(cid:3)

which is equivalent to γ.

7. Conclusions and open problems. We have studied the space of UCQs
and UC2RPQs deﬁned by the notion of acyclicity. This is relevant since acyclicity
is a robust explanation for the tractability of several query languages for relational
and graph databases. Furthermore, some notions of acyclicity explain the linear-time
behavior of various querying mechanisms for graph databases (e.g., XPath [35], PDL
[28], nested regular expressions [5], etc.).

While the results about semantic acyclicity of UCQs follow from techniques in
CSP, studying the notion of semantic acyclicity of UC2RPQs requires new tools and
insights. We have shown that it is Expspace-complete to check whether a UC2RPQ
is semantically acyclic, and that this shows that evaluation of queries in the class
is ﬁxed-parameter tractable. The techniques used to prove decidability also yield a
strong theory of approximations of UC2RPQs.

As far as the notion of semantic acyclicity of UC2RPQs is concerned, in this work
we have only uncovered the tip of the iceberg. Many questions remain open and we
list some of them below.

Complexity. We have proven that evaluation of semantically acyclic UC2RPQs
is ﬁxed-parameter tractable. But is it also polynomial? Tractability of semantically
acyclic UCQs follows from a sophisticated characterization of the problem in terms of
winning strategies in the existential pebble game, but we do not know whether those
techniques can be extended to deal with UC2RPQs.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1370

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

Size of equivalent acyclic queries. The algorithm presented in Theorem 6.1
computes an equivalent acyclic query of single-exponential size for a semantically
Is this optimal, i.e., is there a family (Γn)n≥1 of semantically
acyclic UC2RPQ.
acyclic UC2RPQs such that (1) |Γn| is polynomially bounded by n, and (2) the
smallest acyclic UC2RPQ that is equivalent to Γn is of size Ω(2n), for each n ≥ 1?
Beyond acyclic queries. Acyclicity is a simple syntactic criterion that ensures
In the last decades several
eﬃcient evaluation of CQs, but it is not the only one.
criteria have been identiﬁed that extend acyclicity in diﬀerent ways while retaining
polynomial time evaluation for the CQs that satisfy them. Most of these criteria are
based on the idea of restricting evaluation to CQs θ of bounded treewidth [13, 17],
which are also deﬁned in terms of the existence of a tree decomposition of θ with
desirable properties.

It is known that the results in section 2 (Theorem 2.2 and Proposition 2.3) also
apply to UCQs that are equivalent to unions of CQs of bounded treewidth [17, 14].
That is, such classes of UCQs can be evaluated in polynomial time, and it is NPcomplete 
to check whether a CQ is equivalent to a CQ of treewidth at most k, for
each k ≥ 1.

On the other hand, our results for UC2RPQs are speciﬁcally designed for semantic
acyclicity, and we do not know at this point how to extend them to verify whether
a UC2RPQ is equivalent to a UC2RPQ of bounded treewidth. In the same way, one
might be interested in extending results on approximations of UC2RPQs to classes of
bounded treewidth, as it has been done for UCQs [6].

Beyond C2RPQs. Instead of working with C2RPQs one could also consider the
class of conjunctions of nested regular expressions (CNREs), that properly extends
the former [5]. Acyclicity of CNREs also leads to tractability, and thus it makes sense
to study semantic acyclicity in this extended setting. The problem is relevant since
several linear-time query languages for graph databases are contained in the class of
CNREs but not in the class of UC2RPQs [28, 5].

Enumeration. In the evaluation problem, we are given a query θ, a database
D, and a tuple ¯t, and we have to decide whether ¯t belongs to the evaluation of θ
over D. However, in many practical applications it is also useful to enumerate the
tuples that belong to the evaluation of θ over D. The complexity of this enumeration
problem has been studied for several query languages, e.g., (U)CQs [8, 27]. It follows
from [27] that the tuples in the evaluation of a semantically acyclic UCQs can be
enumerated with polynomial delay. This means that there is an algorithm that, given a
semantically acyclic UCQ Θ and a database D, enumerates Θ(D) (without repetitions)
in such a way that (i) the ﬁrst tuple is produced in polynomial time, and (ii) each
subsequent tuple is produced within polynomial time from the previously produced
tuple. Notice that this tractability result actually extends Theorem 2.2. An important
open question is whether we can obtain a similar tractability result for enumerating
the output of semantically acyclic UC2RPQs.

CSP for C2RPQs. Our work can also be viewed as opening a new line of
research in constraint satisfaction. As noted above, there is an intimate connection
between CQ evaluation and constraint satisfaction. In general this problem is NPcomplete,
 but there is an extensive body of research studying tractable cases, either
by ﬁxing the database and focusing on expression complexity, or by studying the
combined complexity of restricted classes of queries [21, 32]. The same approach,
ﬁxing the database or restricting the class of queries, can also be applied to the

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1371

evaluation of C2RPQs. In particular, as noted above, it is an open question whether
the class of semantically acyclic C2RPQs is an “island of tractability” in the sense of
[32], that is, whether its evaluation problem is tractable.

8. Appendix.

Proof of Theorem 2.2. The existential k-cover game was introduced in [14],
in order to deﬁne tractable restrictions of the constraint satisfaction problem. This
game is a variant of the existential k-pebble game deﬁned by Kolaitis and Vardi [31].
In the k-cover game, instead of imposing the Spoiler to use at most k pebbles—as
in the existential k-pebble game—he is allowed to use any number of pebbles, but
only as long as the set of elements where the pebbles are placed can be covered by at
most k tuples in the database where the Spoiler is playing. We skip here the formal
deﬁnition of the k-cover game but recall some important properties of the game that
were proved in [14].

.

Proposition 8.1. The following hold:
1. There is a polynomial time algorithm that, given databases D and D(cid:4)

over the
same schema, decides whether the Duplicator has a winning strategy in the
1-cover game on D and D(cid:4)
2. Assume that the Duplicator has a winning strategy in the 1-cover game on D
. Then for each acyclic Boolean CQ θ it is the case that θ(D) = true
and D(cid:4)
implies θ(D(cid:4)
(cid:8)m
Let θ(¯x) = ∃¯y

i=1 Pi(¯ui) be a CQ over schema σ. As usual, we deﬁne the
canonical database Dθ of θ to be the database over σ whose facts are precisely the
Pi(¯ui)’s, for 1 ≤ i ≤ m. The proof of the theorem makes use of the following wellknown 
characterization of containment of UCQs in terms of evaluation over canonical
databases, which is due to Sagiv and Yannakakis.

) = true.

(cid:7)
1≤i≤m θi(¯x) and Θ

(cid:4)

(cid:7)
1≤j≤n θ

(cid:4)

(¯x) =

j(Dθi ).
(cid:4)

Proposition 8.2 (see [39]). Let Θ(¯x) =

(cid:4)
j(¯x)
be UCQs. Then Θ(¯x) ⊆ Θ
(¯x) if and only if for each 1 ≤ i ≤ m there exists 1 ≤ j ≤ n
such that ¯x ∈ θ
Let D be a database over schema σ and ¯a = (a1, . . . , ar) a tuple of elements over
D. We denote by (D, ¯a) the database over σ∪{P1, . . . , Pr}, where P1, . . . , Pr are fresh
symbols, obtained from D by adding the new facts P1(a1), . . . , Pr(ar).

(cid:7)
We now present an algorithm for evaluating semantically acyclic UCQs. Given
1≤i≤m θi(¯x), a database D, and a tuple ¯a of
a semantically acyclic UCQ Θ(¯x) =
elements in D, the algorithm checks whether there is an index i ∈ {1, . . . , m} such that
the Duplicator has a winning strategy in the 1-cover game on (Dθi, ¯x) and (D, ¯a). If
this is the case, it accepts (i.e., it declares that ¯a ∈ Θ(D)); otherwise it rejects. From
the ﬁrst part of Proposition 8.1 it follows that this algorithm runs in polynomial time.
We show next that the algorithm is sound and complete.
Assume ﬁrst that ¯a ∈ Θ(D). Then, ¯a ∈ θi(D), for some 1 ≤ i ≤ m. By
deﬁnition, there is a homomorphism h from θi (or, equivalently, from Dθi) to D such
In particular, h is also an homomorphism from (Dθi , ¯x) to (D, ¯a).
that h(¯x) = ¯a.
This trivially implies the existence of a winning strategy for the Duplicator in the 1cover 
game on (Dθi, ¯x) and (D, ¯a). Therefore, the algorithm accepts. (Notice that in
this direction the assumption that Θ is semantically acyclic is not used.) Conversely,
suppose that the algorithm accepts. Then there exists a winning strategy for the
Duplicator in the 1-cover game on (Dθi, ¯x) and (D, ¯a), for some 1 ≤ i ≤ m. Let
(cid:4)
(cid:4)
j(¯x) be an acyclic UCQ which is equivalent to Θ. By Proposition
Θ

(cid:7)
1≤j≤n θ

(¯x) =

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpPABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

1372
8.2, there exists 1 ≤ j ≤ n such that ¯x ∈ θ
obtained from θ
Then, θ
follows that θ
Since Θ

(cid:4)(cid:4)
j be the acyclic Boolean CQ
(cid:4)
j(¯x) by adding the atoms P1(x1), . . . , Pr(xr), where ¯x = (x1, . . . , xr).
(cid:4)(cid:4)
j , it
(D).
j ((D, ¯a)) = true, and, thus, ¯a ∈ θ
(cid:4)(cid:4)

j ((Dθi, ¯x)) = true. Using the second part of Proposition 8.1 with θ = θ
(cid:4)(cid:4)
j(D). This implies that ¯a ∈ Θ
(cid:4)
(cid:4)
(cid:4) ≡ Θ, we conclude that ¯a ∈ Θ(D).

j(Dθi). Let θ
(cid:4)

Proof of Proposition 2.3. For the membership in NP we show that if Θ(¯x)
(¯x) whose size is
is semantically acyclic, then it is equivalent to an acyclic UCQ Θ
bounded by the size of Θ. Then, given a UCQ Θ(¯x), the NP algorithm guesses an
(¯x). The
acyclic UCQ Θ
latter can be done in NP [12], and hence the whole procedure is in NP.

(cid:4)| ≤ |Θ|, and then checks whether Θ(¯x) ≡ Θ

(¯x) with |Θ

(cid:4)

(cid:4)

(cid:4)

Let θ(¯x) be a CQ. We say that a CQ θ

(¯x),
and (b) no CQ with strictly fewer atoms than θ
is equivalent to θ. It is known (see,
e.g., [29]) that each CQ θ(¯x) has a unique (up to isomorphism) core, and thus we can
talk about the core of θ(¯x). We make use of the following proposition in our proof.

(cid:4)

(cid:4)

(¯x) is a core of θ [29, 12] if (a) θ(¯x) ≡ θ

(cid:4)

Proposition 8.3. If θ is an acyclic CQ, then the core of θ is also acyclic.

Proof. We show the claim in two steps. First, we show that the class of acyclic
CQs is closed under taking strong induced subqueries. Then we prove that the core of
a CQ θ is always a strong induced subquery.

For each atom P of θ we denote by VP the set of variables that are mentioned in

P . A CQ θ

is a strong induced subquery of a CQ θ if the following hold:

1. The set Vθ(cid:2) of variables mentioned in θ

is contained in the set Vθ of variables

(cid:4)

(cid:4)

are exactly the atoms of θ induced by the variables in Vθ(cid:2).

are exactly the free variables of θ.

, then there exists an atom P

(cid:4)

(cid:4)

in θ

that

mentioned in θ.
(cid:4)
2. The atoms of θ
3. The free variables of θ
4. If P is an atom in θ but not in θ

contains all the variables in VP ∩ Vθ(cid:2) .

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Suppose θ is an acyclic CQ and let θ

) such that, for each t ∈ T , λ
(cid:4)

(t) = λ(t)∩ Vθ(cid:2) . Clearly, (T, λ
(cid:4)

) such that ˜λ(t) is a hyperedge of H(θ

be a strong induced subquery of θ. Let
(T, λ) be a tree decomposition of H(θ) witnessing the acyclicity of θ. Consider the tree
(cid:4)
decomposition (T, λ
) is a
tree decomposition of H(θ
). We now show that we can transform the decomposition
) into a tree decomposition ( ˜T , ˜λ) of H(θ
(cid:4)
(T, λ
),
for each t ∈ ˜T . This would imply that θ
Let t ∈ T be a node such that λ
(cid:4)
). By deﬁnition,
λ(t) is a hyperedge of H(θ). We can then pick an atom P in θ such that the set of
(t) = VP ∩ Vθ(cid:2) .
(cid:4)
variables VP mentioned in P is precisely λ(t). Then, by deﬁnition, λ
By condition 4. in the deﬁnition of strong induced subquery, there is an atom P
in
(t) = VP ∩ Vθ(cid:2) ⊆ VP (cid:2) . Moreover, by deﬁnition of tree decomposition,
(cid:4)
θ
∗ ∈ T such that VP (cid:2) ⊆ λ
(cid:4)
there is a node t
). Applying
standard techniques (see, e.g., [24]), we can remove the node t from T while preserving
the tree decomposition properties. Iteratively applying this modiﬁcation, we end up
with a tree decomposition ( ˜T , ˜λ) that witnesses the acyclicity of θ

(cid:4)
(t) is not a hyperedge of H(θ

(cid:4)
). It follows that λ

is acyclic, as required.

(cid:4)
such that λ

(t) ⊆ λ
(cid:4)

(t

(t

∗

∗

(cid:4)

(cid:4)

(cid:4)

(cid:4)

.

Finally, we show that the core θ

(¯x) of a CQ θ(¯x) is a strong induced subquery.
Indeed, it follows from well-known core properties [29] that conditions 1., 2., and 3.
in the deﬁnition of strong induced subquery hold. We prove next that condition 4.
also holds. Again by well-known properties of cores [29], we can assume without loss
, i.e., a homomorphism from Dθ
of generality that there is a retract h from θ to θ
to D(cid:4)
(cid:4)
. Let P = R(u1, . . . , um) be an
atom in θ but not in θ
. Then it is the case that R(h(u1), . . . , h(um)) is an atom of

θ that is the identity over the variables Vθ(cid:2) of θ

(cid:4)

(cid:4)

(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1373

(cid:4)

. Since h is the identity in VP ∩ Vθ(cid:2), we conclude that condition 4. holds.

θ

We also make use of the following proposition in our proof.
Proposition 8.4. Let θ(¯x) be a CQ. Then θ(¯x) is semantically acyclic if and

only if its core is acyclic.

(¯x) =

(cid:4)
i. Since θ

(cid:7)
1≤i≤m θ

i(¯x) such that θ(¯x) ≡ Θ
(cid:4)

Proof. The if direction is trivial since θ and its core are equivalent. For the only
if direction, assume that θ is semantically acyclic. Then there is an acyclic UCQ
(cid:4)
(¯x). It then follows from Proposition 8.2
Θ
that there is some i ∈ {1, . . . , m} for which it is the case that θ ≡ θ
(cid:4)
i is
acyclic, we have from Proposition 8.3 that its core is also acyclic. On the other hand,
it is known (see, e.g., [29]) that equivalent CQs have the same core (up to renaming of
(cid:4)
variables). It follows that the core of θ coincides with the core of θ
i (up to renaming
of variables), and, therefore, it is acyclic.
(¯x) with |Θ

Now we turn to our initial claim: If Θ(¯x) is a semantically acyclic UCQ, then it is
(cid:4)| ≤ |Θ|. Assume that Θ(¯x) is semantically
equivalent to an acyclic UCQ Θ
(¯x) be an equivalent acyclic UCQ. Further, let Θmin be a subset of
acyclic and let Θ
the disjuncts in Θ such that (1) Θmin is equivalent to Θ, and (2) no proper subset of
(cid:4)
Θmin is equivalent to Θ. Analogously, we deﬁne Θ
min to be “minimally” equivalent
. By minimality, there are no distinct disjuncts θ1 and θ2 in Θmin such that
to Θ
(cid:4)
min, it follows that, for each
(cid:4)
min. Thus, each disjunct of
be the UCQ obtained from Θmin, by replacing
is acyclic. Moreover,

disjunct θ of Θmin, there is an equivalent disjunct θ
Θmin is semantically acyclic. Let Θ
each disjunct by its core. From Proposition 8.4, we have that Θ
∗ ≡ Θ and |Θ
Θ

θ2 ⊆ θ1. From Proposition 8.2 and the fact that Θmin ≡ Θ

∗| ≤ |Θ|. This completes the proof of the NP upper bound.

in Θ

∗

∗

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

The lower bound follows from [17], which shows that the problem of checking
whether a Boolean CQ over a single binary relation is equivalent to an acyclic one is
NP-hard.

Proof of Lemma 5.7. We start introducing some terminology. A two-way

nondeterminisitic ﬁnite automaton (2NFA) [30, 42] is a tuple B = (Σ, Q, Q0, δ, F ),
where Σ is a ﬁnite alphabet, Q is a ﬁnite set of states, Q0 ⊆ S is the set of initial
states, δ : Q × Σ → 2Q×{−1,0,1}
is the transition function, and F ⊆ Q is the set of
ﬁnal states. Intuitively, a transition indicates both the new state of the automaton
and whether the head should move left (−1), move right (1), or stay in place (0). A
conﬁguration of B is a pair (q, j) consisting of a state q ∈ Q and a position represented
as an integer j ≥ 0. The sequence (q0, j0), . . . , (qm, jm) of conﬁgurations of B is an
accepting run of B on a word w = a0 . . . a(cid:3)−1 ∈ Σ
, for (cid:11) ≥ 0, if (i) q0 ∈ Q0, (ii) j0 = 0,
(iii) qm ∈ F , (iv) jm = (cid:11), and (v) for each i ∈ {0, . . . , m − 1} we have that 0 ≤ ji < (cid:11)
and ji+1 = ji + d. The 2NFA
and there is some (q
B accepts w if it has an accepting run on w. The following fact is well known [42].

, d) ∈ δ(qi, aji ) such that qi+1 = q

∗

(cid:4)

(cid:4)

Proposition 8.5. Given a 2NFA with n states, one can construct an equivalent
Assume that A1, . . . ,Am is an enumeration of all the NFAs over Σ
±

NFA with O(2n log n) states.
mentioned
in Γ. For the Γ-type π and 1 ≤ i ≤ 4, we denote by π(i) the ith coordinate of π. Let
1 ≤ j ≤ m and assume that Aj = (Σ
, Q, Q0, δ, F ), where δ is a transition function
are states of Aj . We then deﬁne a 2NFA
of the form Q × Σ → 2Q, and that q and q
Bit(j, q, q

±

(cid:4)

(cid:4)

) that accepts the following language:
{z ∈ (Σ

∗ | (Aj, q, q
)

±

(cid:4)

) ∈ πz(1), where πz is the Γ-type of z}.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpPABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

1374
Intuitively, Bit(j, q, q
) guesses a folding from the ﬁrst to the last position of z and
in Aj (as this implies, by
veriﬁes that such folding can be read from state q to q
deﬁnition, that (Aj, q, q
) can
be constructed in such a way that its size is bounded by O(|Aj|), and thus by O(|Γ|).

) belongs to πz(1)). It is not hard to see that Bit(j, q, q

(cid:4)

(cid:4)

(cid:4)

(cid:4)

Similarly, we deﬁne a 2NFA Bti(j, q, q

(cid:4)

{z ∈ (Σ

±

∗ | (Aj, q, q
)

(cid:4)

) ∈ πz(2), where πz is the Γ-type of z}.

) that accepts the following language:

(cid:4)

This NFA also guesses a folding from the ﬁrst to the last position of z—which represents 
the “inverse” of a folding from the last position of z to the ﬁrst one—and then
to q in Aj (as this imveriﬁes 
that such folding can be read “backwards” from state q
plies, by deﬁnition, that (Aj, q, q
) belongs to π2(z)). As before, the 2NFA Bti(j, q, q
(cid:4)
)
can be easily constructed in such a way that its size is bounded by O(|Aj|), and thus
by O(|Γ|).
) and Ati(j, q, q
Let Ait(j, q, q
(cid:4)
2NFAs Bit(j, q, q
) and Bti(j, q, q
(cid:4)
(cid:4)
the number of states in Ait(j, q, q
polynomial s : N → N.

) be the NFAs over Σ
which are equivalent to the
), respectively, according to Proposition 8.5. Thus,
) and Ati(j, q, q
(cid:4)
) is bounded by O(2s(|Γ|)), for a

±

(cid:4)

(cid:4)

(cid:4)

We now explain how to construct an NFA Aii(j, q, q

(cid:4)

) which accepts the following

language:

{z ∈ (Σ

±

∗ | (Aj, q, q
)

(cid:4)

) ∈ πz(3), where πz is the Γ-type of z}.

±

(cid:4)

(cid:4)

(cid:4)

) which accepts the following language:

Notice that if z = a0 . . . a(cid:3)−1, where each ak is a symbol in Σ
, then the triple
) belongs to πz(3) if and only if there is a state p of Aj and a position
(Aj , q, q
0 ≤ k ≤ (cid:11) − 1 such that (Aj, q, p) ∈ πzk (1) and (Aj , p, q
) ∈ πzk (2), where for each
0 ≤ k ≤ (cid:11) − 1 we have that zk = a0 . . . ak. Then for each state p of Aj we deﬁne an
NFA Aii(j, q, p, q
{z ∈ (Σ
of z}.
It is easy to deﬁne the NFA Aii(j, q, p, q
) by (i) taking the cross product between
Ait(j, q, p) and Ati(j, p, q
), (ii) adding an ε-transition from each ﬁnal state of this
cross product to a fresh state f , (iii) adding a transition a from f to f , for each
a ∈ Σ
±
, and (iv) letting f be the unique ﬁnal state of the resulting NFA. The NFA
Aii(j, q, q

∗ | (Aj , q, p) ∈ πz(cid:2) (1) and (Aj , p, q
)

) is then deﬁned as the union of all the NFAs in the set

) ∈ πz(cid:2) (2), for some preﬁx z

±

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

{Aii(j, q, p, q

(cid:4)

) | p is a state in Aj}.

The number of states of Aii(j, q, q

(cid:4)

) is O(2s(cid:2)

(|Γ|)) for a polynomial s

(cid:4)

: N → N.

Using the previous idea it is then straightforward to construct an NFA Att(j, q, q

(cid:4)

)

which accepts the following language:

{z ∈ (Σ

±

∗ | (Aj , q, q
)

(cid:4)

) ∈ πz(4), where πz is the Γ-type of z}.

In order to construct the NFA Aπ which accepts the language L⊆

Again, the number of states of Att(i, q, q
(π), we proceed
as follows. We ﬁrst deﬁne NFAs Ait,Ati,Aii, and Att as the product of the NFAs in
the sets

) is O(2s(cid:2)

(|Γ|)).

(cid:4)

{Ait(j, q, q
) ∈ π(1), 1 ≤ j ≤ m},
) | (Aj , q, q
(cid:4)
(cid:4)
{Ati(i, q, q
) ∈ π(2), 1 ≤ j ≤ m},
) | (Aj , q, q
(cid:4)
(cid:4)
) ∈ π(3), 1 ≤ j ≤ m},
) | (Aj , q, q
{Aii(j, q, q
(cid:4)
(cid:4)
{Att(j, q, q
) | (Aj, q, q
) ∈ π(4), 1 ≤ j ≤ m},
(cid:4)
(cid:4)

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.phpSEMANTIC ACYCLICITY ON GRAPH DATABASES

1375
respectively. Then we deﬁne Aπ as the product of Ait,Ati,Aii, and Att. It is straightforward 
to check that the language accepted by Aπ is precisely L⊆
(π). Further, the
: N → N. Thus the size of
number of states of Aπ is O(2s(cid:2)(cid:2)
Aπ is at most exponential in |Γ|, as required.

(|Γ|)), for a polynomial s

(cid:4)(cid:4)

Acknowledgment. We are very grateful to Gaelle Fontaine for helpful discussions 
about the role of unions in approximations of UC2RPQs, and for providing us
with Example 7.

REFERENCES

[1] S. Abiteboul, P. Buneman, and D. Suciu, Data on the Web: From Relations to Semistructured 
Data and XML, Morgan Kauﬀman, Burlington, MA, 1999.

[2] R. Angles and C. Guti´errez, Survey of graph database models, ACM Comput. Surv., 40

(2008), 1.

[3] P. Barcel´o, Querying graph databases, in Proceedings of the 32nd Symposium on Principles

of Database Systems, PODS’13, ACM, New York, 2013, pp. 175–188.

[4] P. Barcel´o, L. Libkin, A. W. Lin, and P. Wood, Expressive languages for path queries over

graph-structured data, ACM T. Database Syst., 37 (2012), 31.

[5] P. Barcel´o, J. Perez, and J. Reutter, Relative expressiveness of nested regular expressions,
in Proceedings of the 6th Alberto Mendelzon International Workshop on Foundations of
Data Management, AMW’12, 2012, pp. 180–195.

[6] P. Barcel´o, L. Libkin, and M. Romero, Eﬃcient approximations of conjunctive queries,

SIAM J. Comput. 43 (2014), pp. 1085–1130, doi:10.1137/130911731.

[7] P. Barcel´o, M. Romero, and M. Y. Vardi, Semantic acyclicity on graph databases,

in
Proceedings of the 32nd ACM Symposium on Principles of Database Systems, PODS’13,
ACM, New York, 2013, pp. 237–248.

[8] A. Bulatov, V. Dalmau, M. Grohe, and D. Marx, Enumerating homomorphisms, J. Comput.
 System Sci., 78 (2012), pp. 638–650.

[9] D. Calvanese, G. de Giacomo, M. Lenzerini, and M. Y. Vardi, Containment of conjunctive
regular path queries with inverse, in Proceedings of the 7th International Conference on
Principles of Knowledge Representation and Reasoning, KR’00, 2000, pp. 176–185.

[10] D. Calvanese, G. de Giacomo, M. Lenzerini, and M. Y. Vardi, Rewriting of regular expressions 
and regular path queries, J. Comput. System Sci., 64 (2002), pp. 443–465.

[11] D. Calvanese, G. de Giacomo, M. Lenzerini, and M. Y. Vardi, View-based query answering
and query containment over semistructured data, in Proceedings of the 8th International
Workshop on Database Programming Languages, DBPL’02, Lecture Notes in Comput. Sci.
2397, Springer-Verlag, Berlin, Heidelberg, 2002, pp. 40–61.

[12] A. K. Chandra and P. M. Merlin, Optimal implementation of conjunctive queries in relational 
data bases, in Conference Record of the 9th Annual ACM Symposium on Theory of
Computing, STOC’77, ACM, New York, 1977, pp. 77–90.

[13] C. Chekuri and A. Rajaraman, Conjunctive query containment revisited, Theoret. Comput.

Sci., 239 (2000), pp. 211–229.

[14] H. Chen and V. Dalmau, Beyond hypertree width: Decomposition methods without decompositions,
 in Proceedings of the 11th International Conference on Principles and Practice
of Constraint Programming, CP’05, Lecture Notes in Comput. Sci. 3709, Springer-Verlag,
Berlin, Heidelberg, 2005, pp. 167–181.

[15] M. P. Consens and A. O. Mendelzon, GraphLog: A visual formalism for real life recursion, in
Proceedings of the Ninth ACM Symposium on Principles of Database Systems, PODS’90,
ACM New York, 1990, pp. 404–416.

[16] I. Cruz, A. O. Mendelzon, and P. T. Wood, A graphical query language supporting recursion,
in Proceedings of the ACM SIGMOD Conference, SIGMOD’87, ACM, New York, 1987,
pp. 323–330.

[17] V. Dalmau, Ph. G. Kolaitis, and M. Y. Vardi, Constraint satisfaction, bounded treewidth,
and ﬁnite-variable logics, in Proceedings of the 8th International Conference on Principles
and Practice of Constraint Programming, CP’02, Lecture Notes in Comput. Sci. 2470,
Springer-Verlag, Berlin, Heidelberg, 2002, pp. 310–326.

[18] R. Fagin, Degrees of acyclicity for hypergraphs and relational database schemes, J. ACM, 30

(1983), pp. 514–550.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php1376

PABLO BARCEL ´O, MIGUEL ROMERO, AND MOSHE Y. VARDI

[19] W. Fan, J. Li, S. Ma, N. Tang, and Y. Wu, Graph pattern matching: From intractable to
polynomial time, Proceedings of the VLDB Endowment, 3 (2010), pp. 264–275, doi:10.
14778/1920841.1920878.

[20] W. Fan, J. Li, S. Ma, N. Tang, and Y. Wu, Adding regular expressions to graph reachability

and pattern queries, Front. Comput. Sci., 6 (2012), pp. 313–338.

[21] T. Feder and M. Y. Vardi, The computational structure of monotone monadic SNP and
constraint satisfaction: A study through datalog and group theory, SIAM J. Comput., 28
(1998), pp. 57–104, doi:10.1137/S0097539794266766.

[22] G. Fletcher, M. Gyssens, D. Leinders, D. Surinx, J. van den Bussche, D. Van Gucht, S.
Vansummeren, and Y. Wu, Relative expressive power of navigational querying on graphs,
Inform. Sci., 298 (2015), pp. 390–406.

[23] D. Florescu, A. Levy, and D. Suciu, Query containment for conjunctive queries with regular 
expressions, in Proceedings of the 17th ACM Symposium on Principles of Database
Systems, PODS’98, ACM, New York, 1998, pp. 139–148.

[24] J. Flum, M. Frick, and M. Grohe, Query evaluation via tree-decompositions, J. ACM, 49

(2002), pp. 716–752.

[25] G. Gottlob, N. Leone, and F. Scarcello, The complexity of acyclic conjunctive queries, J.

ACM, 48 (2001), pp. 431–498.

[26] G. Gottlob, N. Leone, and F. Scarcello, Hypertree decompositions and tractable queries,

J. Comput. System Sci., 64 (2002), pp. 579–627.

[27] G. Greco and F. Scarcello, Structural tractability of enumerating CSP solutions, Constraints,
 18 (2013), pp. 38–74.

[28] D. Harel, D. Kozen, and J. Tiuryn, Dynamic Logic, MIT Press, Cambridge, MA, 2000.
[29] P. Hell and J. Neˇseˇtril, Graphs and Homomorphisms, Oxford University Press, Oxford,

UK, 2004.

[30] J. E. Hopcroft and J. D. Ullman, Introduction to Automata Theory, Languages, and Computation,
 Addison-Wesley, Reading, MA, 1979.

[31] Ph. G. Kolaitis and M. Y. Vardi, On the expressive power of Datalog: Tools and a case

study, J. Comput. System Sci., 51 (1995), pp. 110–134.

[32] Ph. G. Kolaitis and M. Y. Vardi, A logical approach to constraint satisfaction, in The Book
Complexity of Constraints: An Overview of Current Research Themes, N. Creignou, P. G.
Kolaitis, and H. Vollmer, eds., Lecture Notes in Comput. Sci. 5250, Springer-Verlag, Berlin,
Heidelberg, 2008, pp. 125–155.

[33] Ph. G. Kolaitis and M. Y. Vardi, Conjunctive query-containment and constraint satisfaction,

J. Comput. System Sci., 61 (2002), pp. 302–332.

[34] R. E. Ladner, R. J. Lipton, and L. J. Stockmeyer, Alternating pushdown and stack automata,
 SIAM J. Comput., 13 (1984), pp. 135–155, doi:10.1137/0213010.

[35] L. Libkin, W. Martens, and D. Vrgoc, Querying graph databases with XPath, in Proceedings
of the 16th International Conference on Database Theory, ICDT’13, ACM, New York, 2013,
pp. 129–140.

[36] Ch. H. Papadimitriou and M. Yannakakis, The complexity of facets (and some facets of

complexity), J. Comput. System Sci., 28 (1986), pp. 244–259.

[37] Ch. H. Papadimitriou and M. Yannakakis, On the complexity of database queries, in Proceedings 
of the 16th ACM Symposium on Principles of Database Systems, PODS’97, ACM,
New York, 1997, pp. 12–19.

[38] J. Reutter, M. Romero, and M. Y. Vardi, Regular queries on graph databases, in Proceedings 
of the 18th International Conference on Database Theory, ICDT’15, Schloss Dagstuhl.
Leibniz-Zent. Inform., Wadern, 2015, pp. 177–194.

[39] Y. Sagiv and M. Yannakakis, Equivalences among relational expressions with the union and

diﬀerence operator, J. ACM, 27 (1980), pp. 633–655.

[40] R. Tarjan and M. Yannakakis, Simple linear-time algorithms to test chordality of graphs, test
acyclicity of hypergraphs, and selectively reduce acyclic hypergraphs, SIAM J. Comput., 13
(1984), pp. 566–579, doi:10.1137/0213035.

[41] M. Y. Vardi, The complexity of relational query languages (extended abstract), in STOC 1982,

ACM, New York, 1982, pp. 137–146.

[42] M. Y. Vardi, A note on the reduction of two-way automata to one-way automata, Inform.

Process. Lett., 30 (1989), pp. 261–264.

[43] P. T. Wood, Query languages for graph databases, SIGMOD Record, 41 (2012), pp. 50–60.
[44] M. Yannakakis, Algorithms for acyclic database schemes, in Proceedings of the 7th International 
Conference on Very Large Data Bases, 1981, pp. 82–94.

                                                                     Copyright © by SIAM. Unauthorized reproduction of this article is prohibited. Downloaded 07/22/18 to 200.9.97.193. Redistribution subject to SIAM license or copyright; see http://www.siam.org/journals/ojsa.php