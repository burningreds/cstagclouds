Regular Languages of Nested Words: Fixed Points,

Automata, and Synchronization

Marcelo Arenas1, Pablo Barcel´o2, and Leonid Libkin3

1 Pontiﬁcia Universidad Cat´olica de Chile

2 Universidad de Chile
3 University of Edinburgh

Abstract. Nested words are a restriction of the class of visibly pushdown languages 
that provide a natural model of runs of programs with recursive procedure
calls. The usual connection between monadic second-order logic (MSO) and automata 
extends from words to nested words and gives us a natural notion of regular 
languages of nested words.

In this paper we look at some well-known aspects of regular languages – their
characterization via ﬁxed points, deterministic and alternating automata for them,
and synchronization for deﬁning regular relations – and extend them to nested
words. We show that mu-calculus is as expressive as MSO over ﬁnite and inﬁnite
nested words, and the equivalence holds, more generally, for mu-calculus with
past modalities evaluated in arbitrary positions in a word, not only in the ﬁrst
position. We introduce the notion of alternating automata for nested words, show
that they are as expressive as the usual automata, and also prove that Muller automata 
can be determinized (unlike in the case of visibly pushdown languages).
Finally we look at synchronization over nested words. We show that the usual
letter-to-letter synchronization is completely incompatible with nested words (in
the sense that even the weakest form of it leads to an undecidable formalism) and
present an alternative form of synchronization that gives us decidable notions of
regular relations.

1 Introduction

The class of visibly pushdown languages (VPL) has been introduced by Alur and Madhusudan 
[5] as a restriction of the class of context-free languages that subsumes all
regular properties and some non-regular properties relevant in program analysis (e.g.
stack-inspection properties and pre-post conditions). VPLs in many ways resemble regular 
languages: they have the same closure properties, and most natural problems related 
to them are decidable. The intuitive idea of VPLs is that the input alphabet Σ is
partitioned into three parts, Σc, Σr, Σi, of symbols viewed as procedure calls, returns,
and internal operations. A machine model for VPLs is a special pushdown automaton
that pushes a symbol onto the stack in a call, pops one symbol in a return, and does not
touch the stack when reading an internal symbol.

Nested words [6] replaced the implicit nesting structure of calls and returns by an
explicit relation that matches calls and returns. A nested word is thus a word extended
with a hierarchical structure on top of its linear structure. An example of such a nested
structure of matching calls ci and returns ri is given below.

L. Arge et al. (Eds.): ICALP 2007, LNCS 4596, pp. 888–900, 2007.
c(cid:2) Springer-Verlag Berlin Heidelberg 2007

Regular Languages of Nested Words

889

c1

c2

c3

r3

c4

r4

r2

c5

c6

r6

r5

c7

r7

r1

Such structures naturally appear, for instance, in XML documents that are string
representations of trees using opening and closing tags [23,8], or in software veriﬁcation
of programs with stack-based control ﬂow [4,2]. A nested word automaton [6] runs from
left to right, similarly to a ﬁnite state automaton, but each time it encounters a “return”
position, the next state depends not only on the current state but also on the state of the
matching “call”.

A nice property of nested words and their automata is that they share logical characterizations 
with the usual (unnested) words: the automaton model has the same expressiveness 
as monadic second-order logic (MSO) [5,6]. This gives us a natural and robust
notion of regular languages of nested words, with the expected closure properties, decision 
procedures, and logical characterizations.

For ﬁnite or inﬁnite unnested words, an alternative way of describing regularity logically 
is via the modal μ-calculus (cf. [7]). That is, μ-calculus formulae evaluated in
the ﬁrst position of a word deﬁne precisely the regular languages. Moreover, μ-calculus
formulae with past modalities evaluated in an arbitrary position of a word have precisely 
the power of MSO formulae with one free ﬁrst-order variable. As our ﬁrst result,
we extend these equivalences to the case of ﬁnite and inﬁnite nested words.

We then look at automata characterizations of VPLs and nested words. Nondeterministic 
and deterministic automata have previously been considered [5,6,18], and [5]
showed that automata can be determinized in the ﬁnite case, but in the inﬁnite case this
is impossible even for automata with a Muller acceptance condition (unlike in the case
of the usual ω-words), if one considers VPLs. Then [18] introduced a different automaton 
model and showed that it admits a determinization procedure over nested words. We
expand this in two ways. First we introduce alternation in the case of nested word automata,
 and prove that alternating automata can still be translated into nondeterministic
ones. Second, we reﬁne the determinization procedure for automata from [18] to show
that over inﬁnite nested words, every regular language is deﬁnable by a deterministic
Muller automaton. This also gives us some corollaries about the structure of regular
languages of nested ω-words.

We ﬁnally turn our attention to the notion of regular relations. Over words, one
moves from sets to relations by using letter-to-letter synchronization. That is, an automaton 
runs over a tuple of words viewing the tuple of ith letters of the words as a
single letter of an expanded alphabet [15]. The same approach works for trees, ranked
and unranked [11]. The notion of regular relations also leads to a notion of automatic
structures [12,13,10], i.e. decidable ﬁrst-order structures over words in which all deﬁnable 
relations are regular.

Here we show that, in contrast to the case of words and trees, the notion of letter-
to-letter synchronization is incompatible with nested words: the simplest extension of
nested word automata with such synchronization is undecidable. We present an alternative 
call-return notion of synchronization, and show that it gives us a natural concept of
regular relations over nested words.

890

M. Arenas, P. Barcel´o, and L. Libkin

Related work. VPLs were introduced in [5] and nested words in [6]. They can be
viewed as special classes of trees (and we shall use this often in the paper); such tree
representations were introduced in [5,6] as well. Applications in program analysis are
discussed, e.g., in [2,4], and applications in processing tree-structured data in [23,8].

There are several related results on μ-calculus and MSO, e.g. their equality over
inﬁnite binary trees [20] or ﬁnite unranked trees [9] or expressive-completeness of
μ-calculus [16]. We explain in Section 3 why we cannot derive our result from those.
Another ﬁxed-point logic VPμ is deﬁned in [2] to specify properties of executions of
programs. It differs from the standard versions of μ-calculus we look at as its ﬁxed
points are evaluated not over sets of nodes but over sets of subtrees of the program;
further, its expressiveness is known to be different from MSO [3].

Automata for VPLs and nested words were deﬁned in [5,6], and [5] observed that
Muller automata are not determinizable. Then [18] noticed that this is due to VPLs
having potentially arbitrarily many unmatched calls/returns, and introduced a different
automaton model (stair automata) that can be determinized. We use them to show how
to determinize Muller automata over nested ω-words. None of these papers addresses
alternating automata over nested words.

Letter-to-letter synchronization for deﬁning regular relations is an old notion [15],
and the concept of universal automatic structures [13,12] is based on it. Although such
automatic structures exist for both words and trees [10,11], we show here that letter-toletter 
synchronization is incompatible with nesting structure.

Organization. Basic deﬁnitions are given in Section 2. We describe MSO unary queries
via μ-calculus in Section 3. In Section 4 we study automata for nested words, deﬁne
alternating automata, and describe determinization for Muller automata. In Section 5
we look at synchronization and regular relations for nested words.

2 Preliminaries

∗

Words, ω-words, and automata. Let Σ be a ﬁnite alphabet. A ﬁnite word w =
is represented as a logical structure (cid:2){1, . . . , n} , (Pa)a∈Σ , <(cid:3), where
a1 . . . an in Σ
< is the usual linear order on {1, . . . , n}, and Pa is the set of i’s such that ai = a. We
shall use w to refer to both the word and its logical representation. Inﬁnite, or ω-words,
are sequences a1a2 ··· of symbols in Σ indexed by positive natural numbers, and are
represented as structures (cid:2)N+, (Pa)a∈Σ, <(cid:3). The length of w is denoted by |w|.
A (nondeterministic) automaton A over Σ is a tuple (Σ, Q, Q0, δ, F ), where Q is
a ﬁnite set of states, Q0 ⊆ Q is a set of initial states, F ⊆ Q is a set of ﬁnal states
and δ : Q × Σ → 2Q is a transition function. For automata over ω-words we shall
use either a B¨uchi acceptance condition (given by F ⊆ Q) or a Muller acceptance
condition (given by F ⊆ 2Q). A run of A over a word w is a map ρ : {1, . . .} → Q
such that ρ(1) ∈ Q0 and ρ(i + 1) ∈ δ(ρ(i), ai), for all i. A ﬁnite run is accepting if
ρ(|w| + 1) ∈ F . We let Inf (ρ) be the set of states that occurs inﬁnitely often in an
inﬁnite run ρ. Then ρ is accepting for a B¨uchi condition F if Inf (ρ) ∩ F (cid:8)= ∅, and it is
accepting for a Muller condition F if Inf (ρ) ∈ F. A word is accepted iff there exists
an accepting run. Sets of (ω-)words accepted by automata are called regular.

Regular Languages of Nested Words

891

(cid:4)

(cid:4)

(cid:4)

(cid:4)

(cid:4)

or j

(cid:4)

(cid:4)

, j

and η(i, j) and η(i

, j) imply i = i

then either j < i

(cid:4)), and i < i

(cid:4)) imply j = j

A is deterministic if |Q0| = 1, and |δ(q, a)| = 1 for for every a ∈ Σ and q ∈ Q.
Nondeterministic automata over ω-words with B¨uchi and Muller conditions are equivalent,
 and automata with Muller acceptance condition can be determinized, cf. [25].
Nested words. A ﬁnite nested word over Σ is a pair ¯w = (w, η), where w ∈ Σ
∗
and η is a binary matching relation on {1, . . . ,|w|} that satisﬁes: (1) η(i, j) implies
i < j; (2) η(i, j) and η(i, j
; and
(3) if η(i, j), η(i
< j. A nested ω-word is
a pair ¯w = (w, η), where w is an ω-word and η is a matching on N+. We also refer
to them as inﬁnite nested words. We represent nested words as logical structures over
the vocabulary {(Pa)a∈Σ, <, η}, i.e. words expanded with a matching relation. For a
nested word ¯w and two positions i < j, we let ¯w[i, j] be the substructure of ¯w induced
by positions (cid:7) such that i ≤ (cid:7) ≤ j. A position i of a nested word ¯w is: (1) a call position
if there is j such that η(i, j) holds; (2) a return position if there is j such that η(j, i)
holds; and (3) an internal position if it is neither a call nor a return. Whenever η(i, j)
holds we say that i is the call of j, and j is the return of i.
Nested word automata. A nested word automaton, or NWA [6], A over Σ is deﬁned
as a usual automaton, except that δ is a triple (δc, δι, δr) of transition functions δc, δι :
Q × Σ → 2Q, and δr : Q × Q × Σ → 2Q. A run of A over ¯w = (a1 ··· , η) is a
mapping ρ : {1, . . .} → Q such that ρ(1) ∈ Q0 and for every i ∈ N+ (or i ∈ [1,| ¯w|]
for ﬁnite nested words),
– if i is a call position, then ρ(i + 1) ∈ δc(ρ(i), ai);
– if i is an internal position, then ρ(i + 1) ∈ δι(ρ(i), ai);
– if i is a return position whose call is j, then ρ(i + 1) ∈ δr(ρ(i), ρ(j), ai).
B¨uchi and Muller acceptance conditions can then be deﬁned in exactly the same way
as for the usual automata (and are easily shown to be equivalent over nested words,
for nondeterministic automata). We refer to such automata as ω-NWAs. An NWA is
deterministic if the values of all transition functions are singletons.

A class of nested (ω-)words accepted by an (ω-)NWA is called regular.

Monadic second-order logic and μ-calculus. Monadic second-order logic (MSO) extends 
ﬁrst-order logic with quantiﬁcation over sets. Over nested words, its vocabulary
contains predicates Pa (a ∈ Σ), < and η. A class of nested (ω-)words is regular iff it is
deﬁnable by an MSO sentence [5,6].

The μ-calculus over nested words, denoted by Lμ, is deﬁned by the grammar:
| ¬ϕ | 3ϕ | 3ηϕ | μX.ϕ(X)

:= a | X | ϕ ∨ ϕ
(cid:4)

| ϕ ∧ ϕ
(cid:4)

(cid:4)
ϕ, ϕ

with X occurring positively in ϕ(X), and a ∈ Σ ∪ {call, int, ret}. Given a nested
(ω-)word ¯w, a position i in ¯w, and a valuation v assigning each free variable X a set of
positions of ¯w, the semantics is as follows (omitting the rules for Boolean connectives):
– ( ¯w, v, i) |= int iff i is an internal position; ( ¯w, v, i) |= call iff i is a call position;
and ( ¯w, v, i) |= ret iff i is a return position.
– ( ¯w, v, i) |= a, for a ∈ Σ, iff i is labeled a.
– ( ¯w, v, i) |= X iff i ∈ v(X).

M. Arenas, P. Barcel´o, and L. Libkin

(cid:4) | ( ¯w, v[P/X], i

ϕ and 3−
ϕ iff i > 1 and ( ¯w, v, i − 1) |= ϕ.
η ϕ iff there is an (cid:7) such that η((cid:7), i) holds and ( ¯w, v, (cid:7)) |= ϕ.

892
– ( ¯w, v, i) |= 3ϕ iff i + 1 belongs to ¯w and ( ¯w, v, i + 1) |= ϕ.
– ( ¯w, v, i) |= 3ηϕ iff there is an (cid:7) such that η(i, (cid:7)) holds and ( ¯w, v, (cid:7)) |= ϕ.
– ( ¯w, v, i) |= μX.ϕ(X) iff i is in the least ﬁxed point of the operator deﬁned by ϕ;
in other words, if i ∈ (cid:2){P | {i
(cid:4)) |= ϕ} ⊆ P}, where v[P/X]
extends the valuation v with v(X) = P .
The μ-calculus over words does not mention the modality 3ηϕ.
We shall also work with the full μ-calculus [28] (denoted by Lfull
extension of Lμ with the past modalities 3−
– ( ¯w, v, i) |= 3−
– ( ¯w, v, i) |= 3−
Greatest ﬁxed-points νX.ϕ(X) are deﬁnable in Lμ as ¬μX.¬ϕ(¬X). Using greatest
ﬁxed-points and 2ϕ (deﬁned as ¬3¬ϕ), one can push all negations to atoms in Lμ
formulae. For resulting formulae, an important parameter is the alternation-depth of
least and greatest ﬁxed-points [7]. We refer to Lk
μ as the fragment of Lμ that consists of
formulae of alternation depth at most k (e.g., the alternation-free fragment is L0
Languages and unary queries. Formulae of Lμ (without free variables) are satisﬁed in
positions of a nested word, and thus they give rise to classes of unary queries that return,
for ¯w, the set {i | ( ¯w, i) |= ϕ}. Every Lμ formula ϕ without free variables deﬁnes a
language { ¯w | ( ¯w, 1) |= ϕ}. Likewise, every MSO formula ϕ(x) with one free ﬁrstorder 
variable deﬁnes a unary query, and every MSO sentence deﬁnes a language. In the
absence of nesting, it is known [7,20] that a language (of words or ω-words) is deﬁnable
by a Lμ formula iff it is deﬁnable by an MSO sentence (not using relation η).

μ ), which is an

η ϕ:

μ).

3 Mu-Calculus over Nested Words

Since NWA generalize ﬁnite state automata, the translation from MSO to NWAs is
nonelementary. But just as for ﬁnite words or trees, one can ﬁnd equally expressive
logical formalisms with better model-checking complexity. We show that the equivalence 
MSO = Lμ extends from words and trees to nested words. It applies not only in
sentences evaluated in the ﬁrst position of a nested word, but more generally to unary
queries that select a set of positions. This is relevant for ﬁnite nested words viewed as
streaming XML documents: while theoretical investigations have mostly looked at the
case of sentences [23,8], in practical application one typically needs to evaluate unary
queries (e.g. XPath) over such streams [21]. To deal with unary queries, we look at Lμ
with the past, i.e. Lfull
Theorem 1. For ﬁnite nested words and nested ω-words, MSO and Lfull
same classes of unary queries.
As a corollary to the proof, we get
Corollary 1. The languages of nested words deﬁnable in MSO and Lμ are the same.
We can tighten this for ﬁnite nested words. Let (Lfull
μ )+ be the negation-free (and thus
alternation-free) fragment of Lfull
that has two additional constants “ﬁrst” and “last”
with their intuitive meanings: “ﬁrst” holds only at the ﬁrst position of a nested word,
and “last” holds at the last position. Likewise we deﬁne (Lμ)+ from Lμ.

μ , and prove that it is equivalent to MSO unary queries. That is:

deﬁne the

μ

μ

Regular Languages of Nested Words

893

Corollary 2. For unary queries over ﬁnite nested words, MSO = Lfull
μ )+.
Furthermore, MSO, Lμ, and (Lμ)+ deﬁne the same languages of ﬁnite nested words.
μ )+ formula ϕ and every ﬁnite nested word

From [14], we conclude that for every (Lfull
¯w, the set {i | ( ¯w, i) |= ϕ} can be computed in time O(|ϕ| · | ¯w|).

μ = (Lfull

We make a couple of remarks about the proof of Theorem 1. Nested words are naturally 
translated into trees, and there is a closely related result in the literature, Niwinski’s
theorem, showing that over the full inﬁnite binary tree, MSO and Lμ, evaluated in the
root of the tree, are equally expressive [20]. Despite this, there does not seem to be any
easy adaptation of proof techniques in [20] that yields a proof of Theorem 1. Not only
do we need a stronger result for unary queries and an extension with the past modalities,
but in addition translations of inﬁnite nested words are not complete binary trees.

Another natural attempt at a proof is to use the expressive-completeness result of
Janin and Walukiewicz: every bisimulation-invariant MSO property is deﬁnable in Lμ
[16]. Then we could express runs of tree automata on tree encodings of nested words
by bisimulation-invariant MSO sentences, apply [16] to get an equivalent Lμ formula
for trees, and translate it into an Lμ formula over nested words. This sketch indeed
can be turned into a proof of MSO = Lμ for languages of nested words, but it breaks
already for unary queries over ﬁnite nested words, where one needs to encode a more
complicated run of a query automaton [19], and it is even harder to adapt this argument
to inﬁnite nested words for which we do not have an automaton model capturing unary
queries. Thus, our proof is a direct argument based on the composition method.

4 Automata Models for Nested ω-Words

Nested ω-word automata. Visibly pushdown automata (VPA), with both B¨uchi and
Muller acceptance conditions, were introduced in [5], and shown to be equivalent to
MSO, but not necessarily determinizable. The example of a VPL that cannot be accepted 
by a deterministic automaton [5] can use arbitrarily many calls without matching
returns, something that cannot happen in nested words. Then [18] introduced a notion
of stair visibly pushdown automata (stair VPA) to control such unmatched calls and
showed that stair VPAs are determinizable. These models were deﬁned for VPLs, so
we ﬁrst specialize a particular class of stair VPAs [18] to nested words, thereby obtaining 
a notion of combined nested word automata, that admit determinization. We then
use such automata to show that over nested words, for every ω-NWA (with a B¨uchi or a
Muller acceptance condition), there exists an equivalent deterministic Muller ω-NWA.
A combined nested word automaton (CNWA) puts together an ω-word automaton A1
with a Muller acceptance condition and a ﬁnite NWA A2. It runs A1 over all positions
that are not inside a call. Every time A1 ﬁnds a call position i, it invokes A2 to process
the ﬁnite nested word formed by the elements between i and its matching return j, and
then it uses its ﬁnal state to determine what state to assign to j + 1, and continues its
run from position j + 1. Formally, a CNWA A over Σ is a pair (A1,A2), where:
– A2 = (Σ, Q2, Q0
– A1 = (Σ ∪ Q2, Q1, Q0
assume, of course, that Σ and Q2 are disjoint).

1, δ1,F1) is an ω-word automaton over alphabet Σ ∪ Q2 (we

r)) is an NWA without accepting states;

2, δ2 = (δ2

c , δ2

ι , δ2

M. Arenas, P. Barcel´o, and L. Libkin

894
Given a nested ω-word ¯w and i ≥ 1, we deﬁne the set of external positions E( ¯w) as
positions i such that there are no j, k ≥ 1 such that j < i ≤ k and η(j, k) holds. Note
that 1 ∈ E( ¯w) and E( ¯w) is inﬁnite. If i ∈ E( ¯w) is not a call, then i + 1 ∈ E( ¯w). If
i ∈ E( ¯w) is a call with j being its matching return, then the next, after i, element of
E( ¯w) is j + 1. With this, we deﬁne a run of A over a nested ω-word ¯w = (a1a2 ··· , η)
as a mapping ρ : E( ¯w) → Q1 such that ρ(1) ∈ Q0
– if i is not a call (and i + 1 ∈ E( ¯w)), then ρ(i + 1) ∈ δ1(ρ(i), ai);
– if i is a call with return j (and the successor of i in E( ¯w) is j + 1), then ρ(j + 1) ∈
δ1(ρ(i), q), where q is a state in Q2 such that there exists a run ρ2 of A2 over ¯w[i, j]
having q as the last state.

1 and for every i ∈ E( ¯w):

A CNWA A accepts ¯w if there is a run ρ of A over ¯w such that Inf (ρ) ∈ F1. We say
that CNWA A = (A1,A2) is deterministic if both A1 and A2 are deterministic. Then
results in [18] can be restated in this terminology as:

Proposition 1 ([18]). Over nested ω-words, CNWAs and deterministic CNWAs are
equivalent.

We show, by using standard techniques, that CNWA and MSO are equivalent, from
which the main result of this section follows:

Theorem 2. Over nested ω-words, MSO, ω-NWA and deterministic ω-NWA with
Muller acceptance condition, deﬁne precisely the regular languages. Moreover, translations 
between these formalisms are effective.

Determinization of ω-NWAs is done by translating them into CNWAs, determinizing
those (which involves a 2O(n log n) Safra construction [22] and a 2O(n2) determinization
procedure from [5]) and then translating back into ω-NWAs with Muller acceptance
condition. Putting these three components together, we get (note that the bound is the
same as for determinization of stair VPAs for VPLs [18]):

Corollary 3. For every ω-NWA with n states, there exists an equivalent deterministic
ω-NWA with a Muller acceptance condition and with 2O(n2) states.

It is well-known that a language of ω-words is regular (accepted by a B¨uchi or a Muller
automaton) iff it is a ﬁnite union of languages of the form U V ω, where U, V are regular
languages. Automata characterizations imply a similar result for nested ω-words.

Corollary 4. A language of nested ω-words is regular iff it is a ﬁnite union of languages
of the form U V ω where U and V are regular languages of ﬁnite nested words.

A basic problem in automata theory is the nonemptiness problem: is the language accepted 
by an automaton nonempty? It was shown in [5], that nonemptiness, and more
generally reachability problem for visibly pushdown ω-automata, is polynomial. Combining 
this with a NLOGSPACE algorithm for nonemptiness of ω-word automata, we
get polynomial nonemptiness algorithms for ω-NWA and CNWA. Further, a modiﬁcation 
of PTIME-hardness reduction for emptiness for context-free grammars gives us:

Corollary 5. The nonemptiness problem for ω-NWA and CNWA is PTIME-complete.

Regular Languages of Nested Words

895

It is easy to code a deterministic automaton by an L1
Corollary 6. Over nested ω-words, Lμ collapses to L1
μ.

μ formula. Thus,

Alternating automata for nested ω-words. In the context of formal veriﬁcation, alternating 
automata have proved to be the key to a comprehensive automata-theoretic
framework for temporal logics [27]. With the development of temporal logics for nested
words [4,2,1], it is natural to develop alternating automata for nested words, with the
hope that they can simplify the process of translating temporal logics into automata.

∗

We now deﬁne alternating automata for both ﬁnite and inﬁnite nested words, and
show that they are equivalent to NWAs. We note that this is in sharp contrast with the
theory of alternating automata for nested trees, where alternating automata are known
to be more expressive than nondeterministic automata [3].
First recall the deﬁnition of alternating automata for ﬁnite and inﬁnite words. Given a
set of states Q, let B+(Q) be the set of positive Boolean combinations of elements from
Q. Given X ⊆ Q and ϕ ∈ B+(Q), we say that X satisﬁes ϕ if the truth assignment σX
satisﬁes ϕ, where σX is deﬁned as σX(q) = 1 iff q ∈ X. Then an alternating (ω-)word
automaton A is a tuple (Σ, Q, Q0, δ, F ), where Q, Q0 and F are deﬁned as for the case
of word automata, and δ : Q × Σ → B+(Q) is a transition function.
A run of such an automaton is a labeled tree. A Σ-labeled tree T is a pair (D, λ),
such that (1) if x · i ∈ D and
where λ : D → Σ and D is a preﬁx-closed subset of N
0 ≤ j < i, then x · j ∈ D, and (2) for every x ∈ D, there exists a ﬁnite number of
, its length is denoted by |x|.
strings of the form x· i in D (ﬁnite branching). For x ∈ N
∗
The depth of a tree is maxx∈D |x|.
A run of an alternating word automaton A = (Σ, Q, Q0, δ, F ) over w = a1 ··· an
is a ﬁnite Q-labeled tree T = (D, λ) of depth n such that λ(ε) ∈ Q0 and for every
x ∈ D that has children x · 0, . . ., x · (cid:7) of length i, we have that {λ(x · 0), . . . , λ(x · (cid:7))}
satisﬁes δ(λ(x), ai). An alternating word automaton A accepts a word w if there is a
run T = (D, λ) of A over w such that λ(x) ∈ F for every node x in T of length n. The
run of an alternating ω-word automaton A = (Σ, Q, Q0, δ, F ) over an ω-word w =
a1a2 ··· is deﬁned in exactly the same way as an inﬁnite Q-labeled tree T = (D, λ).
Then A accepts ω-word w if there is an accepting run T = (D, λ) of A over w, i.e.
every inﬁnite branch ρ of T includes inﬁnitely many labels in F .
An alternating nested word automaton (or alternating NWA, or ANWA) is an NWA
that admits alternation in call, return, and internal transitions. Formally, an ANWA A is
a tuple (Σ, Q, Q0, δ, F ), where Q, Q0 and F are deﬁned as for the case of alternating
word automata, and δ is a triple (δc, δι, δr) of transition functions δc, δι : Q × Σ →
B+(Q), and δr : Q × Q × Σ → B+(Q). A run of A over ¯w = (a1 ··· an, η) is a
Q-labeled ﬁnite tree T = (D, λ) of depth n such that λ(ε) ∈ Q0 and for every x ∈ D
with children x · 0, . . ., x · (cid:7), of length i ≤ n:
– if |x| (i.e. i− 1) is a call position, then {λ(x·0), . . . , λ(x· (cid:7))} satisﬁes δc(λ(x), ai);
– if |x| is an internal position, then {λ(x · 0), . . . , λ(x · (cid:7))} satisﬁes δι(λ(x), ai);
– if |x| is a return position with matching call j and y is the preﬁx of x with |y| =
j − 1, then {λ(x · 0), . . . , λ(x · (cid:7))} satisﬁes δr(λ(x), λ(y), ai).

Note that if i − 1 is an internal position and x does not have children, then δι(λ(x), ai)
has to be a tautology, and likewise for call and return positions. An alternating nested

M. Arenas, P. Barcel´o, and L. Libkin

896
word automaton A accepts a nested word ¯w if there is a run T = (D, λ) of A over ¯w
such that λ(x) ∈ F for every node x in T of length n.

Proposition 2. For every alternating NWA, there exists an equivalent NWA.

This can be extended to nested ω-words. An alternating nested ω-word automaton (ω-
ANWA) A is a tuple (Σ, Q, Q0, δ, F ), where Q, Q0, δ and F are deﬁned exactly as for
ANWA. A run is deﬁned in the same way as above, and the acceptance condition again
states that along each inﬁnite branch, states from F are seen inﬁnitely often.

Theorem 3. For every ω-ANWA with n states, there exists (and can be effectively con-
structed) an equivalent ω-NWA with a B¨uchi acceptance condition and 2O(n4) states.

For the proof, we introduce a notion of alternating combined nested word automaton
(ACNWA) and provide a direct translation from ω-ANWA into ACNWA. Then by using
Proposition 2 and the fact that alternating ω-word automata can be translated into ωword 
automata [27], we give a translation from ACNWA into CNWA. Theorem 3 then
follows from Proposition 1. We note that Theorem 3 provides an exponential-time algorithm 
for checking nonemptiness of ANWAs and ω-ANWAs. Since even in the ﬁnite
case the problem is as hard as universality for ﬁnite tree automata [24], we get:

Corollary 7. The nonemptiness problem for both ANWAs and ω-ANWAs is EXPTIMEcomplete.


5 Synchronization of Nested Words

∗

Then regular k-ary relations over Σ are deﬁned as sets R ⊆ (Σ

Synchronization of words leads to a concept of regular relations. It ties together (syn-
chronizes) positions in several words, and then runs an automaton over them [15]. To
. Assume that # is a letter that is not in
be concrete, let w1, . . . , wk be words from Σ
Σ. Let n = maxi |wi|, and let [(w1, . . . , wk)] be a word of length n constructed as follows.
 It is over the alphabet (Σ∪{#})k, and its ith letter is a k-tuple ai = (ai
k),
1, . . . , ai
j is the ith letter of wj if i ≤ |wj|, and # if i > |wj|. That is, we pad
where each ai
words shorter than n with #’s to make them all of length n, and then take the ith letter
of [(w1, . . . , wk)] to be the tuple of the ith letters of these padded words.
∗)k such that the set
{[(w1, . . . , wk)] | (w1, . . . , wk) ∈ R} is accepted by an automaton over the alphabet
(Σ ∪ {#})k [13,12]. Such automata are called letter-to-letter automata.Regular relations 
are closed under Boolean combinations, product, and projection. This makes it
with decidable ﬁrst-order theories whose depossible 
to ﬁnd inﬁnite structures over Σ
ﬁnable sets are precisely the regular relations (these are universal automatic structures,
,≺, (Pa)a∈Σ, el(cid:3), where
cf. [13,12]). The most commonly used such structure is (cid:2)Σ
≺ is the preﬁx relation, Pa(w) is true iff the last letter of w is a, and el(w, w
(cid:4)) (the
equal-length predicate) holds iff |w| = |w

∗

∗

(cid:4)| [13,12,10].

We now study synchronization for nested words. We show that the usual letter-toletter 
synchronization for words is completely incompatible with the nesting structure
because even the simplest nested extension of letter-to-letter automata is undecidable.

Regular Languages of Nested Words

897

We propose a different decidable synchronization scheme for nested words that gives
us regular relations with all the expected properties.
Letter-to-letter nested word automata.Assume that we have k nested words ¯w1, . . . , ¯wk,
and we again pad the shorter words with a special symbol # so that all of them are of
the same length n. Let [( ¯w1, . . . , ¯wk)] be such a nested word over the alphabet (Σ ∪
{#})k, and let ai be its ith letter. The letter-to-letter automaton runs from left to right
on [( ¯w1, . . . , ¯wk)], as an NWA. The main difference with NWAs is that each position
i may now be a return position in several of the ¯wj’s, and thus states in several call
positions determine the next state.

: Q × Q

That is, in a k-letter-to-letter NWA over k-tuples of nested words, we have multiple
|X| × (Σ ∪ {#})k → 2Q, indexed by nonempty X ⊆
return transitions δX
{1, . . . , k}. Suppose i is a return position in ¯wl1 , . . . , ¯wlm, where 1 ≤ l1 < . . . < lm ≤
r
k and m > 0. If j1, . . . , jm are the matching calls, i.e. ηl1(j1, i), . . . , ηlm(jm, i) hold,
then ρ(i + 1) depends on ρ(i), ai, and the states in positions j1, . . . , jm:

ρ(i + 1) ∈ δ

r

{l1,...,lm}

(ρ(i), ρ(j1), . . . , ρ(jm), ai).

For positions without returns, we have one transition δ : Q × (Σ ∪ {#})k → 2Q.

We show that even a much simpler automaton is undecidable. Deﬁne a simpliﬁed
k-letter-to-letter NWA as a k-letter-to-letter NWA with one return transition is δr :
Q × Q × (Σ ∪ {#})k → 2Q, just as in the usual NWA. The condition on the run is as
follows: if i is a return position in words ¯wl1 , . . . , ¯wlm, for 1 ≤ l1 < . . . < lm ≤ k,
then ρ(i + 1) ∈ δr(ρ(i), ρ(j1), ai), where j1 is the call of i in ¯wl1. In other words, we
look at the state of only one call position, corresponding to the return with the smallest
index. For all other positions we have a single transition δ : Q × (Σ ∪ {#})k → 2Q.

If k = 1, these are the usual NWAs. But if k = 2, they are undecidable.

nw, Θ(cid:3) (where Σ
∗
iff ¯w = ¯w

Theorem 4. The nonemptiness problem is undecidable for simpliﬁed 2-letter-to-letter
NWAs (and thus for k-letter-to-letter NWAs for k > 1).
Thus, there is no hope to use even the simplest possible form of letter-to-letter synchronization 
in nested words. As another example of such incompatibility, we show that
there are no natural decidable extensions of universal automatic structures on words
to nested words. We look at structures M = (cid:2)Σ
∗
nw is the set of all ﬁnite 
nested words over Σ) of a vocabulary Θ. We assume that Θ includes some basic
(cid:4)[1, m] for some m ≤ | ¯w
(cid:4)|
relations. One is a preﬁx relation ¯w (cid:16)nw ¯w
(so we can refer to the linear structure of nested words). The other allows us to refer 
to the nesting structure: we relate a preﬁx ¯w of ¯w
, there is a call-
. That is, ¯w (cid:16)η ¯w
(cid:4)
return edge from the last position of ¯w to the last position of ¯w
iff ¯w = ¯w
. We say that M deﬁnes all regular languages 
of nested words if for each such language L, there is a formula ϕL(x) such
| M |= ϕ( ¯w)}. We say that M deﬁnes all regular relations over
that L = { ¯w ∈ Σ
words if for each regular relation R ⊆ (Σ
∗)k, there is a formula ψR(x1, . . . , xk) such
that M |= ψR( ¯w1, . . . , ¯wk)} iff (w1, . . . , wk) ∈ R (recall that wi is a word from Σ
∗
obtained by removing the nesting structure from ¯wi).
nw,(cid:16)nw,(cid:16)η, . . .(cid:3) that deﬁnes all regular
Proposition 3. There is no structure M = (cid:2)Σ
∗
languages of nested words, all regular relations over words, and has a decidable theory.

(cid:4)[1, m], and η(m,| ¯w

so that in ¯w

(cid:4)|) holds in ¯w

(cid:4)

∗
nw

(cid:4)

(cid:4)

(cid:4)

(cid:4)

898

M. Arenas, P. Barcel´o, and L. Libkin

Call-return synchronization. As the usual letter-to-letter synchronization is incompatible 
with nested words, we propose a different, call-return synchronization. Intuitively,
instead of synchronizing positions with the same index i in different words, we synchronize 
positions for which the shortest paths to them (from the ﬁrst position) are the same.
To formalize this, we use a notion of a summary path introduced recently in connection
with the study of LTL-like logics on nested ω-words [1]. A summary path to a position
i in a nested word ¯w is the shortest path from 1 to i that combines both successor and
matching edges. That is, it is a sequence 1 = i0 < i1 < . . . < ik = i such that, if il is
a call with η(il, j) and i ≥ j, then η(il, il+1) holds, and otherwise il+1 = il + 1. We
represent this summary path as a word a1 . . . ak over the alphabet Λ = {i, c, m}:
1. if il = il−1 + 1 and il−1 is not a call, then al = i (path goes via an internal edge);
2. if il = il−1 + 1 and il−1 is a call, then al = c (path goes via a call edge);
3. if η(il−1, il) holds, then al = m (path goes via a matching edge).
If both i1 = il−1 + 1 and η(il−1, il) hold, we let al be m. The unique summary path to
position i will be denoted by πη
, and the set of all summary paths by Π η( ¯w).
The label of πη

¯w(i) is the label of i in ¯w. Note that Π η( ¯w) is closed under preﬁx.

¯w(i) ∈ Λ

∗

The idea of the call-return synchronization is that now with each position i,
we keep its summary paths πη
¯w(i), to remember how it was reached in different
nested words. That is, a call-return synchronization of nested words ¯w1, . . . , ¯wk
is a pair (Π η( ¯w1, . . . , ¯wk), λ) where Π η( ¯w1, . . . , ¯wk) =
l Π η( ¯wl), and λ :
Π η( ¯w1, . . . , ¯wk) → (Σ ∪ {#})k is a labeling function that labels each summary path
with its label in ¯wi if it occurs in ¯wi, and with # otherwise, for each i ≤ k. This
synchronization can naturally be viewed as a tree.

(cid:3)

As an example, consider two nested words below, ¯w1 (on the left) and ¯w2 (on the

right), with summary paths shown above positions.

ε

1

i

2

ic

3

ici

4

im

5

imi

6

ε

1

i

2

ic

3

im

4

imi

imii

5

6

The synchronization occurs in the ﬁrst and the second position, and we recursively
synchronize the calls (from i) and what follows their returns (from im). Intuitively, this
results in adding a dummy internal node ici inside the call for ¯w2, and adding a dummy
last internal position imii for ¯w2. Note that position 4 (i.e. ici) in ¯w1 is in no way related
to position 4 (im) in ¯w2, as it would have been in letter-to-letter synchronization.

∗
nw)k is a regular k-ary relation of nested words iff there
is a tree automaton on ternary trees that accepts precisely (Π η( ¯w1, . . . , ¯wk), λ), for
( ¯w1, . . . , ¯wk) ∈ R. The following is an immediate consequence of coding tree representations 
in MSO, and of the work on automatic structures over trees [11]:

We now say that R ⊆ (Σ

Proposition 4.

– Regular relations of nested words are closed under union, intersection,
 complementation, product, and projection.

– Regular 1-ary relations of nested words are precisely the regular nested languages.
∗
– There is a ﬁnite collection Θ of unary and binary predicates on Σ
nw such that
(cid:2)Σ
nw, Θ(cid:3) is a universal automatic structure for nested words, i.e. its deﬁnable rela-
∗
tions are precisely the regular relations of nested words, and its theory is decidable.

Regular Languages of Nested Words

899

Acknowledgments. We thank Rajeev Alur, Kousha Etessami, and Neil Immerman for
helpful discussions. Arenas was supported by FONDECYT grants 1050701, 7060172
and 1070732; Arenas and Barcel´o by grant P04-067-F from the Millennium Nucleus
Centre for Web Research; Libkin by the EC grant MEXC-CT-2005-024502, EPSRC
grant E005039, and by an NSERC grant while on leave from U. Toronto.

References

1. Alur, R., Arenas, M., Barcel´o, P., Etessami, K., Immerman, N., Libkin, L.: First-order and

temporal logics for nested words. In: LICS 2007

2. Alur, R., Chaudhuri, S., Madhusudan, P.: A ﬁxpoint calculus for local and global program

ﬂows. In: POPL 2006, pp. 153–165.

3. Alur, R., Chaudhuri, S., Madhusudan, P.: Languages of nested trees. In: Ball, T., Jones, R.B.

(eds.) CAV 2006. LNCS, vol. 4144, pp. 329–342. Springer, Heidelberg (2006)

4. Alur, R., Etessami, K., Madhusudan, P.: A temporal logic of nested calls and returns. In:
Jensen, K., Podelski, A. (eds.) TACAS 2004. LNCS, vol. 2988, pp. 467–481. Springer, Heidelberg 
(2004)

5. Alur, R., Madhusudan, P.: Visibly pushdown languages. In: STOC 2004, pp. 202–211.
6. Alur, R., Madhusudan, P.: Adding nesting structure to words. In: Ibarra, O.H., Dang, Z. (eds.)

DLT 2006. LNCS, vol. 4036, pp. 1–13. Springer, Heidelberg (2006)

7. Arnold, A., Niwinski, D.: Rudiments of μ-calculus. North-Holland, Amsterdam (2001)
8. B´ar´any, V., L¨oding, C., Serre, O.: Regularity problems for visibly pushdown languages. In:
Durand, B., Thomas, W. (eds.) STACS 2006. LNCS, vol. 3884, pp. 420–431. Springer, Heidelberg 
(2006)

9. Barcel´o, P., Libkin, L.: Temporal logics over unranked trees. In: LICS 2005, pp. 31–40.
10. Benedikt, M., Libkin, L., Schwentick, T., Segouﬁn, L.: Deﬁnable relations and ﬁrst-order

query languages over strings. J. ACM 50(5), 694–751 (2003)

11. Benedikt, M., Libkin, L., Neven, F.: Logical deﬁnability and query languages over ranked
and unranked trees. In: ACM TOCL. Extended abstract in LICS’02 and LICS’03, vol. 8(2),
ACM Press, New York (2007)

12. Blumensath, A., Gr¨adel, E.: Automatic structures. In: LICS 2000, pp. 51–62.
13. Bruy`ere, V., Hansel, G., Michaux, C., Villemaire, R.: Logic and p-recognizable sets of integers.
 Bull. Belg. Math. Soc. 1, 191–238 (1994)

14. Cleaveland, R., Steffen, B.: A linear-time model-checking algorithm for the alternation-free
modal mu-calculus. In: Larsen, K.G., Skou, A. (eds.) CAV 1991. LNCS, vol. 575, pp. 48–58.
Springer, Heidelberg (1992)

15. Elgot, C., Mezei, J.: On relations deﬁned by generalized ﬁnite automata. IBM J. Res. Develop.
 9, 47–68 (1965)

16. Janin, D., Walukiewicz, I.: On the expressive completeness of the propositional mu-calculus
with respect to monadic second order logic. In: Sassone, V., Montanari, U. (eds.) CONCUR
1996. LNCS, vol. 1119, pp. 263–277. Springer, Heidelberg (1996)

17. Lautemann, C., Schwentick, T., Th´erien, D.: Logics for context-free languages. In: Pacholski,

L., Tiuryn, J. (eds.) CSL 1994. LNCS, vol. 933, pp. 205–216. Springer, Heidelberg (1995)

18. L¨oding, C., Madhusudan, P., Serre, O.: Visibly pushdown games. In: Lodaya, K., Mahajan,

M. (eds.) FSTTCS 2004. LNCS, vol. 3328, pp. 408–420. Springer, Heidelberg (2004)

19. Neven, F., Schwentick, Th: Query automata over ﬁnite trees. TCS 275, 633–674 (2002)
20. Niwinski, D.: Fixed points vs. inﬁnite generation. In: LICS 1988, pp. 402–409

900

M. Arenas, P. Barcel´o, and L. Libkin

21. Peng, F., Chawathe, S.: Xpath queries on streaming data. In: SIGMOD 2003, pp. 431–442.
22. Safra, S.: On the complexity of omega-automata. In: FOCS 1988, pp. 319–327
23. Segouﬁn, L., Vianu, V.: Validating streaming XML documents. In: PODS 2002, pp. 53–64.
24. Seidl, H.: Deciding equivalence of ﬁnite tree automata. SICOMP 19(3), 424–437 (1990)
25. Thomas, W.: Languages, automata, and logic. Handbook of Formal Languages, vol. 3 (1997)
26. Thomas, W.: Inﬁnite trees and automaton-deﬁnable relations over ω-words. TCS 103, 143–

159 (1992)

27. Vardi, M.Y.: An automata-theoretic approach to linear temporal logic. Banff Higher Order

Workshop, pp. 238-266 (1995)

28. Vardi, M.Y.: Reasoning about the past with two-way automata. In: Larsen, K.G., Skyum, S.,
Winskel, G. (eds.) ICALP 1998. LNCS, vol. 1443, pp. 628–641. Springer, Heidelberg (1998)

