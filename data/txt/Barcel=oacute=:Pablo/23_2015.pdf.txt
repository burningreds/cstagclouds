On the Data Complexity of Consistent Query
Answering over Graph Databases
Pablo Barceló and Gaëlle Fontaine

Department of Computer Science
University of Chile
pbarcelo@dcc.uchile.cl, gaelle@dcc.uchile.cl

Abstract

Areas in which graph databases are applied – such as the semantic web, social networks and
scientiﬁc databases – are prone to inconsistency, mainly due to interoperability issues. This raises
the need for understanding query answering over inconsistent graph databases in a framework that
is simple yet general enough to accommodate many of its applications. We follow the well-known
approach of consistent query answering (CQA), and study the data complexity of CQA over
graph databases for regular path queries (RPQs) and regular path constraints (RPCs), which are
frequently used. We concentrate on subset, superset and symmetric diﬀerence repairs. Without
further restrictions, CQA is undecidable for the semantics based on superset and symmetric
diﬀerence repairs, and ΠP
2 -complete for subset repairs. However, we provide several tractable
restrictions on both RPCs and the structure of graph databases that lead to decidability, and
even tractability of CQA. We also compare our results with those obtained for CQA in the
context of relational databases.

1998 ACM Subject Classiﬁcation H.2.3 Database Management – Query Languages

Keywords and phrases graph databases, regular path queries, consistent query answering, description 
logics, rewrite systems

Digital Object Identiﬁer 10.4230/LIPIcs.ICDT.2015.380

Introduction

1
Query languages for graph databases are typically navigational, in the sense that they allow
for recursively traversing the labeled edges while checking for the existence of a path whose
label satisﬁes a particular regular condition (see, e.g., [39, 5]). The basic building block for
navigational languages over graph databases is the class of regular path queries, or RPQs
[14]. Each RPQ is a regular expression L, and its evaluation L(G) over a graph database G
corresponds to a binary relation that contains all pairs of nodes in G that are linked by some
path whose label matches L. The evaluation problem for RPQs can be solved in NLogspace
in data complexity; that is, when the RPQ is ﬁxed (cf., [5]).

Although graph databases are schema-less, it is possible to enforce data consistency over
them using path constraints [1, 9]. These constraints have been used in several scenarios
that are based on the graph database paradigm, e.g., to express local knowledge about
semi-structured data [1]; to enforce restrictions over object-oriented databases, XML and
RDF [36, 12, 22, 3, 30]; and to capture ontological hierarchies in the context of description
logics (DLs) [16, 17]. Here we concentrate on a simple class of path constraints based on
RPQs that was introduced by Abiteboul and Vianu; namely, the regular path constraints,
or RPCs [1]. An RPC is an expression of the form L1 v L2, where L1 and L2 are RPQs.
In the graph database and DL contexts, a graph database G satisﬁes L1 v L2 if and only
if L1(G) ⊆ L2(G) [26, 16, 17] (but we also consider a more restrictive semantics for RPCs,

© Pablo Barceló and Gaëlle Fontaine;
licensed under Creative Commons License CC-BY
18th International Conference on Database Theory (ICDT’15).
Editors: Marcelo Arenas and Martín Ugarte; pp. 380–397

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

P. Barceló and G. Fontaine

381

motivated by their application over semi-structured data, following the original proposal of
Abiteboul and Vianu). RPCs are a constituent part of the semantics of graph data and can
also be used in the optimization process for RPQ evaluation [1].

An important problem when dealing with dependencies is that databases might be
inconsistent, i.e., the databases might fail to satisfy the integrity constraints. In the case
of graph database applications, high levels of inconsistency appear due to interoperability
and distribution (e.g., in RDF and social/scientiﬁc networks [27, 40]). As an example,
inconsistency might arise while integrating several sources into a single RDF graph, or while
performing statistical inference on a scientiﬁc or social network. This raises the need for
developing an inconsistency-tolerant semantics for graph databases in a simple yet general
framework that abstracts away from its many implementations. In order to tackle this
problem, we use the widespread approach of consistent query answering (as ﬁrst introduced
in the seminal work of Arenas, Bertossi and Chomicki [2]), which we now describe.

The approach is based on the notion of repair, which represents a possible minimal way
in which consistency over the data could be restored. More formally, a repair is a database
that satisﬁes the constraints and “minimally diﬀers” from the original database. In general, a
database does not admit a unique repair. This leads to an inconsistency-intolerant semantics
based on the consistent answers of a query, i.e., the answers that hold in every possible
repair. The problem of computing consistent answers to a query is known as consistent query
answering (CQA).

Here we study the data complexity of CQA over graph databases in the scenario in which
queries are RPQs and constraints are RPCs. That is, we study the complexity of evaluating
consistent answers over an inconsistent graph database G for a ﬁxed RPQ L under a ﬁxed
set Γ of RPCs. We explain next the context and main contributions of our work.

The context. The complexity of CQA has received considerable attention over diﬀerent data
models, notions of repairs and classes of constraints. Under the relational model, for instance,
this problem has been studied for set-based [2, 18, 24], cardinality-based [29], and attributebased 
repairs [37]; for constraints expressed as traditional functional dependencies, inclusion
dependencies and denial constraints (see, e.g., [11, 19, 25, 38, 28, 24]); and for constraints
expressed as tuple-generating dependencies (tgds) and equality-generating dependencies
(egds) that arise in the context of data integration and data exchange [18].

CQA has also been studied in depth in the DL context, starting from the work of Lembo
and Ruzzi [31]. The DL semantics is open-world in nature, meaning that the non-presence of
a fact is not suﬃcient to ensure that the negation of the fact holds. This implies that in the
DL context the only meaningful set-based repairs are the subset repairs; i.e., those that allow
to restore consistency with respect to the DL constraints (i.e., the ones in the TBox) only by
deleting facts from the database (i.e., the ABox). It is worth mentioning that the notion of
DL repair is slightly diﬀerent to its relational counterpart: A DL repair is not a subinstance
that satisﬁes the constraints in the TBox, but one that does not lead to a contradiction in
conjunction with those constraints [31, 32].

Some applications of graph databases, such as RDF, are open-world in nature. However,
graph databases are not tied to this interpretation and may also accommodate closed-world
applications. Therefore, there should be no a priori restriction on the class of set-based
repairs one allows in this context. We thus study CQA for graph databases under the three
usual notions of set-based repairs: subset, superset, and symmetric diﬀerence repairs [18].

Our contributions. We ﬁrst look at the data complexity of CQA over graph databases
2 , and we prove that it is complete for this class in
under subset repairs. The problem is in ΠP

ICDT 2015

382

On the Data Complexity of Consistent Query Answering over Graph Databases

restricted cases. Moreover, it remains intractable even under an approximation semantics
(based on the intersection of all subset repairs) that is motivated by the DL context [32].

In order to deal with this high complexity, we provide tractable cases by restricting the
class of RPCs or the class of graph databases allowed. In the ﬁrst case, we prove that the
problem is tractable if RPCs are in LAV form, i.e., if they are of the form a v L, where a
is a single letter. This result is, in a sense, tight, since allowing a single RPC of the form
ab v c, for symbols a, b and c, leads to intractability. In the case of restrictions on graph
databases, by applying a deep result of Courcelle [20] we obtain that the data complexity of
CQA under subset repairs is tractable over graph databases of bounded treewidth.

We then move to study CQA under superset and symmetric diﬀerence repairs, and prove
that in both cases the problem is undecidable. However, we obtain decidability by either
restricting the class of RPCs allowed or their semantics. Let us consider ﬁrst the restrictions
on RPCs. We prove that if RPCs are in LAV form then the data complexity of CQA is
tractable when dealing with symmetric diﬀerence repairs. We leave open whether CQA is
also decidable under the semantics of superset repairs, but prove that at least tractability
in data complexity is not preserved. We then prove that if RPCs are in GAV form, i.e., if
they are of the form L v a, where a is a single letter, our CQA problem is tractable under
the semantics of superset repairs, but intractable under symmetric diﬀerence repairs. With
respect to restrictions on the semantics of RPCs, we prove that by forcing RPCs to be read
from a particular node in the graph database, called the origin (which corresponds to the
original semantics Abiteboul and Vianu deﬁned for these constraints), the problem can be
solved in coNP under superset repairs.

Comparison with previous results. The main diﬀerence between the query and constraint
languages we study here (RPQs and RPCs) and the ones studied in the relational context,
is that our languages allow recursion while CQA has been studied in the relational world
mostly in the absence of recursive features. Interestingly, our results show that recursion
does not add to the complexity of the problems studied. In fact, almost all of our lower
bounds hold in the restricted setting in which RPQs do not mention the Kleene-star and
RPCs are word constraints of the form w1 v w2, for words w1 and w2 [1].

If we interpret graph databases as relational databases, word constraints can be represented
as tgds. The tgds corresponding to word constraints have a special restricted structure and
are called chain tgds. On the other hand, CQA under tgds has been intensively studied [18],
and it is tempting to think that lower bounds obtained in such setting could be adapted
to work in our scenario. This is not the case, however, as those proofs do not apply to the
class of chain tgds. Actually, the proofs of our lower bounds are considerably more involved
than the ones for arbitrary tgds. As a side-eﬀect, we obtain that several of our lower bounds
extend to CQA in the relational case for queries deﬁned as unions of CQs under chain tgds.
2 -hardness results
have been obtained by Rosati for the data complexity of CQA under subset repairs, in
particular, for the case when queries are unions of CQs and constraints are expressed in the
logic ALC [35]. However, constraints in this logic cannot be directly expressed as RPCs due
to the presence of negation. Furthermore, the notion of repair in [35] is diﬀerent to ours.

DL databases are (essentially) graph databases. In such scenario, ΠP

Organisation of the paper. Preliminaries are in Section 2. Results about the subset repair
semantics are in Section 3, and those about the semantics of superset and symmetric diﬀerence
repairs are in Section 4. Comparison with previous work is in Section 5 and conclusions in
Section 6. Due to space constraints, complete proofs are in the appendix.

P. Barceló and G. Fontaine

2

Preliminaries

383

Graph databases and regular path queries. As it is customary in the graph database
literature [14, 15, 39, 5], we consider graph databases to be ﬁnite, edge-labeled and directed
graphs. Formally, let Σ be a ﬁnite alphabet. A graph database G = (V, E) over Σ consists of
a ﬁnite set V of nodes and a set of labeled edges E ⊆ V × Σ × V . We interpret each tuple
(u, a, v) ∈ E, for u, v ∈ V and a ∈ Σ, as an edge from node u to node v whose label is a. If
G = (V, E) and G0 = (V 0, E0) are graph databases over Σ, we write G ⊆ G0 to denote that
V ⊆ V 0 and E ⊆ E0. If in addition it is not the case that G0 = G, we write G (cid:40) G0.

Navigational query languages for graph databases, such as the one of RPQs, express
properties of paths. Formally, a path π in G = (V, E) of length m (where m > 0) from
node v0 to node vm is a sequence of the form (v0, a1, v1)(v1, a2, v2) . . . (vm−1, am, vm), where
(vi−1, ai, vi) is an edge in E, for each 1 ≤ i ≤ m. The label of π, denoted λ(π), is the string
a1a2 . . . am ∈ Σ∗. A path π of length 0 is simply a node v and its label λ(π) is the empty
string ε.

Here we concentrate on the simplest navigational language for graph databases, namely,
regular path queries, or RPQs [14]. An RPQ is a regular expression L over Σ. The evaluation
L(G) of L over a graph database G = (V, E) is the set of pairs (u, v) of nodes in V for which
there is a path π in G from u to v such that λ(π) satisﬁes L. If L does not mention the
Kleene-star (i.e., if L deﬁnes a ﬁnite language) then we say that L is non-recursive. It is
well-known (cf., [5]) that computing L(G), for an RPQ L and a graph database G, can be
solved in polynomial time (and in NLogspace if L is ﬁxed, that is, in data complexity).

Regular path constraints. Graph database constraints based on the class of RPQs are
known as regular path constraints [1, 26], or RPCs. Formally, an RPC over Σ is an expression
of the form L1 v L2, where L1 and L2 are RPQs over Σ. A word constraint is an RPC in
which both L1 and L2 are words.
An RPC L1 v L2 expresses that the evaluation of the RPQ L1 is contained in the
evaluation of the RPQ L2 [26]. Formally, a graph database G satisﬁes L1 v L2, denoted
G |= L1 v L2, if and only if L1(G) ⊆ L2(G). If Γ is a ﬁnite set of constraints, we write
G |= Γ to denote that for each RPC L1 v L2 in Γ it is the case that G |= L1 v L2. It follows
from previous remarks that the problem of checking whether G |= Γ, for a ﬁxed set Γ of
RPCs, is in NLogspace.
(cid:73) Example 1. Let Γ be the following set of RPCs:
1. child_of v son_of ∪ daughter_of.
2. brother_of · (brother_of ∪ sister_of) v brother_of.
3. sister_of · (brother_of ∪ sister_of) v sister_of.
4. child_of · (brother_of ∪ sister_of) v is_nephew ∪ is_niece.
Intuitively, the ﬁrst RPC expresses that if u is a child of v, then u is a son or a daughter of
v. The second and third RPCs express that if u is a brother (resp., sister) of v and v is a
sibling of w, then v is a brother (resp., sister) of w. The forth RPC states that each child of
(cid:74)
a person v is the niece or nephew of every sibling of v.

Repairs. A repair of a database D under a set of constraints Γ is a database D0 that satisﬁes
Γ but “minimally” diﬀers from D [2]. We formalise this idea for graph databases and RPCs
below, following closely its formalisation in the relational context [2].

The symmetric diﬀerence between two relational databases D and D0 is deﬁned as a
database D ⊕ D0 that contains those “facts” that belong to D but not to D0 or to D0 but

ICDT 2015

384

On the Data Complexity of Consistent Query Answering over Graph Databases

not to D. We can analogously deﬁne the symmetric diﬀerence between two graph databases
G = (V, E) and G0 = (V 0, E0) over the same alphabet Σ, as the graph database

:= (cid:0) V0, (E ⊕ E0)(cid:1),

G ⊕ G0

where E ⊕ E0 := (E \ E0) ∪ (E0 \ E) and V0 is the set of nodes occurring in E ⊕ E0. That is,
the nodes (resp., edges) of G ⊕ G0 are those nodes (resp., edges) that appear in either G or
G0 but not in both. Notice that G ⊕ G0 is also a graph database over Σ.

Three notions of set-based repairs have been studied in the literature [18]: the subset,
superset and symmetric diﬀerence repairs (⊆–, ⊇–, and ⊕–repairs, respectively). We introduce
them below in the context of graph databases. Let G = (V, E) and G0 = (V 0, E0) be two
graph databases over Σ, and assume that Γ is a ﬁnite set of RPCs over Σ. Then:
1. G0 is a ⊕-repair (i.e., symmetric diﬀerence repair) of G under Γ, if (1) G0 |= Γ, and (2)

there is no graph database G00 over Σ such that G00 |= Γ and G ⊕ G00 (cid:40) G ⊕ G0.

2. G0 is a ⊆-repair (i.e., subset repair) of G under Γ, if G0 ⊆ G and G0 is a ⊕-repair of G.
Equivalently, if (1) G0 ⊆ G, (2) G0 |= Γ, and (3) there is no graph database G00 over Σ
such that G00 |= Γ and G0 (cid:40) G00 ⊆ G.

3. G0 is a ⊇-repair (i.e., superset repair) of G under Γ, if G ⊆ G0 and G0 is a ⊕-repair of G.
Equivalently, if (1) G ⊆ G0, (2) G0 |= Γ, and (3) there is no graph database G00 over Σ
such that G00 |= Γ and G ⊆ G00 (cid:40) G0.

(cid:73) Example 2 (Example 1 cont.). Consider a graph database G whose set of edges is

{(a, child_of, b), (b, sister_of, c), (c, brother_of, d)}.

Then G has two ⊆-repairs under Γ: {(b, sister_of, c)} and {(c, brother_of, d)}. On the
other hand, G has eight ⊇-repairs under Γ. One of them is the one that extends G with
edges:

{(a, son_of, b), (b, sister_of, d), (a, is_nephew, c), (a, is_nephew, d)}.

Finally, G has seven ⊕-repairs under Γ that are neither ⊆-repairs nor ⊇-repairs. One of
them is {(b, sister_of, c), (c, brother_of, d), (b, sister_of, d)}.
(cid:74)
Repairs might not exist in some situations. Consider an RPC of the form L v ε, where ε
is the empty word, and a graph database G that consists of nodes u and v linked by a path
labeled in L. Assume that G has a ⊇-repair H. Then it must be the case that u = v in H,
which is impossible. As the the next lemma shows, repairs exist in all other cases.
(cid:73) Lemma 3. Let G = (V, E) be a graph database and Γ a ﬁnite set of RPCs over Σ.
Then:
1. There is a ⊆-repair and a ⊕-repair of G under Γ.
2. If Γ contains no RPC of the form L v ε, then there is a ⊇-repair of G under Γ.
Proof. Let G = (V, E) be a graph database and Γ a ﬁnite set of RPCs. The empty
database G∅ = (∅,∅) satisﬁes Γ. Hence, there is an ⊆-repair H of G under Γ such that
G∅ ⊆ H ⊆ G. By deﬁnition, H is also a ⊕-repair of G under Γ. Consider now the graph
database Gc = (V, V × Σ × V ). It is easy to see that Gc satisﬁes Γ since Γ contains no
RPC of the form L v ε. Since G ⊆ Gc, there is a ⊇-repair H of G under Γ such that
G ⊆ H ⊆ Gc.
(cid:74)

P. Barceló and G. Fontaine

385

Consistent query answering. We are now ready to deﬁne our most important notion, that
of a consistent answer to an RPQ. The consistent answers are the pairs of nodes that belong
to the evaluation of the RPQ over every single repair of the original graph database.
(cid:73) Deﬁnition 4 (Consistent answers). Assume that ? ∈ {⊕,⊆,⊇}. Let G = (V, E) be a
graph database, Γ a set of RPCs and L an RPQ, all of them over Σ. We deﬁne the set
?-Cons(G, L, Γ) of ?-consistent answers of L over G under Γ as:

?-Cons(G, L, Γ) = \{L(G0) | G0 is a ?-repair of G under Γ}. (cid:74)

(cid:73) Example 5. (Example 1 cont.) Consider the RPQ L = child_of · sister_of. The
pair (a, d) belongs to ⊇-Cons(G,L,Γ). This pair also belongs to ⊇-Cons(G,L0,Γ), for L0 =
is_nephew ∪ is_niece. On the other hand, the only way in which a pair (u, v) can belong
to ⊆-Cons(G,L00,Γ), for an RPQ L00, is when u = v = c and L00 = ε.
(cid:74)

Here we study the data complexity of the problem of computing certain answers. We
formalise this decision problem as follows. Assume that L is an RPQ and Γ is a ﬁnite set of
RPCs over Σ. We denote by ?-CQA(L,Γ) the problem of, given a graph database G = (V, E)
over Σ and a pair (u, v) of nodes in V , checking whether (u, v) ∈ ?-Cons(G, L, Γ).

3

CQA under Subset Repairs

We start by proving that under the subset repair semantics our CQA problem is ΠP
2 -complete.
This holds even in the case in which all RPCs are word constraints and the RPQ is nonrecursive.

(cid:73) Theorem 6.
1. For each RPQ L and ﬁnite set Γ of RPCs over the same alphabet Σ, it is the case that

2. There exist a ﬁnite alphabet Σ, a non-recursive RPQ L and a ﬁnite set Γ of word

⊆-CQA(L,Γ) is in ΠP
2 .
constraints over Σ, such that ⊆-CQA(L,Γ) is ΠP

2 -complete.

Proof. We sketch the hardness proof, i.e., that there is a non-recursive RPQ L and a set Γ
of word constraints such that ⊆-CQA(L,Γ) is ΠP
2 -hard. We do so by providing a reduction
from the quantiﬁed boolean satisfaction problem for ΠP
Let φ be a quantiﬁed boolean formula of the form ∀X∃Y ψ, where X, Y are disjoint sets of
variables and ψ is of the form (z11 ∨ z12 ∨ z13)∧···∧ (zn1 ∨ zn2 ∨ zn3), for zij ∈ {x,¬x, y,¬y |
x ∈ X, y ∈ Y } (1 ≤ i ≤ n, 1 ≤ j ≤ 3). For all i, j, we deﬁne uij as the variable zij if
zij ∈ X ∪ Y , or we deﬁne uij as u if zij is of the form ¬u. Without loss of generality, we
may assume that in each clause Ci := zi1 ∨ zi2 ∨ zi3, there is at least one variable in1 Y .

2 to ⊆-CQA(L,Γ).

We will deﬁne the RPQ L, the constraints Γ and associate a graph database Gφ with φ

in such a way that

φ is satisﬁable

iﬀ (ns, ns) ∈⊆ −Cons(Gφ, L, Γ).

where ns is a node of Gφ.

1 Suppose for example that the clause C1 of ψ contains only variables in X. We construct a new formula
ψ0 deﬁned by (z11 ∨ z12 ∨ y) ∨ (¬y ∨ z13 ∨ z13) ∨ C2 ∧ ··· ∧ Cn, where y is a new fresh variable. We
deﬁne Y 0 as Y ∪ {y}. Then ∀X∃Y ψ is satisﬁable iﬀ ∀X∃Y 0ψ0 is satisﬁable.

ICDT 2015

386

On the Data Complexity of Consistent Query Answering over Graph Databases

It is convenient to start deﬁning a graph database G0

φ over alphabet

The nodes of G0

Σ = {t, f, t0, f0, a, y, z, w, d, s, e, r−,−, r−,+, r+,−, r+,+}.
φ are the following set:

V := {nij | 1 ≤ i ≤ n, 1 ≤ j ≤ 3} ∪ {nt, nf , ns}.

With each variable uij, we associate a node id nij in V . Observe that even if uij = ukl (with
(i, j) 6= (k, l)), the associated nodes are distinct. We also have three special nodes ns, nt and
nf. We let < be an arbitrary irreﬂexive partial order over {1, . . . , n} × {1, 2, 3} such that (a)
for each 1 ≤ i, k ≤ n and 1 ≤ j, l ≤ 3, if uij = ukl, then (i, j) < (k, l) or (k, l) < (i, j), and
(b) for each (i, j), where 1 ≤ i ≤ n and 1 ≤ j ≤ 3, there is at most one pair (k, l) such that
(k, l) is a “successor” of (i, j) with respect to < (where we say that (k, l) is a successor of
(i, j) if (i, j) < (k, l) and there is no (k0, l0) such that (i, j) < (k0, l0) < (k, l)).

φ is deﬁned as the union of all the sets below:

The set of edges of G0
Et = {(nij, t, nij) | 1 ≤ i ≤ n, 1 ≤ j ≤ 3} Ef = {(nij, f, nij) | 1 ≤ i ≤ n, 1 ≤ j ≤ 3}
Et0 = {(nt, t0, nt)}
Ea = {(nij, a, ns) | uij ∈ Y }
Ez = {(nij, z, nt), (nij, z, nf) | uij ∈ Y }
Ed = {(nij, d, nkl) | (i, j) < (k, l)}
Er∼] = {(nij, r∼], ni(j+1)) | zij =∼ uij, zi(j+1) = ]ui(j+1), 1 ≤ i ≤ n, 1 ≤ j ≤ 2}
Ee = ∅

Ef0 = {(nf , f0, nf)}
Ey = {(ns, y, ns)}
Ew = {{(nt, w, ns), (nf , w, ns)}
Es = {(u, s, v) | u, v ∈ V }

where ∼, ] belong to {+,−} and +u := u, −u := ¬u.

The intuition is as follows. There is no edge with label e and there is an edge with label
s between any two nodes. For the labels t and f, each node nij associated with a variable
admits loops with labels t and f. The ⊆-repairs will be such that each such node admit at
most one loop, either with label t or f. This allows us to deﬁne a partial map associating a
truth value with each node nij (> if the loop has label t and ⊥ if the loop has label f). The
special node nt has a loop with label t0 and the special node nf has a loop with label f0.
The labels r++, r−+, r+− and r−− express which variables occur in the same clause
and whether each variable occurs positively or negatively. The label d speciﬁes which nodes
corresponds to the same variable. The constraints will be such that in a ⊆-repair, two nodes
linked by d (corresponding to the same variables) admit loops with the same label (t or
f). This implies that the partial mapping associating a truth value to each node (> if the
loop has label t and ⊥ if the loop has label f), corresponds to a partial valuation over the
variables in X ∪ Y .

The special node ns admits a loop with label y. That loop will act as a “witness”. If that
loop appears in a repair, we will say that the node ns gets activated. When ns is activated
in a repair, the idea is that each node nij associated with a variable in Y admits a loop with
label t or f. That is, each such a node receives a truth value (> if the loop has label t and ⊥
otherwise). Conversely, if in a repair one node associated with a variable in Y admits a loop
with label t or f, then the presence of that loop “activates” the node ns (i.e. ns admits a
loop with label y). As a consequence, all the nodes associated with variables in Y will admit
a loop. Basically, the node ns guarantees that either all the nodes associated with variables
in Y admit a loop, or none of those nodes admits a loop.
In order to encode in the graph database which variables belong to Y , we add an edge
with label a between the source ns and each node of the form nij with uij ∈ Y . We also add
an edge with label z from nij to the special node nt and from nij to nf.

P. Barceló and G. Fontaine

387

We use the nodes nt and nf in the following way. Recall that in a given ⊆-repair, the
(possible) truth value of a node is given by the label (either t or f) of the loop of the node.
Now, for the nodes associated with variables in Y , we have an extra way of encoding the
truth value. If the truth value of a node nij (with uij ∈ Y ) is true, this will also be witnessed
by an arrow with label z from nij to the special node nt (and the other arrow with label z
from nij to nf is deleted). If the truth value is false, this will be witnessed by an arrow with
label z from nij to nf.

We now deﬁne the set Γ of constraints. We have six diﬀerent sets of constraints (C1),

(C2), (C3), (C4), (C5) and (C6) in Γ. The set (C2) contains the constraint

tf v e.

Since e is empty, it says that a node cannot admit both a loop with label t and f. The set
(C3) contains the two constraints

td v dt
f d v df.

It expresses that if two nodes are linked by d (hence, they are associated with the same
variable), then they must admit a loop with the same label (in case they admit a loop). This
guarantees that the partial map associating a truth value to each node (depending on the
label of the loop), can be transformed into a partial valuation over the variables. The set of
constraints (C4) is given by
F(j)rjkF(k)rklF(l) v e,

where j, k, l ∈ {+,−}, F(+) = f and F(−) = t. These constraints express that the formula
ψ is not false under the partial valuation associated with the repair.

The constraints (C5) are given by

zt0 v tz
zf0 v f z.

They express that if a node associated with a variable in Y is linked to the node nt, then it
admits a loop with label t. Similarly, if such a node is linked to the node nf, then it admits
a node with label f.
Indeed, let us look for example at the constraint zt0 ⊆ tz. Suppose that there is a path
with label zt0 from a node u to a node v. By deﬁnition of t0 and z, this can only happen if
u is a node of the form nij (with uij ∈ Y ) and v is the node nt. Now since zt0 ⊆ tz, this
implies that nij admits a loop with label t.

The set (C6a) contains the two constraints

ta v ay
f a v ay

while the constraint (C6b) is given by ay ⊆ zw. The constraints (C6a) express that if one
node associated with a variable in Y admits a loop with label t or f, then the node ns is
activated (i.e. admits a loop with label y). Indeed, if there is a path with label ta from a
node u to a node v, then, u must be a node of the form nij admitting a loop with label t
and v is the node ns. Moreover, since nij admits an outgoing edge with label a, nij must be
associated with a variable in Y . Since ta ⊆ ay, the presence of the loop with label t and the
fact that uij belongs to Y imply that there is an edge with label y. That is, ns is activated.

ICDT 2015

388

On the Data Complexity of Consistent Query Answering over Graph Databases

The constraint (C6b) expresses that if the node ns is activated (admits a loop with label y),
then each node nij associated with a variable in Y is linked either to the node nt or to the
node nf. Together with the contraints (C5), this means that if ns is activated, then each
node nij associated with a variable in Y admits a loop with label t or f.
We deﬁne an RPQ L0 as sys. This RPQ evaluates to V × V in the ⊆-repairs admitting
a y-labeled edge, i.e., the repairs in which ns is activated. Recall that this means that the
partial valuation associated with the repair assigns a truth value to all the variables in Y .
φ, L0, Γ). Now
the implication from left to right is not true. The problem is that since we are allowed to
delete edges in order to obtain a repair, we may loose some “relevant information”. For
example, in a repair, we may loose an edge with label a encoding the fact that a node is
associated with a variable in Y . In such repairs, it might not be the case that (ns, ns) belongs
to the answer of L0.

We would like to prove that φ is satisﬁable iﬀ (ns, ns) belongs to ⊆-Cons(G0

The solution is to extend the graph database G0

φ with a set of extra edges E, deﬁne a new
graph Gφ, and add a set of constraints (C1). If in a repair H of Gφ we lost some “relevant
information”, the constraints (C1) will be such that at least one extra edge in E occurs in H.
We then modify the RPQ L0 into an RPQ L, in such a way that if a graph database contains
a new edge in E, then the evaluation of L consists of all the pairs of nodes. Hence, in all the
repairs in which we lose some relevant information, the answer of the RPQ contains any pair
of nodes.

As an example, we show how to modify the graph G0

φ into a graph Ga, add new
constraints (C1d) and modify the RPQ L into a RPQ La in such a way that if in a repair H
of Ga, we “lost” an edge with label a, then H trivially satisﬁes2 Ld. We deﬁne Ga by adding
the following edges

Ea0 = {(nij, a0, nij) | (nij, a, ns) ∈ Ea}.

That is, we add a loop with label a0 to all the nodes who must admit an outgoing edge with
label a. We deﬁne (C1d) as the following constraint

a0a ⊆ e.

Using the maximality property of the repairs, we can show that this constraint ensure that
in each repair H, exactly one of the following properties holds: (a) we did not loose any edge
with label a, and there is no edge with label a0 or e, (b) there is an edge with label a0 or e.
Case (a) means that we did not lost any “relevant information” with respect to the label a.
In case (b), the fact that we lost that information is witnessed by the fact that in the repair,
there is an edge with label a0 or e.

Finally we let La be the RPQ s(y + a0 + e)s. That is, La is equivalent to sys + s(a0 + e)s.
There are two possibilities for a repair to be such that (ns, ns) belongs to La: either (ns, ns)
belongs to L0 or there is an edge with label a0 or e. Those two possibilities corresponds to
(cid:74)
cases (a) and (b) of the previous paragraph.

Semantics based on the intersection of subset repairs.
In order to obtain good complexity
bounds for CQA in the DL context, Lembo et al.
introduced a sound approximation of
the CQA semantics based on the idea of evaluating queries over the intersection of all

2 For a complete deﬁnition of G, (C1) and L, we should make such modiﬁcations for the labels d, r++,

r−+, r+−, r−−, t0, f0 and w.

P. Barceló and G. Fontaine

389

subset repairs [32]. This approximation leads to tractability for inconsistency-tolerant query
answering over some DLs of interest (e.g., for DL-LiteA). Although the repairs studied in
the DL context are diﬀerent to ours, it makes sense to study the pertinence of this semantics
as a tool for establishing tractability results also in the graph database context.
Formally, let L be an RPQ and Γ a ﬁnite set of RPCs over Σ. We deﬁne ∩-CQA(L,Γ) as
the problem of, given a graph database G = (V, E) over Σ and a pair (u, v) of nodes in V ,
checking whether (u, v) belongs to the evaluation of L over the intersection of all ⊆-repairs
of G under Γ. (The intersection of graph databases G1 = (V1, E1) and G2 = (V2, E2) over Σ
is the graph database (V1 ∩ V2, E1 ∩ E2)).

We prove below that the approximation semantics is not easier to evaluate than the
original one. Therefore, in order to obtain tractability for our CQA problem it is necessary
to look for restrictions that are proper to the scenario of graph databases.
(cid:73) Proposition 7. There exist a ﬁnite alphabet Σ, a non-recursive RPQ L and a ﬁnite set Γ
of word constraints over Σ, such that ∩-CQA(L,Γ) is ΠP

2 -hard.

3.1 Tractable restrictions
Due to the inherent high complexity of our CQA problem under the subset repair semantics,
it is important to look for meaningful restrictions leading to tractability. We provide two
such restrictions in this section. The ﬁrst one is based on the class of LAV RPCs, and the
second one on the class of graph databases of bounded treewidth.

Restricting RPCs.
In the relational case, the data complexity of CQA for unions of CQs
under the class of LAV tgds (i.e., tgds with a single atom in the left-hand side [33]) is
tractable. This actually holds for any of the three repair semantics [18]. The direct analogue
of LAV tgds in our setting is the class of LAV RPCs, which are RPCs with a single symbol
in the left-hand side. Formally, a LAV RPC over Σ is an RPC of the form a v L, where
a ∈ Σ and L is an RPQ over Σ. We can leverage the techniques used to study CQA under
LAV tgds to prove tractability in data complexity for our CQA problem under LAV RPCs.
(cid:73) Theorem 8. For each RPQ L and ﬁnite set Γ of LAV RPCs over the same alphabet Σ, it
is the case that ⊆-CQA(L,Γ) is in NLogspace.

It is interesting to also consider RPCs based on the class of GAV tgds [33], that only
allow for one symbol on the right-hand side. That is, a GAV RPC over Σ is of the form
L v a, for L an RPQ over Σ and a ∈ Σ. While this restriction improves the complexity of
the CQA problem, it does not lead to tractability.
(cid:73) Proposition 9.
1. For each RPQ L and ﬁnite set Γ of GAV RPCs over the same alphabet Σ, it is the case

2. There exist a ﬁnite alphabet Σ, a non-recursive RPQ L over Σ and a single GAV RPC of

that ⊆-CQA(L,Γ) is in coNP.
the form ab v c, where a, b, c ∈ Σ, such that ⊆-CQA(L,Γ) is coNP-complete.
Note that in the setting of relational databases, the data complexity of consistent query
answering for unions of conjunctive queries with respect to GAV constraints was also shown
to be complete for the class coNP [18]. It is worth mentioning that we obtained the upper
bound of Proposition 9 using techniques from the relational case.

The second part of the previous proposition shows that, in a sense, the tractability result
for LAV RPCs in Theorem 8 is optimal: Allowing two-letter words on the left-hand side of
RPCs leads to intractability, even if the right-hand side consists of a single letter.

ICDT 2015

390

On the Data Complexity of Consistent Query Answering over Graph Databases

Restricting graph databases. Our CQA problem under the subset repair semantics can be
reformulated as a monadic second-order logic (MSO) evaluation problem over a relational
representation of graph databases. This allows us to apply results establishing the tractability
of MSO over structures of bounded treewidth [20]. From those results, we obtain tractability
for the CQA problem over graph databases of bounded treewidth.
Formally, let G = (V, E) be a graph database. A tree decomposition of G is a pair (T, λ),
where T is a tree and λ : T → 2V maps each node t in T to a nonempty set λ(t) of nodes in
V , that satisﬁes the following conditions:

The set {t ∈ T | v ∈ λ(t)} is a connected subset of T.
For each edge (u, a, v) ∈ E, it is the case that {u, v} ⊆ λ(t), for some t ∈ T.

The width of the tree decomposition (T, λ) is max {|λ(t)| − 1 | t ∈ T}. The treewidth of G is
the minimum width of a tree decomposition of G. For instance, the treewidth of G is one if
and only if the underlying undirected graph of G is a tree.

We then obtain the following:

(cid:73) Theorem 10. Let L be an RPQ and Γ a set of RPCs. Then ⊆-CQA(L,Γ) can be solved
in linear time over graph databases of treewidth ≤ k, for each k ≥ 1.

CQA under Superset and Symmetric Diﬀerence Repairs

4
We prove in this section that our CQA problem is undecidable under the semantics of ⊇-
and ⊕-repairs. This holds even if RPQs are non-recursive and RPCs are word constraints:
(cid:73) Theorem 11. Assume ? ∈ {⊇,⊕}. There exist a ﬁnite alphabet Σ, a non-recursive RPQ
L and a set Γ of word constraints over Σ, such that ?-CQA(L,Γ) is undecidable.

In order to prove this theorem we establish a connection with the implication problem
for RPCs [1, 26]. Recall that this is the problem of, given a ﬁnite set Γ of RPCs and an
RPC L1 v L2, checking whether Γ |= L1 v L2, i.e., if G |= Γ implies G |= L1 v L2, for
every graph database G. Grahne and Thomo proved this problem to be undecidable, even
for word constraints, using a reduction from the word rewriting problem [26]. We develop
nontrivial adaptations of such reduction to prove Theorem 11. The reason why we have
to develop such adaptations is that there exist diﬀerences in nature between CQA and the
implication problem for constraints. First, in the CQA problem we do not reason about
all graph databases that satisfy the constraints (as in the case of the implication problem),
but only about those that minimally diﬀer from the original graph database. Note that in
the special case of the superset semantics, this ﬁrst problem does not apply. Indeed, given
a graph database G, the intersection of the answers of a monotone query L over all the
⊇-repairs is equal to the intersection of the answers of L over all the databases containing G
and satisfying the constraints.

Second, we study the data complexity of the CQA problem, and, therefore, our goal is to
prove undecidability of CQA for a ﬁxed set of RPCs and a ﬁxed RPQ. This is diﬀerent to the
case of the implication problem in which RPCs and RPQs deﬁne the input, and, therefore,
cannot be ﬁxed.
Proof of Theorem 11. We only prove the case when ? is ⊇. We start by recalling the basic
notions of rewrite systems. Let ∆ be a ﬁnite alphabet. A semi-Thue rewrite system R over
∆ is a ﬁnite subset of ∆∗ × ∆∗. A rewrite system R induces a single-step reduction relation
→R over ∆∗ deﬁned as:

→R = {(v, w) | v = xty, w = xuy, for some (t, u) ∈ R and x, y ∈ ∆∗}.

P. Barceló and G. Fontaine

391

We let →∗
R be the reﬂexive transitive closure of →R. The problem of testing whether a pair
(u, v) belongs to →∗
R is called the rewrite problem for R. It is well known that there is a
semi-Thue rewrite system R0 over ∆ such that the rewrite problem for R0 is undecidable
(see e.g., [8]).
We prove that ⊇-CQA(L,Γ) is undecidable using a reduction from the rewrite problem
for R0. Let ˆ∆ = ∆ ∪ {ˆa | a ∈ ∆} ∪ {$}, where the ˆa’s and $ are fresh symbols. We deﬁne a
set Γ of RPCs and an RPQ L over ˆ∆, such that there is an algorithm that takes as input
two words w1 and w2 over ∆ and constructs a graph database G over ˆ∆ with a node n0 such
that w1 →∗
R0 w2 iﬀ (n0, n0) ∈ ⊇-Cons(G,L,Γ). The set Γ consists of all RPCs of the form:

u v v,
a$ˆa v $,

for (u, v) ∈ R0 and a ∈ ∆. We deﬁne the RPQ L as the letter $.

Let w1 and w2 be two words in ∆∗. We assume that
w1 = w11w12 . . . w1k,
w2 = w21w22 . . . w2l,

where w1i, w2j ∈ ∆ (1 ≤ i ≤ k, 1 ≤ j ≤ l). We deﬁne the graph database G = (V, E) over
ˆ∆ as follows. The set V of nodes of G is {ni : 0 ≤ i ≤ k} ∪ {mi : 0 < i < l}. Let us deﬁne
m0 = n0 and ml = nk. Then the set E of edges of G is deﬁned as E1 ∪ E2 ∪ E3, where E1,
E2 and E3 are as follows:

E1 = {(ni−1, a, ni) | w1i = a, 1 ≤ i ≤ k},
E2 = {(mi, ˆa, m(i−1)) | w2i = a, 1 ≤ i ≤ l},
E3 = {(nk, $, nk)}.

Notice that G consists of a path with label w1 from n0 to nk and a path with label
ˆw2l ˆw2(l−1) . . . ˆw21 from nk to n0. The node nk admits a loop with label $.
The intuition is as follows. We start with the path with label w1 in G0. The idea is that
if w1 →∗
R0 w2, then applying the constraints of the form u v v in Γ, we will construct a path
with label w2. The query is $, and thus we have to check whether n0 admits a loop with
label $ in every repair.
Intuitively, the presence of a path with label w2 from n0 to nk is witnessed by a loop
with label $ at n0. This is due to the presence of the constraints of the form a$ˆa v $ in Γ.
Indeed, suppose that s0w21s1w22 . . . sl is a path with label w2 from n0 to nk (where each
si is a node, and thus s0 = n0 and sl = nk). Then, by induction on 0 ≤ i ≤ l, using the
constraints a$ˆa v $ and the fact that nk admits a loop with label $, we can prove that there
is an edge with label $ from sl−i to ml−i. In particular, there is an edge with label $ from s0
to m0. Since s0 = m0 = n0, this implies that n0 admits a loop with label $.
R0 w2 iﬀ (n0, n0) ∈ ⊇-Cons(G,L,Γ). The proof of the
implication from left to right follows basically from the intuition that we gave in the previous
two paragraphs. For the implication from right to left, suppose that (n0, n0) ∈ ⊇-Cons(G,L,Γ).
We have to prove that w1 →∗
(a) We construct a graph database H such that G ⊆ H and H |= Γ. Moreover, if there is a
(b) Since H0 |= Γ, there is a repair H0 of G under Γ such that G ⊆ H0 ⊆ H. As the
consistent answer of L = $ contains the pair (n0, n0), this implies that n0 admits a loop
with label $ in H0. In particular, n0 admits a loop with label $ in H.

path with label w2 from n0 to nk in H, then w1 →∗

We have to prove that w1 →∗

R0 w2. The strategy is as follows.

R0 w2.

ICDT 2015

392

On the Data Complexity of Consistent Query Answering over Graph Databases

(c) We prove that if n0 admits a loop with label $ in H, then there is a path with label w2

from n0 to nk in H. Together with (a), this ﬁnishes the proof that w1 →∗ w2.
The construction of the graph database H uses ideas from the construction in the
undecidability proof of [26]. In fact, H is an extension of the graph database used in such
construction. Let k0 be the maximum of {k, l}. We deﬁne the set of nodes V 0 of H as:

{[u] | u ∈ ∆∗, |u| ≤ k0} ∪ {mi : 0 < i < l}.

We identify n0 with []. For all 1 ≤ i ≤ k, we identify ni with [w11 . . . w1i]. In particular, nk
is [w1]. Note that this implies that the set V of nodes of G is a subset of V 0.

Let E0
1 be the relation:
1 = {([u], a, [v]) | v →∗
E0

R0 ua}.

The graph H0 := (V 0, E0
of [26]. We now deﬁne H as the graph (V 0, E0

1) is precisely the graph constructed in the undecidability proof
3 are as follows:

2 and E0

1 ∪ E0
2 = {(mi, ˆa, m(i−1)) | w2i = a, 1 ≤ i ≤ l},
E0
3 = {([u], $, m(l−i)) | there is a path with label w2(l−i+1) . . . w2l
E0

3), where E0

2 ∪ E0

from [u] to nk in H0}.

If i = l, by convention, we deﬁne w2(l−i+1) . . . w2l as the empty word . Notice that G ⊆ H.
We skip the details of the proof that (a), (b) and (c) hold. An important part of this
proof of is to show that if there is a path with label w2 from n0 to nk in H, then w1 →∗
R0 w2.
This can be obtained as an immediate consequence of Lemma 2 in the proof of Theorem 2
in [26]. Notice that although it might be impossible to construct the graph database H (since
1 is deﬁned in terms of the rewrite problem for R0), our proof only requires the existence
E0
(cid:74)
of such graph database.

4.1 Decidable restrictions
Since the CQA problem in this context is undecidable, it is crucial to look for decidable
(and, ideally, tractable) restrictions of it. We provide three such restrictions in this section:
The ﬁrst one is based on the class of LAV RPCs, while the second one is based on the class
of GAV RPCs. The third one is obtained by modifying RPC interpretation to be from the
origin. It is worth noticing that the restriction to classes of graph databases of bounded
treewidth, which leads to tractability under the semantics of subset repairs, is not useful in
this context: The undecidability result in Theorem 11 holds even over graph databases of
treewidth two.

Restriction to the class of LAV RPCs. As mentioned before, in the relational scenario
the CQA problem for unions of CQs under LAV tgds is tractable, no matter which repair
semantics is used. We already stated a similar result for CQA over graph databases under
LAV RPCs and the subset repair semantics (Theorem 8). We can further extend those
techniques to obtain tractability for our CQA problem under the semantics of ⊕-repairs.
(cid:73) Theorem 12. For each RPQ L and ﬁnite set Γ of LAV RPCs over the same alphabet Σ,
it is the case that ⊕-CQA(L,Γ) is in NLogspace.

The case of the ⊇-repair semantics is diﬀerent: We do not know whether LAV RPCs yield
decidability in this context, but we prove next that at least they do not yield tractability in
data complexity. This establishes a ﬁrst diﬀerence in complexity between CQA under LAV
tgds in the relational context and under LAV RPCs over graph databases.

P. Barceló and G. Fontaine

393

(cid:73) Proposition 13. There exist a ﬁnite alphabet Σ, a non-recursive RPQ L, and a ﬁnite set
Γ of LAV RPCs (without Kleene-star) over Σ, such that ⊇-CQA(L,Γ) is coNP-hard.

Notice that, unlike all previous lower bounds, the one in Proposition 13 is not stated in
terms of the class of word constraints. In fact, the techniques developed for studying CQA
under tgds in the relational case [18] can be adapted to show that under a set Γ of LAV
word constraints the problem ⊇-CQA(L,Γ) is tractable.

Restriction to the class of GAV RPCs.
In the case of the symmetric diﬀerence semantics,
it is easy to adapt the proof of Proposition 9 in order to show that when restricting to GAV
RPCs, our CQA problem is coNP-hard. Note that in the relational case, a similar result
holds.
(cid:73) Proposition 14.
1. For each RPQ L and ﬁnite set Γ of GAV RPCs over the same alphabet Σ, it is the case

2. There exist a ﬁnite alphabet Σ, a non-recursive RPQ L over Σ and a single GAV RPC of

that ⊕-CQA(L,Γ) is in coNP.
the form ab v c, where a, b, c ∈ Σ, such that ⊕-CQA(L,Γ) is coNP-complete.
In the case of the superset semantics, the restriction to GAV RPCs leads to tractability.
Given a graph database G and a set of GAV RPCs Γ, using a classical chase argument, we
can easily compute in Logspace the unique superset repair of G with respect to Γ. This is
identical to what happens in the setting of relational databases.
(cid:73) Proposition 15. For each RPQ L and ﬁnite set Γ of GAV RPCs over the same alphabet
Σ, it is the case that ⊇-CQA(L,Γ) is in NLogspace.

Modifying the interpretation of RPCs.
In the original proposal of Abiteboul and Vianu,
RPQs, and therefore RPCs, are only evaluated from a particular node called the origin.
This is motivated by their application over semi-structured data. Formally, let o be a ﬁxed
node id that we identify as the origin. A graph database G = (V, E), satisﬁes L1 v L2
from the origin, denoted G |=o L1 v L2, if and only if the origin o belongs to V and
{v ∈ V | (o, v) ∈ L1(G)} ⊆ {v ∈ V | (o, v) ∈ L2(G)}. If Γ is a set of RPCs, we write G |=o Γ
if G |=o L1 v L2, for each RPC L1 v L2 in Γ.
We can now modify the deﬁnition of repairs and consistent answers with respect to the
restricted |=o interpretation of RPCs. Assume ? ∈ {⊆,⊇,⊕}. An {o, ?}-repair of a graph
database G under a set of RPCs Γ is deﬁned exactly as an ?-repair of G under Γ, except
that now the satisfaction of the RPCs in Γ is deﬁned with respect to the relation |=o. (For
safety reasons, we assume that G contains the origin o in this case). For instance, G0 is a
{o,⊇}-repair of G under Γ, if (1) G ⊆ G0, (2) G0 |=o Γ, and (3) there is no graph database
G00 such that G ⊆ G00 (cid:40) G0 and G00 |=o Γ.
Furthermore, if L is an RPQ and Γ is a ﬁnite set of RPCs, we deﬁne {o, ?}-CQA(L,Γ) as
the problem of, given a graph database G = (V, E) and a pair (u, v) of nodes in V , checking
whether (u, v) is an {o, ?}-consistent answer of L over G under Γ, i.e., if (u, v) ∈ L(G0), for
each {o, ?}-repair G0 of G under Γ.

By interpreting RPCs under the relation |=o, we obtain decidability for our CQA problem
under the semantics of ⊇-repairs. We do not know whether this can be extended to the
semantics of ⊕-repairs. Notice the diﬀerence with the restriction to LAV RPCs we studied
before: For the latter we could only obtain decidability under the ⊕-repairs semantics.

ICDT 2015

394

On the Data Complexity of Consistent Query Answering over Graph Databases

(cid:73) Theorem 16. For each RPQ L and ﬁnite set Γ of RPCs over the same alphabet Σ, it is
the case that {o,⊇}-CQA(L,Γ) is in coNP.

The diﬀerence here is that the implication problem for RPCs becomes decidable if RPCs
are interpreted under the relation |=o [1]. We adapt the techniques used to prove this fact in
order to obtain Theorem 16.

We do not know whether the bound in Theorem 16 is tight. Interestingly, we can show
that a slight extension on the query language leads to intractability. We reduce from the
problem of 3-colorability. Assume we are given an undirected graph H. From H we construct
a graph database G = (V, E), such that (1) V corresponds to the set of nodes of H plus the
origin o, and (2) E contains edges (o, a, v), for each node v in H, and (u, e, v) and (v, e, u),
for each edge {u, v} in H. Assume that Γ consists of the single constraint a v c1 ∪ c2 ∪ c3.
Intuitively, this tells us that a ⊇-repair of G contains, for each node v 6= o, one, and only
one, edge of the form (o, ci, v), for 1 ≤ i ≤ 3. This edge represents the color assigned to node
v by an assignment of three colors to the nodes of H.
It is not hard to prove that H is 3-colorable if and only if there exists a ⊇-repair G0 of G
such that no two nodes linked by an edge labeled e in G0 are assigned the same color. This
is equivalent to checking that it is not the case that there are paths labeled cie and ci in G0,
for 1 ≤ i ≤ 3, that start in the origin o and reach the same node v. While this cannot be
expressed as an RPQ, it can be easily expressed as an RPQ with inverses [14]. The query is
i represents a backward traversal of an edge labeled ci. We then
have that H is 3-colorable if and only if (o, o) is not an {o,⊇}-consistent answer of Q over G
under Γ. This query can also be expressed as a conjunction of two RPQs [13].
(cid:73) Remark. The restriction presented in this section does not help reducing the complexity
under the semantics of ⊆-repairs. In fact, it can be proved that all lower bounds obtained in
Section 3 continue to hold for the semantics of {o,⊆}-repairs. This is done in the appendix.

Q :=S

i , where c−

1≤i≤3 ciec−

Comparison with CQA in the relational context

5
We compare our results with previous results on CQA obtained in the relational context.
We assume familiarity with relational schemas and CQs. Tuple-generating dependencies,
or tgds, deﬁne one of the most important classes of relational database constraints. They
subsume several other classes of interest, such as inclusion dependencies.
In addition,
they have important applications in data integration, data exchange and ontological query
answering [33, 23, 10]. Formally, a tgd over a relational schema σ is a formula of the form
∀¯x(φ(¯x) → ψ(¯x)), where both φ(¯x) and ψ(¯x) are CQs over σ and each variable in ¯x is
mentioned in φ(¯x). A relational database D over σ satisﬁes this tgd if D |= φ(¯a) implies
D |= ψ(¯a), for each tuple ¯a of elements in D of the same length than ¯x.

As mentioned in the introduction, each word constraint can be naturally seen as a tgd
over the standard relational representation of graph databases. However, lower bounds for
CQA under tgds in the relational setting, such as the ones obtained by ten Cate et al. [18],
cannot be used to obtain lower bounds for CQA under word constraints (or even RPCs) in
the graph database context. This is because word constraints correspond to a restricted class
of tgds deﬁned by chain CQs (which we call chain tgds). However, none of the lower bounds
developed for the data complexity of CQA under tgds applies to this class.

We formalise the class of chain tgds as follows. Let σ be a relational schema that contains

only binary relation symbols. A chain CQ over σ is a CQ of the form

φ(x, y) := ∃u1u2 . . . um−1

(cid:0)R1(x, u1) ∧ R2(u1, u2) ∧ ··· ∧ Rm−1(um−1, y)(cid:1),

P. Barceló and G. Fontaine

395

where each Ri is a relation symbol in σ [21]. That is, the underlying directed graph of a chain
CQ is a path. A chain tgd is one of the form ∀x∀y(φ(x, y) → ψ(x, y)), where both φ(x, y)
and ψ(x, y) are chain CQs. It is easy to see that each word constraint can be represented as
a chain tgd over the standard relational representation of graph databases (in which, for each
a ∈ Σ, there is a binary relation symbol Ea that contains all pairs of nodes that are linked
by an a-labeled edge in the graph database). Conversely, each chain tgd is the representation
of a word constraint.

This allows us to use our proof techniques to obtain lower bounds for CQA under the

restricted class of chain tgds in the relational context:
(cid:73) Proposition 17.
1. Consider a semantics based on subset repairs of relational databases. There is a relational
schema σ that contains only binary relation symbols, a ﬁnite set T of chain tgds and a
union Q of CQs over σ, such that the problem of evaluating certain answers for Q under
T is ΠP
2 -hard. The same holds for the semantics based on the intersection of all subset
repairs.
2. Consider a semantics based on superset repairs of relational databases. There is a
relational schema σ that contains only binary relation symbols, a ﬁnite set T of chain
tgds and a union Q of CQs over σ, such that evaluating certain answers for Q under T
is undecidable. The same holds for the semantics of symmetric diﬀerence repairs.

6

Conclusions and Future Work

In this work we initiated the study of CQA over graph databases. The data complexity of
the problem is in general undecidable or highly intractable, which motivated our search for
decidable, and even tractable restrictions. In the case of subset repair semantics we obtain
tractability by either restricting to the class of LAV RPCs or to the class of graph databases
of bounded treewidth. The class of LAV RPCs also yields tractability for our problem under
the semantics of ⊕-repairs. On the other hand, for the semantics of superset repairs we
obtain decidability if RPCs are interpreted from the origin or if we restrict to the class of
GAV RPCs.

Several questions regarding CQA under the semantics of ⊇- and ⊕-repairs remain open.
For instance, we do not know if CQA under ⊇-repairs is decidable when RPCs are in LAV
form. Neither do we know whether CQA under ⊕-repairs is decidable when RPCs are
interpreted from the origin. We plan to study this in the future.

It would also be interesting to look for diﬀerent kinds restrictions that yield decidability for
our CQA problem. For instance, in the relational scenario it is possible to obtain tractability
in data complexity for CQA under ⊇- and ⊕-repair semantics if the set Γ of tgds is weakly
acyclic [18]. The reason is that in this case there is a polynomial that bounds the size of each
repair of a database D under Γ. We would like to develop a meaningful adaptation of this
notion to the scenario of RPCs in search for similar positive results. This is more diﬃcult
than in the relational case, however, since the notion of acyclicity will have to consider how
regular expressions interact with each other. Another way in which positive results for our
CQA problem under ⊇- and ⊕-repair semantics could be obtained, is by restricting to classes
of RPCs for which the implication problem is decidable. This includes, for instance, classes
of word constraints for which the associated rewrite problem is decidable [26].

While our work concentrates on queries deﬁned as RPQs, all upper bounds presented in
the paper continue to hold in the extended scenario in which queries are deﬁned as conjunctive
RPQs (CRPQs) [13]. In turn, CRPQs might lead to an expressive class of conjunctive RPCs,

ICDT 2015

396

On the Data Complexity of Consistent Query Answering over Graph Databases

which are expressions of the form φ(¯x) v ψ(¯x), for CRPQs φ and ψ. It is interesting to study
how the positive results presented in this paper can be extended to be applied over this class
of constraints.

Acknowledgements. We are grateful to Aidan Hogan and Leonid Libkin for their helpful
comments in earlier versions of the paper. Carsten Lutz and Meghyn Bienvenu also provided
us with important insights on the nature of DL repairs. Barceló and Fontaine are funded by
the Millennium Nucleus Center for Semantic Web Research under Grant NC120004. Fontaine
is also funded by Fondecyt postdoctoral grant 3130491.

1

References
S. Abiteboul, V. Vianu. Regular path queries with constraints. JCSS, 58(3), pages 428–452,
1999.

2 M. Arenas, L. E. Bertossi, Jan Chomicki. Consistent query answers in inconsistent databases.
 In PODS 1999, pages 68–79.

4

3 M. Arenas, W. Fan, L. Libkin. On the complexity of verifying consistency of XML speciﬁcations.
 SIAM J. Comput. 38(3), pages 841–880, 2008.
F. Baader, D. Calvanese, D. L. McGuinness, D. Nardi, P. F. Patel-Schneider (Eds.). The description 
logic handbook: Theory, implementation, and applications. Cambridge University
Press, 2003.
P. Barceló. Querying graph databases. In PODS 2013, pages 175–188.

5
6 M. Bienvenu. On the complexity of consistent query answering in the presence of simple

ontologies. In AAAI 2012.

7 M. Bienvenu, R. Rosati. Tractable approximations of consistent query answering for robust

ontology-based data access. In IJCAI 2013.

8 R. Book, F. Otto String. Rewriting Systems. Springer Verlag, 1993.
9

P. Buneman, W. Fan, S. Weinstein. Path constraints in semi-structured databases. J. Comput.
 Syst. Sci. 61(2), pages 146–193, 2000.

10 A. Calì, G. Gottlob, M. Kifer. Taming the inﬁnite chase: Query answering under expressive

relational constraints. J. Artif. Intell. Res. (JAIR) 48, pages 115–174, 2013.

11 Andrea Calì, D. Lembo, R. Rosati. On the decidability and complexity of query answering

over inconsistent and incomplete databases. In PODS 2003, pages 260–271.

12 D. Calvanese, G. de Giacomo, M. Lenzerini. Structured objects: Modeling and reasoning.

In DOOD 1995, pages 229–246.

13 D. Calvanese, G. de Giacomo, M. Lenzerini, M. Y. Vardi. Containment of conjunctive

regular path queries with inverse. In KR 2000, pages 176–185.

14 D. Calvanese, G. de Giacomo, M. Lenzerini, M. Y. Vardi. Rewriting of regular expressions

and regular path queries. JCSS, 64(3), pages 443–465, 2002.

15 D. Calvanese, G. de Giacomo, M. Lenzerini, M. Y. Vardi. Reasoning on regular path queries.

SIGMOD Record 32(4), pages 83–92, 2003.

16 D. Calvanese, G. de Giacomo, M. Lenzerini. Conjunctive query containment and answering

under description logic constraints. ACM Trans. Comput. Log. 9(3), 2008.

17 D. Calvanese, M. Ortiz, M. Simkus. Containment of regular path queries under description

logic constraints. In IJCAI 2011, pages 805–812.

18 B. ten Cate, G. Fontaine, Ph. G. Kolaitis. On the data complexity of consistent query

answering. In ICDT 2012, pages 22–33.
J. Chomicki, J. Marcinkowski. Minimal-change integrity maintenance using tuple deletions.
Inf. Comput. 197(1–2), pages 90–121, 2005.

19

P. Barceló and G. Fontaine

397

20 B. Courcelle. The monadic second-order logic of graphs I: Recognizable sets of ﬁnite hraphs.

Inf. Comput. 85(1), pages 12–75, 1990.

21 G. Dong. On datalog linearization of chain queries. Theoretical Studies in Computer Science

1992, pages 181–206.

254–291, 2003.

22 W. Fan, J. Siméon: Integrity constraints for XML. J. Comput. Syst. Sci., 66(1), pages

23 R. Fagin, Ph. G. Kolaitis, R. J. Miller, L. Popa. Data exchange: semantics and query

answering. Theor. Comput. Sci. 336(1), pages 89–124, 2005.

24 G. Fontaine. Why is it hard to obtain a dichotomy for consistent query answering? In LICS

25 A. Fuxman, R. J. Miller. First-order query rewriting for inconsistent databases. J. Comput.

2013, pages 550–559.

Syst. Sci. 73(4), pages 610–635, 2007.

26 G. Grahne, A. Thomo. Query containment and rewriting using views for regular path

queries under constraints. In PODS 2003, pages 111–122.

28

27 A. Hogan, A. Harth, A. Passant, S. Decker, A. Polleres. Weaving the pedantic web. In

LDOW 2010.
Ph. G. Kolaitis, Enela Pema. A dichotomy in the complexity of consistent query answering
for queries with two atoms. Inf. Process. Lett. 112(3), pages 77–85, 2012.

29 A. Lopatenko, L. E. Bertossi. Complexity of consistent query answering in databases under

cardinality-based and incremental repair semantics. In ICDT 2007, pages 179–193.

30 G. Lausen, M. Meier, M. Schmidt. SPARQLing constraints for RDF. In EDBT 2008, pages

31 D. Lembo, M. Ruzzi. Consistent query answering over description logic ontologies. In DL

499–509.

2007.

32 D. Lembo, M. Lenzerini, R. Rosati, M. Ruzzi, D. Fabio Savo. Inconsistency-tolerant semantics 
for description logics. In RR 2010, pages 103–117.

33 M. Lenzerini. Data integration: A theoretical perspective. In PODS 2002, pages 233–246.
34 Th. Lukasiewicz, M. V. Martinez, G. I. Simari. Complexity of inconsistency-tolerant query

answering in Datalog+/-. In OTM Conferences 2013, pages 488–500.

35 R. Rosati. On the complexity of dealing with inconsistency in description logic ontologies.

In IJCAI 2011, pages 1057–1062.

36 K.-D. Schewe, B. Thalheim, J. W. Schmidt, I. Wetzel. Integrity enforcement in object37


38

39

oriented databases. In FMLDO 1992, pages 174–195.
J. Wijsen. Condensed representation of database repairs for consistent query answering. In
ICDT 2003, pages 375–390.
J. Wijsen. Certain conjunctive query answering in ﬁrst-order logic. ACM Trans. Database
Syst. 37(2), 9, 2012.
P. T. Wood. Query languages for graph databases. SIGMOD Record 41(1), pages 50–60,
2012.

40 Y. Yuan, G. Wang, L. Chen, H. Wang. Eﬃcient subgraph similarity search on large probabilistic 
graph databases. In PVLDB 5(9), pages 800–811, 2012.

ICDT 2015

