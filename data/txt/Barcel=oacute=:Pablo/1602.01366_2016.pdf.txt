Semantic Acyclicity Under Constraints

Pablo Barceló

Center for Semantic Web Research &

DCC, University of Chile
pbarcelo@dcc.uchile.cl

Georg Gottlob

Dept. of Computer Science

University of Oxford

georg.gottlob@cs.ox.ac.uk

Andreas Pieris

Inst. of Information Systems

TU Wien

pieris@dbai.tuwien.ac.at

6
1
0
2

 

n
u
J
 

3

 
 
]

B
D
.
s
c
[
 
 

2
v
6
6
3
1
0

.

2
0
6
1
:
v
i
X
r
a

ABSTRACT
A conjunctive query (CQ) is semantically acyclic if it is equivalent 
to an acyclic one. Semantic acyclicity has been studied in
the constraint-free case, and deciding whether a query enjoys this
property is NP-complete. However, in case the database is subject 
to constraints such as tuple-generating dependencies (tgds) that
can express, e.g., inclusion dependencies, or equality-generating
dependencies (egds) that capture, e.g., functional dependencies, a
CQ may turn out to be semantically acyclic under the constraints
while not semantically acyclic in general. This opens avenues to
new query optimization techniques. In this paper we initiate and
develop the theory of semantic acyclicity under constraints. More
precisely, we study the following natural problem: Given a CQ and
a set of constraints, is the query semantically acyclic under the constraints,
 or, in other words, is the query equivalent to an acyclic one
over all those databases that satisfy the set of constraints?

We show that, contrary to what one might expect, decidability
of CQ containment is a necessary but not sufﬁcient condition for
the decidability of semantic acyclicity. In particular, we show that
semantic acyclicity is undecidable in the presence of full tgds (i.e.,
Datalog rules). In view of this fact, we focus on the main classes
of tgds for which CQ containment is decidable, and do not capture
the class of full tgds, namely guarded, non-recursive and sticky
tgds. For these classes we show that semantic acyclicity is decidable,
 and its complexity coincides with the complexity of CQ containment.
 In the case of egds, we show that if we focus on keys
over unary and binary predicates, then semantic acyclicity is decidable 
(NP-complete). We ﬁnally consider the problem of evaluating
a semantically acyclic query over a database that satisﬁes a set of
constraints. For guarded tgds and functional dependencies the evaluation 
problem is tractable.

1.

INTRODUCTION

Query optimization is a fundamental database task that
amounts to transforming a query into one that is arguably
more efﬁcient to evaluate. The database theory community
has developed several principled methods for optimization
of conjunctive queries (CQs), many of which are based on
static-analysis tasks such as containment [1]. In a nutshell,
such methods compute a minimal equivalent version of a
CQ, where minimality refers to number of atoms. As argued
by Abiteboul, Hull, and Vianu [1], this provides a theoretical 
notion of “true optimality” for the reformulation of a
CQ, as opposed to practical considerations based on heuristics.
 For each CQ q the minimal equivalent CQ is its core q′
[21]. Although the static analysis tasks that support CQ minimization 
are NP-complete [12], this is not a major problem
for real-life applications, as the input (the CQ) is small.

It is known, on the other hand, that semantic information

about the data, in the form of integrity constraints, alleviates 
query optimization by reducing the space of possible reformulations.
 In the previous analysis, however, constraints
play no role, as CQ equivalence is deﬁned over all databases.
Adding constraints yields a reﬁned notion of CQ equivalence,
 which holds over those databases that satisfy a given
set of constraints only. But ﬁnding a minimal equivalent CQ
in this context is notoriously more difﬁcult than before. This
is because basic static analysis tasks such as containment become 
undecidable when considered in full generality. This
motivated a long research program for ﬁnding larger “islands
of decidability” of such containment problem, based on syntactical 
restrictions on constraints [2, 8, 10, 11, 22, 23].

An important shortcoming of the previous approach, however,
 is that there is no theoretical guarantee that the minimized 
version of a CQ is in fact easier to evaluate (recall
that, in general, CQ evaluation is NP-complete [12]). We
know, on the other hand, quite a bit about classes of CQs
that can be evaluated efﬁciently. It is thus a natural problem
to ask whether constraints can be used to reformulate a CQ
as one in such tractable classes, and if so, what is the cost of
computing such reformulation. Following Abiteboul et al.,
this would provide us with a theoretical guarantee of “true
efﬁciency” for those reformulations. We focus on one of
the oldest and most studied tractability conditions for CQs;
namely, acyclicity. It is known that acyclic CQs can be evaluated 
in linear time [27].

More formally, let us write q ≡Σ q′ whenever CQs q and
q′ are equivalent over all databases that satisfy Σ. In this
work we study the following problem:

PROBLEM :

SEMANTIC ACYCLICITY

INPUT :
QUESTION :

A CQ q and a ﬁnite set Σ of constraints.
Is there an acyclic CQ q′ s.t. q ≡Σ q′?

We study this problem for the two most important classes

of database constraints; namely:

1. Tuple-generating dependencies (tgds), i.e., expressions
of the form ∀¯x∀¯y(φ(¯x, ¯y) → ∃¯zψ(¯x, ¯z)), where φ and
ψ are conjuntions of atoms. Tgds subsume the important 
class of referential integrity constraints (or inclusion 
dependencies).

2. Equality-generating dependencies (egds), i.e., expressions 
of the form ∀¯x(φ(¯x) → y = z), where φ is a
conjunction of atoms and y, z are variables in ¯x. Egds
subsume keys and functional dependencies (FDs).

A useful aspect of tgds and egds is that containment under
them can be studied in terms of the chase procedure [25].

Coming back to semantic acyclicity, the main problem we
study is, of course, decidability. Since basic reasoning with
tgds and egds is, in general, undecidable, we cannot expect
semantic acyclicity to be decidable for arbitrary such constraints.
 Thus, we concentrate on the following question:
Decidability: For which classes of tgds and egds is the problem 
of semantic acyclicity decidable? In such cases, what is
the computational cost of the problem?

Since semantic acyclicity is deﬁned in terms of CQ equivalence 
under constraints, and the latter has received a lot of
attention, it is relevant also to study the following question:
Relationship to CQ equivalence: What is the relationship
between CQ equivalence and semantic acyclicity under con-
straints? Is the latter decidable for each class of tgds and
egds for which the former is decidable?

Notice that if this was the case, one could transfer the mature 
theory of CQ equivalence under tgds and egds to tackle
the problem of semantic acyclicity.

Finally, we want to understand to what extent semantic
acyclicity helps CQ evaluation. Although an acyclic reformulation 
of a CQ can be evaluated efﬁciently, computing
such reformulation might be expensive. Thus, it is relevant
to study the following question:
Evaluation: What is the computational cost of evaluating semantically 
acyclic CQs under constraints?

Semantic acyclicity in the absence of constraints. The semantic 
acyclicity problem in the absence of dependencies
(i.e., checking whether a CQ q is equivalent to an acyclic
one over the set of all databases) is by now well-understood.
Regarding decidability, it is easy to prove that a CQ q is semantically 
acyclic iff its core q′ is acyclic. (Recall that such
q′ is the minimal equivalent CQ to q). It follows that checking 
semantic acyclicity in the absence of constraints is NPcomplete 
(see, e.g., [6]). Regarding evaluation, semantically
acyclic CQs can be evaluated efﬁciently [13, 14, 19].
The relevance of constraints. In the absence of constraints
a CQ q is equivalent to an acyclic one iff its core q′ is
acyclic. Thus, the only reason why q is not acyclic in the
ﬁrst hand is because it has not been minimized. This tells us
that in this context semantic acyclicity is not really different
from usual minimization. The presence of constraints, on
the other hand, yields a more interesting notion of semantic
acyclicity. This is because constraints can be applied on CQs
to produce acyclic reformulations of them.

Example 1. This simple example helps understanding the
role of tgds when reformulating CQs as acyclic ones. Consider 
a database that stores information about customers,
records, and musical styles. The relation Interest contains
pairs (c, s) such that customer c has declared interest in style
s. The relation Class contains pairs (r, s) such that record r
is of style s. Finally, the relation Owns contains a pair (c, r)
when customer c owns record r.

Consider now a CQ q(x, y) deﬁned as follows:

∃z(cid:0)Interest(x, z) ∧ Class(y, z) ∧ Owns(x, y)(cid:1).

This query asks for pairs (c, r) such that customer c owns
record r and has expressed interest in at least one of the

styles with which r is associated. This CQ is a core but it
is not acyclic. Thus, from our previous observations it is not
equivalent to an acyclic CQ (in the absence of constraints).
Assume now that we are told that this database contains
compulsive music collectors only. In particular, each customer 
owns every record that is classiﬁed with a style in
which he/she has expressed interest. This means that the
database satisﬁes the tgd:

τ = Interest(x, z), Class(y, z) → Owns(x, y).

With this information at hand, we can easily reformulate
q(x, y) as the following acyclic CQ q′(x, y):

∃z(cid:0)Interest(x, z) ∧ Class(y, z)(cid:1).

Notice that q and q′ are in fact equivalent over every database
that satisﬁes τ.
Contributions. We observe that semantic acyclicity under
constraints is not only more powerful, but also theoretically
more challenging than in the absence of them. We start by
studying decidability. In the process we also clarify the relationship 
between CQ equivalence and semantic acyclicity.
Results for tgds: Having a decidable CQ containment problem 
is a necessary condition for semantic acyclicity to be
decidable under tgds.1 Surprisingly enough, it is not a sufﬁcient 
condition. This means that, contrary to what one might
expect, there are natural classes of tgds for which CQ containment 
but not semantic acyclicity is decidable. In particular,
 this is the case for the well-known class of full tgds (i.e.,
tgds without existentially quantiﬁed variables in the head).
In conclusion, we cannot directly export techniques from CQ
containment to deal with semantic acyclicity.

In view of the previous results, we concentrate on classes
of tgds that (a) have a decidable CQ containment problem,
and (b) do not contain the class of full tgds. These restrictions 
are satisﬁed by several expressive languages considered 
in the literature. Such languages can be classiﬁed into
three main families depending on the techniques used for
studying their containment problem: (i) guarded tgds [8],
which contain inclusion and linear dependencies, (ii) nonrecursive 
[16], and (iii) sticky sets of tgds [10]. Instead of
studying such languages one by one, we identify two semantic 
criteria that yield decidability for the semantic acyclicity
problem, and then show that each one of the languages satisﬁes 
one such criteria.

• The ﬁrst criterion is acyclicity-preserving chase. This
is satisﬁed by those tgds for which the application of
the chase over an acyclic instance preserves acyclicity.
 Guarded tgds enjoy this property. We establish
that semantic acyclicity under guarded tgds is decidable 
and has the same complexity than its associated
CQ containment problem: 2EXPTIME-complete, and
NP-complete for a ﬁxed schema.

• The second criterion is rewritability by unions of CQs
(UCQs). Intuitively, a class C of sets of tgds has this
property if the CQ containment problem under a set in
C can always be reduced to a UCQ containment problem 
without constraints. Non-recursive and sticky sets
of tgds enjoy this property. In the ﬁrst case the complexity 
matches that of its associated CQ containment
problem: NEXPTIME-complete, and NP-complete if
1 Modulo some mild technical assumptions elaborated in the paper.

the schema is ﬁxed. In the second case, we get a NEXPTIME 
upper bound and an EXPTIME lower bound.
For a ﬁxed schema the problem is NP-complete.

The NP bounds (under a ﬁxed schema) can be seen as
positive results: By spending exponential time in the size of
the (small) query, we can not only minimize it using known
techniques but also ﬁnd an acyclic reformulation if one exists.

Results for egds: After showing that the techniques developed 
for tgds cannot be applied for showing the decidability
of semantic acyclicity under egds, we focus on the class of
keys over unary and binary predicates and we establish a
positive result, namely semantic acyclicity is NP-complete.
We prove this by showing that in such context keys have
acyclicity-preserving chase. Interestingly, this positive result 
can be extended to unary functional dependencies (over
unconstrained signatures); this result has been established
independently by Figueira [17]. We leave open whether the
problem of semantic acyclicity under arbitrary egds, or even
keys over arbitrary schemas, is decidable.
Evaluation: For tgds for which semantic acyclicity is decidable 
(guarded, non-recursive, sticky), we can use the following 
algorithm to evaluate a semantically acyclic CQ q over a
database D that satisﬁes the constraints Σ:

1. Convert q into an equivalent acyclic CQ q′ under Σ.
2. Evaluate q′ on D.
3. Return q(D) = q′(D).

The running time is O(|D|·f (|q|, |Σ|)), where f is a doubleexponential 
function (since q′ can be computed in doubleexponential 
time for each one of the classes mentioned above
and acyclic CQs can be evaluated in linear time). This constitutes 
a ﬁxed-parameter tractable algorithm for evaluating
q on D. No such algorithm is believed to exist for CQ evaluation 
[26]; thus, semantically acyclic CQs under these constraints 
behave better than the general case in terms of evaluation.


But in the absence of constraints one can do better: Evaluating 
semantically acyclic CQs in such context is in polynomial 
time. It is natural to ask if this also holds in the presence
of constraints. This is the case for guarded tgds and (arbi-
trary) FDs. For the other classes of constraints the problem
remains to be investigated.
Further results: The results mentioned above continue to
hold for a more “liberal” notion based on UCQs, i.e., checking 
whether a UCQ is equivalent to an acyclic union of CQs
under the decidable classes of constraints identiﬁed above.
Moreover, in case that a CQ q is not equivalent to an acyclic
CQ q′ under a set of constraints Σ, our proof techniques yield
an approximation of q under Σ [4], that is, an acyclic CQ q′
that is maximally contained in q under Σ. Computing and
evaluating such approximation yields “quick” answers to q
when exact evaluation is infeasible.
Finite vs. inﬁnite databases. The results mentioned above
interpret the notion of CQ equivalence (and, thus, semantic
acyclicity) over the set of both ﬁnite and inﬁnite databases.
The reason is the wide application of the chase we make in
our proofs, which characterizes CQ equivalence under arbitrary 
databases only. This does not present a serious problem 
though, as all the particular classes of tgds for which we
prove decidability in the paper (i.e., guarded, non-recursive,
sticky) are ﬁnitely controllable [3, 18]. This means that

CQ equivalence under arbitrary databases and under ﬁnite
databases coincide. In conclusion, the results we obtain for
such classes can be directly exported to the ﬁnite case.
Organization. Preliminaries are in Section 2. In Section
3 we consider semantic acyclicity under tgds. Acyclicitypreserving 
chase is studied in Section 4, and UCQrewritability 
in Section 5. Semantic acyclicity under egds is
investigated in Section 6. Evaluation of semantically acyclic
CQs is in Section 7. Finally, we present further advancements 
in Section 8 and conclusions in Section 9.

2. PRELIMINARIES
Databases and conjunctive queries. Let C, N and V be
disjoint countably inﬁnite sets of constants, (labeled) nulls
and (regular) variables (used in queries and dependencies),
respectively, and σ a relational schema. An atom over σ is an
expression of the form R(¯v), where R is a relation symbol
in σ of arity n > 0 and ¯v is an n-tuple over C ∪ N ∪ V.
An instance over σ is a (possibly inﬁnite) set of atoms over
σ that contain constants and nulls, while a database over σ
is simply a ﬁnite instance over σ.

One of the central notions in our work is acyclicity. An
instance I is acyclic if it admits a join tree; i.e., if there exists
a tree T and a mapping λ that associates with each node t of
T an atom λ(t) of I, such that the following holds:

1. For each atom R(¯v) in I there is a node t in T such

that λ(t) = R(¯v); and

2. For each null x occurring in I it is the case that the set

{t | x ∈ λ(t)} is connected in T .

A conjunctive query (CQ) over σ is a formula of the form:

q(¯x) := ∃¯y(cid:0)R1(¯v1) ∧ · · · ∧ Rm(¯vm)(cid:1),

(1)

where each Ri(¯vi) (1 ≤ i ≤ m) is an atom without nulls
over σ, each variable mentioned in the ¯vi’s appears either
in ¯x or ¯y, and ¯x are the free variables of q. If ¯x is empty,
then q is a Boolean CQ. As usual, the evaluation of CQs is
deﬁned in terms of homomorphisms. Let I be an instance
and q(¯x) a CQ of the form (1). A homomorphism from q
to I is a mapping h, which is the identity on C, from the
variables and constants in q to the set of constants and nulls
C ∪ N such that Ri(h(¯vi)) ∈ I,2 for each 1 ≤ i ≤ m.
The evaluation of q(¯x) over I, denoted q(I), is the set of all
tuples h(¯x) over C∪N such that h is a homomorphism from
q to I.

It is well-known that CQ evaluation, i.e., the problem of
determining if a particular tuple ¯t belongs to the evaluation
q(D) of a CQ q over a database D, is NP-complete [12]. On
the other hand, CQ evaluation becomes tractable by restricting 
the syntactic shape of CQs. One of the oldest and most
common such restrictions is acyclicity. Formally, a CQ q is
acyclic if the instance consisting of the atoms of q (after replacing 
each variable in q with a fresh null) is acyclic. It is
known from the seminal work of Yannakakis [27], that the
problem of evaluating an acyclic CQ q over a database D
can be solved in linear time O(|q| · |D|).
Tgds and the chase procedure. A tuple-generating dependency 
(tgd) over σ is an expression of the form:

∀¯x∀¯y(cid:0)φ(¯x, ¯y) → ∃¯zψ(¯x, ¯z)(cid:1),

2As usual, we write h(v1, . . . , vn) for (h(v1), . . . , h(vn)).

(2)

where both φ and ψ are conjunctions of atoms without nulls
over σ. For simplicity, we write this tgd as φ(¯x, ¯y) →
∃¯zψ(¯x, ¯z), and use comma instead of ∧ for conjoining
atoms. Further, we assume that each variable in ¯x is mentioned 
in some atom of ψ. We call φ and ψ the body and head
of the tgd, respectively. The tgd in (2) is logically equivalent 
to the expression ∀¯x(qφ(¯x) → qψ(¯x)), where qφ(¯x) and
qψ(¯x) are the CQs ∃¯yφ(¯x, ¯y) and ∃¯zψ(¯x, ¯z), respectively.
Thus, an instance I over σ satisﬁes this tgd if and only if
qφ(I) ⊆ qψ(I). We say that an instance I satisﬁes a set Σ of
tgds, denoted I |= Σ, if I satisﬁes every tgd in Σ.

The chase is a useful tool when reasoning with tgds [8, 16,
22, 25]. We start by deﬁning a single chase step. Let I be
an instance over schema σ and τ = φ(¯x, ¯y) → ∃¯zψ(¯x, ¯z)
a tgd over σ. We say that τ is applicable w.r.t. I if there
exists a tuple (¯a, ¯b) of elements in I such that φ(¯a, ¯b) holds
in I. In this case, the result of applying τ over I with (¯a, ¯b)
is the instance J that extends I with every atom in ψ(¯a, ¯z′),
where ¯z′ is the tuple obtained by simultaneously replacing
each variable z ∈ ¯z with a fresh distinct null not occurring
in I. For such a single chase step we write I

τ,(¯a,¯b)
−−−−→ J.

Let us assume now that I is an instance and Σ a ﬁnite set

of tgds. A chase sequence for I under Σ is a sequence:

τ0,¯c0−−−→ I1

τ1,¯c1−−−→ I2 . . .

I0

of chase steps such that: (1) I0 = I; (2) For each i ≥ 0, τi is

a tgd in Σ; and (3) Si≥0 Ii |= Σ. We call Si≥0 Ii the result

of this chase sequence, which always exists. Although the
result of a chase sequence is not necessarily unique (up to
isomorphism), each such result is equally useful for our purposes 
since it can be homomorphically embedded into every
other result. Thus, from now on, we denote by chase(I, Σ)
the result of an arbitrary chase sequence for I under Σ. Further,
 for a CQ q = ∃¯y(cid:0)R1(¯v1) ∧ · · · ∧ Rm(¯vm)(cid:1), we denote 
by chase(q, Σ) the result of a chase sequence for the
database {R1(¯v′
m)} under Σ obtained after replacing 
each variable x in q with a fresh constant c(x).
Egds and the chase procedure. An equality-generating dependency 
(egd) over σ is an expression of the form:

1), . . . , Rm(¯v′

∀¯x(cid:0)φ(¯x) → xi = xj(cid:1),

where φ is a conjunction of atoms without nulls over σ, and
xi, xj ∈ ¯x. For clarity, we write this egd as φ(¯x) → xi =
xj, and use comma for conjoining atoms. We call φ the
body of the egd. An instance I over σ satisﬁes this egd if,
for every homomorphism h such that h(φ(¯x)) ⊆ I, it is the
case that h(xi) = h(xj). An instance I satisﬁes a set Σ of
egds, denoted I |= Σ, if I satisﬁes every egd in Σ.

Recall that egds subsume functional dependencies, which
in turn subsume keys. A functional dependency (FD) over
σ is an expression of the form R : A → B, where R is a
relation symbol in σ of arity n > 0, and A, B are subsets
of {1, . . . , n}, asserting that the values of the attributes of
B are determined by the values of the attributes of A. For
example, R : {1} → {3}, where R is a ternary relation, is
actually the egd R(x, y, z), R(x, y′, z′) → z = z′. A FD
R : A → B as above is called key if A ∪ B = {1, . . . , n}.

As for tgds, the chase is a useful tool when reasoning with
egds. Let us ﬁrst deﬁne a single chase step. Consider an instance 
I over schema σ and an egd ǫ = φ(¯x) → xi = xj
over σ. We say that ǫ is applicable w.r.t. I if there exists a homomorphism 
h such that h(φ(¯x)) ⊆ I and h(xi) 6= h(xj ).

In this case, the result of applying ǫ over I with h is as fol-
lows: If both h(xi), h(xj) are constants, then the result is
“failure”; otherwise, it is the instance J obtained from I by
identifying h(xi) and h(xj) as follows: If one is a constant,
then every occurrence of the null is replaced by the constant,
and if both are nulls, the one is replaced everywhere by the
other. As for tgds, we can deﬁne the notion of the chase sequence 
for an instance I under a set Σ of egds. Notice that
such a sequence, assuming that is not failing, always is ﬁnite.
 Moreover, it is unique (up to null renaming), and thus
we refer to the chase for I under Σ, denoted chase(I, Σ).

1), . . . , Rm(¯v′

Further, for a CQ q = ∃¯y(cid:0)R1(¯v1) ∧ · · · ∧ Rm(¯vm)(cid:1), we denote 
by chase(q, Σ) the result of a chase sequence for the
database {R1(¯v′
m)} under Σ obtained after replacing 
each variable x in q with a fresh constant c(x); however,
 it is important to clarify that these are special constants,
which are treated as nulls during the chase.
Containment and equivalence. Let q and q′ be CQs and Σ
a ﬁnite set of tgds or egds. Then, q is contained in q′ under Σ,
denoted q ⊆Σ q′, if q(I) ⊆ q′(I) for every instance I such
that I |= Σ. Further, q is equivalent to q′ under Σ, denoted
q ≡Σ q′, whenever q ⊆Σ q′ and q′ ⊆Σ q (or, equivalently,
if q(I) = q′(I) for every instance I such that I |= Σ). The
following well-known characterization of CQ containment
in terms of the chase will be widely used in our proofs:

LEMMA 1. Let q(¯x) and q′(¯x′) be CQs and Σ be a ﬁnite
set of tgds or egds. Then q ⊆Σ q′ if and only if c(¯x) belongs
to the evaluation of q′ over chase(q, Σ).

A problem that is quite important for our work is CQ containment 
under constraints (tgds or egds), deﬁned as fol-
lows: Given CQs q, q′ and a ﬁnite set Σ of tgds or egds,
is it the case that q ⊆Σ q′? Whenever Σ is bound to belong
to a particular class C of sets of tgds, we denote this problem 
as Cont(C). It is clear that the above lemma provides a
decision procedure for the containment problem under egds.
However, this is not the case for tgds.
Decidable containment of CQs under tgds. It is not surprising 
that Lemma 1 does not provide a decision procedure
for solving CQ containment under tgds since this problem is
known to be undecidable [7]. This has led to a ﬂurry of activity 
for identifying syntactic restrictions on sets of tgds that
lead to decidable CQ containment (even in the case when
the chase does not terminate).3 Such restrictions are often
classiﬁed into three main paradigms:
Guardedness: A tgd is guarded if its body contains an atom,
called guard, that contains all the body-variables. Although
the chase under guarded tgds does not necessarily terminate,
query containment is decidable. This follows from the fact
that the result of the chase has bounded treewidth. Let G be
the class of sets of guarded tgds.

PROPOSITION 2. [8] Cont(G) is 2EXPTIME-complete.
It becomes EXPTIME-complete if the arity of the schema is
ﬁxed, and NP-complete if the schema is ﬁxed.

A key subclass of guarded tgds is the class of linear tgds,
that is, tgds whose body consists of a single atom [9], which
in turn subsume the well-known class of inclusion dependencies 
(linear tgds without repeated variables neither in the
3In fact, these restrictions are designed to obtain decidable query
answering under tgds. However, this problem is equivalent to query
containment under tgds (Lemma 1).

   R(x,y), P(y,z) → ∃w  T(x,y,w)

   R(x,y), P(y,z) → ∃w  T(x,y,w)

  T(x,y,z)  → ∃w  S(y,w)

  T(x,y,z)  → ∃w  S(x,w)

× 

(a) 

(b) 

   R(x,y), P(y,z) → ∃w  

 T(x,y,w)

  T(x,y,z)  → ∃w  S(x,w)

Figure 1: Stickiness and marking.

body nor in the head) [15]. Let L and ID be the classes of
sets of linear tgds and inclusions dependencies, respectively.
Cont(C), for C ∈ {L, ID}, is PSPACE-complete, and NPcomplete 
if the arity of the schema is ﬁxed [22].
Non-recursiveness: A set Σ of tgds is non-recursive if its
predicate graph contains no directed cycles. (Non-recursive
sets of tgds are also known as acyclic [16, 24], but we reserve
this term for CQs). Non-recursiveness ensures the termination 
of the chase, and thus decidability of CQ containment.
Let NR be the class of non-recursive sets of tgds. Then:

PROPOSITION 3. [24] Cont(NR) is complete for NEXPTIME,
 even if the arity of the schema is ﬁxed. It becomes
NP-complete if the schema is ﬁxed.

Stickiness: This condition ensures neither termination nor
bounded treewidth of the chase. Instead, the decidability of
query containment is obtained by exploiting query rewriting
techniques. The goal of stickiness is to capture joins among
variables that are not expressible via guarded tgds, but without 
forcing the chase to terminate. The key property underlying 
this condition can be described as follows: During the
chase, terms that are associated (via a homomorphism) with
variables that appear more than once in the body of a tgd
(i.e., join variables) are always propagated (or “stick”) to the
inferred atoms. This is illustrated in Figure 1(a); the ﬁrst set
of tgds is sticky, while the second is not. The formal deﬁnition 
is based on an inductive marking procedure that marks
the variables that may violate the semantic property of the
chase described above [10]. Roughly, during the base step
of this procedure, a variable that appears in the body of a tgd
τ but not in every head-atom of τ is marked. Then, the marking 
is inductively propagated from head to body as shown in
Figure 1(b). Finally, a ﬁnite set of tgds Σ is sticky if no tgd
in Σ contains two occurrences of a marked variable. Then:
PROPOSITION 4. [10] Cont(S) is EXPTIME-complete. It

becomes NP-complete if the arity of the schema is ﬁxed.

Weak versions: Each one of the previous classes has an associated 
weak version, called weakly-guarded [8], weaklyacyclic 
[16], and weakly-sticky [10], respectively, that guarantees 
the decidability of query containment. The underlying 
idea of all these classes is the same: Relax the conditions
in the deﬁnition of the class, so that only those positions that
receive null values during the chase procedure are taken into
consideration. A key property of all these classes is that they
extend the class of full tgds, i.e., those without existentially
quantiﬁed variables. This is not the case for the “unrelaxed”
versions presented above.

3. SEMANTIC ACYCLICITY WITH TGDS
One of the main tasks of our work is to study the problem
of checking whether a CQ q is equivalent to an acyclic CQ
over those instances that satisfy a set Σ of tgds. When this is
the case we say that q is semantically acyclic under Σ. The
semantic acyclicity problem is deﬁned below; C is a class of
sets of tgds (e.g., guarded, non-recursive, sticky, etc.):

PROBLEM :
INPUT :
QUESTION :

SemAc(C)
A CQ q and a ﬁnite set Σ of tgds in C.
Is there an acyclic CQ q′ s.t. q ≡Σ q′?

3.1 Inﬁnite Instances vs. Finite Databases

It is important to clarify that SemAc(C) asks for the existence 
of an acyclic CQ q′ that is equivalent to q under Σ focussing 
on arbitrary (ﬁnite or inﬁnite) instances. However, in
practice we are concerned only with ﬁnite databases. Therefore,
 one may claim that the natural problem to investigate
is FinSemAc(C), which accepts as input a CQ q and a ﬁnite
set Σ ∈ C of tgds, and asks whether an acyclic CQ q′ exists
such that q(D) = q′(D) for every ﬁnite database D |= Σ.

Interestingly, for all the classes of sets of tgds discussed
in the previous section, SemAc and FinSemAc coincide due
to the fact that they ensure the so-called ﬁnite controllability 
of CQ containment. This means that query containment
under arbitrary instances and query containment under ﬁnite
databases are equivalent problems. For non-recursive and
weakly-acyclic sets of tgds this immediately follows from
the fact that the chase terminates. For guarded-based classes
of sets of tgds this has been shown in [3], while for stickybased 
classes of sets of tgds it has been shown in [18]. Therefore,
 assuming that C is one of the above syntactic classes of
sets of tgds, by giving a solution to SemAc(C) we immediately 
obtain a solution for FinSemAc(C).

The reason why we prefer to focus on SemAc(C), instead
of FinSemAc(C), is given by Lemma 1: Query containment
under arbitrary instances can be characterized in terms of
the chase. This is not true for CQ containment under ﬁnite
databases simply because the chase is, in general, inﬁnite.
3.2 Semantic Acyclicity vs. Containment

There is a close relationship between semantic acyclicity 
and a restricted version of CQ containment under sets
of tgds, as we explain next. But ﬁrst we need to recall the
notion of connectedness for queries and tgds. A CQ is connected 
if its Gaifman graph is connected – recall that the
nodes of the Gaifman graph of a CQ q are the variables of
q, and there is an edge between variables x and y iff they
appear together in some atom of q. Analogously, a tgd τ is
body-connected if its body is connected. Then:

PROPOSITION 5. Let Σ be a ﬁnite set of body-connected
tgds and q, q′ two Boolean and connected CQs without common 
variables, such that q is acyclic and q′ is not semantically 
acyclic under Σ. Then q ⊆Σ q′ iff q ∧ q′ is semantically
acyclic under Σ.

As an immediate corollary of Proposition 5, we obtain an
initial boundary for the decidability of SemAc: We can only
obtain a positive result for those classes of sets of tgds for
which the restricted containment problem presented above
is decidable. More formally, let us deﬁne RestCont(C) to
be the problem of checking q ⊆Σ q′, given a set Σ of bodyconnected 
tgds in C and two Boolean and connected CQs q

 
 
 
 
 
 
 
 
x

start

P#

P#

y

P#

Pb

Pa

Pa

Pa

Pb

z

u

Pb

P∗ 

P∗ 

P∗ 

v

end

1. An initialization rule:

start(x), P#(x, y) → sync(y, y).

That is, the ﬁrst element after the special symbol #
(which denotes the beginning of a word over {a, b}) is
synchronized with itself.

Figure 2: The query q from the proof of Theorem 7.

2. For each 1 ≤ i ≤ n, a synchronization rule:

and q′, without common variables, such that q is acyclic and
q′ is not semantically acyclic under Σ. Then:

COROLLARY 6. SemAc(C) is undecidable for every

class C of tgds such that RestCont(C) is undecidable.

As we shall discuss later, RestCont is not easier than general 
CQ containment under tgds, which means that the only
classes of tgds for which we know the former problem to be
decidable are those for which we know CQ containment to
be decidable (e.g., those introduced in Section 2).

At this point, one might be tempted to think that some version 
of the converse of Proposition 5 also holds; that is, the
semantic acyclicity problem for C is reducible to the containment 
problem for C. This would imply the decidability
of SemAc for any class of sets of tgds for which the CQ containment 
problem is decidable. Our next result shows that
the picture is more complicated than this as SemAc is undecidable 
even over the class F of sets of full tgds, which
ensures the decidability of CQ containment:

.

. . . w′
1, . . . , w′

Let w1, . . . , wn and w′

THEOREM 7. The problem SemAc(F) is undecidable.
PROOF. We provide a sketch since the complete construction 
is long. We reduce from the Post correspondence problem 
(PCP) over the alphabet {a, b}. The input to this problem 
are two equally long lists w1, . . . , wn and w′
1, . . . , w′
n
of words over {a, b}, and we ask whether there is a solution,
i.e., a nonempty sequence i1 . . . im of indices in {1, . . . , n}
such that wi1 . . . wim = w′
i1

im
n be an instance of PCP. In
the full proof we construct a Boolean CQ q and a set Σ of full
tgds over the signature {Pa, Pb, P#, P∗, sync, start, end},
where Pa, Pb, P#, P∗ and sync are binary predicates, and
start and end are unary predicates, such that the PCP instance 
given by w1, . . . , wn and w′
n has a solution
iff there exists an acyclic CQ q′ such that q ≡Σ q′. In this
sketch though, we concentrate on the case when the underlying 
graph of q′ is a directed path; i.e, we prove that the PCP
instance has a solution iff there is a CQ q′ whose underlying
graph is a directed path such that q ≡Σ q′. This does not
imply the undecidability of the general case, but the proof of
the latter is a generalization of the one we sketch below.

1, . . . , w′

The restriction of the query q to the symbols that are not
sync is graphically depicted in Figure 2. There, x, y, z, u, v
denote the names of the respective variables. The interpretation 
of sync in q consists of all pairs in {y, u, z}.

Our set Σ of full tgds deﬁnes the synchronization predicate
sync over those acyclic CQs q′ whose underlying graph is a
path. Assume that q′ encodes a word w ∈ {a, b}+. We denote 
by w[i], for 1 ≤ i ≤ |w|, the preﬁx of w of length i. In
such case, the predicate sync contains those pairs (i, j) such
that for some sequence i1 . . . im of indices in {1, . . . , n} we
im = w[j]. Thus,
have that wi1 . . . wim = w[i] and w′
i1
if w is a solution for the PCP instance, then (|w|, |w|) belongs 
to the interpretation of sync.

. . . w′

Formally, Σ consists of the following rules:

sync(x, y), Pwi (x, z), Pw′

i

(y, u) → sync(z, u).

Here, Pw(x, y), for w = a1 . . . at ∈ {a, b}+, denotes
Pa1 (x, x1), . . . , Pat (xt−1, y), where the xi’s are fresh
variables. Roughly, if (x, y) is synchronized and the
element z (resp., u) is reachable from x (resp., y) by
word wi (resp., w′
i), then (z, u) is also synchronized.

3. For each 1 ≤ i ≤ n, a ﬁnalization rule:

start(x), Pa(y, z), Pa(z, u), P∗(u, v), end(v),

sync(y1, y2), Pwi (y1, y), Pw′
where ψ is the conjunction of atoms:

i

(y2, y) → ψ,

P#(x, y), P#(x, z), P#(x, u), P∗(y, v), P∗(z, v),

Pb(z, y), Pb(u, z), Pa(u, y), Pb(y, u),

sync(y, y), sync(z, z), sync(y, z), sync(z, y),
sync(y, u), sync(u, y), sync(z, u), sync(u, z).

This tgd enforces chase(q′, Σ) to contain a “copy” of
q whenever q′ encodes a solution for the PCP instance.
We ﬁrst show that if the PCP instance has a solution given
by the nonempty sequence i1 . . . im, with 1 ≤ i1, . . . , im ≤
n, then there exists an acylic CQ q′ whose underlying graph
is a directed path such that q ≡Σ q′. Let us assume that
wi1 . . . wim = a1 . . . at, where each ai ∈ {a, b}. It is not
hard to prove that q ≡Σ q′, where q′ is as follows:

x′

P#

start

Pa1

. . .

Pat

y′

Pa

z′

Pa

u′

P∗

v′

end

i

Here, again, x′, y′, z′, u′, v′ denote the names of the respective 
variables of q′. All nodes in the above path are different.
 The main reason why q ≡Σ q′ holds is because the
fact w is a solution implies that there are elements y1 and
(y2, y) hold in
y2 such that sync(y1, y2), Pw1 (y1, y) and Pw′
chase(q′, Σ). Thus, the ﬁnalization rule is ﬁred. This creates
a copy of q in chase(q′, Σ), which allows q to be homomorphically 
mapped to chase(q′, Σ).

Now we prove that if there exists an acyclic CQ q′ such
that q ≡Σ q′ and the underlying graph of q′ is a directed
path, then the PCP instance has a solution. Since q ≡Σ q′,
Lemma 1 tells us that chase(q, Σ) ≡ chase(q′, Σ) are homomorphically 
equivalent. But then chase(q′, Σ) must contain 
at least one variable labeled start and one variable labeled 
end. The ﬁrst variable cannot have incoming edges
(otherwise, chase(q′, Σ) would not homomorphically map
to chase(q, Σ)), while the second one cannot have outcoming 
edges (for the same reason). Thus, it is the ﬁrst variable
x′ of q′ that is labeled start and the last one v′ that is labeled
end. Further, all edges reaching v′ in q′ must be labeled P∗
(otherwise q′ does not homomorphically map to q). Thus,
this is the label of the last edge of q′ that goes from variable
u′ to v′. Analogously, the edge that leaves x′ in q′ is labeled
P#. Further, any other edge in q′ is labeled Pa, Pb, or sync.

 
 
 
1 and y′

2 such that sync(y′

Notice now that v′ must have an incoming edge labeled
P∗ in chase(q′, Σ) from some node u′′ that has an outgoing 
edge with label Pa (since q homomorphically maps to
chase(q′, Σ)). By deﬁnition of Σ, this could only have happened 
if the ﬁnalization rule is ﬁred. In particular, u′ is preceded 
by node z′, which in turn is preceded by y′, and there
are elements y′
1, y′)
1, y′
and Pw′
In fact, the unique
(y′
i).
path from y′
This means that the atom sync(y′
2) was not one of the
edges of q′, but must have been produced during the chase
by ﬁring the initialization or the synchronization rules, and
so on. This process must ﬁnish in the second element x∗ of
q′. (Recall that sync(x∗, x∗) belongs to chase(q′, Σ) due to
the ﬁrst rule of Σ). We conclude that our PCP instance has a
solution.

2, y′) hold in chase(q′, Σ).
1 (resp., y′

2) to y′ in q′ is labeled wi (resp., w′

2), Pw1(y′

i

1, y′

Theorem 7 rules out any class that captures the class of
full tgds, e.g., weakly-guarded, weakly-acyclic and weaklysticky 
sets of tgds. The question that comes up is whether
the non-weak versions of the above classes, namely guarded,
non-recursive and sticky sets of tgds, ensure the decidability
of SemAc, and what is the complexity of the problem. This
is the subject of the next two sections.

4. ACYCLICITY-PRESERVING CHASE

We propose a semantic criterion, the so-called acyclicitypreserving 
chase, that ensures the decidability of SemAc(C)
whenever the problem Cont(C) is decidable. This criterion
guarantees that, starting from an acyclic instance, it is not
possible to destroy its acyclicity during the construction of
the chase. We then proceed to show that the class of guarded
sets of tgds has acyclicity-preserving chase, which immediately 
implies the decidability of SemAc(G), and we pinpoint
the exact complexity of the latter problem. Notice that nonrecursiveness 
and stickiness do not enjoy this property, even
in the restrictive setting where only unary and binary predicates 
can be used; more details are given in the next section.
The formal deﬁnition of our semantic criterion follows:

Deﬁnition 1. (Acyclicity-preserving Chase) We say that
a class C of sets of tgds has acyclicity-preserving chase if,
for every acyclic CQ q, set Σ ∈ C, and chase sequence for q
under Σ, the result of such a chase sequence is acyclic.

We can then prove the following small query property:

PROPOSITION 8. Let Σ be a ﬁnite set of tgds that belongs 
to a class that has acyclicity-preserving chase, and q
a CQ. If q is semantically acyclic under Σ, then there exists
an acyclic CQ q′, where |q′| ≤ 2 · |q|, such that q ≡Σ q′.

The proof of the above result relies on the following technical 
lemma, established in [8] (using slightly different ter-
minology), that will also be used later in our investigation:

LEMMA 9. Let q(¯x) be a CQ, I an acyclic instance, and
¯c a tuple of distinct constants occurring in I such that q(¯c)
holds in I. There exists an acyclic CQ q′(¯x), where q′ ⊆ q
and |q′| ≤ 2 · |q|, such that q′(¯c) holds in I.

For the sake of completeness, we would like to recall the
idea of the construction underlying Lemma 9, which is illustrated 
in Figure 3. Assuming that α1, . . . , α5 are the atoms
of q, there exists a homomorphism µ that maps α1 ∧ . . . ∧ α5

β 1

β 3

β 2

β

β 1

β 2

β 3

β

  µ ( α2) 

  µ ( α4) 

  µ ( α1) 

  µ ( α3) 

  µ ( α5) 

  µ ( α2) 

  µ ( α4) 

  µ ( α1) 

  µ ( α3) 

  µ ( α5) 

   α1    ∧    

 α2   ∧    α3   ∧    

 α4    ∧    α5 

   α1    ∧    

 α2   ∧    α3   ∧    

 α4    ∧    α5 

Figure 3: The compact acyclic query.

to the join tree T of the acyclic instance I (the shaded tree
in Figure 3). Consider now the subtree Tq of T consisting
of all the nodes in the image of the query and their ancestors.
 From Tq we extract the smaller tree F also depicted in
Figure 3; F = (V, E) is obtained as follows:

1. V consists of all the root and leaf nodes of Tq, and all

the inner nodes of Tq with at least two children; and

2. For every v, u ∈ V , (v, u) ∈ E iff u is a descendant
of v in Tq, and the only nodes of V that occur on the
unique shortest path from v to u in Tq are v and u.

It is easy to verify that F is a join tree, and has at most 2 · |q|
nodes. The acyclic conjunctive query q′ is deﬁned as the
conjunction of all atoms occurring in F .

Notice that a result similar to Lemma 9 is implicit in [4],
where the problem of approximating conjunctive queries is
investigated. However, from the results of [4], we can only
conclude the existence of an exponentially sized acyclic CQ
in the arity of the underlying schema, while Lemma 9 establishes 
the existence of an acyclic query of linear size. This is
decisive for our later complexity analysis. Having the above
lemma in place, it is not difﬁcult to establish Proposition 8.

PROOF OF PROPOSITION 8. Since, by hypothesis, q is
semantically acyclic under Σ, there exists an acyclic CQ
q′′(¯x) such that q ≡Σ q′′. By Lemma 1, c(¯x) belongs to
the evaluation of q over chase(q′′, Σ). Recall that Σ belongs
to a class that has acyclicity-preserving chase, which implies
that chase(q′′, Σ) is acyclic. Hence, by Lemma 9, there exists 
an acyclic CQ q′, where q′ ⊆ q and |q′| ≤ 2 · |q|, such
that c(¯x) belongs to the evaluation of q′ over chase(q′′, Σ).
By Lemma 1, q′′ ⊆Σ q′, and therefore q ⊆Σ q′. We conclude 
that q ≡Σ q′, and the claim follows.

It is clear that Proposition 8 provides a decision procedure
for SemAc(C) whenever C has acyclicity-preserving chase
and Cont(C) is decidable. Given a CQ q, and a ﬁnite set
Σ ∈ C:

1. Guess an acyclic CQ q′ of size at most 2 · |q|; and
2. Verify that q ⊆Σ q′ and q′ ⊆Σ q.
The next result follows:

THEOREM 10. Consider a class C of sets of tgds that has
acyclicity-preserving chase. If the problem Cont(C) is decidable,
 then SemAc(C) is also decidable.
4.1 Guardedness

We proceed to show that SemAc(G) is decidable and has
the same complexity as CQ containment under guarded tgds:

 
 
 
 
 
 
 
 
 
 
 
 
 
 
THEOREM 11. SemAc(G) is complete for 2EXPTIME. It
becomes EXPTIME-complete if the arity of the schema is
ﬁxed, and NP-complete if the schema is ﬁxed.

The rest of this section is devoted to establish Theorem 11.

Decidability and Upper Bounds
We ﬁrst show that:

PROPOSITION 12. G has acyclicity-preserving chase.

The above result, combined with Theorem 10, implies the
decidability of SemAc(G). However, this does not say anything 
about the complexity of the problem. With the aim of
pinpointing the exact complexity of SemAc(G), we proceed
to analyze the complexity of the decision procedure underlying 
Theorem 10. Recall that, given a CQ q, and a ﬁnite set
Σ ∈ G, we guess an acyclic CQ q′ such that |q′| ≤ 2 · |q|,
and verify that q ≡Σ q′. It is clear that this algorithm runs
in non-deterministic polynomial time with a call to a C oracle,
 where C is a complexity class powerful enough for solving 
Cont(G). Thus, Proposition 2 implies that SemAc(G)
is in 2EXPTIME, in EXPTIME if the arity of the schema is
ﬁxed, and in NP if the schema is ﬁxed. One may ask why
for a ﬁxed schema the obtained upper bound is NP and not
2 . Observe that the oracle is called only once in order to
ΣP
solve Cont(G), and since Cont(G) is already in NP when
the schema is ﬁxed, it is not really needed in this case.

Lower Bounds
Let us now show that the above upper bounds are optimal.
 By Proposition 5, RestCont(G) can be reduced in constant 
time to SemAc(G). Thus, to obtain the desired lower
bounds, it sufﬁces to reduce in polynomial time Cont(G) to
RestCont(G). Interestingly, the lower bounds given in Section 
2 for Cont(G) hold even if we focus on Boolean CQs
and the left-hand side query is acyclic. In fact, this is true,
not only for guarded, but also for non-recursive and sticky
sets of tgds. Let AcBoolCont(C) be the following problem:
Given an acyclic Boolean CQ q, a Boolean CQ q′, and a
ﬁnite set Σ ∈ C of tgds, is it the case q ⊆Σ q′?

From the above discussion, to establish the desired lower
bounds for guarded sets of tgds (and also for the other classes
of tgds considered in this work), it sufﬁces to reduce in polynomial 
time AcBoolCont to RestCont. To this end, we introduce 
the so-called connecting operator, which provides a
generic reduction from AcBoolCont to RestCont.
Connecting operator. Consider an acyclic Boolean CQ q, a
Boolean CQ q′, and a ﬁnite set Σ of tgds. We assume that

both q, q′ are of the form ∃¯y(cid:0)R1(¯v1) ∧ · · · ∧ Rm(¯vm)(cid:1). The

application of the connecting operator on (q, q′, Σ) returns
the triple (c(q), c(q′), c(Σ)), where

• c(q) is the query

∃¯y∃w(cid:0)R⋆

1(¯v1, w) ∧ · · · ∧ R⋆

where w is a new variable not in q, each R⋆
predicate, and also aux is a new binary predicate;

m(¯vm, w) ∧ aux (w, w)(cid:1),
i is a new

• c(q′) is the query

∃¯y∃w∃u∃v(cid:0)R⋆

m(¯vm, w) ∧

1(¯v1, w) ∧ · · · ∧ R⋆
aux (w, u) ∧ aux (u, v) ∧ aux (v, w)(cid:1),

where w, u, v are new variables not in q; and

• Finally, c(Σ) = {c(τ ) | τ ∈ Σ}, where for a tgd τ =

φ(¯x, ¯y) → ∃¯zψ(¯x, ¯z), c(τ ) is the tgd

φ⋆(¯x, ¯y, w) → ∃¯zψ⋆(¯x, ¯z, w),

with φ⋆(¯x, ¯y, w), ψ⋆(¯x, ¯z, w) be the conjunctions obtained 
from φ(¯x, ¯y), ψ(¯x, ¯z), respectively, by replacing 
each atom R(x1, . . . , xn) with R⋆(x1, . . . , xn, w),
where w is a new variable not occurring in τ.

This concludes the deﬁnition of the connecting operator. A
class C of sets of tgds is closed under connecting if, for every
set Σ ∈ C, c(Σ) ∈ C. It is easy to verify that c(q) remains
acyclic and is connected, c(q′) is connected and not semantically 
acyclic under c(Σ), and c(Σ) is a set of body-connected
tgds. It can be also shown that q ⊆Σ q′ iff c(q) ⊆c(Σ) c(q′).
From the above discussion, it is clear that the connecting
operator provides a generic polynomial time reduction from
AcBoolCont(C) to RestCont(C), for every class C of sets
of tgds that is closed under connecting. Then:

PROPOSITION 13. Let C be a class of sets of tgds that is
closed under connecting such that AcBoolCont(C) is hard
for a complexity class C that is closed under polynomial time
reductions. Then, SemAc(C) is also C-hard.

Back to guardedness. It is easy to verify that the class
of guarded sets of tgds is closed under connecting. Thus,
the lower bounds for SemAc(G) stated in Theorem 11
follow from Propositions 2 and 13. Note that, although
Proposition 2 refers to Cont(G), the lower bounds hold for
AcBoolCont(G); this is implicit in [8].

As said in Section 2, a key subclass of guarded sets of tgds
is the class of linear tgds, i.e., tgds whose body consists of a
single atom, which in turn subsume the well-known class of
inclusion dependencies. By exploiting the non-deterministic
procedure employed for SemAc(G), and the fact that both
linear tgds and inclusion dependencies are closed under connecting,
 we can show that:

THEOREM 14. SemAc(C), for C ∈ {L, ID}, is complete
It becomes NP-complete if the arity of the

for PSPACE.
schema is ﬁxed.

5. UCQ REWRITABILITY

Even though the acyclicity-preserving chase criterion was
very useful for solving SemAc(G), it is of little use for nonrecursive 
and sticky sets of tgds. As we show in the next
example, neither NR nor S have acyclicity-preserving chase:

Example 2. Consider the acyclic CQ and the tgd

τ = P (x), P (y) → R(x, y),

q = ∃¯x(cid:0)P (x1)∧. . .∧P (xn)(cid:1)

where {τ } is both non-recursive and sticky, but not guarded.
In chase(q, {τ }) the predicate R holds all the possible pairs
that can be formed using the terms x1, . . . , xn. Thus, in
the Gaifman graph of chase(q, {τ }) we have an n-clique,
which means that is highly cyclic. Notice that our example
illustrates that also other favorable properties of the CQ are
destroyed after chasing with non-recursive and sticky sets of
tgds, namely bounded (hyper)tree width.4

4Notice that guarded sets of tgds over predicates of bounded arity
preserve the bounded hyper(tree) width of the query.

In view of the fact that the methods devised in Section 4
cannot be used for non-recursive and sticky sets of tgds, new
techniques must be developed. Interestingly, NR and S share
an important property, which turned out to be very useful for
semantic acyclicity: UCQ rewritability. Recall that a union
of conjunctive queries (UCQ) is an expression of the form

schema σ. The evaluation of Q over an instance I, denoted

Q(¯x) = W1≤i≤n qi(¯x), where each qi is a CQ over the same
Q(I), is deﬁned as S1≤i≤n qi(I). The formal deﬁnition of

UCQ rewritability follows:

Deﬁnition 2. (UCQ Rewritability) A class C of sets of
tgds is UCQ rewritable if, for every CQ q, and Σ ∈ C, we
can construct a UCQ Q such that: For every CQ q′(¯x), q′ ⊆Σ
q iff c(¯x) ∈ Q(Dq′ ), with Dq′ be the database obtained from
q′ after replacing each variable x with c(x).

In other words, UCQ rewritability suggests that query containment 
can be reduced to the problem of UCQ evaluation.
It is important to say that this reduction depends only on the
right-hand side CQ and the set of tgds, but not on the lefthand 
side query. This is crucial for establishing the desirable
small query property whenever we focus on sets of tgds that
belong to a UCQ rewritable class. At this point, let us clarify
that the class of guarded sets of tgds is not UCQ rewritable,
which justiﬁes our choice of a different semantic property,
that is, acyclicity-preserving chase, for its study.

Let us now show the desirable small query property. For
each UCQ rewritable class C of sets of tgds, there exists a
computable function fC(·, ·) from the set of pairs consisting
of a CQ and a set of tgds in C to positive integers such that
the following holds: For every CQ q, set Σ ∈ C, and UCQ
rewriting Q of q and Σ, the height of Q, that is, the maximal
size of its disjuncts, is at most fC(q, Σ). The existence of the
function fC follows by the deﬁnition of UCQ rewritability.
Then, we show the following:

PROPOSITION 15. Let C be a UCQ rewritable class, Σ ∈
C a ﬁnite set of tgds, and q a CQ. If q is semantically acyclic
under Σ, then there exists an acyclic CQ q′, where |q′| ≤
2 · fC(q, Σ), such that q ≡Σ q′.

PROOF. Since q is semantically acyclic under Σ, there exists 
an acyclic CQ q′′(¯x) such that q ≡Σ q′′. As C is UCQ
rewritable, there exists a UCQ Q such that c(¯x) ∈ Q(Dq′′ ),
which implies that there exists a CQ qr (one of the disjuncts
of Q) such that c(¯x) ∈ qr(Dq′′ ). Clearly, |qr| ≤ fC(q, Σ).
But Dq′′ is acyclic, and thus Lemma 9 implies the existence
of an acyclic CQ q′, where q′ ⊆ qr and |q′| ≤ 2 · fC(q, Σ),
such that c(¯x) ∈ q′(Dq′′ ). The latter implies that q′′ ⊆ q′.
By hypothesis, q ⊆Σ q′′, and hence q ⊆Σ q′. For the other
direction, we ﬁrst show that qr ⊆Σ q (otherwise, Q is not a
UCQ rewriting). Since q′ ⊆ qr, we get that q′ ⊆Σ q. We
conclude that q ≡Σ q′, and the claim follows.

It is clear that Proposition 15 provides a decision procedure 
for SemAc(C) whenever C is UCQ rewritable, and
Cont(C) is decidable. Given a CQ q, and a ﬁnite set Σ ∈ C:
1. Guess an acyclic CQ q′ of size at most 2 · fC(q, Σ); and
2. Verify that q ⊆Σ q′ and q′ ⊆Σ q.
The next result follows:
THEOREM 16. Consider a class C of sets of tgds that is
UCQ rewritable. If the problem Cont(C) is decidable, then
SemAc(C) is also decidable.

5.1 Non-Recursiveness

As already said, the key property of NR that we are going
to exploit for solving SemAc(NR) is UCQ rewritability. For
a CQ q and a set Σ of tgds, let pq,Σ and aq,Σ be the number of
predicates in q and Σ, and the maximum arity over all those
predicates, respectively. The next result is implicit in [20]:5

PROPOSITION 17. NR is UCQ rewritable. Furthermore,

fNR(q, Σ) = pq,Σ · (aq,Σ · |q| + 1)aq,Σ .

The above result, combined with Theorem 16, implies the
decidability of SemAc(NR). For the exact complexity of the
problem, we simply need to analyze the complexity of the
non-deterministic algorithm underlying Theorem 16. Observe 
that when the arity of the schema is ﬁxed the function 
fNR is polynomial, and therefore Proposition 17 guarantees 
the existence of a polynomially sized acyclic CQ. In
this case, by exploiting Proposition 3, it is easy to show that
SemAc(NR) is in NEXPTIME, and in NP if the schema is
ﬁxed. However, things are a bit cryptic when the arity of the
schema is not ﬁxed. In this case, fNR is exponential, and thus
we have to guess an acyclic CQ of exponential size. But now
the fact that Cont(NR) is in NEXPTIME (by Proposition 3)
alone is not enough to conclude that SemAc(NR) is also in
NEXPTIME. We need to understand better the complexity
of the query containment algorithm for NR.

Recall that given two CQs q(¯x), q′(¯x), and a ﬁnite set Σ ∈
NR, by Lemma 1, q ⊆Σ q′ iff c(¯x) ∈ q′(chase(q, Σ)). By
exploiting non-recursiveness, it can be shown that if c(¯x) ∈
q′(chase(q, Σ)), then there exists a chase sequence

q = I0

τ0,¯c0−−−→ I1

τ1,¯c1−−−→ I2 . . . In−1

τn−1,¯cn−1
−−−−−−−→ In

of q and Σ, where n = |q′| · (bΣ)O(pq′ ,Σ), with bΣ be the
maximum number of atoms in the body of a tgd of Σ, such
that c(¯x) ∈ q′(In). The query containment algorithm for
NR simply guesses such a chase sequence of q and Σ, and
checks whether c(¯x) ∈ q′(In). Since n is exponential, this
algorithm runs in non-deterministic exponential time. Now,
recall that for SemAc(NR) we need to perform two containment 
checks where either the left-hand side or the right-hand
side query is of exponential size. But in both cases the containment 
algorithm for NR runs in non-deterministic exponential 
time, and hence SemAc(NR) is in NEXPTIME. The
lower bounds are inherited from AcBoolCont(NR) since NR
is closed under connecting (see Proposition 13). Then:

THEOREM 18. SemAc(NR) is complete for NEXPTIME,
It becomes NPeven 
if the arity of the schema is ﬁxed.
complete if the schema is ﬁxed.

5.2 Stickiness

We now focus on sticky sets of tgds. As for NR, the key
property of S that we are going to use is UCQ rewritability.
The next result has been explicitly shown in [20]:

PROPOSITION 19. S is UCQ rewritable. Furthermore,

fS(q, Σ) = pq,Σ · (aq,Σ · |q| + 1)aq,Σ .

The above result, combined with Theorem 16, implies the
decidability of SemAc(S). Moreover, Proposition 19 allows
us to establish an optimal upper bound when the arity of the

5The work [20] does not consider NR. However, the rewriting algorithm 
in that paper works also for non-recursive sets of tgds.

schema is ﬁxed since in this case the function fS is polynomial.
 In fact, we show that SemAc(S) is NP-complete when
the arity of the schema is ﬁxed. The NP-hardness is inherited 
from AcBoolCont(S) since S is closed under connecting
(see Proposition 13). Now, when the arity of the schema is
not ﬁxed the picture is still foggy. In this case, the function 
fS is exponential, and thus by following the usual guess
and check approach we get that SemAc(S) is in NEXPTIME,
while Proposition 13 implies an EXPTIME lower bound. To
sum up, our generic machinery based on UCQ rewritability
shows that:

THEOREM 20. SemAc(S) is in NEXPTIME and hard for

EXPTIME. It becomes NP-complete if the arity is ﬁxed.

An interesting question that comes up is whether for sticky
sets of tgds a stronger small query property than Proposition 
15 can be established, which guarantees the existence of
a polynomially sized equivalent acyclic CQ. It is clear that
such a result would allow us to establish an EXPTIME upper
bound for SemAc(S). At this point, one might be tempted to
think that this can be achieved by showing that the function
fS is actually polynomial even if the arity of the schema is
not ﬁxed. The next example shows that this is not the case.
We can construct a sticky set Σ of tgds and a CQ q such that,
for every UCQ rewriting Q for q and Σ, the height of Q is
exponential in the arity.

H

(cid:1)

 

x

y

w1

w2

z

R (x,y,z,w1 )

x

y

w1

w2

z

(cid:1) 

H

(cid:1)

 

(cid:1) 

R (x,y,z,w2)

H

H

H

H

H

x

y

w1

w2

z

R (x,y,z,w1 )

x

w1

w2

y

z

R (x,y,z,w2)

Figure 4: From a “tree” to a grid via key dependencies.

Acyclicity-preserving chase. It is easy to show via a simple
example that keys over binary and ternary predicates do not
enjoy the acyclicity-preserving chase property:

Example 4. Let q be the acyclic query

R(x, y) ∧ S(x, y, z) ∧ S(x, z, w) ∧ S(x, w, v) ∧ R(x, v).
After applying on q the key R(x, y), R(x, z) → y = z,
which simply states that the ﬁrst attribute of the binary predicate 
R is the key, we obtain the query

Example 3. Let Σ be the sticky set of tgds given below;

R(x, y) ∧ S(x, y, z) ∧ S(x, z, w) ∧ S(x, w, y),

we write ¯xj

(cid:8)Pi(¯xi−1

1

i for the tuple of variables xi, xi+1, . . . , xj:
, Z, ¯xn

i+1, Z, O), Pi(¯xi−1

i+1, Z, O) →

, O, ¯xn

1
, Z, ¯xn

Pi−1(¯xi−1

1

i+1, Z, O)(cid:9)i∈{1,...,n}

.

Consider also the Boolean CQ

P0(0, . . . , 0, 0, 1).

It can be shown that, for every UCQ rewriting Q for q and Σ,
the disjunct of Q that mentions only the predicate Pn contains 
exactly 2n atoms. Therefore, there is no UCQ rewriting
for q and Σ of polynomial height, which in turn implies that
fS cannot be polynomial in the arity of the schema.

The above discussion reveals the need to identify a more
reﬁned property of stickiness than UCQ rewritability, which
will allow us to close the complexity of SemAc(S) when the
arity is not ﬁxed. This is left as an interesting open problem.

6. SEMANTIC ACYCLICITY WITH EGDS
Up to now, we have considered classes of constraints that
are based on tgds. However, semantic acyclicity can be naturally 
deﬁned for classes of egds. Hence, one may wonder
whether the techniques developed in the previous sections
can be applied for egd-based classes of constraints. Unfortunately,
 the situation changes dramatically even for the simplest 
subclass of egds, i.e., keys.
6.1 Peculiarity of Keys

We show that the techniques developed in the previous
sections for tgds cannot be applied for showing the decidability 
of semantic acyclicity under keys, and thus under
egds. Although the notions of acyclicity-preserving chase
(Deﬁnition 1) and UCQ rewritability (Deﬁnition 2) can be
naturally deﬁned for egds, are of little use even if we focus
on keys.

which is clearly cyclic.

With the aim of emphasizing the peculiarity of keys, we
give a more involved example, which shows that a tree-like
query can be transformed via two keys into a highly cyclic
query that contains a grid. Interestingly, this shows that also
other desirable properties, in particular bounded (hyper)tree
width, are destroyed when we chase a query using keys.

Example 5. Consider the CQ q depicted in Figure 4 (ignoring 
for the moment the dashed boxes). Although seemingly 
q contains an n×n grid, it can be veriﬁed that the gridlike 
structure in the ﬁgure is actually a tree. In addition, q
contains atoms of the form R(x, y, z, w) as explained in the
ﬁgure. More precisely, for each of the open squares occurring 
in the ﬁrst column (e.g., the upper-left shaded square),
we have the two atoms R(x, y, z, w1) and R(x, y, z, w2) represented 
by the two hyperedges on the left. Moreover, for
each of the internal open squares and the open squares occurring 
in the last column (e.g., the upper-right shaded square),
we have the two atoms R(x, y, z, w1) and R(x, y, z, w2) represented 
by the two hyperedges on the right. Observe that q
is an acyclic query. Consider now the set Σ of keys:

ǫ1 = R(x, y, z, w), R(x, y, z, w′) → w = w′

ǫ2 = H(x, y), H(x, z) → y = z.

Notice that H(·, ·) stores the horizontal edges. It is not difﬁcult 
to see that chase(q, Σ) contains an n × n grid. Roughly,
as described at the bottom of Figure 4, by ﬁrst applying ǫ1
we close the open squares of the ﬁrst column, while the open
squares of the second column have now the same shape as
the ones of the ﬁrst column, but with a dangling H-edge.
Then, by applying ǫ2, the two H-edges collapse into a single 
edge, and we obtain open squares that have exactly the
same shape as those of the ﬁrst column. After ﬁnitely many
chase steps, all the squares are closed, and thus chase(q, Σ)

indeed contains an n× n grid. Therefore, although the query
q is acyclic, chase(q, Σ) is far from being acyclic. Observe
also that the (hyper)tree width of chase(q, Σ) depends on n,
while q has (hyper)tree width 3.

UCQ rewritability. It is not hard to show that keys are not
UCQ rewritable. This is not surprising due to the transitive
nature of equality. Intuitively, the UCQ rewritability of keys
implies that a ﬁrst-order (FO) query can encode the fact that
the equality relation is transitive. However, it is well-known
that this is not possible due to the inability of FO queries to
express recursion.
6.2 Keys over Constrained Signatures

Despite the peculiar nature of keys as discussed above, we
can establish a positive result regarding semantic acyclicity
under keys, providing that only unary and binary predicates
can be used. This is done by exploiting the following generic
result, which is actually the version of Theorem 10 for egdbased 
classes:

THEOREM 21. Consider a class C of sets of egds.

If
C has acyclicity-preserving chase, then SemAc(C) is NPcomplete,
 even if we allow only unary and binary predicates.

The proof of the above result is along the lines of the proof
for Theorem 10, and exploits the fact that the containment
problem under egds is feasible in non-deterministic polynomial 
time (this can be shown by using Lemma 1). The lower
bound follows from [14], which shows that the problem of
checking whether a Boolean CQ over a single binary relation
is equivalent to an acyclic one is NP-hard. We now show the
following positive result for the class of keys over unary and
binary predicates, denoted K2:

PROPOSITION 22. K2 has acyclicity-preserving chase.

Notice that the above result is not in a conﬂict with Examples 
4 and 5, since both examples use predicates of arity
greater than two. It is now straightforward to see that:

THEOREM 23. SemAc(K2) is NP-complete.

Interestingly, Theorem 23 can be extended to unary functional 
dependencies (over unconstrained signatures), that is,
FDs of the form R : A → B, where R is a relational symbol 
of arity n > 0 and the cardinality of A is one. This
result has been established independently by Figueira [17].
Let us recall that egds ensure the ﬁnite controllability of CQ
containment. Consequently, Theorem 23 holds even for FinSemAc,
 which takes as input a CQ q and a set Σ of egds,
and asks for the existence of an acyclic CQ q′ such that q
and q′ are equivalent over all ﬁnite databases that satisfy Σ.

7. EVALUATION OF SEMANTICALLY

ACYCLIC QUERIES

As it has been noted in different scenarios in the absence
of constraints, semantic acyclicity has a positive impact on
query evaluation [4, 5, 6]. We observe here that such good
behavior extends to the notion of semantic acyclicity for
CQs under the decidable classes of constraints we identiﬁed 
in the previous sections.
In particular, evaluation of
semantically acyclic CQs under constraints in such classes
is a ﬁxed-parameter tractable (fpt) problem, assuming the
parameter to be |q| + |Σ|. (Here, |q| and |Σ| represent the

size of reasonable encodings of q and Σ, respectively). Recall 
that this means that the problem can be solved in time
O(|D|c·f (|q|+|Σ|)), for c ≥ 1 and f a computable function.
Let C be a class of sets of tgds. We deﬁne SemAcEval(C)
to be the following problem: The input consists of a set of
constraints Σ in C, a semantically acyclic CQ q under Σ, a
database D such that D |= Σ, and a tuple ¯t of elements in
D. We ask whether ¯t ∈ q(D).

PROPOSITION 24. SemAcEval(C) can be solved in time

O(cid:16)|D| · 22O(|q|+|Σ|)(cid:17) ,

where C ∈ {G, NR, S}.

PROOF. Our results state that for C ∈ {G, NR, S}, checking 
if a CQ q is semantically acyclic under C can be done in
double-exponential time. More importantly, in case that q
is in fact semantically acyclic under C our proof techniques
yield an equivalent acyclic CQ q′ of at most exponential size
in |q| + |Σ|. We then compute and evaluate such a query q′
on D, and return q(D) = q′(D). Clearly, this can be done
in time

O(cid:16)22O(|q|+|Σ|)(cid:17) + O(cid:16)|D| · 2O(|q|+|Σ|)(cid:17) .

The running time of this algorithm is dominated by

O(cid:16)|D| · 22O(|q|+|Σ|)(cid:17)

and the claim follows.

This is an improvement over general CQ evaluation for
which no fpt algorithm is believed to exist [26]. It is worth
remarking, nonetheless, that SemAcEval(C) corresponds to
a promise version of the evaluation problem, where the property 
that deﬁnes the class is EXPTIME-hard for all the C’s
studied in Proposition 24.

The above algorithm computes an equivalent acyclic CQ
q′ for a semantically acyclic CQ q under a set of constraints
in C. This might take double-exponential time. Surprisingly,
computing such q′ is not always needed at the moment of
evaluating semantically acyclic CQs under constraints. In
particular, this holds for the sets of guarded tgds. In fact,
in such case evaluating a semantically acylic CQ q under Σ
over a database D that satisﬁes Σ amounts to checking a
polynomial time property over q and D. It follows, in addition,
 that the evaluation problem for semantically acyclic
CQs under guarded tgds is tractable:

THEOREM 25. SemAcEval(G) is in polynomial time.

The idea behind the proof of the above theorem is as follows.
 When q is a semantically acyclic CQ in the absence of
constraints, evaluating q on D amounts to checking the existence 
of a winning strategy for the duplicator in a particular
version of the pebble game, known as the existential 1-cover
game, on q and D [13]. We denote this by q ≡∃1c D. The
existence of such winning strategy can be checked in polynomial 
time [13]. Now, when q is semantically acyclic under
an arbitrary set Σ of tgds or egds, we show that evaluating
q on D amounts to checking whether chase(q, Σ) ≡∃1c D.
When Σ is a set of guarded tgds, we prove in addition that
chase(q, Σ) ≡∃1c D iff q ≡∃1c D. Thus, SemAcEval(G) is
tractable since checking q ≡∃1c D is tractable.

The fact that the evaluation of q on D boils down to checking 
whether chase(q, Σ) ≡∃1c D, when q is semantically
acyclic under Σ, also yields tractability for SemAcEval(C),
where C is any class of sets of egds for which the chase can
be computed in polynomial time. This includes the central
class of FDs. Notice, however, that we do not know whether
SemAc under FDs is decidable.

exists at least one acyclic CQ q′ such that q′ ⊆Σ q; take a
single variable x and add a tuple R(x, . . . , x) for each symbol 
R. It follows then that an acyclic CQ approximation of q
under Σ can always be found among the set A(q) of acyclic
CQs q′ of size at most f (q, Σ) such that q′ ⊆Σ q. In fact,
the acyclic CQ approximations of q under Σ are the maximal
elements of A(q) under ⊆Σ.

8. FURTHER ADVANCEMENTS

In this section we informally discuss the fact that our previous 
results on semantic acyclicity under tgds and CQs
can be extended to UCQs. Moreover, we show that our
techniques establish the existence of maximally contained
acyclic queries.
8.1 Unions of Conjunctive Queries

It is reasonable to consider a more liberal version of semantic 
acyclicity under tgds based on UCQs. In such case
we are given a UCQ Q and a ﬁnite set Σ of tgds, and the
question is whether there is a union Q′ of acyclic CQs that
is equivalent to Q under Σ. It can be shown that all the complexity 
results on semantic acyclicity under tgds presented
above continue to hold even when the input query is a UCQ.
This is done by extending the small query properties established 
for CQs (Propositions 8 and 15) to UCQs.

Consider a ﬁnite set Σ of tgds (that falls in one of the tgdbased 
classes considered above), and a UCQ Q. If Q is semantically 
acyclic under Σ, then one of the following holds:
(i) for each disjunct q of Q, there exists an acyclic CQ q′
of bounded size (the exact size of q′ depends on the class
of Σ) such that q ≡Σ q′, or (ii) q is redundant in Q, i.e.,
there exists a disjunct q′ of Q such that q ⊆Σ q′. Having this
property in place, we can then design a non-deterministic algorithm 
for semantic acyclicity, which provides the desired
upper bounds. Roughly, for each disjunct q of Q, this algorithm 
guesses whether there exists an acyclic CQ q′ of
bounded size such that q ≡Σ q′, or q is redundant in Q. The
desired lower bounds are inherited from semantic acyclicity
in the case of CQs.
8.2 Query Approximations

Let C be any of the decidable classes of ﬁnite sets of tgds
we study in this paper (i.e., G, NR, or S). Then, for any
CQ q without constants6 and set Σ of constraints in C, our
techniques yield a maximally contained acyclic CQ q′ under 
Σ. This means that q′ ⊆Σ q and there is no acyclic CQ
q′′ such that q′′ ⊆Σ q and q′ (Σ q′′. Following the recent
database literature, such q′ corresponds to an acyclic CQ approximation 
of q under Σ [4, 5, 6]. Notice that when q is
semantically acyclic under Σ, this acyclic approximation q′
is in fact equivalent to q under Σ. Computing and evaluating 
an acyclic CQ approximation for q might help ﬁnding
“quick” (i.e., ﬁxed-parameter tractable) answers to it when
exact evaluation is infeasible.

The way in which we obtain approximations is by slightly
reformulating the small query properties established in the
paper (Propositions 8 and 15). Instead of dealing with semantically 
acyclic CQs only, we are now given an arbitrary
CQ q. In all cases the reformulation expresses the follow-
ing: For every acyclic CQ q′ such that q′ ⊆Σ q, there is
an acyclic CQ q′′ of the appropriate size f (q, Σ) such that
q′ ⊆Σ q′′ ⊆Σ q. It is easy to prove that for each CQ q there
6Approximations for CQs with constants are not well-understood,
even in the absence of constraints [4].

9. CONCLUSIONS

We have concentrated on the problem of semantic acyclicity 
for CQs in the presence of database constraints; in fact,
tgds or egds. Surprisingly, we have shown that there are
cases such as the class of full tgds, where containment is decidable,
 while semantic acyclicity is undecidable. We have
then focussed on the main classes of tgds for which CQ containment 
is decidable, and do not subsume full tgds, i.e.,
guarded, non-recusrive and sticky tgds. For these classes we
have shown that semantic acyclicity is decidable, and obtained 
several complexity results. We have also shown that
semantic acyclicity is NP-complete if we focus on keys over
unary and binary predicates. Finally, we have considered
the problem of evaluating a semantically acyclic CQ over a
database that satisﬁes certain constraints, and shown that for
guarded tgds and FDs is tractable. Here are some interesting 
open problems that we are planning to investigate: (i)
The complexity of semantic acyclicity under sticky sets of
tgds is still unknown; (ii) We do not know whether semantic
acyclicity under keys over unconstrained signatures is decidable;
 and (iii) We do not know the complexity of evaluating
semantically acyclic queries under NR, S and egds.
Acknowledgements: Barceló would like to thank D. Figueira, M.
Romero, S. Rudolph, and N. Schweikardt for insightful discussions
about the nature of semantic acyclicity under constraints.

10. REFERENCES
[1] S. Abiteboul, R. Hull, and V. Vianu. Foundations of

Databases. Addison-Wesley, 1995.

[2] J.-F. Baget, M.-L. Mugnier, S. Rudolph, and

M. Thomazo. Walking the complexity lines for
generalized guarded existential rules. In IJCAI, pages
712–717, 2011.

[3] V. Bárány, G. Gottlob, and M. Otto. Querying the
guarded fragment. Logical Methods in Computer
Science, 10(2), 2014.

[4] P. Barceló, L. Libkin, and M. Romero. Efﬁcient
approximations of conjunctive queries. SIAM J.
Comput., 43(3):1085–1130, 2014.

[5] P. Barceló, R. Pichler, and S. Skritek. Efﬁcient

evaluation and approximation of well-designed pattern
trees. In PODS, pages 131–144, 2015.

[6] P. Barceló, M. Romero, and M. Y. Vardi. Semantic

acyclicity on graph databases. In PODS, pages
237–248, 2013.

[7] C. Beeri and M. Y. Vardi. The implication problem for

data dependencies. In ICALP, pages 73–85, 1981.

[8] A. Calì, G. Gottlob, and M. Kifer. Taming the inﬁnite

chase: Query answering under expressive relational
constraints. J. Artif. Intell. Res., 48:115–174, 2013.
[9] A. Calì, G. Gottlob, and T. Lukasiewicz. A general

Datalog-based framework for tractable query
answering over ontologies. J. Web Sem., 14:57–83,
2012.

[10] A. Calì, G. Gottlob, and A. Pieris. Towards more

expressive ontology languages: The query answering
problem. Artif. Intell., 193:87–128, 2012.

[11] D. Calvanese, G. De Giacomo, and M. Lenzerini.

Conjunctive query containment and answering under
description logic constraints. ACM Trans. Comput.
Log., 9(3), 2008.

[12] A. K. Chandra and P. M. Merlin. Optimal

implementation of conjunctive queries in relational
data bases. In STOC, pages 77–90, 1977.

[13] H. Chen and V. Dalmau. Beyond hypertree width:

Decomposition methods without decompositions. In
CP, pages 167–181, 2005.

[14] V. Dalmau, P. G. Kolaitis, and M. Y. Vardi. Constraint

satisfaction, bounded treewidth, and ﬁnite-variable
logics. In CP, pages 310–326, 2002.

[15] R. Fagin. A normal form for relational databases that
is based on domians and keys. ACM Trans. Database
Syst., 6(3):387–415, 1981.

[16] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data

exchange: Semantics and query answering. Theor.
Comput. Sci., 336(1):89–124, 2005.

[17] D. Figueira. Semantically acyclic conjunctive queries

under functional dependencies. In LICS, 2016. To
appear.

[18] T. Gogacz and J. Marcinkowski. Converging to the

chase - A tool for ﬁnite controllability. In LICS, pages
540–549, 2013.

[19] G. Gottlob, G. Greco, and B. Marnette.

Hyperconsistency width for constraint satisfaction:
Algorithms and complexity results. In Graph Theory,
Computational Intelligence and Thought, pages
87–99, 2009.

[20] G. Gottlob, G. Orsi, and A. Pieris. Query rewriting

and optimization for ontological databases. ACM
Trans. Database Syst., 2014.

[21] P. Hell and J. Nešetˇril. Graphs and Homomorphisms.

Oxford University Press, 2004.

[22] D. S. Johnson and A. C. Klug. Testing containment of

conjunctive queries under functional and inclusion
dependencies. J. Comput. Syst. Sci., 28(1):167–189,
1984.

[23] M. Krötzsch and S. Rudolph. Extending decidable

existential rules by joining acyclicity and guardedness.
In IJCAI, pages 963–968, 2011.

[24] T. Lukasiewicz, M. V. Martinez, A. Pieris, and G. I.
Simari. From classical to consistent query answering
under existential rules. In AAAI, pages 1546–1552,
2015.

[25] D. Maier, A. O. Mendelzon, and Y. Sagiv. Testing

implications of data dependencies. ACM Trans.
Database Syst., 4(4):455–469, 1979.

[26] C. H. Papadimitriou and M. Yannakakis. On the

complexity of database queries. J. Comput. Syst. Sci.,
58(3):407–427, 1999.

[27] M. Yannakakis. Algorithms for acyclic database

schemes. In VLDB, pages 82–94, 1981.

Appendix
Proof of Proposition 5
It is not difﬁcult to show the following result, which reveals the usefulness of connectedness:

LEMMA 26. Let Σ be a ﬁnite set of body-connected tgds, q a Boolean CQ, and q′ a Boolean and connected CQ. If q ⊆Σ q′,

then there exists a maximally connected subquery q′′ of q such that q′′ ⊆Σ q′.

Having the above result in place, we can now establish Proposition 5. For brevity, let q′′ be the CQ q ∧ q′.
(⇒) It is clear that q ⊆Σ q′′. Moreover, q′′ ⊆Σ q holds trivially. Therefore, q′′ ≡Σ q, and the claim follows since, by

hypothesis, q is acyclic.

(⇐) Since Σ belongs to a class that ensures the ﬁnite controllability of containment, it sufﬁces to show the following: If
there exists an acyclic Boolean CQ qA such that q′′ ≡Σ qA, then q ⊆Σ q′. Let q1
A, where k > 1, be the maximally
connected subqueries of qA. Clearly, q and q′ are the two maximally connected subqueries of q′′. Therefore, by Lemma 26, for
each i ∈ {1, . . . , k}, q ⊆Σ qi

A. We deﬁne the following two sets of indices:

A or q′ ⊆Σ qi

A, . . . , qk

Sq = {i ∈ {1, . . . , k} | q ⊆Σ qi

A}

and

Sq′ = {i ∈ {1, . . . , k} | q′ ⊆Σ qi

A and q 6⊆Σ qi

A};

Case 1. Assume ﬁrst that Sq = ∅. This implies that, for each i ∈ {1, . . . , k}, q′ ⊆Σ qi

clearly, Sq and Sq′ form a partition of {1, . . . , k}. We proceed to show that q ⊆Σ q′ by considering the following three cases:
A; thus, q′ ⊆Σ qA. By hypothesis,
qA ⊆Σ q′′, which immediately implies that qA ⊆Σ q′. Therefore, q′ ≡Σ qA, which contradicts our hypothesis that q′ is not
semantically acyclic under Σ. Hence, the case where Sq = ∅ is not possible, and is excluded from our analysis.

Case 2. Assume now that Sq′ = ∅. This implies that, for each i ∈ {1, . . . , k}, q ⊆Σ qi

qA ⊆Σ q′′, which immediately implies that qA ⊆Σ q′. Therefore, q ⊆Σ q′, as needed.

A; thus, q ⊆Σ qA. By hypothesis,

A, and thus q′ ≡Σ qj

A 6⊆Σ q′; notice that qi

Case 3. Finally, assume that Sq 6= ∅ and Sq′ 6= ∅. Fix an arbitrary index i ∈ Sq′. Since q′ ⊆Σ qi

A and q′ is not semantically
A is necessarily acyclic. Since qA ⊆Σ q′, Σ is body-connected and
A ⊆Σ q′. Observe that j 6∈ Sq′; otherwise,
A, which contradicts the fact that q′ is not semantically acyclic under Σ. Since j ∈ Sq, q ⊆Σ qj
A,

acyclic under Σ, we conclude that qi
q′ is connected, Lemma 26 implies that there exists j ∈ {1, . . . , k} \ {i} such that qj
q′ ⊆Σ qj
and therefore q ⊆Σ q′, as needed. This completes our proof.
Proof of Theorem 7
We reduce from the Post correspondence problem (PCP) over alphabet Σ = {a, b}. Recall that the input to this problem are
n of words over Σ, and we ask whether there is a solution, i.e., a nonempty
two equally long lists w1, . . . , wn and w′
. We assume without loss of generality that all
sequence i1 . . . im of indices in {1, . . . , n}, such that wi1 . . . wim = w′
i1
these words are of even length. Otherwise we simply replace in each word each appearance of a (resp., b) with aa (resp., bb).
n be an instance of PCP as described above. We construct a Boolean CQ q and a set of full

1, . . . , w′

1, . . . , w′

. . . w′

im

Let w1, . . . , wn and w′
tgds Σ over the schema:

{Pa, Pb, P#, P∗, sync, start, end},

where Pa, Pb, P#, P∗, and sync are binary relation symbols, and the other ones are unary relation symbols, such that the PCP
instance given by w1, . . . , wn and w′

n has a solution if and only if there exists an acylic CQ q′ such that q ≡Σ q′.

We start with a temporary version of q. This query will have to be modiﬁed later in order to make the proof work, but it is
convenient to work with this version for the time being in order to simplify the presentation. The restriction of our Boolean
CQ q to those relation symbols that are not sync is graphically deﬁned as follows:

1, . . . , w′

y

Pa

P#

x

start

P#

Pa

Pb

P#

z

P∗

P∗

u

P∗

v

end

Pb

Pb

Pa

Here, x, y, z, u, v denote the names of the respective variables. The interpretation of sync in q consists of all pairs in {y, u, z}.

Our set Σ of full tgds consists of the following:
1. An initialization rule:

start(x), P#(x, y) → sync(y, y).

2. A synchronization rule:

sync(x, y), Pwi (x, z), Pw′

i

(y, u) → sync(z, u),

for each 1 ≤ i ≤ n. Here, Pw(x, y),
Pa1 (x, x1), . . . , Pat (xt−1, y), where the xi’s are fresh variables.

for a nonepty word w = a1 . . . at ∈ Σ∗,

is a shortening for

3. For each 1 ≤ i ≤ n, a pair of ﬁnalization rules deﬁned as follows. First:

start(x), Pa(y, z), Pa(z, u), sync(y′, y′′), Pwi (y′, y), Pw′

i

(y′′, y), P∗(u, v), end(v) →

P#(x, y), P#(x, z), P#(x, u), P∗(y, v), P∗(z, v), Pb(z, y), Pb(u, z), Pa(u, y), Pb(y, u).

Second:

start(x), Pa(y, z), Pa(z, u), sync(y′, y′′), Pwi (y′, y), Pw′

i

(y′′, y), P∗(u, v), end(v) →

sync(y, y), sync(z, z), sync(y, z), sync(z, y), sync(y, u), sync(u, y), sync(z, u), sync(u, z).

Notice that these two tgds can be expressed into one since they have the same body. We split in two for the sake of
presentation.

We ﬁrst show that if the PCP instance has a solution given by the nonempty sequence i1 . . . im, with 1 ≤ i1, . . . , im ≤ n,
then there exists an acylic CQ q′ such that q ≡Σ q′. Let us assume that wi1 . . . wim = a1 . . . at, where each ai is a symbol in
Σ. We prove next that q ≡Σ q′, where q′ is the Boolean acyclic CQ depicted below:

x′

P#

start

Pa1

. . .

Pat

y′

Pa

z′

Pa

u′

P∗

v′

end

Here, again, x′, y′, z′, u′, v′ denote the names of the respective variables of q′. It is clear that all these elements are different.

In virtue of Lemma 1, we only need to show that chase(q, Σ) ≡ chase(q′, Σ). It is well-known that the latter is equivalent to
showing that chase(q, Σ) and chase(q′, Σ) are homomorphically equivalent [12]. Let us start by analyzing what chase(q, Σ)
and chase(q′, Σ) are:

1. Notice that chase(q′, Σ) extends q′ with the atom sync(x′′, x′′), where x′′ is the second element of q′ (i.e., the successor
of x′), plus all atoms of the form sync(y∗, z∗) produced by the recursive applications of the second rule starting from
im = a1 . . . at, it must be the case that the atom sync(y′, y′) is
sync(x′′, x′′). Further, since wi1 . . . wim = w′
i1
generated in this process. Thus, there are elements y1 and y2 such that sync(y1, y2), Pwim (y1, y′) and Pw′
(y2, y′) hold.
From the third rule we conclude that that chase(q′, Σ) contains the atoms in the following sets. First:

. . . w′

im

S1 = {P#(x′, y′), P#(x′, z′), P#(x′, u′), P∗(y′, v′), P∗(z′, v′), Pb(z′, y′), Pb(u′, z′), Pa(u′, y′), Pb(y′, u′)}.

Second:

S2 = {sync(y′, y′), sync(z′, z′), sync(y′, z′), sync(z′, y′), sync(y′, u′), sync(u′, y′), sync(z′, u′), sync(u′, z′)}.

2. It can be checked that q is closed under Σ, i.e., q = chase(q, Σ).
We show ﬁrst that chase(q′, Σ) can be homomorphically mapped to q = chase(q, Σ). But this is easy; we simply map the
variable x′ to x, the variable v′ to v, and every consecutive node in between x′ and v′ in q′ to the corresponding element in
between x and v in q.

Let us show now that q = chase(q, Σ) can be homomorphically mapped to chase(q′, Σ). We use the mapping that sends
x, y, z, u, v to x′, y′, z′, u′, v′, respectively. It is not hard to check that this mapping is a homomorphism using the fact that
S1, S2 ⊆ chase(q′, Σ).

Now we prove that if there exists an acyclic CQ q′ such that q ≡Σ q′, then there are indices 1 ≤ i1, . . . , im ≤ n such that
. We start with a simpler case. We assume that the restriction of q′ to Pa, Pb, P#, P# and sync

. . . w′

wi1 . . . wim = w′
i1
looks like this:

im

. . .

That is, the underlying graph of this query corresponds to a directed path.

Since q ≡Σ q′, we can conclude from Lemma 1 that chase(q, Σ) ≡ chase(q′, Σ), i.e., chase(q, Σ) and chase(q′, Σ) are
homomorphically equivalent. But then chase(q′, Σ) must contain at least one variable labeled start and one variable labeled
end. The ﬁrst variable cannot have incoming edges (otherwise, chase(q′, Σ) would not homomorphically map to chase(q, Σ)),
while the second one cannot have outcoming edges (for the same reason). This implies that it is the ﬁrst variable x′ of q′ that
is labeled start and it is the last one v′ that is labeled end. Furthermore, all edges reaching v′ in q′ must be labeled P∗
(otherwise q′ does not homomorphically map to q). Thus, this is the label of the last edge of q′ that goes from variable u′ to v′.
Analogously, the edge that leaves x′ in q′ is labeled P#. Furthermore, any other edge in q′ must be labeled Pa, Pb, or sync.

Notice now that v′ must have an incoming edge labeled P∗ in chase(q′, Σ) from some node u′′ that has an outgoing edge
with label Pa (since q homomorphically maps to chase(q′, Σ)). By the deﬁnition of Σ, this could only have happened if there
are elements y1 and y2 such that the following atoms hold in chase(q′, Σ), for some 1 ≤ i ≤ n:
(y2, y′)},

{Pa(y′, z′), Pa(z′, u′), sync(y1, y2), Pwi (y1, y′), Pw′

i

where y′, z′, u′ are the immediate predecessors of v′ in the order that is naturally induced by q′. In particular, the unique path
from y1 (resp., y2) to y′ in q′ is labeled wi (resp., w′
i). This means that the atom sync(y1, y2) was not one of the edges of q′, but
must have been produced during the chase by another atom of this form, and so on. This process can only ﬁnish in the second
element x∗ of q′ (notice that sync(x∗, x∗) belongs to chase(q′, Σ) due to the ﬁrst rule of Σ). We conclude then that our PCP
instance has a solution.

What now, if q′ contains parallel edges going from one node to another (but in the same direction than before)? Notice that
q contains no parallel edges save for those in between the elements in {y, z, u}. These parallel edges are labeled with both Pa
(or Pb) and sync. Thus, parallel edges in q′ can only be of this form (since q′ homomorphically maps to q). This implies that
q′ can now contain edges labeled sync (this was not the case before). On the other hand, there can be at most one edge labeled
in {Pa, Pb} from one node to another in q′. This is crucial for our reduction to hold.
We use the same idea than before. We know that sync(y1, y2), Pwi (y1, y′), and Pw′

(y2, y′) hold in chase(q′, Σ). Thus, if we
now restrict q′ to relation symbols Pa and Pb, there is a unique path from y∗ (resp., z∗) to u′ in q′, and such path is labeled wi
i). Now, the question is whether sync(y1, y2) could have been part of q′ or was produced by the chase. If the former
(resp., w′
was the case, we would have that y1 and y2 are at distance one, and, therefore, that |wi| = |w′
i| + 1 (or viceversa). But this is
not possible since we are assumming both wi and w′
i to be of even length. Thus, sync(y1, y2) needs to have been produced by
the chase. Iterating this process takes us again all the way back to the atom sync(x∗, x∗). We thus conclude again that the PCP
instance given by w1, . . . , wn and w′

Let us suppose now that q′ contains parallel edges and some of these edges also go in the opposite direction than the ones
we have now. This is problematic for our reduction since now words in this path can be read in both directions. This is why
we mentioned in the beginning of the proof that our version of q was only temporary, and that we would have to change it later
in order to make the proof work. The restriction of q to those relation symbols that are neither Pa, Pb, nor sync will now look
like this:

n has a solution.

1, . . . , w′

i

y

u1

P#

P#

x

P#

start

P#

P#

P∗

P∗

P∗

u

P∗

P∗

end
v

success

z

u2

The cycle z, y, u1, u, u2, z is completely labeled in Pa, and the cycle z, u1, u2, y, u, z is completely labeled in Pb. As before,
the interpretation of sync corresponds to all pairs in {z, y, u1, u, u2}. The main difference with our previous version of q is
that now there are no nodes linked by both edges Pa and Pb in opposite directions. This implies that q′ can only have parallel
edges labeled Pa (or Pb) and sync (in any possible direction). This is crucial for our reduction to work.

Since q is now more complicated, we will have to modify Σ in order to ensure that q maps into chase(q′, Σ). In particular,
the third rule of Σ must now ensure that the structure of q is completely replicated among the ﬁrst element of q′ (where the ﬁrst
element x of q will be mapped), the last element of q′ (where the last element v of q will be mapped), and the four elements
that immediately precede the last element of q′ (where the inner cycle of q will be mapped). The proof then mimicks the one
we presented before.

Let us assume now that q′ also admits loops. Since q′ homomorphically maps to q, these loops can only be labeled sync. Is
this dangerous for our backchase analysis? Not really. If one of these loops is used as a starting point for a chase sequence,
it can only mean that the synchronization of the words in the PCP instance occurs earlier than expected. In particular, there is
still a solution for the instance.

The cases when the query q has branching or disconnected components is not more difﬁcult, since in any case we can carry

out the previous analysis over one of the branches of q. This ﬁnishes the proof.
Proof of Lemma 9
We ﬁrst establish an auxiliary technical lemma:

LEMMA 27. Let q(¯x) be a CQ, I an acyclic instance, and ¯c a tuple of constants. If there exists a homomorphism h such

that h(q(¯c)) ⊆ I, then there exists an acyclic instance J ⊆ I, where h(q(¯c)) ⊆ J and |J| 6 2 · |q|.

PROOF. Assume that q is of the form ∃¯yφ(¯x, ¯y). Since I is acyclic, there exists a join tree T = ((V, E), λ) of I. We assume,
w.l.o.g., that for distinct nodes v, u ∈ V , λ(v) 6= λ(u). Let Tq = ((Vq, Eq), λ) be the ﬁnite subforest of T consisting of the
nodes {v ∈ V | λ(v) ∈ h(φ(¯c, ¯y))} and their ancestors. Let F = ((V ′, E′), λ′) be the forest obtained from Tq as follows:

• V ′ = {v ∈ Vq | v is either a root node or a leaf node} ∪ A, where A are the inner nodes of Tq with at least two children;
• For every pair of nodes (v, u) ∈ V ′ × V ′, (v, u) ∈ E′ iff u is a descendant of v in Tq, and the unique shortest path from v

to u in Tq contains only nodes of ((V \ V ′) ∪ {v, u}); and

• Finally, λ′ = {x 7→ y | x 7→ y ∈ λ and x ∈ V ′}, i.e., λ′ is the restriction of λ on V ′.
We deﬁne J as the instance {λ′(v) | v ∈ V ′} ⊆ I. It is clear that h(ϕ(¯c, ¯y)) ⊆ J. Moreover, by construction, |V ′| 6 2 · |q|,
which in turn implies that |J| 6 2 · |q|. It remains to show that J is acyclic, or, equivalently, that F is a join tree of J. Since, by

construction, {λ′(v) | v ∈ V ′} = J, it remains to show that, for each term t in J, the set {v ∈ V ′ | t occurs in λ′(v)} induces
a connected subtree in F . Consider two distinct nodes v, u ∈ V ′ such that, for some t in J, t occurs in λ′(v) and λ′(u). By
construction of F , there exists a path v, w1, . . . , wn, u in F such that the nodes w1, . . . , wn occur in the unique path from v to
u in T . Since T is a join tree, t occurs in λ′(wi), for each i ∈ {1, . . . , n}. Hence, F is a join tree of J, as needed.

Having the above lemma in place, we can now establish Lemma 9. Assume that q is of the form ∃¯yφ(¯x, ¯y). By hypothesis,
there exists a homomorphism h such that h(φ(¯c, ¯y)) ⊆ I. By Lemma 27, there exists an acyclic instance J ⊆ I, where
h(φ(¯c, ¯y)) ⊆ J and |J| 6 2 · |q|. For notational convenience, let ¯c = (c1, . . . , ck). We deﬁne q′ as the CQ ∃ ¯wψ(¯z, ¯w),

where |¯z| = |¯x|, ¯z = (Vc1 , . . . , Vck ) ∈ Vk, and ψ(¯z, ¯w) is the conjunction of atoms Vp(¯u)∈J ρ(p(¯u)), with ρ be a renaming

substitution that replaces each term t occurring in J with the variable Vt. Intuitively, q′ is obtained by converting J into a CQ.
Since, by hypothesis, J is acyclic, also q′ is acyclic. Clearly, ρ(h(φ(¯x, ¯y))) ⊆ ψ(¯z, ¯w) and ρ(h(¯z)) = ¯z, which implies that
q′ ⊆ q. Moreover, since |J| 6 2 · |q|, |q′| 6 2 · |q|. Finally, observe that ρ−1(ψ(¯z, ¯w)) = J ⊆ I and ρ−1(¯z) = ¯c, and therefore
q′(¯c) holds in I, and the claim follows.
Proof of Proposition 12
Consider an acyclic CQ q, and a set Σ ∈ G. We need to show that chase(q, Σ), that is, the result of an arbitrary chase sequence

q = I0

τ0,¯c0−−−→ I1

τ1,¯c1−−−→ I2 . . . ,

for q under Σ, admits a join tree. This can be done via the guarded chase forest for q and Σ, which is deﬁned as the labeled
forest F = (V, E, λ), where

1. |V | = |chase(q, Σ)|;
2. For each R(¯t) ∈ chase(q, Σ), there exists a node v such that λ(v) = R(¯t); and
3. The edge (v, u) belongs to E iff there exists i > 0 such that λ(v) ∈ Ii, the guard of τi is satisﬁed by λ(v), and

λ(u) ∈ Ii+1 \ Ii.

We proceed to show that each connected component of F , which is a tree with its root labeled by an atom α of q, is a join
tree; we refer to this join tree by Tα. Fix an arbitrary atom α of q. We need to show that for each term t occurring in Tα, the
set {v ∈ V | t occurs in λ(v)} induces a connected subtree in the guarded chase forest for q and Σ. Towards a contradiction,
assume that the latter does not hold. This implies that there exists a path vw1 . . . wnu in the guarded chase forest for q and Σ,
where n > 1, and a term t that occurs in λ(v) and λ(u), and t does not occur in λ(wi), for each i ∈ {1, . . . , n}. Assume that
λ(u) was generated during the i-th application of the chase step, i.e., λ(u) ∈ Ii+1 \ Ii. Since t does not occur in λ(wn), we
conclude that σi is not guarded. But this contradicts our hypothesis that Σ ∈ G, and thus Tα is a join tree.

Since q is acyclic it admits a join tree Tq. Let T be the tree obtained by attaching Tα to the node of Tq labeled by α. Clearly,

T is a join tree for chase(q, Σ), and the claim follows.
Guarded Tgds are not UCQ Rewritable
Consider the guarded tgd

and the two Boolean CQs

τ = P (x, y), S(x) → S(y)

q = S(a) ∧ φP

q′ = S(b),

where a, b are constants, and φP is a conjunction of atoms of the form P (x, y), where x, y are constants. Assume there is a
UCQ Q such that q ⊆{τ } q′ iff Q(Dq) 6= ∅, where Dq consists of all the atoms in q. This means that Q is able to check for
the existence of an unbounded sequence of atoms P (a, c1), P (c1, c2), . . . , P (cn−1, b) in Dq. However, this is not possible via
a ﬁnite (non-recursive) UCQ, which implies that G is not UCQ rewritable.
Proof of Proposition 22
Consider an acyclic CQ q over unary and binary predicates. It sufﬁces to show that, after applying a key dependency ǫ of the
form R(x, y), R(x, z) → y = z on q, the obtained query qǫ is still acyclic. Let Tq be the join tree of q. Assume that ǫ is
triggered due to the homomorphism h, i.e., h maps the body of ǫ to q and h(y) 6= h(z). Without loss of generality, assume
that the atom h(R(x, y) is an ancestor of h(R(x, z)) in Tq. Let α be the ﬁrst atom on the (directed) path from h(R(x, y)) to
h(R(x, z)) in Tq that contains both h(x) and h(z). Since we have only unary and binary predicates, we can safely conclude
that all the atoms in Tq that contain the term h(z) belong to the subtree Tα of Tq that is rooted on α. Therefore, if we delete
the subtree Tα from Tq and attach it on the atom h(R(x, y), and then replace every occurrence of h(z) with h(y), we obtain a
tree which is actually a join tree for qǫ. This implies that qǫ is acyclic, and the claim follows.
Proof of Theorem 25
We start by recalling the existential 1-cover game from [13]. This game is played by the spoiler and the duplicator on two pairs
(I, ¯t) and (I ′, ¯t′), where I and I ′ are instances and ¯t and ¯t′ are two equally long tuples of elements in I and I ′, respectively.
The game proceeds in rounds. At each round either:

1. The spoiler places a pebble on an element a of I, and the duplicator responds by placing its corresponding pebble on an

element f (a) of I ′, or

2. the spoiler removes one pebble from I, and the duplicator responds by removing the corresponding pebble from I ′.

The spoiler is constrained in the following way: (1) At any round k of the game, if a1, . . . , al (l ≤ k) are the elements covered
by the pebbles of the spoiler in I, then there must be an atom of D that contains all such elements (this explains why the
game is called 1-cover, as there is always a single atom that covers all elements which are pebbled), and (2) if the spoiler
places a pebble on the i-th component ti of ¯t, then the duplicator must respond by placing the corresponding pebble on the i-th
i of ¯t′. The duplicator wins the game if he can always ensure that f is a partial homomorphism from (a1, . . . , al)
component t′
in I to I ′.7 In such case we write (I, ¯t) ≡∃1c (I ′, ¯t′).

The following useful characterization of (I, ¯t) ≡∃1c (I ′, ¯t′) can be obtained from results in [13]:
LEMMA 28. It is the case that (I, ¯t) ≡∃1c (I ′, ¯t′) if and only if there is a mapping H that associates with each atom T (¯a)

in I a nonempty set H(T (¯a)) of atoms of the form T (f (¯a)) in I ′ and satisﬁes the following:

1. If the i-th component ai of ¯a corresponds to the j-th component tj of ¯t, then for each tuple T (f (¯a)) ∈ H(T (¯a)) it is the

case that the i-th component of f (¯a) corresponds to the j-th component t′

j of ¯t′.

2. Consider an arbitrary atom T (f (¯a)) ∈ H(T (¯a)). Then for each atom S(¯b) in I there exists an atom S(f ′(¯b)) ∈ H(S(¯b))

such that f (c) = f ′(c) for each element c that appears both in ¯a and ¯b.

It follows, in particular, that for each tuple T (f (¯a)) ∈ H(T (¯a)) the mapping f is a partial homomorphism from ¯a in I to I ′.

When such an H exists we call it a winning strategy for the duplicator in the game on (I, ¯t) and (I ′, ¯t′). The existence of a

winning strategy for the duplicator can be decided in polynomial time over ﬁnite instances:

PROPOSITION 29. There exists a polinomial time algorithm that decides whether (I, ¯t) ≡∃1c (I ′, ¯t′), given ﬁnite instances

I and I ′ and tuples ¯t and ¯t′ of elements in I and I ′, respectively.

The following important fact can also be established from results in [13]:

PROPOSITION 30. If (I, ¯t) ≡∃1c (I ′, ¯t′), then for every acyclic CQ q it is the case that ¯t′ ∈ q(I ′) whenever ¯t ∈ q(I).
This implies, in particular, that for every instance I, tuple ¯t of elements in I, and CQ q(¯x) that is semantically acyclic (in the
absence of constraints), it is the case that ¯t ∈ q(I) if and only if (q, ¯x) ≡∃1c (I, ¯t)8. Applying Proposition 29 we obtain that
the evaluation of semantically acyclic CQs (in the absence of constraints) is a tractable problem.
Now, assume that q(¯x) is semantically acyclic under a set Σ of tgds. Then the following holds:

PROPOSITION 31. For every instance I that satisﬁes Σ and tuple ¯t of elements in I, we have that ¯t ∈ q(I) if and only if

(chase(q, Σ), ¯x) ≡∃1c (I, ¯t).

PROOF. Assume ﬁrst that ¯t ∈ q(I). Then there is a homomorphism h from q to I such that h(¯x) = ¯t. But since I |= Σ,
it is easy to see that h extends to a homomorphism h′ from chase(q, Σ) to I such that h′(¯x) = ¯t. This implies, in particular,
that (chase(q, Σ), ¯x) ≡∃1c (I, ¯t) since the duplicator can simply respond by following the homomorphism h′. Assume, on
the other hand, that (chase(q, Σ), ¯x) ≡∃1c (I, ¯t). Then Proposition 30 implies that for every acyclic CQ q′ we have that
¯t ∈ q′(I) whenever ¯x ∈ q′(chase(q, Σ)). We know that q is equivalent to some acyclic CQ q∗ under Σ, which implies that
¯x ∈ q∗(chase(q, Σ)) from Lemma 1. We conclude then that ¯t ∈ q∗(I), and, thus, that ¯t ∈ q(I) (since q ≡Σ q∗ and I |= Σ).

Thus, in order to prove that SemAcEval(G) can be solved in polynomial time, we only need to prove that the problem of
checking whether (chase(q, Σ), ¯x) ≡∃1c (D, ¯t) can be solved in polynomial time, given a CQ q, a database (ﬁnite instance)
D that satisﬁes a set Σ of guarded tgds, and a tuple ¯t of elements in D. This is done by proving that if Σ is guarded, then
(chase(q, Σ), ¯x) ≡∃1c (D, ¯t) if and only if (q, ¯x) ≡∃1c (D, ¯t). Since we know from Proposition 29 that deciding the existence
of a winning strategy for the duplicator in the existential 1-cover game is in polynomial time, we conclude that the problem of
checking (chase(q, Σ), ¯x) ≡∃1c (D, ¯t) can be solved efﬁciently. Thus, it only remains to prove the following:

LEMMA 32. Let Σ be a ﬁnite set of guarded tgds and q(¯x) a CQ. Then for every database D that satisﬁes Σ and tuple ¯t of

elements in D, it is the case that (chase(q, Σ), ¯x) ≡∃1c (D, ¯t) if and only if (q, ¯x) ≡∃1c (D, ¯t).

PROOF. The implication from left to right is immediate since q is contained in chase(q, Σ). Assume now that (q, ¯x) ≡∃1c
(D, ¯t). In virtue of Lemma 28, there is a winning strategy H for the duplicator in the game on (q, ¯x) and (D, ¯t). We need to
prove then that there is a winning strategy H′ for the duplicator in the game on (chase(q, Σ), ¯x) and (D, ¯t). That is, that there
is a mapping H′ that associates with each atom T (¯a) in chase(q, Σ) a nonempty set H′(T (¯a)) of tuples of the form T (f (¯a))
in D and satisﬁes the following:

1. If the i-th component ai of ¯a corresponds to the j-th component xj of ¯x, then for each tuple T (f (¯a)) ∈ H′(T (¯a)) it is the

case that the i-th component of f (¯a) corresponds to the j-th component tj of ¯t.

7That is, f is a homomorphism from I(a1, . . . , al) to I ′, where I(a1, . . . , al) is the restriction of I to those atoms T (¯a) such that ¯a only
mentions elements in {a1, . . . , al}.
8Here we slightly abuse notation and write q for the database that contains all the atoms of q.

2. Consider an arbitrary atom T (f (¯a)) ∈ H′(T (¯a)). Then for each atom S(¯b) in chase(q, Σ) there exists an atom S(f ′(¯b)) ∈

H′(S(¯b)) such that f (c) = f ′(c) for each element c that appears both in ¯a and ¯b.

Let us assume that chase(q, Σ) is obtained by the following sequence of chase steps:

τ1,¯c1−−−→ I2 . . .

j is a winning
j−1(T (¯a)) for each tuple

τ0,¯c0−−−→ I1
I0
We prove by induction that there are mappings (H′
j)j≥0 such that the following holds for each j ≥ 0: (a) H′
strategy for the duplicator in the game on (Ij , ¯x) and (D, ¯t), and (b) if j > 0 then H′

j(T (¯a)) = H′
j.
T (¯a) ∈ Ij−1. This ﬁnishes the proof of Lemma 32, as it is clear then that H′ can be deﬁned as Sj≥0 H′

0 to be H. Let us consider then the inductive case
For the basis case j = 0 we have I0 = q. Thus, we can deﬁne H′
j for the duplicator in the game on (Ij , ¯x) and (D, ¯t).
j + 1, for j ≥ 0. By inductive hypothesis, there is a winning strategy H′
Further, we have by deﬁnition that Ij+1 is the result of applying tgd τj over Ij with ¯cj. Let us assume that τj is of the form
φ(¯x) → ∃¯zψ(¯y, ¯z), where ¯y is a tuple of variables taken from ¯x. This implies that Ij+1 extends Ij with every tuple in ψ( ¯dj, ¯z′),
where ¯dj is the restriction of ¯cj to ¯y and ¯z′ is a tuple that is obtained by replacing each variable in ¯z with a fresh null. We set
H′

j+1(T (¯a)) := H′
Let T (¯a) be an atom in Ij+1 \ Ij. This implies, in particular, that T (¯a) belongs to ψ( ¯dj , ¯z′). Suppose that the guard of τj is
j(R(¯cj)) is well-deﬁned and nonempty. Take an
R(¯x). Since Ij |= φ(¯cj ) we have that R(¯cj) belongs to Ij, and therefore that H′
j is a winning strategy for the duplicator in the game on (Ij, ¯x) and (D, ¯t),
arbitrary element R(f (¯cj)) ∈ H′
we have from Lemma 28 that f is a partial homomorphism from ¯cj in Ij to D. This implies, in particular, that D |= φ(f (¯cj))
since τj is guarded. But D |= Σ, and therefore there is a tuple g(¯z′) of elements in D such that D |= ψ(f ( ¯dj ), g(¯z′)). Let us
deﬁne then a mapping hf from ¯a to D such that for each a in ¯a the value of hf (a) is deﬁned as follows:

j(T (¯a)) for each atom T (¯a) in Ij. We explain next how to deﬁne H′

j+1 over Ij+1 \ Ij.

j(R(¯cj)). Since H′

hf (a) = (cid:26)f (a),

g(a),

if a appears in ¯dj,
if a appears in ¯z′.

Notice, in particular, that T (hf (¯a)) belongs to D. We deﬁne then H′
T (hf (¯a)), for h a mapping such that R(f (¯cj)) belongs to H′

j+1(T (¯a)) as the set of all tuples in D of the form

j(R(¯cj)). Clearly, H′

j+1(T (¯a)) is nonempty.

j+1(T (¯a)) = H′

We prove next that H′

j+1 satisﬁes the desired conditions: (a) H′

j+1 is a winning strategy for the duplicator in the game on
(Ij+1, ¯x) and (D, ¯t), and (b) H′
j(T (¯a)) for each tuple T (¯a) ∈ Ij. Condition (b) is satisﬁed by deﬁnition. We
concentrate on condition (a) now. Let us start with the ﬁrst condition in the deﬁnition of winning strategy. Take an arbitrary
atom T (¯a) in Ij+1 and assume that the i-th component of ¯a corresponds to the j-th component xj of ¯x. If T (¯a) also belongs to
Ij, then we have by inductive hypothesis that for each atom T (f (¯a)) ∈ H′
j+1(T (¯a)) the i-th component of f (¯a) corresponds
to the j-th component tj of ¯t (since H′
j is a winning strategy for the duplicator in the game on
(Ij , ¯x) and (D, ¯t)). Let us assume, on the other hand, that T (¯a) belongs to Ij+1 \ Ij. In particular, T (¯a) belongs to ψ( ¯dj, ¯z′).
By deﬁnition of the chase, the fact that the i-th component a of ¯a corresponds to the j-th component xj of ¯x implies that a
belongs to ¯dj (as the elements in ¯z′ are fresh nulls). Let us consider an arbitrary atom in H′
j+1(T (¯a)). By deﬁnition, this
j(R(¯cj)). Since a appears in ¯dj we have that
atom is of the form T (hf (¯a)) for a mapping f such that R(f (¯cj)) belongs to H′
hf (a) = f (a). Further, by inductive hypothesis f (a) = hf (a) corresponds to tj.

j+1(T (¯a)) = H′

j(T (¯a)) and H′

We now prove that the second condition in the deﬁnition of winning strategy also holds for H′

j+1. Let T (¯a) and S(¯b) be
j+1(S(¯b)) such
arbitrary atoms in Ij+1. We prove that for each atom T (h(¯a)) ∈ H′
that h and h′ coincide in all elements that are common to ¯a and ¯b. We assume without loss of generality that ¯a and ¯b have at
least one element in common, otherwise the property holds vacuously. We consider two cases:

j+1(T (¯a)) there is an atom S(h′(¯b)) ∈ H′

• T (¯a) and S(¯b) belong to Ij+1 \ Ij. This means that both T (¯a) and S(¯b) are atoms in ψ( ¯dj , ¯z′) that do not belong to
j+1(T (¯a)). By deﬁnition, such atom is of the form T (hf (¯a)) for a mapping f such that
j+1(T (¯a)) must contain an atom of the form S(hf (¯b)).

j(R(¯cj)). But in the same way, then, H′

Ij. Take an arbitrary atom in H′
R(f (¯cj)) belongs to H′
This proves that the property holds in this case.

j(T (¯a)), H′

j+1(T (¯a)) = H′

j+1(S(¯b)) = H′

• Either T (¯a) or S(¯b) belongs to Ij. Suppose ﬁrst that both T (¯a) and S(¯b) belong to Ij. Then the property holds by
j is a winning strategy for the

inductive hypothesis (since H′
duplicator in the game on (Ij, ¯x) and (D, ¯t)).
Let us assume without loss of generality then that T (¯a) ∈ Ij+1 \ Ij and S(¯b) ∈ Ij. This means, in particular, that T (¯a)
belongs to ψ( ¯dj, ¯z′) but not to Ij. Furthermore, each element that is shared by ¯a and ¯b belongs to ¯dj (as ¯z′ is a tuple of fresh
nulls). Thus, each element shared by ¯a and ¯b is also shared by ¯cj and ¯b. Consider ﬁrst an arbitrary atom in H′
j+1(T (¯a)).
j(R(¯cj)). But since
By deﬁnition, such atom is of the form T (hf (¯a)) for a mapping f such that R(f (¯cj)) belongs to H′
j(S(¯b)), and H′
j is a winning strategy for the duplicator in the game on
H′
(Ij, ¯x) and (D, ¯t), we have that there is an atom S(f ′(¯b)) ∈ H′
j+1(S(¯b)) such that f and f ′ coincide in the elements that
are shared by ¯cj and ¯b. This implies that hf and f ′ coincide in the elements that are shared by ¯a and ¯b. Consider now

j+1(S(¯b)) = H′

j+1(R(¯cj)) = H′

j(S(¯b)), and H′

j(R(¯cj )), H′

an atom S(f ′(¯b)) ∈ H′
j+1(R(¯cj)) such that f and f ′ coincide in all
elements shared by ¯cj and ¯b. Therefore, hf and f ′ coincide in all elements shared by ¯a and ¯b. The property follows then
since T (hf (¯a)) belongs to H′

j+1(S(¯b)). Then there is an atom R(f (¯cj)) ∈ H′

j+1(T (¯a)) by deﬁnition.

This concludes the proof of Lemma 32.

Unions of Conjunctive Queries

PROPOSITION 33. Let Σ be a ﬁnite set of tgds that belongs to a class that has acyclicity-preserving chase, and Q a UCQ.
If Q is semantically acyclic under Σ, then, for each CQ q ∈ Q, (i) there exists an acyclic CQ q′, where |q′| ≤ 2 · |q|, such that
q ≡Σ q′, or (ii) there exists q′′ ∈ Q such that q ⊆Σ q′′.

PROOF. Assume there exists q ∈ Q such that (i) and (ii) do not hold. We need to show that Q is not semantically acyclic.
Towards a contradiction, assume there exists an acyclic UCQ QA such that Q ≡Σ QA. Since Q ⊆Σ QA, there exists qA ∈ QA
such that q ⊆Σ qA. Moreover, since QA ⊆Σ Q, there exists ˆq ∈ Q such that qA ⊆Σ ˆq. Observe that q = ˆq; otherwise, q ⊆Σ ˆq
which contradicts the fact that (ii) does not hold. Therefore, q ≡Σ qA, which in turn implies that q is semantically acyclic
under Σ. By Proposition 8, we conclude that there exists an acyclic CQ q′, where |q′| ≤ 2 · |q|, such that q ≡Σ q′. But this
contradicts the fact that (i) does not hold, and the claim follows.

A similar result can be shown for UCQ rewritable classes of tgds. Notice that for the following result we exploit Proposition 
15 instead of Proposition 8.

PROPOSITION 34. Let C be a UCQ rewritbale class, Σ ∈ C a ﬁnite set of tgds, and q a UCQ. If Q is semantically acyclic
under Σ, then, for each CQ q ∈ Q, (i) there exists an acyclic CQ q′, where |q′| ≤ 2 · fC(q, Σ), such that q ≡Σ q′, or (ii) there
exists q′′ ∈ Q such that q ⊆Σ q′′.

By exploiting the above results, it is not difﬁcult to show that the complexity of SemAc when we focus on UCQs under the

various classes of sets of tgds considered in this work is the same as for CQs.

