Sharing and Exchanging Data

Rana Awada1(B), Pablo Barcel´o2, and Iluju Kiringa1

1 EECS, University of Ottawa, Ottawa, Canada

{rawad049,Iluju.kiringa}@uottawa.ca

2 Department of Computer Science, University of Chile, Santiago, Chile

pbarcelo@dcc.uchile.cl

Abstract. Exchanging and integrating data that uses diﬀerent vocabularies 
are two prominent problems in the database literature. These
problems have been, so far, solved separately, and never been addressed
together in a uniﬁed setting. In this paper, we propose a class of mappings 
- called DSE, for data sharing and exchange - that represents this
uniﬁed setting. We introduce a DSE setting with particular interpretation 
of related data where ordinary data exchange or data integration
cannot be applied. We deﬁne the class of DSE solutions in a DSE setting,
 that allow to store a part of explicit data and a set of inference rules
used to generate the complete set of exchanged data. We identify among
those a particular DSE solution with good properties; namely, one that
contains a minimal amount of explicit data. Finally, we deﬁne the set of
certain answers to conjunctive queries.

Keywords: Data exchange · Data coordination · Knowledge exchange

1 Introduction

Diﬀerent problems of accessing and integrating data residing in independent
sources have received wide attention in the literature, and diﬀerent systems
were introduced to solve these problems, e.g. distributed databases, federated
databases, data exchange settings, and (peer-to-peer) data coordination settings.
Data exchange [7] deﬁnes the problem of moving data residing in independent 
applications and accessing it through a new target schema. This process
of exchange only allows to move data from a source into a target that uses
the same set of vocabularies, and thus, transformation occurs to the structure
of the data, and not to the data itself. All data integration and coordination
systems [2,14,15], on the other hand, use diﬀerent query re-writing methods to
allow access to data residing in independent sources, that possibly use diﬀerent
vocabularies, without having to exchange it and while maintaining autonomy.

We show in what follow that a collaborative process – including coordination 
tools for managing diﬀerent vocabularies of diﬀerent sources and exchange
tools – would yield interoperability capabilities that are beyond the ones that
can be oﬀered today by any of the two tasks separately.

M. Hanus and R. Rocha (Eds.): KDPD 2013, LNAI 8439, pp. 17–32, 2014.
DOI: 10.1007/978-3-319-08909-6 2, c(cid:2) Springer International Publishing Switzerland 2014

18

R. Awada et al.

Recall that a data exchange (DE) setting [7] S consists of a source schema
S, a target schema T, and a set Σst of database dependencies – the so-called
source-to-target dependencies – that describes structural changes made to data
as we move it from source to target. This exchange solution supports exchanging
information between two applications that refer to the same object using the
same instance value. However, there exist cases where objects in the source are
named and referred to diﬀerently in the target. A motivating example of such
an exchange scenario is exchanging data about students applying for program
transfers from one university to a diﬀerent one. Indeed, diﬀerent universities can
oﬀer diﬀerent courses and a course in one university can possess one or more
equivalent courses in the second. Given what we mentioned so far about a DE
setting, we can easily deduce that DE does not support such type of exchange.
Unlike data exchange, data coordination (DC) settings [1] solved the problem
of integrating information of diﬀerent sources that possess diﬀerent yet related
domains of constants by using the mapping table construct [9] in their query
rewriting mechanisms. A mapping table speciﬁes for each source value the set of
related (or corresponding) target values. DC settings have been studied mainly in
peer-to-peer networks, where sources – called peers – possess equal capabilities
and responsibilities in terms of propagating changes and retrieving related information.
 A DC setting S consists of two schemas S1 and S2, and a set of mapping
tables {M}. We give in the following example a data coordination instance that
integrates data from two diﬀerent universities with diﬀerent domains of constants,
 and we show that query re-writing techniques still miss to return results
that are inferred by certain semantics of mapping tables.

Example 1. Let S be a DC setting. Suppose that S1 in S is a schema for the
University of Ottawa (UOO) and S2 in S is the schema of the University of
Carleton (UOC).

Suppose S1 has the relations: Student(Sname, Sage), Course(Cid, Cname,
P name), and Enroll(Sname, Cid, Cgrade). Also, let S2 consist of the relation symbols 
St(Sname, Sage, Saddress), Cr(Cid, Cname, P name) and T ake(Sname,
Cid, Cgrade).

Relation Student (St) stores students name and age (and address) information.
 Relation Course (Cr) stores courses ids and names information, in addition
to the program name which provides each course. Finally, relation Enroll (T ake)
stores the set of courses that each student completed.
Further, assume that S1 and S2 are connected by a mapping table M that
consists of the following pairs {(CSI1390, ECOR1606), (CSI1390, COM P 1005),
(CS, CS), (EN G, EN G)}.
Let I be an instance of S1 and J = {St (Alex, 18, Ottawa), Cr (ECOR1606,
Problem Solving and Computers, EN G), Cr (COM P 1005, Introduction to Computer 
Science I, CS), T ake (Alex, ECOR1606, 80)} be an instance of S2.

According to [2], posing a query q to I that computes the list of students
(cid:3) to
(cid:3) can

considered to have ﬁnished CS courses in U OO, will re-write q to a query q
retrieve a similar list from U OC following the semantics of M. A query q

Sharing and Exchanging Data

(cid:3). In this case, the answer of posing q

19
(cid:3): Select Sname From Cr, T ake Where Cr.Cid = T ake.Cid
be the following: q
And Cr.P name = (cid:3)
(cid:2)
CS
Assume that UOO accredits a ‘CS’ course to a student doing program transfer
from UOC only if this student ﬁnishes an equivalent ‘CS’ course, according to M,
in UOC. In Example 1, Alex is not considered as ﬁnished a ‘CS’ course at UOC.
Therefore, if Alex does a transfer to the CS program in U OO, he will not be
credited the CSI1390 course. However, if the semantics of the mapping table M
in this example specify that course CSI1390 in UOO is equivalent to the ENG
course ECOR1606 in UOC, and course CSI1390 in UOO is equivalent to the
CS course COM P 1005 in UOC, then it can be deduced that courses ECOR1606
and COM P 1005 are considered equivalent with respect to UOO according to M.
Therefore, given the fact that T ake (Alex, ECOR1606, 80) ∈ J in Example 1
along with the equivalence semantics in M, Alex is considered to have ﬁnished
the equivalent CS course COM P 1005 in UOC and he should be credited the
‘CS’ course CSI1390 with a grade 80 if he did a transfer to UOO.

(cid:3) to J is ∅.

To solve such a problem, we introduce a new class of settings, called data
sharing and exchange (DSE) settings, where exchange occurs between a source
and a target that use diﬀerent sets of vocabularies. Despite the importance of
the topic, the fundamentals of this process have not been laid out to date. In
this paper, we embark on the theoretical foundations of such problem, that
is, exchanging data between two independent applications with diﬀerent sets of
domains of constants. DSE settings extend DE settings with a mapping table M,
introduced in [9], to allow collaboration at the instance level. In addition, the
set of source-to-target dependencies Σst in DSE refers to such mapping table
so that coordination of distinct vocabularies between applications takes place
together with the exchange.

From what we have mentioned so far about DSE, one would think that all
DSE instances can be reduced to a usual DE instance where the source schema is
extended with a mapping table M. However, we argue in this paper that there
exist DSE settings with particular interpretation of related data in mapping
tables where DSE is diﬀerent than a DE setting (as we show later in Example 2).
One such particular interpretation of related data that we consider in this paper
is: a source element is mapped to a target element only if both are considered
to be equivalent (i.e. denote the same object). In this DSE scenario, DSE and
DE are diﬀerent because source and target data can be incomplete with respect
to the “implicit” information provided by the semantics of mapping tables. To
formalize this idea we use techniques developed by Arenas et al. in [5], where
authors introduced a knowledge exchange framework for exchanging knowledge
bases. It turns out that this framework suits our requirements, and in particular,
allows us to deﬁne the exchange of both explicit and implicit data from source
to target. Our main contributions in this work are the following:
(1) Universal DSE Solutions. We formally deﬁne the semantics of a DSE
setting and introduce the class of universal DSE solutions, that can be seen as a
natural generalization of the class of universal data exchange solutions [7] to the
DSE scenario, and thus, as “good” solutions. A universal DSE solution consists

20

R. Awada et al.

of a subset of explicit data that is necessary to infer the remaining implicit
information using a given set Σt of rules in the target.
(2) Minimal Universal DSE Solutions. We deﬁne the class of minimal universal 
DSE solutions which are considered as “best” solutions. A minimal universal 
DSE solution contains the minimal amount of explicit data required to
compute the complete set of explicit and implicit data using a set of target rules
Σt. We show that there exists an algorithm to generate a canonical minimal universal 
DSE solution, with a well-behaved set Σt of target rules, in Logspace.
(3) Query Answering. We formally deﬁne the set of DSE certain answers
for conjunctive queries. We also show how to compute those eﬃciently using
canonical minimal universal DSE solutions.

2 Preliminaries
A schema R is a ﬁnite set {R1, . . . , Rk} of relation symbols, with each Ri having
a ﬁxed arity ni > 0. Let D be a countably inﬁnite domain. An instance I of
i ⊆ Dni.
R assigns to each relation symbol Ri of R a ﬁnite ni-ary relation RI
Sometimes we write Ri(¯t) ∈ I instead of ¯t ∈ RI
i , and call Ri(¯t) a fact of I. The
domain dom(I) of instance I is the set of all elements that occur in any of the
relations RI
i . We often deﬁne instances by simply listing the facts that belong
to them. Further, every time that we have two disjoint schemas R and S, an
instance I of R and an instance J of S, we deﬁne (I, J) as the instance K of
schema R ∪ S such that RK = RI, for each R ∈ R, and SK = SJ, for each
S ∈ S.
Data Exchange Settings. As is customary in the data exchange literature
[7,8], we consider instances with two types of values: constants and nulls.1 More
precisely, let Const and Var be inﬁnite and disjoint sets of constants and nulls,
respectively, and assume that D = Const ∪ Var. If we refer to a schema S as
a source schema, then we assume that for an instance I of S, it holds that
dom(I) ⊆ Const; that is, source instances are assumed to be “complete”, as they
do not contain missing data in the form of nulls. On the other hand, if we refer
to a schema T as a target schema, then for every instance J of T, it holds that
dom(J) ⊆ Const∪Var; that is, target instances are allowed to contain null values.
A data exchange (DE) setting is a tuple S = (S, T, Σst), where S is a source
schema, T is a target schema, S and T do not have predicate symbols in common,
and Σst consists of a set of source-to-target tuple-generating dependencies (st-
tgds) that establish the relationship between source and target schemas. An
st-tgd is a FO-sentence of the form:

∀¯x∀¯y (φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z)),

(1)

1 We usually denote constants by lowercase letters a, b, c, . . . , and nulls by symbols
⊥,⊥(cid:2),⊥1, . . .

Sharing and Exchanging Data

21

(cid:3)

(cid:3)

where φ(¯x, ¯y) is a conjunction of relational atoms over S and ψ(¯x, ¯z) is a conjunction 
of relational atoms over T.2 A source (resp. target) instance K for S is
, I1, . . . ,
an instance of S (resp. T). We usually denote source instances by I, I
and target instances by J, J
An instance J of T is a solution for an instance I under S = (S, T, Σst), if
the instance (I, J) of S ∪ T satisﬁes every st-tgd in Σst. If S is clear from the
context, we say that J is a solution for I.

, J1, . . . .

The data exchange literature has identiﬁed a class of preferred solutions,
called the universal solutions, that in a precise way represents all other solutions.
In order to deﬁne these solutions, we need to introduce the notion of homomorphism 
between instances. Let K1 and K2 be instances of the same schema R.
A homomorphism h from K1 to K2 is a function h : dom(K1) → dom(K2) such
that: (1) h(c) = c for every c ∈ Const ∩ dom(K1), and (2) for every R ∈ R and
tuple ¯a = (a1, . . . , ak) ∈ RK1, it holds that h(¯a) = (h(a1), . . . , h(ak)) ∈ RK2. Let
S be a DE setting, I a source instance and J a solution for I under S. Then
(cid:3) for I under S,
J is a universal solution for I under S, if for every solution J
there exists a homomorphism from J to J

(cid:3).

For the class of data exchange settings that we referred to in this paper, every
source instance has a universal solution [7]. Further, given a DE setting S, there
is a procedure (based on the chase [6]) that computes a universal solution for
each source instance I under S. In the case when S is ﬁxed such procedure works
in Logspace. Assuming S to be ﬁxed is a usual and reasonable assumption in
data exchange [7], as mappings are often much smaller than instances. We stick
to this assumption for the rest of the paper.
Mapping Tables. Coordination can be incorporated at the data level, through
the use of mapping tables [9]. These mechanisms were introduced in data coordination 
settings [2] to establish the correspondence of related information in
diﬀerent domains. In its simplest form, mapping tables are just binary tables containing 
pairs of corresponding identiﬁers from two diﬀerent sources. Formally,
given two domains D1 and D2, not necessarily disjoint, a mapping table over
(D1, D2) is nothing else than a subset of D1 × D2. Intuitively, the fact that a pair
(d1, d2) belongs to the mapping table implies that value d1 ∈ D1 corresponds
to value d2 ∈ D2. Notice that the exact meaning of “correspondence” between
values is unspeciﬁed and depends on the application.

In this paper we deal with a very particular interpretation of the notion of
correspondence in mapping tables. We assume that the fact that a pair (a, b) is
in a mapping table implies that a and b are equivalent objects. We are aware
of the fact that generally mapping tables do not interpret related data in this
way. However, we argue that this particular case is, at the same time, practically
relevant (e.g. in peer-to-peer settings [9]) and theoretically interesting (as we will
see along the paper).

This particular interpretation of mapping tables implies that they may contain
implicit information that is not explicitly listed in their extension. For instance,

2 We usually omit universal quantiﬁcation in front of st-tgds and express them simply
as φ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z).

22

R. Awada et al.

assume that M is a mapping table that consists of the pairs {(a, c), (b, c), (b, d)}.
Since a and c are equivalent, and the same is true about b and c, we can infer
that a and b are equivalent. Also, we can infer using the same reasoning that c
and d are equivalent. Such implicit information is, of course, valuable, and cannot
be discarded at the moment of using the mapping table as a coordination tool.
In particular, we will use this view of mapping tables as being incomplete with
respect to its implicit data when deﬁning the semantics of DSE settings.

3 Data Sharing and Exchange Settings

We formally deﬁne in this section DSE settings that extend DE settings to allow
collaboration via mapping tables.

Deﬁnition 1 (DSE setting). A data sharing and exchange (DSE) setting is a
tuple S = (S, T,M, Σst), where: (1) S and T are a source and a target schema,
respectively; (2) M is a binary relation symbol that appears neither in S nor in
T, and that is called a source-to-target mapping (we call the ﬁrst attribute of M
the source attribute and the second one the target attribute); and (3) Σst consists
of a set of mapping st-tgds, which are FO sentences of the form

∀¯x∀¯y∀¯z (φ(¯x, ¯y) ∧ μ(¯x, ¯z) → ∃ ¯w ψ(¯z, ¯w)),

(2)

where (i) φ(¯x, ¯y) and ψ(¯z, ¯w) are conjunctions of relational atoms over S and T,
resp., (ii) μ(¯x, ¯z) is a conjunction of atomic formulas that only use the relation
symbol M, (iii) ¯x is the tuple of variables that appear in μ(¯x, ¯z) in the positions
of source attributes of M, and (iv) ¯z is the tuple of variables that appear in
μ(¯x, ¯z) in the positions of target attributes of M.

(cid:3)

(cid:3)

, I1, . . . and target instances by J, J

We provide some terminology and notations before explaining the intuition
behind the diﬀerent components of a DSE setting. As before, instances of S (resp.
T) are called source (resp. target) instances, and we denote source instances
, J1, . . . . Instances of M are called
by I, I
source-to-target mapping tables (st-mapping tables). By slightly abusing notation,
 we denote st-mapping tables also by M.
Let S = (S, T,M, Σst) be a DSE setting. We distinguish between the set of
source constants, denoted by ConstS, and the set of target constants, denoted by
ConstT, since applications that collaborate on data usually have diﬀerent data
domains. As in the case of usual data exchange, we also assume the existence of a
countably inﬁnite set Var of labelled nulls (that is disjoint from both ConstS and
ConstT). Also, in a DSE the domain of a source instance I is contained in ConstS,
while the domain of a target instance J belongs to ConstT ∪ Var. On the other
hand, the domain of the st-mapping table M is a subset of ConstS × ConstT.
Thus, coordination between the source and the target at the data level occurs
when M identiﬁes which source and target constants denote the same object.
The intuition behind usual st-tgds is that they specify how source data has to
be transformed to conform to the target schema (that is, coordination at the

Sharing and Exchanging Data

23

schema level). However, since in the DSE scenario we are interested in transferring 
data based on the source instance as well as on the correspondence between
source and target constants given by the st-mapping table that interprets M,
the mapping st-tgds extend usual st-tgds with a conjunction μ that ﬁlters the
target data that is related via M with the corresponding source data.
More formally, given a source instance I and an st-mapping table M, the
mapping st-tgd φ(¯x, ¯y) ∧ μ(¯x, ¯z) → ∃ ¯wψ(¯z, ¯w) enforces the following: whenever
I |= φ(¯a, ¯b), for a tuple (¯a, ¯b) of constants in ConstS∩ dom(I), and the tuple ¯c of
constants in ConstT is related to ¯a via μ (that is, M |= μ(¯a, ¯c)), then it must be
the case that J |= ψ(¯c, ¯d), for some tuple ¯d of elements in dom(J) ∩ (ConstT ∪
Var), where J is the materialized target instance. In usual DE terms, we should
say that J is a solution for I and M under S, i.e. (((I ∪ {M}), J) (cid:3) Σst).
However, as we see in the next section, solutions have to be deﬁned diﬀerently
in DSE. Therefore, to avoid confusions, we say J is a pre-solution for I and M
under S.
Example 2. Let S = (S, T,M, Σst) be a DSE setting. In reference to Example 1,
assume that S in S is the schema of UOC and T in S is the schema of UOO.
Suppose that M in S consists of the following pairs {(ECOR1606, CSI1390),
(COM P 1005, CSI1390), (COM P 1005, CSI1790), (CS,CS), (EN G,EN G),
(Alex,Alex), (18,18)}. Finally, let Σst consist of the following st-mapping depen-
dencies:

(a) St(x, y, z) ∧ T ake(x, w, u) ∧ Cr(w, v, ‘CS’) ∧ M(x, x
(b) St(x, y, z)∧ T ake(x, w, u)∧ Cr(w, v, ‘CS’)∧M(x, x

(cid:3)) ∧ M(y, y
(cid:3))
→ Student(x
(cid:3)
(cid:3)).
, y
(cid:3))∧M(w, w
(cid:3))∧M(u, u
→ Enroll(x
(cid:3)
(cid:3)
, w

(cid:3)).

(cid:3))

, u

It is clear that this DSE instance is exchanging information of UOC students
that have taken ‘CS’ courses with the list of courses they have ﬁnished. Also,
M speciﬁes that the Introduction to Computers course with Cid = CSI1390
in UOO has a French version course Introduction aux Ordinateurs with Cid =
CSI1790 provided at UOO. Let I = {St(Alex, 18, Ottawa), Cr(ECOR1606,
Problem Solving and Computers, EN G), Cr(COM P 1005, Introduction to Computer 
Science I, CS), T ake (Alex, ECOR1606, 80)} be an instance of S. Then,
J = ∅ is a pre-solution for I and M under S.
(cid:2)
We can see in Example 2 that in the pre-solution J, Alex is not considered
as have ﬁnished a ‘CS’ course. However, if the st-mapping table M follows
the semantics we adopt in this paper, then Alex should be considered to have
completed the ‘CS’ course Introduction to Computer Science I. Therefore, we
can easily deduce that in a DSE setting S, we cannot identify solutions with
pre-solutions. One reason is that a source instance I in S can be incomplete with
respect to the semantics of M as the case in Example 2 above. A second reason
is that data mappings in an st-mapping table M in S can also be incomplete
with respect to the semantics of M as we shall show in Sect. 4. Data mappings in
an st-mapping table M are usually speciﬁed by domain specialists. However, M

24

R. Awada et al.

should record not only the associations suggested by the domain specialists, but
also the ones inferred by its semantics. Therefore, to capture the real semantics
of the DSE problem, we came up with a more sophisticated notion of a solution
that we introduce in the following section.

4 DSE and Knowledge Exchange
From now on we use the equivalence relation ∼ as a ∼ b to intuitively denote
that a and b, where {a, b} ⊆ ConstS (or {a, b} ⊆ ConstT) are inferred by the
semantics of an st-mapping table M as equivalent objects. Let us revisit Example 
2. There are two ways in which the data in S is incomplete: First of all,
since M(ECOR1606, CSI1390) holds in S, then UOC course ECOR1606 is
equivalent to the UOO course CSI1390. Also, since M(COM P 1005, CSI1390)
holds, then UOC course COM P 1005 is equivalent to the UOO course CSI1390.
Therefore, we can deduce that ECOR1606 ∼ COM P 1005 with respect to the
target UOO. This means, according to semantics of ∼, the source instance I
is incomplete, since I should include the tuple T ake(Alex, COM P 1005, 80) in
order to be complete with respect to M.
Second, since M(COM P 1005, CSI1390) holds in S, then the UOC course
COM P 1005 is equivalent to the UOO course CSI1390 according to the semantics 
of M. Also, since M(COM P 1005, CSI1790) holds in S, then course COM P
1005 is equivalent to the UOO course CSI1790. Therefore, we can deduce that
CSI1390 ∼ CSI1790, according to the semantics of M. This implies that
M is incomplete, since the fact that {(ECOR1606, CSI1390), (COM P 1005,
CSI1390), (COM P 1005, CSI1790)} ⊆ M entails from the semantics of ∼ the
fact that (ECOR1606, CSI1790) ∈ M. Therefore, we say I and M are incomplete 
in the sense that they do not contain all the data that is implied by the
semantics of M. Further, it is not hard to see that the completion process we
just sketched can become recursive in more complex DSE instances.

Given the above reasoning, again one would think to solve the DSE problem
by reducing it to a DE setting S with a set of dependencies deﬁned over a
combined schema (S ∪ {M}), which complete the source instance I and the stmapping 
table M under S with the additional data entailed by the semantics
of M. However, usually the real reason behind deﬁning dependencies over a
databases schema is to ensure that data stored in the extension of this schema
or new coming tuples follow the structure of it [16]. Also, such constraints are
not treated as additional implicit data that represents speciﬁc semantics in stmapping 
tables, and whose purpose is to entail new facts in addition to the stored
ones. Therefore, to apply the intuition explained in Example 2 and to generate
“good” solutions in a DSE setting, it is assumed to be fundamental that both
explicit data stored in I and implicit data entailed by the semantics of M are
exchanged to the target. Contrarily, we show in what follow that semantics of
a DSE setting vary from those of DE setting since there exist solutions which
consist of a portion of the fully exchanged set of data and yet are still good
solutions that proved in Sect. 7 to be eﬃcient for conjunctive query answering.

Sharing and Exchanging Data

25

From what we explained so far, we conclude that the real semantics of a
DSE setting is based on the explicit data contained in I and M, in addition to
the implicit data obtained by following a completion process for the source, the
target, and M.
We deﬁne below a set of FO sentences, of type full tgds3, over a schema
S ∪ M (T ∪ M) extended with a fresh binary relation symbol Equal that
appears neither in S nor in T and that captures the semantics of ∼ in a recursive
scenario, which formally deﬁnes this completion process:
Deﬁnition 2 (Source and Target Completion). Let S = (S, T,M, Σst) be
s, is the conjunction
a DSE setting. The source completion of S, denoted by Σc
of the following FO sentences over the schema S ∪ {M, Equal}:
1. For each S ∈ S∪{M} of arity n and 1 ≤ i ≤ n: ∀x1 ···∀xn(S(x1, . . . , xi, . . . , xn) →
2. ∀x∀y(Equal(y, x) → Equal(x, y)).
3. ∀x∀y∀z(Equal(x, z) ∧ Equal(z, y) → Equal(x, y)).
4. ∀x∀y∀z(M(x, z) ∧ M(y, z) → Equal(x, y)).
5. ∀x∀y∀z∀w(M(x, z) ∧ Equal(x, y) ∧ Equal(z, w) → M(y, w)).
6. For each S ∈ S of arity n: ∀x1, y1 ···∀xn, yn(S(x1, . . . , xn)∧(cid:2)n

Equal(xi, yi) →

Equal(xi, xi)).

i=1

S(y1, . . . , yn)).

The target completion of S, denoted Σc
ing the role of S by T in Σc
M(z, y) → Equal(x, y)) that deﬁnes the completion of M over the target.

t , is deﬁned analogously by simply replacs,
 and then adding the rule 7. ∀x∀y∀z(M(z, x) ∧

t is analogous.

Notice that the ﬁrst 3 rules of Σc

s make sure that Equal is an equivalence
relation on the domain of the source instance. The fourth rule detects which
source elements have to be declared equal by the implicit knowledge contained
in the st-mapping table. The last two rules allow to complete the interpretation
of M and the symbols of S, by adding elements declared to be equal in Equal.
The intuition for Σc
Summing up, data in a DSE scenario always consists of two modules: (1)
The explicit data stored in the source instance I and the st-mapping table M,
t . This naturally calls for
and (2) the implicit data formalized in Σc
a deﬁnition in terms of knowledge exchange [5], as deﬁned next. A knowledge
base (KB) over schema R is a pair (K, Σ), where K is an instance of R (the
explicit data) and Σ is a set of logical sentences over R (the implicit data). The
knowledge base representation has been used to represent various types of data
including ontologies in the semantic web, which are expressed using diﬀerent
types of formalisms including Description Logic (DL) [12].

s and Σc

The set of models of (K, Σ) [5], denoted by Mod(K, Σ), is deﬁned as the set
of instances of R that contain the explicit data in K and satisfy the implicit
data in Σ; that is, Mod(K, Σ) corresponds to the set {K
(cid:3) is an instance of
(cid:3) |= Σ}. In DSE, we consider source KBs of the form ((I ∪
R, K ⊆ K
{M}), Σc
s), which intuitively correspond to completions of the source instance
3 Full tgds are tgds that do not use existential quantication.

(cid:3) and K

(cid:3) | K

26

R. Awada et al.

I with respect to the implicit data in M, and, analogously, target KBs of the
form ((J ∪ {M}), Σc
t ).

s, Σc

(cid:3)
S and K

(cid:3)
M under S.

(cid:3) ∈ Mod((I ∪ {M}, Σc

(cid:3) ∈ Mod((I ∪ {M}), Σc

A good bulk of work has recently tackled the problem of exchange of KBs
that are deﬁned using diﬀerent DL languages [4]. we formalize the notion of
(universal) DSE solution to extend the KB (universal) solution introduced in [5].
The main diﬀerence is that in DSE solutions we need to coordinate the source
and target information provided by M, as opposed to KB solutions that require
no data coordination at all. This is done by establishing precise relationships
in a (universal) DSE solution between the interpretation of M in S and T,
respectively. KB exchange in DL showed that target KB (universal) solutions [5]
present several limitations since these can miss some semantics of the source
KB [4]. Universal DSE solutions, on the other hand, do not have those limitations
and they reﬂect the semantics in the source and the st-mapping table accurately.
From now on, KR(cid:2) denotes the restriction of instance K to a subset R(cid:3) of
its schema R. Let S = (S, T,M, Σst) be a DSE setting, I a source instance, M
t are the source and
an st-mapping table, J a target instance. Recall that Σc
target completions of S, respectively. Then:
1. J is a DSE solution for I and M under S, if for every K ∈ Mod((J∪{M}), Σc
t )
M ⊆
(cid:3)
2. In addition, J is a universal DSE solution for I and M under S, if J is a
s) there is K ∈ Mod((J ∪
(cid:3)
S and

there is K
KM, and (b) KT is a pre-solution for K

t ) such that (a) KM ⊆ K

s) such that the following hold: (a) K

(cid:3)
M, and (b) KT is a pre-solution for K

DSE solution, and for every K
{M}, Σc
(cid:3)
M under S.
K
In Example 2, J = {Student(Alex, 18), Enroll (Alex, CSI1390, 80), Enroll
(Alex, CSI1790, 80)} is a universal DSE solution for I and M under S. We
deﬁne below a simple procedure CompUnivDSESolS that, given a DSE setting
S = (S, T,M, Σst) and a source instance I and an st-mapping table M, it
generates a universal DSE solution J for I and M under S.
CompUnivDSESolS:
Input: A source instance I, an st-mapping table M, and a set Σst of st-tgds.
Output: A Canonical Universal DSE solution J for I and M under S.
s, to I and M, and generate ˆI and
1. Apply the source completion process, Σc
2. Apply a procedure (based on the chase [6]) to the instance (ˆI ∪ { ˆM}), and

ˆM respectively.
generate a canonical universal pre-solution J for ˆI and ˆM.
The procedure CompUnivDSESolS works as follows: step 1 applies the source
s, given in Deﬁnition 2, to I and M, and returns as outcome
completion process Σc
the source instance ˆI and the st-mapping table ˆM that are complete with respect
to the implicit data in M. Next, step 2 generates a canonical universal presolution 
J for ˆI and ˆM such that ((ˆI ∪ ˆM), J) (cid:3) Σst.

We can combine the fact that universal solutions in ﬁxed data exchange
settings S = (S, T, Σst) can be computed in Logspace [3] with some deep

Sharing and Exchanging Data

27

results in the computation of symmetrical binary relations [10], to show that
universal DSE solutions can be computed in Logspace:
Proposition 1. Let S = (S, T,M, Σst) be a ﬁxed DSE setting. Then computing
a universal DSE solution J for a source instance I and an st-mapping table M
is in Logspace.

(1) In Σc

Proof. To prove that the CompUnivDSESolS procedure computes a universal
DSE solution for I and M under S in Logspace, we rely on the following facts:
s (in step 1 to step 4), we compute the transitive closures of the symmetrical 
binary table Equal. Computing the transitive closure of symmetrical
s compute
binary relations is solvable in Logspace [10]; (2) steps 5 and 6 of Σc
the complete instances ˆI and the st-mapping table ˆM using Equal. This step
can be computed by applying the naive chase procedure to I and M using rules
s. Following the result in [7] that a naive chase procedure runs in
5 and 6 of Σc
Logspace, we can deduce that generating ˆI and ˆM using steps 5 and 6 of Σc
s is
in Logspace; (3) step 2 of CompUnivDSESolS procedure can be reduced to the
problem of computing a universal solution for (ˆI∪{ ˆM}) in a ﬁxed DE setting S.
Consequently, similar to steps 5 and 6 in Σc
s, this process works in Logspace in
a ﬁxed DSE setting; (4) ﬁnally, since Logspaceis closed under composition [11],
we conclude that CompUnivDSESolS is in Logspace.

5 Minimal Universal DSE Solutions

(cid:3) of J such that J

In the context of ordinary data exchange, “best”solutions – called cores – are
universal solutions with minimal size. In knowledge exchange, on the other hand,
“best” solutions are cores that materialize a minimal amount of explicit data.
Intuitively, a minimal universal DSE (MUDSE) solution is a core universal DSE
solution J that contains a minimal amount of explicit data in J with respect to
t , and such that no universal DSE solution with strictly less constants is also
Σc
t .
a universal DSE solution with respect to Σc
We deﬁne this formally: Let S be a DSE setting, I be a source instance, M
an st-mapping table, and J a universal DSE solution for I and M under S.
Then J is a MUDSE solution for I and M under S, if: (1) There is no proper
(cid:3) is a universal DSE solution for I and M under S,
subset J
(cid:3)) ∩ ConstT is
and; (2) There is no universal DSE solution J
properly contained in dom(J) ∩ ConstT .
So, in Example 2, J = {Student(Alex, 18), Enroll (Alex, CSI1390, 80)} is
a MUDSE solution for I and M under S. Note that the DSE solution J
(cid:3) =
{Student(Alex, 18), Enroll (Alex, CSI1390, 80), Enroll (Alex, CSI1790, 80)}
is a core universal DSE solution, however it is not the most compact one. Condition 
(2) in the deﬁnition of MUDSE solutions is not part of the original deﬁnition
of minimal solutions in knowledge exchange [5]. However, this condition is necessary 
as we see below.
Assume that the universal DSE solution in Example 2 includes the following 
two facts {T each(Anna, CSI1390), T each(Anna, CSI1790)}, where T

(cid:3) such that dom(J

28

R. Awada et al.

is extended with the relation T each(T id, Cid) which speciﬁes the teachers and
the list of courses they teach. Then, the DSE solution J = {Student(Alex, 18),
Enroll (Alex, CSI1390, 80), T each(Anna, CSI1790)} does not satisfy condition
(2) and provides us with redundant information with respect to I and M, since
we can conclude that CSI1390 and CSI1790 are equivalent courses. A MUDSE
solution however would be J = {Student(Alex, 18), Enroll(Alex, CSI1390, 80),
T each(Anna, CSI1390)}.
We deﬁne below a procedure CompMUDSEsolS, that given a DSE setting S, a
source instance I, and an st-mapping table M, it computes a MUDSE solution
∗ for I and M under S in Logspace. This procedure works as follows:
J
CompMUDSEsolS:
Input: A source instance I, an st-mapping table M, and a set Σst of st-tgds.
Output: A Minimal Universal DSE solution J

∗ for I and M under S.

ˆM respectively.
there exists a source constant a such that ˆM(a, c1) and ˆM(a, c2) hold.
that c1 and c2 exist in Ci only if c1 ∼ c2.

s, to I and M, and generate ˆI and
1. Apply the source completion process, Σc
2. Deﬁne an equivalence relation ∼ on dom( ˆM) ∩ ConstT as follows: c1 ∼ c2 iﬀ
3. Compute equivalence classes {C1, . . . , Cm} for ∼ over dom( ˆM)∩ConstT such
4. Choose a set of witnesses {w1, . . . , wm} where wi ∈ Ci, for each 1 ≤ i ≤ m.
5. Compute from ˆM the instance M1 := replace( ˆM, w1, . . . , wm) by replacing
6. Apply a procedure (based on the chase [6]) to the instance (ˆI ∪ {M1}), and

each target constant c ∈ Ci ∩ dom( ˆM) (1 ≤ i ≤ m) with wi ∈ Ci.
generate a canonical universal pre-solution J for ˆI and M1.

7. Apply a procedure (based on the core [8]) to the target instance J and generate

the target instance J

∗ that is the core of J.

We prove the correctness of CompMUDSEsolS in the following Theorem.

Theorem 1. Let S be a DSE setting, I a source instance, and M an st-mapping
∗ is an arbitrary result for CompMUDSEsolS(I,M). Then,
table. Suppose that J
∗ is a minimal universal DSE solution for I and M under S.
J
In data exchange, the smallest universal solutions are known as cores and
can be computed in Logspace [8]. With the help of such result we can prove
that MUDSE solutions can be computed in Logspace too. Also, in this context
MUDSE solutions are unique up to isomorphism:

Theorem 2. Let S be a ﬁxed DSE setting. There is a Logspace procedure
that computes, for a source instance I and an st-mapping table M, a MUDSE
solution J for I and M under S. Also, for any two MUDSE solutions J1 and
J2 for I and M under S, it is the case that J1 and J2 are isomorphic.
Proof. The proof of the ﬁrst part of this theorem is very similar to the proof of
Proposition 1, with the diﬀerence that steps 2, 3, and 4 in CompMUDSEsolS seem
to be non-deterministic since they involve choosing a set of witnesses {w1, . . . ,
wm} for {C1, . . . , Cm}. Clearly, diﬀerent sets of witnesses may yield diﬀerent

Sharing and Exchanging Data

29

target instances. However, each possible choice of witnesses leads to a minimal
universal DSE solution. In addition, according to [7,8], generating cores can be
computed in Logspace by applying the naive chase and the simple Greedy
algorithm [8]. Finally, since Logspace is closed under composition [11], we can
deduce that the procedure CompMUDSEsolS is computed in Logspace.

6 Query Answering

In data exchange, one is typically interested in the certain answers of a query
Q, that is, the answers of Q that hold in each possible solution [7]. For the case
of DSE we need to adapt this deﬁnition to solutions that are knowledge bases.
Formally, let S be a DSE setting, I a source instance, M an st-mapping table,
and Q a FO conjunctive query over T. The set of certain answers of Q over I
and M and under S, denoted certainS((I ∪ {M}), Q), corresponds to the set of
tuples that belong to the evaluation of Q over KT, for each DSE solution J for
I and M and K ∈ Mod((J ∪ {M}), Σc
t ).
Example 3. We refer to the DSE setting given in Example 2. Let Q(x, y, z) =
Enroll(x, y, z). Then, certainS((I ∪ {M}), Q) = {Enroll(Alex, CSI1390, 80),
Enroll(Alex, CSI1790, 80)}.
(cid:2)

In DE, certain answers of unions of CQs can be evaluated in Logspace
by directly posing them over a universal solution [7], and then discarding tuples
with null values. The same complexity bound holds in DSE by applying a slightly
diﬀerent algorithm. In fact, certain answers cannot be simply obtained by posing
Q on a universal DSE solution J, since J might be incomplete with respect to
the implicit data in Σc
t .

One possible solution would be to apply the target completion program Σc
t
to a universal DSE solution J (denoted as Σc
t (J)) as a ﬁrst step, then apply
Q to Σc
t (J). A second method is to compute certain answers of Q using a
MUDSE solution. A MUDSE solution J in DSE possesses an interesting property,
 that is, applying Q to J returns a set of certain answers U that mini-
(cid:3) returned when Q is applied to
mally represents the set of certain answers U
t (J). We can compute certainS((I ∪{M}), Q) directly using J, by ﬁrst applyΣc

ing rules in Σc
t , excluding rule 6, to generate the binary table Equal. Then
complete the evaluation of Q on J, Q(x1, . . . , xn), and return ˆQ(y1, . . . , yn) =
Q(x1, . . . , xn) ∧ (cid:2)n

Equal(xi, yi).

i=1

Adopting the second method to compute certain answers using MUDSE solutions 
and EQUAL proved in Sect. 7 to exhibit a much better performance in run
times than the ﬁrst method. These results make MUDSE solutions distinguished
for their compactness and for their performance in query answering. We also
obtain the following result:
Proposition 2. Let S = (S, T,M, Σst) be a ﬁxed DSE setting, I a source
instance, M an st-mapping table, J a MUDSE solution, and Q a ﬁxed CQ over
T. Then, certainS((I ∪{M}), Q) = ˆQ(J) where ˆQ(y1, . . . , yn) = Q(x1, . . . , xn)∧
(cid:2)n

Equal(xi, yi)

i=1

30

R. Awada et al.

In addition, we prove in the following proposition that we can still compute

the set of certain answers of a conjunctive query Q in Logspace.
Proposition 3. Let S = (S, T,M, Σst) be a ﬁxed DSE setting and Q a ﬁxed
union of CQs. There is a Logspace procedure that computes certainS((I ∪
{M}), Q), given a source instance I and an st-mapping table M.
Proof. Let Q be a ﬁxed union of conjunctive queries. The fact that computing
the set of certain answers of Q, certainS((I ∪{M}), Q) is in Logspace, is based
on the following facts: (1) following Proposition 1, generating a universal DSE
solution is in Logspace; and (2) following Theorem 2, generating a MUDSE
solution is in Logspace; and ﬁnally (3) it is known from [11] that the data
complexity of any FO formula is in Logspace, and thus checking if a ﬁxed
conjunctive query is satisﬁed in a database instance is in Logspace.

7 Experiments

(cid:3)

, y

, z

We implement the knowledge exchange semantics we introduced in this paper in
a DSE prototype system. This system eﬀectively generates universal DSE and
MUDSE solutions that can be used to compute certain answers for CQs using
the two methods introduced in Sect. 6. We used the DSE scenario of Example 2
(cid:3)) → Course
extended with the st-tgd: Cr(x, y, z)∧M(x, x
(cid:3)). Due to the lack of a benchmark that enforces recursion of the ∼
(cid:3)
(x
equivalence relation in the st-mapping table M and due to size restrictions, we
synthesized the data in our experiments.

(cid:3))∧M(y, y

(cid:3))∧M(z, z

We show in our experiments that as the percentage of recursion increases in
an st-mapping table, the run time to generate a universal DSE solution exceeds
the time to generate a MUDSE solution. We also show that computing certain
answers using a MUDSE solution is more eﬀective than using a universal DSE
solution. The experiments were conducted on a Lenovo workstation with a DualCore 
Intel(R) 1.80 GHz processor running Windows 7, and equipped with 4GB
of memory and a 297 GB hard disk. We used Python (v2.7) to write the code
and PostgreSQL (v9.2) database system.
DSE and MUDSE Solutions Computing Times. We used in this experiment 
a source instance I of 4,500 tuples, and 500 of those were courses information.
 The DSE system leveraged the work done in the state of the art ++Spicy
system [13] to generate MUDSE solutions. We mapped courses data in the source
to common target courses in M, with diﬀerent ∼ equivalence percentages (to
enforce a recursive ∼ relation). The remaining set of source data was mapped to
itself in M. Figure 1 shows that as the percentage of recursion in ∼ equivalence
relation over M increases, the run times to generate universal DSE and MUDSE
solutions increase. The reason is, as the ∼ percentage increases, the number of
source values (and target values) inferred to be ∼ increases, and thus the size of
t increases. Also, since target instances are usually
Equal created in Σc
larger than M, the run time of completing the former to generate DSE solutions
exceeds the time of completing the later when generating MUDSE solutions.

s and Σc

Sharing and Exchanging Data

31

Fig. 1. MUDSE and Universal DSE
solutions generation times

Fig. 2. Queries run times against a
core of a universal DSE solution and
a MUDSE solution

Table 1. List of queries

Q1 Fetch all the students names and the name of courses they have taken
Q2 Fetch the list of pairs of students ids and names that took the same course
Q3 Fetch all the students names and the grades they have received
Q4 Fetch the list of pairs of courses names that belong to the same program
Q5 Fetch for each student id the pair of courses that he has ﬁnished with the same

grade

Q6 Fetch all the courses ids and their names
Q7 Fetch all the students ids and their names
Q8 Fetch the list of pairs of students ids that possess the same address

Conjunctive Queries Computing Times. We have selected a set of 8 queries
to compare the performance of computing certain answers using a universal
DSE solution (following the ﬁrst method in Sect. 6) versus a MUDSE solution
(following the second method in Sect. 6). We list the queries in Table 1.
We applied the list of input queries to a DSE instance where the ∼ percentage
is 40 % and a course in the source is mapped to a maximum of two courses in
the target. We chose a universal DSE solution, with a property of being a core
of itself, that had around 18,000 records, and a MUDSE solution that contained
around 4,900 records. Figure 2 shows that computing the sets of certain answers
for the input conjunctive queries using a MUDSE solution take less run times
than when computing these using a DSE solution. In addition, the deterioration
in performance of query execution against the DSE solution appeared more in
queries Q2 and Q5 than the remaining queries, is because both queries apply
join operations to the Enroll table that involves a lot of elements which are
inferred to be equivalent by M.

8 Concluding Remarks

We introduced a DSE setting which exchanges data between two applications
that have distinct schemas and distinct yet related sets of vocabularies. To cap32


R. Awada et al.

ture the semantics of this setting, we deﬁned DSE as a knowledge exchange
system with a set of source and target rules that infer the implicit data should
be in the target. We formally deﬁned DSE solutions and identiﬁed the minimal
among those. Also, we studied certain answers for CQs. Finally, we presented a
prototype DSE system that generates universal DSE solutions and minimal ones,
and it computes certain answers of CQs. In future work, we will investigate a
more general DSE setting were mapped elements are not necessarily equal.

Acknowledgments. We thank NSERC for providing us the grants.

References

1. Bernstein, P., Giunchiglia, F., Kementsietsidis, A., Mylopoulos, J., Serani, L.,
Zaihrayeu, I.: Data management for Peer-to-Peer computing: a vision. In: Proceedings 
of the Workshop on the Web and Databases (WebDB’02) (2002)

2. Arenas, M., Kantere, V., Kementsietsidis, A., Kiringa, I., Miller, R.J., Mylopoulos,
J.: The hyperion project: from data integration to data coordination. In: ACM
SIGMOD Record, pp. 53–58 (2003)

3. Arenas, M., Barcel´o, P., Libkin, L., Murlak, F.: Relational and XML Data

Exchange. Morgan and Claypool Publishers, New York (2010)

4. Arenas, M., Botoeva, E., Calvanese, D.: Knowledge base exchange. In: Proceedings

of Description Logics (2011)

5. Arenas, M., Perez, J., Reutter, J.L.: Data exchange beyond complete data. In:

Proceedings of PODS, pp. 83–94 (2011)

6. Beeri, C., Vardi, M.Y.: A proof procedure for data dependencies. J. ACM 71(4),

718–741 (1984)

7. Fagin, R., Kolaitis, P.G., Miller, R.J., Popa, L.: Data exchange: semantics and

query answering. Theor. Comput. Sci 336(1), 89–124 (2005)

8. Fagin, R., Kolaitis, P.G., Popa, L.: Data exchange: getting to the core. ACM Trans.

Database Syst 30(1), 174–210 (2005)

9. Kementsietsidis, A., Arenas, M., Miller, R.J.: Mapping data in peer-to-peer sys-
tems: semantics and algorithmic issues. In: Proceedings of the 2003 ACM SIGMOD
International Conference on Management of Data, pp. 325–336 (2003)

10. Reinghold, O.: Undirected connectivity in log-space. J. ACM 55(4), 1–24 (2008)
11. Arenas, M., Reutter, J., Barcel´o, P.: Query languages for data exchange: beyond
unions of conjunctive queries. In: Proceedings of the 12th International Conference
on Database Theory, pp. 73–83 (2009)

12. Baader, F., Calvanese, D., McGuinness, D.L., Nardi, D., Patel-Schneider, P.F.:
The Description Logic Handbook. Cambridge University Press, Cambridge (2003)
13. Marnette, B., Mecca, G., Papotti, P.: ++Spicy: an open-source tool for secondgeneration 
schema mapping and data exchange. In: Proceedings of the VLDB, pp.
1438–1441 (2011)

14. Levy, A.Y., Rajaraman, A., Ordille, J.: Querying heterogeneous information

sources using source descriptions. In: Proceedings of VLDB, pp. 251–262 (1996)

15. Larson, J.A., Sheth, A.P.: Federated database systems for managing distributed,
heterogeneous, and autonomous databases. ACM Comput. Surv 22(3), 183–236
(1990)

16. Motik, B., Horrocks, I., Sattler, U.: Bridging the gap between OWL and relational

databases. J. Web Semant. 7(2), 74–89 (2009)

