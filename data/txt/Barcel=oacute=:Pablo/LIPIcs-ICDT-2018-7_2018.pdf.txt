A More General Theory of Static Approximations
for Conjunctive Queries

Pablo Barceló
Millenium Institute for Foundational Research on Data, DCC, University of Chile, Santiago,
Chile
pbarcelo@dcc.uchile.cl
Miguel Romero
University of Oxford, Oxford, UK
miguel.romero@cs.ox.ac.uk
Thomas Zeume
TU Dortmund, Dortmund, Germany
thomas.zeume@cs.tu-dortmund.de

Abstract

Conjunctive query (CQ) evaluation is NP-complete, but becomes tractable for fragments of
bounded hypertreewidth. If a CQ is hard to evaluate, it is thus useful to evaluate an approximation 
of it in such fragments. While underapproximations (i.e., those that return correct answers
only) are well-understood, the dual notion of overapproximations that return complete (but not
necessarily sound) answers, and also a more general notion of approximation based on the symmetric 
diﬀerence of query results, are almost unexplored. In fact, the decidability of the basic
problems of evaluation, identiﬁcation, and existence of those approximations, is open.

We develop a connection with existential pebble game tools that allows the systematic study
of such problems. In particular, we show that the evaluation and identiﬁcation of overapproximations 
can be solved in polynomial time. We also make progress in the problem of existence
of overapproximations, showing it to be decidable in 2EXPTIME over the class of acyclic CQs.
Furthermore, we look at when overapproximations do not exist, suggesting that this can be alleviated 
by using a more liberal notion of overapproximation. We also show how to extend our
tools to study symmetric diﬀerence approximations. We observe that such approximations properly 
extend underand 
over-approximations, settle the complexity of its associated identiﬁcation
problem, and provide several results on existence and evaluation.

2012 ACM Subject Classiﬁcation Information systems → Structured Query Language, Theory
of computation → Database query languages (principles), Theory of computation → Database
theory → Database query processing and optimization (theory)

Keywords and phrases conjunctive queries, hypertreewidth, approximations, pebble games

Digital Object Identiﬁer 10.4230/LIPIcs.ICDT.2018.7

Acknowledgements Barceló and Romero have been funded by Millennium Nucleus Center for
Semantic Web Research under Grant NC120004. Barceló has also been funded by Fondecyt grant
1170109. Zeume acknowledges the ﬁnancial support by the European Research Council (ERC),
grant agreement No 683080. Romero and Zeume thank the Simons Institute for the Theory of
Computing for hosting them.

© Pablo Barceló, Miguel Romero, and Thomas Zeume;
licensed under Creative Commons License CC-BY

21st International Conference on Database Theory (ICDT 2018).
Editors: Benny Kimelfeld and Yael Amsterdamer; Article No. 7; pp. 7:1–7:22

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

7:2

A More General Theory of Static Approximations for Conjunctive Queries

Introduction

1
Context. Due to the growing number of scenarios in which exact query evaluation is
infeasible – e.g., when the volume of the data being queried is very large, or when queries
are inherently complex – approximate query answering has become an important area of
study in databases (see, e.g.
[15, 20, 24, 12, 13]). Here we focus on approximate query
answering for the fundamental class of conjunctive queries (CQs), for which exact evaluation
is NP-complete. (Recall that CQ evaluation is the problem of given a CQ q, a database D,
and a tuple ¯a of constants in D, check if ¯a belongs to q(D), the result of q over D).

It is known that the complexity of evaluation of a CQ depends on its degree of acyclicity,
which can be formalized using diﬀerent notions. One of the most general and well-studied
such notions corresponds to generalized hypertreewidth [17]. Notably, the classes of CQs
of bounded generalized hypertreewidth can be evaluated in polynomial time (see [16] for a
survey). Following recent work on approximate query answering for CQs and some related
query languages [5, 6], we study the process of approximating a CQ as one of bounded
generalized hypertreewidth. This provides us with a certiﬁcate of eﬃciency for the cost of
evaluating such an approximation.

It is worth noticing that our approximations are static, in the sense that they depend
only on the CQ q and not on the underlying database D. This has clear beneﬁts in terms of
the cost of the approximation process, as q is often orders of magnitude smaller than D and
an approximation that has been computed once can be used for all databases. Moreover, it
allows us to construct a principled approach to CQ approximation based on the well-studied
notion of CQ containment [8]. Recall that a CQ q is contained in a CQ q0, written q ⊆ q0,
if q(D) ⊆ q0(D) over each database D. This notion constitutes the theoretical basis for the
study of several CQ optimization problems [1].

We denote by GHW(k) the class of CQs of generalized hypertreewidth at most k, for k ≥ 1.
As mentioned above, we look for an approximation of a CQ q in GHW(k). A formalization of
this notion was ﬁrst introduced in [4], based on the following partial order vq over the set of
CQs in GHW(k): if q0, q00 ∈ GHW(k), then q0 vq q00 iﬀ over every database D the symmetric
diﬀerence between q(D) and q00(D) is contained in the symmetric diﬀerence between q(D)
and q0(D). Intuitively, this states that q00 is a better GHW(k)-approximation of q than q0.
The GHW(k)-approximations of q then correspond to maximal elements with respect to
vq among a distinguished class of CQs in GHW(k). Three notions of approximation were
introduced in [4], by imposing diﬀerent “reasonable” conditions on such a class. These are:
Underapproximations: In this case we look for approximations in the set of CQs q0 in
GHW(k) that are contained in q, i.e., q0 ⊆ q. This ensures that the evaluation of such
approximations always produce correct (but not necessarily complete) answers to q. A
GHW(k)-underapproximation of q is then a CQ q0 amongst these CQs that is maximal
with respect to the partial order deﬁned by vq. Noticeably, the latter coincides with being
maximal with respect to the containment partial order ⊆ among the CQs in GHW(k)
that are contained in q; i.e., no other CQ in such a set strictly contains q0.
Overapproximations: This is the dual notion of underapproximations, in which we look
for minimal elements in the class of CQs q0 in GHW(k) that contain q, i.e., q ⊆ q0. Hence,
GHW(k)-overapproximations produce complete (but not necessarily correct) answers to q.
Symmetric diﬀerence approximations: While underapproximations must be contained
in the original query, and overapproximations must contain it, symmetric diﬀerence
approximations do not impose any constraint on approximations with respect to the
partial order ⊆. Thus, a symmetric diﬀerence GHW(k)-approximation of q – or simply

P. Barceló, M. Romero, and T. Zeume

7:3

GHW(k)-∆-approximation from now on – is a maximal CQ in GHW(k) with respect to
the partial order vq.
The approximations presented above provide “qualitative” guarantees for evaluation, as
they are as close as possible to q among all CQs in GHW(k) of a certain kind. In particular,
underand 
overapproximations are dual notions which provide lower and upper bounds for
the exact evaluation of a CQ, while ∆-approximations can give us useful information when
the quality of the result of the underand 
overapproximations is poor. Then, in order to
develop a robust theory of bounded hypertreewidth static approximations for CQs, it is
necessary to have a good understanding of all three notions.

The notion of underapproximation is by now well-understood [5]. Indeed, it is known
that for each k ≥ 1 the GHW(k)-underapproximations have good properties that justify their
application: (a) they always exist, and (b) evaluating all GHW(k)-underapproximations of a
CQ q over a database D is ﬁxed-parameter tractable with the size of q as parameter. This is
an improvement over general CQ evaluation for which the latter is believed not to hold [26].
The notions of GHW(k)-overapproximations and GHW(k)-∆-approximations, while already 
introduced in [4], are much less understood. No general tools have been identiﬁed so
far for studying the decidability of basic problems such as:

Existence: Does CQ q have a GHW(k)-overapproximation (or GHW(k)-∆-approximation)?
Identiﬁcation: Is q0 a GHW(k)-overapproximation (or GHW(k)-∆-approximation) of q?
Evaluation: Given a CQ q, a database D, and a tuple ¯a in D, is it the case that ¯a ∈ q0(D),
for some GHW(k)-overapproximation (resp., GHW(k)-∆-approximation) q0 of q?

Partial results were obtained in [4], but based on ad-hoc tools. It has also been observed
that some CQs have no GHW(k)-overapproximations (in contrast to underapproximations,
that always exist), which was seen as a negative result.

Contributions. We develop tools for the study of overapproximations and ∆-approximations.
While we mainly focus on the former, we provide a detailed account of how our techniques
can be extended to deal with the latter. In the context of GHW(k)-overapproximations,
we apply our tools to pinpoint the complexity of evaluation and identiﬁcation, and make
progress in the problem of existence. We also study when overapproximations do not exist
and suggest how this can be alleviated. Our contributions are as follows:
1. Link to existential pebble games. We establish a link between GHW(k)-overapproximations 
and existential pebble games [22]. Such games have been used to show that CQs
of bounded width can be evaluated eﬃciently [11, 9]. Using the fact that the existence
of winning conditions in the existential pebble game can be checked in PTIME [9], we
show that identiﬁcation and evaluation for GHW(k)-overapproximations are tractable
problems.

2. A more liberal notion of overapproximation. We observe that non-existence of overapproximations 
is due to the fact that in some cases overapproximations require expressing
conjunctions of inﬁnitely many atoms. By relaxing our notion, we get that each CQ
q has a (potentially inﬁnite) GHW(k)-overapproximation q0. This q0 is unique (up to
equivalence). Further, it can be evaluated eﬃciently – in spite of being potentially inﬁnite
– by checking a winning condition for the existential k-pebble game on q and D.

3. Existence of overapproximations. It is still useful to check if a CQ q has a ﬁnite GHW(k)-
overapproximation q0, and compute it if possible. This might allow us to optimize q0
before evaluating it. There is also a diﬀerence in complexity, as existential pebble game
techniques are PTIME-complete in general [21], and thus inherently sequential, while
evaluation of CQs in GHW(k) is highly parallelizable (Gottlob et al. [17]).

ICDT 2018

7:4

A More General Theory of Static Approximations for Conjunctive Queries

Table 1 Summary of results on underand 
overapproximations of bounded generalized hypertreewidth.
 The complexity of identiﬁcation coincides with that of evaluation in both cases. New
results are marked with (∗). All remaining results follow from [4, 5].

GHW(k)-underapp.
GHW(k)-overapp.

Existence? Unique?
not always

always

not always

always

Evaluation Existence check

NP-hard
PTIME∗

N/A
For k = 1:

2Exptime∗
PTIME∗ on binary schemas

For k > 1: Open

By exploiting automata techniques, we show that checking if a CQ q has a (ﬁnite) GHW(1)-
overapproximation q0 is in 2Exptime. Also, when such q0 exists it can be computed
in 3Exptime. This is important since GHW(1) coincides with the well-known class of
acyclic CQs [27]. If the arity of the schema is ﬁxed, these bounds drop to Exptime and
2Exptime, respectively. Also, we look at the case of binary schemas, such as the ones used
in graph databases [3] and description logics [2]. In this case, GHW(1)-overapproximations
can be computed eﬃciently via a greedy algorithm. This is optimal, as over ternary
schemas we prove an exponential lower bound for the size of GHW(1)-overapproximations.
We do not know if the existence problem is decidable for k > 1. However, we show that
it can be recast as an unexplored boundedness condition for the existential pebble game.
Understanding the decidability boundary for such conditions is often diﬃcult [25, 7].

Table 1 shows a summary of these results in comparison with underapproximations.

Our contributions for GHW(k)-∆-approximations are as follows. As a preliminary step, we
show that GHW(k)-under and GHW(k)-overapproximations are particular cases of GHW(k)-
∆-approximations, but not vice versa. Afterwards, as for GHW(k)-overapproximations, we
provide a link between GHW(k)-∆-overapproximations and the existential pebble game, and
use it to characterize when a CQ q has at least one GHW(k)-∆-approximation that is neither
a GHW(k)-underapproximation nor a GHW(k)-overapproximation (a so-called incomparable
GHW(k)-∆-approximation). This allows us to show that the identiﬁcation problem for
such ∆-approximations is coNP-complete. As for the problem of checking for the existence
of incomparable GHW(k)-∆-approximations, we extend our automata techniques to prove
that it is in 2Exptime for k = 1 (and in Exptime for ﬁxed-arity schemas). In case such
a GHW(1)-∆-approximation exists, we can evaluate it using a ﬁxed-parameter tractable
algorithm. We also provide results on existence and evaluation of inﬁnite incomparable
GHW(1)-∆-approximations.

Organization. Section 2 contains preliminaries. Basic properties of overapproximations are
presented in Section 3, while the existence of overapproximations is studied in Section 4. In
Section 5 we deal with ∆-approximations, and conclude in Section 6 with ﬁnal remarks.

Preliminaries

2
Relational databases and homomorphisms. A relational schema σ is a ﬁnite set of relation
symbols, each one of which has an arity n > 0. A database D over σ is a ﬁnite set of atoms of
the form R(¯a), where R is a relation symbol in σ of arity n and ¯a is an n-tuple of constants.
We often abuse notation and write D also for the set of elements in D.
Let D and D0 be databases over σ. A homomorphism from D to D0 is a mapping h
from D to D0 such that for every atom R(¯a) in D it is the case that R(h(¯a)) ∈ D0. If ¯a

P. Barceló, M. Romero, and T. Zeume

7:5

and ¯b are n-ary tuples (n ≥ 0) in D and D0, respectively, we write (D, ¯a) → (D0,¯b) if there
is a homomorphism h from D to D0 such that h(¯a) = ¯b. Checking if (D, ¯a) → (D0,¯b) is a
well-known NP-complete problem.

form ∃¯yV
of homomorphisms. Recall that the canonical database Dq of a CQ q = ∃¯yV

Conjunctive queries. A conjunctive query (CQ) over schema σ is a formula q of the
1≤i≤m Ri(¯xi), where each Ri(¯xi) is an atom over σ (1 ≤ i ≤ m). We often write
this as q(¯x) to denote that ¯x are the free variables of q, i.e., those that are not existentially
quantiﬁed in ¯y. If ¯x is empty, then q is Boolean. We deﬁne the evaluation of CQs in terms
1≤i≤m Ri(¯xi)
consists precisely of the atoms Ri(¯xi), for 1 ≤ i ≤ m. The result of q over D, denoted q(D),
is the set of all tuples ¯a such that (Dq, ¯x) → (D, ¯a). We often do not distinguish between a
CQ q and its canonical database Dq (i.e., we write q for Dq).

Evaluation and tractable classes of CQs. The evaluation problem for CQs is as follows:
Given a CQ q, a database D, and a tuple ¯a in D, is ¯a ∈ q(D)? Since this problem corresponds
to checking if (q, ¯x) → (D, ¯a), it is NP-complete [8]. This led to a ﬂurry of activity for ﬁnding
classes of CQs for which evaluation is tractable.

for working with non-Boolean queries. A tree decomposition of a CQ q = ∃¯yV

Here we deal with one of the most studied such classes: CQs of bounded generalized hypertreewidth 
[17], also called coverwidth [9]. We adopt the deﬁnition of [9] which is better suited
1≤i≤m Ri(¯xi)
is a pair (T, χ), where T is a tree and χ is a mapping that assigns a subset of the existentially
quantiﬁed variables in ¯y to each node t ∈ T, such that:
1. For each 1 ≤ i ≤ m, the variables in ¯xi ∩ ¯y are contained in χ(t), for some t ∈ T.
2. For each variable y in ¯y, the set of nodes t ∈ T for which y occurs in χ(t) is connected.
i∈I ¯xi
covers χ(t). The width of (T, χ) is the maximal width of the nodes of T. The generalized
hypertreewidth of q is the minimum width of its tree decompositions.
For a ﬁxed k ≥ 1, we denote by GHW(k) the class of CQs of generalized hypertreewidth

The width of node t in (T, χ) is the minimal size of an I ⊆ {1, . . . , m} such thatS

at most k. The CQs in GHW(k) can be evaluated in polynomial time; see [16].

Containment of CQs. A CQ q is contained in a CQ q0, written as q ⊆ q0, if q(D) ⊆ q0(D)
over every database D. Two CQs q and q0 are equivalent, denoted q ≡ q0, if q ⊆ q0 and q0 ⊆ q.
It is known that CQ containment and CQ evaluation are, essentially, the same problem

[8]. In particular, let q(¯x) and q0(¯x) be CQs. Then

q ⊆ q0 ⇐⇒ ¯x ∈ q0(Dq) ⇐⇒ (Dq0, ¯x) → (Dq, ¯x).

(1)

Thus, q ⊆ q0 and (q0, ¯x) → (q, ¯x) (i.e., (Dq0, ¯x) → (Dq, ¯x)) are used interchangeably.
Approximations of CQs. Fix k ≥ 1. Let q be a CQ. The approximations of q in GHW(k)
are deﬁned with respect to a partial order vq over the set of CQs in GHW(k). Formally, for
any two CQs q0, q00 in GHW(k) we have

q0 vq q00 ⇐⇒ ∆(q(D), q00(D)) ⊆ ∆(q(D), q0(D)), for every database D,

where ∆(A, B) denotes the symmetric diﬀerence between sets A and B. Thus, q0 vq q00,
whenever the “error” of q00 with respect to q – measured in terms of the symmetric diﬀerence
between q00(D) and q(D) – is contained in that of q0 for each database D. As usual, we write
q0 (cid:64)q q00 if q0 vq q00 but q00 6vq q0.

ICDT 2018

7:6

A More General Theory of Static Approximations for Conjunctive Queries

q:

Pb

Pb

q0:
Pb

Pb

Pa

Pa

Figure 1 The CQ q and its GHW(1)-overapproximation q0 from Example 2.

The approximations of q in GHW(k) always correspond to maximal elements, with respect
to the partial order vq, over a class of CQs in GHW(k) that satisﬁes certain conditions. The
following three basic notions of approximation were identiﬁed in [4]:

Underapproximations: Let q, q0 be CQs such that q0 ∈ GHW(k). Then q0 is a GHW(k)-
underapproximation of q if it is maximal, with respect to vq, among all CQs in GHW(k)
that are contained in q. That is, q0 ⊆ q, and there is no CQ q00 ∈ GHW(k) such that
q00 ⊆ q and q0 (cid:64)q q00. In particular, the GHW(k)-underapproximations of q produce
correct (but not necessarily complete) answers with respect to q over every database D.
Overapproximations: Analogously, q0 is a GHW(k)-overapproximation of q if it is maximal,
with respect to vq, among all CQs in GHW(k) that contain q. That is, the GHW(k)-
overapproximations of q produce complete (but not necessarily correct) answers with
respect to q over every database D.
∆-approximations: In this case we impose no restriction on q0. That is, q0 is a GHW(k)-
∆-approximation of q if it is maximal with respect to the partial order vq, i.e., there is
no q00 ∈ GHW(k) such that q0 (cid:64)q q00.
Underapproximations and overapproximations admit an equivalent, but arguably simpler,
characterization as maximal (resp., minimal) elements, with respect to the containment
partial order ⊆, among all CQs in GHW(k) that are contained in q (resp., contain q):
(cid:73) Proposition 1. [4] Fix k ≥ 1. Let q, q0 be CQs such that q0 ∈ GHW(k). Then:

q0 is a GHW(k)-underapproximation of q iﬀ q0 ⊆ q and there is no CQ q00 ∈ GHW(k) such
that q0 ⊂ q00 ⊆ q.
q0 is a GHW(k)-overapproximation of q iﬀ q ⊆ q0 and there is no CQ q00 ∈ GHW(k) such
that q ⊆ q00 ⊂ q0.
As mentioned before, GHW(k)-underapproximations are by now well-understood. We
concentrate on GHW(k)-overapproximations and GHW(k)-∆-approximations in this paper.
We start by studying the former.

3 Overapproximations
Recall that GHW(k)-overapproximations are minimal elements (in terms of ⊆) in the set of
CQs in GHW(k) that contain q. We show an example of a GHW(1)-approximation below:
(cid:73) Example 2. Figure 1 shows a CQ q and its GHW(1)-overapproximation q0. The schema
consists of binary symbols Pa and Pb. Dots represent variables, and an edge labeled Pa
between x and y represents the presence of atoms Pa(x, y) and Pa(y, x). (Same for Pb). All
variables are existentially quantiﬁed. Clearly, q ⊆ q0 (as q0 → q). In addition, there is no CQ
q00 ∈ GHW(1) such that q ⊆ q00 ⊂ q0. We provide an explanation for this later.
(cid:74)

We start in Section 3.1 by stating some basic properties on existence and uniqueness
of GHW(k)-overapproximations. Later in Section 3.2 we establish a connection between
GHW(k)-overapproximations and the existential pebble game, which allows us to show that

P. Barceló, M. Romero, and T. Zeume

7:7

q:

q0:

Figure 2 The CQ q is in GHW(2) but has no GHW(1)-overapproximations, while q0 is in GHW(3)

but has no GHW(‘)-overapproximations for ‘ ∈ {1, 2}.

both the identiﬁcation and evaluation problems for GHW(k)-overapproximations are tractable.
Finally, in Section 3.4 we look at the case when GHW(k)-overapproximations do not exist,
and suggest how this can be alleviated by allowing inﬁnite overapproximations.

3.1 Existence and uniqueness of overapproximations
As shown in [4], existence of overapproximations is not a general phenomenon. In fact, for
every k > 1 there is a Boolean CQ q in GHW(k) that has no GHW(1)-overapproximation.
Using the characterization given later in Theorem 21, we can strengthen this further:
(cid:73) Proposition 3. For each k > 1, there is a Boolean CQ q ∈ GHW(k) without GHW(‘)-
overapproximations for any 1 ≤ ‘ < k.

Figure 2 depicts examples of CQs in GHW(k), for k = 2 and k = 3, respectively, without

GHW(‘)-overapproximations for any 1 ≤ ‘ < k.

Interestingly, when GHW(k)-overapproximations do exist, they are unique (up to equival-
ence). This follows since, in this case, GHW(k)-overapproximations are not only the minimal
elements, but also the lower bounds of the set of CQs in GHW(k) that contain q:
(cid:73) Proposition 4. Let q, q0 be CQs such that q0 ∈ GHW(k). The following are equivalent:
1. q0 is a GHW(k)-overapproximation of q.
2. (i) q ⊆ q0, and (ii) for every CQ q00 ∈ GHW(k), it is the case that q ⊆ q00 implies q0 ⊆ q00.
Proof. We only prove the nontrivial direction (1) ⇒ (2). By contradiction, suppose that
there is a CQ q00 ∈ GHW(k) such that q ⊆ q00 but q0 6⊆ q00. Note that we can assume that
q0 and q00 have the same free variables ¯x; otherwise we can rename them accordingly. Let
(q0 ∧ q00) be the conjunction of q0 and q00, i.e., the CQ which is obtained by ﬁrst renaming
each existentially quantiﬁed variable in q0 and q00 with a diﬀerent fresh variable, and then
taking the conjunction of the atoms in q0 and q00. The tuple of free variables of (q0 ∧ q00) is
¯x. Observe that (q0 ∧ q00) is in GHW(k). Also, by the deﬁnition of (q0 ∧ q00) we have that
q ⊆ (q0 ∧ q00) ⊆ q0. But q0 is a GHW(k)-overapproximation of q, and thus q0 ⊆ (q0 ∧ q00). On
the other hand, we have that (q0 ∧ q00) ⊆ q00, and then q0 ⊆ q00. This is a contradiction. (cid:74)

As a corollary, we immediately obtain the following:

(cid:73) Corollary 5. If a CQ q has GHW(k)-overapproximations q1 and q2, then q1 ≡ q2.

The previous results show the stark diﬀerence between GHW(k)-overapproximations and
GHW(k)-underapproximations: GHW(k)-overapproximations do not necessarily exist, but
when they do they are unique; GHW(k)-underapproximations always exist but there can be
exponentially many incomparable ones [5].

ICDT 2018

7:8

A More General Theory of Static Approximations for Conjunctive Queries

3.2 A link with the existential pebble game
We characterize GHW(k)-overapproximations in terms of the existential pebble game. We
use a version of such a game, known as existential cover game, that is tailored for CQs of
bounded generalized hypertreewidth [9]. Let k ≥ 1. The existential k-cover game is played
by Spoiler and Duplicator on pairs (D, ¯a) and (D0,¯b), where D and D0 are databases and ¯a
and ¯b are n-ary (n ≥ 0) tuples over D and D0, respectively. The game proceeds in rounds.
In each round, Spoiler places (resp., removes) a pebble on (resp., from) an element of D, and
Duplicator responds by placing (resp., removing) its corresponding pebble on an element of
(resp., from) D0. The number of pebbles is not bounded, but Spoiler is constrained as follows:
At any round p of the game, if c1, . . . , c‘ (‘ ≤ p) are the elements marked by Spoiler’s pebbles
in D, there must be a set of at most k atoms in D that contain all such elements (this is why
the game is called k-cover, as pebbled elements are covered by no more than k atoms).

of Duplicator in D0, then(cid:0)(c1, . . . , c‘, ¯a), (d1, . . . , d‘,¯b)(cid:1) is a partial homomorphism from D

Duplicator wins if she has a winning strategy, i.e., she can indeﬁnitely continue playing the
game in such a way that after each round, if c1, . . . , c‘ are the elements that are marked by
Spoiler’s pebbles in D and d1, . . . , d‘ are the elements marked by the corresponding pebbles
to D0. That is, for every atom R(¯c) ∈ D, where each element c of ¯c appears in (c1, . . . , c‘, ¯a),
it is the case that R( ¯d) ∈ D0, where ¯d is the tuple obtained from ¯c by replacing each element c
of ¯c by its corresponding element d in (d1, . . . , d‘,¯b). We write (D, ¯a) →k (D0,¯b) if Duplicator
has a winning strategy.
Notice that →k “approximates” → as follows: → ⊂ ··· ⊂ →k+1 ⊂ →k ⊂ ··· ⊂→1.
These approximations are convenient complexity-wise: Checking whether (D, ¯a) → (D0,¯b) is
NP-complete, but (D, ¯a) →k (D0,¯b) can be solved eﬃciently.
(cid:73) Proposition 6. [9] Fix k ≥ 1. Checking whether (D, ¯a) →k (D0,¯b) is in polynomial time.
Moreover, there is a connection between →k and the evaluation of CQs in GHW(k) that

we heavily exploit in our work:
(cid:73) Proposition 7. [9] Fix k ≥ 1. Then (D, ¯a) →k (D0,¯b) iﬀ for each CQ q(¯x) in GHW(k) we
have that if (q, ¯x) → (D, ¯a) then (q, ¯x) → (D0,¯b).

In particular, if q(¯x) ∈ GHW(k) then for every D and ¯a:
¯a ∈ q(D) ⇐⇒ (q, ¯x) → (D, ¯a) ⇐⇒ (q, ¯x) →k (D, ¯a).

(2)
That is, the “approximation” of → provided by →k is suﬃcient for evaluating CQs in GHW(k).
Together with Proposition 6, this proves that CQs in GHW(k) can be evaluated eﬃciently.

The characterization. Existential cover games can be applied to obtain a semantic characterization 
of GHW(k)-overapproximations:
(cid:73) Theorem 8. Fix k ≥ 1. Let q, q0 be CQs with q0 ∈ GHW(k). Then q0(¯x) is the GHW(k)-
overapproximation of q(¯x) iﬀ (q0, ¯x) →k (q, ¯x) and (q, ¯x) →k (q0, ¯x).
Proof. Assume that q0(¯x) is the GHW(k)-overapproximation of q(¯x). Then (q0, ¯x) → (q, ¯x),
and thus (q0, ¯x) →k (q, ¯x) since →⊂→k. We prove now that (q, ¯x) →k (q0, ¯x). From
Proposition 7, we need to prove that if q00(¯x) is a CQ in GHW(k) such that (q00, ¯x) → (q, ¯x),
then also (q00, ¯x) → (q0, ¯x). This follows directly from Proposition 4.
Assume now that (q0, ¯x) →k (q, ¯x) and (q, ¯x) →k (q0, ¯x). Since q0 ∈ GHW(k), we have that
q ⊆ q0 by Equation (2). From Proposition 7, if q ⊆ q00 and q00 ∈ GHW(k) then q0 ⊆ q00, i.e.,
there is no q00 in GHW(k) such that q ⊆ q00 ⊂ q0. Hence q0 is a GHW(k)-overapproximation. (cid:74)

P. Barceló, M. Romero, and T. Zeume

7:9

(cid:73) Example 9. (Example 2 cont.) It is now easy to see that the CQ q0 in Figure 1 is a
GHW(1)-overapproximation of q. In fact, since q0 → q, we only need to show that q →1 q0.
(cid:74)
The latter is simple and left to the reader.

Next we show that this characterization allows us to show that the identiﬁcation and

evaluation problems for GHW(k)-overapproximations can be solved in polynomial time.

3.3 Identiﬁcation and evaluation of GHW(k)-overapproximations
A direct corollary of Proposition 6 and Theorem 8 is that the identiﬁcation problem for
GHW(k)-overapproximations is in polynomial time:
(cid:73) Corollary 10. Fix k ≥ 1. Given CQs q, q0 such that q0 ∈ GHW(k), checking if q0 is the
GHW(k)-overapproximation of q can be solved in polynomial time.

This corresponds to a promise version of the problem, as it is given to us that q0 is in

fact in GHW(k). Checking the latter is NP-complete for every ﬁxed k ≥ 2 [18, 14].
Assume now that we are given the promise that q has a GHW(k)-overapproximation q0
(but q0 itself is not given). How hard is it to evaluate q0 over a database D? We could try to
compute q0, but so far we have no techniques to do that. Notably, we can use existential
cover games to show that GHW(k)-overapproximations can be evaluated eﬃciently, without
even computing them. This is based on the next result, which states that evaluating q0 over
D boils down to checking (q, ¯x) →k (D, ¯a) for the tuples ¯a over D.
(cid:73) Theorem 11. Fix k ≥ 1. Let q(¯x) be a CQ with a GHW(k)-overapproximation q0(¯x). Then
for every D and ¯a:

¯a ∈ q0(D) ⇐⇒ (q0, ¯x) → (D, ¯a) ⇐⇒ (q, ¯x) →k (D, ¯a).

Proof. Assume ﬁrst that (q, ¯x) →k (D, ¯a). Since q0 is a GHW(k)-overapproximation of q, we
have that (q0, ¯x) → (q, ¯x). Since winning strategies for Duplicator compose and →⊂→k then,
(q0, ¯x) →k (D, ¯a). But q0 ∈ GHW(k), and thus (q0, ¯x) → (D, ¯a) from Equation (2). Assume
now that (q0, ¯x) → (D, ¯a). From Theorem 8, we have that (q, ¯x) →k (q0, ¯x). By composition
and →⊂→k, it follows that (q, ¯x) →k (D, ¯a) holds.
(cid:74)

As a corollary to Theorem 11 and Proposition 6 we obtain:

(cid:73) Corollary 12. Fix k ≥ 1. Checking if ¯a ∈ q0(D), given a CQ q that has a GHW(k)-
overapproximation q0, a database D, and a tuple ¯a in D, can be solved in polynomial time by
checking if (q, ¯x) →k (D, ¯a). Moreover, this can be done without even computing q0.

3.4 More liberal GHW(k)-overapproximations
CQs may not have GHW(k)-overapproximations, for some k ≥ 1. We observe in this
section that this anomaly can be solved by extending the language of queries over which
overapproximations are to be found.

An inﬁnite CQ is as a ﬁnite one, save that now the number of atoms is countably inﬁnite.
We assume that there are ﬁnitely many free variables in an inﬁnite CQ. The evaluation of an
inﬁnite CQ q(¯x) over a database D is deﬁned analogously to the evaluation of a ﬁnite one.
Similarly, the generalized hypertreewidth of an inﬁnite CQ is deﬁned as in the ﬁnite case,
but now tree decompositions can be inﬁnite. We write GHW(k)∞ for the class of all CQs,
ﬁnite and inﬁnite ones, of generalized hypertreewidth at most k. The next result states a
crucial relationship between the existential k-cover game and the class GHW(k)∞:

ICDT 2018

7:10

A More General Theory of Static Approximations for Conjunctive Queries

(cid:73) Lemma 13. Fix k ≥ 1. For every CQ q there is a q0 in GHW(k)∞ such that for every
database D and tuple ¯a of constants in D:

¯a ∈ q0(D) ⇐⇒ (q0, ¯x) → (D, ¯a) ⇐⇒ (q, ¯x) →k (D, ¯a).

This holds even for countably inﬁnite databases D.

The proof of this result follows from techniques in [22]. The basic idea is that q0 has an
(inﬁnite) generalized hypertree decomposition of width k that represents all possible moves
of Spoiler in the existential k-cover game played from q.

Since we now deal with inﬁnite CQs and databases, we cannot apply Proposition 7 directly
in our analysis of GHW(k)∞-overapproximations. Instead, we use the following suitable
reformulation of it, which we obtain by inspection of its proof:
(cid:73) Proposition 14. Fix k ≥ 1. Consider countably inﬁnite databases D and D0. Then
(D, ¯a) →k (D0,¯b) iﬀ for each CQ q(¯x) in GHW(k)∞, if (q, ¯x) → (D, ¯a) then (q, ¯x) → (D0,¯b).

GHW(k)∞-overapproximations. We expand the notion of overapproximation by allowing
inﬁnite CQs. Let q0 ∈ GHW(k)∞. Then q0 is a GHW(k)∞-overapproximation of CQ q, if q ⊆ q0
and there is no q00 ∈ GHW(k)∞ such that q ⊆ q00 ⊂ q0. (Here, ⊆ is still deﬁned with respect
to ﬁnite databases only). In GHW(k)∞, we can provide each CQ q an overapproximation:
(cid:73) Theorem 15. Fix k ≥ 1. For every CQ q there is a CQ in GHW(k)∞ that is a GHW(k)∞-
overapproximation of q.
Proof. We prove that q0, as given in Lemma 13, is a GHW(k)∞-overapproximation of q.
Notice that (q0, ¯x) → (q, ¯x) (by choosing (D, ¯a) as (q, ¯x) in Lemma 13). Therefore, q ⊆ q0
since this direction of Equation (1) continues to hold for countably inﬁnite CQs. Observe
now that (q, ¯x) →k (q0, ¯x) (by choosing (D, ¯a) as (q0, ¯x) in Lemma 13). Proposition 14 tells
us that for every q00(¯x) in GHW(k)∞, if (q00, ¯x) → (q, ¯x) then (q00, ¯x) → (q0, ¯x). But then
q ⊆ q00 implies that q0 ⊆ q00, since Equation (1) continues to hold if q (but not necessarily q0)
(cid:74)
is ﬁnite. Thus, q0 is a GHW(k)∞-overapproximation of q.

Despite the non-computable nature of GHW(k)∞-overapproximations, we get from Proposition 
6 and the proof of Theorem 15 that they can be evaluated eﬃciently:
(cid:73) Corollary 16. Fix k ≥ 1. Checking whether ¯a ∈ q0(D), given a CQ q with GHW(k)∞-
overapproximation q0, a database D, and a tuple ¯a in D, boils down to checking if (q, ¯x) →k
(D, ¯a), and thus it can be solved in polynomial time.

4 Deciding existence of GHW(k)-overapproximations
CQs always have GHW(k)∞-overapproximations, but not necessarily ﬁnite ones. Here we
study when a CQ q has a ﬁnite overapproximation. We start with the case k = 1, which we
show to be decidable in 2Exptime (we do not know if this is optimal). For k > 1 we leave
the decidability open, but provide some explanation about where the diﬃculty lies.

4.1 The acyclic case
We start with the case of GHW(1)-overapproximations. Recall that GHW(1) is an important
class, as it consists precisely of the well-known acyclic CQs. Our main result is the following:

P. Barceló, M. Romero, and T. Zeume

7:11

(cid:73) Theorem 17. There is a 2Exptime algorithm that checks if a CQ q has a GHW(1)-
overapproximation and, if one exists, it computes one in triple-exponential time.

If the arity of the schema is ﬁxed, there is an Exptime algorithm that does this and

computes a GHW(1)-overapproximation of q in double-exponential time.

We sketch the proof for nonﬁxed arities. From a CQ q we build a two-way alternating
tree automaton [10], or 2ATA, Aq, such that the language L(Aq) of trees accepted by Aq is
nonempty iﬀ q has a GHW(1)-overapproximation. Intuitively, Aq accepts those trees that
encode a GHW(1)-overapproximation q0 of q. Formally:
(cid:73) Proposition 18. There exists a double-exponential time algorithm that takes as input a
CQ q and returns a 2ATA Aq with exponentially many states, such that q has a GHW(1)-
overapproximation iﬀ L(Aq) 6= ∅. Furthermore, from every tree T in L(Aq) one can construct
in polynomial time a GHW(1)-overapproximation of q.

Proof sketch. For simplicity we assume that q is Boolean. Before describing the construction
of Aq, we explain how input trees for Aq encode CQs in GHW(1). To this end let q0 be a CQ
in GHW(1) and (Tq0, χ) a tree decomposition of q0. The CQ q0 can have unbounded many
variables. Yet, in each node of Tq0 at most r variables appear, where r is the maximum arity
of an atom in q. Thus, by reusing variables, (Tq0, χ) can be encoded by using 2r variables in
such a way that it can then be decoded, i.e. a variable name ui is used in two neighboring
nodes v and v0 of the encoding iﬀ the corresponding variables of the tree decomposition also
occur in neighboring nodes. The encoding Enc(Tq0, χ) of (Tq0, χ) is a tree labeled by (a) the
variables {u1, . . . , u2r} as described, and (b) the atoms of q0 covered by those variables.
The 2ATA Aq checks that the CQ q0 encoded by T 0 = Enc(Tq0, χ) is a GHW(1)-
overapproximation of q. From Theorem 8, we need to check: (1) q0 →1 q, and (2) q →1 q0.
The 2ATA Aq will be deﬁned as the intersection of 2ATAs A1 and A2, that check conditions
(1) and (2), respectively. Condition (1) is equivalent to q0 → q (since q0 ∈ GHW(1)). A
2ATA A1 can guess and verify a homomorphism from q0 to q. In particular, A1 requires no
alternation and has at most exponentially many states.
We now sketch how the automaton A2 works. First, q →1 q0 can be restated as Duplicator
having a compact winning strategy [9] as follows. The set of variables appearing in an atom
of q constitute a 1-union of q. Then q →1 q0 iﬀ there is a non-empty family F of partial
homomorphisms from q to q0 such that: (a) the domain of each f ∈ F is a 1-union of q, and
(b) if U and U0 are 1-unions of q, then each f ∈ F with domain U can be extended to U0,
i.e., there is f0 ∈ F with domain U0 such that f(x) = f0(x) for every x ∈ U ∩ U0.

The 2ATA A2 assumes an annotation of T 0 = Enc(Tq0, χ) that encodes the intended
strategy F. This annotation labels each node t0 of T 0 by the set of partial mappings from q
to q0 whose domain is a 1-union of q, and whose range is contained in the variables from
{u1, . . . , u2r} labeling t0. It can be easily checked from the labelings of T 0 if each mapping in
this annotation is a partial homomorphism. To check condition (2), the 2ATA A2 makes a
universal transition for each pair (U, U0) of 1-unions and partial mapping g with domain U
annotating a node t0 of T 0. Then it checks the existence of a node t0 in T 0 that is annotated
with a mapping g0 that extends g to U0. The latter means that, for each x ∈ U ∩ U0, both
g(x) and g0(x) are the same variable of q0, that is, g(x) and g(x0) are connected occurrences of
the same variable in {u1, . . . , u2r}. Thus to check the consistency of g and g0, the automaton
can store the variables in {g(x) | x ∈ U ∩ U0}, and check that these are present in the label
of each node guessed before reaching t0. As this is a polynomial amount of information, A2
(cid:74)
can be implemented using exponentially many states.

ICDT 2018

7:12

A More General Theory of Static Approximations for Conjunctive Queries

q3:

x1
3

x1
2

x1
1

x2
3

x2
2

x2
1

x0

q0
3:

y111
3

y112
3

y121
3

y122
3

y211
3

y212
3

y221
3

y222
3

y11
2

y12
2

y21
2

y22
2

y1
1

y2
1

y0

Figure 3 Illustration of the CQs q3 and q0

two atoms in the query; e.g., {y0, y1

1, y2

1} represents atoms R(y0, y1

3 from Proposition 20. Each triple of variables represents

1, y2

1) and R(y0, y2

1, y1

1) in q0
3.

It is easy to see how Theorem 17 follows from Proposition 18. Checking if a CQ q has a
GHW(1)-overapproximation amounts to checking if L(Aq) 6= ∅. The latter can be done in
exponential time in the number of states of Aq [10], and thus in double-exponential time in
the size of q. If L(Aq) 6= ∅, one can construct a tree T ∈ L(Aq) in double-exponential time
in the size of Aq, and thus in triple-exponential time in the size of q. From T one then gets
in polynomial time (i.e., in 3EXPTIME in the size of q) a GHW(1)-overapproximation of q.

The case of binary schemas. For schemas of arity two the existence and computation
of GHW(1)-overapproximations can be solved in polynomial time. This is of practical
importance since data models such as graph databases [3] and description logic ABoxes [2]
can be represented using schemas of this kind. Note that in this context GHW(1) coincides
with the class of CQs of treewidth one [11]. Then:
(cid:73) Theorem 19. There is a Ptime algorithm that checks if a CQ q over a schema of maximum
arity two has a GHW(1)-overapproximation q0, and computes such a q0 if it exists.

The proof of this result can be found in the appendix.

Size of overapproximations. Over binary schemas GHW(1)-overapproximations are of
polynomial size. This is optimal as over schemas of arity three there is an exponential lower
bound for the size of GHW(1)-overapproximations:
(cid:73) Proposition 20. There is a schema σ with a single ternary relation symbol and a family
(qn)n≥1 of Boolean CQs over σ, such that (1) qn is of size O(n), and (2) the size of every
GHW(1)-overapproximation of qn is Ω(2n).
Proof. The CQ qn contains the atoms R(x0, x1
i+1)
i+1, x2
i , x1
i+1), for each 1 ≤ i ≤ n−1 and j ∈ {1, 2}. Consider now the CQ q0
n with the
and R(xj
1), as well as R(yw|w|, yw1|w|+1, yw2|w|+1) and R(yw|w|, yw2|w|+1, yw1|w|+1),
1), R(y0, y2
atoms R(y0, y1
for each word w over {1, 2} of length 1 ≤ |w| ≤ n − 1. Figure 3 depicts q3 and q0
3.
n → qn deﬁned
n indeed is an overapproximation of qn. The mapping h : q0
as h(y0) = x0 and h(ywj|w|+1) = xj|w|+1, for each word w over {1, 2} of length 0 ≤ |w| ≤ n − 1
and j ∈ {1, 2}, is a homomorphism. On the other hand, a compact winning strategy for
Duplicator can be obtained by basically “inverting” the homomorphism h.

i+1, x1
1, y2
The query q0

1), as well as R(xj

1), R(x0, x2

i , x2

1, x2

1, x1

1, y1

The size of q0

n is Ω(2n). We claim that q0

n is the smallest GHW(1)-overapproximation of qn,
which proves the proposition. A straightforward case-by-case analysis shows that q0
n is a core
[8, 19]. Now assume, towards a contradiction, that q0 is a GHW(1)-overapproximation of qn
n ≡ q0 by Corollary 5. Composing the homomorphisms
with fewer atoms than q0
h1 : q0
n to a proper subset of the
(cid:74)
atoms of q0

n yields a homomorphism from q0

n → q0 and h2 : q0 → q0

n. This is a contradiction to q0

n being a core.

n. Then q0

P. Barceló, M. Romero, and T. Zeume

7:13

We write (D, ¯a) →c

4.2 Beyond acyclicity
Theorem 8 characterizes when a CQ has a GHW(k)-overapproximation. We provide an
alternative characterization in terms of a boundedness condition for the existential cover
game. This helps understanding where lies the diﬃculty of determining the decidability
status of the problem of existence of GHW(k)-overapproximations, for k > 1.
k (D,¯b), for k ≥ 1 and c ≥ 0, if Duplicator has a winning strategy
in the ﬁrst c rounds of the existential k-cover game on (D, ¯a) and (D,¯b). The next result
establishes that a CQ q has a GHW(k)-overapproximation iﬀ the existential k-cover game
played from q is “bounded”, i.e., if there is a constant c ≥ 0 that bounds the number of
rounds this game needs to be played in order to determine if Duplicator wins.
(cid:73) Theorem 21. Fix k ≥ 1. The CQ q(¯x) has a GHW(k)-overapproximation iﬀ there is an
integer c ≥ 0 such that (q, ¯x) →k (D, ¯a) iﬀ (q, ¯x) →c
k (D, ¯a), for each database D and ¯a ∈ D.
Boundedness conditions are a diﬃcult area of study, with a delicate decidability boundary.
For least ﬁxed point logic (LFP), undecidability results for boundedness abound with the
exception of a few restricted fragments [25, 7]. The existence of winning Duplicator strategies
in existential pebble games is expressible in LFP [23], yet results from this context are not
directly applicable to determine the decidability status of the condition from Theorem 21.

Beyond under and overapproximations: ∆-approximations

5
We now turn to GHW(k)-∆-approximations. Recall that a GHW(k)-∆-approximation of q
is a maximal element in GHW(k) with respect to the order vq, where q0 vq q00, for CQs
q0, q00 ∈ GHW(k), iﬀ ∆(q(D), q00(D)) ⊆ ∆(q(D), q0(D)) for all databases D. It is not surprising
that GHW(k)-∆-approximations generalize overand 
underapproximations.
(cid:73) Proposition 22. Fix k ≥ 1. Let q, q0 be CQs such that q0 ∈ GHW(k). If q ⊆ q0 (resp., q0 ⊆
q), then q0 is a GHW(k)-∆-approximation of q if and only if q0 is a GHW(k)-overapproximation
(resp., GHW(k)-underapproximation) of q.

Thus, we concentrate on the study of GHW(k)-∆-approximations that are neither GHW(k)-
undernor 
GHW(k)-overapproximations. Evaluating such ∆-approximations can give us
useful information when the quality of GHW(k)-underand 
GHW(k)-overapproximations
is poor. But, are there GHW(k)-∆-approximations that are neither GHW(k)-undernor

GHW(k)-overapproximations? In the rest of this section, we settle this question and study
complexity questions associated with such GHW(k)-∆-approximations.

5.1 Incomparable GHW(k)-∆-approximations
Let q be a CQ. In view of Proposition 22, the GHW(k)-∆-approximations q0 of q that are
neither GHW(k)-overapproximations nor GHW(k)-underapproximations must be incomparable
with q in terms of containment; i.e., both q 6⊆ q0 and q0 6⊆ q must hold. Incomparable GHW(k)-
∆-approximations do not necessarily exist, even when approximating in the set of inﬁnite CQs
GHW(k)∞. A trivial example is any CQ q in GHW(k), as its only GHW(k)-∆-approximation
(up to equivalence) is q itself. The following characterization will help us to ﬁnd CQs with
incomparable GHW(k)-∆-approximations.
(cid:73) Theorem 23. Fix k ≥ 1. Let q(¯x), q0(¯x) be CQs such that q0 ∈ GHW(k). Then q0 is an
incomparable GHW(k)-∆-approximation of q iﬀ (q, ¯x) →k (q0, ¯x), and both q 6⊆ q0 and q0 6⊆ q.

ICDT 2018

7:14

A More General Theory of Static Approximations for Conjunctive Queries

Proof. Suppose that q0 is an incomparable GHW(k)-∆-approximation of q and assume,
by contradiction, that (q, ¯x) 6→k (q0, ¯x). By Proposition 7, there is a q00 ∈ GHW(k) such
that q ⊆ q00 and q0
6⊆ q00. We show that q0 (cid:64)q (q00 ∧ q0), which is a contradiction as
(q00 ∧ q0) ∈ GHW(k). Assume that ¯a ∈ ∆(q(D), (q00 ∧ q0)(D)), for some D and ¯a ∈ D. If
¯a 6∈ q(D), then ¯a ∈ (q00 ∧ q0)(D) ⊆ q0(D), and thus, ¯a ∈ ∆(q(D), q0(D)). Otherwise, ¯a ∈ q(D)
and ¯a 6∈ (q00 ∧ q0)(D). Since q ⊆ q00, we have ¯a 6∈ q0(D), and then ¯a ∈ ∆(q(D), q0(D)). Hence
q0 vq (q00 ∧ q0). Now, since q0 6⊆ q00, there is a database D∗ such that q0(D∗) 6⊆ q00(D∗), i.e.,
¯a ∈ q0(D∗) but ¯a 6∈ q00(D∗), for some tuple ¯a in D∗. In particular ¯a ∈ ∆(q(D∗), q0(D∗)) and
¯a 6∈ ∆(q(D∗), (q00 ∧ q0)(D∗)), and thus (q00 ∧ q0) 6vq q0. For the converse, we need the following:
(cid:73) Lemma. Fix k ≥ 1. Let q(¯x), q0(¯x), q00(¯x) be CQs such that q00 ∈ GHW(k). Suppose that
(q, ¯x) →k (q0, ¯x). Then (q00, ¯x) → (q0 ∧ q, ¯x) implies (q00, ¯x) → (q0, ¯x).

Assume that q (cid:42) q0, q0 (cid:42) q, and (q, ¯x) →k (q0, ¯x). By contradiction, suppose that there
is a CQ q00 ∈ GHW(k) such that q0 (cid:64)q q00. We show that q0 ≡ q00, which is a contradiction.
Recall that D(q0∧q) denotes the canonical database of (q0 ∧ q). Clearly, ¯x ∈ q(D(q0∧q))
and ¯x ∈ q0(D(q0∧q)).
It follows that ¯x 6∈ ∆(q(D(q0∧q)), q0(D(q0∧q))), and by hypothesis,
¯x 6∈ ∆(q(D(q0∧q)), q00(D(q0∧q))). Hence, ¯x ∈ q00(D(q0∧q)). By the lemma above, we have
(q00, ¯x) → (q0, ¯x), that is, q0 ⊆ q00. For q00 ⊆ q0, note that ¯x 6∈ q(Dq00); otherwise, q00 ⊆ q
would hold, implying that q0 ⊆ q, which is a contradiction. Since ¯x ∈ q00(Dq00), we have
¯x ∈ ∆(q(Dq00), q00(Dq00)). This implies that ¯x ∈ ∆(q(Dq00), q0(Dq00)), and then ¯x ∈ q0(Dq00),
i.e., q00 ⊆ q0. Hence, q0 ≡ q00.
(cid:74)

(cid:73) Example 24. Consider again the CQ q = ∃x∃y∃z(E(x, y) ∧ E(y, z) ∧ E(z, x)) from
Figure 2. Then q has a unique GHW(1)-underapproximation q0 = ∃xE(x, x). As mentioned
in Section 3.1, q has no GHW(1)-overapproximations. Does q have incomparable GHW(1)-∆-
approximations? By applying Theorem 23, we can give a positive answer to this question:
the CQ q00 = ∃x∃y(E(x, y) ∧ E(y, x)) is an incomparable GHW(1)-∆-approximation of q. (cid:74)
Therefore, as Example 24 shows, incomparable GHW(k)-∆-approximations may exist for
some CQs. However, in contrast with overapproximations, they are not unique in general:
(cid:73) Proposition 25. There is a CQ with inﬁnitely many (non-equivalent) incomparable
GHW(1)-∆-approximations. In fact, this holds for the CQ q in Figure 1.

Identiﬁcation, existence and evaluation. A direct consequence of Theorem 23 is that
the identiﬁcation problem, i.e., checking if q0 ∈ GHW(k) is an incomparable GHW(k)-∆-
approximation of a CQ q, is in coNP. It suﬃces to check that q 6⊆ q0 and q0 6⊆ q – which are
in coNP – and (q, ¯x) →k (q0, ¯x) – which is in Ptime from Proposition 6. This is optimal:
(cid:73) Proposition 26. Fix k ≥ 1. Checking if a given CQ q0 ∈ GHW(k) is an incomparable
GHW(k)-∆-approximation of a given CQ q, is coNP-complete.

As in the case of GHW(k)-overapproximations, we do not know how to check existence of
incomparable GHW(k)-∆-approximations, for k > 1. Nevertheless, for k = 1 we can exploit
the automata techniques developed in Section 4 and obtain an analogous decidability result:
(cid:73) Proposition 27. There is a 2Exptime algorithm that checks if a CQ q has a incomparable
GHW(1)-∆-approximation and, if one exists, it computes one in triple exponential time. The
bounds become Exptime and 2Exptime, respectively, if the arity of the schema is ﬁxed.

P. Barceló, M. Romero, and T. Zeume

7:15

q:

P1

P2

q∗:
q0:

P1

P2

P1

P2

P1

. . .

Figure 4 The CQ q ∈ GHW(2) from Example 29. The CQ (q∗ ∧ q0) is an incomparable GHW(1)∞-

∆-approximation of q. On the other hand, q has no incomparable GHW(1)-∆-approximations.

Now we study evaluation. Recall that, unlike GHW(k)-overapproximations, incomparable
GHW(k)-∆-approximations of a CQ q are not unique. In fact, there can be inﬁnitely many
(see Proposition 25). Thus, it is reasonable to start by trying to evaluate at least one of
them. It would be desirable, in addition, if the one we evaluate depends only on q (i.e., it
is independent of the underlying database D). Proposition 27 allows us to do so as follows.
Given a CQ q with at least one incomparable GHW(1)-∆-approximation, we can compute in
3Exptime one such an incomparable GHW(1)-∆-approximation q0. We can then evaluate q0
over a database D in time O(|D| · |q0|) [27], which is O(|D| · f(|q|)), for f a triple-exponential
function. This means that the evaluation of such a q0 over D is ﬁxed-parameter tractable,
i.e., it can be solved by an algorithm that depends polynomially on the size of the large
database D, but more loosely on the size of the small CQ q. (This is a desirable property for
evaluation, which does not hold in general for the class of all CQs [26]). Formally, then:
(cid:73) Theorem 28. There is a ﬁxed-parameter tractable algorithm that, given a CQ q that
has incomparable GHW(1)-∆-approximations, a database D, and a tuple ¯a, checks whether
¯a ∈ q0(D), for some incomparable GHW(1)-∆-approximation q0 of q that depends only on q.
It is worth noticing that the automata techniques are essential for proving this result,
and thus for evaluating incomparable GHW(1)-∆-approximations. This is in stark contrast
with GHW(k)-overapproximations, which can be evaluated in polynomial time by simply
checking if (q, ¯x) →k (D, ¯a). It is not at all clear whether such techniques can be extended
to allow for the eﬃcient evaluation of incomparable GHW(k)-∆-approximations.

The inﬁnite case. All the previous results continue to apply for the class of inﬁnite CQs in
GHW(k)∞. The following example shows that, as in the case of GHW(k)-overapproximations,
considering GHW(k)∞ helps us to obtain better incomparable GHW(k)-∆-approximations.
(cid:73) Example 29. Consider the CQ q that asks for the existence of the two oriented paths P1
and P2, as shown in Figure 4. Theorem 23 can be used to show that q has no incomparable
GHW(1)-∆-approximation. However, q has an incomparable GHW(1)∞-∆-approximation.
In fact, let q∗ be the GHW(1)∞-overapproximation of q which is depicted in Figure 4 (a
P1-labeled edge represents a copy of the oriented path P1, similarly for P2). Also, let q0 be
an arbitrary CQ in GHW(1) which is incomparable with q (one such a q0 is shown in Figure
4). Applying the extension of Theorem 23 to the class GHW(k)∞, we can prove that (q∗ ∧ q0)
(cid:74)
is an incomparable GHW(1)∞-∆-approximation of q.
Example 29 also illustrates the following fact: If there is a CQ q0 ∈ GHW(k) which is
incomparable with q, then (q∗ ∧ q0) is an incomparable GHW(k)∞-∆-approximation of q,
where q∗ is the GHW(k)∞-overapproximation of q. Given a database D and a tuple ¯a in
D, we can check whether ¯a belongs to the evaluation of such a ∆-approximation (q∗ ∧ q0)
over D as follows: First we compute q0, and then we check both (q, ¯x) →k (D, ¯a) and
¯a ∈ q0(D). In other words, we evaluate (q∗ ∧ q0) via the existential k-cover game, as for the

ICDT 2018

7:16

A More General Theory of Static Approximations for Conjunctive Queries

GHW(k)∞-overapproximation, and then use the incomparable CQ q0 to ﬁlter out some tuples
in the answer. Interestingly, we can easily exploit automata techniques and compute such an
incomparable q0 (in case one exists). Thus we have the following:
(cid:73) Theorem 30. Fix k ≥ 1. There is a ﬁxed-parameter tractable algorithm that given a CQ q
that has an incomparable q0 in GHW(k), a database D, and a tuple ¯a in D, decides whether
¯a ∈ ˆq(D), for some incomparable GHW(k)∞-∆-approximation ˆq of q that depends only on q.

Final Remarks

6
Several problems remain open: is the existence of GHW(k)-overapproximations decidable
for k > 1? What is the precise complexity of checking for the existence of GHW(1)-
overapproximations? In particular, can we improve the 2Exptime upper bound from
Theorem 17? What is an optimal upper bound on the size of GHW(1)-overapproximations?
In the future we plan to study how our notions of approximation can be combined with
other techniques to obtain quantitative guarantees. One possibility is to exploit semantic
information about the data – e.g., in the form of integrity constraints – in order to ensure
that certain bounds on the size of the result of the approximation hold. Another possibility is
to try to obtain probabilistic guarantees for approximations based on reasonable assumptions
about the distribution of the data.

1

2

3
4

5

6

References
Serge Abiteboul, Richard Hull, and Victor Vianu. Foundations of Databases. AddisonWesley,
 1995.
Franz Baader, Diego Calvanese, Deborah L. McGuinness, Daniele Nardi, and Peter F.
Patel-Schneider, editors. The Description Logic Handbook: Theory, Implementation, and
Applications. Cambridge University Press, 2003.
Pablo Barceló. Querying graph databases. In PODS, pages 175–188, 2013.
Pablo Barceló, Leonid Libkin, and Miguel Romero. Eﬃcient approximations of conjunctive
queries. In PODS, pages 249–260, 2012.
Pablo Barceló, Leonid Libkin, and Miguel Romero. Eﬃcient approximations of conjunctive
queries. SIAM J. Comput., 43(3):1085–1130, 2014.
Pablo Barceló, Miguel Romero, and Moshe Y. Vardi. Semantic acyclicity on graph databases.
 SIAM J. Comput., 45(4):1339–1376, 2016.

7 Achim Blumensath, Martin Otto, and Mark Weyer. Decidability results for the boundedness

problem. Logical Methods in Computer Science, 10(3), 2014.

8 Ashok K. Chandra and Philip M. Merlin. Optimal implementation of conjunctive queries

in relational data bases. In STOC, pages 77–90, 1977.

10

9 Hubie Chen and Víctor Dalmau. Beyond hypertree width: Decomposition methods without

decompositions. In CP, pages 167–181, 2005.
Stavros S. Cosmadakis, Haim Gaifman, Paris C. Kanellakis, and Moshe Y. Vardi. Decidable
optimization problems for database logic programs (preliminary report). In STOC, pages
477–490, 1988.

11 Víctor Dalmau, Phokion G. Kolaitis, and Moshe Y. Vardi. Constraint satisfaction, bounded

treewidth, and ﬁnite-variable logics. In CP, pages 310–326, 2002.

12 Wenfei Fan, Jianzhong Li, Shuai Ma, Nan Tang, Yinghui Wu, and Yunpeng Wu. Graph

pattern matching: From intractable to polynomial time. PVLDB, 3(1):264–275, 2010.

13 Robert Fink and Dan Olteanu. On the optimal approximation of queries using tractable

propositional languages. In ICDT, pages 174–185, 2011.

25 Martin Otto. The boundedness problem for monadic universal ﬁrst-order logic. In LICS,

26 Christos H. Papadimitriou and Mihalis Yannakakis. On the complexity of database queries.

J. Comput. Syst. Sci., 58(3):407–427, 1999.

27 Mihalis Yannakakis. Algorithms for acyclic database schemes.

113–119, 2009.

pages 37–48, 2006.

1981.

P. Barceló, M. Romero, and T. Zeume

7:17

14 Wolfgang Fischl, Georg Gottlob, and Reinhard Pichler. General and fractional hypertree
decompositions: Hard and easy cases. CoRR, abs/1611.01090, 2016. arXiv:1611.01090.
15 Minos Garofalakis and Phillip Gibbon. Approximate query processing: taming the terabytes.
 In VLDB, page 725, 2001.

16 Georg Gottlob, Gianluigi Greco, Nicola Leone, and Francesco Scarcello. Hypertree decom-

positions: Questions and answers. In PODS, pages 57–74, 2016.

17 Georg Gottlob, Nicola Leone, and Francesco Scarcello. Hypertree decompositions and

tractable queries. J. Comput. Syst. Sci., 64(3):579–627, 2002.

18 Georg Gottlob, Zoltán Miklós, and Thomas Schwentick. Generalized hypertree decomposi-

tions: NP-hardness and tractable variants. J. ACM, 56(6), 2009.
Pavol Hell and Jaroslav Nesetril. The core of a graph. Discrete Mathematics, 109(1-3):117–
126, 1992.

19

20 Yannis Ioannidis. Approximations in database systems. In ICDT, pages 16–30, 2003.
21

Phokion G. Kolaitis and Jonathan Panttaja. On the complexity of existential pebble games.
In CSL, pages 314–329, 2003.
Phokion G. Kolaitis and Moshe Y. Vardi. On the expressive power of datalog: Tools and
a case study. J. Comput. Syst. Sci., 51(1):110–134, 1995.
Phokion G. Kolaitis and Moshe Y. Vardi. Conjunctive-query containment and constraint
satisfaction. J. Comput. Syst. Sci., 61(2):302–332, 2000.

22

23

24 Qing Liu. Approximate query processing.

In Encyclopedia of Database Systems, pages

In VLDB, pages 82–94,

ICDT 2018

7:18

A More General Theory of Static Approximations for Conjunctive Queries

Appendix

7
(cid:73) Theorem 19 (restated). There is a Ptime algorithm that checks if a CQ q over a schema
of maximum arity two has a GHW(1)-overapproximation q0, and computes such q0 if it exists.
The idea is to show that if a CQ q has a GHW(1)-overapproximation then it can be
extracted from q in a simple way: it is a subquery of q or it is a subquery of a CQ qu#qv
constructed from q and two distinguished variables u, v in q. The algorithm then greedily
searches through the subqueries of q and qu#qv to ﬁnd an overapproximation of q.

We need to introduce some notation. The Gaifman graph of a CQ q, denoted by G(q), is
the undirected graph whose set of nodes is the set of variables of q and where there is an
edge {z, z0} whenever z and z0 are distinct variables that appear together in an atom of q.
The existential Gaifman graph of q, denoted by G∃(q), is the subgraph of G(q) induced by
the existentially quantiﬁed variables of q.
(cid:73) Claim 31. Let q(¯x) be a CQ. Then q ∈ GHW(1) iﬀ G∃(q) is an acyclic graph.

A CQ q is connected if G(q) is connected. Using Theorem 8, we have the following:

(cid:73) Lemma 32. Let q be a connected CQ. If q has a GHW(1)-overapproximation, then it has
one that is connected.

We start by proving Theorem 19 for Boolean CQs; thus, until stated otherwise, we assume
all CQs to be Boolean. First we show Theorem 19 for connected CQs, then we extend it to
the non-connected case and ﬁnally prove the general non-Boolean statement.

7.1 The connected case
We start with the following technical lemma. Let q be a CQ. We say that u and v are
adjacent if {u, v} is an edge in G(q), that is, if u and v appear together in an atom of q.
(cid:73) Lemma 33. Let q be a connected CQ in GHW(1). If q is a core then for all variables u
and v in q there is at most one endomorphism of q that maps u to v.
Proof. Assume that there are two distinct endomorphisms h1 and h2 with h1(u) = h2(u) = v.
Recall that, since q is a core, h1 and h2 are isomorphisms. We root G(q) at u. Let x be a
variable in q with h1(x) 6= h2(x) whose distance to u is minimal in G(q). Then there is a
unique y such that h1(x) = h2(y). We claim that x and y have the same parent in G(q). Let
z be the parent of x. Since h1 is an isomorphism, h1(x) and h1(z), and therefore also h2(y)
and h2(z), are adjacent in G(q). Thus, also y and z are adjacent. However, y cannot be the
parent of z since h1 and h2 agree on all variables above z in G(q). Therefore z is the parent
of y.
Construct a new endomorphism h that maps variables w in the subtree G(q) rooted at y
to h2(w), and all other variables w0 to h1(w0). Then h is an endomorphism, but not injective
as both x and y are mapped to h1(x) = h2(y). This is a contradiction to q being a core, and
(cid:74)
therefore there are no two distinct endomorphisms h1 and h2 mapping u to v.
Suppose q ∈ GHW(1) is connected and u, v are adjacent. If we remove all the atoms that
mention u, v, we obtain two connected CQs, one containing u and the other containing v.
We denote these CQs by tq

Suppose q ∈ GHW(1) is a connected core. If an endomorphism h of q maps u to v where
u and v are adjacent, then it is the case that h(u) = v and h(v) = u, and h swaps the

u and tq

v, respectively.

P. Barceló, M. Romero, and T. Zeume

7:19

u and tq

subqueries tq
v. We call such an h a swapping endomorphism for u and v. Note that
Lemma 33 tells us that if such a swapping homomorphism for u and v exists, then it is
unique.
(cid:73) Lemma 34. Let q be a connected core in GHW(1). Then q has at most one endomorphism
besides the identity mapping. If this endomorphism exists, it is a swapping endomorphism.
Proof. Let P = x0, x1, ...xm be a simple path of maximal length in G(q). For each endomorphism 
h of q, the path P 0 = y1 . . . ym where yi = h(xi) is a simple path of the same
length (as q is a core and therefore h is an isomorphism). Furthermore, P and P 0 share a
vertex. Indeed, if this not the case, since q is connected, one can pick w in P and w0 in P 0
such that w and w0 are connected by a path P 00 vertex-disjoint (except for w and w0) from
P and P 0, and construct a longer path than P.
Now, if |P| is even, then its middle vertex u = xm/2 is in the intersection of P and P 0 (as
otherwise q would contain a path longer than P). But then h(u) = u and then h must be
the identity mapping by Lemma 33.
If |P| is odd, then u = xbm/2c and v = xdm/2e are in the intersection of P and P 0 (again,
as otherwise q would contain a path longer than P). If h(u) = u, again we have that h is
the identity. Otherwise, if h(u) = v, since u and v are adjacent, we have that h must be the
(cid:74)
swapping endomorphism for u and v.
For a CQ q and variables u, v in q the CQ qu#qv is deﬁned as follows. Denote by q \ v the
CQ obtained from q by removing all atoms that contain v. Let qu be the query constructed
from q \ v by replacing each variable z by a fresh variable zu. Similarly let qv be the CQ
where each variable z in q\ u is replaced by a fresh variable zv. The CQ qu#qv is the union of
qu and qv plus all atoms R(uu, vv) when R(u, v) is an atom in q. Likewise for atoms R(v, u).
By construction, we have the following:
(cid:73) Claim 35. For each CQ q and variables u, v in q, it is the case that qu#qv → q.

Before immersing into the proof of Theorem 19 for connected CQs, we need some notation
and properties of GHW(1)-overapproximations. Suppose ˆq, ˆq0 are CQs and X, Y are set of
variables from ˆq and ˆq0, respectively. We denote by (ˆq, X) →1 (ˆq0, Y ) the fact that Duplicator
has a winning strategy in the existential 1-cover game on ˆq and ˆq0 with the property that
whenever Spoiler places a pebble on an element of X in ˆq, then Duplicator responds with
some element of Y in ˆq0. Checking whether (ˆq, X) →1 (ˆq0, Y ) can still be done in polynomial
time.
(cid:73) Lemma 36. Suppose q is a CQ and suppose q0 is a connected core that is a GHW(1)-
overapproximation of q. Then we have the following:

If the only endomorphism of q0 is the identity, then any homomorphism from q0 to q is
injective. In particular, q0 is a subquery of q.
If q0 has a swapping endomorphism for u0 and v0, then for any homomorphism h from q0
to q, we have that

(q,{h(u0), h(v0)}) →1 (q0,{u0, v0}), and
h is “almost” injective, more precisely, h(z0) 6= h(z00) for all pairs of variables z0, z00,
except maybe for z0 6= u0 in tq0
v0. In particular, q0 is a subquery of
qh(u0)#qh(v0).

u0 and z0 6= v0 in tq0

Proof. Suppose the only endomorphism of q0 is the identity and towards a contradiction,
suppose there is a non-injective homomorphism h from q0 to q. Then we have h(z0) = h(z00),

ICDT 2018

7:20

A More General Theory of Static Approximations for Conjunctive Queries

for distinct variables z0, z00 in q0. Using the fact that q →1 q0, it is easy to see that there is a
Duplicator winning strategy on q0 and q0 such that z00 is a possible response of Duplicator
when Spoiler starts playing on z0. Since q0 ∈ GHW(1), we can deﬁne an endomorphism g of
q0 that maps z0 to z00. Then g is an endomorphism diﬀerent from the identity, which is a
contradiction.

Suppose now that q0 has a swapping endomorphism for u0 and v0, and let h be a
homomorphism from q0 to q. First, assume by contradiction that Duplicator’s strategy
witnessing q →1 q0 is such that for h(u0) (the case for h(v0) is analogous), Duplicator
responds with z0 6∈ {u0, v0}. By composing h with this strategy, and using the fact that
q0 ∈ GHW(1), it follows that there is an endomorphism g of q0 that maps u0 to z0. This
endomorphism is diﬀerent from the identity and from the swapping endomorphism for u0 and
v0, which contradicts Lemma 34. Finally, suppose towards a contradiction that h(z0) = h(z00),
where z0 6= z00 and z0 = u0 and z00 is in tq0
v0 (the other case is analogous). Again by composing
h with the strategy witnessing q →1 q0 and the fact that q0 ∈ GHW(1), it is easy to derive
an endomorphism of q0 that is neither the identity nor the swapping endomorphism for u0
(cid:74)
and v0.
As a corollary of Lemma 36 and Lemma 34, we have that whenever q0 is a connected
core, and it is a GHW(1)-overapproximation of q, then q0 is a subquery of q or a subquery of
qu#qv, for some variables u, v in q.
Proof of Theorem 19 for connected, Boolean CQs. We assume that the given CQ q is
connected. The algorithm ﬁrst checks whether a subquery of q is a GHW(1)-overapproximation.
This is Step 1. In Step 2, the algorithm checks whether a subquery of qu#qv is a GHW(1)-
overapproximation, for some u and v in q. If neither step succeed then the algorithm rejects.
Step 1 is as follows:
1. Set q0 to be q.
2. While qi /∈ GHW(1), search for an atom e such that qi →1 qi \ e. If there is no such atom
3. If qi ∈ GHW(1), for some i, then accept and output qi.

then continue with Step 2. Otherwise, set qi+1 to be qi \ e.

For Step 2, let P be an enumeration of the pairs (u, v) such that u, v are adjacent in q

and q →1 qu#qv. Step 2 is as follows:
1. Let (u, v) be the ﬁrst pair in P.
2. Set q0 to be qu#qv.
3. While qi /∈ GHW(1), search for an atom e that does not mention uu and vv simultaneously
such that (qi,{uu, vv}) →1 (qi \ e,{uu, vv}). If there is no such atom, let (u, v) be the
next pair in P and repeat from item 2. Otherwise, set qi+1 to be qi \ e.

4. If qi ∈ GHW(1), for some i, then accept and output qi.

Notice that the described algorithm can be implemented in polynomial time. Below we

argue that it is correct.

Suppose ﬁrst that the algorithm, on input q, accepts with output q∗. By construction 
q∗ ∈ GHW(1). Assume ﬁrst that the algorithm accepts in the m-th iteration of Step 1, and
thus q∗ = qm. By construction, for each 0 ≤ i < m, we have that qi →1 qi+1 and qi+1 →1 qi.
In particular, q →1 q∗ and q∗ →1 q, and thus q∗ is a GHW(1)-overapproximation of q.
Suppose now that the algorithm accepts in Step 2 for a pair (u, v) ∈ P, in the m-th iteration.
Again we have that qi →1 qi+1 and qi+1 →1 qi, for each 0 ≤ i < m, and thus qu#qv →1 q∗
and q∗ →1 qu#qv. Since (u, v) ∈ P, it follows that q →1 qu#qv, and then q →1 q∗. Using the
fact that qu#qv → q, we have that q∗ →1 q. Hence, q∗ is a GHW(1)-overapproximation of q.

P. Barceló, M. Romero, and T. Zeume

7:21

It remains to show that if q has a GHW(1)-overapproximation q0 then the algorithm
accepts. Since q is connected, we can assume that q0 also is. Moreover, we can assume
w.l.o.g. that q0 is a core. By Lemma 34, we have two cases: (1) the only endomorphism of
q0 is the identity, or (2) q0 has two endomorphisms, namely, the identity and the swapping
endomorphism for some variables u0 and v0.

First suppose case (1) applies. We show that the algorithm accepts in Step 1. By
deﬁnition, qi →1 qi+1 and qi+1 →1 qi (actually qi+1 → qi), for each 0 ≤ i ≤ m, where m is
the number of iteration in Step 1. It follows that q0 = q →1 qm and qm →1 q. Since the
relation →1 composes, q0 is a GHW(1)-overapproximation of qm and by using Lemma 36, q0
is a subquery of qm. Now for the sake of contradiction assume that the algorithm does not
accept in Step 1. Then qm 6∈ GHW(1) and there is no edge e in qm such that qm →1 qm \ e.
Since q0 is GHW(1)-overapproximation of qm, we have that qm →1 q0 and, since q0 ∈ GHW(1),
q0 is a proper subquery of qm. It follows that there is an edge e in qm such that qm →1 qm \ e,
which is a contradiction.

Suppose case (2) holds.

In this case the algorithm accepts in Step 2. Let h be a
homomorphism from q0 to q, and let u = h(u0) and v = h(v0). By Lemma 36, u 6= v and
then u and v are adjacent. Also, by Lemma 36, q0 is a subquery of qu#qv. Since q →1 q0, it
follows that q →1 qu#qv, and then (u, v) ∈ P. We claim that the algorithm accepts when
(u, v) is chosen from P. First, note that q0 is a GHW(1)-overapproximation of qm. Indeed,
by deﬁnition, qm → qu#qv, qu#qv → q (Claim 35), and q →1 q0. It follows that qm →1 q0.
On the other hand, we have that (q0, (u0, v0)) → (qu#qv, (uu, vv)) (q0 is a subquery of qu#qv)
and (qu#qv,{uu, vv}) →1 (qm,{uu, vv}).
It follows that (q0,{u0, v0}) →1 (qm,{uu, vv}),
which implies that (q0, (u0, v0)) → (qm, (uu, vv)) via a homomorphism g. Then q0 is a
GHW(1)-overapproximation of qm. By applying Lemma 36 to qm, q0 and g, we obtain that
(qm,{uu, vv}) →1 (q0,{u0, v0}), and g is “almost” injective. Observe that g(z0) 6= g(z00) for
all z0 6= u0 in tq0
v0, since {uu, vv} is a bridge of G(qm), that is, its removal
disconnect G(qm). We conclude that g is injective and then q0 is a subquery of qm.
Towards a contradiction, assume that the algorithm do not accept when (u, v) is chosen
from P. Then qm 6∈ GHW(1) and there is no edge e that does not mention both uu, vv such
that (qm,{uu, vv}) →1 (qm\e,{uu, vv}). Since (qm,{uu, vv}) →1 (q0,{u0, v0}), (q0, (u0, v0)) →
(qm, (uu, vv)) via the injective homomorphism g and q0 ∈ GHW(1), it follows that there is
an edge e that does not mention both uu, vv such that (qm,{uu, vv}) →1 (qm \ e,{uu, vv}).
(cid:74)
This is a contradiction.

u0 and z00 6= v0 in tq0

7.2 The unconnected case
Now we consider the non-connected case. A connected component of a CQ is a maximal
connected subquery. Given a CQ q with connected components q1, . . . , qm, the algorithm
proceeds as follows:
1. Start by simplifying q: Compute a minimal subset of CQs Q in {q1, . . . , qm} such that

for each 1 ≤ i ≤ m, there is a p ∈ Q with qi →1 p.

2. Check whether each p ∈ Q has a GHW(1)-overapproximation p0 using the algorithm

described for connected CQs. If this is the case then accept and outputV
suppose ﬁrst that the algorithm accepts and outputs q0 =V
p∈Q p0. Then q0 →V
We also have that q →1V
p∈Q p (by deﬁnition of Q), andV

Clearly, the algorithm can be implemented in polynomial time. For the correctness,
p∈Q p → q.
p∈Q p →1 q0. This implies that q0

is a GHW(1)-overapproximation of q.

p∈Q p0.

ICDT 2018

7:22

A More General Theory of Static Approximations for Conjunctive Queries

Suppose now that q has a GHW(1)-overapproximation q0. Since q →1 V
V
p∈Q p →1 q, it follows that q0 is also a GHW(1)-overapproximation of V
connected component of q0. Also, since q0 →V

p∈Q p and
p∈Q p. By the
minimality of Q, we have that p 6→1 ˆp, for each pair of distinct CQs p, ˆp ∈ Q. Let p be
a CQ in Q. Since p →1 q0 and p is connected, it follows that p →1 p∗, where p∗ is a
p∈Q p, there is p0 ∈ Q such that p∗ → p0.
In particular, p →1 p0. It follows that p0 = p, and then p∗ is a GHW(1)-overapproximation
of p. We conclude that each p ∈ Q has a GHW(1)-overpproximation, and thus the algorithm
accepts.

7.3 The non-Boolean case
Finally, we consider the general case that includes non-Boolean queries. Let q(¯x) be a CQ.
We denote by qB the Boolean CQ obtained from q(¯x) by existentially quantifying the free
variables ¯x. Recall that G(q) is the Gaifman graph of q, while G∃(q) denotes the restriction
of G(q) to the existentially quantiﬁed variables of q. Recall also that q(¯x) is connected if G(q)
is connected, and a connected component of q is a maximal connected subquery. If q(¯x) is
connected, q0(¯x) is a part of q if it is a maximal subquery of q with G∃(q0) connected.
Let q(¯x) be a CQ. Let q1 . . . , qm be the connected components of q. Let Cfree be the CQs
in {q1 . . . , qm} that contain a free variable from ¯x, and let C∃ be the rest of the CQs. The
algorithm proceeds as follows:
1. Simplify q(¯x): Compute a minimal subset of CQs Q in {q1, . . . , qm} such that Cfree ⊆ Q
2. Check whether each p ∈ Q has a GHW(1)-overapproximation p0. If this is the case then
p∈Q p0. To check if p ∈ Q has a GHW(1)-overapproximation, for a
p ∈ C∃, we simply apply the algorithm for the Boolean and connected case described
previously. In case p(¯z) ∈ Cfree ∩ Q, where ¯z are the free variables from ¯x present in p,
the algorithm does the following:
a. Simplify p(¯z): Compute a minimal subset S of the parts of p(¯z) such that for each
part p0(¯z) of p(¯z) there is a part p00(¯z) ∈ S such that (p0, ¯z) →1 (p00, ¯z).
b. Check whether each part p0(¯z) ∈ S has a GHW(1)-overapproximation p0

accept and outputV

and for each 1 ≤ i ≤ m, there is a p ∈ Q with qB

the case then accept and outputV

∗(¯z). If this is

i →1 pB.

p0∈S p0

∗(¯z).

It remains to explain how the algorithm checks the existence of GHW(1)-overapproximations 
for a part p0(¯z) of a connected CQ p(¯z). This is done by applying an adaptation of
the algorithm described for the connected and Boolean case. For p0(¯z) and two existentially
quantiﬁed variables u, v adjacent in G∃(p0), we deﬁne p0
v(¯z) as the CQ obtained from
p0(¯z) as follows: the free variables are ¯z and the atoms in p0
v(¯z) mentioning only variables
in ¯z are exactly those in p0(¯z). The CQ induced by the existentially quantiﬁed variables of
u#p0
p0
v, where p00 is the subquery of p0 induced by the existential
variables. Finally, if there is an atom in p0 mentioning a free variable and an existential
variable w, then the same atom appears in p0
v(¯z) but replacing w by its “copies”, that is,
by wu or wv, if w = u or w = v respectively, or by wu and wv, if w 6∈ {u, v}.

v(¯z) is the Boolean CQ p00

u#p0
u#p0

Observe that Lemma 3–5, Claim 35 and Lemma 36 hold for the non-Boolean case, when
we consider the adapted deﬁnition for qu#qv (exactly the same arguments apply). Using
this, we have that the algorithm developed for Boolean and connected CQs still works for
non-Boolean CQs p0(¯z) that are parts of connected CQs.

u#p00

u#p0

This ﬁnishes the proof of Theorem 19.

