Expressive Path Queries on Graphs with Data

Pablo Barcel´o1, Gaelle Fontaine1, and Anthony Widjaja Lin2,3

1 Dept. of Computer Science, University of Chile
2 Dept. of Computer Science, Oxford University

3 Academia Sinica, Taipei, Taiwan

Abstract. Graph data models have recently become popular owing to
their applications, e.g., in social networks, semantic web. Typical navigational 
query languages over graph databases — such as Conjunctive
Regular Path Queries (CRPQs) — cannot express relevant properties
of the interaction between the underlying data and the topology. Two
languages have been recently proposed to overcome this problem: walk
logic (WL) and regular expressions with memory (REM). In this paper,
we begin by investigating fundamental properties of WL and REM, i.e.,
complexity of evaluation problems and expressive power. We ﬁrst show
that the data complexity of WL is nonelementary, which rules out its
practicality. On the other hand, while REM has low data complexity,
we point out that many natural data/topology properties of graphs expressible 
in WL cannot be expressed in REM. To this end, we propose
register logic, an extension of REM, which we show to be able to express
many natural graph properties expressible in WL, while at the same
time preserving the elementariness of data complexity of REMs. It is
also incomparable in expressive power against WL.

1

Introduction

Graph databases have recently gained renewed interest due to applications, such
as the semantic web, social network analysis, crime detection networks, software 
bug detection, biological networks, and others (e.g., see [1] for a survey).
Despite the importance of querying graph databases, no general agreement has
been reached to date about the kind of features a practical query language for
graph databases should support and about what can be considered a reasonable
computational cost of query evaluation for the aforementioned applications.

Typical navigational query languages for graph databases — including the
conjunctive regular path queries [6] and its many extensions [4] — suﬀer from a
common drawback: they are well-suited for expressing relevant properties about
the underlying topology of a graph database, but not about how it interacts
with the data. This drawback is shared by common speciﬁcation languages for
), which are evaluated over a similar graph data model
veriﬁcation [5] (e.g. CTL
(a.k.a. transition systems). Examples of important queries that combine graph
data and topology, but cannot be expressed in usual navigational languages for
graph databases, include the following [7,11]: (Q1) Find pairs of people in a
social network connected by professional links restricted to people of the same

∗

K. McMillan, A. Middeldorp, and A. Voronkov (Eds.): LPAR-19, LNCS 8312, pp. 71–85, 2013.
c(cid:3) Springer-Verlag Berlin Heidelberg 2013

72

P. Barcel, G. Fontaine, and A.W. Lin

age. (Q2) Find pairs of cities x and y in a transportation system, such that y
can be reached from x using only services operated by the same company. In each
one of these queries, the connectivity between two nodes (i.e., the topology) is
constrained by the data (from an inﬁnite domain, e.g., N), in the sense that we
only consider paths in which all intermediate nodes satisfy a certain condition
(e.g. they are people of the same age).

Two languages, walk logic and regular expressions with memory, have recently
been proposed to overcome this problem. These languages aim at diﬀerent goals:

(a) Walk logic (WL) was proposed by Hellings et al.

[7] as a unifying
framework for understanding the expressive power of path queries over graph
databases. Its strength is on the expressiveness side. The underlying data model
of WL is that of (node or edge)-labeled directed graphs. In this context, WL can
be seen as a natural extension of FO with path quantiﬁcation, plus the ability to
check whether positions p and p(cid:4)
, respectively, have the same
data values. In their paper, they assume the restriction that each node carries a
distinct data value. However, as we shall see, this makes no diﬀerence in terms
of the results that we can obtain.

in paths π and π(cid:4)

(b) Regular expressions with memory (REMs) were proposed by Libkin and
Vrgoˇc [9] as a formalism for comparing data values along a single path, while
retaining a reasonable complexity for query evaluation. The strength of this
language is on the side of eﬃciency. The data model of the class of REMs is that
of edge-labeled directed graphs, in which each node is assigned a data value from
an inﬁnite domain. REMs deﬁne pairs of nodes in the graph database that are
linked by a path satisfying a given condition c. Each such condition c is deﬁned
in a formalism inspired by the class of register automata [8], allowing some data
values to be stored in the registers and then compared against other data values.
The evaluation problem for REMs is Pspace-complete (same than for FO over
relational databases), and can be solved in polynomial time in data complexity
[9], i.e., assuming queries to be ﬁxed.1 This shows that the language is, in fact,
well-behaved in terms of the complexity of query evaluation.

The aim of this paper is to investigate the expressiveness and complexity
of query evaluation for WL and the class of REMs with the hope of ﬁnding a
navigational query language for data graphs that strikes a good balance between
these two important aspects of query languages.

Contributions. We start by considering WL, which is known to be a powerful
formalism in terms of expressiveness. Little is known about the cost of query evaluation 
for this language, save for the decidability of the evaluation problem and
NP-hardness of its data complexity. Our ﬁrst main contribution is to pinpoint
the exact complexity of the evaluation problem for WL (and thus answering an
open problem from [7]): we prove that it is non-elementary, and that this holds
even in data complexity, which rules out the practicality of the language.

1 Recall that data complexity is a reasonable measure of complexity in the database

scenario [15], since queries are often much smaller than the underlying data.

Expressive Path Queries on Graphs with Data

73

We thus move to the class of REMs, which suﬀers from the opposite drawback:
Although the complexity of evaluation for queries in this class is reasonable, the
expressiveness of the language is too rudimentary for expressing some important
path properties due to its inability to (i) compare data values in diﬀerent paths
and (ii) express branching properties of the graph database. An example of an
interesting query that is not expressible as an REM is the following: (Q) Find
pairs of nodes x and y, such that there is a node z and a path π from x to y in
which each node is connected to z. Notice that this is the query that lies at the
basis of the queries (Q1) and (Q2) we presented before.

Our second contribution then is to identify a natural extension of this language,
 called register logic (RL), that closes REMs under Boolean combinations
and existential quantiﬁcation over nodes, paths and register assignments. The
latter allows the logic to express comparisons of data values appearing in diﬀerent 
paths, as well as branching properties of the data. This logic is incomparable
in expressive power to WL. Besides, many natural queries relating data and
topology in data graphs can be expressed in RL including: the query (Q), hamiltonicity,
 the existence of an Eulerian trail, bipartiteness, and complete graphs
with an even number of nodes. We then study the complexity of the problem of
query evaluation for RL, and show that it can be solved in elementary time (in
particular, that it is Expspace-complete). This is in contrast to WL, for which
even the data complexity is non-elementary. With respect to data complexity,
we prove that RL is Pspace-complete. We then identify a slight extension of its
existential-positive fragment, which is tractable (NLogspace) in data complexity 
and can express many queries of interest (including the query (Q)). The idea
behind this extension is that atomic REMs can be enriched with an existential
branching operator – in the style of the class of nested regular expressions [3] –
that increases expressiveness without aﬀecting the cost of evaluation.
Organization of the Paper. Section 2 deﬁnes our data model. In Section 3,
we brieﬂy recall the deﬁnition of walk logic and some basic results from [7]. In
Section 4, we prove that the data complexity of WL is nonelementary. Section
5 contains our results concerning register logic. We conclude in Section 6 with
future work.

2 The Data Model

We start with a deﬁnition of our data model: data graphs.

Deﬁnition 1 (Data graph). Let Σ be a ﬁnite alphabet. A data graph G over
Σ is a tuple (V, E, κ), where V is the ﬁnite set of nodes, E ⊆ V × Σ × V is
) ∈ E is to be
the set of directed edges labeled in Σ (that is, each triple (v, a, v(cid:4)
in G labeled a), and κ : V → D is a function
understood as an edge from v to v(cid:4)
that assigns a data value in D to each node in V .
This is the data model adopted by Libkin and Vrgoˇc [9] in their deﬁnition of
REMs. In the case of WL [7], the authors adopted graph databases as their data
model, i.e., data graphs G = (V, E, κ) such that κ is injective (i.e. each node

74

P. Barcel, G. Fontaine, and A.W. Lin

carries a diﬀerent data value). We shall adopt the general model of [9] since
none of our complexity results are aﬀected by the data model: upper bounds
hold for data graphs, while all lower bounds are proved in the more restrictive
setting of graph databases.

There is also the issue of node-labeled vs edge-labeled data graphs. Our data
model is edge-labeled, but the original one for WL is node-labeled [7]. We have
chosen to use the former because it is the standard in the literature [2]. Again,
this choice is inessential, since all the complexity results we present in the paper 
continue being true if the logics are interpreted over node-labeled graph
databases or data graphs (applying the expected modiﬁcations to the syntax).
Finally, in several of our examples we use logical formulas to express properties
of undirected graphs. In each such case we assume that an undirected graph H
is represented as a graph database G = (V, E, κ) over unary alphabet Σ = {a},
) ∈ E
where V is the set of nodes of H and E is a symmetric relation (i.e. (v, a, v(cid:4)
iﬀ (v(cid:4), a, v) ∈ E).

3 Walk Logic

WL is an elegant and powerful formalism for deﬁning properties of paths in
graph databases, that was originally proposed in [7] as a yardstick for measuring
the expressiveness of diﬀerent path logics.

The syntax of WL is deﬁned with respect to countably inﬁnite sets Π of path
variables (that we denote π, π1, π2, . . . ) and T (π), for each π ∈ Π, of position
variables of sort π. We assume that position variables of diﬀerent sort are diﬀerent.
 We denote position variables by t, t1, t2, . . . , and we write tπ when we need
to reinforce that position variable t is of sort π.

Deﬁnition 2 (Walk logic (WL)). The set of formulas of WL over ﬁnite alphabet 
Σ is deﬁned by the following grammar, where (i) a ∈ Σ, (ii) t, t1, t2
are position variables of any sort, (iii) π is a path variable, and (iv) tπ
2 are
1
position variables of the same sort π:

, tπ

φ, φ(cid:4)

:= Ea(tπ
1

2 ) | tπ
, tπ

1

< tπ
2

| t1 ∼ t2 | ¬φ | φ ∨ φ(cid:4) | ∃tφ | ∃πφ

As usual, WL formulas without free variables are called Boolean.

To deﬁne the semantics of WL we need to introduce some terminology. A path
(a.k.a. walk in [7]) in the data graph G = (V, E, κ) is a ﬁnite, nonempty sequence
ρ = v1a1v2 ··· vn−1an−1vn, such that (vi, ai, vi+1) ∈ E for each 1 ≤ i < n. The
set of positions of ρ is {1, . . . , n}, and vi is the node in position i of ρ, for
1 ≤ i ≤ n. The intuition behind the semantics of WL formulas is as follows.
Each path variable π is interpreted as a path ρ = v1a1v2 ··· vn−1an−1vn in the
data graph G, while each position variable t of sort π is interpreted as a position
1 ≤ i ≤ n in ρ (that is, position variables of sort π are interpreted as positions
in the path that interprets π). The atomic formula Ea(tπ
2 ) is true iﬀ π is
interpreted as path ρ = v1a1v2 ··· vn−1an−1vn, the position p2 that interprets t2
1

, tπ

Expressive Path Queries on Graphs with Data

75

< tπ

in ρ is the successor of the position p1 that interprets t1 (i.e. p2 = p1 + 1), and
node in position p1 is linked in ρ by an a-labeled edge to node in position p2 (that
is, ap1 = a). In the same way, tπ
2 holds iﬀ in the path ρ that interprets π the
1
position that interprets t1 is smaller than the one that interprets t2. Furthermore,
t1 ∼ t2 is the case iﬀ the data value carried by the node in the position assigned
to t1 is the same than the data value carried by the node in the position assigned
to t2 (possibly in diﬀerent paths). We formalize the semantics of WL below.
Let G = (V, E, κ) be a data graph and φ a WL formula. Assume that Sφ is
the set that consists of (i) all position variables tπ and path variables π such
that tπ is a free variable of φ, and (ii) all path variables π such that π is a free
variable of φ. Intuitively, Sφ deﬁnes the set of (both path and position) variables
that are relevant to deﬁne the semantics of φ over G. An assignment α for φ over
G is a mapping that associates a path ρ = v1a1v2 ··· vn−1an−1vn in G with each
path variable π ∈ Sφ, and a position 1 ≤ i ≤ n with each position variable of the
form tπ in Sφ (notice that this is well-deﬁned since π ∈ Sφ every time a position
variable of the form tπ is in Sφ). As usual, we denote by α[t → i] and α[π → ρ]
the assignments that are equal to α except that t is now assigned position i and
π the path ρ, respectively.
We say that G satisﬁes φ under α, denoted (G, α) |= φ, if one of the following

holds (we omit Boolean combinations which are standard):

that α(tπ

– φ = Ea(tπ
1

2 ) = α(tπ
< tπ

1 ) + 1 and a = aα(tπ

2 ), the path α(π) is v1a1v2 ··· vn−1an−1vn, and it is the case
, tπ
2 and α(tπ

– φ = tπ
– φ = (t1 ∼ t2), t1 is of sort π1, t2 is of sort π2, and κ(v1) = κ(v2), where vi is
1
– φ = ∃tπψ and there is a position i in α(π) such that (G, α[tπ → i]) |= ψ.
– φ = ∃πψ and there is a path ρ in G such that (G, α[π → ρ]) |= ψ.

the node in position α(ti) of α(πi), for i = 1, 2.

1 ) < α(tπ

2 ).

1 ).

Example 1. A simple example from [7]
that WL expresses
NP-complete properties is the following query that checks if a graph has a Hamiltonian 
path:
∃π

(cid:2)∀tπ

→ tπ

(cid:10)∼ tπ

shows

∀tπ

that

(cid:3)
.

2 ) ∧ ∀π(cid:4)∀tπ(cid:2)

1

∃tπ
2 (tπ(cid:2)

1

∼ tπ
2 )

(cid:10)= tπ

2

1

2 (tπ

1

1

In fact, this query expresses that there is a path π that does not repeat nodes
(because π satisﬁes ∀tπ
2 )), and every node belongs to such
path (because π satisﬁes ∀π(cid:4)∀tπ(cid:2)
2 ), and, thus, every node that occurs
in some path π(cid:4)
2

in the graph database also occurs in π).

→ tπ
(cid:10)= tπ
∃tπ
2 (tπ(cid:2)

(cid:10)∼ tπ
∼ tπ

2 (tπ

∀tπ

1

1

2

1

1

1

4 WL Evaluation Is Non-elementary in Data Complexity

In this section we pinpoint the precise complexity of query evaluation for WL.
It was proven in [7] that this problem is decidable. Although the precise complexity 
of this problem was left open in [7], one can prove that this is, in fact, a
non-elementary problem by an easy translation from the satisﬁability problem

76

P. Barcel, G. Fontaine, and A.W. Lin

for FO formulas – which is known to be non-elementary [13,14]. In databases,
however, one is often interested in a diﬀerent measure of complexity – called
data complexity [15] – that assumes the formula φ to be ﬁxed. This is a reasonable 
assumption since databases are usually much bigger than formulas. Often
in the setting of data complexity the cost of evaluating queries is much smaller
than in the general setting in which formulas are part of the input. The main
result of this section is that the data complexity of evaluating WL formulas is
nonelementary even over graph databases, which rules out its practicality.

Theorem 1. The evaluation problem for WL is non-elementary in data complexity.
 In particular, for each k ∈ Z>0, there is a ﬁnite alphabet Σ and a Boolean
formula φ over Σ, such that the problem Eval(WL,φ) of evaluating the WL formula 
φ is k-Expspace-hard. In addition, the latter holds even if the input is
restricted to the class of graph databases.
Proof (Sketch): We start by sketching the case k = 1 here, which provides
insightful technical details about the nature of the proof. There is a Turing
machine M such that the following problem is ExpSpace-hard: given a word
w of size n, is there an accepting run of M over w using at most 2cn cells? We
prove that there is a formula φ ∈ WL of size polynomial in the size of M such
that for all words w of size n, we can compute a graph Gw such that

Gw (cid:2) φ iﬀ there is an accepting run of M over w using ≤ 2cn cells.

(1)
The formula φ is of the form ∃πψ(π), where ψ is a formula that does not contain
any quantiﬁcation over path variables. Given a word w of size n, the label of the
path π in the graph Gw will encode an accepting run of M over the word w in
the following way. Suppose that in a conﬁguration C, the content of the tape is
the word a1 . . . a2cn , the head is scanning cell number j0 and the state is q0. The
conﬁguration C is encoded by the word eC deﬁned by
c(0)($, a0) . . . c(j0 − 1)($, aj0−1)c(j0)(q0, aj0 )c(j0 + 1)($, aj0+1) . . . c(2n)($, a2cn ),
where c(j) is the binary representation of the number j. The pair c(j)(qj , aj)
(where qj = q0 if j = j0 and qj = $ otherwise) is the description of cell number
j in C. A run C0C1 . . . is encoded as the word eC0eC1 . . . .

We think of a path π encoding a run as consisting of two parts: the ﬁrst part
contains the encoding eC0 of the initial conﬁguration and is a path through a
subgraph Iw of Gw, while the second part contains the encoding eC1eC2 . . . and
is a path through the subgraph Hw of Gw. If Q is the set of states of M and Γ
is the alphabet, we deﬁne Hw as the following graph

d1

x

0

1

0

1

. . .

0

1

y

d2
. . .

dl

z

Expressive Path Queries on Graphs with Data

77

where {dj : 1 ≤ j ≤ l} = (Q ∪ {$}) × Γ and the number of nodes with outgoing
edges with labels 0 and 1 is equal to cn. The label of a path π(cid:4)
from the “left-
most” node x to the “right-most” node z with only once occurrence of x is
exactly the description of a cell in a conﬁguration: it is the binary encoding of
a number ≤ 2cn followed by a pair of the form (q(cid:4), a). We can deﬁne a formula
φC ∈ WL such that for all paths π starting in x and ending in z,

Hw (cid:2) φC (π)

iﬀ the label of π is the encoding of a conﬁguration.

We do not give details; φC has to express that the ﬁrst number encoded in binary
is 0, that the last number is 2cn and that the encoding of the description of cell
number j is followed by the description of cell number j + 1. Using the formula
φC , we can deﬁne a formula φ1 such that for all paths π,

Hw (cid:2) φ1(π)

iﬀ the label of π is the encoding of an accepting run.

The formula φ1 has to ensure that if eCeC(cid:2) occurs in the label of π, then C and
C(cid:4)
are consecutive conﬁgurations according to M . Moreover, φ1 has to express
that eventually we reach the ﬁnal state. In order to express φC and φ1, we
use the ability of WL to check whether two positions correspond to the same
node. For example, in order to deﬁne φ1, since we need to compare consecutive
conﬁgurations eC and eC(cid:2), we need to be able to compare the content of a cell in
conﬁguration C and the content of that same cell in C(cid:4)
. In particular, we want
to be able to express whether two subpaths π(cid:4)
0 and π(cid:4)
1 of π starting in x and
ending in y correspond to the binary encoding of the same number. Since the
length of such subpaths depends on n, we cannot check node by node whether
the two subpaths are equal. However, it is suﬃcient to check that if tπ(cid:2)
0 and tπ(cid:2)
1
corresponds to the same node (tπ(cid:2)
1 ), then their successors also correpond
0 + 1 ∼ tπ(cid:2)
to the same node (tπ(cid:2)
1 + 1). Similarly, in the formula φC , we use
the operator ∼ in order to express that two subpaths correspond to the binary
encodings of numbers that are successors of each other.

∼ tπ(cid:2)

0

1

Similarly to the way we deﬁne the graph Hw, we can introduce a graph Iw

0

1

0

0
1

and a formula φ0(π) such that

Iw (cid:2) φ0(π)

iﬀ the label of π is the encoding eC0,

where C0 is the initial conﬁguration of the run of M over w. By adding an
“adequate edge” from Iw to Hw, we construct a graph Gw such that for all
paths π, Gw (cid:2) φ0(π) ∧ φ1(π) iﬀ the label of π is the encoding of an accepting
run over w. Hence, the formula φ := ∃π(φ0(π) ∧ φ1(π)) satisﬁes (1).

For the case where k > 1, the problem to adapt the above proof is that
we have to consider runs using a number of cells that is bound by a tower of
exponentials of height k. If k > 1, the binary representation of such a bound is
not polynomial. The trick is to represent such exponential towers by k-counters.
A 1-counter is the binary representation of a number. If k > 1, a k-counter
c is a word σ0l0 . . . σj0 lj0 , where lj is a (k − 1)-counter and σj ∈ {0, 1}. The

78

P. Barcel, G. Fontaine, and A.W. Lin

counter c represents the number r(c) =
exponentials of height k is represented by a k-counter of polynomial size.
We can show that there are a graph Fk and a formula χk(π) such that the
label of π is a k-counter iﬀ Fk (cid:2) χk(π). Using Fk and χk, we can then adapt the
above proof to the cases where k > 1.
2

σjr(σj ). In particular, a tower of

(cid:4)j0
j=0

As a corollary to the proof of Theorem 1, we obtain that data complexity is
non-elementary even for simple WL formulas that talk about a single path in a
graph database.

Corollary 1. The evaluation problem for WL over graph databases is nonelementary 
in data complexity, even if restricted to Boolean WL formulas of
the form ∃πψ, where ψ uses no path quantiﬁcation and contains no position
variable of sort diﬀerent that π.

5 Register Logic

We saw in the previous section that WL is impractical due to its very high data
complexity. In this section, we start by recalling the notion of regular expressions 
with memory (REM) and their basic results from [9]. The problem with
this logic though is its limitation in expressive power. For instance, the query
(Q) from the introduction cannot be expressed in REM. We then introduce an
extension of REM, called regular logic (RL), that remedies this limitation in
expressive power (in fact, it can express many natural examples of queries expressible 
in WL, e.g., those given in [7]) while retaining elementary complexity
of query evaluation. Finally, we study which fragments of RL are well-behaved
for database applications.

5.1 Regular Expressions with Memory

REMs deﬁne pairs of nodes in data graphs that are linked by a path that satisﬁes
a constraint in the way in which the topology interacts with the underlying data.
REMs allow to specify when data values are remembered and used. Data values
are stored in k registers r1, . . . , rk. At any point we can compare a data value
with one previously stored in the registers. As an example, consider the REM
↓ r.a+[r=]. It can be read as follows: Store the current data value in register r,
and then check that after reading a word in a+ we see the same data value again
(condition [r=]). We formally deﬁne REM next.
Let r1, . . . , rk be registers. The set of conditions c over {r1, . . . , rk} is recur-
| c ∧ c | ¬c, for 1 ≤ i ≤ k. Assume that D⊥ is the
sively deﬁned as: c := r=
extension of the set D of data values with a new symbol ⊥. Satisfaction of coni

ditions is deﬁned with respect to a value d ∈ D (the data value that is currently
being scanned) and a tuple τ = (d1, . . . , dk) ∈ Dk⊥ (the data values stored in the
registers, assuming that di = ⊥ represents the fact that register ri has no value
assigned) as follows (Boolean combinations omitted): (d, τ ) |= r=

iﬀ d = di.

i

Expressive Path Queries on Graphs with Data

79

Deﬁnition 3 (REMs). The class of REMs over Σ and {r1, . . . , rk} is deﬁned

by the grammar:

e := ε | a | e ∪ e | e · e | e+ | e[c] | ↓ ¯r.e

where a ranges over symbols in Σ, c over conditions over {r1, . . . , rk}, and ¯r
over tuples of elements in {r1, . . . , rk}.

That is, REM extends the class of regular expressions e – which is a popular
mechanism for specifying topological properties of paths in graph databases (see,
e.g., [16,2]) – with expressions of the form e[c], for c a condition, and ↓ ¯r.e, for ¯r
a tuple of registers – that deﬁne how such topology interacts with the data.

Semantics: To deﬁne the evaluation e(G) of an REM e over a data graph G =
(V, E, κ), we use a relation (cid:2)e(cid:3)G that consists of tuples of the form (u, λ, ρ, v, λ(cid:4)
),
two k-tuples over D⊥. The
for u, v nodes in V , ρ a path in G from u to v, and λ, λ(cid:4)
intuition is the following: the tuple (u, λ, ρ, v, λ(cid:4)
) belongs to (cid:2)e(cid:3)G if and only if
the data and topology of ρ can be parsed according to e, with λ being the initial
assignment of the registers, in such a way that the ﬁnal assignment is λ(cid:4)
. We
then deﬁne e(G) as the pairs (u, v) of nodes in G such that (u,⊥k, ρ, v, λ) ∈ (cid:2)e(cid:3)G,
for some path ρ in G from u to v and k-tuple λ over D⊥.
We inductively deﬁne relation (cid:2)e(cid:3)G below. We assume that λ¯r=d, for d ∈ D,
is the tuple obtained from λ by setting all registers in ¯r to be d. Also, if ρ1 =
v1a1v2 ··· vk−1ak−1vk and ρ2 = vkakvk+1 ··· vn−1an−1vn are paths, then ρ1ρ2 is
the path v1a1v2 ··· vk−1ak−1vkakvk+1 ··· vn−1an−1vn. Then:
– (cid:2)ε(cid:3)G = {(u, λ, ρ, u, λ) | u ∈ V, ρ = u, λ ∈ Dk⊥}.
– (cid:2)a(cid:3)G = {(u, λ, ρ, v, λ) | ρ = uav, λ ∈ Dk⊥}.
– (cid:2)e1 ∪ e2(cid:3)G = (cid:2)e1(cid:3)G ∪ (cid:2)e2(cid:3)G.
– (cid:2)e1·e2(cid:3)G = (cid:2)e1(cid:3)G◦(cid:2)e2(cid:3)G, where (cid:2)e1(cid:3)G◦(cid:2)e2(cid:3)G is the set of tuples (u, λ, ρ, v, λ(cid:4)
) ∈ (cid:2)e2(cid:3)G, for some

) ∈ (cid:2)e1(cid:3)G and (w, λ(cid:4)(cid:4), ρ2, v, λ(cid:4)
– (cid:2)e+(cid:3)G = (cid:2)e(cid:3)G ∪ ((cid:2)e(cid:3)G ◦ (cid:2)e(cid:3)G) ∪ ((cid:2)e(cid:3)G ◦ (cid:2)e(cid:3)G ◦ (cid:2)e(cid:3)G) . . .
– (cid:2)e[c](cid:3)G = {(u, λ, ρ, v, λ(cid:4)
– (cid:2)↓ ¯r.e(cid:3)G = {(u, λ, ρ, v, λ(cid:4)
) ∈ (cid:2)e(cid:3)G}.
For each REM e, we will use the shorthand notation e∗
Example 2. The REM Σ∗ · (↓ r.Σ+[r=]) · Σ∗
deﬁnes the pairs of nodes that
are linked by a path in which two nodes have the same data value. The REM
↓ r.(a[¬r=])+ deﬁnes the pairs of nodes that are linked by a path ρ with label in
a+, such that the data value of the ﬁrst node in the path is diﬀerent from the
data value of all other nodes in ρ.
2

over D⊥, and paths ρ1, ρ2 such that ρ = ρ1ρ2.

such that (u, λ, ρ1, w, λ(cid:4)(cid:4)
w ∈ V , k-tuple λ(cid:4)(cid:4)

)

) ∈ (cid:2)e(cid:3)G | (κ(v), λ(cid:4)
) | (u, λ¯r=κ(u), ρ, v, λ(cid:4)

) |= c}.

to denote ε ∪ e+.

The problem Eval(REM) is, given a data graph G = (V, E, κ), a pair (v1, v2)
of nodes in V , and an REM e, is (v1, v2) ∈ e(G)? The data complexity of the
problem refers again to the case when φ is considered to be ﬁxed. REMs are
tractable in data complexity and have no worst combined complexity than FO
over relational databases:

80

P. Barcel, G. Fontaine, and A.W. Lin

Proposition 1 ([9]). Eval(REM) is Pspace-complete, and in Nlogspace in
data complexity.

5.2 Register Logic

REM is well-behaved in terms of the complexity of evaluation, but its expressive
power is rather rudimentary for expressing several data/topology properties of
interest in data graphs. As an example, the query (Q) from the introduction
– which can be easily expressed in WL – cannot be expressed as an REM (we
actually prove a stronger result later). The main shortcomings of REM in terms
of its expressive power are its inability to (i) compare data values in diﬀerent
paths and (ii) express branching properties of the data.

¬

In this section, we propose register logic (RL) as a natural extension of REM
that makes up for this lack of expressiveness. We borrow ideas from the logic
, presented in [4], that closes the class of regular path queries [6] under
CRPQ
Boolean combinations and existential node and path quantiﬁcation. In the case
of RL we start with REMs and close them not only under Boolean combinations
and node and path quantiﬁcation – which allow to express arbitrary patterns
over the data – but also under register assignment quantiﬁcation – which permits
to compare data values in diﬀerent paths. We also prove that the complexity of
the evaluation problem for RL is elementary (Expspace), and, thus, that in this
regard RL is in stark contrast with WL.

To deﬁne RL we assume the existence of countably inﬁnite sets of node, path
and register assignment variables. Node variables are denoted x, y, z, . . . , path
variables are denoted π, π(cid:4), π1, π2, . . . , and register assignment variables are denoted 
ν, ν1, ν2, . . .

Deﬁnition 4 (Register logic (RL)). We deﬁne the class of RL formulas φ
over alphabet Σ and {r1, . . . , rk} using the following grammar:

atom := x = y | π = π(cid:4) | ν = ν(cid:4) | ν = ¯⊥ | (x, π, y) | e(π, ν1, ν2)

φ := atom | ¬φ | φ ∨ φ | ∃xφ | ∃πφ | ∃νφ
are path variables, ν, ν(cid:4)

Here x, y are node variables, π, π(cid:4)
variables, and e is an REM over Σ and {r1, . . . , rk}.

are register assignment

Intuitively, ν = ¯⊥ holds iﬀ ν is the empty register assignment, (x, π, y) checks
that π is a path from x to y, and e(π, ν, ν(cid:4)
) checks that π can be parsed according
to e starting from register assignment ν and ﬁnishing in register assignment ν(cid:4)
.
The quantiﬁer ∃ν is to be read “there exists an assignment of data values in the
data graph to the registers”.

Let G = (V, E, κ) be a data graph over Σ and φ a RL formula over Σ and
{r1 . . . , rk}. Assume that D is the set of data values that are mentioned in G,
i.e., D = {κ(v) | v ∈ V }. An assignment α for φ over G is a mapping that assigns
(i) a node in V to each free node variable x in φ, (ii) a path ρ in G to each free
path variable π in φ, and (iii) a tuple λ in (D ∪{⊥})k to each register variable ν

Expressive Path Queries on Graphs with Data

81

that appears free in φ. That is, for safety reasons we assume that α(ν) can only
contain data values that appear in the underlying data graph. This represents
no restriction for the expressiveness of the logic.
We inductively deﬁne (G, α) |= φ, for G a data graph, φ a RL formula, and
α an assignment for φ over G, as follows (we omit equality atoms and Boolean
combinations since they are standard):
– (G, α) |= ν = ¯⊥ iﬀ α(ν) = ⊥k.
– (G, α) |= (x, π, y) iﬀ α(π) is a path from α(x) to α(y) in G.
– (G, α) |= e(π, ν, ν(cid:4)
from node u to v.
– (G, α) |= ∃xφ iﬀ there is node v ∈ V such that (G, α[x → v]) |= φ.
– (G, α) |= ∃πφ iﬀ there is path ρ in G such that (G, α[π → ρ]) |= φ.
– (G, α) |= ∃νφ iﬀ there is tuple λ in (D ∪{⊥})k such that (G, α[ν → λ]) |= φ.

)) ∈ (cid:2)e(cid:3)G, assuming α(π) goes

) iﬀ (u, α(ν), α(π), v, α(ν(cid:4)

Thus, each REM e is expressible in RL using the formula:

∃π∃ν∃ν(cid:4)

( ν = ¯⊥ ∧ e(π, ν, ν(cid:4)

) ).

Example 3. Recall query (Q) from the introduction: Find pairs of nodes x and
y in a graph database, such that there is a node z and a path π from x to y
in which each node is connected to z. This query can be expressed in RL over
Σ = {a} and a single register r as follows:

(cid:2)

∃π

(x, π, y) ∧ ∃z∀ν(e1(π, ν, ν) → ∃z(cid:4)∃π(cid:4)

((z(cid:4), π(cid:4), z) ∧ e2(π(cid:4), ν, ν)))

(cid:3)

,

[r=] · a∗

where e1 := a∗
stored in register r appears in a path, and e2 := ε[r=] · a∗
checks if the ﬁrst node of a path is the one that is stored in register r.

is the REM that checks whether the node (i.e. data)
is the REM that

In fact, this formula deﬁnes the pairs of nodes x and y such that there exists
a path π that goes from x to y and a node z for which the following holds: for
every register value ν (i.e., for every node ν) such that e1(π, ν, ν) (i.e. node ν
is in π), it is the case that there is a path π(cid:4)
to z such that
e2(π(cid:4), ν, ν) (i.e., z(cid:4)
connects ν to z). Notice that this uses the fact
that the underlying data model is that of graph databases, in which each node
2
is uniquely identiﬁed by its data value.

from some node z(cid:4)

= ν and π(cid:4)

Complexity of Evaluation for RL: The evaluation problem for RL, denoted
Eval(RL), is as follows: Given a data graph G, a RL formula φ, and an assignment 
α for φ over G, is it the case that (G, α) |= φ? As before, we denote by
Eval(RL,φ) the evaluation problem for the ﬁxed RL formula φ.

We show next that, unlike WL, register logic RL can be evaluated in elementary 
time, and, actually, with only one exponential jump over the complexity of
evaluation of REMs:

Theorem 2. Eval(RL) is Expspace-complete. The lower bound holds even if
the input is restricted to graph databases.

82

P. Barcel, G. Fontaine, and A.W. Lin

¬
Proof (Idea): For the upper bound, we adapt for RL the proof that CRPQ
formulas can be evaluated in Pspace [4]. This requires some care in the way
in which register values and atomic REM formulas are handled. The extra exponential 
blow up is produced by the fact that checking whether a path ρ in a
data graph G does not satisfy an REM e (i.e. whether it is not the case that
(u, ¯⊥, ρ, v, λ) ∈ (cid:2)e(cid:3)G, for some register assignment λ, assuming that ρ goes from
u to v) requires exponential space. The lower bound is obtained by a reduction
from the acceptance problem for a Turing machine that works in Expspace. 2

The increase in expressiveness of RL over REM has an important cost in data

complexity, which becomes intractable:

Theorem 3. Eval(RL) is in Pspace in data complexity. Furthermore, there
is a ﬁnite alphabet Σ and a RL formula φ over Σ and a single register r, such
that Eval(RL,φ) is Pspace-hard. In addition, the latter holds even if the input
is restricted to graph databases.

In the next section we introduce an interesting language, based on a restriction
of RL, that is tractable in data complexity, and thus better suited for database
applications. This language is a proper extension of REM. But before, we make
some important remarks about the expresive power of RL.

¬

Expressive Power of RL: We now look at the expressive power of the logic
RL. It was proven in [7] that CRPQ is not subsumed in WL. Since RL subsumes
, it follows that RL is not subsumed in WL. On the other hand, WL
CRPQ
is also not subsumed in RL due to Theorem 1, Theorem 2, and the standard
time/space hierarchy theorem from complexity theory. Therefore, we have the
following proposition:

Proposition 2. The expressive powers of WL and RL are incomparable.

On the other hand, we shall argue now that many natural queries about the interaction 
between data and topology are also expressible in RL. The aforementioned
query (Q) is one such example. We shall now mention other examples: hamiltonicity 
(H), the existence of Eulerian trail (E), bipartiteness (B), and complete
graphs with even number of nodes (C2). The ﬁrst two are expressible in WL,
while (B) and (C2) are not known to be expressible in WL. We conjecture that
they are not.

We now show how to express in RL the existence of a hamiltonian path in a
graph; the query (E) can be expressed in the same way but with two registers (to
remember edges, i.e., consisting of two nodes). This is done with the following
formula over Σ = {a} and a single register r:

∃π

(cid:2)∀λ∀λ(cid:4)¬e1(π, λ, λ(cid:4)

) ∧ ∀λ(λ (cid:10)= ⊥ → e2(π, λ, λ))

(cid:3)

,

where e1 := a∗ · (↓r.a+[r=]) · a∗
is the REM that checks whether in a path some
node is repeated (i.e., that it is not a simple path), and e2 := a∗
is the
REM that checks that the node stored in register r appears in a path. In fact,

[r=]a∗

Expressive Path Queries on Graphs with Data

83

this query expresses that there is a path π that it is simple (as expressed by the
formula ∀λ∀λ(cid:4)¬e1(π, λ, λ(cid:4)
)), and every node of the graph database is mentioned
in π (as expressed by the formula ∀λ(λ (cid:10)= ⊥ → e2(π, λ, λ))).

We now show how to express in RL the property bipartiteness from graph
theory. An undirected G = (V, E) is bipartite if its set of nodes can be partitioned
into two sets S1 and S2 such that, for each edge (v, w) ∈ E, either (i) v ∈ S1
and w ∈ S2, or (ii) v ∈ S2 and w ∈ S2. It is well-known that a graph database is
bipartite iﬀ it does not have cycles of odd length. The latter is expressible in RL
since the existence of an odd-length cycle can be expressed as ∃π∃λ∃λ(cid:4)e(π, λ, λ(cid:4)
),
where e =↓ r.a(aa)
∗

[r=].

We now show how to express in RL that a graph database is a complete
graph with an even number of nodes. To this end, it is suﬃcient and necessary
to express the existence of a hamiltonian path π with an odd number of edges
in the graph. But this is a simple modiﬁcation of our formula for expressing
hamiltonicity: we add the check that π has an odd number of edges by adding
), where e = a∪ a(aa)+, and close the entire formula under
the conjunct e(π, ν, ν(cid:4)
existential quantiﬁcation of ν and ν(cid:4)

.

5.3 Tractability in Data Complexity

Let RL+ be the positive fragment of RL (i.e. the logic obtained from RL by
forbidding negation and adding conjunctions). It is easy to prove that the data
complexity of the evaluation problem for RL+ is tractable (NLogspace). This
fragment contains the class of conjunctive REMs, that has been previously identiﬁed 
as tractable in data complexity [9]. However, the expressive power of RL+
is limited as the following proposition shows.

Proposition 3. The query (Q) from the introduction is not expressible in RL+.

On the other hand, increasing the expressive power of RL+ with some simple
forms of negation leads to intractability of query evaluation in data complexity:

Proposition 4. There is a ﬁnite alphabet Σ and REMs e1, e2, e3, e4 over Σ and
a single register r, such that Eval(RL,φ) is Pspace-complete, where φ is either
∃π∃λ¬(e1(π,⊥, λ) ∨ e2(π,⊥,⊥)) or ∃π∀λ¬(e3(π,⊥, λ) ∨ e4(π,⊥,⊥)).

In the case of basic navigational languages for graph databases, it is possible
to increase the expressive power – without aﬀecting the cost of evaluation –
by extending formulas with a branching operator (in the style of the class of
nested regular expressions [3]). The same idea can be applied in our scenario,
by extending atomic REM formulas in RL+ with such branching operator. The
resulting language is more expressive than RL+ (in particular, this extension
can express query (Q)), yet remains tractable in data complexity. We formalize
this idea below.
The class of nested REMs (NREM) extends REM with a nesting operator (cid:16)·(cid:17)
deﬁned as follows: If e is an NREM then (cid:16)e(cid:17) is also an NREM. Intuitively, the
formula (cid:16)e(cid:17) ﬁlters those nodes in a data graph that are the origin of a path that

84

P. Barcel, G. Fontaine, and A.W. Lin

) ∈ (cid:2)e(cid:3)G, for some node v in G, path ρ(cid:4)

can be parsed according to e. Formally, if e is an NREM over k registers and G
is a data graph, then (cid:2)(cid:16)e(cid:17)(cid:3)G consists of all tuples of the form (u, λ, ρ = u, u, λ)
such that (u, λ, ρ(cid:4), v, λ(cid:4)
in G, and k-tuple
over D⊥.
λ(cid:4)
Let NRL+ be the logic that is obtained from RL+ by allowing atomic formulas
of the form e(π, ν, ν(cid:4)
), for e an NREM. Given a data graph G and an assignment
α for π, ν and ν(cid:4)
) if and only if α(π)
)) ∈ (cid:2)e(cid:3)G. The semantics of NRL+
goes from u to v and (u, α(ν), α(π), v, α(ν(cid:4)
is thus obtained from the semantics of these atomic formulas in the expected
way. The following example shows that query (Q) is expressible in NRL+, and,
therefore, that NRL+ increases the expressiveness of RL+.

over G, we write as before (G, α) |= e(π, ν, ν(cid:4)

φ = ∃π∃ν

(cid:2)

(cid:3)
,

Example 4. Over graph databases, the query (Q) from the introduction is expressible 
in NRL+ using the following formula over Σ = {a} and register r:

∗(cid:16)e1(cid:17), for e1 = a∗

(x, π, y) ∧ e(π, ν, ν)
where e := ((cid:16)e1(cid:17)·a)
[r=]. Intuitively, e1 checks in a path whether
its last node is precisely the node stored in register r, and thus e checks whether
every node in a path can reach the node stored in register r. Therefore, the
formula φ deﬁnes the set of pairs (x, y) of nodes, such that there is a path π that
goes from x to y and a register value ν (i.e., a node ν) that satisfy that every
node in π is connected to ν.
2

The extra expressive power of NRL+ over RL+ does not aﬀect the data complexity 
of query evaluation:

Theorem 4. Evaluation of NRL+ formulas can be solved in NLogspace in
data complexity.

From the proof of Theorem 4 it also follows that NRL+ formulas can be

evaluated in Pspace in combined complexity.

6 Conclusions and Future Work

We have proven that the data complexity of walk logic is nonelementary, which
rules out the practicality of the logic. We have proposed register logic, which is an
extension of regular expressions with memory. Our results in this paper suggest
that register logic is capable of expressing natural queries about interactions
between data and topology in data graphs, while still preserving the elementary
data complexity of query evaluation (Pspace). Finally, we showed how to make
register logic more tractable in data complexity (NLogspace) through the logic
NRL+, while at the same time preserving some level of expressiveness of RL.

We leave open several problems for future work. One interesting question is to
study the expressive power of extensions of walk logic, in comparison to RL and
from [4]. For example, we can consider extensions with regularity tests
ECRPQ
(i.e. an atomic formula testing whether a path belongs to a regular language).

¬

Expressive Path Queries on Graphs with Data

85

¬

Even in this simple case, the expressive power of the resulting logic, compared
to RL and ECRPQ
, is already not obvious. Secondly, we do not know whether
NRL+ is strictly more expressive than RL. Finally, we will also mention that
expressibility of bipartiteness in WL is still open (an open question from [7]).
We also leave open whether the query that a graph database is a complete graph
with an even number of nodes is expressible in WL.

Acknowledgements. We thank the reviewers for the useful comments. Barcel´o is
funded by Fondecyt grant 1130104, Fontaine by Fondecyt postdoctoral grant 3130491,
and Lin by EPSRC (EP/H026878/1). Part of this work was done when Lin visited
Barcel´o funded by Fondecyt grant 1130104.

References

1. Angles, R., Guti´errez, C.: Survey of graph database models. ACM Comput.

Surv. 40(1) (2008)

2. Barcel´o, P.: Querying graph databases. In: PODS, pp. 175–188 (2013)
3. Barcel´o, P., P´erez, J., Reutter, J.L.: Relative expressiveness of nested regular expressions.
 In: AMW, pp. 180–195 (2012)

4. Barcel´o, P., Libkin, L., Lin, A.W., Wood, P.T.: Expressive languages for path
queries over graph-structured data. ACM Trans. Database Syst. 37(4), 31 (2012)

5. Clarke, E.M., Grumberg, O., Peled, D.A.: Model checking. MIT Press (2000)
6. Cruz, I., Mendelzon, A.O., Wood, P.T.: A graphical query language supporting

recursion. In: SIGMOD, pp. 323–330 (1987)

7. Hellings, J., Kuijpers, B., van den Bussche, J., Zhang, X.: Walk logic as a framework

for path query languages on graph databases. In: ICDT, pp. 117–128 (2013)

8. Kaminski, M., Francez, N.: Finite memory automata. TCS 134(2), 329–363 (1994)
9. Libkin, L., Vrgoˇc, D.: Regular path queries on graphs with data. In: ICDT 2012,

pp. 74–85 (2012)

10. Libkin, L., Vrgoˇc, D.: Regular expressions for data words. In: Bjørner, N., Voronkov,
A. (eds.) LPAR-18 2012. LNCS, vol. 7180, pp. 274–288. Springer, Heidelberg (2012)
11. Libkin, L., Reutter, J.L., Vrgoc, D.: Trial for RDF: adapting graph query languages

for RDF data. In: PODS, pp. 201–212 (2013)

12. Mendelzon, A.O., Wood, P.T.: Finding regular simple paths in graph databases.

SIAM J. Comput. 24(6), 1235–1258 (1995)

13. Robertson, L.E.: Structure of complexity in the weak monadic second-order theories 
of the natural numbers. In: STOC, pp. 161–171 (1974)

14. Stockmeyer, L.: The complexity of decision problems in automata theory and logic.

Ph.D. thesis. MIT (1974)

15. Vardi, M.Y.: The complexity of relational query languages. In: STOC, pp. 137–146

(1982)

16. Wood, P.T.: Query languages for graph databases. SIGMOD Record 41(1), 50–60

(2012)

