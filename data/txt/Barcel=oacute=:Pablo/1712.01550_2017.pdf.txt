G-CORE
A Core for Future Graph (cid:131)ery Languages
Designed by the LDBC Graph (cid:131)ery Language Task Force∗

RENZO ANGLES, Universidad de Talca
MARCELO ARENAS, PUC Chile
PABLO BARCEL ´O, DCC, Universidad de Chile
PETER BONCZ, CWI, Amsterdam
GEORGE FLETCHER, Technische Universiteit Eindhoven
CLAUDIO GUTIERREZ, DCC, Universidad de Chile
TOBIAS LINDAAKER, Neo4j
MARCUS PARADIES, SAP SE
STEFAN PLANTIKOW, Neo4j
JUAN SEQUEDA, Capsenta
OSKAR VAN REST, Oracle
HANNES VOIGT, Technische Universit¨at Dresden

We report on a community e(cid:130)ort between industry and academia to shape the future of graph query languages. We argue that existing
graph database management systems should consider supporting a query language with two key characteristics. First, it should be
composable, meaning, that graphs are the input and the output of queries. Second, the graph query language should treat paths as
(cid:128)rst-class citizens. Our result is G-CORE, a powerful graph query language design that ful(cid:128)lls these goals, and strikes a careful balance
between path query expressivity and evaluation complexity.

ACM Reference format:
Renzo Angles, Marcelo Arenas, Pablo Barcel´o, Peter Boncz, George Fletcher, Claudio Gutierrez, Tobias Lindaaker, Marcus Paradies,
Stefan Plantikow, Juan Sequeda, Oskar van Rest, and Hannes Voigt. 2017. G-CORE
A Core for Future Graph (cid:139)ery Languages. 1, 1, Article (January 2017), 33 pages.
DOI:

∗(cid:140)is paper is the culmination of 2.5 years of intensive discussion between the LDBC Graph (cid:139)ery Language Task Force and members of industry and
academia. We thank the following organizations who participated in this e(cid:130)ort: Capsenta, HP, Huawei, IBM, Neo4j, Oracle, SAP and Sparsity. We also
thank the following people for their participation: Alex Averbuch, Hassan Cha(cid:128), Irini Fundulaki, Alastair Green, Josep Lluis Larriba Pey, Jan Michels,
Raquel Pau, Arnau Prat, Tomer Sagi and Yinglong Xia.

Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not
made or distributed for pro(cid:128)t or commercial advantage and that copies bear this notice and the full citation on the (cid:128)rst page. Copyrights for third-party
components of this work must be honored. For all other uses, contact the owner/author(s).
© 2017 Copyright held by the owner/author(s). Manuscript submi(cid:138)ed to ACM

Manuscript submi(cid:138)ed to ACM

1

2

R. Angles et al.

PREAMBLE
G-CORE is a design by the LDBC Graph (cid:139)ery Language Task Force, consisting of members from industry and academia,
intending to bring the best of both worlds to graph practitioners.

LDBC is not a standards body and rather than proposing a new standard, we hope that the design and features of
G-CORE will guide the evolution of both existing and future graph query languages, towards making them more useful,
powerful and expressive.

1 INTRODUCTION
In the last decade there has been increased interest in graph data management. In industry, numerous systems that
store and query or analyze such data have been developed. In academia, manifold functionalities for graph databases
have been proposed, studied and experimented with.

Graphs are the ultimate abstraction for many real world processes and today the computer infrastructure exists to
collect, store and handle them as such. (cid:140)ere are several models for representing graphs. Among the most popular is the
property graph data model, which is a directed graph with labels on both nodes and edges, as well as (cid:104)property,value(cid:105)
pairs associated with both. It has gained adoption with systems such as AgensGraph [3], Amazon Neptune [4],
ArangoDB [9], Blazegraph [12], CosmosDB [24], DataStax Enterprise Graph [14], HANA Graph [37], JanusGraph [21],
Neo4j [25], Oracle PGX [38], OrientDB [30], Sparksee [39], Stardog [40], TigerGraph [41], Titan [42], etc. (cid:140)ese systems
have their own storage models, functionalities, libraries and APIs and many have query languages. (cid:140)is wide range of
systems and functionalities poses important interoperability challenges to the graph database industry. In order for the
graph database industry to cooperate, community e(cid:130)orts such as Apache Tinkerpop, openCypher[2] and the Linked
Data Benchmark Council (LDBC) are providing vendor agnostic graph frameworks, query languages and benchmarks.
LDBC was founded by academia and industry in 2012 [7] in order to establish standard benchmarks for such new graph
data management systems. LDBC has since developed a number of graph data management benchmarks [16, 20, 22]
to contribute to more objective comparison among systems, informing prospective users of some of the strongand

weak-points of the various systems before even doing a Proof-Of-Concept study, while providing system engineers and
architects clear targets for performance testing and improvement. LDBC regularly organizes Technical User Community
(TUC) meetings, where not only members report on progress of LDBC task forces but also gather requirements and
feedback from data practitioners, who are also present. (cid:140)ere have been over 40 graph use-case presentations by data
practitioners in these TUC meetings, who o(cid:137)en are users of the graph data management so(cid:137)ware of LDBC members,
such as IBM, Neo4j, Ontotext, Oracle and SAP. (cid:140)e topics and contents of these collected TUC presentations show that
graph databases are being adopted over a wide range of application (cid:128)elds, as summarized in Figure 1. (cid:140)is further
shows that the desired graph query language features are graph pa(cid:138)ern matching (e.g., identi(cid:128)cation of communities in
social networks), graph reachability (e.g., fraud detection in (cid:128)nancial transactions or insurance), weighted path (cid:128)nding
(e.g., route optimization in logistics, or bo(cid:138)leneck detection in telecommunications), graph construction (e.g., data
integration in Bioinformatics or specialized publishing domains such as legal) and graph clustering (e.g., on social
networks for customer relationship management).

1.1 Three Main Challenges
(cid:140)e following issues are observed about existing graph query languages. (cid:140)ese observations are based on the LDBC
TUC use-case analysis and feedback from industry practitioners:
Manuscript submi(cid:138)ed to ACM

G-CORE

3

Application Fields

healthcare / pharma
publishing
(cid:128)nance / insurance
cultural heritage
e-commerce
social media
telecommunications

14
10
6
6
5
4
4

Used Features
graph reachability
graph construction
pa(cid:138)ern matching
shortest path search
graph clustering

36
34
32
19
14

Fig. 1. Graph database usage characteristics derived from the use-case presentations in LDBC TUC Meetings 2012-2017 (source:
h(cid:130)ps://github.com/ldbc/tuc presentations).

Composability. (cid:140)e ability to plug and play is an essential step in standardization. Having the ability to plug outputs
and inputs in a query language incentivizes its adoption (modularity, interoperability); simplify abstractions, users do
not have to think about multiple data models during the query process; and increases its productivity, by facilitating
reuse and decomposition of queries. Current query languages do not provide full composability because they output
tables of values, nodes or edges.

Path as (cid:128)rst-class citizens. (cid:140)e notion of Path is fundamental for graph databases, because it introduces an intermediate 
abstraction level that allows to represents how elements in a graph are related. (cid:140)e facilities provided by a graph
query language to manipulate paths (i.e. describe, search, (cid:128)lter, count, annotate, return, etc.) increase the expressivity of
the language. Particularly, the ability to return paths enables the user to post-process paths within the query language
rather that in an ad-hoc manner [15].

Capture the core of available languages. Both the desirability of a standard query language and the di(cid:129)culty of
achieving this, is well-established. (cid:140)is is particularly true for graph data languages due to the diversity of models and
the rich properties of the graph model. (cid:140)is motivates our approach to take the successful functionalities of current
languages as a base from where to develop the next generation of languages.

1.2 Contributions
Since the lack of a common graph query language kept coming up in LDBC benchmark discussions, it was decided
in 2014 to create a task force to work on a common direction for property graph query languages. (cid:140)e authors are
members of this task-force.

(cid:140)is paper presents G-CORE, a closed query language on Property Graphs. It is a coherent, comprehensive and
consistent integration of industry desiderata and the leading functionalities found in industry practices and theoretical
research.
(cid:140)e paper presents the following contributions:

Path Property Graph model. G-CORE treats paths as (cid:128)rst-class citizens. (cid:140)is means that paths are outputs of certain
queries. (cid:140)e fact that the language must be closed implies that paths must be part of the graph data model. (cid:140)is leads to
a principled change of the data model: it extends property graphs with paths. (cid:140)at is, in a graph, there is also a (possibly
empty) collection of paths; where a path is a concatenation of existing, adjacent, edges. Further, given that nodes, edges
and paths are all (cid:128)rst-class citizens, paths have identity and can also have labels and (cid:104)property,value(cid:105) pairs associated
with them. (cid:140)is extended property graph model, called the Path Property Graph model, is backwards-compatible with
the property graph model.

Manuscript submi(cid:138)ed to ACM

4

R. Angles et al.

Fig. 2. A small social network. A Path Property Graph (PPG) is a Property Graph that can have “Stored Paths”.

Syntax and Semantics of G-CORE. A key contribution is the formal de(cid:128)nition of G-CORE. (cid:140)is formal de(cid:128)nition prevents 
any ambiguity about the functionality of the language, thus enabling the development of correct implementations.
In particular, an open source grammar for G-CORE is available1.

Complexity results. To ensure that the query language is practically usable on large data, the design of G-CORE was
built on previous complexity results. Features were carefully restricted in such ways that G-CORE is tractable (each
query in the language can be evaluated e(cid:129)ciently). (cid:140)us, G-CORE provides the most powerful path query functionalities
proposed so far, while carefully avoiding intractable complexity.

Organization of the paper. (cid:140)is paper (cid:128)rst de(cid:128)nes the Extended Property Graph model in Section 2. (cid:140)en it explains
G-CORE in Section 3 via a guided tour, using examples on the LDBC Social Network Benchmark dataset [16], which
demonstrate its main features. We summarize our formal contributions, comprising syntax, semantics and complexity
analysis of G-CORE in Section 4, while the details of these are described in Appendix A. In Section 5, we show how
G-CORE can be easily extended to handle tabular data. We discuss related work in Section 6, before concluding in
Section 7.

2 PATH PROPERTY GRAPHS
We (cid:128)rst de(cid:128)ne the data model of G-CORE, which is an extension of the Property Graph data model [6, 25, 27, 35, 44].
We call this model the Path Property Graph model, or PPG model for short. Let L be an in(cid:128)nite set of label names for
nodes, edges and paths, K an in(cid:128)nite set of property names, and V an in(cid:128)nite set of literals (actual values such as integer

1h(cid:138)ps://github.com/ldbc/ldbc gcore parser
Manuscript submi(cid:138)ed to ACM

G-CORE

5

and real numbers, strings, dates, truth values ⊥ and (cid:62), that represent true and false, respectively, etc.). Moreover, given
a set X, let FSET(X) denote the set of all (cid:128)nite subsets of X (including the empty set), and FLIST(X) denote the set of all
(cid:128)nite lists of elements from X (including the empty list).

De(cid:128)nition 2.1. A PPG is a tuple G = (N , E, P, ρ, δ, λ, σ), where:
(1) N is a (cid:128)nite set of node identi(cid:128)ers, E is a (cid:128)nite set of edge identi(cid:128)ers and P is a (cid:128)nite set of path identi(cid:128)ers,

where N , E and P are pairwise disjoint.

(2) ρ : E → (N × N) is a total function.
(3) δ

: P → FLIST(N ∪ E) is a total function such that for every p ∈ P,

it holds that δ(p) =
[a1, e1, a2, . . . , an, en, an+1], where: (i) n ≥ 0, (ii) ej ∈ E for every j ∈ {1, . . . , n}, and (iii) ρ(ej) = (aj , aj+1) or
ρ(ej) = (aj+1, aj) for every j ∈ {1, . . . , n}

(4) λ : (N ∪ E ∪ P) → FSET(L) is a total function.
(5) σ : (N∪E∪P)×K → FSET(V) is a total function for which there exists a (cid:128)nite set of tuples (x, k) ∈ (N∪E∪P)×K

such that σ(x, k) (cid:44) ∅

Given an edge e in a PPG G, if ρ(e) = (a, b), then a is the starting node of e and b is the ending node of e. (cid:140)e function
ρ allows us to have several edges between the same pairs of nodes. Function δ assigns to each path identi(cid:128)er p ∈ P an
actual path in G: this is a list [a1, e1, a2, . . . , an, en, an+1] satisfying condition (3) in De(cid:128)nition 2.1. Function λ is used to
specify the set of labels of each node, edge, and path, while function σ is used to specify the values of a property for
every node, edge, and path. To be precise, if x ∈ (N ∪ E ∪ P) and k ∈ K is a property name, then σ(x, k) is the set of
values of the property k for the identi(cid:128)er x. Observe that if σ(x, k) = ∅, then we implicitly assume that property k is
not de(cid:128)ned for identi(cid:128)er x, as there is no value of this property for this object. Note that although K is an in(cid:128)nite set of
property names, in G only a (cid:128)nite number of properties are assigned values as we assume that there exists a (cid:128)nite set
of tuples (x, k) ∈ (N ∪ E ∪ P) × K such that σ(x, k) (cid:44) ∅.

Example 2.2. As a simple example of a PPG, consider the small social network graph given in Figure 2. Here we have

N = {101, 102, 103, 104, 105, 106},
E = {201, 202, 203, 204, 205, 206, 207}, and
P = {301}

as node, edge, and path identi(cid:128)ers, respectively;

ρ = {201 (cid:55)→ (102, 101), . . . , 207 (cid:55)→ (105, 103)} and
δ = {301 (cid:55)→ [105, 207, 103, 202, 102]}

as edge and path assignments, respectively; and,

λ = {101 (cid:55)→ {Tag}, 102 (cid:55)→ {Person, Manager}, . . . , 201 (cid:55)→ {hasInterest}, . . . , 301 (cid:55)→ {toWagner}}

and

σ

=

{(101, name)

(cid:55)→ {Wagner} , . . . ,(205, since)

(cid:55)→ {1/12/2014} , . . . ,(301, trust)

(cid:55)→ {0.95}}

as label and property value assignments, respectively.

Manuscript submi(cid:138)ed to ACM

6

R. Angles et al.

Fig. 3. Social Network Benchmark schema (simplified).

Paths. It is worth remarking that paths are included as a (cid:128)rst-class citizens in this data model (at the level of nodes and
edges). In particular, paths can have labels and properties, where the la(cid:138)er can be used to describe built-in properties
like the length of the path. In our example above, the path with identi(cid:128)er 301 has label “toWagner” and value 0.95 on
property “trust”.

For convenience, we use nodes(p) and edges(p) to denote the list of all nodes and edges of a path bound to a variable
p, respectively. Formally, if δ(p) = [a1, e1, a2, . . . , en, an+1] then nodes(p) = [a1, . . . , an+1] and edges(p) = [e1, . . . , en].
In our example above, nodes(301) = [102, 103, 105] and edges(301) = [202, 207].

3 A GUIDED TOUR OF G-CORE
We will now demonstrate and explain the main features of the G-CORE language. (cid:140)e concrete se(cid:138)ing is the LDBC
Social Network Benchmark (SNB), as illustrated in the simple social network from Figure 2, whose (simpli(cid:128)ed) schema
is depicted in Figure 3. Figure 4 depicts the toy instance (which we refer to as social_graph) on which our example
queries are evaluated. (cid:140)e use-cases in these examples are data integration and expert (cid:128)nding in a social network.

Always returning a graph. Let us start with what is possibly one of the simplest G-CORE queries:
1 CONSTRUCT (n)
2
3
4

ON
WHERE n. employer = ’ Acme ’

social_graph

MATCH

(n: Person )

In G-CORE every query returns a graph, as embodied by the CONSTRUCT clause which is at the start of every query
body. (cid:140)is example query constructs a new graph with no edges and only nodes, namely those persons who work at
Acme – all the labels and properties that these person nodes had in social_graph are preserved in the returned result
graph.

Match and Filter. (cid:140)e MATCH..ON..WHERE clause matches one or more (comma separated) graph pa(cid:136)erns on a named
graph, using the homomorphic semantics [6].

Systems may omit ON if there is a default graph – let us assume in the sequel that social_graph is the default graph.
Parenthesis demarcate a node, where n is a variable bound to the identity of a node, :Person a label, and n.employer a
Manuscript submi(cid:138)ed to ACM

G-CORE

7

Fig. 4. Initial graph database (social_graph). Note that the knows edges are drawn bi-directionally – this means there are two edges:
one in each direction.

property. (cid:140)e G-CORE builds on the ASCII-art syntax from Cypher [17] and the regular path expression syntax from
PGQL [43], which has proven intuitive, e(cid:130)ective and popular among property graph database users.

(cid:140)e previous example contains a WHERE (cid:128)lter with the obvious semantics: it eliminates all matches where the employer

is not Acme.

Multi-Graph (cid:134)eries and Joins. A more useful query would be a simple data integration query, where we might
have loaded (unconnected) company nodes into a temporary graph company_graph, but now want to create a uni(cid:128)ed
graph where employees and companies are connected with an edge labeled worksAt. Let us assume that company_graph
contains nodes for Acme, HAL, CWI and MIT. As an aside, the real SNB dataset already contains such Company nodes
with :worksAt edges to the employees (which in reality do not have an employer property).

(cid:140)e below query has a MATCH clause with two graph pa(cid:138)erns, matching these on two di(cid:130)erent input graphs. Graph
pa(cid:138)erns that do not have variables in common lead to the Cartesian product of variable bindings, but this query also
has a WHERE clause that turns it into an equi-join:
5 CONSTRUCT (c) < -[: worksAt ] -( n)
6
7
8
9 UNION social_graph

(c: Company ) ON company_graph ,
(n: Person )

MATCH

WHERE c. name = n. employer

ON social_graph

(cid:140)e UNION operator takes it intuitive meaning, and will be touched upon later when we talk about node and edge

identity.

Manuscript submi(cid:138)ed to ACM

8

R. Angles et al.

Generally speaking, MATCH produces a set of bindings which alternatively may be viewed as a table having a column
for each variable and one row for each binding. Bindings typically contain node, edge and path identities, whose shape
is opaque, but we use intuitive names pre(cid:128)xed # here:

c
#Acme
#HAL
#Acme

n
#Alice
#Celine
#John

Dealing with Multi-Valued properties. In the previous query there is the complication that n.employer is multi-valued
for Frank Gold: he works for both MIT and CWI. (cid:140)erefore, his person node fails to match with both companies. To
explain this, we show the bindings and values of c.name and n.employer if WHERE c.name = n.employer were omi(cid:138)ed, and the
query would be a Cartesian product:

c
#MIT
#CWI
#Acme
#HAL
#MIT
#CWI
#Acme
#HAL
#MIT
#CWI
#Acme
#HAL
#MIT
#CWI
#Acme
#HAL
#MIT
#CWI
#Acme
#HAL

c.name
”MIT”
”CWI”
”Acme”
”HAL”
”MIT”
”CWI”
”Acme”
”HAL”
”MIT”
”CWI”
”Acme”
”HAL”
”MIT”
”CWI”
”Acme”
”HAL”
”MIT”
”CWI”
”Acme”
”HAL”

n
#Peter
#Peter
#Peter
#Peter
#Frank
#Frank
#Frank
#Frank
#Alice
#Alice
#Alice
#Alice
#Celine
#Celine
#Celine
#Celine
#John
#John
#John
#John

n.employer

{”CWI”, ”MIT”}
{”CWI”, ”MIT”}
{”CWI”, ”MIT”}
{”CWI”, ”MIT”}
”Acme”
”Acme”
”Acme”
”Acme”
”HAL”
”HAL”
”HAL”
”HAL”
”Acme”
”Acme”
”Acme”
”Acme”

Notice that according to the de(cid:128)nition of our data model, the value of c.name is a set. But in the case c.name is a
singleton set, we omit curly braces, so we simply write "MIT" instead of {"MIT"}. In the table above, the rows in bold
would be the ones that earlier led to bindings surviving the join. Essentially, "MIT"={"CWI","MIT"} and "CWI"={"CWI","MIT"}
evaluate to FALSE.

Note that Peter is unemployed, so his n.employer value is unbound. More precisely, its Person node does not have an
employer property at all. In case of an absent property, its evaluation results in the empty set, which a length test can
detect. G-CORE provides CASE expressions to coalesce such missing data into other values.

One way to resolve the failing join for Frank, would be to use IN instead of =, so the comparisons mentioned earlier

resolve to TRUE:
10 CONSTRUCT (c) < -[: worksAt ] -( n)
11
12
13
14 UNION social_graph

WHERE c. name IN n. employer

MATCH

(c: Company ) ON company_graph ,
(n: Person )

ON social_graph

Manuscript submi(cid:138)ed to ACM

G-CORE

9

Notice that the IN operator can be used when c.name is a singleton set, as in this case it is natural to ask whether the
value in c.name is an element of n.employer. If we need to compare c.name with n.employer as sets, then the operator SUBSET
can be used.

Another way to deal with this in G-CORE is to bind a variable ({name:e}) to the employer property, which unrolls

multi-valued properties into individual bindings:
15 CONSTRUCT (c) < -[: worksAt ] -( n)
16
17
18
19 UNION social_graph

WHERE c. name = e

MATCH

(c: Company )
(n: Person { employer =e }) ON social_graph

ON company_graph ,

Inside the MATCH expression that binds a node, curly braces can be used to bind variables to property values. (cid:140)e set of

bindings for this MATCH (which includes the join) now has three variables and the following bindings:

c
#MIT
#CWI
#Acme
#HAL
#Acme

n
#Frank
#Frank
#Alice
#Celine
#John

e
”MIT”
”CWI”
”Acme”
”HAL”
”Acme”

Construction that respects identities. (cid:140)e CONSTRUCT operation (cid:128)lls a graph pa(cid:138)ern (used as template) for each
binding in the set of bindings produced by the MATCH clause. Edges are denoted with square brackets, and can be pointed
towards either direction; in this case there is no edge variable, but there is an edge label :worksAt. Note, to be precise,
that CONSTRUCT by default groups bindings when creating elements. Nodes are grouped by node identity, and edges by the
combination of source and destination node. While (cid:128)ve new edges are created here, they are between four existing
persons and four existing companies due to this grouping. For instance, the person #Frank, who works for both MIT and
CWI, gets two :worksAt edges, to respectively company #MIT and company #CWI.

In the last line of this example query, we UNION-ed these new edges with the original graph, resulting in an enriched
graph: the original graph plus (cid:128)ve edges. (cid:140)e “full graph” query operators like union and di(cid:130)erence are de(cid:128)ned in
terms of node, edge and path identities. (cid:140)ese identities are taken from the input graph(s) of the query. G-CORE is
a query language, not an update language. Even though CONSTRUCT allows with SET prop:=val and REMOVE prop to change
properties and values (a later example will demonstrate SET), this does not modify the graph database, it just changes
the result of that particular query. (cid:140)e practice of returning a graph that shares (parts of) nodes, edges and paths with
its inputs, using this concept of identity, provides opportunities for systems to share memory and storage resources
between query inputs and outputs.

A shorthand form for the union operation is to include a graph name directly in the comma separated list of CONSTRUCT

pa(cid:138)erns, as depicted in the next query:
20 CONSTRUCT
21
22

(n: Person { employer =e })

social_graph ,

MATCH

(x GROUP e : Company { name := e }) <-[y: worksAt ] -( n)

Graph Aggregation. (cid:140)e above query demonstrates graph aggregation. Supposing there would not have been any
company nodes in the graph, we might also have created them with this excerpt:

CONSTRUCT (n)-[y:worksAt]->(x:Company{name:=n.employer})

Manuscript submi(cid:138)ed to ACM

10

R. Angles et al.

However, this unbound destination node x would create a company node for each binding2. (cid:140)is is not what we want:
we want only one company per unique name. Graph aggregation therefore allows an explicit GROUP clause in each graph
pa(cid:138)ern element. (cid:140)us, in the above query with GROUP e, we create only one company node for each unique value of e
in the binding set. Here the curly brace notation is used inside CONSTRUCT to instantiate the Company.name property in the
newly created nodes.

(cid:140)e set of bindings of our graph aggregation query example has the same variables n and e variables of the previous
binding set. (cid:140)e CONSTRUCT for node expression (n) groups by node identity so instantiates the nodes with identity #Frank,
#Alice, #Celine and #John in the query result. (cid:140)ese nodes were already part of social_graph, so given that the CONSTRUCT is
UNION-ed with that, no extra nodes result.

For the (x GROUP e..) node expression, CONSTRUCT groups by e into bindings ”CWI”, ”MIT”, ”Acme”, and ”HAL” and because x
is unbound, it will create four new nodes with, say, identities #CWI, #MIT, #Acme and #HAL. For the edges to be constructed,
G-CORE performs by default grouping of the bindings on the combination of source and destination node, and this
results in again (cid:128)ve new edges.

When using bound variables in a CONSTRUCT, they must be of the right sort: it would be illegal to use n (a node) in the
place of y (an edge) here. In case an edge variable (here: y) would have been bound (in the MATCH), CONSTRUCT imposes the
restriction that its node variables must also be bound, and be bound to exactly its source and destination nodes, because
changing the source and destination of an edge violates its identity. However, it can be useful to bind edges in MATCH
and use these to construct edges with a new identity, which are copies of these existing edges in terms of labels and
property-values. For this purpose, G-CORE supports the -[=y]- syntax which makes a copy of the bound y edges (as
well as the (=n) syntax for nodes). (cid:140)en, the above restriction does not apply. With the copy syntax, it is even possible
to copy all labels and properties of a node to an edge (or a path) and vice versa.

In this example, x and y were unbound and could have been omi(cid:138)ed. In the preceding examples, they were in fact
omi(cid:138)ed. Unbound variables in a CONSTRUCT are useful if they occur multiple times in the construct pa(cid:138)erns, in order
to ensure that the same identities will be used (i.e., to connect newly created graph elements, rather than generate
independent nodes and edges).

Storing Paths with @p. G-CORE is unique in its treatment of paths, namely as (cid:128)rst-class citizens. (cid:140)e below query
demonstrates (cid:128)nding the three shortest paths from John Doe towards each other person who lives at his location,
reachable over knows edges, using Kleene star notation <:knows*>:
23 CONSTRUCT (n) -/ @p : localPeople { distance := c }/ - >( m)
24
(n) -/3 SHORTEST p <: knows *> COST c / - >( m)
25
26
27

AND n. firstName = ’ John ’ AND n. lastName = ’ Doe ’
AND (n) -[: isLocatedIn ] - >() < -[: isLocatedIn ] -( m)

MATCH

WHERE (n: Person ) AND (m: Person )

In G-CORE, paths are demarcated with slashes -/ /-. In the above example p <:knows*> binds the shortest path
between the single node n (i.e. John Doe) and every possible person m, under the restriction that this target person
lives in the same place. By writing e.g., -/3 SHORTEST p <:knows*>/-> we obtain multiple shortest paths (at most 3, in this
case) for every source–destination combination; if the number 3 would be omi(cid:138)ed, it would default to 1. In case there
are multiple shortest paths with equal cost between two nodes, G-CORE delivers just any one of them. By writing

2In addition, it would create a company with the name property with the values {"CWI", "MIT"}.
Manuscript submi(cid:138)ed to ACM

G-CORE

11

Fig. 5. Graph view social_graph1, which adds nr_message properties to the original social_graph (social_graph2 is social_graph1 plus
the Stored Paths in the grey box).

p <:knows*> COST c/-> we bind the shortest path cost to variable c. By default, the cost of a path is its hop-count (length).
We will de(cid:128)ne weighted shortest paths later. If we would not be interested in the length, COST c could be omi(cid:138)ed.

In CONSTRUCT (n)-/@p:localPeople{distance:c}, we see the bound path variable @p. (cid:140)e @ pre(cid:128)x indicates a stored path,
that is, this query is delivering a graph with paths. Each path is stored a(cid:138)aching the label :localPeople, and its cost as
property distance.

(cid:140)e graph returned by this query – which lacks a UNION with the original social_graph – is a projection of all nodes and

edges involved in these stored paths. We omi(cid:138)ed a (cid:128)gure of this for brevity.

Reachability and All Paths. In a similar query where we just return m, and do not store paths, the <:knows*> path
expression semantics is a reachability test:
28 CONSTRUCT (m)
29
30
31

WHERE n. firstName = ’ John ’ AND n. lastName = ’ Doe ’

AND (n) -[: isLocatedIn ] - >() < -[: isLocatedIn ] -( m)

(n: Person ) -/ <: knows * >/ - >( m: Person )

MATCH

In this case we use -/<:knows*>/-> without the SHORTEST keyword. Using ALL instead of SHORTEST: asking for all paths, is
not allowed if a path variable is bound to it and used somehwere, as this would be intractable or impossible due to an
in(cid:128)nite amount of results. However, G-CORE can support it in the case where the path variable is only used to return a
graph projection of all paths:
32 CONSTRUCT (n) -/p / - >( m)
33
34
35

WHERE n. firstName = ’ John ’ AND n. lastName = ’ Doe ’

(n: Person ) -/ ALL p <: knows * >/ - >( m: Person )

AND (n) -[: isLocatedIn ] - >() < -[: isLocatedIn ] -( m)

MATCH

Manuscript submi(cid:138)ed to ACM

12

R. Angles et al.

(cid:140)e method [10] shows how the materialization of all paths can be avoided by summarizing these paths in a graph

projection; hence this functionality is tractable.

Existential Subqueries. In the SNB graph, isLocatedIn is not a simple string a(cid:138)ribute, but an edge to a city, and the three
previous query examples used pa(cid:138)ern matching directly in the WHERE clause: (n)-[:isLocatedIn]->()<-[:isLocatedIn]-(m).
G-CORE allows this and uses implicit existential quanti(cid:128)cation, which here is equivalent to:
36 WHERE EXISTS (
37
CONSTRUCT ()
38

MATCH (n) -[: isLocatedIn ] - >() < -[: isLocatedIn ] -( m) )

(cid:140)is constructs one new node (unbound anonymous node variable ()) for each match of n and m coinciding in the
city where they are located – where that city is represented by a () again. Whenever such a subquery evaluates to the
empty graph, the automatic existential semantics of WHERE evaluates to FALSE; otherwise to TRUE.

CONSTRUCT social_graph ,

MATCH (n) -[e: knows ] - >( m)

Views and Optionals. (cid:140)e fact that G-CORE is closed on the PPG data model means that subqueries and views are
possible. In the following example we create such a view:
39 GRAPH VIEW social_graph1 AS (
40
41
42
43
44
45
46
47

WHERE (n: Person ) AND (m: Person )
OPTIONAL (n) <-[ c1 ] -( msg1 : Post | Comment ) ,

(n) -[e ] - >( m) SET e. nr_messages := COUNT (*)

( msg1 ) -[: reply_of ] -( msg2 ) ,

( msg2 : Post | Comment ) -[ c2 ] - >( m)

WHERE ( c1 : has_creator ) AND ( c2 : has_creator ) )

(cid:140)e result of this graph view can be seen in Figure 5. To each :knows edge, this view adds a nr_messages property, using
the SET .. := sub-clause. (cid:140)is sub-clause of CONSTRUCT can be used to modify properties of nodes, edges and paths that
are being constructed. (cid:140)is particular nr_messages property contains the amount of messages that the two persons n and
m have actually exchanged, and is a reliable indicator of the intensity of the bond between two persons.

(cid:140)e edge construction (n)-[e]->(m) adds nothing new, but as described before, performs implicit graph aggregation,

where bindings are grouped on n,m,e, and COUNT(*) evaluates to the amount of occurrences of each combination.

(cid:140)is example also demonstrates OPTIONAL matches, such that people who know each other but never exchanged
a message still get a property e.nr_messages=0. All pa(cid:138)erns separated by comma in an OPTIONAL block must match.
Technically, the set of bindings from the main MATCH is le(cid:137) outer-joined with the one coming out of the OPTIONAL block
(and there may be more than one OPTIONAL blocks, in which case this repeats). (cid:140)ere can be multiple OPTIONAL blocks, and
each OPTIONAL block can have its own WHERE; we demonstrate this here by moving some label tests to WHERE clauses (on
:Person and :has_creator). (cid:140)is query also demonstrates the use of disjunctive label tests (msg1:Post|Comment).

If a query contains multiple OPTIONAL blocks, they have to be evaluated from the top to the bo(cid:138)om. For example, to

evaluate the following pa(cid:138)ern:
48 MATCH (n: Person )
49
50

OPTIONAL (n) -[: worksAt ] - >( c)
OPTIONAL (n) -[: livesIn ] - >( a)

Manuscript submi(cid:138)ed to ACM

G-CORE

13

we need to perform the following steps: evaluate (n:Person) to generate a binding set T1, evaluate (n)-[:worksAt]->(c) to
generate a binding set T2, compute the le(cid:137)-outer join of T1 with T2 to generate a binding set T3, evaluate (n)-[:livesIn
]->(a) to generate a binding set T4, and compute the le(cid:137)-outer join of T3 with T4 to generate a binding set T that is the
result of evaluating the entire pa(cid:138)ern. Obviously, in this case the order of evaluation is not relevant, and the previous
pa(cid:138)ern is equivalent to:
51 MATCH (n: Person )
52
53

OPTIONAL (n) -[: livesIn ] - >( a)
OPTIONAL (n) -[: worksAt ] - >( c)

However, the order of evaluation can be relevant if the optional blocks of a pa(cid:138)ern shared some variables that are not
mentioned in the (cid:128)rst pa(cid:138)ern. For example, in the following expression the variable a is mentioned in the optional
blocks but not in the (cid:128)rst pa(cid:138)ern (n:Person):
54 MATCH (n: Person )
55
56

OPTIONAL (n) -[: worksAt ] - >( a)
OPTIONAL (n) -[: livesIn ] - >( a)

Arguably, such a pa(cid:138)ern is not natural, and it should not be allowed in practice. By imposing the simple syntactic
restriction that variables shared by optional blocks have to be present in their enclosing pa(cid:138)ern, one can ensure that
the semantics of a pa(cid:138)ern with multiple OPTIONAL blocks is independent of the evaluation order [31].

Weighted Shortest Paths. (cid:140)e (cid:128)nale of this section describes an example of expert (cid:128)nding: let us suppose that John
Doe wants to go to a Wagner Opera, but none of his friends likes Wagner. He thus wants to know which friend to ask
to introduce him to a true Wagner lover who lives in his city (or to someone who can recursively introduce him). To
optimize his chances for success, he prefers to try “friends” who actually communicate with each other. (cid:140)erefore we
look for the weighted shortest path over the wKnows (“weighted knows”) path pa(cid:136)ern towards people who like Wagner,
where the weight is the inverse of the number of messages exchanged: the more messages exchanged, the lower the
cost (though we add one to the divisor to avoid over(cid:131)ow). For each Wagner lover, we want a shortest path.

In G-CORE, weighted shortest paths are speci(cid:128)ed over basic path pa(cid:136)erns, de(cid:128)ned by a PATH .. WHERE .. COST clause,
because this allows to specify a cost value for each traversed path pa(cid:138)ern. (cid:140)e speci(cid:128)ed cost must be numerical, and
larger than zero (otherwise a run-time error will be raised), where the full cost of a path (to be minimized) is the sum of
the costs of all path segments. If the COST is omi(cid:138)ed, it defaults to 1 (hop count).
57 GRAPH VIEW social_graph2 AS (
58 PATH wKnows = (x) -[e: knows ] - >( y)
59
WHERE NOT ’ Acme ’ IN y. employer
60
COST 1 / (1 + e. nr_messages )
61 CONSTRUCT social_graph1 , (n) -/ @p : toWagner / - >( m)
62
(n: Person ) -/p <˜ wKnows * >/ - >( m: Person )
63
64
65
66

ON
WHERE (m) -[: hasInterest ] - >(: Tag { name = ’ Wagner ’})
AND (n) -[: isLocatedIn ] - >() < -[: isLocatedIn ] -( m)
AND n. firstName = ’ John ’ AND n. lastName = ’ Doe ’)

MATCH

social_graph1

(cid:140)e result of this graph view (social_graph2) was already depicted in Figure 5: it adds to social_graph1 two stored paths.
Apart from GRAPH VIEW name AS (query), and similar to CREATE VIEW in SQL which introduces a global name for a query

Manuscript submi(cid:138)ed to ACM

14

R. Angles et al.

Matching
Matching all pa(cid:138)erns (Homomorphism)
Matching literal values
Matching k shortest paths
Matching all shortest paths
Matching weighted shortest paths
(multi-segment) optional matching

*
18, 22
24
29
60
44

(cid:139)erying multiple graphs
(cid:139)eries on paths
Filtering matches
Filtering path expressions
Value joins
Cartesian product
List membership

Set operations on graphs
Existential subqueries
- Implicit
- Explicit

Graph construction
Graph aggregation
Graph projection
Graph views
Property addition

(cid:134)erying

6
69
4,8,13,18,26,30,34,59,64,71
58
8
11
13

Subqueries

Construction

8, 14, 19

27, 31, 35
36

*
21
23
39, 57
41

Table 1. Overview of G-CORE features and their line occurrences in the example queries in Section 3.

expression, G-CORE also supports a GRAPH name AS (query1) query2 clause which, similar to WITH in SQL, introduces a
name that is only visible inside query2.

Powerful Path Patterns. Basic PATH pa(cid:138)erns are a powerful building block that allow complex path expressions as
concatenations of these pa(cid:138)erns [43] using a Kleene star, yet still allow for fast Dijkstra-based evaluation. In G-CORE,
these path pa(cid:138)erns can even be non-linear shapes, as PATH can take a comma-separated list of multiple graph pa(cid:138)erns.
But, the path pa(cid:138)ern must contain a start and end node (a path segment), which is taken to be the (cid:128)rst and last node
in its (cid:128)rst graph pa(cid:138)ern. (cid:140)is ensures path pa(cid:138)erns can be stitched together to form paths – a path pa(cid:138)ern always
contains a path segment between its start and end nodes. (cid:140)ese basic path pa(cid:138)erns can also contain WHERE conditions,
without restrictions on their complexity. As John Doe wants his preference for Wagner to remain unknown at his work,
we exclude employees of Acme from occurring on the path3. (cid:140)e result of this query is a view social_graph2 in which all
these shortest paths from John Doe to Wagner lovers have been materialized (the @p in (n)-/@p:toWagner/->(m)).

A unique capability of G-CORE is to query and analyze databases of potentially many stored paths. We demonstrate

this in the (cid:128)nal query, where we score John’s friends for their aptitude:
67 CONSTRUCT (n) -[e: wagnerFriend { score := COUNT (*) }] - >( m)
68
69
70

WHEN e. score > 0
(n: Person ) -/ @p : toWagner / - >() , (m: Person )

social_graph2

MATCH

ON

3Note that non-linear path pa(cid:138)erns, such as PATH (a)-[]-(b),(b)-(c) add power over linear pa(cid:138)erns with existential (cid:128)lters: PATH (a)-[]-(b)WHERE
(b)-(c), because the la(cid:138)er cannot bind variables. In G-CORE, variable c can be used in a COST expression.
Manuscript submi(cid:138)ed to ACM

G-CORE

71

WHERE n = nodes (p) [1]

15

For the :toWagner paths, we use nodes(p)[1] to look at the second node in each path, i.e. a direct friend of John Doe.
G-CORE starts counting at 0 so nodes(my_path)[n] returns the n − 1 item from the list returned by the function nodes(),
which returns all nodes on a path. For these direct friends we count how o(cid:137)en they occur as the start of :toWagner paths.
(cid:140)ese scores has been a(cid:138)ached as a score property to new :wagnerFriend edges. Since in the toy example there are only
two Wagner lovers and thus two shortest paths to them, both via Peter, the result of this query is a single :wagnerFriend
edge between John and Peter with score 2.

4 FORMALIZING AND ANALYZING G-CORE
One of the main goals of this paper is to provide a formal de(cid:128)nition of the syntax and semantics of a graph query
language including the features shown in the previous sections. Formally, a G-CORE query is de(cid:128)ned by the following
top-down grammar:

query ::= headClause fullGraph(cid:137)ery

headClause ::= ε | pathClause headClause | graphClause headClause

fullGraph(cid:137)ery ::= basicGraph(cid:137)ery |

(fullGraph(cid:137)ery setOp fullGraph(cid:137)ery)

setOp ::= Union | Intersect | Minus
basicGraph(cid:137)ery ::= constructClause matchClause

(cid:140)us, a G-CORE query consists of a sequence of Path and Graph clauses, followed by a full graph query, i.e., a
combination of basic graph queries under the set operations of union, intersection and di(cid:130)erence. A basic graph query
consists of a single Construct clause followed by one Match clause. We have seen examples of all these features in
Section 3.

In Appendix A, we provide formal de(cid:128)nitions of the syntax and semantics of G-CORE. (cid:140)e basic idea of the language
is, given a PPG G, to create a new PPG H using the Construct clause. (cid:140)is is achieved, in turn, by applying an
intermediate step provided by the Match clause. (cid:140)e application of such a clause creates a set of bindings Ω, based on
a graph pa(cid:138)ern that is evaluated over G. (cid:140)e interaction between the Match and the Construct clause is explained
in more detail below:

• (cid:140)e result of evaluating the graph pa(cid:138)ern φ that de(cid:128)nes the content of a Match clause over a PPG G always

boolean conditions speci(cid:128)ed in the Where clause.

corresponds to a set Ω of bindings, which is denoted by(cid:74)φ(cid:75)G. (cid:140)e bindings in Ω can then be (cid:128)ltered by using
H, which is denoted by(cid:74)ψ(cid:75)Ω,G. Note that G is also an input in the evaluation of ψ, as the set of bindings Ω can

• A Construct clause ψ then takes as input both the PPG G and the set of bindings Ω, and produces a new PPG

make reference to objects whose labels and properties are de(cid:128)ned in G.

(cid:140)e role of the Path clause is to de(cid:128)ne complex path expressions, as well as the cost associated with them, that can
in turn be used in graph pa(cid:138)erns in the Match clause. In this way, it is possible to de(cid:128)ne rich navigational pa(cid:138)erns on
graphs that capture expressive query languages that have been studied in depth in the theoretical community (e.g., the
class of regular queries [34]).

Manuscript submi(cid:138)ed to ACM

16

R. Angles et al.

Complexity analysis. (cid:140)e G-CORE query language has been carefully designed to ensure that G-CORE queries can

be evaluated e(cid:129)ciently in data complexity. Formally, this means that for each (cid:128)xed G-CORE query q, the result(cid:74)q(cid:75)G of

evaluating q over an input PPG G can be computed in polynomial time. (cid:140)e main reasons that explain this fact are
given below.

First of all, graph pa(cid:138)erns correspond (essentially) to conjunctions of atoms expressing that two nodes are linked by
a path satisfying a certain regular expression over the alphabet of node and edge labels. (cid:140)e set Ω of all bindings of a
(cid:128)xed graph pa(cid:138)ern φ over the input PPG G can then be easily computed in polynomial time: we simply look for all
possible ways of replacing node and edge variables in φ by node and edge identi(cid:128)ers in G, respectively, and then for
each path variable π representing a path in G from node u to node v whose label must conform to a regular expression r,
we replace π by the shortest/cheapest path in G from u to v that satis(cid:128)es r (if it exists). (cid:140)is can be done in polynomial
time by applying standard automata-theoretic techniques in conjunction with Dijkstra-style algorithms. (Notice that
the la(cid:138)er would not be true if our semantics was based on simple paths; in fact, checking if there is a simple path in an
extended property graph whose label satis(cid:128)es a (cid:128)xed regular expression is an NP-complete problem [23]).

Suppose, now, that we are given a (cid:128)xed G-CORE query q that corresponds to a sequence of clauses followed by a
full graph query q(cid:48). Each clause is de(cid:128)ned by a graph pa(cid:138)ern φ whose evaluation corresponds to a binary relation over
the nodes of the input PPG G. By construction, the graph pa(cid:138)ern φ might mention binary pa(cid:138)erns which are de(cid:128)ned in
previous clauses. (cid:140)erefore, it is possible to iteratively evaluate in polynomial time all graph pa(cid:138)erns φ1, . . . , φk that
are mentioned in the clauses of q. Once this process is (cid:128)nished, we proceed to evaluate q(cid:48) (which is de(cid:128)ned in terms of
the φi’s).

By de(cid:128)nition, q(cid:48) is a boolean combination of full graph queries q1, . . . , qm. It is thus su(cid:129)cient to explain how to
evaluate each such a full graph query qj in polynomial time. We can assume by construction that qj consists of a
Construct clause applied over a Match clause. We (cid:128)rst explain how the set of bindings that satisfy the Match clause
can be computed in polynomial time. Since one or more Optional clauses could be applied over the Match clause,
the semantics is based on the set Ω of maximal bindings for the whole expression, i.e., those that satisfy the primary
graph pa(cid:138)ern expressed in the Match clause, and as many atoms as possible from the basic graph pa(cid:138)erns that de(cid:128)ne
the Optional clauses. (cid:140)e computation of Ω can be carried out in polynomial time by a straightforward extension of
the aforementioned techniques for e(cid:129)ciently evaluating basic graph pa(cid:138)erns. Finally, (cid:128)ltering Ω in accordance with
the boolean conditions expressed in the Where clause can easily be done in polynomial time (under the reasonable
assumption that such conditions can be evaluated e(cid:129)ciently). Recall that a possible such a condition is Exists Q, for Q
a subquery. We then need to check whether the evaluation of Q over G yields an empty graph. We inductively assume
the existence of an e(cid:129)cient algorithm for checking this.

Finally, the application of the Construct clause on top G and the set Ω of bindings generated by the Match clause
can be carried out in polynomial time. Intuitively, this is because the operations allowed in the Construct clause are
de(cid:128)ned by applying some simple aggregation and grouping functions on top of bindings generated by relational algebra
operations.

Given that all evaluation steps of G-CORE have polynomial complexity in data size, we conclude that G-CORE is

tractable.

Manuscript submi(cid:138)ed to ACM

G-CORE

17

5 EXTENSIONS OF G-CORE
Practical use of graphs o(cid:137)en requires handling tabular data. (cid:140)is suggests that extending G-CORE with additional
functionality for projecting tabular results or constructing graphs from imported tabular data may be useful.

Projecting tabular results. In order to integrate the results of graph matching into another system, it would be
necessary or at least convenient to be able to produce a tabular projection from a query. It is quite straightforward to
imagine the set of bindings produced by MATCH as a table, and use that to return a tabular projection. To achieve this,
G-CORE could be extended with a SELECT clause for projecting expressions into a table. Such a tabular projection clause
would also allow the introduction of other common relational operations for slicing, sorting, and aggregation, similar to
Cypher’s RETURN clause or the SELECT clauses of SQL or SPARQL. Furthermore, SELECT could be used for adding various
forms of expression-level subqueries, such as scalar subqueries or list subqueries.

Consider this example of a query that uses tabular projection:

72 SELECT m. lastName + ’, ’ + m. firstName AS friendName
73 MATCH (n: Person ) -/ <: knows * >/ - >( m: Person )
74
75

WHERE n. firstName = ’ John ’ AND n. lastName = ’ Doe ’

AND (n) -[: isLocatedIn ] - >() < -[: isLocatedIn ] -( m)

(cid:140)is query matches persons with the name “John Doe” together with indirect friends that live in the same city and

returns a table with the names of these friends.

It should be noted that the introduction of tabular projection into G-CORE changes the language to a multi-sorted
language that is capable of either producing a table or a graph. Such a language would no longer be fully closed under
graphs in a strict sense, which is one reason why this extension has been le(cid:137) to the future.

Importing tabular data. Conversely, integration of G-CORE with existing systems raises the question of how preexisting 
tabular data could be processed in a pure graph query language. Next we present two di(cid:130)erent alternative
proposals for how tabular data could be brought in to the graph world of G-CORE.

Binding table inputs. One way to import tabular data would be through the introduction of a new FROM <table> clause
that would import sets of scalar bindings from a table, which could be used for de(cid:128)ning a graph using the CONSTRUCT
clause such as in this example:
76 CONSTRUCT
77
78
79
80 FROM orders

( cust GROUP custName : Customer { name := custName }) ,
( prod GROUP prodCode : Product { code := prodCode }) ,
( cust ) -[: bought ] - >( prod )

(cid:140)is will construct a new graph from an input table of customer names custName and product codes prodCode by

connecting per-customer and per-product nodes as given by the table.

Interpreting tables as graphs. Another alternative is to allow the MATCH .. ON .. to treat a tabular input following ON
as a graph consisting of only isolated nodes that correspond to each row in the table. (cid:140)e properties of these nodes are
the columns of the table and the values are the (cid:128)elds of the corresponding row.

If we express the previous example using this syntax, it would now look as follows:

81 CONSTRUCT

Manuscript submi(cid:138)ed to ACM

18

R. Angles et al.

( cust GROUP o. custName : Customer { name := o. custName }) ,
( prod GROUP o. prodCode : Product { code := o. prodCode }) ,
( cust ) -[: bought ] - >( prod )

82
83
84
85 MATCH (o) ON orders

6 DISCUSSION AND RELATED WORK
Graph query languages have been extensively researched in the past decades, and comprehensive surveys are available.
Angles and Gutierrez [8] surveyed GQLs proposed during the eighties and nineties, before the emergence of current
(practical) graph database systems. Wood [45] studied GQLs focusing on their expressive power and computational
complexity. Angles [5] compares graph database systems in terms of their support for essential graph queries. Bar-
cel´o [11] studies the expressiveness and complexity of several navigational query languages. Recently, Angles et al. [6]
presented a study on fundamental graph querying functionalities (mainly graph pa(cid:138)erns and navigational queries) and
their implementation in modern graph query languages.

(cid:140)e extensive research on querying graph databases has not give rise yet to a standard query language for property
graphs (like SQL for the relational model). Nevertheless, there are several industrial graph database products on the
market. Gremlin [18] is a graph-based programming language for property graphs which makes extensive use of
XPath to support complex graph traversals. Cypher [13], originally introduced by Neo4j and now implemented by a
number of vendors, is a declarative query language for property graphs that has graph pa(cid:138)erns and path queries as
basic constructs. We primarily consider version 9 of Cypher as outlined by [17, 26], while recognizing that Cypher is an
evolving language where several advancements compared to Cypher 9 have already been made. Oracle has developed
PGQL [43], a graph query languages that is closely aligned to SQL and that supports powerful regular path expressions.
Several implementations of PGQL, both for non-distributed [38] and distributed systems [36], exist. Here, we consider
PGQL 1.1 [29], which is the most recent version that is commercially available [28].

G-CORE has been designed to support most of the main and relevant features provided by Cypher, PGQL, and
Gremlin. Next we describe the main di(cid:130)erences among G-CORE, Cypher, PGQL, and Gremlin based on the query
features described in Section 3. Some features (e.g. aggregate operators) will not be discussed here as there are not
substantial di(cid:130)erences from one language to other.

Graph pattern queries. (cid:140)e notion of basic graph pa(cid:138)ern, i.e. the conjunction of node-edge-node pa(cid:138)erns with (cid:128)lter
conditions over them, is intrinsically supported by Cypher, PGQL and G-CORE. Some di(cid:130)erences arise regarding the
support for complex graph pa(cid:138)erns (i.e. union, di(cid:130)erence, optional). Both Cypher and G-CORE de(cid:128)ne the UNION
operator to merge the results of two graph pa(cid:138)erns. (cid:140)e absence of graph pa(cid:138)erns (negation) is mainly supported via
existential subqueries. It is expressed in G-CORE, Cypher and PGQL with the WHERE NOT (EXISTS) clause. Optional
graph pa(cid:138)erns can be explicitly declared in G-CORE and Cypher with the OPTIONAL clause. PGQL does not support
optional graph pa(cid:138)erns, although they can be roughly simulated with length-restricted path expressions (see below).
Although Gremlin is focused on navigational queries, it supports complex graph pa(cid:138)erns (including branches and
cycles) as the combination of traversal pa(cid:138)erns.

Path queries. G-CORE, Cypher and PGQL support path queries in terms of regular path expressions (i.e. edges can
be labeled with regular expressions). (cid:140)e main di(cid:130)erence between Cypher 9 and PGQL is that the closure operator is
restricted to a single repeated label / value. Both Cypher and PGQL support path length restrictions, a feature that
Manuscript submi(cid:138)ed to ACM

G-CORE

19

although can be simulated using regular expressions, improves the succinctness of the language. Gremlin supports
arbitrary or (cid:128)xed iteration of any graph traversal (i.e. it is more expressive than regular path queries). Similar to Cypher,
Gremlin allows specifying the number of times a traversal should be performed.

(cid:134)ery output. (cid:140)e general approach followed by Cypher 9 and PGQL is to return tables with atomic values (e.g.
property values). (cid:140)is approach can be extended such that a result table can contain complex values. (cid:140)e extension in
Cypher 9 allows returning nodes, edges, and paths. Recent implementations of Cypher have the ability to return graphs
alongside this table [1, 32]. Gremlin also supports returning complete paths as results. In contrast, G-CORE has been
designed to return graphs with paths as (cid:128)rst class citizens.

(cid:134)ery composition. With the output of a query in G-CORE being a graph, it follows naturally that queries can be
composed by querying the output of one query by means of another query. Neither Cypher 9, PGQL or SPARQL supports
this capability. Gremlin supports creating graphs and then populate them before querying the new graph. A notable
parallel to G-CORE is the evolution of Cypher 10, where queries are composed through the means of “table-graphs”.
Cypher 10 expresses queries with multiple graphs and a driving table as input, and produces a set of graphs along with
a table as output. (cid:140)is allows Cypher 10 queries to compose both linearly and through correlated subqueries [17].

Evaluation semantics. (cid:140)ere are several variations among the languages regarding the semantics for evaluating
graph and path expressions. In the context of graph pa(cid:138)ern matching semantics, G-CORE, PGQL, and Gremlin follow
the homomorphism-based semantics (i.e. no restrictions are imposed during matching), and Cypher 9 follows a no-
repeated-edge semantics (i.e. two variables cannot be bound to the same term in a given match) to prevent matching
of potentially in(cid:128)nite result sets when enumerating all paths of a pa(cid:138)ern. With respect to the evaluation of path
expressions, G-CORE uses shortest-path semantics (i.e. paths of minimal length are returned), Cypher 9 implements
no-repeated-edge semantics (i.e. each edge occurs at most once in the path), and Gremlin follows arbitrary path
semantics (i.e. all paths are considered). Additionally, Cypher 9 and PGQL allow changing the default semantics by
using built-in functions (e.g. allShortestPaths).

Expressive power versus e(cid:129)ciency. A balance between expressiveness and e(cid:129)ciency (complexity of evaluation)
means a balance between practice and theory. Currently no industrial graph query language has a theoretical analysis
of its complexity and, conversely, theoretical results have not been systematically translated into a design. One of the
main virtues of G-CORE is that its design is the integration of both sources of knowledge and experience.

SPARQL and RDF. In this paper we concentrated on property graphs, but there are other data models and query
languages available. A well-known alternative is the Resource Description Framework (RDF), a W3C recommendation
that de(cid:128)nes a graph-based data model for describing and publishing Web metadata. RDF has a standard query language,
SPARQL [33], which was designed to support several types of complex graph pa(cid:138)erns (including union and optional).
Its latest version, SPARQL 1.1 [19], adds support for negation, regular path queries (called property paths), subqueries
and aggregate operators. (cid:140)e path queries support reachability tests, but paths cannot be returned, nor can the cost of
paths be computed. (cid:140)e evaluation of SPARQL graph pa(cid:138)erns follows a homomorphism-based bag semantics, whereas
property paths are evaluated using an arbitrary paths semantics [6]. SPARQL allows queries that return RDF graphs,
however creating graphs consisting of multiple types of nodes (e.g., belonging to di(cid:130)erent RDF schema classes; having
di(cid:130)erent properties) in one query is not possible as SPARQL lacks (cid:131)exible graph aggregation: its CONSTRUCT directly

Manuscript submi(cid:138)ed to ACM

20

R. Angles et al.

instantiates a single binding table without reshaping. Such constructed RDF graphs can not be reused as subqueries,
that is, for composing queries; nor does the language o(cid:130)er “full graph” operations to union or di(cid:130) at the graph level.
We think the ideas outlined in G-CORE could also inspire further development of SPARQL.

7 CONCLUSIONS
Graph databases have come of age. (cid:140)e number of systems, databases and query languages for graphs, both commercial
and open source, indicates that these technologies are gaining wide acceptance [3, 4, 9, 12, 14, 21, 24, 25, 30, 37–42].

At this stage, it is relevant to begin making e(cid:130)orts towards interoperability of these systems. A language like G-CORE

could work as a base for integrating the manifold models and approaches towards querying graphs.

We defend here two principles we think should be at the foundations of the future graph query languages: composability,
 that is, having graphs and their mental model as departure and ending point and treat the most popular feature
of graphs, namely paths, as (cid:128)rst class citizens.

(cid:140)e language we present, G-CORE, which builds on the experiences with working systems, as well as theoretical
results, show these desiderata are not only possible, but computationally feasible and approachable for graph users.
(cid:140)is paper is a call to action for the stakeholders driving the graph database industry.

REFERENCES
[1] 2017. Cypher for Apache Spark. (2017). h(cid:138)ps://github.com/opencypher/cypher-for-apache-spark
[2] 2017. (cid:140)e openCypher Project. (2017). h(cid:138)p://www.openCypher.org
[3] AgensGraph - (cid:140)e Performance-Driven Graph Database. 2017. (2017). h(cid:138)p://www.agensgraph.com/
[4] Amazon Neptune - Fast, reliable graph database build for cloud. 2017. (2017). h(cid:138)ps://aws.amazon.com/neptune/
[5] Renzo Angles. 2012. A comparison of current graph database models. In 4rd Int. Workshop on Graph Data Management: Techniques and Applications.
[6] Renzo Angles, Marcelo Arenas, Pablo Barcel´o, Aidan Hogan, Juan L. Reu(cid:138)er, and Domagoj Vrgoc. 2017. Foundations of Modern Graph (cid:139)ery

Languages. Comput. Surveys 50, 5 (2017). h(cid:138)ps://doi.org/10.1145/280277.280279

[7] Renzo Angles, Peter Boncz, Josep Larriba-Pey, Irini Fundulaki, (cid:140)omas Neumann, Orri Erling, Peter Neubauer, Norbert Martinez-Bazan, Venelin
Kotsev, and Ioan Toma. 2014. (cid:140)e Linked Data Benchmark Council: A Graph and RDF Industry Benchmarking E(cid:130)ort. SIGMOD Record 43, 1 (May
2014), 27–31.

[8] Renzo Angles and Claudio Gutierrez. 2008. Survey of graph database models. ACM Computing Surveys (CSUR) 40, 1 (2008), 1–39.
[9] ArangoDB - Native multimodel database. 2017. (2017). h(cid:138)ps://arangodb.com/
[10] Pablo Barcel´o, Leonid Libkin, Anthony W. Lin, and Peter T. Wood. 2012. Expressive Languages for Path (cid:139)eries over Graph-Structured Data. TODS

37, 4, Article 31 (Dec. 2012), 46 pages.

[11] Pablo Barcel´o Baeza. 2013. (cid:139)erying graph databases. In Proc. of the 32nd Symposium on Principles of Database Systems (PODS). ACM, 175–188.
[12] Blazegraph. 2017. (2017). h(cid:138)ps://www.blazegraph.com/
[13] Cypher - Graph (cid:139)ery Language. 2017. (2017). h(cid:138)p://neo4j.com/developer/cypher-query-language/
[14] DataStax Enterprise Graph. 2017. (2017). h(cid:138)ps://www.datastax.com/products/datastax-enterprise-graph
[15] Anton Dries, Siegfried Nijssen, and Luc De Raedt. 2009. A (cid:139)ery Language for Analyzing Networks. In Proc. of the 18th ACM Conference on

Information and Knowledge Management (CIKM). ACM, 485–494.

[16] Orri Erling, Alex Averbuch, Josep Larriba-Pey, Hassan Cha(cid:128), Andrey Gubichev, Arnau Prat, Minh-Duc Pham, and Peter Boncz. 2015. (cid:140)e LDBC

Social Network Benchmark: Interactive Workload. In SIGMOD2015. ACM, 619–630.

[17] Nadime Francis, Alastair Green, Paolo Guagliardo, Leonid Libkin, Tobias Lindaaker, Victor Marsault, Stefan Plantikow, Mats Rydberg, Petra Selmer,

and Andr´es Taylor. 2018. Cypher: An Evolving (cid:139)ery Language for Property Graphs. (2018).

[18] Gremlin - A graph traversal language. 2017. (2017). h(cid:138)ps://github.com/tinkerpop/gremlin
[19] Steve Harris and Andy Seaborne. 2013. SPARQL 1.1 (cid:139)ery Language - W3C Recommendation. h(cid:138)ps://www.w3.org/TR/sparql11-query/. (March 21

2013).

[20] Alexandru Iosup, Tim Hegeman, Wing Lung Ngai, Stijn Heldens, Arnau Prat-P´erez, (cid:140)omas Manhardt, Hassan Cha(cid:128), Mihai Capot˘a, Narayanan
Sundaram, Michael Anderson, Ilie Gabriel T˘anase, Yinglong Xia, Lifeng Nai, and Peter Boncz. 2016. LDBC Graphalytics: A Benchmark for Large-scale
Graph Analysis on Parallel and Distributed Platforms. PVLDB 9, 13 (Sept. 2016), 1317–1328.
JanusGraph - Distributed graph database. 2017. (2017). h(cid:138)p://janusgraph.org/

[21]
Manuscript submi(cid:138)ed to ACM

G-CORE

21

[22] Venelin Kotsev, Orri Erling, Atanas Kiryakov, Irini Fundulaki, and Vladimir Alexiev. 2017. (cid:140)e Semantic Publishing Benchmark v2.0. (2017).

github.com/ldbc/ldbc spb bm 2.0/blob/master/doc/LDBC SPB v2.0.docx

[23] Alberto O. Mendelzon and Peter T. Wood. 1995. Finding Regular Simple Paths in Graph Databases. SIAM J. Comput. 24, 6 (1995), 1235–1258.
[24] Microso(cid:137) Azure Cosmos DB. 2017. (2017). h(cid:138)ps://docs.microso(cid:137).com/en-us/azure/cosmos-db/introduction
[25] Neo4j. 2017. (cid:140)e Neo4j Developer Manual v3.3. (2017).
[26] openCypher. 2017. Cypher (cid:139)ery Language Reference, Version 9. (2017). h(cid:138)ps://github.com/opencypher/openCypher/blob/master/docs/openCypher9.pdf.
[27] (cid:140)e openCypher implementer’s group. 2017. Property Graph Model. (2017). h(cid:138)ps://github.com/opencypher/openCypher/blob/master/docs/

property-graph-model.adoc

[28] Oracle. 2017.

Oracle Big Data Spatial and Graph.

(2017).

h(cid:138)p://www.oracle.com/technetwork/database/database-technologies/

bigdata-spatialandgraph/

[29] Oracle. 2017. PGQL 1.1 Speci(cid:128)cation. (2017). h(cid:138)p://pgql-lang.org/spec/1.1/
[30] OrientDB - Multi-Model Database. 2017. (2017). h(cid:138)p://orientdb.com/
Jorge P´erez, Marcelo Arenas, and Claudio Gutierrez. 2009. Semantics and complexity of SPARQL. ACM Trans. Database Syst. 34, 3 (2009), 16:1–16:45.
[31]
[32] Stefan Plantikow, Martin Junghanns, Petra Selmer, and Max Kießling. 2017. Cypher and Spark: Multiple Graphs and More in openCypher. (2017).

h(cid:138)ps://www.youtube.com/watch?v=EaCFxDxhtsI

[33] Eric Prud’hommeaux and Andy Seaborne. 2008. SPARQL (cid:139)ery Language for RDF - W3C Recommendation. h(cid:138)ps://www.w3.org/TR/rdf-sparql-

query/. (2008).
Juan L. Reu(cid:138)er, Miguel Romero, and Moshe Y. Vardi. 2017. Regular (cid:139)eries on Graph Databases. (cid:138)eory Comput. Syst. 61, 1 (2017), 31–83.

[34]
[35] Marko A. Rodriguez and Peter Neubauer. 2010. Constructions from Dots and Lines. Bulletin of the American Society for Information Science and

Technology 36, 6 (Aug. 2010), 35–41.

[36] Nicholas P Roth, Vasileios Trigonakis, Sungpack Hong, Hassan Cha(cid:128), Anthony Po(cid:138)er, Boris Motik, and Ian Horrocks. 2017. PGX.D/Async: A

Scalable Distributed Graph Pa(cid:138)ern Matching Engine. (2017).

[37] Michael Rudolf, Marcus Paradies, Christof Bornh¨ovd, and Wolfgang Lehner. 2013. (cid:140)e Graph Story of the SAP HANA Database.. In BTW, Vol. 13.

403–420.

[38] Martin Sevenich, Sungpack Hong, Oskar van Rest, Zhe Wu, Jayanta Banerjee, and Hassan Cha(cid:128). 2016. Using domain-speci(cid:128)c languages for analytic

graph databases. Proceedings of the VLDB Endowment 9, 13 (2016), 1257–1268.

[39] Sparksee - Scalable high-performance graph database. 2017. (2017). h(cid:138)p://www.sparsity-technologies.com/#sparksee
[40] Stardog - (cid:140)e Knowledge Graph Platform for the Enterprise. 2017. (2017). h(cid:138)p://www.stardog.com/
[41] TigerGraph - (cid:140)e First Native Parallel Graph. 2017. (2017). h(cid:138)ps://www.tigergraph.com/
[42] Titan - Distributed Graph Database. 2017. (2017). h(cid:138)p://titan.thinkaurelius.com/
[43] Oskar van Rest, Sungpack Hong, Jinha Kim, Xuming Meng, and Hassan Cha(cid:128). 2016. PGQL: a property graph query language. In GRADES2016.

ACM, 7.

[44] Hannes Voigt. 2017. Declarative Multidimensional Graph (cid:139)eries, Patrick Marcel and Esteban Zim´anyi (Eds.). Business Intelligence – 6th European

Summer School, eBISS 2016, Tours, France, July 3-8, 2016, Tutorial Lectures 280, 1–37.

[45] Peter T. Wood. 2012. (cid:139)ery languages for graph databases. SIGMOD Record 41, 1 (2012), 50–60.

A A FORMAL DEFINITION OF G-CORE
In this section we formally present the semantics of G-CORE queries. For ease of presentation, we focus on a simpli(cid:128)ed
syntax equal in expressive power to the full syntax of the language.

A.1 Basic notions
G-CORE queries are recursively de(cid:128)ned by the top-down grammar presented in Section 4. In this section we de(cid:128)ne in
detail the di(cid:130)erent components of the G-CORE grammar. But before doing so, it is important to introduce some basic
notions that are used in the de(cid:128)nition of their semantics.

Recall the domains used by the PPG data model as de(cid:128)ned in Section 2. Let L be an in(cid:128)nite set of label names for
nodes, edges and paths, K an in(cid:128)nite set of property names and V an in(cid:128)nite set of literals (i.e. actual values like
integers).

Paths conforming to regular expressions. In graph query languages, one is typically interested in checking if two
nodes are linked by a path whose label satis(cid:128)es a regular expression r, and computing one (or more) of such paths if
Manuscript submi(cid:138)ed to ACM

22

R. Angles et al.

needed. Some graph query languages. e.g., Cypher 9 [17], de(cid:128)ne the semantics of path expressions based on simple
paths only (those without repetition of nodes and/or edges), which is known to easily lead to intractability in data
complexity [23]. For this reason, in G-CORE we follow a long tradition of graph query languages introduced in the
last 30 years and de(cid:128)ne the semantics of path expressions based on arbitrary paths (see, e.g., [6]). In addition, for the
problem of computing a path from node u to node v that satis(cid:128)es a given regular expression r, we choose to compute
the shortest such a path according to a (cid:128)xed lexicographical order on nodes.4 (cid:140)e reason for this is that checking for
the existence of an arbitrary path in a PPG G from u to v that conforms to a regular expression r, and computing the
shortest path that witnesses this fact, can be done in polynomial time by applying standard automata techniques in
combination with depth-(cid:128)rst search. We de(cid:128)ne the notion of (shortest) paths conforming to regular expressions below.
We start by de(cid:128)ning the notion of regular expression used in G-CORE. A regular expression r is speci(cid:128)ed by the

grammar:

::=

r

| (cid:96) | (cid:96)

− | !(cid:96) | (r + r) | (rr) | (r)∗

,

where (cid:96) ∈ L. Intuitively, an expression of the form either (cid:96) or (cid:96)−, with (cid:96) ∈ L, refers to an edge label, while !(cid:96) refers to a
node label. (cid:140)e expression is used as a wildcard that stands for “any label”. Notice that under this de(cid:128)nition, the
alphabet of every regular expression is a (cid:128)nite subset of { } ∪ L ∪ {(cid:96)− | (cid:96) ∈ L} ∪ {!(cid:96) | (cid:96) ∈ L}.

Let G = (N , E, P, ρ, δ, λ, σ) be a PPG and L = [a1, e1, a2, . . . , an, en, an+1] be a path over G. (cid:140)en given a regular
expression r, we say that L is a path from a1 to an+1 conforming to r if there exists a string u1v2u2 . . . unvn+1, un+1 in
the regular language de(cid:128)ned by r such that:

• For each i ∈ {1, . . . , n + 1}, either ui = or ui = !(cid:96) for some (cid:96) ∈ λ(ai).
• For each j ∈ {1, . . . , n}, either

– vj = , or
– ρ(ej) = (aj , aj+1) and vj = (cid:96) for some (cid:96) ∈ λ(ej), or
– ρ(ej) = (aj+1, aj) and vj = (cid:96)− for some (cid:96) ∈ λ(ej).

(cid:140)e length of a path L = [a1, e1, a2, . . . , an, en, an+1], wri(cid:138)en length(L), is n. (cid:140)en L is a shortest path from a node
a to a node b conforming to a regular expression r, if for every path L(cid:48) from a to b that conforms to r, it holds that
length(L) ≤ length(L(cid:48)).
Bindings. From now on, we assume that N, E and P are countably in(cid:128)nite sets of node, edge and path variables,
respectively, which are pairwise disjoint. Let G = (N , E, P, ρ, δ, λ, σ) be a PPG. A binding µ over G is a partial function
µ : (N ∪ E ∪ P) → (N ∪ E ∪ P) such that µ(x) ∈ N if x ∈ N, µ(y) ∈ E if y ∈ E, and µ(z) ∈ P if z ∈ P. (cid:140)e domain
of a binding µ is denoted by dom(µ), and it is assumed to be (cid:128)nite. Two bindings µ1 and µ2 are said to be compatible,
denoted by µ1 ∼ µ2, if for every variable x ∈ dom(µ1) ∩ dom(µ2), it holds that µ1(x) = µ2(x). Notice that if µ1 and µ2
are compatible bindings, then µ1 ∪ µ2 is a well-de(cid:128)ned function.

4We acknowledge that using a (cid:128)xed lexicographical order could be too restrictive when choosing a single path, so a system implementing G-CORE could
use a di(cid:130)erent criterion based, for instance, on whether it can be evaluated more e(cid:129)ciently.
Manuscript submi(cid:138)ed to ACM

G-CORE

23

Let Ω1, Ω2 be (cid:128)nite sets of bindings over G. (cid:140)e following four basic operations will be extensively used in this

article:

Ω1 ∪ Ω2 = {µ | µ ∈ Ω1 or µ ∈ Ω2},
Ω1 1 Ω2 = {µ1 ∪ µ2 | µ1 ∈ Ω1, µ2 ∈ Ω2 and µ1 ∼ µ2},
Ω1 (cid:110) Ω2 = {µ1 | µ1 ∈ Ω1, µ2 ∈ Ω2 and µ1 ∼ µ2},
Ω1 (cid:114) Ω2 = {µ1 | µ1 ∈ Ω1 and (cid:64)µ2 ∈ Ω2, µ1 ∼ µ2},
Ω1 1 Ω2 = (Ω1 1 Ω2) ∪ (Ω1 (cid:114) Ω2).

Given a countably in(cid:128)nite set of value variables V disjoint from N, E and P, it is straightforward to extend our
de(cid:128)nition of bindings (and our presentation of the semantics of G-CORE) to capture assignments of literals to variables,
i.e., such an extended binding would be a partial function µ : (N ∪ E ∪ P ∪ V) → (N ∪ E ∪ P ∪ V) such that µ(x) ∈ V
if x ∈ V. For ease of presentation, however, we do not further consider such extended bindings in the sequel.
Expressions. We next de(cid:128)ne expressions ξ according to the following grammar:

ξ ::= x | x .k | x : (cid:96) | (cid:5)ξ | ξ (cid:12) ξ |

f (ξ , ξ , . . .) | Σ(ξ) | Exists q,

where x is a variable, k ∈ K is property key, (cid:96) ∈ L is a label, (cid:5) is a unary operator, (cid:12) is a binary operator, f is a built-in
function whose value only depends on its inputs and Σ is an aggregation function. Unary operators are boolean negation
Not, arithmetic negation −1, etc. Binary operators are comparisons such as =, (cid:44), <, ≤, Subset Of, In, . . ., boolean
operations such as And and Or, arithmetic operations on numbers and strings such as +,−,∗,/, . . ., etc. Built-in
functions include the standard ones for type casting, string, date and collection handling (e.g. Size) known from other
query languages, as well as graph-speci(cid:128)c function such as Labels, which returns the set of labels, and Nodes, and
Edges, which return the list of nodes and edges of o, respectively, when applied to an object identi(cid:128)er o. Aggregation
functions include the standard ones inherited from relational query languages, Count, Min, Max, Sum, Avg, etc. and
Collect to collect all values of the group into a collection.

(cid:140)e semantics of expressions inherited from other query languages is de(cid:128)ned in analogy with them, so we do not
repeat it here. We denote the evaluation of any such an expression ξ over a PPG G = (N , E, P, ρ, δ, λ, σ) and a set of

bindings Ω as(cid:74)ξ(cid:75)Ω,G. In any such a case,(cid:74)ξ(cid:75)Ω,G ∈ N ∪ E ∪ P ∪ L ∪ V (recall that V includes truth values ⊥ and (cid:62)).

(cid:140)e semantics of the G-CORE speci(cid:128)c expressions, on the other hand, is de(cid:128)ned as follows (where we denote by µ the
singleton binding set {µ}):

• If ξ is a variable x, then(cid:74)ξ(cid:75)µ,G =(cid:74)x(cid:75)µ,G = µ(x).
• If ξ = x .k, then(cid:74)ξ(cid:75)µ,G = σ((cid:74)x(cid:75)µ,G , k) = σ(µ(x), k).
• If ξ = x : (cid:96), then(cid:74)ξ(cid:75)µ,G = (cid:62) i(cid:130) (cid:96) ∈ λ((cid:74)x(cid:75)µ,G) i(cid:130) (cid:96) ∈ λ(µ(x)).
• If ξ = Labels(o), then(cid:74)ξ(cid:75)µ,G = λ((cid:74)o(cid:75)µ,G).
• If ξ = Nodes(o), then(cid:74)ξ(cid:75)µ,G = nodes((cid:74)o(cid:75)µ,G).
• If ξ = Edges(o), then(cid:74)ξ(cid:75)µ,G = edges((cid:74)o(cid:75)µ,G).
• If ξ = Exists q, then(cid:74)ξ(cid:75)µ,G = (cid:62) i(cid:130) (N (cid:44) ∅), assuming that(cid:74)q(cid:75)µ,G = (N , E, P, ρ, δ, λ, σ).

Manuscript submi(cid:138)ed to ACM

24

A.2 The MATCH clause

R. Angles et al.

Basic graph patterns. A basic graph pa(cid:136)ern is speci(cid:128)ed by the following grammar:

basicGraphPa(cid:136)ern ::= nodePa(cid:136)ern | edgePa(cid:136)ern | pathPa(cid:136)ern

nodePa(cid:136)ern ::= (x)
edgePa(cid:136)ern ::= x

pathPa(cid:136)ern ::= x

z−−→ y
@w in r

y | x

w in r

y

de(cid:128)ned:

where x, y ∈ N, z ∈ E, w ∈ P, and r is a regular expression.

Let α be a basic graph pa(cid:138)ern. (cid:140)e evaluation of α over a PPG G = (N , E, P, ρ, δ, λ, σ), denoted by(cid:74)α(cid:75)G, is inductively
• If α is a node pa(cid:138)ern (x), then(cid:74)α(cid:75)G = {µ | dom(µ) = {x} and µ(x) ∈ N}.

@w in r

z−→ y, then(cid:74)α(cid:75)G = {µ | dom(µ) = {x, y, z}, µ(x), µ(y) ∈ N , µ(z) ∈ E and ρ(µ(z)) =
y, then(cid:74)α(cid:75)G = {µ | dom(µ) = {x, y, w}, µ(x), µ(y) ∈ N , µ(w) ∈ P and δ(µ(w))
y, then(cid:74)α(cid:75)G = {µ | dom(µ) = {x, y, w}, µ(x), µ(y) ∈ N , and µ(w) is a fresh

w in r

path identi(cid:128)er (i.e., µ(w) (cid:60) P) associated to the shortest path L from µ(x) to µ(y) over G that conforms to r}.

• If α is an edge pa(cid:138)ern x

(µ(x), µ(y))}.

• If α is a path pa(cid:138)ern x

• If α is a path pa(cid:138)ern x

is the shortest path from µ(x) to µ(y) that conforms to r}.

Basic graph patterns with location and full graph patterns. Basic graph pa(cid:138)erns can be evaluated over di(cid:130)erent
graphs in G-CORE. More speci(cid:128)cally, we use an On operator to specify the location where a basic graph pa(cid:138)ern has to
be evaluated:

basicGraphPa(cid:136)ernLocation ::= basicGraphPa(cid:136)ern |

basicGraphPa(cid:136)ern On location

location ::= gid | fullGraph(cid:137)ery,

where gid is a graph identi(cid:128)er and fullGraph(cid:137)ery is as de(cid:128)ned in the G-CORE grammar given in Section 4. For reasons

that will become clear later, we can always assume the evaluation(cid:74)α(cid:75)G of a full graph query α over a PPG G to be

another PPG H.

To de(cid:128)ne the semantics of basic graph pa(cid:138)erns with location, we assume given a function gr that associates an
actual graph, denoted by gr(gid), to every graph identi(cid:128)er gid. (cid:140)en given a basic graph pa(cid:138)ern with location β, the

evaluation of β over a PPG G, denoted by(cid:74)β(cid:75)G, is de(cid:128)ned as follows.

• If β is α On gid, where α is a basic graph pa(cid:138)ern and gid is a graph identi(cid:128)er, then(cid:74)β(cid:75)G =(cid:74)α(cid:75)gr(gid).
• If β is α On Q, where α is a basic graph pa(cid:138)ern, Q is a full graph query, and H =(cid:74)Q(cid:75)G, then(cid:74)β(cid:75)G =(cid:74)α(cid:75)H .

Manuscript submi(cid:138)ed to ACM

G-CORE

25

Finally, a full graph pa(cid:138)ern is de(cid:128)ned as a sequence of basic graph pa(cid:138)erns with locations separated by comma:

fullGraphPa(cid:136)ern ::= basicGraphPa(cid:136)ernLocation |

basicGraphPa(cid:136)ernLocation, fullGraphPa(cid:136)ern

recursive rule:

To de(cid:128)ne the evaluation of such pa(cid:138)ern γ over a PPG G, denoted by(cid:74)γ(cid:75)G, we only need to consider the following
• If γ is a β, γ (cid:48), where β is a basic graph pa(cid:138)ern with location and γ (cid:48) is a full graph pa(cid:138)ern, then(cid:74)γ(cid:75)G =(cid:74)β(cid:75)G 1
(cid:74)γ (cid:48)(cid:75)G.

Conditions on binding tables. G-CORE includes a Where clause that allows to (cid:128)lter bindings according to some
boolean conditions. It is important to mention that this clause cannot be used to generate new bindings, it can only be
used to (cid:128)lter the bindings that are produced by a Match clause.

A Where clause can include conditions of the form Exists Q, where Q is a sub-query. Such a query evaluates to true
if the evaluation of Q is a non-empty PPG, and it evaluates to false otherwise. It is important to consider that Q can
share some variables with the outer query, which are considered as parameters as in the case of correlated subqueries
in SQL. (cid:140)us, in order to de(cid:128)ne the semantics of Exists Q, it is necessary to extend the de(cid:128)nition of the semantics of
full graph pa(cid:138)erns to consider some previously computed bindings. More precisely, given a full graph pa(cid:138)ern γ and a

set Ω of bindings, the evaluation of γ over G given Ω, denoted by(cid:74)γ(cid:75)Ω,G, is de(cid:128)ned as(cid:74)γ(cid:75)Ω,G =(cid:74)γ(cid:75)G (cid:110) Ω. Notice that
if Ω = {µ∅}, where µ∅ is the binding with empty domain, then(cid:74)γ(cid:75)Ω,G =(cid:74)γ(cid:75)G.

We now have the necessary ingredients to de(cid:128)ne the semantics of MATCH clauses with conditions. (cid:140)e syntax of

such expressions is given by the following grammar:

matchClause ::= Match fullGraphPa(cid:136)ern |

Match fullGraphPa(cid:136)ern Where BooleanCondition,

where BooleanCondition is a Boolean-valued expression, that is, an expression that evaluates to (cid:62) or ⊥ (expressions
are formally de(cid:128)ned in Section A.1). To de(cid:128)ne the evaluation of a MATCH clause over a PPG G given a set of Ω of
bindings, we only need to consider the following rule:

• If γ is a full graph pa(cid:138)ern and ξ is a Boolean-valued expression, then(cid:74)Match γ Where ξ(cid:75)Ω,G = {µ ∈(cid:74)γ(cid:75)Ω,G |
(cid:74)ξ(cid:75)µ,G = (cid:62)}.

Optional full graph patterns. In its most general version, full graph pa(cid:138)erns can also use an Optional operator
to include optional information if present. (cid:140)us, the general syntax of Match clauses is speci(cid:128)ed by the following
grammar:

fullGraphPa(cid:136)ernCondition ::= fullGraphPa(cid:136)ern |

fullGraphPa(cid:136)ern Where BooleanCondition

matchClause ::= Match fullGraphPa(cid:136)ernCondition |

Match fullGraphPa(cid:136)ernCondition optionalClause

Manuscript submi(cid:138)ed to ACM

26

R. Angles et al.

where optionalClause is given by the following grammar:

optionalClause ::= Optional fullGraphPa(cid:136)ernCondition |

Optional fullGraphPa(cid:136)ernCondition optionalClause

(cid:140)e semantics of the Optional operator is de(cid:128)ned by using the operator 1 on sets of bindings. More precisely, given a
sequence of full graph pa(cid:138)erns γ, γ1, . . ., γk, where k ≥ 1, and a sequence of Boolean conditions ξ, ξ1, . . ., ξk, we have
that:

(cid:74)Match γ Where ξ
Optional γ1 Where ξ1 · · · Optional γk Where ξk(cid:75)G, Ω =
((· · · (((cid:74)Match γ Where ξ(cid:75)G, Ω 1 (cid:74)Match γ1 Where ξ1(cid:75)G, Ω)

1 · · · ) · · · ) 1 (cid:74)Match γk Where ξk(cid:75)G, Ω).

Example. Consider Match γ Where ξ where

−−−−−−−−−→ w, y
locatedIn

γ = x
ξ = w.name = Houston.

−−−−−−−−−→ w, x
locatedIn

@z in (knows+knows−)∗

y

On the PPG G = (N , E, P, ρ, δ, λ, σ) given in Figure 2 and formalized in Section 2, we have that

locatedIn

(cid:74)γ(cid:75)G =(cid:74)x
−−−−−−−−−→ w(cid:75)G 1(cid:74)y
1(cid:74)x

@z in (knows+knows−)∗

= {{x (cid:55)→ 105, w (cid:55)→ 106}, {x (cid:55)→ 102, w (cid:55)→ 106}}

locatedIn

−−−−−−−−−→ w(cid:75)G

y(cid:75)G

1 {{y (cid:55)→ 102, w (cid:55)→ 106}, {y (cid:55)→ 105, w (cid:55)→ 106}}
1 {{z (cid:55)→ 301, x (cid:55)→ 105, y (cid:55)→ 102}}

= {{x (cid:55)→ 105, y (cid:55)→ 102, w (cid:55)→ 106}, {x (cid:55)→ 105, y (cid:55)→ 105, w (cid:55)→ 106},
{x (cid:55)→ 102, y (cid:55)→ 102, w (cid:55)→ 106}, {x (cid:55)→ 102, y (cid:55)→ 105, w (cid:55)→ 106}}
1 {{z (cid:55)→ 301, x (cid:55)→ 105, y (cid:55)→ 102}}

= {{x (cid:55)→ 105, y (cid:55)→ 102, w (cid:55)→ 106, z (cid:55)→ 301}}

and, le(cid:138)ing µ = {x (cid:55)→ 105, y (cid:55)→ 102, w (cid:55)→ 106, z (cid:55)→ 301} ∈(cid:74)γ(cid:75)G, we then have that
(cid:74)ξ(cid:75)µ,G =(cid:74)w.name = Houston(cid:75)µ,G = (cid:62).
(cid:140)erefore,(cid:74)Match γ Where ξ(cid:75)G = {{x (cid:55)→ 105, y (cid:55)→ 102, w (cid:55)→ 106, z (cid:55)→ 301}}.

A.3 The CONSTRUCT clause
(cid:140)e de(cid:128)nition of the Construct clause assumes (cid:128)nite set of variables B ⊂ N ∪ E ∪ P ∪ V. (cid:140)e set contains the
variables declared in all full graph pa(cid:138)erns of the Match clause. B is a syntactical property of a given query. We use
G∅ to denote an empty graph.
Manuscript submi(cid:138)ed to ACM

G-CORE

27

Syntax of Basic Construct Patterns. (cid:140)e basic constructs are speci(cid:128)ed by the following grammar:

basicConstruct ::= objectConstructsList |

objectConstructsList When ξ

objectConstructsList ::= gid | objectConstruct |

objectConstruct objectConstructsList

where gid is a graph identi(cid:128)er.

Object constructs with respect to the set of variables B are speci(cid:128)ed by the following grammar:

objectConstruct ::= nodeContruct | relationshipContruct

relationshipContruct ::= edgeContruct | pathContruct

nodeContruct ::= (x Group Γ; S)
z Group Γ;S
−−−−−−−−−−→ y
edgeContruct ::= x
@u;S

pathContruct ::= x

y

where x, y ∈ N, z ∈ E, u ∈ P, Γ ⊆ B is a grouping sets, S is a set of assignments, and o is the optional symbol @ (i.e.,
can appear or can be le(cid:137) out). Each object construct pa(cid:138)ern has a construct variable, which is unique within the basic
construct. For a node construct (x Group Γ; S), an edge construct x
y,
the construct variable is x, z, and u, respectively. In situation of ambiguity, we refer to Γ and S of a speci(cid:128)c object
construct ❕ by subscripting Γ and S with ❕’s construct variable.

z Group Γ;S
−−−−−−−−−−→ y, and a path construct x

@u;S

We further constrain the syntax of a basic construct b used in the context of a basic graph query, as follows.

• In each node construct appearing in b, if x ∈ B then Γ = {x}.
• In each edge construct x

z Group Γz;Sz
−−−−−−−−−−−−→ y appearing in b, it holds that

– node construct (x Group Γx; Sx) and (y Group Γy; Sy) must appearing in b;
– Γx ∪ Γy ∪ {x, y} ⊆ Γz; and
– if z ∈ B, then x, y ∈ B.
Furthermore, if z ∈ B, then Γz = {z} ∪ Γx ∪ Γy.

• In each path construct x

ou;S

y appearing in b, it must hold that a path pa(cid:138)ern x

match clause, i.e. x, y, u ∈ B. By de(cid:128)nition the grouping set for a path construct is Γ = {x, y, u}.

@u in r

y appears in the

(cid:140)e conditions ensure, that all object constructs in a basic construct form a valid directed graph and, hence, the use

of the When sub-clause can not cause the creation of dangling edges in the resulting PPG.

For the remaining cases, without loss of generality, we consider a basic construct b to be L When ξ, where L is
the set of all object constructs in b. We assume ξ = (cid:62) if the When sub-clause is not given in the query. It should be
Manuscript submi(cid:138)ed to ACM

Semantics of Basic Construct Patterns. (cid:140)e semantics of any basic construct b with respect to a set of bindings Ω
is a set of bindings. In case
where b is a graph identi(cid:128)er gid, the PPG resulting from the basic construct pa(cid:138)ern is the actual graph associated with

is a PPG and(cid:74)b(cid:75)bindings

Ω,G

Ω,G

evaluated on G, is a pair(cid:16)(cid:74)b(cid:75)graph
gid, i.e.(cid:74)gid(cid:75)graph

Ω,G ,(cid:74)b(cid:75)bindings
= gr(gid) and(cid:74)gid(cid:75)bindings

Ω,G

Ω,G

(cid:17), where the(cid:74)b(cid:75)graph

Ω,G

= {µ∅}.

28

R. Angles et al.

mentioned that the When sub-clause is not syntactic sugar. Since basic queries form the scope for variables, the When
sub-clause can not be rewri(cid:138)en to a full query with Union.

(cid:140)e semantics of a basic construct is de(cid:128)ned as:

Ω,G

(cid:74)L When ξ(cid:75)graph
(cid:74)L When ξ(cid:75)bindings

Ω,G

=

=

Ω,G

(cid:74)L(cid:75)graph
(cid:74)L(cid:75)bindings

Ω,G
{µ∅}

G∅

otherwise,

if(cid:74)ξ(cid:75)Ωξ ,G = (cid:62)
if(cid:74)ξ(cid:75)Ωξ ,G = (cid:62)

otherwise.

where Ωξ = Ω 1(cid:74)L When ξ(cid:75)bindings

Ω,G

. Note, that Ωξ ensures that the expression ξ in a When sub-clause can use

variables appearing the Match clause (B) as well as construct variables of the constructs.

For the semantics of L, let LN be the set of all node constructs in L and LR the set of all relationship constructs
(edge and path constructs) in L. We de(cid:128)ne the semantics of L such that the PPGs and the sets of bindings resulting
from evaluation of all object constructs in L are united and joined, respectively. (cid:140)e union of graphs is de(cid:128)ned as in
Section A.5. Further, we ensure that the evaluation of all relationship constructs (LR) is based on the set of bindings
resulting from the evaluation of all node constructs (LN ), so new edges connect to new nodes. (cid:140)e semantics of L is:

(cid:17)
= GN ∪(cid:16)
(cid:16)
(cid:17)
❕∈LR(cid:74)❕(cid:75)graph
(cid:74)L(cid:75)graph
(cid:74)L(cid:75)bindings
1❕∈LR (cid:74)❕(cid:75)bindings
=
(cid:74)LN(cid:75)graph
❕∈LN(cid:74)❕(cid:75)graph
= 1❕∈LN (cid:74)❕(cid:75)bindings
ΩN = Ω 1(cid:74)LN(cid:75)bindings
In the following we de(cid:128)ne the semantics object constructs and with that(cid:74)❕(cid:75)graph

= ΩN 1

GN =

ΩN ,G

ΩN ,G

Ω,G

Ω,G

Ω,G

Ω,G

Ω,G

Ω,G

Ω,G

.

with:

and(cid:74)❕(cid:75)bindings

Ω,G

.

Semantics of Object Construct Patterns. Let Ω be a set of bindings on PPG G = (N , E, P, ρ, δ, λ, σ). Given an object
construct ❕ with a grouping set Γ, we use grp(Ω, ❕) to denote the grouping of Ω according to the grouping set Γ of ❕.
(cid:140)e grouped set of bindings grp(Ω, ❕) is the set of equivalence classes of Ω according to the equivalence relation ∼Γ
such that µ1 ∼Γ µ2 if ∀x ∈ Γ, µ1(x) = µ2(x) with µ1, µ2 ∈ Ω.
In the following, we denote one equivalence class of grp(Γ, ❕) as Ω(cid:48) so that Ω(cid:48) ∈ grp(Γ, ❕) holds. Ω(cid:48) is a set of
bindings, where all µ ∈ Ω(cid:48) bind a grouping variable x ∈ Γ to the same value. We denote the value of a grouping
variable x in Ω(cid:48) as Ω(cid:48)(x). Further, we denote the projection of Ω(cid:48) to the grouping variables Γ as Ω(cid:48)(Γ) such that
(cid:16)(cid:74)❕(cid:75)graph
Ω(cid:48)(Γ) = {x (cid:55)→ Ω(cid:48)(x) | x ∈ Γ}.
Ω,G ,(cid:74)❕(cid:75)bindings
and(cid:74)❕(cid:75)bindings

(cid:140)e semantics of an object construct ❕ with grouping set Γ with respect to Ω evaluated on G is the pair

(cid:17) where(cid:74)❕(cid:75)graph

is the set of bindings de(cid:128)ned as

(cid:74)❕(cid:75)graph

is the PPG de(cid:128)ned as

Ω,G

Ω,G

Ω,G

Ω,G

Ω(cid:48),G

= 
Ω(cid:48)∈grp(Ω,❕)(cid:74)❕(cid:75)graph
= 
Ω(cid:48)∈grp(Ω,❕)(cid:74)❕(cid:75)bindings

Ω(cid:48),G

.

(cid:74)❕(cid:75)bindings

Ω,G

Manuscript submi(cid:138)ed to ACM

G-CORE

29

for each object construct, assuming G = (N , E, P, ρ, δ, λ, σ).

• If ❕ is a node construct (x Group Γ; S), then

Ω(cid:48),G

We next de(cid:128)ne the semantics of(cid:74)❕(cid:75)graph
(cid:74)❕(cid:75)graph
(cid:74)❕(cid:75)bindings

Ω(cid:48),G

Ω(cid:48),G

and(cid:74)❕(cid:75)bindings
= ({v} , ∅, ∅, ∅, ∅,(cid:74)S(cid:75)labels
x,v, Ω(cid:48),G ,(cid:74)S(cid:75)properties
(cid:48)(Γ)(cid:9)
= (cid:8){x (cid:55)→ v} ∪ Ω
x,v, Ω(cid:48),G )
if x ∈ B and Ω(cid:48)(x) is de(cid:128)ned
if x (cid:60) B.

v =

new(x, Ω(cid:48)(Γ))

where
Here new(x, Ω(cid:48)(Γ)) is a skolem function, returning a new distinct identi(cid:128)er for distinct values of x and Ω(cid:48)(Γ).
In case x ∈ B and Ω(cid:48)(x) is unde(cid:128)ned, then(cid:74)❕(cid:75)graph

Ω(cid:48),G

Ω(cid:48),G

= G∅ and(cid:74)❕(cid:75)bindings
= {µ∅}.
z Group Γ;S
−−−−−−−−−−→ y and Ω(cid:48)(x) and Ω(cid:48)(y) are de(cid:128)ned, then
z,e, Ω(cid:48),G ,(cid:74)S(cid:75)properties
= ({v, u} , {e} , ∅, {e (cid:55)→ (v, u)} , ∅,(cid:74)S(cid:75)labels
z,e, Ω(cid:48),G )
if z ∈ B and Ω(cid:48)(z) is de(cid:128)ned
if z (cid:60) B

= {{z → e} ∪ Ω

(cid:48)(Γ)}

e =

where
and v = Ω(cid:48)(x) and u = Ω(cid:48)(y). In case Ω(cid:48)(x) or Ω(cid:48)(y) is unde(cid:128)ned, or in case x ∈ B and Ω(cid:48)(x) is unde(cid:128)ned,
then(cid:74)❕(cid:75)graph

= {µ∅}. (cid:140)is prevents dangling edges.

Ω(cid:48),G

y and Ω(cid:48)(u) is de(cid:128)ned, then
(cid:48)
, {p} , {e (cid:55)→ ρ(e) | e ∈ edges(p)} , {p (cid:55)→ δ(p)} , λ

(cid:48)

, σ

(cid:48))

• If ❕ is an edge construct x

Ω(cid:48),G

Ω(cid:48),G

Ω(cid:48)(x)
(cid:74)❕(cid:75)graph
(cid:74)❕(cid:75)bindings
Ω(cid:48)(z)
new(z, Ω(cid:48)(Γ))
= G∅ and(cid:74)❕(cid:75)bindings
(cid:74)❕(cid:75)graph
(cid:74)❕(cid:75)bindings
Ω(cid:48),G
where p = Ω(cid:48)(u) and

Ω(cid:48),G
@u;S

Ω(cid:48),G

Ω(cid:48),G

• If ❕ is a path construct x

λ

(cid:48)
= (N
, E
(cid:48)({x, y}) ∪ {u (cid:55)→ p}}
= {Ω
(cid:48) = λ |nodes(u)∪edges(u) ∪(cid:74)S(cid:75)labels
(cid:48) = σ |nodes(u)∪edges(u) ∪(cid:74)S(cid:75)properties
= G∅ and(cid:74)❕(cid:75)bindings
y and Ω(cid:48)(u) is de(cid:128)ned, then

u,p, Ω(cid:48),G

Ω(cid:48),G

u;S

If Ω(cid:48)(u) is unde(cid:128)ned, then(cid:74)❕(cid:75)graph
Ω(cid:48)(u) is de(cid:128)ned, since u, x, and y are all bound by the same path pa(cid:138)ern in the Match clause.

u,p, Ω(cid:48),G
= {µ∅}. Note that Ω(cid:48)(x) and Ω(cid:48)(y) are de(cid:128)ned, if

Ω(cid:48),G

σ

• If ❕ is a path construct x

Ω(cid:48),G

(cid:74)❕(cid:75)graph
(cid:74)❕(cid:75)bindings
= {µ∅}.

Ω(cid:48),G

= (nodes(u), edges(u), ∅, {e (cid:55)→ ρ(e) | e ∈ edges(p)} , ∅, λ
= {Ω

(cid:48)({x, y})}

(cid:48)

, σ

(cid:48))

where λ(cid:48) = λ |nodes(u)∪edges(u) and σ (cid:48) = σ |nodes(u)∪edges(u). If Ω(cid:48)(u) is unde(cid:128)ned, then(cid:74)❕(cid:75)graph
(cid:74)❕(cid:75)bindings

Ω(cid:48),G

Ω(cid:48),G

= G∅ and

Set and Remove Assignments. In the practical syntax, Set and Remove assignments can appear either inlined in
the object pa(cid:138)ern or in the Set–Remove sub-clause of the Construct clause. In both cases, an assignment refers to a
Manuscript submi(cid:138)ed to ACM

30

R. Angles et al.

particular object construct by means of a construct variable. In the following, we assume all assignments are inlined
and appear in set of assignments S of the respective object construct.

For a construct variable x, a variable y ∈ B ∩ (N ∪ E ∪ P), a label l ∈ L, a property key k ∈ K, and an expression ξ,

assignments are syntactically de(cid:128)ned as follows:

• (+x = y), (+x : l), and (+x .k = ξ) are Set assignments;
• (−x : l), and (−x .k) are Remove assignments.

For a variable x and an object identi(cid:128)er o,

∪ λS) \ λR and (cid:74)S(cid:75)properties
{(o, k) (cid:55)→ v | (o, k) (cid:55)→ v ∈ σ ∧ ¬∃v(cid:48),(o, k) (cid:55)→ v(cid:48) ∈ σS}, and

x,o, Ω(cid:48),G

|o
= (σ |o ∪ σS) \ σR where λ |o is de(cid:128)ned as expected and σ |o =

the semantics of S is de(cid:128)ned as (cid:74)S(cid:75)labels

= (λ

x,o, Ω(cid:48),G

λS = (cid:8)o (cid:55)→ l | Ω
(cid:48)(y) (cid:55)→ l ∈ λ ∧ (+x = y) ∈ S(cid:9)
σS = (cid:8)(o, k) (cid:55)→ v |(cid:0)Ω
(cid:48)(y), k(cid:1) (cid:55)→ v ∈ σ ∧ (+x = y) ∈ S(cid:9)
∪ (cid:8)(o, k) (cid:55)→(cid:74)ξ(cid:75)Ω(cid:48),G | (+x .k = ξ) ∈ S(cid:9)

∪ {o (cid:55)→ l | (+x : l) ∈ S}
λR = {o (cid:55)→ l | (−x : l) ∈ S}

σR = {(o, k) (cid:55)→ v | (o, k) (cid:55)→ v ∈ σ ∧ (−x .k) ∈ S} .

In essence, all Set assignments override values of existing properties k and are applied before all Remove assignments,
so that any expression ξ used in a Set assignment sees all existing properties.

Full Construction Patterns. We now have the necessary ingredients to de(cid:128)ne the semantics of Construct clauses.
(cid:140)e syntax of such expressions is given by the following grammar:

constructClause ::= Construct fullConstruct

fullConstruct ::= basicConstruct | basicConstruct, fullConstruct

Note that we are not considering Set–Remove sub-clauses here.

Given a full construct f consisting of a set of basic constructs L, we de(cid:128)ne the semantics of Construct clause as

follow.

(cid:74)Construct f(cid:75)Ω,G = 

b∈L(cid:74)b(cid:75)graph

Ω,G

Example. Consider a Construct { f , ❕, h} When (cid:62) as shown in Line 21 without social_graph, where

f = (x Group {e} ; {(+x : Company) ,(+x .name = e)}),
❕ = (n Group {n} ; ∅), and h = n

y Group {x,e,n};{(+e:worksAt)}
−−−−−−−−−−−−−−−−−−−−−−−−−−−−→ x .

Let’s assume the Match clause has the following set of bindings when evaluated on the PPG G in Figure 2:

Ω = { {(n (cid:55)→ #Frank),(e (cid:55)→ #MIT)} , {(n (cid:55)→ #Frank),(e (cid:55)→ #CWI)} ,

{(n (cid:55)→ #Alice),(e (cid:55)→ #Acme)} , {(n (cid:55)→ #Celine),(e (cid:55)→ #HAL)} , {(n (cid:55)→ #John),(e (cid:55)→ #Acme)} }.

Manuscript submi(cid:138)ed to ACM

G-CORE

31

We then have(cid:74){ f , ❕, h}(cid:75)Ω,G = GN ∪(cid:74)h(cid:75)graph

ΩN ,G

with

GN =(cid:74)f(cid:75)graph

Ω,G ∪(cid:74)❕(cid:75)graph

Ω,G

= ({#HAL, #Acme, #MIT, #CWI} , ∅, ∅, ∅, ∅,
∪ ({#John, #Frank, #Alice, #Celine} , ∅, ∅, ∅, ∅,
= ({#HAL, #Acme, #MIT, #CWI, #John, #Frank, . . .} , . . .)

ΩN =(cid:74)(x Group {e} ; Sx)(cid:75)bindings

Ω,G

1(cid:74)(n Group {n} ; ∅)(cid:75)bindings

Ω,G

{#HAL (cid:55)→ :Company, . . .} , {(#HAL, name) (cid:55)→ ”HAL”, . . .})

{#John (cid:55)→ :Person, . . .} , {(#John, fristname) (cid:55)→ ”John”, . . .})

= Ω 1

1

=

e

x
#HAL ”HAL”
#Acme ”Acme”
#MIT ”MIT”
#CWI
”CWI”

n
#Frank
#Alice
#Celine
#John

e

x

n
#Frank #MIT ”MIT”
#Frank #CWI
”CWI”
#Alice
#Acme ”Acme”
#Celine #HAL ”HAL”
#John
#Acme ”Acme”

so that(cid:74)h(cid:75)ΩN ,G = (N , E, ∅, ρ, ∅, λ, ∅) with

N = {#John, #Acme, #Frank, #MIT, #Frank, #CWI, . . .} ,
E = {#1, #2, #3, #4, #5} ,
ρ = {#1 (cid:55)→ (#John, #Acme), #2 (cid:55)→ (#Frank, #MIT), #2 (cid:55)→ (#Frank, #CWI), . . .} , and
λ = {#1 (cid:55)→ :worksAt, . . .} .

Finally,(cid:74){ f , ❕, h}(cid:75)Ω,G = (N , E, ∅, ρ, ∅, λ, σ) with

λ = {#John (cid:55)→ :Person, #Acme (cid:55)→ :Company, #1 (cid:55)→ :worksAt, . . .} , and
σ = {(#John, fristname) (cid:55)→ ”John”,(#Acme, name) (cid:55)→ ”Acme”, . . .} .

A.4 The PATH clause
A frequent idiom is to de(cid:128)ne a temporary view consisting of paths speci(cid:128)ed using a path pa(cid:136)ern, optionally associating
a weight to each path in the view. (cid:140)e grammar for path clause expressions is:

basicPathClause ::= Path pname = pathPa(cid:136)ern
basicPathClauseCost ::= basicPathClause Cost fexpr

pathPa(cid:136)ern ::= walkPa(cid:136)ern | walkPa(cid:136)ern; graphPa(cid:136)ern
graphPa(cid:136)ern ::= basicGraphPa(cid:136)ern | basicGraphPa(cid:136)ern, graphPa(cid:136)ern
walkPa(cid:136)ern ::= edgePa(cid:136)ern | edgePa(cid:136)ern, walkPa(cid:136)ern |
pathPa(cid:136)ern | pathPa(cid:136)ern, walkPa(cid:136)ern

where pname is a path view name and fexpr is a cost function expression. Note that pathPa(cid:136)ern can refer to path views
de(cid:128)ned by other Path clauses appearing before it in the head clause where it is de(cid:128)ned.

In the syntax, we additionally require that walk pa(cid:138)erns are joinable. Given a walk pa(cid:138)ern b1, . . . , bn, where n ≥ 1
and each bi is either an edge pa(cid:138)ern or a path pa(cid:138)ern, we say that b1, . . . , bn is joinable if for every i ∈ {1, . . . , n − 1}:
Manuscript submi(cid:138)ed to ACM

32

• bi is either an edge pa(cid:138)ern x

z−−→ y or a path pa(cid:138)ern x

an edge pa(cid:138)ern x(cid:48)

z(cid:48)−−−→ y(cid:48) or a path pa(cid:138)ern x(cid:48) @w(cid:48) in r(cid:48)

y or a path pa(cid:138)ern x

@w in r
y(cid:48) or a path pa(cid:138)ern x(cid:48) w(cid:48) in r(cid:48)

w in r

R. Angles et al.

y, bi +1 is either

y(cid:48), and y = x(cid:48).

(cid:140)e interpretation of a walk pa(cid:138)ern in a graph G is a path in G.
We express path views via a Path clause, de(cid:128)ned as follows:

pathClause ::= basicPathClause | basicPathClauseCost |

basicPathClause Where BooleanCondition |
basicPathClauseCost Where BooleanCondition

Intuitively, the evaluation of

Path pname = pathPa(cid:136)ern Cost fexpr Where BooleanCondition

on a PPG G is a view pname consisting of a set of paths, each satisfying BooleanCondition. (cid:140)e paths are given by
bindings of pathPa(cid:136)ern = walkPa(cid:136)ern; graphPa(cid:136)ern in G. More precisely, assuming that x, y ∈ N are the starting
and ending nodes of walkPa(cid:136)ern, for every pair of nodes a, b in G, we look for the shortest path L from a to b over G
that conforms to walkPa(cid:136)ern and satis(cid:128)es the other graph pa(cid:138)erns in pathPa(cid:136)ern, and if such a path exists then we
check that it satis(cid:128)es BooleanCondition. If this holds, then we create a binding µ and a fresh path identi(cid:128)er p such that
dom(µ) = {x, y, pname}, µ(x) = a, µ(y) = b, µ(pname) = p and p is associated to L. Finally, the evaluation of the path
clause is a set containing all such bindings µ. It is straightforward to see how these ideas can be formalized by using the
notation considered previously.

Regarding the use of path views, recall that pname is de(cid:128)ned in the head clause of a full graph query φ. For any path
pa(cid:138)ern appearing in φ, pname can be used as a symbol in the regular expression over which the pa(cid:138)ern is evaluated.
pname is then pre(cid:128)xed with the tilde symbol “˜” to indicate that reference is being made to the binary view pname(x, y)
(rather than an element of L).

A.5 Basic and Full Graph (cid:131)eries
Recall that a basic graph query is de(cid:128)ned as a CONSTRUCT clause followed by a MATCH clause, i.e., a basic
graph query has the form Construct Φ Match Ψ. (cid:140)e evaluation of such a query over a graph G is de(cid:128)ned as:

(cid:74)Construct Φ Match Ψ(cid:75)G =(cid:74)Φ(cid:75)Ω,G, where Ω =(cid:74)Ψ(cid:75)Ω(cid:48),G and Ω(cid:48) is either the set of bindings provided by an outer

query if Ψ is an inner query or a singleton set containing the binding µ∅ with empty domain (recall that µ∅ is compatible
with every other binding). A full graph query is obtained by using the operators Union, Intersect, and Minus to
combine basic graph queries. (cid:140)us, to complete the de(cid:128)nition of full graph queries, we need to provide the semantics of
these operators on PPG’s.

In what follows, assume that G1 = (N1, E1, P1, ρ1, δ1, λ1, σ1) and G2 = (N2, E2, P2, ρ2, δ2, λ2, σ2) are PPG. Moreover,
say that G1 and G2 are consistent if: (i) for every e ∈ E1 ∩ E2, it holds that ρ1(e) = ρ2(e), and (ii) for every p ∈ P1 ∩ P2,
it holds that δ1(p) = δ2(p).
(cid:135)e union operator. If G1 and G2 are not consistent, then G1 ∪ G2 is de(cid:128)ned as the empty PPG. Otherwise, G1 ∪ G2 =
(N1 ∪ N2, E1 ∪ E2, P1 ∪ P2, ρ, δ, λ, σ), where (i) for every x ∈ (N1 ∪ N2 ∪ E1 ∪ E2 ∪ P1 ∪ P2) and k ∈ K: λ(x) =λ1(x)∪ λ2(x)
Manuscript submi(cid:138)ed to ACM

G-CORE

33

and σ(x, k) =σ1(x, k) ∪ σ2(x, k); (ii) for every e ∈ E1 ∪ E2:

and (iii) for every p ∈ P1 ∪ P2:

ρ(e) =

δ(p) =

if e ∈ E1

ρ2(e) otherwise;

ρ1(e)
δ1(p)

if p ∈ P1
δ2(p) otherwise.

(cid:135)e intersection operator. If G1 and G2 are not consistent, then G1 ∩ G2 is de(cid:128)ned as the empty PPG. Otherwise,
G1 ∩ G2 = (N1 ∩ N2, E1 ∩ E2, P1 ∩ P2, ρ, δ, λ, σ), where (i) for every x ∈ (N1 ∩ N2) ∪ (E1 ∩ E2) ∪ (P1 ∩ P2) and k ∈ K:
λ(x) =λ1(x)∩ λ2(x) and σ(x, k) =σ1(x, k)∩σ2(x, k); (ii) for every e ∈ E1∩ E2: ρ(e) = ρ1(e); and (iii) for every p ∈ P1∩ P2:
δ(p) = δ1(p).
(cid:135)e di(cid:130)erence operator. (cid:140)e di(cid:130)erence of G1 and G2 is de(cid:128)ned as: G1 (cid:114)G2 = (N , E, P, ρ, δ, λ, σ), where: N = N1 (cid:114)N2,
E = {e ∈ E1 (cid:114) E2 | ρ1(e) = (a, b), a ∈ N and b ∈ N}, P = {p ∈ P1 (cid:114) P2 | nodes(p) ⊆ N and edges(p) ⊆ E}, ρ = ρ1 |E,
δ = δ1 |P , λ = λ1 |(N∪E∪P) and σ = σ1 |(N∪E∪P)×K.

A.6 The GRAPH clause and GRAPH VIEW
(cid:140)e Graph View clause is used to create permanent views that may be re-used by multiple queries while the GRAPH
clause is used for the declaration of query-local views only (similar to the Path clause). Both clauses are given by the
following grammar:

::= Graph gid As (fullGraph(cid:137)ery),

graphClause
graphView ::= Graph View gid As (fullGraph(cid:137)ery),

Assuming that Ψ is a full graph query, the evaluation of clause Graph gid As (Ψ) over a graph G associates the graph

(cid:74)Ψ(cid:75)G to the graph identi(cid:128)er gid, that is, gr(gid) =(cid:74)Ψ(cid:75)G. (cid:140)e semantics of Graph View gid As (Ψ) is de(cid:128)ned exactly in

the same way.

Manuscript submi(cid:138)ed to ACM

