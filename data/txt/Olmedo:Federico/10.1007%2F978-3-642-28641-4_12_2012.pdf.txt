Veriﬁed Indifferentiable Hashing

into Elliptic Curves

Gilles Barthe1, Benjamin Gr´egoire2, Sylvain Heraud2,
Federico Olmedo1, and Santiago Zanella B´eguelin1

{Gilles.Barthe,Federico.Olmedo,Santiago.Zanella}@imdea.org

1 IMDEA Software Institute, Madrid, Spain

2 INRIA Sophia Antipolis-M´editerran´ee, France

{Benjamin.Gregoire,Sylvain.Heraud}@inria.fr

Abstract. Many cryptographic systems based on elliptic curves are proven secure 
in the Random Oracle Model, assuming there exist probabilistic functions
that map elements in some domain (e.g. bitstrings) onto uniformly and independently 
distributed points in a curve. When implementing such systems, and in
order for the proof to carry over to the implementation, those mappings must be
instantiated with concrete constructions whose behavior does not deviate significantly 
from random oracles. In contrast to other approaches to public-key cryptography,
 where candidates to instantiate random oracles have been known for
some time, the ﬁrst generic construction for hashing into ordinary elliptic curves
indifferentiable from a random oracle was put forward only recently by Brier et
al. We present a machine-checked proof of this construction. The proof is based
on an extension of the CertiCrypt framework with logics and mechanized tools
for reasoning about approximate forms of observational equivalence, and integrates 
mathematical libraries of group theory and elliptic curves.

1 Introduction

Following an established trend [18], the prevailing methodology for building secure
cryptosystems is to conduct a rigorous analysis that proves security under standard hypotheses.
 Sometimes this analysis is performed assuming that some components of the
system have an ideal behavior. However, ideal functionalities are difﬁcult or even impossible 
to realize, leading to situations where provably secure systems have no secure
implementation. An alternative methodology is to devise systems based on constructions 
that do not deviate signiﬁcantly from ideal ones, and to account for these deviations 
in the security analysis. Statistical distance is a natural notion for quantifying the
deviation between idealized functionalities and their implementations.

Veriﬁable security [3,4] is an emerging approach that advocates the use of interactive
proof assistants and automated provers to establish the security of cryptographic systems.
 It
improves on the guarantees of provable security by delivering fully
machine-checked and independently veriﬁable proofs. The CertiCrypt framework, built
on top of the Coq proof assistant, is one prominent tool that realizes veriﬁable security
by using standard techniques from programming languages and program veriﬁcation.
CertiCrypt is built around the central notion of observational equivalence of probabilistic 
programs, which unfortunately cannot model accurately other weaker, quantitative,

P. Degano and J.D. Guttman (Eds.): POST 2012, LNCS 7215, pp. 209–228, 2012.
c(cid:2) Springer-Verlag Berlin Heidelberg 2012

210

G. Barthe et al.

forms of equivalence. As a result, CertiCrypt cannot be used as it is to reason about
the statistical distance of distributions generated by probabilistic programs. More generally,
 the development of quantitative notions of equivalence is quite recent and rather
limited; see Section 7 for an account of related work.

One main contribution of this article is the formalization of several quantitative notions 
of program equivalence and logics for reasoning about them. More speciﬁcally, we
extend CertiCrypt with the notion of statistical distance and develop a logic to upper
bound the distance between distributions generated by probabilistic programs. Moreover,
 we introduce approximate and conditional variants of observational equivalence
and develop equational theories for reasoning about them.

In a landmark article, Maurer et al. [23] introduce the concept of indifferentiability 
to justify rigorously the substitution of an idealized component in a cryptographic
system by a concrete implementation. In a subsequent article, Coron et al. [13] argue 
that a secure hash function should be indifferentiable from a random oracle, i.e.
a perfectly random function. Although the random oracle model has been under ﬁerce
criticism [10] and the indifferentiability framework turns out to be weaker than initially
believed [16, 25], it is generally accepted that proofs in these models provide some
evidence that a system is secure. Not coincidentally, all ﬁnalists in the ongoing NIST
Cryptographic Hash Algorithm competition have been proved indifferentiable from a
random oracle.

Elliptic curve cryptography allows to build efﬁcient public-key cryptographic systems 
with comparatively short keys and as such is an attractive solution for resourceconstrained 
applications. In contrast to other approaches to public-key cryptography,
where candidates to instantiate random oracles have been known for some time, adequate 
constructions for hashing into ordinary elliptic curves have remained elusive.
In 2010, Brier et al. [9] proposed the ﬁrst generic construction indifferentiable from a
random oracle into elliptic curves. This construction is of practical signiﬁcance since
it allows to securely implement elliptic curve cryptosystems. We present a machinechecked 
and independently veriﬁable proof of the security of this construction. The
proof involves the various notions of equivalence we develop in this paper and is thus
an excellent testbed for evaluating the applicability of our methods. Additionally, the
proof builds on several large developments (including Th´ery’s formalization of elliptic
curves [30] and Gonthier et al. formalization of ﬁnite groups [19]) and demonstrates
that CertiCrypt blends well with large and complex mathematical libraries, and is apt
to support proofs involving advanced algebraic and number-theoretical reasoning.

Organization of the paper. The remainder of the paper is structured as follows. Section 
2 provides a brief introduction to CertiCrypt. Section 3 introduces the notion of statistical 
distance between probabilistic programs and describes programming language
techniques to bound it, whereas Sect. 4 deﬁnes weak forms of observational equivalence 
and their associated reasoning principles. Section 5 presents a machine-checked
proof of the indifferentiability of a generalization of Brier et al.’s construction from a
random oracle into an abelian ﬁnite group; its application to elliptic curves is discussed
in Sect. 6. We survey prior art and conclude in Sections 7 and 8.

Veriﬁed Indifferentiable Hashing into Elliptic Curves

211

2 An Overview of CertiCrypt

This section provides a brief description of the CertiCrypt framework. We refer the
reader to [4] for further details.

2.1 Representation of Distributions

CertiCrypt adopts the monadic representation of distributions proposed by Audebaud
and Paulin in [2]. A distribution over a set A is represented as a monotonic, continuous
and linear function of type

D(A) def= (A → [0, 1]) → [0, 1]

where [0, 1] denotes the unit interval. Intuitively, an element of type D(A) models the
expectation operator of a sub-probability distribution over A. Thus, the probability that
a distribution μ : D(A) assigns to an event X ⊆ A can be computed by measuring its
characteristic function 1X, i.e. Pr [μ : X]

def= μ(1X ).

2.2 Programming Model

We model games as probabilistic imperative programs with procedure calls. The set of
commands C is deﬁned inductively by the clauses:

C ::= skip

| V ← E
| V $← DE
|
if E then C else C
| while E do C
| V ← P(E, . . . ,E)
| C; C

nop
deterministic assignment
random assignment
conditional
while loop
procedure call
sequence

where V is a set of variables tagged with their scope (either local or global), E is a set
of deterministic expressions, and DE is a set of expressions that denote distributions
from which values can be sampled in random assignments. In the remainder, we let
true ⊕δ false denote the Bernoulli distribution with success probability δ, so that the
instruction x $← true ⊕δ false assigns true to x with probability δ, and we denote by
x $← A the instruction that assigns to x a value uniformly chosen from a ﬁnite set A.

A program (or game) consists of a command c and an environment E that maps procedure 
identiﬁers to their declaration, specifying its formal parameters, its body, and a
return expression that is evaluated upon exit. (Although procedures are single-exit, we
often write games using explicit return expressions for the sake of readability.) Declarations 
are subject to well-formedness and well-typedness conditions; these conditions
are enforced using the underlying dependent type system of Coq. Procedures corresponding 
to adversaries are modelled as procedures with unknown code.
Program states (or memories) are dependently typed functions that map a variable of
type T to a value in its interpretation (cid:2)T (cid:3); we let M denote the set of states. Expressions

212

G. Barthe et al.

have a deterministic semantics: an expression e of type T is interpreted as a function
(cid:2)e(cid:3) : M → (cid:2)T (cid:3). The semantics of a command c in an environment E relates an initial
memory to a probability sub-distribution over ﬁnal memories: (cid:2)c, E(cid:3) : M → D(M).
We often omit the environment when it is irrelevant.

By specializing the above deﬁnition of probability Pr [μ : X] to programs, we have
that the probability Pr [G, m : X] of an event X in a game G and an initial memory m
is given by (cid:2)G(cid:3) m 1X. The probability of termination of a game G starting in an initial
memory m is given by Pr [G, m : true]. We say that a game is lossless if it terminates
with probability 1 independently from the initial memory.

In order to reason about program complexity and deﬁne the class of probabilistic
polynomial-time computations, the semantics of programs is indexed by a security parameter 
(a natural number) and instrumented to compute the time and memory cost of
evaluating a command, given the time and memory cost of each construction in the
expression language. We chose not to make this parameterization explicit to avoid cluttering 
the presentation.

2.3 Reasoning Tools

CertiCrypt provides several tools for reasoning about games. One main tool is a probabilistic 
relational Hoare logic. Its judgments are of the form |= G1 ∼ G2 : Ψ ⇒ Φ,
where G1 and G2 are games, and Ψ and Φ are relations over states. We represent relations 
as ﬁrst-order formulae over tagged program variables; we use the tags (cid:8)1(cid:9) and (cid:8)2(cid:9)
to distinguish between the value of a variable or formula in the left and right-hand side
program, respectively.
Formally, a judgment |= G1 ∼ G2 : Ψ ⇒ Φ is valid, iff for all memories m1 and m2
such that m1 Ψ m2, we have that ((cid:2)G1(cid:3) m1)L(Φ) ((cid:2)G2(cid:3) m2), where L(Φ) denotes the
lifting of Φ to distributions. Relational Hoare logic can be used to prove claims about
the probability of events in games by using, for instance, the following rule:
Φ =⇒ (A(cid:8)1(cid:9) =⇒ B(cid:8)2(cid:9))

m1 Ψ m2

|= G1 ∼ G2 : Ψ ⇒ Φ
Pr [G1, m1 : A] ≤ Pr [G2, m2 : B]

Observational equivalence is deﬁned by specializing the judgments to relations Ψ and
Φ corresponding to the equality relation on subsets of program variables. Formally, let
X be a set of variables, m1, m2 ∈ M and f1, f2 : M → [0, 1]. We deﬁne

m1 =X m2
f1 =X f2

def= ∀x ∈ X. m1(x) = m2(x)
def= ∀m1 m2. m1 =X m2 =⇒ f1(m1) = f2(m2)

Then, two games G1 and G2 are observationally equivalent w.r.t. an input set of variables
I and an output set of variables O, written |= G1 (cid:13)I
O G2, iff |= G1 ∼ G2 : =I ⇒ =O.
Equivalently, |= G1 (cid:13)I
O G2 iff for all memories m1, m2 ∈ M and functions f1, f2 :
M → [0, 1],

m1 =I m2 ∧ f1 =O f2 =⇒ (cid:2)G1(cid:3) m1 f1 = (cid:2)G2(cid:3) m2 f2

Observational equivalence is amenable to automation. CertiCrypt provides mechanized
tactics based on dependency analyses to perform common program transformations

Veriﬁed Indifferentiable Hashing into Elliptic Curves

213

and to prove that two programs are observationally equivalent (note that observational
equivalence is only a partial equivalence relation). The mechanized transformations
include dead code elimination, call inlining, interand 
intra-procedural code motion
and expression propagation.
We sometimes use a standard Hoare logic for reasoning about single programs. Its
judgments are of the form {P} G {Q}, where G is a game and P and Q are predicates
on states. Formally, a judgment {P} G {Q} is valid iff for every memory m ∈ M and
function f : M → [0, 1],

P m ∧ (∀m. Q m =⇒ f (m) = 0) =⇒ (cid:2)G(cid:3) m f = 0

This logic is subsumed by the relational Hoare logic,

|= {P} G {Q} ⇐⇒ |= G ∼ skip : P(cid:8)1(cid:9) ⇒ Q(cid:8)1(cid:9).

3 Statistical Distance

Statistical distance quantiﬁes the largest difference between the probability that two
distributions assign to the same event. We refer to [28] for an in-depth presentation
of statistical distance and its properties. Formally, the statistical distance Δ (μ1, μ2)
between two distributions μ1 and μ2 over a set A is deﬁned as:
|μ1 f − μ2 f|

Δ (μ1, μ2) def=

sup

f :A→[0,1]

One important property of statistical distance that we frequently use in proofs is its
invariance under function application, i.e. for any function F : D(A) → D(B) and
distributions μ1, μ2 over A, Δ (F (μ1), F (μ2)) ≤ Δ (μ1, μ2).

Remark. In the traditional deﬁnition of statistical distance, f ranges only over Booleanvalued 
functions. Our deﬁnition is more convenient for reasoning about our monadic
formalization of distributions. We have proved in Coq that the two deﬁnitions coincide
for discrete distributions.

3.1 A Logic for Bounding Statistical Distance

Statistical distance admits a natural extension to programs; we deﬁne the statistical
distance between two programs G1 and G2 as follows:

Δ (G1, G2) def= max
m,f

|(cid:2)G1(cid:3) m f − (cid:2)G2(cid:3) m f|

Or, ﬁxing an initial memory m,

Δm (G1, G2) def= max

f

|(cid:2)G1(cid:3) m f − (cid:2)G2(cid:3) m f|

We deﬁne a logic that allows to upper bound Δm (G1, G2) by a function of the memory
m; the logic deals with judgments of the form (cid:4)G1, G2(cid:5) (cid:16) g, where
(cid:4)G1, G2(cid:5) (cid:16) g def= ∀m. Δm (G1, G2) ≤ g m ≡ ∀m f. |(cid:2)G1(cid:3) m f − (cid:2)G2(cid:3) m f| ≤ g m

214

G. Barthe et al.

(cid:2)skip, skip(cid:3) (cid:2) λm. 0
∀m. Δ ((cid:4)μ1(cid:5) m, (cid:4)μ2(cid:5) m) ≤ g m

[Skip]

(cid:2)x ← e, x ← e(cid:3) (cid:2) λm. 0
[Ass]
2(cid:3) (cid:2) g
(cid:2)
(cid:2)
(cid:2)c
1, c
(cid:2)

(cid:2)c1, c2(cid:3) (cid:2) g
2(cid:3) (cid:2) λm.(cid:4)c1(cid:5)m g
(cid:2)
(cid:2)
(cid:2)c1; c
1, c2; c
2(cid:3) (cid:2) g2
(cid:2)
(cid:2)c2, c

(cid:2)

(cid:2)x $← μ1, x $← μ2(cid:3) (cid:2) g
[Rnd]
1(cid:3) (cid:2) g1
(cid:2)
(cid:2)c1, c
2(cid:3) (cid:2) λm. if (cid:4)b(cid:5) m then g1 m else g2 m
(cid:2)
(cid:2)
(cid:2)if b then c1 else c2, if b then c
1 else c
(cid:2)c1, c2(cid:3) (cid:2) g
g0(m) = 0 gn+1(m) = if (cid:4)b(cid:5) m then (cid:4)c1(cid:5) m gn + g(m) else 0

+ g m

[Seq]

[Cond]

[Whl]

(cid:2)while b do c1, while b do c2(cid:3) (cid:2) sup(λn. gn)

(cid:2)E1(p), E2(p)(cid:3) (cid:2) g

g =X g ∀x. x ∈ X ⇒ global(x)

(cid:2)y ← p(x), y ← p(x)(cid:3) (cid:2) g

[Call]

Fig. 1. Logic to bound the statistical distance between two probabilistic programs

Figure 1 presents the main rules of the logic; for readability, rules are stated for pairs
of commands rather than pairs of programs, and assume that this pair of programs are
executed in two ﬁxed environments E1 and E2 respectively.

To prove the soundness, for instance, of the rule for sequential composition, we in-
(cid:3)
(cid:3)
troduce an intermediate program c1; c
2 (where c1 is executed in environment E1 and c
2
(cid:3)
1(cid:3) m is
in environment E2) and prove that the distance between (cid:2)c1; c
(cid:3)
bounded by (cid:2)c1(cid:3) m g
2(cid:3) m is bounded
by g m. The rule for loops relies on the characterization of the semantics of a while loop
as the least upper bound of its n-th unrolling [while e do c]n, and on the auxiliary rule

, while the distance between (cid:2)c1; c

(cid:3)
2(cid:3) m and (cid:2)c1; c

(cid:3)
2(cid:3) m and (cid:2)c2; c

(cid:3)

(cid:4)[while b do c1]n, [while b do c2]n(cid:5) (cid:16) gn
(cid:4)while b do c1, while b do c2(cid:5) (cid:16) sup(λn. gn)

While the rules in Figure 1 are sufﬁcient to reason about closed programs, they do
not allow to reason about games in the presence of adversaries. We enhance the logic
with a rule that allows to bound the statistical distance between calls to an adversary A
executed in two different environments E1 and E2, i.e. it allows to draw conclusions
of the form (cid:4)A,A(cid:5) (cid:16) g.1 In its simplest formulation, the rule assumes that oracles are
instrumented with a counter that keeps track of the number of queries made, and that the
statistical distance between the distributions induced by a call to an oracle x ← O((cid:7)e) in
E1 and E2 is upper bounded by a constant , i.e. (cid:4)O,O(cid:5) (cid:16) . In this case, the statistical
distance between calls to the adversary A in E1 and E2 is upper bounded by q· , where
q is an upper bound on the number of oracle calls made by the adversary.

For the application presented in Section 5, we need to formalize a more powerful
rule, in which the statistical distance between two oracle calls can depend on the program 
state. Moreover, we allow the counter to be any integer expression, and only require 
that it does not decrease across oracle calls.
1 For the sake of readability, we write (cid:2)A, A(cid:3) (cid:2) g instead of (cid:2)x ← A((cid:4)e), x ← A((cid:4)e)(cid:3) (cid:2) g, and
likewise for oracles.

215
Lemma 1 (Adversary rule). Let A be an adversary and let cntr be an integer expression 
whose variables cannot be written by A. Let h : N → [0, 1] and deﬁne

Veriﬁed Indifferentiable Hashing into Elliptic Curves

⎛
⎝1,

(cid:2)cntr(cid:3)m(cid:2)−1(cid:4)

i=(cid:2)cntr(cid:3)m

¯hcntr(m, m

(cid:3)

) def= min

⎞
⎠
h(i)

Assume that for every oracle O,

(cid:4)O,O(cid:5) (cid:16) λm. (cid:2)E1(O)(cid:3) m (λm

(cid:3)

. ¯hcntr(m, m

(cid:3)

))

and {cntr = i} E1(O) {i ≤ cntr}. Then,

(cid:4)A,A(cid:5) (cid:16) λm. (cid:2)E1(A)(cid:3) m

(cid:7)
λm

(cid:3)

. ¯hcntr(m, m

(cid:8)
)

(cid:3)

3.2 Reasoning about Failure Events

Transitions based on failure events allow to transform a game into another game that
is semantically equivalent unless some failure condition is triggered. The main tool to
justify such transitions is the following lemma.

Lemma 2 (Fundamental Lemma). Consider two games G1, G2 and let A, B, and F
be events. If Pr [G1 : A ∧ ¬F ] = Pr [G2 : B ∧ ¬F ] , then

|Pr [G1 : A] − Pr [G2 : B]| ≤ max{Pr [G1 : F ] , Pr [G2 : F ]}

Note also that if, for instance, game G2 is lossless, then Pr [G1 : F ] ≤ Pr [G2 : F ].
When A = B and F = bad for some Boolean variable bad, the hypothesis of the
lemma can be automatically established by inspecting the code of both games: it holds
if their code differs only after program points setting bad to true and bad is never reset
to false. As a corollary, if two games G1, G2 satisfy this syntactic criterion and e.g. G2
is lossless, (cid:4)G1, G2(cid:5) (cid:16) λm. Pr [G2, m : bad] .

4 Weak Equivalences

In this section we introduce quantitative notions of program equivalence and equational
theories to reason about them.

4.1 Approximate Observational Equivalence

Approximate observational equivalence generalizes observational equivalence between
two games by allowing that their output distributions differ up to some quantity . Informally,
 two games G1 and G2 are -observationally equivalent w.r.t. an input set of
variables I and an output set of variables O iff for every pair of memories m1, m2
coinciding on I,

Δ (((cid:2)G1(cid:3) m1)/ =O, ((cid:2)G2(cid:3)m2)/ =O) ≤ ,

216

G. Barthe et al.

where for a distribution μ over a set A and an equivalence relation R on A, we let μ/R
denote the quotient distribution of μ over A/R. For the purpose of formalization, it is
more convenient to rely on the following alternative characterization that does not use
quotient distributions, in part because the underlying language of Coq does not support
quotient types.

Deﬁnition 1. Two games G1 and G2 are -observationally equivalent w.r.t. an input set
of variables I and an output set of variables O, written |= G1 (cid:13)I
O G2 (cid:16) , iff for all
memories m1, m2 ∈ M and functions f1, f2 : M → [0, 1]

m1 =I m2 ∧ f1 =O f2 =⇒ |(cid:2)G1(cid:3) m1 f1 − (cid:2)G2(cid:3) m2 f2| ≤ 

Figure 2 provides an excerpt of an equational theory for approximate observational
equivalence; further and more general rules appear in the formal development. Most
rules generalize observational equivalence in the expected way. For instance, the rule
for random assignment considers the case of uniformly sampling over two ﬁnite sets A
and B: in case A = B, one obtains  = 0.

|= c1 (cid:8)I

O c2 (cid:2) 1
|= c1 (cid:8)I

|= c2 (cid:8)I
O c3 (cid:2) 1 + 2

O c3 (cid:2) 2

|= c1 (cid:8)I

1 (cid:2) 
(cid:2)
O c

|= c2 (cid:8)I

(cid:2)

(cid:2) ≤ 


(cid:2) ⊆ I O ⊆ O
O c2 (cid:2) 

|= c1 (cid:8)I(cid:2)

O(cid:2) c2 (cid:2) 
(cid:2)

I
|= c1 (cid:8)I
|= c
1 (cid:8)O(cid:2)
2 (cid:2) 2
(cid:2)
(cid:2)
O c
2 (cid:2) 1 + 2
(cid:2)
O c2; c
=⇒ (cid:4)b(cid:5) m = (cid:4)b
∀m, m
. I m m
2 (cid:2) 
(cid:2)
(cid:2)
(cid:2)
(cid:2)
then c
1 else c
O if b
| + max
#(B\A)
#(A\B)
#A ,
I∪{x} x $← B (cid:2) 

(cid:3)

#B

(cid:2)

(cid:2)

(cid:2)

(cid:2)(cid:5) m

|= c1 (cid:8)I

O(cid:2) c2 (cid:2) 1
1 (cid:8)I
|= c1; c
(cid:2)
2 (cid:2) 
(cid:2)
O c

|= if b then c1 else c2 (cid:8)I

 = #(A ∩ B)| 1

− 1
|= x $← A (cid:8)I

#B

#A

Fig. 2. Selected rules for reasoning about approximate observational equivalence

4.2 A Conditional Variant

The application we describe in Section 5 requires reasoning about conditional approximate 
observational equivalence, a generalization of approximate observational equivalence.
 We deﬁne for each distribution μ and event P the conditional distribution μ |P
as

(cid:10)

μ |P

def= λf. μ

(cid:9)
λa.

f (a) 1P (a)

μ 1P

Intuitively, μ |P 1Q yields the conditional probability of Q given P .

Veriﬁed Indifferentiable Hashing into Elliptic Curves

217

Deﬁnition 2. A game G1 conditioned on predicate P1 is -observationally equivalent
to a game G2 conditioned on P2 w.r.t. an input set of variables I and an output set
of variables O, written |= [G1]P1
(cid:16) , iff for any m1, m2 ∈ M and
f1, f2 : M → [0, 1],

(cid:13)I
O [G2]P2

m1 =I m2 ∧ f1 =O f2 =⇒ |((cid:2)G1(cid:3) m1) |P1 f1 − ((cid:2)G2(cid:3) m2) |P2 f2| ≤ 

Conditional approximate observational equivalence subsumes classic approximate observational 
equivalence, which can be recovered by taking P1 = P2 = true.

5 Indifferentiability

In this section we present an application of the techniques introduced above to prove the
security of cryptographic constructions in the indifferentiability framework of Maurer
et al. [23]. In particular, we consider the notion of indifferentiability from a random
oracle. A random oracle is an ideal primitive that maps elements in some domain into
uniformly and independently distributed values in a ﬁnite set; queries are answered
consistently so that identical queries are given the same answer. A proof conducted in
the random oracle model for a function h : A → B assumes that h is made publicly
available to all parties.
Deﬁnition 3 (Indifferentiability). A procedure F that has access to a random oracle
h : {0, 1}∗ → A is said to be (tS, tD, q1, q2, )-indifferentiable from a random oracle
H : {0, 1}∗ → B if there exists a simulator S with oracle access to H and executing
within time tS such that any distinguisher D running within time tD and making at most
q1 queries to an oracle O1 and q2 queries to an oracle O2 has at most probability  of
distinguishing a scenario where O1 is implemented as F and O2 as h from a scenario
where O1 is implemented as H and O2 as S instead. Put in terms of games,
: L ← nil; b ← D( )

Game G : L ← nil; b ← D( )
Oracle O1(x) : return F(x)
Oracle O2(x) :
if x /∈ dom(L) then
y $← A; L(x) ← y
return L(x)

|Pr [G : b = true] − Pr [G(cid:3)

(cid:2)
Game G
Oracle O1(x) :
if x /∈ dom(L) then
y $← B; L(x) ← y
return L(x)
Oracle O2(x) : return S(x)
: b = true]| ≤ 

Random oracles into elliptic curves over ﬁnite ﬁelds are typically built from a random
oracle h on the underlying ﬁeld and a deterministic encoding f that maps elements of
the ﬁeld into the elliptic curve. Examples of such encodings include Icart function [21]
and the Shallue-Woestijne-Ulas (SWU) algorithm [27]. In general, and in particular
for the aforementioned mappings, the function f is not surjective and only covers a
fraction of points in the curve. Hence, the naive deﬁnition of a hash function H as f ◦ h
would not cover the whole curve, contradicting the assumption that H behaves as a
random oracle. In a recent paper, Brier et al. [9] show how to build hash functions into

218

G. Barthe et al.

elliptic curves that are indifferentiable from a random oracle from a particular class of
encodings, including both SWU and Icart encodings.

We prove the indifferentiability of the construction put forward by Brier et al. in the
formal framework of CertiCrypt. The proof introduces two intermediate constructions
and is structured in three steps:

1. We ﬁrst prove that any efﬁciently invertible encoding f can be turned into a weak

encoding (Theorem 1);

2. We then show an efﬁcient construction to transform any weak encoding f into an

admissible encoding (Theorem 2);

3. Finally, we prove that any admissible encoding can be turned into a hash function

indifferentiable from a random oracle (Theorem 3).

Moreover, we show in Sect. 6 that Icart encoding is efﬁciently invertible and thus yields
a hash function indifferentiable from a random oracle when plugged in into the above
construction. We recall the alternative deﬁnitions of weak and admissible encoding
from [22]. Note that these do not match the deﬁnitions in [9], but, in comparison, are
better behaved: e.g. admissible encodings as we deﬁne them are closed under functional
composition and cartesian product.
Deﬁnition 4 (Weak encoding). A function f : S → R is an (α, )-weak encoding
if it is computable in polynomial-time and there exists a probabilistic polynomial-time
algorithm If : R → S⊥ such that
1. {true} r $← R; s ← If (r) {s = ⊥ ∨ f (s) = r}
2. |= [r $← R; s ← If (r)]s(cid:6)=⊥ (cid:13)∅
{s} [s $← S] (cid:16) 
3. Pr [r $← R; s ← If (r) : s = ⊥] ≤ 1 − α
Deﬁnition 5 (Admissible encoding). A function f : S → R is an -admissible encoding 
if it is computable in polynomial-time and there exists a probabilistic polynomialtime 
algorithm If : R → S⊥ such that
1. {true} r $← R; s ← If (r) {s = ⊥ ∨ f (s) = r}
2. |= r $← R; s ← If (r) (cid:13)∅
Brier et al. [9] prove that if G is a ﬁnite cyclic group of order N with generator g,
a function into G indifferentiable from a random oracle can be built from any polynomially 
invertible function f : A → G and hash functions h1 : {0, 1}(cid:3) → A and
h2 : {0, 1}∗ → ZN as follows:

{s} s $← S (cid:16) 

−1

H(m) def= f (h1(m)) ⊗ gh2(m)

(1)
Intuitively, the term gh2(m) behaves as a one-time pad and ensures that H covers all
points in the group even if f covers only a fraction. Our proof generalizes this construction 
to ﬁnitely generated abelian groups.

We begin by showing that any efﬁciently invertible encoding is a weak encoding.

Theorem 1. Let f : S → R be a function computable in polynomial-time such that
−1(r) ≤ B. Assume there exists a polynomial-time algorithm I
for any r ∈ R, #f
that given r ∈ R outputs the set f
−1(r). Then, f is an (α, 0)-weak encoding, with
α = B #R/#S.

219
Proof. Using I, we build a partial inverter If : R → S⊥ of f that satisﬁes the properties 
in Deﬁnition 4:

Veriﬁed Indifferentiable Hashing into Elliptic Curves

If (r) : X ← I(r); b $← true ⊕#X/B false;

if b = true then s $← X; return s else return ⊥

First observe that If (r) fails with probability 1−#f
−1(r)/B or else returns an element
uniformly chosen from the set of pre-images of r, and thus satisﬁes the ﬁrst property
trivially. In addition, for any x ∈ S we have
Pr [r $← R; s ← If (r) : s = x] =
Pr [r $← R; s ← If (r) : s (cid:22)= ⊥] =

(cid:4)

B#R

#f

=

1

1

−1(r)
B

#S
B#R

#R

r∈R

Hence, for a uniformly chosen r, the probability of If (r) failing is exactly 1 − α
−1,
and the probability of returning any particular value in S conditioned to not failing is
(cid:23)(cid:24)
uniform.

G (cid:13) Zn1 × ··· × Znk

We show next how to construct an admissible encoding from a weak-encoding into a
ﬁnite abelian group. Recall that every ﬁnite abelian group G is isomorphic to a product
of cyclic groups2
If we ﬁx generators gi for each Zni, then any x ∈ G admits a unique representation
zk
as a vector (gz1
k ). We use log to denote the operator that returns the canonical
representation (cid:7)z = (z1, . . . , zk) for any x ∈ G.
Theorem 2. Let G (cid:13) Zn1×···×Znk be a ﬁnite abelian group and let gi be a generator
of Zni for i = 1 . . . k. Assume that f : A → G is an (α, )-weak encoding. Then, for
any polynomially bounded T , the function

1 , . . . , g

F
F (a, z1, . . . , zk) = f (a) ⊗ gz1

: A × Zn1 × ··· × Znk
1 ⊗ ··· ⊗ gzk
(cid:7)
1 − α
−1

→ G
(cid:8)T +1

=  +

k

(cid:3)

.

(cid:3)

is an 

-admissible encoding into G, with 

Proof. Since f is a weak encoding, there exists a polynomial-time computable inverter
If of f satisfying the conditions in Deﬁnition 4. Let T ∈ N be polynomially bounded.
Using If , we build a partial inverter IF of F that satisﬁes the properties in Deﬁnition 5:

IF (r) : i ← 0; a ← ⊥;

while (i ≤ T ∧ a = ⊥) do
(cid:7)z $← Zn1 × ··· × Znk ;
1 ⊗ ··· ⊗ g
x ← r ⊗ g
−z1
a ← If (x); i ← i + 1

−zk
k

;

end;
if a (cid:22)= ⊥ then return (a, (cid:7)z) else return ⊥

2 The decomposition can be made unique by ﬁxing additional conditions on n1 . . . nk.

220

G. Barthe et al.

Game G1 : r $← G; s ← IF (r)

Game G7 : s $← A × Z

Game G2 :
r $← G;
i ← 0; a ← ⊥;
while (i ≤ T ∧ a = ⊥) do

x $← G; (cid:2)z ← log (r ⊗ x−1);
a ← If (x); i ← i + 1

end;
if a (cid:7)= ⊥ then s ← (a, (cid:2)z) else s ← ⊥

Game G3 :
r $← G;
i ← 0; a ← ⊥;
while (i ≤ T ∧ a = ⊥) do

x $← G; a ← If (x); i ← i + 1

end;
(cid:2)z ← log (r ⊗ x−1);
if a (cid:7)= ⊥ then s ← (a, (cid:2)z) else s ← ⊥

Game G5 G6 :
i ← 0; a ← ⊥;
while (i ≤ T ∧ a = ⊥) do

x $← G; a ← If (x); i ← i + 1

end;
(cid:2)z $← (cid:2)Z;
if a (cid:7)= ⊥ then a $← A; s ← (a, (cid:2)z)
else bad ← true;

s ← ⊥ a $← A; s ← (a, (cid:2)z)

Game G4 :
i ← 0; a ← ⊥;
while (i ≤ T ∧ a = ⊥) do

x $← G; a ← If (x); i ← i + 1

end;
(cid:2)z $← (cid:2)Z;
if a (cid:7)= ⊥ then s ← (a, (cid:2)z) else s ← ⊥

Fig. 3. Sequence of games used in Theorem 2

The partial inverter IF runs in time tIF = (T + 1) tIf , where tIf is a bound on the
running time of If . Hence, IF is polynomial-time for any polynomially bounded T .
For the sake of readability in the following we use (cid:7)Z to denote Zn1 × ··· × Znk and

(cid:7)g(cid:4)z to denote gz1

1 ⊗ ··· ⊗ gzk

k . We prove that

|= r $← G; s ← IF (r) (cid:13)∅

{s} s $← A × (cid:7)Z (cid:16) 

(cid:3)

using the sequence of games G1, . . . , G7 shown in Figure 3, the mechanized program
transformations of CertiCrypt, and the proof rules for observational and approximate
observational equivalence. We brieﬂy describe the proof below.
We obtain game G2 by ﬁrst inlining the call to IF in the initial game and then applying 
the following algebraic equivalence to transform the body of the while loop:

|= (cid:7)z $← (cid:7)Z; x ← r ⊗ (cid:7)g

−(cid:4)z (cid:13){r}

{r,x,z} x $← G; (cid:7)z ← log (r ⊗ x

−1)

We obtain game G3 by moving the assignment to (cid:7)z outside the loop in game G2. This
transformation is semantics-preserving because (cid:7)z is never used inside the loop and the
value that it has when exiting the loop only depends on the value of x in the last iteration.
Formally, this is proven by unfolding the ﬁrst iteration of the loop and establishing that
the relation

={i,x,a,r} ∧ ((cid:7)z = log (r ⊗ x
is a relational invariant between the loop in G2 and the loop resulting from removing
the assignment to (cid:7)z. By appending (cid:7)z ← log (r ⊗ x
−1) to the latter loop, we recover
equivalence on (cid:7)z.

−1))(cid:8)1(cid:9)

Veriﬁed Indifferentiable Hashing into Elliptic Curves

221

Since r is no longer used inside the loop, we can postpone its deﬁnition after the

loop, and use the following algebraic equivalence to sample (cid:7)z instead of r:
{r,x,z} (cid:7)z $← (cid:7)Z; r ← x ⊗ (cid:7)g(cid:4)z

|= r $← G; (cid:7)z ← log (r ⊗ x

−1) (cid:13){x}

We obtain G4 by additionally removing the assignment to r, which is now dead code.
For the next step in the proof we use the fact that f is a weak encoding and therefore
the distribution of a after a call a ← If (x) conditioned to a (cid:22)= ⊥ is -away from the
uniform distribution. This allows us to resample the value of a after the loop, provided
a (cid:22)= ⊥, incurring a penalty  on the statistical distance of the distribution of s between
G4 and G5. To prove this formally, let b be the condition of the loop and c its body. Observe 
that the semantics of the loop coincides with the semantics of its (T +1)-unrolling
[while b do c]T +1. We show by induction on T that for any [0, 1]-valued functions f, g
s.t. f ={a(cid:2)} g,

m1 ={a,i} m2 ∧ m1(a) = ⊥ =⇒ |(cid:2)c1(cid:3) m1 f

(cid:3)−(cid:2)c2(cid:3) m2 g

(cid:3)| ≤ 

where

= [while b do c]T +1; if a (cid:22)= ⊥ then a
c1
= [while b do c]T +1; if a (cid:22)= ⊥ then a
c2
(m) = if m(a) (cid:22)= ⊥ then f (m) else 0
(cid:3)
f
(m) = if m(a) (cid:22)= ⊥ then g(m) else 0
(cid:3)
g

(cid:3) ← a
(cid:3) $← A

and use this to conclude the -approximate equivalence of G4 and G5.

Since G5 and G6 are syntactically equivalent except for code appearing after the ﬂag
bad is set, we apply the corollary of the Fundamental Lemma in Section 3.2 to obtain
the bound

(cid:4)G5, G6(cid:5) (cid:16) Pr [G5 : bad]

Since the probability of failure of If on a uniformly chosen input is upper bounded by
1 − α

−1, we can show by induction on T that
Pr [G5 : bad] ≤ (cid:7)
{s} G6 (cid:16) (cid:7)

from which we conclude |= G5 (cid:13)∅

(cid:8)T +1
−1
(cid:8)T +1

1 − α
1 − α
−1

.

,

By coalescing the branches in the conditional at the end of G6 and removing dead
code, we prove that the game is observational equivalent w.r.t a and (cid:7)z to the game
a $← A; (cid:7)z $← (cid:7)Z; s ← (a, z), which is trivially equivalent to G7.
(cid:8)T +1

By composing the above results, we conclude
(cid:7)
1 − α
{s} G7 (cid:16)  +

(2)
We must also show that s = ⊥ ∨ F (s) = r is a post-condition of G1. As G1 and G3
are observationally equivalent with respect to s and r, it is sufﬁcient to establish the
validity of the post-condition for G3. We show that a (cid:22)= ⊥ ⇒ x = f (a) is an invariant
of the loop. When the loop ﬁnishes, either a = ⊥ and in this case s = ⊥, or a (cid:22)= ⊥ and
we have F (s) = f (a) ⊗ (cid:7)g(cid:4)z = x ⊗ r ⊗ x
(cid:23)(cid:24)

|= G1 (cid:13)∅

−1 = r.

−1

G. Barthe et al.

222
Finally, we show that the composition of an admissible encoding f : S → R and a
random oracle into S is indifferentiable from a random oracle into R.
Theorem 3. Let f : S → R be an -admissible encoding with inverter algorithm
If and let h : {0, 1}(cid:3) → S be a random oracle. Then, f ◦ h is (tS, tD, q1, q2, 
(cid:3)
)-
indifferentiable from a random oracle into R, where tS = q1 tIf and 
= 2(q1 + q2).

(cid:3)

Before moving to the proof of Theorem 3, we prove the following useful result.
Lemma 3. Let f : S → R be an -admissible encoding with inverter algorithm If .
Then

|= s $← S; r ← f (s) (cid:13)∅

{r,s} r $← R; s ← If (r) (cid:16) 2

Proof. Deﬁne

def= s $← S; r ← f (s)
def= r $← R; s ← If (r)
def= ci; if s = ⊥ then r $← R else r ← f (s)
def= cf ; if s = ⊥ then bad ← true; r $← R else r ← f (s)
def= cf ; if s = ⊥ then bad ← true else r ← f (s)

ci
cf
c1
c2
c3

Since the ﬁrst branch of the conditional in c1 is never executed, we have:

|= ci (cid:13)∅

{r,s} c1

Due to the second property of Deﬁnition 5, the distributions of s after executing ci and
cf are -away. Using the rules for approximate observational equivalence, we obtain

{r,s} c2 (cid:16) 
corollary to the Fundamental Lemma

|= c1 (cid:13)∅

The
(cid:4)c2, c3(cid:5) (cid:16) Pr [c2 : bad]. Moreover,
Pr [c2 : bad] = 1 − Pr [cf : s (cid:22)= ⊥] = Pr [s $← S : s (cid:22)= ⊥] − Pr [cf : s (cid:22)= ⊥] ≤ 

in Section 3.2 implies

that

where the last inequality holds again because of the second property of Deﬁnition 5.
Since the ﬁnal values of r and s in programs c2 and c3 are independent of the initial
memory, we have

|= c2 (cid:13)∅

{r,s} c3 (cid:16) 

Because If is a partial inverter for f , the else branch of the conditional in c3 has no
effect and can be removed, and thus |= c3 (cid:13)∅
{r,s} cf . We conclude by transitivity of
(cid:23)(cid:24)
approximate observational equivalence.
Proof (of Theorem 3). Let D be a distinguisher against the indifferentiability of f ◦ h
making at most q1 queries to O1 and at most q2 queries to O2. We exhibit a simulator
S that uses a random oracle into R to simulate h and show that D cannot distinguish a
game G where O1 and O2 are implemented by f ◦ h and h respectively from a game
where they are implemented by S and a random oracle into R instead. An overview
G(cid:3)

Veriﬁed Indifferentiable Hashing into Elliptic Curves

223

Game G : L ← nil; b ← D( )
Oracle O1(x) :
if x /∈ dom(L1) then
s $← S; L1(x) ← s
return L1(x)
Oracle O2(x) :
if x /∈ dom(L2) then
s ← O1(x); r ← f (s); L2(x) ← r
return L2(x)
Game G1 : L ← nil; b ← A( )
Oracle O(x) :
if x /∈ dom(L) then
s $← S; r ← f (s); L(x) ← (s, r)
return L(x)

: L ← nil; b ← D( )

(cid:2)
Game G
Oracle O1(x) :
if x /∈ dom(L1) then
r ← O2(x); s ← If (r); L1(x) ← s
return L1(x)
Oracle O2(x) :
if x /∈ dom(L2) then
r $← R; L2(x) ← r
return L2(x)
Game G2 : L ← nil; b ← A( )
Oracle O(x) :
if x /∈ dom(L) then
r $← R; r ← If (r); L(x) ← (s, r)
return L(x)

1

: L ← nil; b ← A( )

Game Gbad
Oracle O(x) :
if x /∈ dom(L) then
if |L| < q1 + q2 then
s $← S; r ← f (s)
else bad ← true; s $← S; r ← f (s)
L(x) ← (s, r)
return L(x)

2

: L ← nil; b ← A( )

Game Gbad
Oracle O(x) :
if x /∈ dom(L) then
if |L| < q1 + q2 then
s $← S; r ← f (s)
else bad ← true; r $← R; s ← If (r)
L(x) ← (s, r)
return L(x)

Fig. 4. Games used in the proof of Theorem 3

of the proof, including these two games and the deﬁnition of the simulator is shown in
Figure 4.

Our goal is to prove

|Pr [G : b = true] − Pr [G(cid:3)

: b = true]| ≤ 2(q1 + q2)

(3)

The crux of the proof is an application of Lemma 1. In order to apply it, we need ﬁrst
to transform the initial games to replace oracles O1 and O2 by a single joint oracle that
simultaneously returns the responses of both. Using D, we construct an adversary A
with access to a single joint oracle, such that games G and G(cid:3)
are equivalent to games
G1 and G2 in the ﬁgure. Adversary A simply calls the distinguisher D and forwards the
value it returns; it simulates O1 and O2 by using its own oracle O.
We assume without loss of generality the equivalence between games G and G1, and
G(cid:3)
and G2, respectively. This is identical to the assumption in [9] that the distinguisher
always makes the same queries to both its oracles. Games G1 and G2 satisfy the equali-
ties:

Pr [G : b = true] = Pr [G1 : b = true]

Pr [G(cid:3)

: b = true] = Pr [G2 : b = true]

(cid:11)

(cid:12)

Gbad

1

: b = true ∧ ¬bad

Pr

= Pr

Gbad

2

: b = true ∧ ¬bad

(cid:12)

(cid:11)

(cid:11)

G. Barthe et al.

224
Furthermore, since D makes at most q1 queries to O1 and q2 queries to oracle O2, A
makes at most q = q1 + q2 queries to its oracle.
We next transform the implementation of oracle O in games G1 and G2 to enforce
the bound q1 + q2 on the total number of queries. After the allotted number of queries is
exhausted, oracle O behaves the same way in the two games. This ensures that further
queries will not make the statistical distance between the two games grow and paves
the way to applying Lemma 1. This transformation preserves observational equivalence
because we know that A will not make more queries than allowed. One way of justifying
this is using the syntactic criterion for Lemma 2: we annotate the games with a ﬂag bad
that is set to true at points where the implementations of the oracle O in the games differ
and obtain

But since bad =⇒ q < |L| is an invariant and |L| ≤ q is a post-condition of both
games,

(cid:11)

Pr

Gbad

1

(cid:12)
: b = true

= Pr

Gbad

2

(cid:12)
: b = true

, deﬁning cntr = |L| and
We can now apply Lemma 1 to the games G2 and Gbad
h(i) = if i < q then 2 else 0. The second hypothesis of the lemma, i.e that a call to
E2(O) cannot decrease |L|, is immediate. We can assume that 2q < 1 (otherwise the
theorem is trivially true). Then,

2

(cid:2)cntr(cid:3)m(cid:2)−1(cid:4)

i=(cid:2)cntr(cid:3)m

h(i) ≤ 2q < 1,

and

¯hcntr(m, m

(cid:3)

) =

(cid:2)cntr(cid:3)m(cid:2)−1(cid:4)

i=(cid:2)cntr(cid:3)m

h(i)

We are only left to prove that
(cid:4)E2(O), Ebad

2

(O)(cid:5) (cid:16) λm. (cid:2)E2(O)(cid:3) m (λm

(cid:3)

. ¯hcntr(m, m

(cid:3)

))

Doing a case analysis on the conditions x ∈ dom(L) and |L| < q yields four cases;
three of them yield a null distance and are immediate. The remaining case, where x /∈
dom(L) and |L| < q, yields a distance 2 and follows from Lemma 3. We ﬁnally obtain
(cid:5) (cid:16) 2(q1+q2), which combined with the previous results implies the desired
(cid:4)G2, Gbad
(cid:23)(cid:24)
inequality.

2

6 Application to Elliptic Curves

This section discuss the application of the proof presented in the previous section to
hashing into elliptic curves.

Let Fpm be a ﬁnite ﬁeld of cardinal pm, with p > 3 prime. An elliptic curve over Fpm
is deﬁned by the equation Y 2 = X 3 + aX + b where the parameters a, b are elements
of Fpm such that 4a3 + 27b2 (cid:22)= 0 (the curve must be non-singular). The set of points of
such a curve, which we denote Ea,b, can be construed as a ﬁnite abelian group with the
point at inﬁnite O as the identity element. Furthermore, it can be shown that the group
Ea,b is either cyclic or a product of two cyclic groups.

Veriﬁed Indifferentiable Hashing into Elliptic Curves

225

Hence, applying the results from the previous section, any polynomially invertible
function into a Ea,b can be transformed into a hash function that is indifferentiable from
a random oracle. In particular, this holds for Icart encoding, as we show next.

For pm ≡ 2 (mod 3), Icart function fa,b : Fpm → Ea,b is deﬁned as:

⎧⎨
⎩

(x, ux + v) if u (cid:22)= 0
((−b)
O

3 , 0) if u = 0 ∧ a = 0
if u = 0 ∧ a (cid:22)= 0

1

(4)

fa,b(u) def=
(cid:9)
v2 − b − u6
27

x =

(cid:10) 1

3

+

u2
3

where

3a − u4

6u

v =

As a side remark, observe that the original deﬁnition only deals with the case a (cid:22)= 0;
the deﬁnition for the case a = 0 was suggested to us by Thomas Icart in a private
communication.

The set of pre-images of a point in the curve under Icart function can be computed
efﬁciently by solving for the roots of polynomials over Fpm of degree at most 4—any
point in the curve has at most 4 pre-images:

(cid:16){u|u3 − 6uX + 6Y = 0}
if a = 0
{u|u4 − 6u2X + 6uY = 3a} if a (cid:22)= 0
This can be done using any efﬁcient algorithm for factoring polynomials over ﬁnite
ﬁelds, e.g. Berlekamp’s algorithm. Thus, Icart encoding is polynomially invertible.

(cid:16){0} if a (cid:22)= 0
∅

−1
a,b (X, Y ) def=

−1
a,b (O) def=

if a = 0

f

f

Formalization. To apply our generic proof of indifferentiability to Icart function, we
proceeded as follows:

1. We integrated Th´ery’s formalization of elliptic curves [30] in our framework, and
showed that the set of points of the elliptic curve Ea,b can be construed as a ﬁnite
cyclic group, as deﬁned in SSREFLECT standard library [19];

2. We deﬁned Icart function, and showed that it generates points in the curve Ea,b.
This required showing the existence of cubic roots in the ﬁeld Fpm (the cubic root
of x ∈ Fpm is the element x(2pm−1)/3);

3. We deﬁned the inverse of Icart function, for which we need to assume an efﬁcient
method for factoring polynomials of degree 4 over the underlying ﬁeld, as no existing 
Coq library readily provides the necessary background;

4. We applied Theorem 1 to show that Icart function is an (α, 0)-weak encoding,

where α = 4N/pm where N is the order of Ea,b;
5. We applied Theorem 2 to show that for any polynomially bounded T , the function
F : Fpm × ZN , deﬁned as F (u, z) = fa,b(u) + gz, where g is a generator of ZN ,
is an -admissible encoding, where  = (1 − α
6. We ﬁnally applied Theorem 3 to show that if F is composed with a random oracle
into Fpm × ZN (equivalently, a random oracle into Fpm and a random oracle into
ZN ), the resulting construction is (tS , tD, q1, q2, 2(q1 + q2))-indifferentiable from
a random oracle into Ea,b, where tS = q1 tIF = q1 (T + 1) tf−1 and tf−1 is an
upper bound on the time needed to compute the pre-image of a point under Icart
function, i.e. to solve a polynomial of degree 4 in Fpm.

−1)T +1;

226

G. Barthe et al.

7 Related Work

Weak Equivalences. The impossibility to achieve perfect security has motivated several
proposals for weaker, quantitative, deﬁnitions of security. Prominent examples include
notions of conﬁdentiality based on information theory [11, 12, 24, 29]. More recently,
Dwork [14] has suggested differential privacy as an alternative notion that quantiﬁes
the privacy guaranteed by conﬁdential data analysis. All of these deﬁnitions can be construed 
as quantitative hyperproperties [12], and readily extend to relational properties
that are closely related to statistical distance.

Approximate observational equivalence is also closely related to weak notions of
bisimulations [26]. Barthe et al. [6] generalize approximate observational equivalence
to an approximate relational Hoare logic and report on an extension of the CertiCrypt
framework for reasoning about differential privacy. The validity of judgments in this
logic is based on a notion of approximate lifting of a relation that is closely related to
the notion used in [26].

Hashing into Elliptic Curves. A number of highly relevant cryptographic constructions,
including identity based schemes [8] and password based key exchange protocols [7],
require hashing into elliptic curves. Indeed, there have been a number of proposals for
such hash functions, see for instance [17, 21, 27]. Recently, Farashahi et al. [15] developed 
powerful techniques to show the indifferentiability of hash function constructions
based on deterministic encodings. Their results improve on [9], in the sense that they
apply to a larger class of encodings, including encodings to hyperelliptic curves, and
that they provide tighter bounds for encodings that are covered by both methods.

Formalization and Veriﬁcation of Elliptic Curves. To our best knowledge, our work
provides the ﬁrst machine-checked proof of security for a cryptographic primitive based
on elliptic curves. There are, however, previous works on the formalization of elliptic
curves: Hurd, Gordon and Fox [20] report on the veriﬁcation in HOL of the group
laws and an application to the functional correctness of ElGamal encryption. Th´ery and
Hanrot [30] use Coq to formalize the group laws, and show how the formalization of
elliptic curves can be used to build efﬁcient reﬂective tactics for testing primality.

8 Conclusion

This paper reports on a machine-checked proof of a recent construction to build hash
functions that are indifferentiable from a random oracle into an elliptic curve. The example 
is singular among other examples that have been formalized using CertiCrypt,
because it involves complex reasoning about algebraic geometry and requires the formalization 
of new weak forms of program equivalence.

The formalization establishes the ability of CertiCrypt to integrate smoothly with
existing libraries of complex mathematics. Overall, the formalization consists of over
65,000 lines of Coq (without counting components reused from the standard libraries
of Coq and SSReﬂect), which break down as follows: 45,000 lines corresponding to
the original CertiCrypt framework, 3,500 lines of extensions to CertiCrypt, 7,000 lines

Veriﬁed Indifferentiable Hashing into Elliptic Curves

227

written originally for our application to indifferentiability, and 10,000 lines of a slightly
adapted version of Th´ery [30] elliptic curve library.

Our work paves the way for further developments. We are interested in leveraging our
earlier formalization of zero-knowledge protocols [5] to statistical zero-knowledge, and
to use the result as a back-end for a certifying ZK compiler, in the style of [1]. We also
intend to pursue the machine-checked formalization of indifferentiability proofs, and
in particular to show that the ﬁnalists of NIST SHA-3 competition are indifferentiable
from a random oracle. Finally, it would be of interest to enhance EasyCrypt [3], an
automated front-end that generates veriﬁable security proofs in CertiCrypt, so that it
can manipulate the notions of equivalence considered in this paper (and in [6]).

Acknowledgments. This work was partially funded by European Projects FP7-256980
NESSoS and FP7-229599 AMAROUT, Spanish project TIN2009-14599 DESAFIOS
10, Madrid Regional project S2009TIC-1465 PROMETIDOS and French project ANR
SESUR-012 SCALP.

References

1. Almeida, J.B., Bangerter, E., Barbosa, M., Krenn, S., Sadeghi, A.-R., Schneider, T.: A Certifying 
Compiler for Zero-Knowledge Proofs of Knowledge Based on Σ-Protocols. In: Gritzalis,
 D., Preneel, B., Theoharidou, M. (eds.) ESORICS 2010. LNCS, vol. 6345, pp. 151–167.
Springer, Heidelberg (2010)

2. Audebaud, P., Paulin-Mohring, C.: Proofs of randomized algorithms in Coq. Sci. Comput.

Program. 74(8), 568–589 (2009)

3. Barthe, G., Gr´egoire, B., Heraud, S., Zanella B´eguelin, S.: Computer-Aided Security Proofs
for the Working Cryptographer. In: Rogaway, P. (ed.) CRYPTO 2011. LNCS, vol. 6841,
pp. 71–90. Springer, Heidelberg (2011)

4. Barthe, G., Gr´egoire, B., Zanella B´eguelin, S.: Formal certiﬁcation of code-based cryptographic 
proofs. In: 36th ACM SIGPLAN-SIGACT Symposium on Principles of Programming 
Languages, POPL 2009, pp. 90–101. ACM, New York (2009)

5. Barthe, G., Hedin, D., Zanella B´eguelin, S., Gr´egoire, B., Heraud, S.: A machine-checked
formalization of Sigma-protocols. In: 23rd IEEE Computer Security Foundations Symposium,
 CSF 2010, pp. 246–260. IEEE Computer Society, Los Alamitos (2010)

6. Barthe, G., K¨opf, B., Olmedo, F., Zanella B´eguelin, S.: Probabilistic reasoning for differential 
privacy. In: 39th ACM SIGPLAN-SIGACT Symposium on Principles of Programming
Languages, POPL 2012. ACM (2012)

7. Bellovin, S., Merritt, M.: Encrypted key exchange: password-based protocols secure against
dictionary attacks. In: 13th IEEE Symposium on Security and Privacy, S&P 1992, pp. 72–84.
IEEE Computer Society, Los Alamitos (1992)

8. Boneh, D., Lynn, B., Shacham, H.: Short signatures from the Weil pairing. Journal of Cryptology 
17, 297–319 (2004)

9. Brier, E., Coron, J.-S., Icart, T., Madore, D., Randriam, H., Tibouchi, M.: Efﬁcient Indifferentiable 
Hashing into Ordinary Elliptic Curves. In: Rabin, T. (ed.) CRYPTO 2010. LNCS,
vol. 6223, pp. 237–254. Springer, Heidelberg (2010)

10. Canetti, R., Goldreich, O., Halevi, S.: The random oracle methodology, revisited. J.

ACM 51(4), 557–594 (2004)

11. Clark, D., Hunt, S., Malacaria, P.: A static analysis for quantifying information ﬂow in a

simple imperative language. Journal of Computer Security 15(3), 321–371 (2007)

228

G. Barthe et al.

12. Clarkson, M.R., Schneider, F.B.: Hyperproperties. Journal of Computer Security 18(6),

1157–1210 (2010)

13. Coron, J.-S., Dodis, Y., Malinaud, C., Puniya, P.: Merkle-Damg˚ard Revisited: How to Construct 
a Hash Function. In: Shoup, V. (ed.) CRYPTO 2005. LNCS, vol. 3621, pp. 430–448.
Springer, Heidelberg (2005)

14. Dwork, C.: Differential Privacy. In: Bugliesi, M., Preneel, B., Sassone, V., Wegener, I. (eds.)

ICALP 2006. LNCS, vol. 4052, pp. 1–12. Springer, Heidelberg (2006)

15. Farashahi, R.R., Fouque, P.A., Shparlinski, I., Tibouchi, M., Voloch, J.F.: Indifferentiable deterministic 
hashing to elliptic and hyperelliptic curves. Mathematics of Computation (2011)
16. Fleischmann, E., Gorski, M., Lucks, S.: Some Observations on Indifferentiability. In: Steinfeld,
 R., Hawkes, P. (eds.) ACISP 2010. LNCS, vol. 6168, pp. 117–134. Springer, Heidelberg
(2010)

17. Fouque, P.-A., Tibouchi, M.: Deterministic Encoding and Hashing to Odd Hyperelliptic
Curves. In: Joye, M., Miyaji, A., Otsuka, A. (eds.) Pairing 2010. LNCS, vol. 6487, pp. 265–277.
Springer, Heidelberg (2010)

18. Goldwasser, S., Micali, S.: Probabilistic encryption. J. Comput. Syst. Sci. 28(2), 270–299

(1984)

19. Gonthier, G., Mahboubi, A., Rideau, L., Tassi, E., Th´ery, L.: A Modular Formalisation of
Finite Group Theory. In: Schneider, K., Brandt, J. (eds.) TPHOLs 2007. LNCS, vol. 4732,
pp. 86–101. Springer, Heidelberg (2007)

20. Hurd, J., Gordon, M., Fox, A.: Formalized elliptic curve cryptography. In: High Conﬁdence

Software and Systems, HCSS 2006 (2006)

21. Icart, T.: How to Hash into Elliptic Curves. In: Halevi, S. (ed.) CRYPTO 2009. LNCS,

vol. 5677, pp. 303–316. Springer, Heidelberg (2009)

22. Icart, T.: Algorithms Mapping into Elliptic Curves and Applications. Ph.D. thesis, Universit´e

du Luxembourg (2010)

23. Maurer, U.M., Renner, R.S., Holenstein, C.: Indifferentiability, Impossibility Results on Reductions,
 and Applications to the Random Oracle Methodology. In: Naor, M. (ed.) TCC
2004. LNCS, vol. 2951, pp. 21–39. Springer, Heidelberg (2004)

24. Pierro, A.D., Hankin, C., Wiklicky, H.: Approximate non-interference. Journal of Computer

Security 12(1), 37–82 (2004)

25. Ristenpart, T., Shacham, H., Shrimpton, T.: Careful with Composition: Limitations of the Indifferentiability 
Framework. In: Paterson, K.G. (ed.) EUROCRYPT 2011. LNCS, vol. 6632,
pp. 487–506. Springer, Heidelberg (2011)

26. Segala, R., Turrini, A.: Approximated computationally bounded simulation relations for
probabilistic automata. In: 20th IEEE Computer Security Foundations Symposium, CSF
2007, pp. 140–156 (2007)

27. Shallue, A., van de Woestijne, C.E.: Construction of Rational Points on Elliptic Curves
over Finite Fields. In: Hess, F., Pauli, S., Pohst, M. (eds.) ANTS 2006. LNCS, vol. 4076,
pp. 510–524. Springer, Heidelberg (2006)

28. Shoup, V.: A Computational Introduction to Number Theory and Algebra, 2nd edn. Cambridge 
University Press (2009)

29. Smith, G.: On the Foundations of Quantitative Information Flow. In: de Alfaro, L. (ed.)

FOSSACS 2009. LNCS, vol. 5504, pp. 288–302. Springer, Heidelberg (2009)

30. Th´ery, L., Hanrot, G.: Primality Proving with Elliptic Curves. In: Schneider, K., Brandt, J.

(eds.) TPHOLs 2007. LNCS, vol. 4732, pp. 319–333. Springer, Heidelberg (2007)

