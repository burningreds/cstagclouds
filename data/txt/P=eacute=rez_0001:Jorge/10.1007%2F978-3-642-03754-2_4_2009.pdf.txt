Foundations of RDF Databases

Marcelo Arenas1, Claudio Gutierrez2, and Jorge P´erez1

1 Department of Computer Science, Pontiﬁcia Universidad Cat´olica de Chile

2 Department of Computer Science, Universidad de Chile

Abstract. The goal of this paper is to give an overview of the basics
of the theory of RDF databases. We provide a formal deﬁnition of RDF
that includes the features that distinguish this model from other graph
data models. We then move into the fundamental issue of querying RDF
data. We start by considering the RDF query language SPARQL, which
is a W3C Recommendation since January 2008. We provide an algebraic
syntax and a compositional semantics for this language, study the complexity 
of the evaluation problem for diﬀerent fragments of SPARQL, and
consider the problem of optimizing the evaluation of SPARQL queries,
showing that a natural fragment of this language has some good properties 
in this respect. We furthermore study the expressive power of
SPARQL, by comparing it with some well-known query languages such
as relational algebra. We conclude by considering the issue of querying
RDF data in the presence of RDFS vocabulary. In particular, we present
a recently proposed extension of SPARQL with navigational capabilities.

1 Introduction

The Resource Description Framework (RDF) [34] is a data model for representing
information about World Wide Web resources. Jointly with its release in 1998 as
Recommendation of the W3C, the natural problem of querying RDF data was
raised. Since then, several designs and implementations of RDF query languages
have been proposed. In 2004, the RDF Data Access Working Group, part of the
W3C Semantic Web Activity, released a ﬁrst public working draft of a query
language for RDF, called SPARQL [45]. Since then, SPARQL has been rapidly
adopted as the standard for querying Semantic Web data. In January 2008,
SPARQL became a W3C Recommendation.

RDF and SPARQL are two of the core technologies in the data and query layers 
of the Semantic Web stack. In this paper, we give an overview of the current
state of the theory of RDF and SPARQL from a database perspective. We ﬁrst
provide a formal deﬁnition of RDF that includes the features that distinguish
this model from other database models. We then move into the fundamental
issue of querying RDF data with SPARQL. We provide an algebraic syntax and
a compositional semantics for this language, study the complexity of the evaluation 
problem for diﬀerent fragments of SPARQL, and consider the problem
of optimizing the evaluation of SPARQL queries, showing that a natural fragment 
of this language has some good properties in this respect. We furthermore

S. Tessaris et al. (Eds.): Reasoning Web 2009, LNCS 5689, pp. 158–204, 2009.
c(cid:2) Springer-Verlag Berlin Heidelberg 2009

Foundations of RDF Databases

159

study the expressive power of SPARQL, by comparing it with some well-known
query languages such as relational algebra. We conclude by considering the issue 
of querying RDF data in the presence of RDFS vocabulary. In particular, we
present a recently proposed extension of SPARQL with navigational capabilities,
and show that this language is expressive enough to deal with the semantics of
the RDFS vocabulary.

The paper is organized as follows. In Section 2, we introduce RDF as a data
model. In Section 3, we provide a formalization of the syntax and semantics of
SPARQL. In Section 4, we study the complexity of the evaluation problem for
SPARQL and some optimization results for this language. In Section 5, we study
the expressiveness of SPARQL. Finally, we present in Section 6 an extension of
SPARQL that gives navigational capabilities to the language and allows to deal
with the RDFS vocabulary.

2 The RDF Data Model

The Semantic Web is a proposal to build an infrastructure of machine-readable
semantics for the data on the Web. In 1998, the W3C issued a recommendation
of a metadata model and language to serve as the basis for such infrastructure,
the Resource Description Framework (RDF) [32]. As RDF evolves, it is increasingly 
gaining attraction from both researchers and practitioners, and is being
implemented in world-wide initiatives such as the Open Directory Project [39],
Dublin Core [48], FOAF [49], and RSS [46].

RDF follows the W3C design principles of interoperability, extensibility, evolution 
and decentralization. Particularly, the RDF model was designed to have
a simple data model, with a formal semantics and provable inference, with
an extensible URI-based vocabulary, and which allows anyone to make statements 
about any resource. In the RDF model, the universe to be modeled is a
set of resources, essentially anything that can have a universal resource identiﬁer,
 URI [50]. The language to describe them is a set of properties, technically
binary predicates. Descriptions are statements very much in the subject-predicateobject 
structure, where predicate and object are resources or strings. Both subject 
and object can be anonymous objects, known as blank nodes. In addition,
the RDF speciﬁcation includes a built-in vocabulary with a normative semantics 
(RDFS). This vocabulary deals with inheritance of classes and properties,
as well as typing, among other features [11].

The RDF model is speciﬁed in a series of W3C documents [11,27,32,34]. In
this section, we introduce an abstract version of the RDF data model, which
is both a fragment following faithfully the original speciﬁcation, and also an
abstract version suitable to do formal analysis. What is left out are features of
RDF dealing with some implementation issues, such as detailed typing issues,
some distinguish vocabulary which has no particular semantics, and all topics
involved with the XML-based syntax and serialization. The original formulation
of this fragment was introduced in [23], and enriched and corrected in [37]. The
main goal of isolating such a fragment is to have a simple and stable core over

160

M. Arenas, C. Gutierrez, and J. P´erez

which to discuss theoretical issues, dealing with RDF from a database point of
view.

2.1 RDF Graphs

Assume there are pairwise disjoint inﬁnite sets U (RDF URI references) and B
(Blank nodes)1. Through the paper we assume U and B ﬁxed, and for simplicity 
we denote unions of these sets simply concatenating their names. A tuple
(s, p, o) ∈ UB × U × UB is called an RDF triple. In this tuple, s is the subject,
p the predicate, and o the object.

Deﬁnition 1. An RDF graph (or simply a graph) is a set of RDF triples. A
graph is ground if it has no blank nodes.

Graphically, we represent RDF graphs as follows: each triple (s, p, o) is repre-
p−→ o. Notice that the set of arc labels can have a
sented by a labeled edge s
non-empty intersection with the set of node labels. Thus, technically speaking,
and “RDF graph” is not a graph in the classical sense (for further discussion on
this issue see [26]).
In what follows, we need the fundamental notion of homomorphism. Given
two RDF graphs G1 and G2, a homomorphism h : G1 → G2 is a mapping from
UB to UB such that h(u) = u for every element u ∈ U, and for every triple
(s, p, o) in G1, it holds that (h(s), h(p), h(o)) ∈ G2. We denote by h(G1) the
RDF graph {(h(s), h(p), h(o)) | (s, p, o) ∈ G1}. Thus, a homomorphism h from
G1 to G2 is such that h(G1) ⊆ G2.

2.2 RDFS

The RDF speciﬁcation includes a set of reserved words, the RDFS vocabulary
(RDF Schema [11]), which is designed to describe relationships between resources
and properties like attributes of resources (traditional attribute-value pairs).
Roughly speaking, this vocabulary can be conceptually divided into the following
groups:

(a) A set of properties, which are binary relations between subject resources
and object resources: rdfs:subPropertyOf (denoted by sp in this paper),
rdfs:subClassOf (sc), rdfs:domain (dom), rdfs:range (range) and rdf:type
(type).

(b) A set of classes, that denote set of resources. Elements of a class are known
as instances of that class. To state that a resource is an instance of a class,
the reserved word type may be used.

1 For the sake of simplicity, here we do not make a special distinction between URIs
and Literals, and we assume that RDF graphs are constructed by using only URIs
and Blank nodes. The inclusion of literals does not change any of the results of this
paper.

Foundations of RDF Databases

161

(c) Other functionalities, like a system of classes and properties to describe lists,

(d) Utility vocabulary used to document, comment, etc. (the complete vocabuand 
a system for doing reiﬁcation.

lary can be found in [11]).

The groups in (b), (c) and (d) have a light semantics, essentially describing their
internal relationships in the ontological design of the system of classes of RDFS.
Their semantics is deﬁned by a set of “axiomatic triples” [27], which express
the relationships among these reserved words. All axiomatic triples are “struc-
tural”, in the sense that do not refer to external data. Much of this semantics
corresponds to what in standard languages is captured via typing.

On the contrary, the group (a) is formed by predicates whose intended meaning 
is non-trivial, and is designed to relate individual pieces of data external to
the vocabulary of the language. Their semantics is deﬁned by rules which involve
variables (to be instantiated by actual data). For example, rdfs:subClassOf (sc)
is a reﬂexive and transitive binary property; and when combined with rdf:type
(type) specify that the type of an individual (a class) can be lifted to that of a
superclass.

The group (a) forms the core of the RDF language and, from a theoretical
point of view, it has been shown to be a very stable core to work with (the
detailed arguments supporting this claim are given in [37]). Thus, throughout
the paper we focused on the fragment of RDFS given by the set of keywords
{sp, sc, type, dom, range}.

2.3 Semantics of RDF Graphs

In this section, we present the formalization of the semantics of RDF given in
[27,37]. The normative semantics for RDF graphs given in [27] follows a standard 
logical treatment, including classical notions such as model, interpretation,
entailment, and so on. We present the simpliﬁcation of the normative semantics
proposed in [37]. It is important to notice that these two approaches were shown
to be equivalent for the fragment of the RDFS vocabulary considered in this
paper [37].
An RDF interpretation is a tuple I = (Res, Prop, Class, PExt , CExt, Int),
where (1) Res is a nonempty set of resources, called the domain or universe of
I; (2) Prop is a set of property names (not necessarily disjoint from Res); (3)
Class ⊆ Res is a distinguished subset of Res identifying if a resource denotes
a class of resources; (4) PExt : Prop → 2Res×Res, a mapping that assigns an
extension to each property name; (5) CExt : Class → 2Res a mapping that
assigns a set of resources to every resource denoting a class; (6) Int : U →
Res ∪ Prop, the interpretation mapping, is a mapping that assigns a resource or
a property name to each element of U.
Intuitively, a ground triple (s, p, o) in a graph G is true under the interpretation 
I, if p is interpreted as a property name, s and o are interpreted as resources,
and the interpretation of the pair (s, o) belongs to the extension of the property 
assigned to p. Formally, we say that I satisﬁes the ground triple (s, p, o) if

162

M. Arenas, C. Gutierrez, and J. P´erez

Int(p) ∈ Prop and (Int(s), Int(o)) ∈ PExt(Int(p)). An interpretation must also
satisfy additional conditions induced by the usage of the RDFS vocabulary. For
example, an interpretation satisfying the triple (c1, sc, c2) must interpret c1 and
c2 as classes of resources, and must assign to c1 a subset of the set assigned to
c2. More formally, we say that I satisﬁes (c1, sc, c2) if Int(c1), Int(c2) ∈ Class
and CExt(c1) ⊆ CExt(c2).
Blank nodes work as existential variables. Intuitively, a triple (x, p, o) would
be true under I, where x is a blank node, if there exists a resource s such that
(s, p, o) is true under I. An arbitrary element can be chosen when interpreting a
blank node, with the restriction that all the occurrences of the same blank node in
an RDF graph must be replaced by the same value. To formally deal with blank
nodes, an extension of the interpretation mapping Int is used. Let A : B → Res
be a function between blank nodes and resources. Then Int A : UB → Res
is deﬁned as the extension of function Int: Int A(x) = A(x) for x ∈ B, and
Int A(x) = Int(x) for x ∈ U.
We next formalize the notion of model for an RDF graph [27,37]. We say that
the RDF interpretation I = (Res, Prop, Class, PExt , CExt, Int) is a model of
(is an interpretation for) an RDF graph G, denoted by I |= G, if the following
conditions hold:

Simple Interpretation:

– there exists a function A : B → Res such that for each (s, p, o) ∈ G, it

holds that Int(p) ∈ Prop and (Int A(s), Int A(o)) ∈ PExt(Int(p)).

Properties and Classes:

– Int(sp), Int(sc), Int(type), Int(dom), Int(range) ∈ Prop,
– if (x, y) ∈ PExt(Int(dom)) ∪ PExt(Int(range)), then x ∈ Prop and y ∈

Class.
Sub-property:

Sub-class:

– PExt(Int(sp)) is transitive and reﬂexive over Prop,
– if (x, y) ∈ PExt(Int(sp)), then x, y ∈ Prop and PExt(x) ⊆ PExt(y).

Typing:

– PExt(Int(sc)) is transitive and reﬂexive over Class,
– if (x, y) ∈ PExt(Int(sc)), then x, y ∈ Class and CExt(x) ⊆ CExt(y).
– (x, y) ∈ PExt(Int(type)) if and only if y ∈ Class and x ∈ CExt(y),
– if (x, y) ∈ PExt(Int(dom)) and (u, v) ∈ PExt(x), then u ∈ CExt(y),
– if (x, y) ∈ PExt(Int(range)) and (u, v) ∈ PExt(x), then v ∈ CExt(y).

Example 1. Figure 1 shows an RDF graph storing information about painters.
All the triples in the graph are composed by elements in U, except for the triples
containing the blank node X. Consider now the interpretation I = (Res, Prop,
Class, PExt, CExt, Int) deﬁned as follows:
– Res = {Painter, Guayasamin, Cubist, creates, paints, Guernica, Bilbao}.
– Prop = {paints, creates, exhibited in, type, sp, sc, dom, range}.
– Class = {Cubist, Painter}.
– PExt is such that:

Foundations of RDF Databases

163

Painter

sc

Cubist

type

type

type

Guayasamin

X

creates

sp

paints

exhibited in

Guernica

Bilbao

Fig. 1. Example of an RDF graph

• PExt(paints) = PExt(creates) = {(Guayasamin, Guernica)},
• PExt(exhibited in) = {(Guernica, Bilbao)},
• PExt(type) = {(Guayasamin, Cubist), (Guayasamin, Painter)},
• PExt(sp) = {(paints, create)} ∪ {(x, x) | x ∈ Prop},
• PExt(sc) = {(Cubist, Painter), (Cubist, Cubist), (Painter, Painter)},
• PExt(dom) = PExt(range) = ∅.

– CExt is such that CExt(Cubist) = CExt(Painter) = {Guayasamin}.
– Int is the identity mapping over Res ∪ Prop.
Notice that in our interpretation the sets Res and Prop are subsets of U, but in
general, Res and Prop can be arbitrary sets. Let G be the RDF graph of Fig. 1.
By considering the function A : B → Res such that A(X) = Guayasamin, it can
be shown that I |= G, that is, I satisﬁes all the conditions to be a model of G.
In the interpretation I, we use Guayasamin as a witness for the blank node
X. Another model of G can use a diﬀerent witness. For example consider the
interpretation I(cid:3) = (Res
– Res(cid:3) = Res ∪ {Picasso}.
– PExt(cid:3) is such that:

(cid:3), Prop, Class, PExt

(cid:3), CExt

Painter) },

• PExt(cid:3)(paints) = PExt(cid:3)(creates) = {(Picasso, Guernica)},
• PExt(cid:3)(type) = { (Picasso, Cubist), (Picasso, Painter), (Guayasamin,
• PExt(cid:3) is equal to PExt in every other case.
Guayasamin}

– CExt(cid:3) is such that CExt(cid:3)(Cubist) = {Picasso} and CExt(cid:3)(Painter) = {Picasso,

is the identity mapping over Res

– Int
It can be shown that interpretation I(cid:3) is also a model for G, but this time using
(cid:7)(cid:8)
Picasso as witness for the blank node X in G.

(cid:3), Int

(cid:3)

) where:

(cid:3)

(cid:3) ∪ Prop.

2.4 A Deductive System for RDFS

The notion of entailment has shown to be of fundamental importance for many
tasks in the database context, and as such it also plays a fundamental role in
the context of RDF. Indeed, this notion has been present since the beginning of
the Semantic Web initiative. In this section, we study this concept in detail.

164

M. Arenas, C. Gutierrez, and J. P´erez

Given RDF graphs G1 and G2, we say that G1 entails G2, denoted by G1 |=
G2, if for every interpretation I such that I |= G1, it holds that I |= G2. In
[37], the authors showed that this entailment notion between RDF graphs is
equivalent to the W3C normative notion of entailment [27], for the fragment of
the RDFS vocabulary considered in this paper. In Table 1, we present a deductive
system for this notion. This system was given in [37], and is based on a set of
rules for |= introduced in [27].
The ﬁrst rule in Tab. 1 captures the semantics of blank nodes. In every rule
(2)-(7), letters A, B, C, X , and Y, stand for variables to be replaced by actual
terms. More formally, an instantiation of a rule (2)-(7) is a replacement of the
variables occurring in the triples of the rule by elements of UB, such that all the

Table 1. RDFS inference rules

G
G(cid:2)

for a homomorphism h : G(cid:2) → G

(A,sp,B) (X ,A,Y)

(X ,B,Y)

(b)

(b)

(A,sc,B) (X ,type,A)

(X ,type,B)

(b)

(A,range,B) (X ,A,Y)

(Y,type,B)

1. Existential:

2. Subproperty:

(a)

(A,sp,B) (B,sp,C)

(A,sp,C)

3. Subclass:

(a)

(A,sc,B) (B,sc,C)

(A,sc,C)

4. Typing:

(a)

(A,dom,B) (X ,A,Y)

(X ,type,B)

5. Implicit Typing:

(a)

(A,dom,B) (C,sp,A) (X ,C,Y)

(X ,type,B)

(b)

(A,range,B) (C,sp,A) (X ,C,Y)

(Y,type,B)

6. Subproperty Reﬂexivity:

(a)

(b)

(X ,A,Y)
(A,sp,A)

(A,sp,B)

(A,sp,A) (B,sp,B)

7. Subclass Reﬂexivity:

(a)

(A,sc,B)

(A,sc,A) (B,sc,B)

(c) (p,sp,p)
(A,p,X )
(A,sp,A)

(d)

for p ∈ {sp, sc, dom,
for p ∈ {dom, range}

range, type}

(b)

(X ,p,A)
(A,sc,A)

for p ∈ {dom, range, type}

Foundations of RDF Databases

165

Painter

sc

Cubist

type

type

Guayasamin

Picasso

creates

sp

paints

exhibited in

Bilbao

Guernica

Dryad

Fig. 2. RDF graph from which we can deduce the graph in Fig. 1

triples obtained after the replacement are well formed RDF triples, that is, not
assigning blank nodes to variables in predicate positions.
An application of a rule to a graph G is deﬁned as follows. For rule (1), if
h is a homomorphism from G(cid:3) to G, then G(cid:3) is the result of an application of
rule (1) to G. If r is any of the rules (2)-(7), and there is an instantiation R
R(cid:2) of
r such that R ⊆ G, then the graph G(cid:3) = G ∪ R(cid:3) is the result of an application
of r to G. We say that a graph G(cid:3) is deduced from G, if G(cid:3) is obtained from G
by successively applying the rules in Tab. 1.

In [37], the authors proved that the set of rules in Tab. 1 is sound and complete
for the inference problem for the fragment of RDFS consisting of the reserved
words sc, sp, range, dom and type. That is, it captures the semantics of the
normative RDF speciﬁcation when one focuses on the fragment of the RDFS
vocabulary considered in this paper.

Theorem 1 (Soundness and completeness [37]). Let G and H be RDF
graphs, then G |= H iﬀ H is deduced from G by applying rules in Tab. 1.
It is worth mentioning that the set of rules presented in [27] is not complete for |=
(this was pointed out by Marin in [35]). The problem with the system proposed
in [27] is that a blank node X can be implicitly used as a property in triples
like (a, sp, X), (X, dom, b), and (X, range, c). This problem was solved in [37] by
following the approach proposed by Marin [35]. In fact, the rules (5a)-(5b) were
added to the system given in [27] to deal with this problem.
Example 2. Let G be the graph in Fig. 1 and G(cid:3) the graph in Fig. 2. Notice that
the triples (Picasso, type, Cubist) and (Cubist, sc, Painter) belong to G(cid:3). Thus,
by using rule (3b) we obtain that G(cid:3)(cid:3) = G(cid:3)∪{(Picasso, type, Painter)} is deduced
from G(cid:3). Moreover, if we consider a homomorphism h such that h(X) = Picasso,
then we have that h(G) ⊆ h(G(cid:3)(cid:3)), and, thus, applying rule (1) we conclude that
G can be deduced from G(cid:3)(cid:3). Therefore, the graph G can be deduced from G(cid:3) by
successively applying rules (3b) and (1). Hence, from Theorem 1 we have that
(cid:7)(cid:8)
every model of G(cid:3) is also a model of G, i.e. G(cid:3) |= G.
In [37], the authors showed that the deductive system of Tab. 1 can be simpliﬁed
by imposing some syntactic restrictions on RDF graphs. The most simple case

166

M. Arenas, C. Gutierrez, and J. P´erez

is obtained when G and H are graphs that do not have blank nodes, and do
not mention RDFS vocabulary. In that case, the entailment relation G |= H is
reduced to just testing whether H ⊆ G. On the other hand, if G and H are
RDF graphs that do not mention RDFS vocabulary (but possibly blank nodes),
then G |= H if and only if H can be obtained from G by using rule (1), that
is, if and only if there exists a homomorphism h : H → G2. Another important
simpliﬁcation is obtained if one forbids the presence of reﬂexive triples. A triple
t is reﬂexive if t is of the form (x, sp, x) or (x, sc, x) for x ∈ UB. We formalize
two of these special cases in the following proposition.

Proposition 1 ([37])

1. If G and H are RDF graphs that do not mention RDFS vocabulary, then

G |= H iﬀ there exists a homomorphism h : H → G.
triples, then G |= H iﬀ H can be deduced from G by using rules (2)-(4).

2. If G and H are RDF graphs that have neither blank nodes nor reﬂexive

In the following sections, we study the fundamental problem of querying RDF
data. There is no yet consensus in the Semantic Web community on how to
deﬁne a query language for RDF that includes all the features of the RDF data
model, in particular blank nodes and the RDFS vocabulary. The speciﬁcation of
SPARQL, the standard language for RDF, currently considers RDF data without
RDFS vocabulary and with no special semantics for blank nodes. Thus, we study
SPARQL in the next sections focusing on ground RDF graphs with no RDFS
vocabulary. In Section 6.3, we explore the possibility of having an RDF query
language capable of dealing with the special semantics of the RDFS vocabulary.

3 The RDF Query Language SPARQL

In 2004, the RDF Data Access Working Group, part of the W3C Semantic Web
Activity, released a ﬁrst public working draft of a query language for RDF, called
SPARQL [45]3. Since then, SPARQL has been rapidly adopted as the standard
for querying Semantic Web data. In January 2008, SPARQL became a W3C
Recommendation.

RDF is a directed labeled graph data format and, thus, SPARQL is essentially
a graph-matching query language. SPARQL queries are composed by three parts.
The pattern matching part, which includes several interesting features of pattern
matching of graphs, like optional parts, union of patterns, nesting, ﬁltering values
of possible matchings, and the possibility of choosing the data source to be
matched by a pattern. The solution modiﬁers, which once the output of the
pattern has been computed (in the form of a table of values of variables), allow
to modify these values applying classical operators like projection, distinct, order
and limit. Finally, the output of a SPARQL query can be of diﬀerent types:

2 Notice that this result is also a corollary of [16].
3 The name SPARQL is a recursive acronym that stands for SPARQL Protocol and

RDF Query Language.

Foundations of RDF Databases

167

yes/no queries, selections of values of the variables which match the patterns,
construction of new RDF data from these values, and descriptions of resources.
The deﬁnition of a formal semantics for SPARQL has played a key role in
the standardization process of this query language. Although taken one by one
the features of SPARQL are intuitive and simple to describe and understand, it
turns out that the combination of them makes SPARQL into a complex language.
Reaching a consensus in the W3C standardization process about a formal semantics 
for SPARQL was not an easy task. The initial eﬀorts to deﬁne SPARQL
were driven by use cases, mostly by specifying the expected output for particular 
example queries. In fact, the interpretations of examples and the exact
outcomes of cases not covered in the initial drafts of the SPARQL speciﬁcation,
were a matter of long discussions in the W3C mailing lists. In [40], the authors
presented one of the ﬁrst formalizations of a semantics for a fragment of the
language. Currently, the oﬃcial speciﬁcation of SPARQL [45], endorsed by the
W3C, formalizes a semantics based on [40].

A formalization of a semantics for SPARQL is beneﬁcial for several reasons,
including to serve as a tool to identify and derive relations among the constructors 
that stay hidden in the use cases, identify redundant and contradicting
notions, to drive and help the implementation of query engines, and to study the
complexity, expressiveness, and further natural database questions like rewriting
and optimization. In this section, we present a streamlined version of the core
fragment of SPARQL with precise algebraic syntax and a formal compositional
semantics based on [40].

One of the delicate issues in the deﬁnition of a semantics for SPARQL is
the treatment of optional matching and incomplete answers. The idea behind
optional matching is to allow information to be added if the information is available 
in the data source, instead of just failing to give an answer whenever some
part of the pattern does not match. This feature of optional matching is crucial
in Semantic Web applications, and more speciﬁcally in RDF data management,
where it is assumed that every application have only partial knowledge about
the resources being managed. The semantics of SPARQL is formalized by using
partial mappings between variables in the patterns and actual values in the RDF
graph being queried. This formalization allows one to deal with partial answers
in a clean way, and is based on the extension of some classical relational algebra
operators to work over sets of partial mappings.
A SPARQL query is of the form head ← body, where the body of the query is a
complex RDF graph pattern expression that may include RDF triples with variables,
 conjunctions, disjunctions, optional parts and constraints over the values
of the variables, and the head of the query is an expression that indicates how to
construct the answer to the query. The evaluation of a query Q against an RDF
graph G is done in two steps: the body of Q is matched against G to obtain a set
of bindings for the variables in the body, and then using the information on the
head of Q, these bindings are processed applying classical relational operators
(projection, distinct, etc.) to produce the answer to the query.

168

M. Arenas, C. Gutierrez, and J. P´erez

It should be noticed that the normative speciﬁcation of SPARQL [45] is deﬁned 
over RDF graphs without RDFS vocabulary, and not considering the special 
semantics of blank nodes. In this section, we work over the same setting.

3.1 Syntax and Semantics of SPARQL Graph Patterns

We ﬁrst concentrate on the body of SPARQL queries, i.e. in the graph pattern
matching facility.

The oﬃcial syntax of SPARQL [45] considers operators OPTIONAL, UNION,
FILTER, and concatenation via a point symbol (.), to construct graph pattern
expressions. The syntax also considers { } to group patterns, and some implicit 
rules of precedence and association. For example, the point symbol (.) has
precedence over OPTIONAL, and OPTIONAL is left associative. In order to avoid
ambiguities in the parsing of expressions, we present the syntax of SPARQL
graph patterns in a more traditional algebraic formalism, using binary operators 
AND (.), UNION (UNION), OPT (OPTIONAL), and FILTER (FILTER). We
fully parenthesize expressions making explicit the precedence and association of
operators.

Assume the existence of a set of variables V disjoint from U. A SPARQL

graph pattern expression is deﬁned recursively as follows:
1. A tuple from (U ∪V )×(U ∪V )×(U ∪V ) is a graph pattern (a triple pattern).
2. If P1 and P2 are graph patterns, then expressions (P1 AND P2), (P1 OPT P2),
and (P1 UNION P2) are graph patterns (conjunction graph pattern, optional
graph pattern, and union graph pattern, respectively).

3. If P is a graph pattern and R is a SPARQL built-in condition, then the

expression (P FILTER R) is a graph pattern (a ﬁlter graph pattern).

A SPARQL built-in condition is constructed using elements of the set U ∪ V and
constants, logical connectives (¬, ∧, ∨), inequality symbols (<, ≤, ≥, >), the
equality symbol (=), unary predicates like bound, isBlank, and isIRI, plus other
features (see [45] for a complete list). In this paper, we restrict to the fragment
where the built-in condition is a Boolean combination of terms constructed by
using = and bound, that is:
1. If ?X, ?Y ∈ V and c ∈ U, then bound(?X), ?X = c and ?X =?Y are built-in
2. If R1 and R2 are built-in conditions, then (¬R1), (R1 ∨ R2) and (R1 ∧ R2)

conditions.

are built-in conditions.

Let P be a SPARQL graph pattern. In the rest of the paper, we use var(P ) to
denote the set of variables occurring in P . In particular, if t is a triple pattern,
then var(t) denotes the set of variables occurring in the components of t. Similarly,
 for a built-in condition R, we use var(R) to denote the set of variables
occurring in R.

To deﬁne the semantics of SPARQL graph pattern expressions, we need to
introduce some terminology. A mapping μ from V to U is a partial function

Foundations of RDF Databases

169

μ : V → U. Abusing notation, for a triple pattern t we denote by μ(t) the
triple obtained by replacing the variables in t according to μ. The domain of μ,
denoted by dom(μ), is the subset of V where μ is deﬁned. Two mappings μ1
and μ2 are compatible when for all ?X ∈ dom(μ1) ∩ dom(μ2), it is the case that
μ1(?X) = μ2(?X), i.e. when μ1 ∪ μ2 is also a mapping. Intuitively, μ1 and μ2 are
compatibles if μ1 can be extended with μ2 to obtain a new mapping, and vice
versa. Note that two mappings with disjoint domains are always compatible, and
that the empty mapping μ∅ (i.e. the mapping with empty domain) is compatible
with any other mapping.

Let Ω1 and Ω2 be sets of mappings. We deﬁne the join of, the union of and

the diﬀerence between Ω1 and Ω2 as [40]:
Ω1 (cid:2)(cid:3) Ω2 = {μ1 ∪ μ2 | μ1 ∈ Ω1, μ2 ∈ Ω2 and μ1, μ2 are compatible mappings},
Ω1 ∪ Ω2 = {μ | μ ∈ Ω1 or μ ∈ Ω2},
Ω1 (cid:4) Ω2 = {μ ∈ Ω1 | for all μ(cid:3) ∈ Ω2, μ and μ(cid:3)
Based on the previous operators, we deﬁne the left outer-join as:

are not compatible}.

Ω1 Ω2 = (Ω1 (cid:2)(cid:3) Ω2) ∪ (Ω1 (cid:4) Ω2).

Intuitively, Ω1 (cid:2)(cid:3) Ω2 is the set of mappings that result from extending mappings
in Ω1 with their compatible mappings in Ω2, and Ω1 (cid:4) Ω2 is the set of mappings
in Ω1 that cannot be extended with any mapping in Ω2. The operation Ω1∪Ω2 is
the usual set theoretical union. A mapping μ is in Ω1 Ω2 if it is the extension
of a mapping of Ω1 with a compatible mapping of Ω2, or if it belongs to Ω1
and cannot be extended with any mapping of Ω2. These operations resemble
relational algebra operations over sets of mappings (partial functions) [52].
We are ready to deﬁne the semantics of graph pattern expressions as a function
(cid:2)· (cid:3)G which takes a pattern expression and returns a set of mappings. We follow
the approach in [23] deﬁning the semantics as the set of mappings that matches
the graph G. For the sake of readability, the semantics of ﬁlter expressions is
presented in a separate deﬁnition.

Deﬁnition 2. The evaluation of a graph pattern P over an RDF graph G, denoted 
by (cid:2)P (cid:3)G, is deﬁned recursively as follows:
1. if P is a triple pattern t, then (cid:2)P (cid:3)G = {μ | dom(μ) = var(t) and μ(t) ∈ G}.
2. if P is (P1 AND P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G (cid:2)(cid:3) (cid:2)P2(cid:3)G.
3. if P is (P1 OPT P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G
(cid:2)P2(cid:3)G.
4. if P is (P1 UNION P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G ∪ (cid:2)P2(cid:3)G.
The idea behind the OPT operator is to allow for optional matching of patterns.
Consider pattern expression (P1 OPT P2) and let μ1 be a mapping in (cid:2)P1(cid:3)G.
If there exists a mapping μ2 ∈ (cid:2)P2(cid:3)G such that μ1 and μ2 are compatible, then
μ1 ∪ μ2 belongs to (cid:2)(P1 OPT P2)(cid:3)G. But if no such a mapping μ2 exists, then
μ1 belongs to (cid:2)(P1 OPT P2)(cid:3)G. Thus, operator OPT allows information to be
added to a mapping μ if the information is available, instead of just rejecting μ
whenever some part of the pattern does not match.

170

M. Arenas, C. Gutierrez, and J. P´erez

The semantics of ﬁlter expressions goes as follows. Given a mapping μ and a

built-in condition R, we say that μ satisﬁes R, denoted by μ |= R, if:
1. R is bound(?X) and ?X ∈ dom(μ);
2. R is ?X = c, ?X ∈ dom(μ) and μ(?X) = c;
3. R is ?X =?Y , ?X ∈ dom(μ), ?Y ∈ dom(μ) and μ(?X) = μ(?Y );
4. R is (¬R1), R1 is a built-in condition, and it is not the case that μ |= R1;
5. R is (R1 ∨ R2), R1 and R2 are built-in conditions, and μ |= R1 or μ |= R2;
6. R is (R1 ∧ R2), R1 and R2 are built-in conditions, μ |= R1 and μ |= R2.
Deﬁnition 3. Given an RDF graph G and a ﬁlter expression (P FILTER R),

(cid:2)(P FILTER R)(cid:3)G = {μ ∈ (cid:2)P (cid:3)G | μ |= R}.

In the normative semantics of SPARQL [45], there is an additional feature of
graph patterns that allows to query several diﬀerent RDF graphs with a single
pattern. This is accomplished with the GRAPH operator that allows to dynamically 
change the graph being used in the evaluation of a pattern. For the sake
of readability, we do not include here the GRAPH operator. We refer the reader
to [42] for a formalization of SPARQL graph patterns including GRAPH, and
to [9] for some tutorial material.

In the rest of the paper, we usually represent sets of mappings as tables where
each row represents a mapping in the set. We label every row with the name
of a mapping, and every column with the name of a variable. If a mapping is
not deﬁned for some variable, then we simply leave empty the corresponding
position. For instance, the table

?X ?Y ?Z ?V ?W

b
c

μ1 : a
μ2 :
μ3 :

d

e

represents the set Ω = {μ1, μ2, μ3} where
- dom(μ1) = {?X, ?Y }, μ1(?X) = a, and μ1(?Y ) = b,
- dom(μ2) = {?Y, ?W}, μ2(?Y ) = c, and μ2(?W ) = d,
- dom(μ3) = {?Z}, and μ3(?Z) = e.
Sometimes we use notation {{?X → a, ?Y → b},{?Y → c, ?W → d},{?Z → e}}
for a set of mappings as the one above.

Example 3. Consider an RDF graph G storing information about professors in
a university:
G = { (B1, name,
(B2, name,
(B3, name,
(B4, name,
(B4, webPage, www.starr.edu),

(B1, phone,
(B2, email,
(B3, webPage, www.george.edu),
(B4, email,
(B4, phone,

paul),
john),
george),
ringo),

ringo@acd.edu),
888-4537)

}

777-3426),
john@acd.edu),

Foundations of RDF Databases

171

The following are graph pattern expressions and their evaluations over G:

- P1 = ((?A, email, ?E) AND (?A, webPage, ?W )). Then

(cid:2)P1(cid:3)G =

?A

?E

?W

μ1 : B4 ringo@acd.edu www.starr.edu

- P2 = ((?A, email, ?E) OPT (?A, webPage, ?W )). Then

(cid:2)P2(cid:3)G =

?A

?E

?W

μ1 : B2 john@acd.edu
μ2 : B4 ringo@acd.edu www.starr.edu

- P3 = (((?A, name, ?N) OPT (?A, email, ?E)) OPT (?A, webPage, ?W )).

Then

(cid:2)P3(cid:3)G =

?E

?A ?N
μ1 : B1 paul
μ2 : B2 john john@acd.edu
μ3 : B3 george
www.george.edu
μ4 : B4 ringo ringo@acd.edu www.starr.edu

?W

- P4 = ((?A, name, ?N) OPT ((?A, email, ?E) OPT (?A, webPage, ?W ))).

Then

(cid:2)P4(cid:3)G =

?E

?A ?N
μ1 : B1 paul
μ2 : B2 john john@acd.edu
μ3 : B3 george
μ4 : B4 ringo ringo@acd.edu www.starr.edu

?W

Notice the diﬀerence between (cid:2)P2(cid:3)G and (cid:2)P3(cid:3)G. These two examples show
that (cid:2)((A OPT B) OPT C)(cid:3)G (cid:15)= (cid:2)(A OPT (B OPT C))(cid:3)G in general.
- P5 = ((?A, name, ?N) AND ((?A, email, ?E) UNION (?A, webPage, ?W ))).

Then

(cid:2)P5(cid:3)G =

?A ?N

?E

μ1 : B2 john john@acd.edu
μ2 : B3 george
μ3 : B4 ringo ringo@acd.edu
μ4 : B4 ringo

?W

www.george.edu

www.starr.edu

- P6 = (((?A, name, ?N) OPT (?A, phone, ?P )) FILTER ?N = paul). Then

(cid:2)P6(cid:3)G =

?A ?N

?P

μ1 : B1 paul 777-3426

(cid:7)(cid:8)

172

M. Arenas, C. Gutierrez, and J. P´erez

Simple algebraic properties. We say that two graph patterns P1 and P2
are equivalent, denoted by P1 ≡ P2, if (cid:2)P1(cid:3)G = (cid:2)P2(cid:3)G for every RDF graph G.
The following simple lemma states some simple algebraic properties of AND and
UNION operators. These properties are direct consequence of the semantics of
AND and UNION, both based on set-theoretical union.

Lemma 1 ([40]). The operators AND and UNION are associative and commutative 
and the operator AND distribute over UNION. That is, if P1, P2 and
P3 are graph patterns, then it holds that:
– (P1 AND P2) ≡ (P2 AND P1)
– (P1 UNION P2) ≡ (P2 UNION P1)
– (P1 AND (P2 AND P3)) ≡ ((P1 AND P2) AND P3)
– (P1 UNION (P2 UNION P3)) ≡ ((P1 UNION P2) UNION P3)
– (P1 AND (P2 UNION P3)) ≡ ((P1 AND P2) UNION (P1 AND P3))

The above lemma permits us to avoid parenthesis when writing sequences of either 
AND operators or UNION operators. This is consistent with the deﬁnitions
of Group Graph Pattern and Union Graph Pattern in [45]. We use Lemma 1 to
simplify the notation in the following sections.

3.2 Query Result Forms

The normative speciﬁcation of SPARQL [45] considers four query forms. These
query forms use the mappings obtained after the evaluation of a graph pattern
to construct result sets or RDF graphs. The query forms are: (1) SELECT, that
performs a projection over a set of variables in the evaluation of a graph pattern,
 (2) CONSTRUCT, that returns an RDF graph constructed by substituting
variables in a template, (3) ASK, that returns a truth value indicating whether
the evaluation of a graph pattern produces at least one mapping, and (4) DESCRIBE,
 that returns an RDF graph that describes the resources found. In this
paper, we only consider the SELECT query form. We refer the reader to [42] for
a formalization of the remaining query forms.
Given a mapping μ : V → U and a set of variables W ⊆ V , the restriction of
μ to W , denoted by μ|W , is a mapping such that dom(μ|W ) = dom(μ) ∩ W and
μ|W (?X) = μ(?X) for every ?X ∈ dom(μ) ∩ W .

Deﬁnition 4. A SPARQL SELECT query is a tuple (W, P ), where P is a graph
pattern and W is a set of variables such that W ⊆ var(P ). The answer of (W, P )
over an RDF graph G, denoted by (cid:2)(W, P )(cid:3)G, is the set of mappings:

(cid:2)(W, P )(cid:3)G = {μ|W

| μ ∈ (cid:2)P (cid:3)G}.

Example 4. Consider the RDF graph G and the graph pattern P3 in Example 3.
Then we have that:

Foundations of RDF Databases

173

(cid:2)({?N, ?E}, P3)(cid:3)G =

?E

?N
μ1 : paul
μ2 :
μ3 : george
μ4 : ringo ringo@acd.edu

john john@acd.edu

(cid:7)(cid:8)
In the following sections, we study some fundamental issues regarding the query
language SPARQL. The ﬁrst of that issues is the complexity of the evaluation
problem for SPARQL. In Section 4, we focus on studying the complexity of the
evaluation problem for SPARQL graph patterns. Then in Section 5, we consider
SPARQL SELECT queries to compare the expressive powers of SPARQL and
the Relational Algebra.

4 Complexity and Optimization of SPARQL

A fundamental issue in every query language is the complexity of query evaluation 
and, in particular, what is the inﬂuence of each component of the language
in this complexity.

In this section, we present a thorough study of the complexity of the evaluation
of SPARQL graph patterns based on [40]. In this study, we consider several fragments 
of SPARQL built incrementally, and present complexity results for each
such fragment. Among other results, we show that the complexity of the evaluation 
problem for general SPARQL graph patterns is PSPACE-complete [40],
and that this high complexity is obtained as a consequence of unlimited use of
nested optional parts.

Given the high complexity of the evaluation problem for general SPARQL
graph patterns, an important question is whether one can ﬁnd interesting classes
of patterns where the query evaluation problem can be solved more eﬃciently.
In [40,41], the authors identiﬁed a large class of patterns with the previous
characteristic that is deﬁned by a simple and natural syntactic restriction. This
class is obtained by forbidding a special form of interaction between variables
appearing in optional parts. Patterns satisfying this condition are called welldesigned 
[40,41]. Well-designed patterns form a natural fragment of SPARQL
that is very common in practice, and has several interesting features. On the
one hand, the complexity of the evaluation problem for well-designed patterns is
considerably lower, namely coNP-complete. On the other hand, the property of
being well designed has important consequences for the optimization of SPARQL
queries. We present some rewriting rules for well-designed patterns whose application 
may have a considerable impact in the cost of evaluating SPARQL queries,
and prove the existence of a normal form for well-designed patterns based on
the application of these rewriting rules.

4.1 Complexity of Evaluating Graph Pattern Expressions
In this section, we review some the results in the literature regarding the complexity 
of evaluating SPARQL graph pattern expressions. The ﬁrst study about

174

M. Arenas, C. Gutierrez, and J. P´erez

this problem was published in [40], and some reﬁnements of the complexity results 
of [40] were presented in [47]. This section focuses on the complexity results
proved in these two papers.

As is customary when studying the complexity of the evaluation problem for
a query language [51], we consider its associated decision problem. We denote
this problem by Evaluation and we deﬁne it as follows:

INPUT
QUESTION : Is μ ∈ (cid:2)P (cid:3)G?

: An RDF graph G, a graph pattern P and a mapping μ.

It is important to notice that the evaluation problem that we study considers
the mapping as part of the input. That is, we study the complexity by measuring
how diﬃcult it is to verify whether a given mapping is a solution for a pattern
evaluated over an RDF graph. This is the standard decision problem considered
when studying the complexity of a query language [51], as opposed to the computation 
problem of actually listing the set of solutions (ﬁnding all the mappings).
To focus on the associated decision problem allows us to obtain a ﬁne grained
analysis of the complexity of the evaluation problem, classifying the complexity
for diﬀerent fragments of SPARQL in terms of standard complexity classes. Also
notice that the pattern and the graph are both input for Evaluation. Thus,
we study the combined complexity of the query language [51].

We start this study by considering the fragment consisting of graph pattern
expressions constructed by using only AND and FILTER operators. This simple
fragment is interesting as it does not use the two most complicated operators in
SPARQL, namely UNION and OPT. Given an RDF graph G, a graph pattern
P in this fragment and a mapping μ, it is possible to eﬃciently check whether
μ ∈ (cid:2)P (cid:3)G by using the following simple algorithm [40]. First, for each triple t in
P , verify whether μ(t) ∈ G. If this is not the case, then return false. Otherwise,
by using a bottom-up approach, verify whether the expression generated by
instantiating the variables in P according to μ satisﬁes the FILTER conditions
in P . If this is the case, then return true, else return false.
Theorem 2. Evaluation can be solved in time O(|P| · |D|) for graph pattern
expressions constructed by using only AND and FILTER operators.

We continue this study by adding the UNION operator to the AND-FILTER
fragment. It is important to notice that the inclusion of UNION in SPARQL
is one of the most controversial issues in the deﬁnition of this language. The
following theorem proved in [40], shows that the inclusion of the UNION operator
makes the evaluation problem for SPARQL considerably harder.

Theorem 3 ([40]). Evaluation is NP-complete for graph pattern expressions
constructed by using only AND, FILTER and UNION operators.

In [47], the authors strengthen the above result by showing that the complexity
of evaluating graph pattern expressions constructed by using only AND and
UNION operators is already NP-hard. Thus, we have the following result.

Foundations of RDF Databases

175

Theorem 4 ([47]). Evaluation is NP-complete for graph pattern expressions
constructed by using only AND and UNION operators.

We now consider the OPT operator, which is the most involved operator in graph
pattern expressions and, deﬁnitively, the most diﬃcult to deﬁne. The following
theorem proved in [40] shows that when considering all the operators in SPARQL
graph patterns, the evaluation problem becomes considerably harder.

Theorem 5 ([40]). Evaluation is PSPACE-complete.

To prove the PSPACE-hardness of Evaluation, the authors show in [40] how
to reduce in polynomial time the quantiﬁed boolean formula problem (QBF) to
Evaluation. An instance of QBF is a quantiﬁed propositional formula ϕ of the
form:

∀x1∃y1∀x2∃y2 ···∀xm∃ym ψ,

where ψ is a quantiﬁer-free formula of the form C1 ∧ ··· ∧ Cn, with each Ci (i ∈
{1, . . . , n}) being a disjunction of literals, that is, a disjunction of propositional
variables xi and yj, and negations of propositional variables. Then the problem
is to verify whether ϕ is valid. It is known that QBF is PSPACE-complete [22].
In the encoding presented in [40], the authors use a ﬁxed RDF graph G and a
ﬁxed mapping μ. Then they encode formula ϕ with a pattern Pϕ that uses nested
OPT operators to encode the quantiﬁer alternation of ϕ, and a graph pattern
without OPT to encode the satisﬁability of formula ψ. By using a similar idea,
it is shown in [47] how to encode formulas ϕ and ψ by using only the OPT
operator, thus strengthening Theorem 5.

Theorem 6 ([47]). Evaluation is PSPACE-complete for graph pattern
expressions constructed by using only the OPT operator.
When verifying whether μ ∈ (cid:2)P (cid:3)G, it is natural to assume that the size of P
is considerably smaller than the size of G. This assumption is very common
when studying the complexity of a query language. In fact, it is named data
complexity in the database literature [51], and it is deﬁned as the complexity of
the evaluation problem for a ﬁxed query. More precisely, for the case of SPARQL,
given a graph pattern expression P , the evaluation problem for P , denoted by
Evaluation(P ), has as input an RDF graph G and a mapping μ, and the
problem is to verify whether μ ∈ (cid:2)P (cid:3)G.
Theorem 7 ([40]). Evaluation(P ) is in LOGSPACE for every graph pattern
expression P .

An important question is whether one can ﬁnd interesting classes of graph patterns,
 constructed by imposing simple and natural syntactic restrictions, such
that one can obtain lower complexity bounds for the evaluation problem on that
classes. In the following section, we introduce a ﬁrst such restriction.

176

M. Arenas, C. Gutierrez, and J. P´erez

4.2 A Simple Normal Form for Graph Patterns

We say that a pattern P is UNION-free if P is constructed by using only operators 
AND, OPT and FILTER. In [40], the authors proved the following normalform 
result.

Proposition 2 ([40]). Every graph pattern P is equivalent to a pattern of the
form:

(P1 UNION P2 UNION P3 UNION ··· UNION Pn),

(1)

where each Pi (1 ≤ i ≤ n) is UNION-free.
Notice that we omit the parenthesis in the expression (1) given the associativity
of UNION. We say that a graph pattern is in UNION normal form if the pattern
is in the form (1).4

The following result shows that for graph patterns in UNION normal form that
do not use the OPT operator, the evaluation problem can be solved eﬃciently.
It is a direct consequence of Theorem 2.
Corollary 1. Evaluation can be solved in time O(|P|·|G|) for graph patterns
in UNION normal form constructed by using only AND, FILTER, and UNION
operators.

We have managed to lower the complexity of the AND-FILTER-UNION fragment 
by imposing a simple normal form. However, Theorem 6 implies that when
the OPT operator is allowed in graph patterns, the complexity of the evaluation
problem is PSPACE-hard even if we restrict to patterns in UNION normal form.
In the following section, we introduce a simple and natural syntactic condition
that patterns usually satisfy in practice. Under this condition, the complexity
of the evaluation of graph patterns in UNION normal form is lower even if the
OPT operator is allowed.

4.3 Well-Designed Graph Patterns

The exact semantics of graph pattern expressions has been extensively discussed
on the mailing list of the W3C. One of the most delicate issues in the deﬁnition of
a semantics for graph pattern expressions is the semantics of the OPT operator.
As we have mentioned before, the idea behind the OPT operator is to allow for
optional matching of patterns, that is, to allow information to be added if it
is available, instead of just rejecting whenever some part of a pattern does not

4 In the

of

the

existence

of

[40],

conference

version of

a
form used the equivalence (P1 OPT (P2 UNION P3)) ≡
UNION normal
((P1 OPT P2) UNION (P1 OPT P3)) (see Proposition 1 in [40]). Unfortunately,
this rule does not hold in general [47]. In the errata of [40] (that can be downloaded
from http://www.ing.puc.cl/~ marenas/publications/errata-iswc06.pdf), the
authors provide a proof of Proposition 2 without using this rule.

the proof

Foundations of RDF Databases

177

match. However, this intuition fails in some simple, but unnatural, examples.
For instance, consider the graph pattern:

P = ((?X, name, john) OPT ((?Y, name, mick) OPT (?X, email, ?Z))). (2)

What is unnatural about graph pattern P is the fact that (?X, email, ?Z) is
giving optional information for (?X, name, john), but in P appears as giving
optional information for (?Y, name, mick). For example, (B2, name, john) and
(B2, email, john@ac.edu) are triples in the graph G of Example 3, but the evaluation 
of P results in the set {{?X → B2}} (since (cid:2)(?Y, name, mick)(cid:3)G = ∅)
without giving information about the email of john.
A careful examination of the examples that produce conﬂicts reveals a common 
pattern: A graph pattern P mentions an expression P (cid:3) = (P1 OPT P2) and
a variable ?X occurring both inside P2 and outside P (cid:3) but not occurring in P1.
In general, graph pattern expressions satisfying this condition are not natural.
In [40], the authors considered a special class of patterns that they called
well-designed patterns, obtained by forbidding the form of interaction between
variables appearing in optional parts discussed above. To present the formal
deﬁnition of well-designed patterns, we need to introduce some terminology. We
say that a graph pattern Q is safe if for every sub-pattern (P FILTER R) of
Q, it holds that var(R) ⊆ var(P ). This safety condition is a usual restriction in
many database query languages.

Deﬁnition 5 ([40]). A UNION-free graph pattern P is well designed if P is
safe and, for every sub-pattern P (cid:3) = (P1 OPT P2) of P and for every variable
?X occurring in P , the following condition holds:

if ?X occurs both inside P2 and outside P (cid:3), then it also occurs in P1.

For instance, pattern (2) above is not well designed. One can extend Deﬁnition 5
to patterns in UNION normal form; a pattern (P1 UNION P2 UNION ···
UNION Pn) is well designed if every Pi (1 ≤ i ≤ n) is a UNION-free welldesigned 
graph pattern.

It should be noticed that to prove the PSPACE lower bound of Theorem 5,
it is used in [40] a graph pattern that is not well designed. Thus, an immediate
question is whether the complexity of evaluating well-designed graph pattern expressions 
is lower than in the general case. In [41] (the extended version of [40]),
the authors showed that this is indeed the case, in fact, they proved a coNP upper
bound for the case of well-designed graph patterns. In [40,41], the authors also
considered the problem of optimizing well-designed graph patterns. Since the beginning 
of the relational model, several techniques for optimizing the evaluation
of relational algebra expressions have been developed. In fact, one of the reasons
why relational algebra is so extensively used to implement SQL is the existence
of simple reordering and optimization rules for this language. Unfortunately, the
development of this type of rules for SPARQL is limited by the presence of the
OPT operator. However, it was shown in [40,41] that well-designed patterns are
suitable for reordering and optimization, demonstrating the signiﬁcance of this

178

M. Arenas, C. Gutierrez, and J. P´erez

class of queries from the practical point of view. In the rest of this section, we
review some of the results in [40,41] regarding well-designed patterns.

We note ﬁrst that the property of being well-designed can be checked efﬁciently 
by a straightforward procedure. Let P be a pattern. Then for every
sub-pattern P (cid:3) of P of the form (P1 OPT P2), we construct three sets: sets VP1
and VP2, containing the variables occurring in P1 and P2, respectively, and set
OP (cid:2) containing the variables that occur outside P (cid:3). To construct VP1, we collect
variables by making a bottom-up traversal of the sub-patterns of P1. We repeat
this procedure in P2 to construct VP2. To construct OP (cid:2), we make a bottom-up
traversal of the entire pattern P , but not taking into consideration P (cid:3). Having
these three sets, we check whether VP2 ∩ OP (cid:2) ⊆ VP1, that is, we check whether
every variable that occurs inside P2 and outside P (cid:3) also occurs inside P1, which
is exactly the well-designed condition. We must repeat this test for every OPT
sub-pattern of P . Notice that the test for every OPT sub-pattern takes linear
time in the size of P , and then, the entire process takes time proportional to the
size of P times the number of OPT sub-patterns of P . We can then state the
following proposition:

Proposition 3 ([41]). Testing if a pattern P is well designed can be done in
time O(|P|2).

4.4 Complexity of Evaluating Well-Designed Patterns

Intuitively, if we delete some optional parts of a pattern P to obtain a new
pattern P (cid:3), the mappings in the evaluation of P (cid:3) over a graph G could not be
more informative than the mappings in the evaluation of P over G. That is,
the optional matchings of a pattern must only serve to extend solutions with
new information, but not to reject solutions if some information is not provided.
In [41], the authors showed that the intuition is indeed correct for the case of
well-designed graph patterns. In this section, we present the formalization of this
intuition given in [41], and use it to develop a characterization of the evaluation
of well-designed graph patterns.
We say that a mapping μ is subsumed by a mapping μ(cid:3), denoted by μ (cid:19) μ(cid:3), if
μ and μ(cid:3) are compatible and dom(μ) ⊆ dom(μ(cid:3)). That is, μ is subsumed by μ(cid:3)
if μ agrees with μ(cid:3) in every variable for which μ is deﬁned. For sets of mappings
Ω and Ω(cid:3), we write Ω (cid:19) Ω(cid:3) if for every mapping μ ∈ Ω, there exists a mapping
μ(cid:3) ∈ Ω(cid:3) such that μ (cid:19) μ(cid:3).
We say that a pattern P (cid:3) is a reduction of a pattern P , if P (cid:3) can be obtained
from P by replacing a sub-formula (P1 OPT P2) of P by P1, that is, if P (cid:3) is
obtained by deleting some optional part of P . For example,

P (cid:3)

= (t1 AND (t2 OPT (t3 AND t4)))

is a reduction of

P = ((t1 OPT t2) AND (t2 OPT (t3 AND t4)))

Foundations of RDF Databases

179

since P (cid:3) can be obtained from P by replacing (t1 OPT t2) by t1. The reﬂexive and
transitive closure of the reduction relation is denoted by (cid:2). Thus, for example,
if P (cid:3)(cid:3) = (t1 AND t2), then P (cid:3)(cid:3) (cid:2) P since P (cid:3)(cid:3) is a reduction of P (cid:3) and P (cid:3) is a
reduction of P . We note that if P (cid:3) (cid:2) P and P is well designed, then P (cid:3) is well
designed.

We can now state the result that formalizes the intuition mentioned at the

beginning of this section.
Lemma 2 ([41]). Let P be a UNION-free well-designed graph pattern, and P (cid:3)
a pattern such that P (cid:3) (cid:2) P . Then (cid:2)P (cid:3)(cid:3)G (cid:19) (cid:2)P (cid:3)G for every graph G.
It should be noticed that the property stated in Lemma 2 does not hold for
patterns that are not well designed. For example, consider a graph G = {(1, a, 1),
(2, a, 2), (3, a, 3)} and non well-designed pattern:

P = ((?X, a, 1) OPT ((?Y, a, 2) OPT (?X, a, 3))).

The evaluation of P results in the set {{?X → 1}}. By deleting the optional
part (?X, a, 3) of P , we obtain the reduction P (cid:3) = ((?X, a, 1) AND (?Y, a, 2)) of
P . The evaluation of P (cid:3) results in the set {{?X → 1, ?Y → 2}}. Thus, we have
that (cid:2)P (cid:3)(cid:3)G (cid:15)(cid:19) (cid:2)P (cid:3)G.

We have mentioned that, when evaluating an optional part of a pattern, one is
trying to extend mappings with optional information. Another intuition behind
the OPT operator is that, when a pattern has several optional parts, one wants
to extend the solutions as much as possible, that is, one does not want to lose
information when the information is present. We formalize this intuition with
the notion of partial solution for a pattern. Informally, a partial solution for a
pattern P is a mapping that is an exact match for some P (cid:3) such that P (cid:3) (cid:2) P .
We show then, in Proposition 4, that the evaluation of a well-designed graph
pattern P is exactly the set of maximal partial solutions for P w.r.t. (cid:19), that
is, the solutions that retrieve as much information as possible. This proposition
gives an alternative characterization of the evaluation of well-designed graph
patterns.

Given a pattern P , deﬁne and(P ) to be the pattern obtained from P by
replacing every OPT operator in P by an AND operator. For example, if P is
the pattern:

P = ((t1 OPT t2) AND (t2 OPT (t3 AND t4))),

then we have that:

and(P ) = ((t1 AND t2) AND (t2 AND (t3 AND t4))).

Notice that, by the semantics of the OPT operator, for every (not necessarily
well designed) pattern P and every graph G, we have that (cid:2)and(P )(cid:3)G ⊆ (cid:2)P (cid:3)G.
A mapping μ is a partial solution for a pattern P over a graph G if μ ∈
(cid:2)and(P (cid:3))(cid:3)G, for some P (cid:3) (cid:2) P . Partial solutions and the notion of subsumption
of mappings give the following characterization of the evaluation of well-designed
graph patterns.

180

M. Arenas, C. Gutierrez, and J. P´erez

Proposition 4 ([41]). Given a UNION-free well-designed graph pattern P , a
graph G, and a mapping μ, we have that μ ∈ (cid:2)P (cid:3)G if and only if μ is a maximal
(w.r.t. (cid:19)) partial solution for P over G.

In [41], the authors use this characterization to prove that the complexity of the
evaluation problem for well-designed patterns is lower than for general patterns.

Theorem 8 ([41]). Evaluation is coNP-complete for the case of UNION-free
well-designed graph pattern expressions.

The characterization of the evaluation of well-designed graph patterns in Proposition 
4 can be extended to patterns in UNION normal form. For a well-designed
pattern P = (P1 UNION P2 UNION ··· UNION Pn) in UNION normal form, a
mapping μ, and a graph G, it holds that μ ∈ (cid:2)P (cid:3)G if and only if μ is a maximal
partial solution (w.r.t. (cid:19)) for some Pi (1 ≤ i ≤ n). Then the evaluation problem
for well-designed patterns in UNION normal form is still in coNP.

Corollary 2 ([41]). Evaluation is coNP-complete for well-designed graph
pattern expressions in UNION normal form.

4.5 Optimization of Well-Designed Patterns

Due to the evident similarity between certain operators of SPARQL and relational 
algebra, a natural question is whether the classical results of normal forms
and optimization for relational algebra are applicable in the SPARQL context.
The answer is not straightforward, at least for the case of optional patterns and
its relational counterpart, the left outer join. The classical results about outerjoin 
query reordering and optimization by Galindo-Legaria and Rosenthal [21]
are not directly applicable in the SPARQL context, as they assume constraints
on the relational queries that are rarely satisﬁed in SPARQL. The ﬁrst, and most
problematic issue, is the assumption on predicates used for joining/outer-joining
relations to be null-rejecting [21]. A predicate p is null-rejecting if it evaluates to
false (or undeﬁned) whenever a null value is used in p. In SPARQL, those predicates 
are implicit in the variables that graph patterns share and, by the deﬁnition
of compatible mappings, they are never null-rejecting. In fact, people who have
developed algorithms for translating SPARQL queries into relational algebra and
SQL queries (e.g. [20]) have used NULL to represent unbound variables, IS NULL
in predicates for joining/outer-joining, and COALESCE for merging the values of
diﬀerent columns into a single column. These features are explicitly prohibited
in [21] since they may imply a violation of the null-rejecting requirement.

Since the application of classical results in relational query optimization is
not straightforward, it would be desirable to develop speciﬁc techniques in the
SPARQL context. In [40], the authors proved that the property of being well designed 
has important consequences for the study of normalization and
optimization for SPARQL.

Proposition 5 ([40]). Let P1, P2 and P3 be graph pattern expressions and R
a built-in condition. Consider the rewriting rules:

Foundations of RDF Databases

181

((P1 OPT P2) FILTER R) −→ ((P1 FILTER R) OPT P2),

(P1 AND (P2 OPT P3)) −→ ((P1 AND P2) OPT P3),
((P1 OPT P2) AND P3) −→ ((P1 AND P3) OPT P2).

(3)
(4)
(5)
Let P be a UNION-free well-designed pattern, and assume that P (cid:3) is a pattern
obtained from P by applying either Rule (3), or Rule (4), or Rule (5). Then P (cid:3)
is a UNION-free well-designed pattern equivalent to P .

It is worth mentioning that the previous rules are not applicable to non welldesigned 
graph patterns. For example, consider the graph G = {(1, a, 1), (2, a, 2),
(3, a, 3)} and non well-designed pattern:

P = ((?X, a, 1) AND ((?Y, a, 2) OPT (?X, a, 3))).

The evaluation of P results in the empty set of mappings. If we apply rule (4)
to P , we obtain pattern P (cid:3) = (((?X, a, 1) AND (?Y, a, 2)) OPT (?X, a, 3)). The
evaluation of P (cid:3) results in the set {{?X → 1, ?Y → 2}} and, thus, we have that
(cid:2)P (cid:3)G (cid:15)= (cid:2)P (cid:3)(cid:3)G.

We say that a UNION-free graph pattern P is in OPT normal form if either:
(1) P is constructed by using only the AND and FILTER operators, or (2)
P = (O1 OPT O2), with O1 and O2 patterns in OPT normal form. For example,
consider a pattern P :
(cid:2)(cid:3)

((t1 AND t2) FILTER R1)

(cid:4)
OPT (t3 OPT ((t4 FILTER R2) AND t5))

(cid:3)
t6 FILTER R3

(cid:4)(cid:5)

,

OPT

where every ti is a triple pattern, and every Rj is a built-in condition. Then P is
in OPT normal form. The following theorem shows that for every well-designed
graph pattern, an equivalent pattern in OPT normal form can be eﬃciently
obtained.

Theorem 9 ([41]). For every UNION-free well-designed pattern P , an equivalent 
pattern in OPT normal form can be obtained after O(|P|2) applications of
Rules (3)-(5).

The application of Rules (3)-(5) may have a considerable impact in the cost
of evaluating graph patterns. One can measure this impact by analyzing the
intermediate sizes of the sets of mappings produced when evaluating a pattern.
By the semantics of the OPT operator, when evaluating an expression of the
form (P1 OPT P2) over a graph G, the number of mappings obtained is at
least the number of mappings obtained when evaluating P1 over D. That is,
the application of the OPT operator never implies a reduction in the size of the

182

M. Arenas, C. Gutierrez, and J. P´erez

intermediate results in the evaluation of a graph pattern expression. In contrast,
it is clear that operators AND and FILTER may imply a reduction in the size of
intermediate results. Thus, for optimization purposes, it would be convenient to
perform all the AND and FILTER operations ﬁrst, delaying the OPT operations
to the last step of the evaluation. A pattern in OPT normal form has its operators
ordered in a way that, the bottom-up evaluation of the pattern follows exactly
this strategy: AND and FILTER operations are executed prior to the execution
of the OPT operations.

5 On the Expressiveness of SPARQL

Determining the expressive power of a query language is crucial for understanding 
its capabilities, that is, what types of queries a user can pose in this language,
and how complex the evaluation of such queries is. In this section, we study the
expressive power of SPARQL. The main goal is to show that SPARQL is equivalent,
 from an expressive-power point of view, to Relational Algebra.
In order to determine the expressive power of a query language L, one usually
chooses a well-studied query language L(cid:3), and then compares the expressiveness
of L and L(cid:3). In particular, one says that two query languages have the same
expressive power if they express exactly the same set of queries. In this section,
we present an overview of the results in [7], that show that the query language
SPARQL SELECT has the same expressiveness as non-recursive Datalog with
negation (nr-Datalog¬) and Relational Algebra.

We start with an overview of Datalog (for further details see [1,33]). A term is
either a variable or a constant. An atom is either a predicate formula p(x1, ..., xn),
where p is a predicate name and each xi is a term, or an equality formula t1 = t2,
where t1 and t2 are terms. A literal is either an atom (a positive literal), or the
negation of an atom (a negative literal). A fact is a predicate formula containing
only constants. A substitution θ for variables x1, . . . , xk is a set of assignments
{x1 → t1, . . . , xk → tk} where each ti is a term. Given a literal L, we denote by
θ(L) the literal that results by replacing in L each variable xi by the term ti.
A Datalog rule is an expression H ← L1, . . . , Ln, where H is a predicate
formula containing only variables and each Li is a literal. H is called the head
of the rule, and the sequence L1, . . . , Ln is called its body. A Datalog program
Π is a ﬁnite set of Datalog rules. A predicate is extensional in Π if it does not
occur in the head of any rule of Π, otherwise it is called intensional. A Datalog
program is non-recursive if there is some ordering r1, . . . , rm of its rules so that,
the predicate name in the head of ri does not occur in the body of a rule rj
for every j ≤ i. We further impose the following safety condition to rules: every
variable occurring in a rule r must occur in at least one (positive) predicate
formula in the body of r. In what follows, we only consider non-recursive and
safe programs. Moreover, we may assume that all heads of rules in a program
have distinct variables, since repeated variables can always be replaced by adding
equalities. For example, the rule p(X, X) ← t(X) can be replaced by p(X, Y ) ←
t(X), t(Y ), X = Y .

Foundations of RDF Databases

183

∗

Let D be a set of facts over the extensional predicates of a Datalog program
Π. We deﬁne the meaning of Π given D, denoted by facts
(Π, D), as the set of
facts that results from the following process. Fix an order r1, . . . , rm of the rules
(Π, D)
that satisﬁes the aforementioned non-recursive property. The set facts
is obtained evaluating the rules by following that order. Formally, we denote
by factsi(Π, D) the total set of facts obtained after evaluating rule ri. Initially,
facts0(Π, D) = D. In order to compute factsi+1(Π, D), assume that rule ri+1 is
H ← L1, . . . Ln. Then factsi+1(Π, D) is obtained by adding to factsi(Π, D) all
the facts of the form θ(H), where θ is a substitution such that θ(L1), . . . , θ(Ln)
hold in factsi(Π, D). The process stops when all rules have been considered.

∗

A Datalog query Q is a pair (Π, L) where Π is a Datalog program and L
is a predicate formula (the goal of the program). The answer to a Datalog
query Q = (Π, L) over a database D, denoted by answer(Q, D), is the set of all
substitutions θ for the variables occurring in L, such that θ(L) ∈ facts
(Π, D).

∗

5.1 From SPARQL to nr-Datalog¬
¬
In this section, we show that nr-Datalog
is at least as expressive as SPARQL
SELECT, that is, we show that every SPARQL SELECT query can be expressed
¬
program. More speciﬁcally, we ﬁrst deﬁne a one-to-one transas 
an nr-Datalog
formation T1 that assigns to every RDF graph G a set of Datalog facts T1(G).
We then deﬁne a one-to-one transformation T2 that assigns to every SPARQL
SELECT query Q, a Datalog query T2(Q), and show that for every SPARQL
SELECT query Q and RDF graph G, the evaluation of Q over G corresponds
to the evaluation of the Datalog query T2(Q) over the set of facts T1(G).
The transformation T1 from RDF graphs into Datalog facts essentially transform 
triples into facts, but taking special care of encoding unbounded values
as nulls. Formally, given an RDF graph G, the transformation T1(G) works as
follows: every element a occurring in G is encoded by a fact term(a); each triple
(s, p, o) is encoded by a fact triple(s, p, o); additionally, we include a special fact
N(null), where null is a constant value used to represent unbounded variables.
We now have to show how graph patterns are transformed into Datalog rules.
We show here some examples of this transformation to highlight the intuition
of the process. We refer the reader to [44,7] for the details on the general transformation.
 Consider ﬁrst the graph pattern P1 = ((?X, a, 1) OPT (?X, b, ?Z)).
Then the transformation T2 generates the following Datalog program with goal
predicate p to express P1:

p(?X, ?Z) ← triple(?X, a, 1), triple(?X, b, ?Z)
p(?X, ?Z) ← triple(?X, a, 1), N(?Z),¬q(?X)

q(?X) ← triple(?X, b, ?V )

(6)
(7)
(8)

The ﬁrst rule is encoding the join operation between sets of mappings, while
the second and third rules are encoding the diﬀerence. The left outer-join, which
deﬁnes the semantics of the OPT operator, is then obtained by considering rules
(6), (7) and (8), that is, considering the union between the results of the join

184

M. Arenas, C. Gutierrez, and J. P´erez

and the diﬀerence. Notice that predicate N is used in the second rule to encode
unbounded variables.
Second, consider SPARQL SELECT query ({?Z}, P1), where P1 is the pattern
deﬁned above. To express the SELECT operator, one only needs to perform a
projection in Datalog, that is, one can express query ({?Z}, P1) by using rules
(6), (7), (8) and the following projection rule:

r(?Z) ← p(?X, ?Z).
Notice that in this case r is the new goal predicate.

(cid:3)
Finally, consider SPARQL pattern:

(cid:3)

(cid:4)(cid:4)

P2 =

(?X, a, 1) AND

(?X, b, 1) UNION (?Y, c, 1)

.

¬
The main diﬃculty in translating P2 into an nr-Datalog
program is the encoding
of the notion of compatible mapping. To see why this is the case, ﬁrst notice
that one can easily express pattern P (cid:3)
2 = ((?X, b, 1) UNION (?Y, c, 1)) as an
¬
nr-Datalog

program:
p(cid:3)
p(cid:3)

(?X, ?Y ) ← triple(?X, b, 1), N(?Y ),
(?X, ?Y ) ← triple(?Y, c, 1), N(?X).

But if we now want to translate pattern P2 = ((?X, a, 1) AND P (cid:3)
directly use the previous two rules together with a rule like the following:

2), one cannot

p(?X, ?Y ) ← triple(?X, a, 1), p(cid:3)

(?X, ?Y ),

as this rule does not take into consideration the fact that the occurrence of ?X
in p(cid:3) could be instantiated with value null. In fact, if this is the case, then the
rule does not generate any facts as either there is no value d ∈ U such that
triple(d, a, 1) holds, or there is such a value d but then d is diﬀerent from null.
Notice that this failure is due to the fact that the previous rule does not correctly
encode the notion of compatible mapping. To solve this problem, one needs to
replace the previous rule by:

p(?X, ?Y ) ← triple(?X, a, 1), p(cid:3)

(?U, ?Y ), compatible(?X, ?U),

where compatible(·,·) is deﬁned as:

compatible(?X, ?Y ) ← term(?X), term(?Y ), ?X =?Y
compatible(?X, ?Y ) ← term(?X), N(?Y )
compatible(?X, ?Y ) ← N(?X), term(?Y )
compatible(?X, ?Y ) ← N(?X), N(?Y )

To conclude this section, it only remains to show how SPARQL mappings are
represented as Datalog substitutions. Notice that a mapping μ is a partial function.
 To represent the fact that a mapping is not deﬁned for some variables, we

Foundations of RDF Databases

185

use the special value null. Given a mapping μ and a set of variables W such that
dom(μ) ⊆ W , we deﬁne θ(μ,W ) as a substitution for variables in W such that (1)
θ(μ,W )(?X) = μ(?X) for every variable ?X ∈ dom(μ), and (2) θ(μ,W )(?X) = null
for every variable ?X such that ?X ∈ W and ?X (cid:15)∈ dom(μ).

¬
With the above transformations, we can show that nr-Datalog

is at least as
expressive as the language SPARQL SELECT. More precisely, let G be an RDF
graph and Q = (W, P ) a SPARQL SELECT query, with W a set of variables
and P a SPARQL graph pattern. Then a mapping μ is in (cid:2)Q(cid:3)G if and only if
the substitution θ(μ,W ) is in answer(T1(Q),T2(G)). Thus, we have that:
Theorem 10 ([44,7]). nr-Datalog
SPARQL SELECT.

is at least as expressive as the language

¬

5.2 From Datalog to SPARQL

¬
In this section, we show that SPARQL is at least as expressive as nr-Datalog
,
that is, we provide transformations from Datalog facts into RDF graphs, Datalog
¬
programs into SPARQL
substitutions into SPARQL mappings, and nr-Datalog
graph patterns. But before presenting these transformations, we give a technical
result that is used to encode negated literals of Datalog rules. Let MINUS be
a binary operator deﬁned as follows. Given SPARQL graph patterns P1, P2 and
an RDF graph G:

(cid:2)(P1 MINUS P2)(cid:3)G = (cid:2)P1(cid:3)G (cid:4) (cid:2)P2(cid:3)G,

where (cid:4) denotes the diﬀerence between sets of mappings deﬁned in Section 3.
Then the following proposition shows that the MINUS operator can be expressed
in SPARQL:
Proposition 6. Let P1 and P2 be graph patterns. Then pattern (P1 MINUS P2)
is equivalent to:

(cid:4)
P1 OPT (P2 AND (?X1, ?X2, ?X3))

(cid:4)
FILTER ¬ bound(?X1)

,

(9)

(cid:3)(cid:3)

where ?X1, ?X2, ?X3 are fresh variables mentioned neither in P1 nor in P2.
Thus, from now on we use SPARQL patterns including the operator MINUS, as
they can be translated into usual SPARQL patterns.

¬
We now describe the transformations used to show that nr-Datalog

is contained 
in SPARQL. Given a fact f = p(c1, ..., cn), let desc(f) be the set of
triples {(b, predicate, p), (b, 1, c1), . . . , (b, n, cn)}, where b is a fresh value in
U. Moreover, given a set of facts D, deﬁne a one-to-one transformation T (cid:3)
1 as
T (cid:3)
1 (D) = {desc(f) | f ∈ D}.
Transformation T (cid:3)
1 allows one to represent a set of facts as an RDF graph.
¬
,
Thus, to show that SPARQL SELECT is at least as expressive as nr-Datalog
it remains to provide a one-to-one mapping T (cid:3)
¬
2 that transforms nr-Datalog
programs into SPARQL SELECT queries. As we did for the other direction, we

186

M. Arenas, C. Gutierrez, and J. P´erez

show the intuition of the transformation with an example, and refer the reader
¬
to [7] for a detailed description of this transformation. Let Π be an nr-Datalog
program, and L a predicate formula p(x1, . . . , xn). For the sake of readability,
we assume that all the variables in Π are in V (that is, they can be used as
variables in SPARQL graph patterns). We deﬁne gp(Π, L) as a function which
returns a graph pattern that encodes the program (Π, L). The function gp(Π, L)
works as follows:

(a) If predicate p is extensional in Π, then gp(Π, L) returns the graph pattern
((?Y, predicate, p) AND (?Y, 1, x1) AND ··· AND (?Y, 1, xn)), where ?Y is
a fresh variable.
(b) If predicate p is intensional in Π, then for each rule L ← L1,··· , Ls,¬K1,··· ,
¬Kt, Leq
,··· , Leq
u in Π having p in its head, where each Li is a positive litis 
a literal of the form t1 = t2 or ¬(t1 = t2), the following
eral and each Leq
j
SPARQL pattern is generated:
(cid:2)(cid:3)(cid:3)

(cid:4)
gp(Π, L1) AND ··· AND gp(Π, Ls)

(cid:3)(cid:3)

···

1

(cid:4)
MINUS gp(Π, K1)

···

(cid:4)

(cid:4)
MINUS gp(Π, Kt)

(cid:3)

FILTER

Leq
1

∧ ··· ∧ Leq

u

(cid:4)(cid:5)

.

Assume that there are k rules in Π having p in their heads, and that P1,
. . ., Pk are the SPARQL patterns generated from these rules as above. Then
gp(Π, L) is deﬁned as (P1 UNION ··· UNION Pk).

Function gp(·,·) is used to deﬁne transformation T (cid:3)
variables mentioned in L is W , then T (cid:3)
(W, gp(Π, L)).
Example 5. Consider the following Datalog program Π:

2 . More precisely, if the set of
2 ((Π, L)) is the SPARQL SELECT query

p(?X, ?Y ) ← r(?X, ?Y, ?Z),¬s(?X, ?X)
p(?X, ?Y ) ← t(?X, ?Y )

(cid:2)(cid:3)

In order to translate this program into a SPARQL SELECT query, the ﬁrst rule
is transformed into the pattern:
(cid:4)
(?U, predicate, r) AND (?U, 1, ?X) AND (?U, 2, ?Y ) AND (?U, 3, ?Z)
(cid:4)(cid:5)

(cid:3)
(?V, predicate, s) AND (?V, 1, ?X) AND (?V, 2, ?X)

P1 =

,

and the second rule is transformed into the pattern:

MINUS
(cid:3)
(cid:4)
(?W, predicate, t) AND (?W, 1, ?X) AND (?W, 2, ?Y )

.

P2 =

Foundations of RDF Databases

187

Thus, we have that gp(Π, p(?X, ?Y )) is the pattern (P1 UNION P2), from
which we conclude that T (cid:3)
2 ((Π, p(?X, ?Y ))) is the SPARQL SELECT query
({?X, ?Y }, (P1 UNION P2)).
(cid:7)(cid:8)
To conclude this section, it only remains to show how Datalog substitutions
are represented as SPARQL mappings. Given a substitution θ over a set W of
variables, deﬁne μθ as a mapping such that: (1) ?X ∈ dom(μθ) if and only if
?X → t is in θ and t (cid:15)= null, and (2) for every ?X ∈ dom(μθ), mapping μθ assigns
to ?X the value assigned by θ to this variable. This transformation together with
T (cid:3)
1 and T (cid:3)
2 can be used to show that the language SPARQL SELECT is at least as
¬
. More precisely, given a set D of Datalog facts and an
expressive as nr-Datalog
¬
nr-Datalog
query Q = (Π, L), we have that a substitution θ is in answer(Q, D)
if and only if the mapping μθ is in (cid:2)T (cid:3)
Theorem 11 ([7]). The language SPARQL SELECT is at least as expressive
¬
as nr-Datalog

1 (D). Thus, we have that:

2 (Q)(cid:3)T (cid:2)

.

From Theorems 10 and 11, and using the well-known fact that Relational Algebra
¬
[1], we obtain that SPARQL
has the same expressive power as nr-Datalog
SELECT and Relational Algebra have the same expressive power.

Corollary 3 ([7]). The language SPARQL SELECT has the same expressive
power as Relational Algebra.

6 A Query Language for RDFS Data

The RDF speciﬁcation includes a set of reserved keywords with its own semantics,
 the RDFS vocabulary. This vocabulary is designed to describe special
relationships between resources like typing and inheritance of classes and properties 
[11]. As with any data structure designed to model information, a natural
question that arises is what the desiderata are for an RDFS query language.
Among the multiple design issues to be considered, it has been largely recognized 
that navigational capabilities are of fundamental importance for data
models with explicit tree or graph structure (like XML and RDF [6,12]).

SPARQL has been designed much in the spirit of classical relational languages
such as SQL. In particular, it has been noted that, although RDF is a directed
labeled graph data format, SPARQL only provides limited navigational functionalities.
 This is more notorious when one considers the RDFS vocabulary (which
current SPARQL speciﬁcation does not cover [45]), where testing conditions like
being a subclass of or a subproperty of naturally requires navigating the RDF
data. A good illustration of this is shown by the following query, which cannot 
be expressed in SPARQL without some navigational capabilities. Consider
the RDF graph shown in Fig. 3. This graph stores information about cities,
transportation services between cities, and further relationships among those
transportation services (in the form of RDFS annotations). For instance, in the
graph we have that a “Seafrance” service is a subproperty of a “ferry” service,
which in turn is a subproperty of a general “transport” service. Assume that we

188

M. Arenas, C. Gutierrez, and J. P´erez

sp

train

sp

TGV

Paris

Calais

Dijon

transport

sp

ferry

sp

dom

sp

bus

sp

Seafrance

NExpress

Dover

Hastings

London

Fig. 3. An RDF graph storing information about transportation services between cities

want to test whether a pair of cities A and B are connected by a sequence of
transportation services, but without knowing in advance what services provide
those connections. We can answer such a query by testing whether there is a path
connecting A and B in the graph, such that every edge in that path is connected
with “transport” by following a sequence of subproperty relationships. For instance,
 for “Paris” and “Calais” the condition holds, since “Paris” is connected
with “Calais” by an edge with label “TGV”, and “TGV” is a subproperty of
“train”, which in turn is a subproperty of “transport”. Notice that the condition
also holds for “Paris” and “Dover”.

In this section, we present a language for navigating RDF data grounded
on paths expressed with regular expressions, which was proposed in [43]. This
language takes advantage of the special features of RDF, and besides regular
expressions, it borrows the notion of branching from XPath [17], to obtain what
is called nested regular expressions. We also show how these navigational capabilities 
can be incorporated into SPARQL, which gives rise to the query language
nSPARQL [43].

Furthermore, in this section we consider two fundamental questions about
these new navigational capabilities and the language nSPARQL. First, we deal
with the problem of whether these new navigational capabilities can be implemented 
eﬃciently. In this section, we present the evaluation algorithm for
nested regular expressions that was proposed in [43], and which works in time
O(|G| · |E|) for an RDF graph G and a nested regular expression E. Second,
we consider the issue of whether nSPARQL is a good query language from an
expressiveness point of view. In this section, we provide evidence that the capabilities 
of nSPARQL can be used to pose many interesting and natural queries
over RDF data. For the sake of presentation, in this section we consider RDF
graphs constructed by using only elements from U, that is, we do not consider
blank nodes.

Foundations of RDF Databases

189

r1

p4

p3

r2

a5

a4

p5

a6

a1

p1

a2

p2

a3

Fig. 4. Nodes a1 and a6 are connected by a path that follows the sequence of navigational 
axes next/next/edge/next/next

-1/node

6.1 Nested Regular Expressions for RDF Data

As usual for graph query languages [36,14,6], the language presented in this
section uses regular expressions to deﬁne paths on graph structures, but taking
advantage of the special features of RDF graphs.

The navigation of a graph is usually done by using an operator next, which
allows one to move from one node to an adjacent one. In our setting, we have RDF
“graphs”, which are sets of triples, not classical graphs. In particular, instead of
classical edges (pair of nodes), we have directed triples of nodes (hyperedges).
Hence, a language for navigating RDF graphs should be able to deal with this
type of objects. In this section, we present the notion of nested regular expression
to navigate through an RDF graph, which was introduced in [43]. This notion
takes into account the special features of the RDF data model. In particular,
nested regular expressions use three diﬀerent navigation axes next, edge and
node, and their inverses next-1, edge-1 and node-1, to move through an RDF
triple. These axes are shown in the following ﬁgure:
-1

edge

node

edge

-1

node

a

p

next

b

a

p

-1

next

b

A navigation axis allows one to move one step forward (or backward) in an RDF
graph. Thus, a sequence of these axes deﬁnes a path in an RDF graph. For
instance, in the graph of Fig. 4, the sequence of axes:

next/next/edge/next/next-1/node

deﬁnes a path between nodes a1 and a6 (the path is shown with dashed lines in
the ﬁgure). Moreover, one can use classical regular expressions over these axes
to deﬁne a set of paths that can be used in a query. The language proposed in
[43] considers an additional axis self that is used not to actually navigate, but
instead to test the label of a speciﬁc node in a path. The language also allows
nested expressions that can be used to test for the existence of certain paths

190

M. Arenas, C. Gutierrez, and J. P´erez

starting at any axis. The following grammar deﬁnes the syntax of nested regular
expressions:

exp := axis | axis::a (a ∈ U) | axis::[exp]

|

exp/exp | exp|exp | exp

∗

(10)
where axis ∈ {self, next, next-1, edge, edge-1, node, node-1}. Before introducing 
the formal semantics of nested regular expressions, we give some intuition
about how these expressions are evaluated in an RDF graph. The most natural 
navigation axis is next::a, with a an arbitrary element from U. Given an
RDF graph G, the expression next::a is interpreted as the a-neighbor relation
in G, that is, the pairs of nodes (x, y) such that (x, a, y) ∈ G. Given that in the
RDF data model, a node can also be the label of an edge, the language allows
one to navigate from a node to one of its leaving edges by using the edge axis.
More formally, the interpretation of edge::a is the pairs of nodes (x, y) such that
(x, y, a) ∈ G. The nesting construction [exp] is used to check for the existence
of a path deﬁned by expression exp. For instance, when evaluating nested expression 
next::[exp] in a graph G, we retrieve the pairs of nodes (x, y) such that
there exists z with (x, z, y) ∈ G, and such that there is a path in G that follows
expression exp starting in z.

The evaluation of a nested regular expression exp in a graph G is formally
deﬁned as a binary relation (cid:2)exp(cid:3)G, denoting the pairs of nodes (x, y) such that
y is reachable from x in G by following a path that conforms to exp [43]. The
formal semantics of the language is shown in Tab. 2. In this table, G is an RDF
graph, a ∈ U, voc(G) is the set of all the elements from U that are mentioned
in G, and exp, exp1, exp2 are nested regular expressions.

Example 6. Let G be the graph in Fig. 3, and consider expression

exp1 = next::[next::sp/self::train].

The expression next::sp/self::train deﬁnes the pairs of nodes (z, w) such that
from z one can reach w by following an edge labeled sp, and furthermore the
label of w is train (expression self::train is used to perform this test). Thus,
the nested expression [next::sp/self::train] performs an existential test; it is
satisﬁed by the nodes in G from which there exists a path that follows an edge
labeled sp and reaches a node labeled train. TGV is the only such node in G
(cid:7)(cid:8)
and, thus, we have that (cid:2)exp1

(cid:3)G = {(Paris, Calais), (Paris, Dijon)}.

6.2 An Eﬃcient Algorithm for Evaluating Nested Regular

Expressions

In [43], it was introduced the language nSPARQL that combines the operators
of SPARQL with the navigational capabilities of nested regular expressions. As
pointed out in that paper, an essential requirement to use nSPARQL in large
applications is that nested regular expressions could be evaluated eﬃciently.

Foundations of RDF Databases

191

Table 2. Formal semantics of nested regular expressions

(cid:2)self(cid:3)G = {(x, x) | x ∈ voc(G)}
(cid:2)self::a(cid:3)G = {(a, a)}
(cid:2)next(cid:3)G = {(x, y) | there exists z s.t. (x, z, y) ∈ G}
(cid:2)next::a(cid:3)G = {(x, y) | (x, a, y) ∈ G}
(cid:2)edge(cid:3)G = {(x, y) | there exists z s.t. (x, y, z) ∈ G}
(cid:2)edge::a(cid:3)G = {(x, y) | (x, y, a) ∈ G}
(cid:2)node(cid:3)G = {(x, y) | there exists z s.t. (z, x, y) ∈ G}
(cid:2)node::a(cid:3)G = {(x, y) | (a, x, y) ∈ G}
(cid:2)axis-1(cid:3)G = {(x, y) | (y, x) ∈ (cid:2)axis(cid:3)G} with axis ∈ {next, node, edge}
(cid:2)axis-1::a(cid:3)G = {(x, y) | (y, x) ∈ (cid:2)axis::a(cid:3)G} with axis ∈ {next, node, edge}
(cid:2)exp 1/exp 2(cid:3)G = {(x, y) | there exists z s.t. (x, z) ∈ (cid:2)exp1(cid:3)G and (z, y) ∈ (cid:2)exp2(cid:3)G}
(cid:2)exp 1|exp 2(cid:3)G = (cid:2)exp1(cid:3)G ∪ (cid:2)exp2(cid:3)G
(cid:2)self::[exp](cid:3)G = {(x, x) | x ∈ voc(G) and there exists z s.t. (x, z) ∈ (cid:2)exp(cid:3)G}
(cid:2)next::[exp](cid:3)G = {(x, y) | there exist z, w s.t. (x, z, y) ∈ G and (z, w) ∈ (cid:2)exp(cid:3)G}
(cid:2)edge::[exp](cid:3)G = {(x, y) | there exist z, w s.t. (x, y, z) ∈ G and (z, w) ∈ (cid:2)exp(cid:3)G}
(cid:2)node::[exp](cid:3)G = {(x, y) | there exist z, w s.t. (z, x, y) ∈ G and (z, w) ∈ (cid:2)exp(cid:3)G}
(cid:2)axis-1::[exp](cid:3)G = {(x, y) | (y, x) ∈ (cid:2)axis::[exp](cid:3)G} with axis ∈ {next, node, edge}

∗(cid:3)G = (cid:2)self(cid:3)G ∪ (cid:2)exp(cid:3)G ∪ (cid:2)exp/exp(cid:3)G ∪ (cid:2)exp/exp/exp(cid:3)G ∪ · ··

(cid:2)exp

In this section, we present an eﬃcient algorithm for this task, which works in
time proportional to the size of the input graph times the size of the expression
being evaluated. As is customary when studying the complexity of the evaluation
problem for a query language [51], we consider its associated decision problem.
For nested regular expressions, this problem is deﬁned as:

: An RDF graph G, a nested regular expression exp, and a pair
(a, b).

Problem : Evaluation problem for nested regular expressions.
Input
Question : Is (a, b) ∈ (cid:2)exp(cid:3)G?
It is important to note that the evaluation problem that we study considers
the pair of nodes (a, b) as part of the input. That is, similar to the complexity
study presented in Section 4, we study the complexity by measuring how diﬃcult
it is to verify whether a given pair of nodes is in the evaluation of a nested regular
expression over an RDF graph.

Following the terminology introduced in [43], we assume that an RDF graph
G is stored as an adjacency list that makes explicit the navigation axes (and their
inverses). Thus, every u ∈ voc(G) is associated with a list of pairs α(u), where
every pair contains a navigation axis and the destination node. For instance,
if (s, p, o) is a triple in G, then (next::p, o) ∈ α(s) and (edge-1::o, s) ∈ α(p).
Moreover, we assume that (self::u, u) ∈ α(u) for every u ∈ voc(G). Notice
that if the number of triples in G is N, then the adjacency list representation
uses space O(N). Thus, when measuring the size of G, we use |G| to denote
the size of its adjacency list representation. We further assume that given an

192

M. Arenas, C. Gutierrez, and J. P´erez

element u ∈ voc(G), we can access its associated list α(u) in time O(1). This is
a standard assumption for graph data-structures in a RAM model [19].
Example 7. The following ﬁgure shows an example of an adjacency-list representation 
of an RDF graph.

a

c

e

d

b

a

b

c

d

e

self::a, a
self::b, b
self::c, c
self::d, d
self::e, e

next::c, b
-1::c, a

next
next::d, e
-1::e, c

edge

next

-1::d, c

edge::b, c
-1::a, c

node
edge::e, d
node::c, e
-1::c, d

node

edge

-1::b, a

node::a, b

(cid:7)(cid:8)
The algorithm in [43] for the evaluation of nested regular expressions was inspired
by some of the algorithms for the evaluation of temporal logics [18] and propositional 
dynamic logic [2,24]. To present this algorithm, we need to introduce
some terminology. An expression exp(cid:3) is a nested subexpression of an expression
exp if axis::[exp(cid:3) ] occurs in exp, with axis ∈ {self, next, next-1, edge, edge-1,
node, node-1}. Given an RDF graph G and a nested regular expression exp, the
algorithm proceeds by recursively considering the nested subexpressions of exp,
labeling every node u of G with a set label(u) of nested expressions. Initially,
label(u) is the empty set. Then at the end of the execution of the algorithm, it
holds that exp ∈ label(u) if and only if there exists z such that (u, z) ∈ (cid:2)exp(cid:3)G.
Before giving any technical details, let us show the general idea of this process
with an example. Figure 5 exempliﬁes the process for a graph G and the nested
expression:

β = next::a/(next::[next::b/self::c])

∗/(edge::[next::d] | next::a)+.

(11)

The process ﬁrst considers the nested subexpressions γ = next::b/self::c and
λ = next::d, and marks the nodes in G according to which ones of these subexpressions 
they satisfy. Thus, after this stage we have that γ ∈ label(r3) since
(r3, c) ∈ (cid:2)γ(cid:3)G, and λ ∈ label(r6) since (r6, r7) ∈ (cid:2)λ(cid:3)G (see Fig. 5). Using
this information, the nodes are marked according to whether they satisfy β,
but considering the previously computed labels (γ and λ) and the expression
β(cid:3) = next::a/(next::γ)∗/(edge::λ | next::a)+. In the example of Fig. 5, we have
that (r1, r5) ∈ (cid:2)β(cid:3)G and, thus, β ∈ label(r1).

We now explain how to eﬃciently carry out the labeling process by using
some tools from automata theory (here we assume some familiarity with this
theory). A key idea in the algorithm presented in [43] is to associate to each
nested regular expression a nondeterministic ﬁnite automaton with ε-transitions

Foundations of RDF Databases

193

G :

self::c

c

next::b

b

β

r1

a

r2

γ

r3

edge::λ

r4

r5

λ

r6

d

r7

next::a

next::γ

next::d

Fig. 5. Example of the labeling process of the RDF graph G according to expres-
∗/(edge::[ next::d ] | next::a)+. First, node
sion β = next::a/(next::[ next::b/self::c ])
r3 is marked with label γ = next::b/self::c (since (r3, c) ∈ (cid:2)γ(cid:3)G), and node r6
with label λ = next::d (since (r6, r7) ∈ (cid:2)λ(cid:3)G). Finally, node r1 is labeled with β
(since (r1, r5) ∈ (cid:2)β(cid:3)G). This last label
is obtained by considering the expression
β(cid:2)

∗/(edge::λ | next::a)+.

= next::a/(next::γ)

(ε-NFA). Given a nested regular expression exp, the set of depth-0 terms of exp,
denoted by D0(exp), is recursively deﬁned as follows:

D0(exp) = {exp} if exp is either axis, or axis::a, or axis::[exp(cid:3) ],
D0(exp1
D0(exp∗) = D0(exp),

|exp2) = D0(exp1) ∪ D0(exp2),

/exp2) = D0(exp1

where axis ∈ {self, next, next-1, edge, edge-1, node, node-1}. For instance, for
the nested expression β in (11), we have that:

D0(β) = { next::a, next::[next::b/self::c], edge::[next::d]}.

Notice that a nested regular expression exp can be viewed as a classical regular
expression over the alphabet D0(exp). We denote by Aexp the ε-NFA that accepts
the language generated by the regular expression exp over the alphabet D0(exp).
For example, Fig. 6 shows an ε-NFA Aβ that accepts the language generated by
expression β in (11) over the alphabet D0(β). As for the case of RDF graphs,
ε-NFAs are stored using an adjacency-list representation.
An essential ingredient in the algorithm presented in [43] is the use of the
product automaton G × Aexp, which is constructed as follows. Assume that we
have the graph G labeled with respect to the nested subexpressions of exp, that
is, for every node u of G and nested subexpression exp(cid:3) of exp, we have that
exp(cid:3) ∈ label(u) if and only if there exists a node v such that (u, v) ∈ (cid:2)exp(cid:3)(cid:3)G.
Let Q be the set of states of Aexp, and δ : Q × (D0(exp) ∪ {ε}) → 2Q the
transition function of Aexp. Then the set of states of G × Aexp is voc(G) × Q,
and its transition function δ(cid:3) : (voc(G) × Q) × (D0(exp) ∪ {ε}) → 2voc(G)×Q is
deﬁned as follows. For every (u, p) ∈ voc(G) × Q and s ∈ D0(exp), we have that
(v, q) ∈ δ(cid:3)((u, p), s) if and only if q ∈ δ(p, s) and one of the following cases hold:

194

M. Arenas, C. Gutierrez, and J. P´erez

next::[ next::b/self::c ]

Aβ :

next::a

q0

q1

ε

q3

q2

ε

edge::[ next::d ]

ε

ε

next::a

qf

G × Aβ :

next::a

r1, q0

r2, q1

next::[ next::b/self::c ]

ε

ε

r2, q2

r2, q3

r4, q1

ε

r4, q3

ε

r4, q2

edge::[ next::d ]

r5, qf

ε

ε

r5, q3

r5, q2

Fig. 6. Automaton Aβ for the nested regular expression β in (11), and product automaton 
G × Aβ

– s = axis and there exists a such that (axis::a, v) ∈ α(u),
– s = axis::a and (axis::a, v) ∈ α(u),
– s = axis::[exp ] and there exists b such that (axis::b, v) ∈ α(u) and exp ∈

label(b),

where axis ∈ {self, next, next-1, edge, edge-1, node, node-1}. Additionally,
if q ∈ δ(p, ε) we have that (u, q) ∈ δ(cid:3)((u, p), ε) for every u ∈ voc(G). That is,
G×Aexp is the standard product automaton of G and Aexp if G is viewed as an
ε-NFA over the alphabet D0(exp). Figure 6 shows the product automaton G×Aβ
for the nested expression β in (11) and the graph G of Fig. 5 (labeled with respect
to the nested subexpressions of β). In this ﬁgure, we have only depicted the states
of G × Aβ that are reachable from the initial state. For instance, we have that
there is a transition from (r2, q1) to (r4, q1) with symbol next::[next::b/self::c]
since: (i) there is a transition from q1 to q1 with next::[next::b/self::c] in Aβ,
and (ii) (next::r3, r4) ∈ α(r2) and γ = next::b/self::c ∈ label(r3).

Two key observations about the product automaton deﬁned above should be
made. Let G be a graph labeled with respect to the nested subexpressions of exp,
and Aexp an ε-NFA for exp. Assume that q0 is the initial state of Aexp and qf is
one of its ﬁnal states. The ﬁrst observation is that if there exists two elements
u, v ∈ voc(G) such that from (u, q0) one can reach state (v, qf ) in G×Aexp, then
(u, v) ∈ (cid:2)exp(cid:3)G. In the example of Fig. 6, we have that (r1, r5) ∈ (cid:2)β(cid:3)G since we
can reach state (r5, qf ) from state (r1, q0) in G × Aβ. The second observation is

Foundations of RDF Databases

195

that given a nested regular expression exp, one can construct in linear time an
ε-NFA for exp by using standard techniques [28]. Thus, given a nested regular
expression exp and an RDF graph G that has been labeled with respect to the
nested subexpressions of exp, it is easy to see that automaton G × Aexp can be
constructed in time O(|G| · |Aexp|).

Now we have all the necessary ingredients to present the algorithm for the
evaluation problem for nested regular expressions given in [43]. This algorithm is
split in two procedures: Label labels G according to the nested subexpressions
of exp as explained above, and Eval returns Yes if (a, b) ∈ (cid:2)exp(cid:3)G and No
otherwise.
Label(G, exp):
1. for each axis::[ exp
2.
3. construct Aexp , and assume that q0 is its initial state and F is its set of ﬁnal states
4. construct G × Aexp
5. for each (u, q0) that is connected to a state (v, qf ) in G × Aexp , with qf ∈ F do
6.

label(u) := label(u) ∪ {exp}

] ∈ D0(exp) do
(cid:2)

(cid:2)

call Label(G, exp

)

Eval(G, exp, (a, b)):
1. for each u ∈ voc(G) do
label(u) := ∅
2.
3. call Label(G, exp)
4. construct Aexp, and assume that q0 is its initial state and F is its set of ﬁnal states
5. construct G × Aexp
6. if a state (b, qf ), with qf ∈ F , is reachable from (a, q0) in G × Aexp
7.
8.
In [43], it is formally proved that procedure Eval can be implemented eﬃciently.
More precisely, assuming that |exp| denotes the size of a nested regular expression
exp, it is shown in [43] that:
Theorem 12 ([43]). Procedure Eval solves the evaluation problem for nested
regular expressions in time O(|G| · |exp|).

then return Yes
else return No

6.3 The Navigational Language nSPARQL
We conclude this section by presenting the query language nSPARQL introduced
in [43], and showing that the navigational capabilities of nSPARQL can be used
to pose many interesting and natural queries over RDF data. In particular, we
formally show that these capabilities can be used to evaluate queries according
to the semantics of the RDFS vocabulary.

The language nSPARQL (nested SPARQL) is obtained by using triple patterns
with nested regular expressions in the predicate position, plus SPARQL operators 
AND, OPT, UNION, and FILTER. Formally, a nested-regular-expression
triple (or just nre-triple) is a tuple t of the form (x, exp, y), where x, y ∈
U ∪ V and exp is a nested regular expression. nSPARQL patterns are recursively
deﬁned from nre-triples:

196

M. Arenas, C. Gutierrez, and J. P´erez

– An nre-triple is an nSPARQL pattern.
– If P1 and P2 are nSPARQL patterns and R is a built-in condition, then
(P1 AND P2), (P1 OPT P2), (P1 UNION P2), and (P1 FILTER R) are
nSPARQL patterns.

To deﬁne the semantics of nSPARQL, we just need to deﬁne the semantics of
nre-triples. The evaluation of an nre-triple t = (?X, exp, ?Y ) over an RDF graph
G is deﬁned as the following set of mappings:

(cid:2)t(cid:3)G = {μ | dom(μ) = {?X, ?Y } and (μ(?X), μ(?Y )) ∈ (cid:2)exp(cid:3)G}.

Similarly, the evaluation of an nre-triple t = (?X, exp, a) over an RDF graph G,
where a ∈ U, is deﬁned as {μ | dom(μ) = {?X} and (μ(?X), a) ∈ (cid:2)exp(cid:3)G}, and
likewise for (a, exp, ?X) and (a, exp, b) with b ∈ U.
Notice that every SPARQL triple (?X, p, ?Y ) with p ∈ U is equivalent to
nSPARQL triple (?X, next::p, ?Y ). Also notice that, since variables are not allowed 
in nested regular expressions, the occurrence of variables in the predicate 
position of triple patterns is forbidden in nSPARQL. Nevertheless, every
SPARQL triple of the form (?X, ?Y, a), with a ∈ U, is equivalent to nSPARQL
pattern (?X, edge::a, ?Y ), and every triple of the form (a, ?X, ?Y ) is equivalent
to (?X, node::a, ?Y ). Thus, what one loses in nSPARQL is only the possibility
of using variables in the three positions of a triple pattern [43].

In the following examples, we show that the navigational capabilities of
nSPARQL can be used to pose queries that are likely to occur in the Semantic
Web, and which cannot be expressed in SPARQL without using nested regular
expressions.

Example 8. Assume that we want to obtain the pairs of cities (?X, ?Y ) such that
there is a way to travel from ?X to ?Y by using either Seafrance or NExpress,
with an intermediate stop in a city that has a direct NExpress trip to London.
Consider nested expression:
exp1 = (next::Seafrance | next::NExpress)+/

self::[next::NExpress/self::London]/

(next::Seafrance | next::NExpress)+

Then pattern P = (?X, exp1
, ?Y ) answers our initial query. Notice that expression 
self::[next::NExpress/self::London] is used to perform the intermediate
(cid:7)(cid:8)
existential test of having a direct NExpress trip to London.

Example 9. Let G be the graph in Fig. 3 and P1 the following pattern:

P1 = (?X, next::[(next::sp)

∗/self::transport], ?Y ).

(12)

Pattern P1 deﬁnes the pairs of cities (?X, ?Y ) such that, there exists a triple
(?X, p, ?Y ) in the graph and a path from p to transport where every edge has label 
sp. Thus, nested expression [(next::sp)∗/self::transport] is used to emulate

Foundations of RDF Databases

197

person

sc

dom

sportsman

works in

range

company

sc

soccer player

sp

soccer team

dom

range

type

Ronaldinho

plays in

type

Barcelona

Sorace

lives in

Chile

Everton

Fig. 7. An RDF graph storing information about soccer players

the process of inference in RDFS; it retrieves all the nodes that are sub-properties
of transport. Hence, pattern P1 retrieves the pairs of cities that are connected by
a direct transportation service, which could be a train, ferry, bus, etc. In general,
if we want to obtain the pairs of cities such that there is a way to travel from
one city to the other, we can use the following nSPARQL pattern:
∗/self::transport])+, ?Y ).

P2 = (?X, (next::[(next::sp)

(13)
(cid:7)(cid:8)

The previous example shows that nSPARQL can be used to emulate some of
the inference rules of RDFS. In [43], it is shown that this is not a particular
phenomenon, that is, it is formally proved that if one wants to answer a SPARQL
query P according to the semantics of RDFS, then one can rewrite P into an
nSPARQL query Q such that Q retrieves the answer to P by directly traversing
the input graph. In the remaining of this section, we show how this is done.

SPARQL follows a subgraph-matching approach, and thus, a SPARQL query
treats RDFS vocabulary without considering its predeﬁned semantics. For example,
 consider the RDF graph G in Fig. 7, which stores information about soccer
players, and consider the graph pattern P = (?X, works in, ?C). Note that,
although the triples (Ronaldinho, works in, Barcelona) and (Sorace, works in,
Everton) can be deduced from G, one obtains the empty set as the result of
evaluating P over G as there is no triple in G with “works in” in the predicate
position.

We are interested in deﬁning the semantics of SPARQL over RDFS, that is,
taking into account not only the explicit RDF triples of a graph G, but also

198

M. Arenas, C. Gutierrez, and J. P´erez

person

sc

dom

sportsman

sc

works in

range

company

type

type

sc

type

soccer player

type

type

type

Ronaldinho

dom

range

sp

plays in

soccer team

type

type

Barcelona

type

type

Sorace

lives in

Chile

Everton

Fig. 8. The closure of the RDF graph of Fig. 7

the triples that can be derived from G according to the semantics of RDFS.
We make an initial restriction. In the rest of the paper we assume that RDFS
vocabulary cannot occur in subject or object position in RDF triples. Supported
on Proposition 1 (2), we only consider rules (2)-(4) for the semantics of RDFS.
Let the closure of an RDF graph G, denoted by cl(G), be the graph obtained
from G by successively applying rules (2)-(4) in Tab. 1 until the graph does not
change. For instance, Fig. 8 shows the closure of the RDF graph of Fig. 7. The
solid lines in Fig. 8 represent the triples in the original graph, and the dashed
lines the additional triples in the closure.

The most direct way to deﬁne the semantics of the RDFS evaluation of
SPARQL patterns is by considering not the original graph but its closure. Thus,
if we now evaluate pattern P = (?X, works in, ?C) over the RDF graph in
Fig. 8, we obtain the mappings {?X → Ronaldinho, ?C → Barcelona} and
{?X → Sorace, ?C → Everton}. The theoretical formalization of such an approach 
was studied in [23]. The following deﬁnition formalizes this notion.

Deﬁnition 6 ([43]). Given a SPARQL graph pattern P , the RDFS evaluation
G , is deﬁned as the set of mappings (cid:2)P (cid:3)cl(G), that
of P over G, denoted by (cid:2)P (cid:3)rdfs
is, as the evaluation of P over the closure of G.

Let us show with an example how nSPARQL can be used to obtain the RDFS
evaluation of some patterns by directly traversing the input graph.

Example 10. Let G be the RDF graph in Fig. 7, and assume that we want to
obtain the type information of Ronaldinho. This information can be obtained
by computing the RDFS evaluation of the pattern (Ronaldinho, type, ?C). By

Foundations of RDF Databases

199

simply inspecting the closure of G in Fig. 8, we obtain that the RDFS evaluation
of (Ronaldinho, type, ?C) is the set of mappings:

{{?C → soccer player},{?C → sportsman},{?C → person}}.

However, if we directly evaluate this pattern over G, we obtain a single mapping
{?C → soccer player}. Consider now the nSPARQL pattern:

P = (Ronaldinho, next::type/(next::sc)

∗, ?C).

The expression next::type/(next::sc)∗ is intended to obtain the pairs of nodes
such that there is a path between them that starts with label type followed
by zero or more labels sc. When evaluating this expression in G, we obtain the
set of pairs {(Ronaldinho, soccer player), (Ronaldinho, sportsman), (Ronaldinho,
person), (Barcelona, soccer team)}. Thus, the evaluation of P results in the set
of mappings:

{{?C → soccer player},{?C → sportsman},{?C → person}}.

In this case, pattern P is enough to obtain the type information of Ronaldinho
in G according to the RDFS semantics, that is,

G = (cid:2)(Ronaldinho, next::type/(next::sc)

∗, ?C)(cid:3)G.
(cid:2)(Ronaldinho, type, ?C)(cid:3)rdfs
Although the expression next::type/(next::sc)∗ is enough to obtain the type
information for Ronaldinho in G, it cannot be used in general to obtain the
type information of a resource. For instance, in the same graph, assume that we
want to obtain the type information of Everton. In this case, if we evaluate the
pattern (Everton, next::type/(next::sc)∗, ?C) over G, we obtain the empty set.
Consider now the nSPARQL pattern:

Q = (Everton, node-1/(next::sp)

∗/next::range, ?C).

With the expression node-1/(next::sp)∗/next::range, we follow a path that ﬁrst
navigates from a node to one of its incoming edges by using node-1, and then
continues with zero or more sp edges and a ﬁnal range edge. The evaluation of
this expression over G results in the set {(Everton, soccer team), (Everton, company 
), (Barcelona, soccer team), (Barcelona, company)}. Thus, the evaluation
of Q in G is the set of mappings:

{{?C → soccer team},{?C → company}}.

By looking at the closure of G in Fig. 8, we see that pattern Q obtains exactly
the type information of Everton in G, that is, (cid:2)(Everton, type, ?C)(cid:3)rdfs
G = (cid:2)Q(cid:3)G.(cid:7)(cid:8)
Next we show how the ideas in Examples 9 and 10 were generalized in [43] to
obtain a way to evaluate a SPARQL query according to the RDFS semantics.
More precisely, we show that if a SPARQL pattern P is constructed by using

200

M. Arenas, C. Gutierrez, and J. P´erez

triple patterns having at least one position with a non-variable element, then the
RDFS evaluation of P can be obtained by directly traversing the input graph
with an nSPARQL pattern.

Consider the following translation function from elements in U to nested regular 
expressions:
trans(sc)
trans(sp)
trans(dom) = next::dom
trans(range) = next::range
trans(type) = ( next::type/(next::sc)∗ |

= (next::sc)+
= (next::sp)+

edge/(next::sp)∗/next::dom/(next::sc)∗ |
node-1/(next::sp)∗/next::range/(next::sc)∗ )

= next::[(next::sp)∗/self::p]

for p /∈ {sc, sp, range, dom, type}.
trans(p)
Notice that this translation function has been implicitly used in Examples 9
and 10. In the following lemma, it is shown that given an RDF graph G and
a triple pattern t not containing a variable in the predicate position, the above
translation function can be used to obtain the RDFS evaluation of t over G by
navigating G through a nested regular expression.
Lemma 3 ([43]). Let (x, p, y) be a SPARQL triple pattern with x, y ∈ U ∪ V
and p ∈ U. Then (cid:2)(x, p, y)(cid:3)rdfs
Suppose now that we have a SPARQL triple pattern t with a variable in the
predicate position, but such that the subject and object of t are not both variables.
 Next it is shown how to construct an nSPARQL pattern Pt such that
G = (cid:2)Pt(cid:3)G [43]. Assume that t = (x, ?Y, a) with x ∈ U ∪ V , ?Y ∈ V , and
(cid:2)t(cid:3)rdfs
a ∈ U, that is, t does not contain a variable in the object position. Consider for
every p ∈ {sc, sp, dom, range, type}, the pattern Pt,p deﬁned as:

G = (cid:2)(x, trans(p), y)(cid:3)G for every RDF graph G.

((x, trans(p), a) AND (?Y, self::p, ?Y )).

Then deﬁne pattern Pt as follows:

Pt = ((x, edge::a/(next::sp)∗, ?Y ) UNION Pt,sc UNION Pt,sp UNION

Pt,dom UNION Pt,range UNION Pt,type).

In a similar way, it is possible to deﬁne pattern Pt for a triple pattern t =
(a, ?Y, x), where a ∈ U, ?Y ∈ V and x ∈ U ∪ V . By using this construction, it is
shown in [43] that:
Lemma 4 ([43]). Let t = (x, ?Y, z) be a triple pattern such that ?Y ∈ V and
x /∈ V or z /∈ V . Then (cid:2)t(cid:3)rdfs
Let T be the set of triple patterns of the form (x, y, z) such that x /∈ V or
y /∈ V or z /∈ V . We have shown how to translate every triple pattern t ∈ T into
an nSPARQL pattern Pt such that (cid:2)t(cid:3)rdfs
G = (cid:2)Pt(cid:3)G. Moreover, for every triple
pattern t, its translation is of size linear in the size of t. Given that the semantics
of SPARQL is deﬁned from the evaluation of triple patterns, the following results
follows:

G = (cid:2)Pt(cid:3)G for every RDF graph G.

Foundations of RDF Databases

201

sp

sp

Z

train

sp

sp

transport

sp

ferry

sp

dom

sp

bus

sp

TGV

Seafrance

NExpress

Paris

Calais

Dijon

Dover

Hastings

London

Fig. 9. An RDF graph with RDFS vocabulary and blank nodes

Theorem 13 ([43]). Let P be a SPARQL pattern constructed from triple patterns 
in T . Then there exists an nSPARQL pattern Q such that (cid:2)P (cid:3)rdfs
G = (cid:2)Q(cid:3)G
for every RDF graph G. Moreover, the size of Q is linear in the size of P .

7 Future Work: Dealing with Blank Nodes

Blank nodes, that is, existential objects, are not new in the area of databases
[29,52]. And not only that, they have also been present in the RDF data model
since the beginning of the Semantic Web initiative [34]. However, the design of
SPARQL was made to keep the eﬃciency of the language and, in this direction,
the current deﬁnition of this language does not consider the semantics of blank
nodes recommended by the W3C [27]. To see why this is the case, let G1 and
G2 be the RDF graphs in Figures 3 and 9, respectively, and assume that node
Z in G2 is a blank node. Consider the following SPARQL query:

(cid:3)(cid:3)

P =

(?X, sp, ?V ) AND (?V, sp, ?Y ) AND

(cid:4)
(?X, sp, ?W ) AND (?W, sp, ?Y )

(cid:4)
FILTER¬(?V =?W )

.

Query P evaluated over an RDF graph G retrieves mappings {?X → a, ?Y →
b, ?V → c, ?W → d} such that (a, sp, c), (c, sp, b), (a, sp, d) and (d, sp, b)
are all triples in G and c, d are distinct elements. Notice that the clause
FILTER¬(?V =?W ) is used to indicate that ?V and ?W must take distinct
values. Under the W3C semantics for blank nodes [27], G1 and G2 are equivalent 
as blank node Z in G2 can be identiﬁed with node train. Therefore,
one would expect that the answer to P over G1 is the same as over G2.
However, this is not the case; Z and train are considered to be distinct values 
under the semantics for SPARQL proposed in [45] and, thus, mapping

202

M. Arenas, C. Gutierrez, and J. P´erez

{?X → TGV, ?Y → transport, ?V → train, ?W → Z} is in the answer of P
over G2 but not in the answer of P over G1.

Evaluating queries which involve blank nodes is challenging, and there is not
yet consensus in the Semantic Web community on how to deﬁne a query language
for this type of data. As an important problem for future work, we identify the
issue of extending SPARQL to consider RDF data with blank nodes. In practice,
a considerable number of RDF databases include this type of nodes and, thus,
this project is driven by the need to extend SPARQL to cope with this data. We
hope that a project like this will help in bridging the gap between the current
speciﬁcation of SPARQL [45] and both the deﬁnition of the semantics of RDF
data [27] and the way RDF data is used in real life.

We conclude this section by pointing out that blank nodes are used not only
on RDF graphs but also in SPARQL patterns. They were introduced to make
SPARQL compatible with future logical extensions. Nevertheless, they play no
major role in the current semantics. In fact, it can be shown that each SPARQL
query Q can be simulated by a SPARQL query Q(cid:3) not mentioning any blank
nodes. More precisely, it follows from the deﬁnitions of RDF instance mapping,
solution mapping, and the order of evaluation of solution modiﬁers (see [45]),
that if Q(cid:3) is obtained from Q by replacing each blank node B by a fresh variable
?XB, then Q and Q(cid:3) give the same results.

Acknowledgments

This paper is a survey of well-known results on the theory of RDF, which compiles 
and summarizes results of papers of the authors and their colleagues Renzo
Angles, Carlos Hurtado, Alberto Mendelzon and Sergio Mu˜noz. The authors
were supported by: Arenas - Fondecyt grant 1090565; Gutierrez - Fondecyt grant
1070348; P´erez - Conicyt Ph.D. Scholarship; Arenas, Gutierrez and P´erez - grant
P04-067-F from the Millennium Nucleus Center for Web Research.

References

1. Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley,

Reading (1995)

2. Alechina, N., Immerman, N.: Reachability Logic: An Eﬃcient Fragment of Transitive 
Closure Logic. Logic Journal of the IGPL 8(3), 325–338 (2000)

3. Alkhateeb, F.: Querying RDF(S) with Regular Expressions. PhD Thesis, Universit´e

Joseph Fourier, Grenoble, FR (2008)

4. Alkhateeb, F., Baget, J., Euzenat, J.: RDF with regular expressions. Research

Report 6191, INRIA (2007)

5. Alkhateeb, F., Baget, J., Euzenat, J.: Constrained regular expressions in SPARQL.

In: SWWS 2008, pp. 91–99 (2008)

6. Angles, R., Gutierrez, C.: Survey of graph database models. ACM Comput.

Surv. 40(1), 1–39 (2008)

7. Angles, R., Gutierrez, C.: The Expressive Power of SPARQL. In: Sheth, A.P.,
Staab, S., Dean, M., Paolucci, M., Maynard, D., Finin, T., Thirunarayan, K. (eds.)
ISWC 2008. LNCS, vol. 5318, pp. 114–129. Springer, Heidelberg (2008)

Foundations of RDF Databases

203

8. Anyanwu, K., Maduko, A., Sheth, A.: SPARQ2L: Towards Support for Subgraph

Extraction Queries in RDF Databases. In: WWW 2007, pp. 797–806 (2007)

9. Arenas, M., Gutierrez, C., Parsia, B., P´erez, J., Polleres, A., Seaborne, A.: SPARQL
- Where are we? Current state, theory and practice. Unit-2: SPARQL Formalization.
 In: Tutorial given at ESWC 2007, Innsbruck, Austria (2007),
http://axel.deri.ie/~axepol/sparqltutorial/

10. Arenas, M., Gutierrez, C., P´erez, J.: An Extension of SPARQL for RDFS. In:
Christophides, V., Collard, M., Gutierrez, C. (eds.) SWDB-ODBIS 2007. LNCS,
vol. 5005, pp. 1–20. Springer, Heidelberg (2008)

11. Brickley, D., Guha, R.V.: RDF Vocabulary Description Language 1.0: RDF

Schema. W3C Recommendation (February 2004),
http://www.w3.org/TR/rdf-schema/

12. Benedikt, M., Koch, C.: XPath leashed. ACM Computing Surveys 41(1) (2008)
13. Broekstra, J., Kampman, A., van Harmelen, F.: Sesame: A generic architecture for
storing and querying RDF and RDF schema. In: Horrocks, I., Hendler, J. (eds.)
ISWC 2002. LNCS, vol. 2342, pp. 54–68. Springer, Heidelberg (2002)

14. Calvanese, D., De Giacomo, G., Lenzerini, M., Vardi, M.Y.: Rewriting of Regular
Expressions and Regular Path Queries. J. Comput. Syst. Sci (JCSS) 64(3), 443–465
(2002)

15. Carroll, J.J., Bizer, C., Hayes, P., Stickler, P.: Named graphs. Journal of Web

Semantics 3, 247–267 (2005)

16. Chandra, A.K., Merlin, P.M.: Optimal Implementation of Conjunctive Queries in

Relational Data Bases. In: STOC 1977, pp. 77–90 (1977)

17. Clark, J., DeRose, S.: XML Path Language (XPath). W3C Recommendation

(November 1999), http://www.w3.org/TR/xpath

18. Clarke, E., Grumberg, O., Peled, D.: Model Checking. The MIT Press, Cambridge

(2000)

19. Cormen, T., Leiserson, C., Rivest, R., Stein, C.: Introduction to Algorithms.

McGraw-Hill, New York (2003)

20. Cyganiak, R.: A relational algebra for SPARQL. Tech. Rep. HPL-2005-170, HPLabs 
(2005), http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html

21. Galindo-Legaria, C.A., Rosenthal, A.: Outerjoin simpliﬁcation and reordering for

query optimization. TODS 22(1), 43–73 (1997)

22. Garey, M.R., Johnson, D.S.: Computers and Intractability: A Guide to the Theory

of NP-Completeness. W.H. Freeman, New York (1979)

23. Gutierrez, C., Hurtado, C., Mendelzon, A.: Foundations of Semantic Web

Databases. In: PODS 2004, pp. 95–106 (2004)

24. Harel, D., Kozen, D., Tiuryn, J.: Dynamic Logic. MIT Press, Cambridge (2000)
25. Harris, S., Gibbins, N.: 3store: Eﬃcient bulk RDF storage. In: PSSS 2003, pp. 1–15

(2003)

26. Hayes, J., Gutierrez, C.: Bipartite Graphs as Intermediate Model for RDF. In: McIlraith,
 S.A., Plexousakis, D., van Harmelen, F. (eds.) ISWC 2004. LNCS, vol. 3298,
pp. 47–61. Springer, Heidelberg (2004)

27. Hayes, P.: RDF Semantics. W3C Recommendation (February 2004),

http://www.w3.org/TR/rdf-mt/

28. Hopcroft, J.E., Motwani, R., Ullman, J.D.: Introduction to Automata Theory, Languages,
 and Computation. Addison Wesley, Reading (2006)

29. Imielinski, T., Lipski Jr., W.: Incomplete Information in Relational Databases. J.

ACM 31(4), 761–791 (1984)

30. Karvounarakis, G., Alexaki, S., Christophides, V., Plexousakis, D., Scholl, M.:
RQL: a declarative query language for RDF. In: WWW 2002, pp. 592–603 (2002)

204

M. Arenas, C. Gutierrez, and J. P´erez

31. Kochut, K.J., Janik, M.: SPARQLeR: Extended Sparql for Semantic Association
Discovery. In: Franconi, E., Kifer, M., May, W. (eds.) ESWC 2007. LNCS, vol. 4519,
pp. 145–159. Springer, Heidelberg (2007)

32. Lassila, O., Swick, R.: Resource description framework (RDF) model and syntax

speciﬁcation W3C Recommendation (February 1999),
http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/

33. Levene, M., Loizou, G.: A Guided Tour of Relational Databases and Beyond.

Springer, Heidelberg (1999)

34. Manola, F., Miller, E., McBride, B.: RDF Primer, W3C Recommendation

(February 10 , 2004), http://www.w3.org/TR/REC-rdf-syntax/

35. Marin, D.: RDF Formalization, Santiago de Chile, Technical Report Universidad

de Chile, TR/DCC-2006-8 (2004),
http://www.dcc.uchile.cl/~cgutierr/ftp/draltan.pdf

36. Mendelzon, A., Wood, P.: Finding Regular Simple Paths in Graph Databases.

SIAM J. Comput. 24(6), 1235–1258 (1995)

37. Mu˜noz, S., P´erez, J., Gutierrez, C.: Minimal Deductive Systems for RDF.
In: Franconi, E., Kifer, M., May, W. (eds.) ESWC 2007. LNCS, vol. 4519,
pp. 53–67. Springer, Heidelberg (2007)

38. Olson, M., Ogbuji, U.: The Versa Speciﬁcation,

http://uche.ogbuji.net/tech/rdf/versa/etc/versa-1.0.xml

39. ODP - Open Directory Project, http://www.dmoz.org/
40. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL. In:
Cruz, I., Decker, S., Allemang, D., Preist, C., Schwabe, D., Mika, P., Uschold, M.,
Aroyo, L.M. (eds.) ISWC 2006. LNCS, vol. 4273, pp. 30–43. Springer, Heidelberg
(2006)

41. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL (submitted 
for publication)

42. P´erez, J., Arenas, M., Gutierrez, C.: Semantics of SPARQL. Tech. Report Universidad 
de Chile, TR/DCC-2006-17 (2006)

43. P´erez, J., Arenas, M., Gutierrez, C.: nSPARQL: A Navigational Language for
RDF. In: Sheth, A.P., Staab, S., Dean, M., Paolucci, M., Maynard, D., Finin,
T., Thirunarayan, K. (eds.) ISWC 2008. LNCS, vol. 5318, pp. 66–81. Springer,
Heidelberg (2008)

44. Polleres, A.: From SPARQL to rules (and back). In: Proceedings of the 16th International 
World Wide Web Conference (WWW), pp. 787–796. ACM, New York
(2007)

45. Prud’hommeaux, E., Seaborne, A.: SPARQL Query Language for RDF. W3C Recommendation 
(January 2008), http://www.w3.org/TR/rdf-sparql-query/

46. RDF Site Summary (RSS) 1.0, http://web.resource.org/rss/1.0/
47. Schmidt, M., Meier, M., Lausen, G.: Foundations of SPARQL Query Optimization.

arXiv.org paper arXiv:0812.3788v1 (December 19, 2008)

48. The Dublin Core Metadata Initiative, http://dublincore.org/
49. The Friend of a Friend (FOAF) project, http://www.foaf-project.org/
50. Uniform Resource Identiﬁer (URI): Generic Syntax, http://tools.ietf.org/

html/rfc3986

51. Vardi, M.Y.: The Complexity of Relational Query Languages (Extended Abstract).

In: STOC 1982, pp. 137–146 (1982)

52. Zaniolo, C.: Database Relations with Null Values. J. Comput. Syst. Sci. 28(1),

142–166 (1984)

