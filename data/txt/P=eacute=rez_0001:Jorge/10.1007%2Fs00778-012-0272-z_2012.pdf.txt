The VLDB Journal (2012) 21:823–842
DOI 10.1007/s00778-012-0272-z

REGULAR PAPER

Query language-based inverses of schema mappings:
semantics, computation, and closure properties
Marcelo Arenas · Jorge Pérez · Juan Reutter ·
Cristian Riveros

Received: 23 August 2011 / Revised: 13 January 2012 / Accepted: 5 March 2012 / Published online: 6 April 2012
© Springer-Verlag 2012

Abstract The inversion of schema mappings has been
identiﬁed as one of the fundamental operators for the development 
of a general framework for metadata management.
During the last few years, three alternative notions of inversion 
for schema mappings have been proposed (Fagininverse 
(Fagin, TODS 32(4), 25:1–25:53, 2007), quasiinverse 
(Fagin et al., TODS 33(2), 11:1–11:52, 2008), and
maximum recovery (Arenas et al., TODS 34(4), 22:1–22:48,
2009)). However, these notions lack some fundamental properties 
that limit their practical applicability: most of them
are expressed in languages including features that are difﬁcult 
to use in practice, some of these inverses are not guaranteed 
to exist for mappings speciﬁed with source-to-target 
tuple-generating dependencies (st-tgds), and it has been
futile to search for a meaningful mapping language that is
closed under any of these notions of inverse. In this paper,

A preliminary version of this article appeared in PVLDB [3].

Electronic supplementary material The online version of this
article (doi:10.1007/s00778-012-0272-z) contains supplementary
material, which is available to authorized users.

M. Arenas
Department of Computer Science, PUC Chile, Santiago, Chile
e-mail: marenas@ing.puc.cl

J. Pérez (B)

Department of Computer Science, Universidad de Chile,
Santiago, Chile
e-mail: jperez@dcc.uchile.cl

J. Reutter
School of Informatics, University of Edinburgh, Edinburgh, UK
e-mail: juan.reutter@ed.ac.uk

C. Riveros
Department of Computer Science, University of Oxford, Oxford, UK
e-mail: cristian.riveros@cs.ox.ac.uk

we develop a framework for the inversion of schema mappings 
that fulﬁlls all of the above requirements. It is based on
the notion of C-maximum recovery, for a query language C,
a notion designed to generate inverse mappings that recover
back only the information that can be retrieved with queries in
C. By focusing on the language of conjunctive queries (CQ),
we are able to ﬁnd a mapping language that contains the
class of st-tgds, is closed under CQ-maximum recovery, and
for which the chase procedure can be used to exchange data
efﬁciently. Furthermore, we show that our choices of inverse
notion and mapping language are optimal, in the sense that
choosing a more expressive inverse operator or mapping language 
causes the loss of these properties.

Inverses · Schema mappings · Metadata

Keywords
management · Closure properties · Conjunctive queries ·
Data exchange · Data integration

1 Introduction

A schema mapping is a speciﬁcation that describes how
data from a source schema are to be mapped to a target
schema. Schema mappings have proved to be essential for
several data interoperability tasks such as data exchange [12],
data integration [23], and peer data management [18,20].
The research on this area has mainly focused on performing 
these tasks and has produced several applications that
work with declarative speciﬁcations of schema mappings.
However, as Bernstein pointed out in [8], many information
system problems involve not only the design and integration 
of complex application artifacts, but also their subsequent 
manipulation. Driven by this consideration, Bernstein
proposed in [8] a general framework for managing schema
mappings. In this framework, schema mappings are usually
speciﬁed in some logical language, and high-level algebraic

123

824

M. Arenas et al.

operators like match, merge, and compose are used to manipulate 
them [8,9,26,28].

One of the operators in Bernstein’s framework is the
inverse of a schema mapping that has recently received considerable 
attention [2,4,9,11,15]. Consider a mapping M
from a schema A to a schema B. Intuitively, an inverse of M
is a new mapping that describes the reverse relationship from
B to A and is semantically consistent with the relationship
established by M.

In practical scenarios, the inverse of a mapping can have
several applications. In a data exchange context [7,12], if
a mapping M is used to exchange data from a source to a
target schema, an inverse of M can be used to exchange
the data back to the source, thus reverting the application of
M. As a second application, consider a peer data management 
system (PDMS) [19,20]. In a PDMS, a peer can act
as a data source, a mediator, or both, and the system relates
peers by establishing mappings between the peer schemas.
Mappings between peers are usually directional and are used
to reformulate queries. For example, if there is a mapping M
from peer P1 to peer P2 and a query over P2, a PDMS can use
M to reformulate the query by using P1 as a source. Hence,
an inverse of M would allow the PDMS to reformulate a
query over P1 in terms of P2, thus considering this time P2
as a source. Another application is schema evolution, where
the inverse together with the composition operator play a
crucial role [9]. Consider a mapping M between schemas A
(cid:2)
and B, and assume that schema A evolves into a schema A
.
This evolution can be expressed as a mapping M(cid:2)
between
(cid:2)
(cid:2)
. Thus, the relationship between the new schema A
A and A
and schema B can be obtained by inverting mapping M(cid:2)
and
then composing the result with mapping M.

All the previous work on inverting schema mappings has
been motivated by foundational issues [4,11,15,16], one of
the most delicate being the definition of a good semantics
for inversion of mappings. Yet, up to now, little attention has
been paid to the study of practical issues regarding inverting
schema mappings, and systems implementing these notions
are scarce, mostly built for speciﬁc management tasks [27].
One possible reason for this is that all the notions of inverse
proposed so far fail to meet some fundamental requirements
that guarantee their practical applicability. Below, we identify 
three such crucial conditions.

Existence for the most common mappings: A ﬁrst crucial
requirement for any notion of inverse for schema mappings
is that it has to be deﬁned for the mappings used in practice. In
particular, given that the language of source-to-target tuplegenerating 
dependencies (st-tgds), or GLAV constraints, is
arguably the most popular language to specify schema mappings,
 an inverse notion to be used in practice has to be applicable 
for each schema mapping speciﬁed in terms of these
dependencies.

123

Efﬁciency of exchanging data: In the data exchange scenario,
the standard procedure used to exchange data efﬁciently with
a mapping is based on the classical chase procedure [12].
More precisely, given a mapping M and a source database
I , a canonical translation of I according to M is computed
by chasing I with the set of dependencies deﬁning M [12].
Thus, when computing an inverse of M, it would be desirable 
from a practical point of view to obtain a mapping M(cid:2)
where the chase procedure can also be used to exchange data
in an efﬁcient way.

Speciﬁcation of inverses: Closely related with the previous 
issue, there is a representation issue. In the framework
proposed by Bernstein [8], schema mappings are ﬁrst-class
citizens, and high-level algebraic operators are used to
manipulate and reuse them. In this algebraic context, a natural 
question is whether a logical language for specifying
mappings is closed under inversion: given a schema mapping 
speciﬁed in some language L, can its inverse be also
speciﬁed in L? For example, if a mapping is speciﬁed by a
set of st-tgds, can its inverse be speciﬁed in the same lan-
guage? In practice, this is a desirable condition as it means
that inverse mappings can be speciﬁed in a language with
good properties for metadata management.

The search for an inverse notion satisfying these requirements 
has several practical implications, as these properties 
are crucial to guarantee the possibility of combining
the inverse operator with other operators from Bernstein’s
framework [8]. Up to this point, no meaningful mapping
language is known to be closed under any of the inverse
notions proposed in the literature [4,11,15,16], and a few
of them where the chase can be used to exchange data efﬁciently 
are not guaranteed to exist for a mapping speciﬁed by
st-tgds, which obviously undermines their practical applicability 
(see e.g., [11]). Thus, the main goal of this paper is to
ﬁnd a notion of inverse that satisﬁes the three requirements
previously mentioned. This goal amounts to (1) ﬁrst choose
a natural semantics for the inverse operator and (2) provide
a useful mapping language L that contains the language of
st-tgds, is closed under this notion of inverse, and where
the classical chase procedure can be used to exchange data
efﬁciently.

The issue of ﬁnding closed mapping languages for schema
mapping operators has been raised as a “prominent issue” in
metadata management [22]. Unfortunately, until now there
have been very little positive results about this issue for an
inverse operator [4,11,15,16]. This suggests that one should
look for a weaker notion of inverse in order to obtain the
desired closure results. But how can an inverse notion be
weakened, and how much? To answer these questions, we
follow earlier work on schema mapping composition [24] and
schema mapping optimization [13] and propose a new inverse
notion designed to generate inverse mappings that recover

Query language-based inverses of schema mappings

825

back only the information that could have been retrieved by
a given query language.
More precisely, our framework is based on the following
idea. Let C be a class of queries. Then, assuming that we
are only interested in answering queries that belong to C,
our inverse should only care to recover the initial data that
could be retrieved by posing queries in C. Moreover, there
is a soundness requirement; we would like to recover only
sound information, that is, information that was already present 
before the exchange. But, what does it mean to recover
sound information? By answering this simple yet fundamental 
question, we uncover a rich theory. In fact, this gives rise
to the notion of C-recovery of a mapping: a reverse mapping
that recovers sound information for a given mapping under a
query language C. We further introduce an order relation on
C recoveries that lead to the notion of C-maximum recovery,
which is a mapping that recovers the maximum amount of
information for a given mapping according to C.
By choosing different alternatives for the query language
C in the definition of the notion of C-maximum recovery, we
are able to ﬁne-tune the power of the resulting inverses. In
particular, this allows us to characterize the notions of inverse
proposed in the literature; as an example, it is shown in the
paper that the notion of Fagin-inverse proposed in [11] corresponds 
to the notion of C-maximum recovery if C is the class
of unions of conjunctive queries with inequalities. But more
importantly, the parameterization of our notion of inverse
by a query language allows us to ﬁnd a natural notion of
inverse for schema mappings that satisﬁes the requirements
mentioned before.

Let CQ be the class of conjunctive queries. The main
result of the second part of the paper states that the notion of
CQ-maximum recovery satisﬁes our proposed desiderata.
That is, there exists a well-behaved language that contains
the class of st-tgds, that is closed under CQ-maximum recovery,
 and where the classical chase procedure can be used to
exchange data efﬁciently. More specifically, this language is
deﬁned by the class of CQC,(cid:3)=- toCQ 
dependencies, which
are, essentially, st-tgds extended in the premises with inequalities 
and a built-in predicate C(·) to differentiate constants
from null values.

We prove several results that

justify our choices of
CQ-maximum recovery as the notion of inverse for schema
mappings and of CQC,(cid:3)=- toCQ 
dependencies as the language 
for specifying schema mappings. In particular, we
show in the paper that given that the new features of
CQC,(cid:3)=- toCQ 
dependencies are only allowed in the
premises, this language is good as the language of st-tgds
for data exchange purposes. Moreover, we provide in the
paper an algorithm that, given a mapping speciﬁed by a set
of CQC,(cid:3)=- toCQ 
dependencies, returns a CQ-maximum
recovery of this mapping that is also speciﬁed by a set of
CQC,(cid:3)=- toCQ 
dependencies. Finally, we show that our

choices are optimal to obtain the desired aforementioned
properties, in the sense that choosing a more expressive
inverse operator or mapping language causes the loss of these
properties. For instance, we prove that a closure result cannot
be obtained if instead of using CQ-maximum recoveries as
the notion for inverting mappings, we consider either UCQmaximum 
recoveries or CQ(cid:3)=

-maximum recoveries.

In Sect. 2, we introduce the notaOrganization 
of the paper.
tion used in this paper. In Sect. 3, we present the notion of Cmaximum 
recovery. In Sect. 4, we compare our proposal with
the previous notions of inverses proposed in the literature. In
Sect. 5, we present an algorithm to compute CQ-maximum
recoveries and show a closure result for the language of mappings 
speciﬁed by CQC,(cid:3)=- toCQ 
dependencies. In Sect. 6,
we show the optimality of the closure result in Sect. 5. Finally,
we present some concluding remarks in Sect. 7. For the sake
of space, the complete proofs of the results in this paper
are included as electronic supplementary material (electronic
Appendix A).

1.1 New material in this paper

Preliminary versions of some of the results in this paper
appeared in [3]. Nevertheless, this paper contains substantial 
new material. We include a new result on the separation
of C-maximum recoveries for the most common extensions
of CQ (Proposition 1). The notion of fully recoverable query
introduced in Sect. 4 is new, as well as the characterizations of
Fagin-inverses and quasi-inverses that use this notion (Propositions 
2 and 3). We also include a result on the relationship
between maximum recoveries and C-maximum recoveries
(Theorem 3), which is not given in [3]. The closure result
presented in Sect. 5 (Theorem 4) is also new as well as the
results in Sect. 6, which show the optimality of this closure
property (Propositions 5, 6 and 7). Beside the aforementioned
new results, in this paper, we include new examples and also
many proof sketches in the body of the paper plus full proofs
in the electronic appendix (which are not included in [3]).

1.2 Related work and limitations of our approach

As most of the research on schema mappings [12,13,22]
and in particular on inverting mappings [2–4,11,15,17], we
make the assumption that source instances contain only constant 
values, while target instances contain constant and null
values, the latter to represent missing (incomplete) information 
(see Sect. 2 for a formalization of our setting). We discuss 
here the limitations of this assumption when studying
inverses, as well as the related work on relaxing this assumption 
[5,16].

There have been at least two investigations that relax the
assumption mentioned above in order to study the inversion

123

826

M. Arenas et al.

of schema mappings. In [16], the authors study a setting in
which both source and target instances contain null values,
and make the case that inverses should be studied in this symmetric 
setting. Similarly, in [5], the authors study the problem 
of exchanging incomplete information in a more general
setting not only including nulls in the source data, but also
considering general representation systems to exchange data.
In both papers, the focus is on the semantics of inversion,
and less attention is paid in more practical concerns. In particular,
 although in [16] the authors introduce a meaningful
notion of inverse in the symmetric setting, the results from
an algorithmic point of view are not very encouraging; the
authors provide an algorithm to compute inverses of st-tgds
that uses second-order quantiﬁcation to express inverses, and
left open whether the full power of ﬁrst-order logic is enough
to express inverses even for the simple fragment of mappings
speciﬁed by full st-tgds (which are st-tgds without existential
quantiﬁcation). Similarly, although the authors in [5] show
that by adding expressiveness to source and target instances
one can obtain good properties for the existence of inverses,
they do not provide an algorithm to compute them.

Instead of studying a more expressive setting allowing
mappings to contain incomplete information in source and
target instances, we try to substantially improve our understanding 
of the classical data exchange setting in which
source instances are considered to have only constant values.
 This assumption not only allows us to simplify our
study but also allows us to provide several positive algorithmic 
and practical results. Nevertheless, as observed by Fagin
et al. [16], our setting comes with a limitation on the uniform
treatment of data exchange in both directions (from source to
target and from target to source). It has been noted in [16] that
after exchanging data with a mapping M, the usual instance
that one would like to materialize in the target, which is the
result of the chase procedure, contains null values. Thus, if
one uses the inverse of M to exchange data back, this time
from the target to the source schema, nulls would naturally
arise in the source. This is the reason why Fagin et al. [16]
consider that the restriction of having only constant in the
source is a semantic mismatch in the study of inverses.

From the point of view advocated in [16], the proposal
for inverting mappings introduced in this paper also suffers
from the aforementioned semantic mismatch. Nevertheless,
it should be noticed that there is not yet consensus on the
community on what is the ultimate setting to study inverses
and more generally, schema mapping operators. Moreover,
most of the investigation has been carried out on the classical 
(asymmetrical) data exchange setting, and this setting
had allowed the development of several positive results on the
subject [4,11,14,15,17]. Our proposal in this paper can be
considered as continuing the top-down approach to the subject 
of inverting mappings, trying to close the gap between
theory and practice based on the huge amount of work on

123

the the classical setting of data exchange. This approach is
complementary to the more integral approaches proposed
in [5,16] of adding expressiveness to database instances and
mappings. We expect that our results on the classical scenario
of data exchange could be useful in the future research on
mappings for databases with incomplete information, on
extensions of the notions of inversion in a symmetric scenario,
 and on the search for the right notion of inversion
together with the right language for expressing inverses that
can be used in the next generation of schema mapping tools.

2 Basic notation

Our study assumes that data are represented in the relational
model. A relational schema, or just schema, is a ﬁnite set
{R1, . . . , Rn} of relation symbols, with each Ri having a
ﬁxed arity ni . As is customary in the data exchange and
schema mapping literature, we consider two types of data
values when constructing database instances: constants and
nulls [11,12,15]. More precisely, let C and N be inﬁnite and
disjoint sets of constants and nulls, respectively. A database
instance (or just instance) I of schema R assigns to each nary
relation symbol R of R a ﬁnite nary relation R I ⊆ (C∪ N)n.
If a tuple ¯a belongs to R I , we say that R(¯a) is a fact in I . We
sometimes describe an instance as a set of facts. If we refer to
a schema S as a source schema, then we restrict all instances
of S to consist only of constant values. On the other hand, we
allow null values in the instances of any target schema T.

Schema mappings and solutions. Schema mappings are
used to deﬁne a semantic relationship between two schemas.
In this paper, we use a general representation of mappings;
given two schemas R1 and R2, a mapping M from R1 to R2
is a set of pairs (I, J ), where I is an instance of R1, and J is
an instance of R2. Further, we say that J is a solution for I
under M, if (I, J ) is in M. We denote by SolM(I ) the set
of all solutions for I under M.

Some of our results are focused on a special class of mappings 
that we call source-to-target mappings (st-mappings).
If we refer to a mapping M from R1 to R2 as an st-mapping,
then we assume that R1 is a source schema (that is, instances
of R1 are constructed using only elements from C), and R2
is a target schema (that is, instances of R2 are constructed by
using elements from C and N).

Composition of mappings. The notion of composition has
shown to be of fundamental importance in the study of the
inverse of a schema mapping [4,11,15]. Let M12 be a mapping 
from a schema R1 to a schema R2, and M23 a mapping
from R2 to a schema R3. Then, the composition of M12 and
M23, denoted by M12 ◦ M23, is deﬁned as the standard
composition of binary relations, that is, as the set of all pairs

Query language-based inverses of schema mappings

827

of instances (I, J ) such that I is an instance of R1, J is an
instance of R3, and there exists an instance K of R2 such that
(I, K ) belongs to M12, and (K , J ) belongs to M23 [14,26].

Query answering. A kary query Q over a schema R, with
k ≥ 0, is a function that maps every instance I of R into
a k-relation Q(I ) ⊆ dom(I )k, where dom(I ) is the set of
elements mentioned in I . Notice that if k = 0 (Q is a Boolean
query), then the answer to Q is either the set with one 0-ary
tuple or the empty set, denoted by true and false, respectively.
We use CQ to denote the class of conjunctive queries and
UCQ to denote the class of unions of conjunctive queries. We
note that we consider that CQ and UCQ are not equipped with
equalities. If we extend these classes by allowing equalities or
inequalities, then we use superscripts = and (cid:3)=, respectively.
Thus, for example, CQ=
is the class of conjunctive queries
with equalities, and UCQ(cid:3)=
is the class of union of conjunctive 
queries with inequalities. FO is the class of all ﬁrst-order
queries with equality. Slightly abusing notation, we use C(·)
to denote a built-in unary predicate such that C(a) holds if
and only if a is a constant, that is, a ∈ C. If L is any of
the previous query languages, then LC is the extension of L
allowing predicate C(·). For example, CQC,(cid:3)=
is the class of
conjunctive queries with inequalities and predicate C(·).

As usual, the semantics of queries in the presence of
schema mappings is deﬁned in terms of the notion of certain 
answer. Assume that M is a mapping from a schema
R1 to a schema R2. Then, given an instance I of R1 and a
query Q over R2, the certain answers of Q for I under M,
denoted by certainM(Q, I ), is the set of tuples that belong to
the evaluation of Q over every possible solution for I under
M, that is,
certainM(Q, I ) = (cid:2){Q(J ) | J ∈ SolM(I )}.
Dependencies and deﬁnability of mappings. Let L1, L2
be query languages and R1, R2 be schemas with no relation
symbols in common. An L1- toL2 
dependency from R1 to
R2 is a formula Φ of the form
∀¯x (ϕ(¯x) → ψ (¯x)),
(1)
where (a) ¯x is the tuple of free variables in both ϕ(¯x) and
ψ (¯x); (b) ϕ(¯x) is an L1-formula over R1 ∪ {C(·)} if C(·)
is allowed in L1, and over R1 otherwise, and (c) ψ (¯x) is
an L2-formula over R2 ∪ {C(·)} if C(·) is allowed in L2,
and over R2 otherwise. We call ϕ(¯x) the premise of Φ, and
ψ (¯x) the conclusion of Φ. We usually omit the outermost
universal quantiﬁer in L1- toL2 
dependencies, and thus,
we write dependency (1) just as ϕ(¯x) → ψ (¯x). Moreover,
for the sake of readability, we usually write α(¯x, ¯y) → ψ (¯x)
instead of (∃¯y α(¯x, ¯y)) → ψ (¯x) in the examples.

A fundamental class of dependencies in the schema
mapping literature is the class of source-to-target tuplegenerating 
dependencies (st-tgds), which corresponds to the
class of CQ- toCQ 
dependencies. Another class that we
extensively use in this paper is the class of CQ(cid:3)=,C- toCQ

dependencies, which are essentially st-tgds in which the premise 
is extended with inequalities and predicate C(·).
Let R1 and R2 be schemas with no relation symbols in
common and Σ a set of L1- to- L2-dependencies from R1
to R2. We say that a mapping M from R1 to R2 is speciﬁed
by Σ, denoted by M = (R1, R2, Σ ), if for every instance I
of R1 and instance J of R2, it holds that (I, J ) ∈ M if and
only if (I, J ) satisﬁes the dependencies in Σ.

Homomorphisms and the chase. Given instances J1 and
J2 of the same schema, a homomorphism h from J1 to J2
is a function that is the identity over constants (h(a) = a
for every a ∈ C), maps null values to null or constant values,
 and for every fact R(a1, . . . , an) in J1, it holds that
R(h(a1), . . . , h(ak )) is a fact in J2. If there exists homomorphisms 
from J1 to J2 and from J2 to J1, then we say that
J1 and J2 are homomorphically equivalent.
Another notion that will be used in this document is the
notion of chase [25]. Assume that M = (S, T, Σ ) is an
st-mapping, where Σ is a set of FO- toCQ 
dependencies.
Let I be an instance of S, and let JI be an instance of T constructed 
as follows. For every σ ∈ Σ of the form ϕ(¯x) →
∃¯y ψ (¯x, ¯y), where ¯x = (x1, . . . , xm ) and ¯y = (y1, . . . , y(cid:8))
are tuples of pairwise distinct variables with no variables in
common, and for every m-tuple ¯a of elements mentioned in
I such that I | ϕ(¯a), do the following. Choose an (cid:8)-tuple ¯n
of pairwise distinct fresh values from N and include all the
conjuncts of ψ (¯a, ¯n) as facts in JI . We call instance JI the
result of chasing I with Σ and write JI = chaseΣ (I ).
The instance chaseΣ (I ) has several desirable properties 
[1,12]. In particular, if M = (S, T, Σ ) is an st-mapping 
with Σ a set of FO- toCQ 
dependencies, then for
every instance I of S, it holds that chaseΣ (I ) ∈ SolM(I ).
Moreover, for every solution J ∈ SolM(I ), it holds that
there exists a homomorphism from chaseΣ (I ) to J [12],
reason for which chaseΣ (I ) is called a canonical universal 
solution for I under M [1,12]. This property of the
chase implies that it can be used to compute certain answers
of unions of conjunctive queries [12]. Formally, for every
instance I of S and query Q in UCQ over T, it holds that
certainM(Q, I ) = Q(chaseΣ (I ))↓, where Q(chaseΣ (I ))↓
denotes the set of tuples obtained from Q(chaseΣ (I )) by
eliminating all the tuples that mention null values.

3 Query language-based inverses of schema mappings
Intuitively, an inverse of a schema mapping M is a reverse
mapping that undoes the application of M. Any natural
notion of inverse should capture the intuition that if M

123

828

M. Arenas et al.

describes how to exchange data from a source to a target
schema, then the inverse of M must describe how to recover
the initial data back in the source (or, at least, part of it).
Moreover, one should impose a soundness requirement; one
would like to recover only sound information, that is, information 
that was already present before the exchange.

A natural question at this point is how one can formally
describe the idea of recovering sound information. In this
paper, we give a formal definition of what it means to recover
sound information with respect to a query language, and
use this notion to deﬁne our query language-based notion
of inverse of a schema mapping. It is important to notice that
a ﬁrst notion of recovering sound information was proposed
in [4], and it was called a recovery of a mapping M. A recovery 
is a reverse mapping that recovers sound information with
respect to a mapping M. Here, we deﬁne a relaxation of this
notion that is parameterized by a query language.

Before formalizing what does it mean to recover sound
information with respect to a query language, let us present
the intuition of this notion with one example.

(3)

(2)

Example 1 Let S be a source schema consisting of binary
relations R(·,·) and S(·,·), T a target schema consisting of a
binary relation T (·,·), and assume that schemas S and T are
related by a mapping M speciﬁed by st-tgd:
R(x, y) ∧ S(y, z) → T (x, z).
Thus, target relation T stores the join of source relations R
and S. Consider now the reverse mapping M(cid:2)
relating T and
S through the dependency:
T (x, y) → ∃u R(x, u).
This dependency states that whenever an element is in the
ﬁrst component of relation T in the target database, it must
also be in the ﬁrst component of relation R in the source
database. Thus, given the definition of mapping M, one can
intuitively conclude that mapping M(cid:2)
recovers sound information 
with respect to M. The previous intuition can be
formalized by considering the composition of M with M(cid:2)
,
which represents the idea of using M(cid:2)
to bring back to the
source the information that was exchanged from the source
by using mapping M. It is important to notice that M ◦ M(cid:2)
is a round-trip mapping from S to S and, therefore, one can
use queries over S to measure the amount of recovered information.
 In particular, one can claim in this example that M(cid:2)
recovers sound information with respect toM since for every
source instance I and query Q over S, if a tuple ¯t belongs to
, then ¯t also
the certain answers of Q for I under M ◦ M(cid:2)
belongs to the evaluation of Q over I .

Let us give an example of the previous discussion with
a concrete scenario. Assume that I is a source database
{R(a, b), R(c, d), S(b, e)}, and Q(x) is the source conjunctive 
query ∃y R(x, y). If we directly evaluate Q over I , we

123

.

obtain the set of answers Q(I ) = {a, c}. On the other hand,
if we evaluate Q over the set of instances obtained by
exchanging data from I through M ◦ M(cid:2)
, then we obtain
the set of answers {a}. To see why {a} is the set of certain
answers in this case, notice that every solution for I under
M contains the tuple T (a, e) and, hence, every solution for I
under M◦M(cid:2)
contains the tuple R(a, u), for some element
u. Thus, the value a belongs to the set of certain answers of
query Q over I under mapping M ◦ M(cid:2)
. Besides, no other
element belongs to this set of certain answers as {R(a, b)} is
a solution for I under M ◦ M(cid:2)
We conclude this example by pointing out that given the
definitions of mappings M and M(cid:2)
, when computing the
certain answers of a query Q over a source instance I under
M ◦ M(cid:2)
, we obtain a subset of the direct evaluation of the
query over I , that is:
certainM◦M(cid:2) (Q, I ) ⊆ Q(I ).
In general, we say that a mapping M(cid:2)

is a Q-recovery of
a mapping M whenever Eq. (4) holds for every source database 
I . For example, for the mappings M and M(cid:2)
deﬁned
by dependencies (2) and (3), respectively, we have that M(cid:2)
is a Q-recovery of M for the query Q(x) = ∃y R(x, y).
Furthermore, it can also be shown that M(cid:2)
is a Q-recovery
of M for every query Q. In fact, this is the reason why we
claim that M(cid:2)
recovers sound information with respect to M
in this case. This intuition gives rise to the following notion
of C-recovery, where C is a class of queries.
Deﬁnition 1 Let C be a class of queries, M a mapping from
schema S to schema T, and M(cid:2)
a mapping from T to S. Then,
is a C-recovery of M if for every query Q ∈ C over S
M(cid:2)
and every instance I of S, it holds that:
certainM◦M(cid:2) (Q, I ) ⊆ Q(I ).

(4)

Notice that in the previous definition we consider a class
C of queries, as in some scenarios one is interested in retrieving 
sound information not for every possible query but for
a class of queries of interest (for instance, for the class of
conjunctive queries).
Being a C-recovery is a sound but mild requirement. Thus,
it is natural to ask whether one can compare mappings according 
to their ability to recover sound information, and then
whether there is a natural way to deﬁne a notion of best possible 
recovery according to a given query language. It turns
out that there is simple and natural way to do this, as we show
in the following example.
Example 2 Let M and M(cid:2)
dencies (2) and (3), respectively, andM(cid:2)(cid:2)
by dependency:
T (x, y) → ∃u (R(x, u) ∧ S(u, y)).

be the mappings given by depena 
mapping speciﬁed

Query language-based inverses of schema mappings

As mentioned in Example 1, M(cid:2)
recovers sound information 
with respect to M as it is a Q-recovery of M for every
query Q. Furthermore, it can be shown that this property also
holds for mapping M(cid:2)(cid:2)
. In order to compare these mappings,
we observe that for every query Q and source instance I ,
mappings M(cid:2)
and M(cid:2)(cid:2)
satisfy the following property:
certainM◦M(cid:2) (Q, I ) ⊆ certainM◦M(cid:2)(cid:2) (Q, I ) ⊆ Q(I ).
For instance, if I = {R(a, b), R(c, d), S(b, e)} and Q(x, y)
is conjunctive query∃z (R(x, z)∧ S(z, y)), then we have that
Q(I ) = {(a, e)} and certainM◦M(cid:2)(cid:2) (Q, I ) = {(a, e)}, while
certainM◦M(cid:2) (Q, I ) = ∅. Thus, every tuple that is retrieved
by posing query Q against the space of solutions for I under
M◦M(cid:2)
is also retrieved by posing this query over the space
of solutions for I under M ◦ M(cid:2)(cid:2)
. Hence, we can claim that
M(cid:2)(cid:2)
recovering sound information with
(cid:16)(cid:17)
respect to M.

is better than M(cid:2)

and M(cid:2)(cid:2)

recovers as much information as M(cid:2)

The above discussion gives rise to a simple way to compare 
two Q-recoveries M(cid:2)
of a mapping M; a
mapping M(cid:2)(cid:2)
does
for M under Q if for every source instance I , it holds
that certainM◦M(cid:2) (Q, I ) ⊆ certainM◦M(cid:2)(cid:2) (Q, I ). With this
way of comparing inverse mappings, it is straightforward to
deﬁne a notion of best possible recovery according to a query
language.
Deﬁnition 2 Let C be a class of queries, M a mapping from
a schema S to a schema T, and M1 a C-recovery of M. Then,
M1 is a C-maximum recovery of M if for every C-recovery
M2 of M, it holds that:
certainM◦M2
for every query Q in C over S and every instance I of S.

(Q, I ) ⊆ certainM◦M1

(Q, I ),

That is, M1 is a C-maximum recovery of a mapping M if
by exchanging data from I throughM◦M1, one can retrieve
by using queries from C as much information as by exchanging 
data from I through M ◦ M2, for any other C-recovery
M2 of M. For instance, for the mappings M and M(cid:2)(cid:2)
mentioned 
in Example 2, it holds that M(cid:2)(cid:2)
is an All-maximum
recovery of M, where All is the class of all queries.

3.1 On the choice of a query language

At this point, a natural question is what is the inﬂuence of
the parameter C on the notion of C-maximum recovery. In the
following sections, we show that this parameter is essential
to obtain a good mapping language for inversion, but ﬁrst we
need to show how different selections of the language C give
rise to essentially different notions of inverse. Let us start
with an example relating the classes UCQ and CQ.

829

(cid:4)

Example 3 Let M be a mapping speciﬁed by st-tgds:
A(x, y) → R(x, y)
B(x) → R(x, x)
It can be shown that mapping M1 speciﬁed by dependency:
R(x, y) → A(x, y) ∨ (cid:3)
B(x) ∧ x = y
(5)
is a UCQ-maximum recovery of M.
Notice that to specify M1, we use a disjunction in the
conclusion of dependency (5), which can be shown to be
unavoidable as UCQ is used to retrieve information. Unfortunately,
 tgds with disjunctions on the conclusion make the
processes of exchanging data and computing certain answers
much more complicated. On the other hand, if we focus
on CQ to retrieve information, then, intuitively, there is no
need for disjunctions in the right-hand side of the rules as
conjunctive queries cannot extract disjunctive information.
In fact, it can be shown that a CQ-maximum recovery of M
is speciﬁed by dependency:
R(x, y) ∧ x (cid:3)= y → A(x, y).
Intuitively, the only conjunctive information that one can
obtain from a target instance is that if R(a, b) is a fact in
the target with a (cid:3)= b, then the fact A(a, b) was a fact in
the initial source instance. Notice that if R(a, a) is in the
target, we cannot assume that this information came either
from relation A(·,·) or B(·). Although in this case one can
safely assume that the initial source instance contained either
the fact A(a, a) or the fact B(a), this information is useless
if we only consider conjunctive queries to extract data.

that

The above example suggests

(2) There exist st-tgd mappings M and M(cid:2)

the notion of
CQ-maximum recovery is a strict generalization of the notion
of UCQ-maximum recovery. The following proposition provides 
a complete picture of the relationship of the notions of
C-maximum recovery, when one focuses on mappings speciﬁed 
by st-tgds and the most common extensions of CQ.
Proposition 1
(1) There exist st-tgd mappings M and M(cid:2)

such that M(cid:2)
is
-maxisuch 
that M(cid:2)
is
-maximum recovery of M but not a UCQ-maxia 
UCQ-maximum recovery of M but not a CQ(cid:3)=
mum recovery of M.
a CQ(cid:3)=
mum recovery of M.
Proposition 1 tells us that the notions of UCQand 
CQ(cid:3)=
-
maximum recovery are incomparable, even in the case of
st-tgds. Moreover, we can also conclude from this proposition 
that if C1 and C2 are any of the classes of queries CQ,
UCQ, CQ(cid:3)=
, and C1 (cid:2) C2, then there exist mappings 
M and M(cid:2)
is a C1-maximum recovery
of M but not a C2-maximum recovery of M.
We now move to the proof of Proposition 1.

or UCQ(cid:3)=

such that M(cid:2)

123

830

M. Arenas et al.

con-

(6)
(7)

:

is not a CQ(cid:3)=

is not a CQ(cid:3)=

, we have that every solution for I under M◦M(cid:2)

Proof of Proposition 1 (1) Consider a source schema S =
{P(·), R(·)}, a target schema T = {T (·,·), S(·)} and a mapping 
M = (S, T, Σ ), where Σ consists of the following
st-tgds:
P(x) → ∃y T (x, y)
R(x) → S(x)
Consider also a mapping M(cid:2) = (T, S, Σ(cid:2)), where Σ(cid:2)
sists of the following dependencies:
T (x, x) ∧ S(y) → P(y)
T (x, y) → P(x) ∧ P(y)
S(x) → R(x)
We ﬁrst show that M(cid:2)
-recovery of M, from
which we conclude that M(cid:2)
-maximum recovery 
of M. Consider instance I = {P(a), R(b)} with a (cid:3)= b.
Notice that every solution for I under mapping M contains
facts S(b) and T (a, u) for some value u. Thus, by definition
of M(cid:2)
contains 
facts P(a), P(u) (dependency (7)) and, if u = a, then
it also contains fact P(b) (dependency (6)). Assume that Q
is the following boolean query in CQ(cid:3)=
∃x∃y (P(x) ∧ P(y) ∧ x (cid:3)= y).
Then, we have that certainM◦M(cid:2) (Q, I ) = true but Q(I ) =
false, from which we conclude that M(cid:2)
-recovery 
of M.
is a UCQ-maximum recovery
of M. Let Q be a mary query in UCQ over S (m ≥
0) and I an instance of S. Next we show that Q(I ) =
certainM◦M(cid:2) (Q, I ), from which we conclude that M(cid:2)
is
a UCQ-maximum recovery of M. Consider the instance
I = {P(a1), . . . , P(ak ), R(b1), . . . , R(b(cid:8))},
where {a1, . . . , ak} and {b1, . . . , b(cid:8)} are not necessarily disjoint 
sets, and let J = chaseΣ (I ). It is easy to see that
J = {T (a1, n1), . . . , T (ak , nk ), S(b1), . . . , S(b(cid:8))},
where n1, . . . , nk is a sequence of pairwise distinct null values.
 Now let K = chaseΣ(cid:2) (J ). It is straightforward to prove
that K is the instance given by the set of facts
{P(a1), P(n1), . . . , P(ak ), P(nk ), R(b1), . . . , R(b(cid:8))}.
Thus, given that Q is a monotone query, we have that
Q(I ) ⊆ Q(K ), and given that Q is a query in UCQ
and there exists a homomorphism h from K to I that
is the identity on the constants, we have that Q(K ) ∩
{a1, . . . , ak , b1, . . . , b(cid:8)}m ⊆ Q(I ). Therefore, we conclude
that Q(I ) = (Q(K ) ∩ {a1, . . . , ak , b1, . . . , b(cid:8)}m ), from
which we obtain that Q(I ) = certainM◦M(cid:2) (Q, I ), given
that the certain answers to Q over I under M ◦ M(cid:2)
can

We now prove that M(cid:2)

is not a CQ(cid:3)=

123

is a CQ(cid:3)=

be obtained by evaluating Q over K and then removing the
tuples containing null values [12,14].
(2) Consider a source schema S = {D(·), E (·), F (·)},
a target schema T = {P(·), R(·)}, and a mapping M =
(S, T, Σ ), where Σ consists of the following st-tgds:
D(x) → P(x)
E (x) → P(x)
F (x) → R(x)
Consider also a mapping M(cid:2) = (T, S, Σ(cid:2)), where Σ(cid:2)
consists 
of dependency R(x) → F (x). We show next that M(cid:2)
is not a UCQ-maximum recovery of M, and we show in
electronic Appendix A.1 that M(cid:2)
-maximum recovery 
of M, from which we conclude that (2) holds.
consists of dependency P(x) → (D(x) ∨ E (x))
Let Σ(cid:2)(cid:2)
andM(cid:2)(cid:2) = (T, S, Σ(cid:2)(cid:2)). From their definitions, one can easily
and M(cid:2)(cid:2)
see that M(cid:2)
are UCQ-recoveries of M. We show
next that M(cid:2)
is not as informative as M(cid:2)(cid:2)
w.r.t. queries in
UCQ, which implies that M(cid:2)
is not a UCQ-maximum recovery 
of M. Consider the instance I = {D(a)} of S, and let Q
be the following boolean query in UCQ over S:
∃x D(x) ∨ ∃y E (y)
Let I∅ be the empty instance of schema S. It is clear by
the definitions of M and M(cid:2)
that I∅ is a possible solution 
for I under the composition M ◦ M(cid:2)
. Thus, we have
that certainM◦M(cid:2) (Q, I ) = false since Q(I∅) = false.
On the other hand, every solution for I under M ◦ M(cid:2)(cid:2)
contains fact D(a) or fact E (a) (as every solution for I
under M contains fact P(a)), from which we conclude
that certainM◦M(cid:2)(cid:2) (Q, I ) = true. Therefore, we have that
certainM◦M(cid:2)(cid:2) (Q, I ) (cid:3)⊆ certainM◦M(cid:2) (Q, I ), which implies
(cid:16)(cid:17)
that M(cid:2)

is not a UCQ-maximum recovery of M.

We have learned in this section, specifically in Example 1,
that by focusing on some particular query languages in the
notion of C-maximum recovery, one can avoid employing
in mapping languages features that are difﬁcult to use in
practice. This observation motivates the search for a class
of queries that gives rise to an inverse notion meeting the
requirements mentioned in the introduction, namely that
every mapping speciﬁed by a set of st-tgds admits an inverse
under this new notion, that this mapping can be expressed in a
language that has the same good properties for data exchange
as st-tgds, and that the language is closed under this notion of
inverse. A natural starting point in this search is the class of
conjunctive queries, as this class is widely used in practice
and, in particular, has been extensively studied in the context 
of data exchange [7,12]. In fact, from the results in [4],
it is straightforward to prove that every mapping speciﬁed
by a set of st-tgds has a CQ-maximum recovery. Hence, it
remains to show that the notion of CQ-maximum recovery
admits a closed mapping language with good properties for

Query language-based inverses of schema mappings

831

data exchange. In Sect. 5, we show that this is indeed the
case. But before going into the details of this result, we show
in Sect. 4 that the general notion of C-maximum recovery is
of independent interest, as it can be used to characterize the
previous notions of inverse for schema mappings proposed
in the literature [4,11,15]. Moreover, in Sect. 4 we also provide 
some theoretical tools that are fundamental to proving
that the notion of CQ-maximum recovery admits a closed
mapping language.

4 C-Maximum recovery as a unifying framework
for inverse operators

During the last few years, several different notions of inverse
have been proposed for schema mappings, among them one
can ﬁnd Fagin-inverse [11], quasi-inverse [15], and maximum 
recovery [4]. The goal of this section is to establish
the relationship between these notions and the concept of
C-maximum recovery. Specifically, we show that the notion
of C-maximum recovery provides a uniﬁed framework for
the seemingly different notions of inverse previously proposed 
in the literature, thus improving the understanding of
the problem of inverting schema mappings. We recall that in
this paper we consider the typical data exchange setting in
which source instances contain only constant values. Thus,
we only compare with the notions of inverses proposed in this
setting [4,11,15] and leave for future research the comparison 
with the notions proposed in the setting in which source
instances can contain incomplete information [5,16].

We begin in Sects. 4.1 and 4.2 by showing that both Fagininverse 
and quasi-inverse can be characterized in terms of the
notion of C-maximum recovery, for some speciﬁc choices of
the query language C. Next, in Sect. 4.3, we formalize the
intuitive idea that maximum recovery should be the best possible 
way to recover information given by any possible query,
and show that, if M(cid:2)
is a maximum recovery of M, then M(cid:2)
is an All-maximum recovery of M, where All is the class
of all queries. Finally, in Sect. 4.4, we show how the concept
of C-maximum recovery can be obtained from the notion of
maximum recovery by taking into consideration the concept
of schema mapping equivalence under a query language,
which has been studied in some contexts such as schema
mapping composition [24] and schema mapping optimization 
[13].

4.1 Fagin-inverse

We start our study by considering the notion of Fagininverse 
[11]. Roughly speaking, Fagin’s definition is based on
the idea that a mapping composed with its inverse should be
equal to the identity schema mapping. To deﬁne this notion,
Fagin ﬁrst deﬁnes an identity mapping IdR as{(I1, I2) | I1, I2

instances of R and I1 ⊆ I2}, which is an appropriate identity
for the mappings speciﬁed by st-tgds [11]. Then given a mapping 
M from a schema S to a schema T, a mapping M(cid:2)
from
T to S is said to be a Fagin-inverse of M if M ◦ M(cid:2) = IdS.
In order to characterize the notion of Fagin-inverse in
terms of the notion of C-maximum recovery, we ﬁrst introduce 
a concept that measures the ability of an inverse mapping 
to recover sound data according to a query language,
we then characterize the notion of Fagin-inverse in terms
of this concept, and we ﬁnally use this characterization to
establish the relationship between Fagin-inverses andC-maximum 
recoveries. More precisely, let M be a mapping from
a schema R1 to a schema R2, M(cid:2)
a mapping from R2 to
R1 and Q a query over R1. Then we say that M(cid:2)
fully
recovers Q for M if for every instance I of R1, it holds
that:
certainM◦M(cid:2) (Q, I ) = Q(I ).
That is, a mapping M(cid:2)
fully recovers a query Q for a mapping 
M if all data extracted by using Q can be recovered
after translating the source information with M and then
back with M(cid:2)
. Moreover, given a class C of queries, we
say that M(cid:2)
fully recovers C for M if for every query
Q ∈ C over R1, it holds that M(cid:2)
fully recovers Q for
M.
The following proposition shows that the Fagin-inverses
of a mapping M speciﬁed by a set of st-tgds exactly corresponds 
with the mappings that fully recover for M every
union of conjunctive queries with inequalities.
Proposition 2 Let M = (S, T, Σ ), where Σ is a set of sttgds,
 and assume thatM is Fagin-invertible. Then a mapping
M(cid:2)
fully recovers
UCQ(cid:3)=
Proof We start by showing the only if direction, that is, if M(cid:2)
is a Fagin-inverse of M, then for every query Q in UCQ(cid:3)=
over S, it holds that M(cid:2)
over S and I an instance of
S. We have to show that certainM◦M(cid:2) (Q, I ) = Q(I ). Given
is a Fagin-inverse ofM, we have that I ⊆ J for every
thatM(cid:2)
J ∈ SolM◦M(cid:2) (I ). Thus, given that Q is a monotone query,
we have that Q(I ) ⊆ Q(J ) for every J ∈ SolM◦M(cid:2) (I ).
It follows that Q(I ) ⊆ certainM◦M(cid:2) (Q, I ) and, thus,
Q(I ) = certainM◦M(cid:2) (Q, I ) since I ∈ SolM◦M(cid:2) (I ).
We show now the if direction, that is, if for every query
Q in UCQ(cid:3)=
over S, it holds that M(cid:2)
fully recovers Q for
M, then M(cid:2)
is a Fagin-inverse of M. By the definition of
Fagin-inverse, the latter hold if M ◦ M(cid:2) = IdS. Thus, to
show that M(cid:2)
is a Fagin-inverse of M, we prove that:
(I, J ) ∈ M ◦ M(cid:2)
. We need to show
that I ⊆ J . To this end, for every R ∈ S of arity k, let Q R

if and only if I ⊆ J.
(⇒) Assume that (I, J ) ∈ M ◦ M(cid:2)

Let Q be a query in UCQ(cid:3)=

is a Fagin-inverse of M if and only if M(cid:2)

for M.

fully recovers Q for M.

123

832

M. Arenas et al.

R(¯xi )
⎛
⎝

(cid:9)

1≤i≤n+1
∧

⎞
⎠

⎤
⎦ ,

¯xi (cid:3)= ¯x j

be the identity query for table R, that is, Q R(x1, . . . xk ) =
R(x1, . . . , xk ). Given that M(cid:2)
fully recovers each of these
queries for M, we have that Q R(I ) = certainM◦M(cid:2) (Q R, I )
for every R ∈ S. Thus, we conclude that for every K ∈
SolM◦M(cid:2) (I ) and R ∈ S, it holds that Q R(I ) ⊆ Q R(K ),
that is, R I ⊆ R K . Hence, we have that I ⊆ J since J ∈
SolM◦M(cid:2) (I ).
(⇐) Assume that I ⊆ J . To prove that (I, J ) ∈ M◦M(cid:2)
,
we ﬁrst show that (J, J ) ∈ M ◦ M(cid:2)
For the sake of contradiction, assume that (J, J ) (cid:3)∈ M ◦
. Then for every relation R ∈ S, deﬁne a Boolean query
M(cid:2)
Q R as follows. Assuming that the arity of R is k and R J
contains n tuples, Q R is the following query in UCQ(cid:3)=
∃¯x1 ···∃¯xn∃¯xn+1

⎛
⎝

⎞
⎠

⎡
⎣

(cid:9)

:

.

1≤i < j≤n+1
(cid:14)
k
(cid:8)=1 ui

(cid:2)

:

Q R.

By the direction (⇒), we know that if (J, J

where ¯u (cid:3)= ¯v stands for the formula
(cid:3)= vi , for
k-tuples ¯u = (u1, . . . , uk ) and ¯v = (v1, . . . , vk ). Thus, Q R
says that relation R contains at least n + 1 tuples. Let Q be
the following query in UCQ(cid:3)=
Q = (cid:15)
R∈S
By the construction of Q, it is clear that Q(J ) = false.
(cid:2)) ∈ M◦M(cid:2)
,
(notice that the proof of direction (⇒) was
then J ⊆ J
done for an arbitrary pair of instances in M◦M(cid:2)
). Thus, we
(cid:2) ∈ SolM◦M(cid:2) (J ), there exists R ∈ S
have that for every J
and J (cid:3)= J
, given that J ⊆ J
(cid:2)
such that R J (cid:2) R J
(since
(cid:2)) = true for every
(J, J ) (cid:3)∈ M◦M(cid:2)
). We conclude that Q(J
(cid:2) ∈ SolM◦M(cid:2) (J ) and, hence, certainM◦M(cid:2) (Q, J ) = true.
J
But this contradicts the fact that M(cid:2)
fully recovers Q for M
since Q(J ) = false and, thus, Q(J ) (cid:3)= certainM◦M(cid:2) (Q, J ).
, we have that there exists an
instance K of T such that (J, K ) ∈ M and (K , J ) ∈ M(cid:2)
.
Thus, given that M is speciﬁed by a set of st-tgds and I ⊆ J ,
we conclude that (I, K ) ∈ M. Hence, given that (K , J ) ∈
M(cid:2)
. This concludes the proof
(cid:16)(cid:17)
of the if direction.

, we have that (I, J ) ∈ M◦M(cid:2)

Given that (J, J ) ∈ M◦M(cid:2)

(cid:2)

(cid:2)

Fagin et al. [16] introduce a notion similar to our notion of
fully recoverable query when studying extended inverses in
a setting in which null values are allowed to appear in source
instances. In [16] the authors prove a weaker form of Proposition 
2 stating that (extended) Fagin-inverses are capable
of fully recovering all the class conjunctive queries (we refer
the reader to Theorem 6.11 in [16] for a precise formulation).
Our result is in a sense stronger as we are able to completely
characterize Fagin-inverses as the mapping that fully recover
the class UCQ(cid:3)=

.

123

is a UCQ(cid:3)=

is a UCQ(cid:3)=

fully recovers UCQ(cid:3)=

We are now ready to state the main theorem of this sec-
-maximum

is a Fagin-inverse of M, then by Proposifor 
M, which
-maximum recovery

tion, that characterizes Fagin-inverses as UCQ(cid:3)=
recoveries.
Theorem 1 Let M = (S, T, Σ ), where Σ is a set of st-tgds,
and assume that M is Fagin-invertible. Then a mapping M(cid:2)
is a Fagin-inverse of M if and only if M(cid:2)
-maximum 
recovery of M.
Proof (⇒) If M(cid:2)
tion 2 we have that M(cid:2)
immediately implies that M(cid:2)
of M.
-maximum recovery of
M. Given that M is Fagin-invertible, there exists a Fagininverse 
M(cid:9) of M. By Proposition 2, we have that M(cid:9)
fully recovers UCQ(cid:3)=
for M. Thus, we have that M(cid:9) is a
UCQ(cid:3)=
-recovery of M and, hence, we conclude, from the
is a UCQ(cid:3)=
fact that M(cid:2)
-maximum recovery of M, that for
every query Q in UCQ(cid:3)=
over S and every instance I of S:
certainM◦M(cid:9) (Q, I ) ⊆ certainM◦M(cid:2) (Q, I ). Therefore, we
deduce that M(cid:2)
for M from the fact
that M(cid:9) fully recovers UCQ(cid:3)=
for M. Hence, considering
again Proposition 2, we deduce that M(cid:2)
is a Fagin-inverse
(cid:16)(cid:17)
of M.

(⇐) Assume that M(cid:2)

fully recovers UCQ(cid:3)=

is a UCQ(cid:3)=

4.2 Quasi-inverse

(cid:2)
2

(cid:2)
1

(cid:2)
1

) such that

(cid:2)
2 and (I

(cid:2)
, I
1
) ∈ M1}

, I2 ∼M I
is a quasi-inverse of M if

We continue our study by considering the notion of quasiinverse 
[15]. The idea behind quasi-inverses is to relax
the notion of Fagin-inverse by not differentiating between
instances that are data-exchange equivalent. Two instances
I1, I2 are data-exchange equivalent w.r.t. a mapping M,
denoted by I1 ∼M I2, if the space of solutions of I1 under
M coincides with the space of solutions of I2 under M, that
is, if SolM(I1) = SolM(I2) [15]. Given a mapping M1
from S to S, mapping M1[∼M,∼M] is deﬁned as [15]:
M1[∼M,∼M] = {(I1, I2) | ∃(I
I1 ∼M I
(cid:2)
, I
2
Then M(cid:2)
(M ◦ M(cid:2))[∼M,∼M] = IdS[∼M,∼M],
where IdS is the same identity mapping used in the definition
of the notion of Fagin-inverse.
It turns out that the notion of quasi-inverse can be characterized 
in terms of the notion of C-maximum recovery, just as
for the case of Fagin-inverse. However, this characterization
is slightly more technical, since now the choice of the query
language C depends on the mapping that is being inverted.
More specifically, given a mapping M speciﬁed by a set of
st-tgds, we deﬁne next a set of unions of conjunctive queries
with inequalities CM that depends on the dependencies that

Query language-based inverses of schema mappings

833

(cid:2)

specify M, and then we show that the quasi-inverses of M
correspond to the CM-maximum recoveries of M.
In order to deﬁne the class of queries CM for a given mapping 
M, we need to recall some concepts regarding query
rewriting. Assume that M is a mapping from a schema S
to a schema T, and that Q is a query over T. We say that
over S is a source rewriting of Q w.r.t. M if
a query Q
(cid:2)(I ) is exactly the set
for every instance I of S, the set Q
of certain answers of Q over I with respect to M, that is,
(cid:2)(I ) = certainM(Q, I ). It is known that if M is speciQ

ﬁed by a set of st-tgds and Q is a conjunctive query over the
target schema, a source rewriting of Q always exists [1,29].
Moreover, it can be shown that in this case a source rewriting 
of Q can be expressed as a union of conjunctive queries
with equality predicates (UCQ=
). As an example, consider
a mapping given by the following st-tgds:
A(x, y) → P(x, y),
B(x) → P(x, x),
and let Q be the target query P(x, y). Then a source rewriting
of Q is given by the query:
A(x, y) ∨ (B(x) ∧ x = y),
which is a query in UCQ=
do need disjunction and the equality x = y.

. Notice that in this rewriting, we
Let M = (S, T, Σ ), where Σ is a set of st-tgds, and

consider the following set of queries over S:

PM = {χ (¯x) | there exists ϕ(¯x ) → ψ (¯x) ∈ Σ
such that χ (¯x) is a source rewriting of ψ (¯x) w.r.t. M}.
Notice that PM is a set of queries in UCQ=
since Σ is a set
of st-tgds. Then deﬁne CM as the set of union of conjunctive 
queries with inequalities obtained by closing PM under
conjunction, disjunction, existential quantiﬁcation, variable
substitution, and the use of inequalities between free variables.

Example 4 Consider again the mapping M given by st-tgds:
A(x, y) → P(x, y),
B(x) → P(x, x).
We have that
PM = {A(x, y) ∨ (B(x) ∧ x = y), A(x, x) ∨ B(x)}
since A(x, y) ∨ (B(x) ∧ x = y) and A(x, x) ∨ B(x) are the
source rewritings of P(x, y) and P(x, x) w.r.t. M, respectively.
 Thus, the following are some of the queries in the set
CM:
A(x, y) ∨ (B(x) ∧ x = y), ∃y A(x, y) ∨ B(x),
A(x, y) ∧ x (cid:3)= y,
∃x A(x, x) ∨ ∃y B(y)

∃x∃y (A(x, y) ∧ x (cid:3)= y),

As our ﬁrst result regarding the notion of quasi-inverse,
we show that the quasi-inverses of a mapping M speciﬁed
by a set of st-tgds exactly corresponds with the mappings
that fully recover CM for M. Notice that this result is the
analogue of Proposition 2.
Proposition 3 Let M = (S, T, Σ ), where Σ is a set of sttgds,
 and assume that M is quasi-invertible. Then a mapping
M(cid:2)
fully recovers
CM for M.

is a quasi-inverse of M if and only if M(cid:2)

The proof of Proposition 3 is given in electronic Appendix
A.2. With this result, we are ready to state the main theorem
of this section, that characterizes the quasi-inverses of a mapping 
M as CM-maximum recoveries.
Theorem 2 Let M = (S, T, Σ ), where Σ is a set of st-tgds,
and assume that M is quasi-invertible. Then a mapping M(cid:2)
is a quasi-inverse of M if and only if M(cid:2)
is a CM-maximum
recovery of M.

The proof of Theorem 2 is given in electronic Appendix

A.3.

4.3 Maximum recovery

We consider now the notion of maximum recovery proposed
in [4]. In that paper, the authors follow a different approach
to deﬁne a notion of inversion. In fact, the main goal of [4]
is not to deﬁne a notion of inverse mapping, but instead to
give a formal definition for what it means for a mapping M(cid:2)
to recover sound information with respect to a mapping M.
Such a mapping M(cid:2)
is called a recovery of M in [4]. In general,
 there may exist many possible recoveries for a given
mapping M. Given that, an order relation on recoveries is
introduced in [4], and then it is shown that this naturally gives
rise to the notion of maximum recovery, which is a mapping
that brings back the maximum amount of sound information.
Let M be a mapping from a schema R1 to a schema R2,
=
and IdR1 the identity schema mapping over R1, that is, IdR1
{(I, I ) | I is an instance of R1}. When trying to invert M,
the ideal would be to ﬁnd a mapping M(cid:2)
from R2 to R1 such
that M◦M(cid:2) = IdR1. Unfortunately, in most cases this ideal
is impossible to reach (for example, for the case of mappings
speciﬁed by st-tgds [11]). If for a mapping M, there is no
mapping M1 such that M ◦ M1 = IdR1, at least one would
like to ﬁnd a schema mapping M2 that does not forbid the
possibility of recovering the initial source data. This gives rise
to the notion of recovery proposed in [4]. Formally, given a
mapping M from a schema R1 to a schema R2, a mapping
from R2 to R1 is a recovery of M if (I, I ) ∈ M ◦ M(cid:2)
M(cid:2)
for every instance I of R1 [4]. In general, if M(cid:2)
is a recovery
of M, then the smaller the space of solutions generated by
M◦M(cid:2)
is about the initial source

, the more informative M(cid:2)

123

834

M. Arenas et al.

[4].

is a maximum recovery of M, then M(cid:2)

instances. This naturally gives rise to the notion of maximum
recovery; given a mapping M and a recovery M(cid:2)
of it, M(cid:2)
is said to be a maximum recovery of M if for every recovery
M(cid:2)(cid:2)

of M, it holds that M ◦ M(cid:2) ⊆ M ◦ M(cid:2)(cid:2)
The following theorem presents our main result for this
section regarding the notion of maximum recovery. Part (1)
of Theorem 3 shows that for every class of queries C, if a
mapping M(cid:2)
is also
a C-maximum recovery of M. Thus, a maximum recovery
is the best possible alternative to retrieve sound information.
In particular, one obtains as a corollary (part (2) of Theorem 
3) that if M(cid:2)
is a maximum recovery of M and a query
Q can be fully recovered for M, then M(cid:2)
also fully recovers
Q for M.
Theorem 3 Let M be a mapping from a schema R1 to a
schema R2, M(cid:2)
a maximum recovery of M and Q an arbitrary 
query over R1.

(1)

(2)

recovers sound information forM under Q, then

IfM(cid:2)(cid:2)
for every instance I of R1:
certainM◦M(cid:2)(cid:2) (Q, I ) ⊆ certainM◦M(cid:2) (Q, I ) ⊆ Q(I ).
If some mapping fully recovers Q for M, then M(cid:2)
recovers Q for M.

fully

If M1 and M2 are C-equivalent, then we know that they
behave in the same way with respect to the queries in C.
Thus, if one is going to retrieve information by using only
queries from C, a mapping M can be replaced by any other
C-equivalent mapping. In particular, it can be replaced by
a mapping that can be handled more efﬁciently, thus optimizing 
the initial schema mapping [13]. In the notion of
C-maximum recovery, this idea of only considering a particular 
query language to retrieve information is also present. The
following result shows that the notions of maximum recovery
and C-maximum recovery can be related through the notion
of C-equivalence [13]. This result will play a central role
when we present our algorithm to compute CQ-maximum
recoveries in Sect. 5.
Proposition 4 Let M be a mapping from a schema R1 to
a schema R2, M(cid:2)
be mappings from R2 to R1, and
assume that M(cid:2)
(1) M(cid:2)(cid:2)

, M(cid:2)(cid:2)
is a maximum recovery of M.

is a C-maximum recovery of M iff (M ◦ M(cid:2)(cid:2)) ≡C
is a C-maximum recovery of

, then M(cid:2)(cid:2)

(M ◦ M(cid:2)).
If M(cid:2)(cid:2) ≡C M(cid:2)
M.

(2)

The proof of this proposition can be found in electronic

Appendix A.5.

The proof of this theorem can be found in electronic Appendix 
A.4. It is important to notice that from the previous theorem 
it is possible to conclude that if M(cid:2)
is a maximum
recovery of M, then M(cid:2)
is an All-maximum recovery of
M. The converse of this last statement does not hold, as it
can be proved that there exist mappings M and M(cid:2)
such
that M(cid:2)
is an All-maximum recovery of M but M(cid:2)
is not a
maximum recovery of M. The example that prove this fact
is very involved and for the sake of the space we skip this
construction here.
4.4 C-maximum recovery, maximum recovery,

and C-equivalence

The idea of parameterizing a notion by a class of queries is
not new in schema mappings management. In fact, this idea
was developed by Madhavan and Halevy [24] to study the
composition operator, and was also used by Fagin et al. [13]
to develop a theory of schema mapping optimization. In particular,
 the authors of these papers considered the notion of
certain-answers equivalence of mappings [13,24]. Let C be
a class of queries. Then two mappings M and M(cid:2)
from
a schema R1 to a schema R2 are C-equivalent, denoted by
, if for every query Q ∈ C over R2 and every
M ≡C M(cid:2)
instance I of R1: certainM(Q, I ) = certainM(cid:2) (Q, I ).

5 A schema mapping language closed under inversion

The main result of this section is that, when we consider
the notion of CQ-maximum recovery as our semantics for
inverting st-mappings, there exists a language that is closed
under inversion, contains the class of st-tgds, and for which
the standard chase procedure can be used to exchange data.
The language corresponds to CQC,(cid:3)=- toCQ 
dependencies
an extension of the st-tgds by allowing formulas in the
premises to contain inequalities and a built-in predicate C(·)
to differentiate constants from null values. The fact that
CQC,(cid:3)=- toCQ 
dependencies contain the class of st-tgds
is obvious, and it is an easy observation that the standard
chase procedure can be used to construct a canonical universal 
solution in the same way as it is done for st-tgds (see e.g.,
[12]). Thus, we devote the rest of the section in showing that
our choice of CQ-maximum recoveries and CQC,(cid:3)=- toCQ

dependencies satisfy the sought-after closure result. More
specifically, we prove that every st-mapping speciﬁed by a set
of CQC,(cid:3)=- toCQ 
dependencies has a CQ-maximum recovery 
also speciﬁed by a set of CQC,(cid:3)=- toCQ 
dependencies
(Theorem 4). Although this language has appeared before in
the literature about inverses of schema mappings [15,17], it
has not been used to study closure properties such as the ones
considered in this paper.

123

Query language-based inverses of schema mappings

835

It should be noticed that our closure result (Theorem 4) is
speciﬁc to the case of st-mappings, that is, mappings that
consider only constant values in source instances. In this
scenario inverses are ts-mappings which are mappings that
transform instances with constant and null values into source
instances that only contain constant values. This has been a
common assumption on the literature on inverting mappings
[4,11,15,17]. As we have mentioned, Fagin et al. [16] have
recently raised the issue of the asymmetry in the study of the
inverse operator, and have proposed to study the inverse operator 
in a symmetric scenario in which both source and target
schemas have constant and null values. We leave the study of
closure properties in this symmetric scenario for future work.

The following Theorem formalizes the closure result.

Theorem 4 Every st-mapping speciﬁed by a set of
CQC,(cid:3)=- toCQ 
dependencies, has a CQ-maximum recovery 
speciﬁed by a set of CQC,(cid:3)=- toCQ 
dependencies.

To prove the theorem, we provide in this section an algorithm 
for computing a CQ-maximum recovery of an st-mapping 
speciﬁed by a set of CQC,(cid:3)=- toCQ 
dependencies (see
Theorem 5), and whose output is a mapping speciﬁed in
the same language. In order to simplify the exposition of
the procedure, for the rest of this section ﬁx a set Σ of
CQC,(cid:3)=- toCQ 
dependencies from a source schema S to
a target schema T, and let M = (S, T, Σ ) be the st-mapping
speciﬁed by Σ that is the input for our algorithm.

5.1 An overview of the algorithm

Our algorithm works as follows. We start by computing a
maximum recovery M(cid:2)
of M by using the algorithm presented 
in [4]. Given that M(cid:2)
is a maximum recovery of M,
we have by Theorem 3 thatM(cid:2)
is also a CQ-maximum recovery 
of M. However, by the results in [4], we know that M(cid:2)
is speciﬁed by a set of CQC,(cid:3)=- to- UCQ=,(cid:3)=
dependencies,
which have features beyond CQC,(cid:3)=- toCQ 
dependencies
such as disjunctions, equalities, and inequalities in the conclusions 
of a rule. Thus, our algorithm performs a series of
transformations on M(cid:2)
to eliminate these features while preserving 
conjunctive-query equivalence. To be more precise,
we ﬁrst use a procedure EliminateEqIneq that eliminates
some equalities and inequalities from M(cid:2)
to produce a mapping 
M(cid:2)(cid:2)
that is also a maximum recovery of M. Then, we
use some graph-theoretical techniques to devise a procedure
EliminateDisjunctions that produces a mappingM(cid:9) from
M(cid:2)(cid:2)
and the dependencies specifying 
M(cid:9) do not include disjunctions in the conclusions. That
is, the output of this last procedure is a set of CQC,(cid:3)=- toCQ

dependencies. By using Proposition 4, we conclude that the
mapping M(cid:9) is also a CQ-maximum recovery of M, thus
obtaining our desired result.

such that M(cid:9) ≡CQ M(cid:2)(cid:2)

5.2 A detailed description of the algorithm

We start with a simple observation. Consider the set Σ
obtained from Σ by dropping all the atoms of the form C(x)
that appear in the premises of the dependencies in Σ. Notice
that, since M is a source-to-target mapping, every instance
in the domain of M is composed only by elements in C. This
implies that the st-mapping speciﬁed by Σ is exactlyM (that
is, if M = (S, T, Σ ), then we have that for every instance I
of S: SolM(I ) = SolM(I )). Thus, in what follows we work
with Σ instead of Σ.

We split the presentation of our algorithm in several subprocedures.


Computing a maximum recovery for Σ
We start by computing a set Σ(cid:2)
that speciﬁes a maximum
recovery of our initial mapping M. For this we use the algorithm 
MaximumRecovery proposed in [4], which works
for mappings speciﬁed by sets of FO- toCQ 
dependencies,
with Σ as input.
Let M be the st-mapping speciﬁed by Σ and M(cid:2) =
(T, S, Σ(cid:2)) the output of the call MaximumRecovery(M).
Given that M is speciﬁed by a set of CQ(cid:3)=- toCQ

dependencies, we have by the definition of algorithm
is a set of CQC- to- UCQ=,(cid:3)=
MaximumRecovery that Σ(cid:2)
dependencies such that every dependency in Σ(cid:2)
is of the form
∃¯y ψ (¯x, ¯y) ∧ C(¯x) → β1(¯x) ∨ ··· ∨ βk (¯x),
where k ≥ 1 and
1. ∃¯y ψ (¯x, ¯y) is a query in CQ which is the conclusion of
some of the dependencies in Σ,
¯x is the tuple of free variables of∃¯y ψ (¯x, ¯y) and of βi (¯x),
2.
for every i ∈ {1, . . . , k},
3. C(¯x) is a conjunction of formulas C(x) for every x in ¯x,

4.

and
every formula βi (¯x) is a query in CQ=,(cid:3)=
– if the inequality z (cid:3)= z
occur in some relational atom of βi (¯x),
– if the equality z = z
(cid:2)

occurs in βi (¯x), then z and z
(cid:2)
occurs in βi (¯x), then z or z

(but
not necessarily both) occur in some relational atom
of βi (¯x).

such that:

(cid:2)

(cid:2)

Moreover, we can assume, without loss of generality, that for
every i ∈ {1, . . . , k}, the equalities occurring in the formula
βi (¯x) are only among free variables (equalities among existentially 
quantiﬁed variables, or among free variables and
existentially quantiﬁed variables, can be eliminated by the
corresponding variable replacements).

In what follows, we show how disjunctions, equalities,
and inequalities can be eliminated from the conclusions of
the dependencies deﬁningM(cid:2)
, in such a way that the obtained
mapping is a CQ-maximum recovery of M.

123

836

M. Arenas et al.

Eliminating equalities and inequalities among free variables
from the conclusions of Σ(cid:2)
In this step, we construct a set Σ(cid:2)(cid:2)
that deﬁnes a maximum 
recovery of M, and such that the dependencies in Σ(cid:2)(cid:2)
have neither equalities among free variables nor inequalities
among free variables in their conclusions. To this end, we
use a notion similar to what is called complete description
in [15]. Let ¯x = (x1, . . . , xn) be a tuple of distinct variables.
Consider a partition π of the set{x1, . . . , xn}, and let[xi]π be
the equivalence class induced by π to which xi belongs (1 ≤
fπ : {x1, . . . , xn} → {x1, . . . , xn} be a funci 
≤ n). Let
tion such that fπ (xi ) = x j if j is the minimum over all the
indexes of the variables in [xi]π . That is, fπ is a function that
selects a unique representative from every equivalence class
induced by π. For example, if ¯x = (x1, x2, x3, x4, x5) and π
is the partition {{x1, x4},{x2, x5},{x3}}, then fπ (x1) = x1,
fπ (x2) = x2, fπ (x3) = x3, fπ (x4) = x1, fπ (x5) = x2. We
also consider the formula δπ that is constructed by taking the
conjunction of the inequalities fπ (xi ) (cid:3)= fπ (x j ) whenever
fπ (xi ) and fπ (x j ) are distinct variables. In the above example 
we have that δπ is the formula x1 (cid:3)= x2 ∧ x1 (cid:3)= x3 ∧ x2 (cid:3)=
x3. Finally, given a conjunction α of equalities and inequalities 
and a conjunction β of inequalities, we say α is consistent
with β if there is an assignment of values to the variables in α
and β that satisﬁes all the equalities and inequalities in these
formulas. For example, x1 = x2 is consistent with x1 (cid:3)= x3,
while x1 = x2 ∧ x2 = x3 is not consistent with x1 (cid:3)= x3.
dependencies
that speciﬁes the mapping M(cid:2)
, which is a maximum recovery 
of M. At this point, we have the necessary ingredients
to describe the procedure that constructs a set Σ(cid:2)(cid:2)
from Σ(cid:2)
such that every inequality in the conclusion of a dependency
in Σ(cid:2)(cid:2)
includes at least one quantiﬁed variable, and the mapping 
speciﬁed by Σ(cid:2)(cid:2)
is also a maximum recovery of M. We
call this procedure EliminateEqIneq. For a tuple ¯x of variables,
 in the procedure we use C(¯x) to denote a conjunction
of formulas C(x) for every x in ¯x.

is a set of CQC- to- UCQ=,(cid:3)=

Recall that Σ(cid:2)

Procedure EliminateEqIneq(Σ(cid:2)

)

1. Let Σ(cid:2)(cid:2)
2. For every dependency σ in Σ(cid:2)

be the empty set.

of the form
∃¯y ψ (¯x, ¯y) ∧ C(¯x) → β1(¯x) ∨ ··· ∨ βk (¯x)
with ¯x = (x1, . . . , xn) a tuple of distinct variables, and
for every partition π of {x1, . . . , xn} do the following:
– Let α(¯x) = β1(¯x) ∨ ··· ∨ βk (¯x) and fπ (¯x) =
– Construct a formula γ from α( fπ (¯x)) as follows. For

( fπ (x1), . . . , fπ (xn))
every i ∈ {1, . . . , k}:

123

– If the conjunction of equalities and inequalities
among free variables in βi ( fπ (¯x)) is consistent
with δπ , then drop the equalities and inequalities
among free variables in βi ( fπ (¯x)) and add the
resulting formula as a disjunct in γ .

– If γ has at least one disjunct, then add to Σ(cid:2)(cid:2)

the

dependency σπ given by formula
∃¯y ψ ( fπ (¯x), ¯y) ∧ C( fπ (¯x)) ∧ δπ → γ .

3. Return Σ(cid:2)(cid:2)

(cid:16)(cid:17)
For example, assume ¯x = (x1, x2, x3) and consider the

following formulas:
∃y ψ (¯x, y) : ∃y (A(x1, x2, y) ∧ B(x3, y))
β1(¯x) : ∃u (P(x1, x2, x3, u) ∧ u (cid:3)= x1) ∧ x2 = x3
β2(¯x) : R(x2, x3) ∧ x1 = x2 ∧ x1 (cid:3)= x3
Moreover, assume that σ ∈ Σ(cid:2)
is the following dependency:
∃y ψ (¯x, y) ∧ C(x1) ∧ C(x2) ∧ C(x3) → β1(¯x) ∨ β2(¯x).
Consider a partition π1 = {{x1, x2},{x3}}. Then we have that
δπ1 is the formula x1 (cid:3)= x3. Notice that the equality x2 = x3
in β1(¯x) becomes x1 = x3 after applying fπ1, which is not
consistent with δπ1. Considering now β2(¯x). In this case, the
formula x1 = x2 ∧ x1 (cid:3)= x3 becomes x1 = x1 ∧ x1 (cid:3)= x3
after applying fπ1, which is consistent with δπ1. Then to construct 
the conclusion of dependency σπ1, we just consider
(¯x))
the formula R(x1, x3), which is obtained from β2( fπ1
by dropping the equalities and inequalities. The premise of
(¯x), y),
σπ1 is constructed as the conjunction of ∃y ψ ( fπ1
(¯x)) and δπ1. That
C( fπ1
is the
is, we have that σπ1
formula
∃y (A(x1, x1, y) ∧ B(x3, y))

∧ C(x1) ∧ C(x3) ∧ x1 (cid:3)= x3 → R(x1, x3),
which is added to Σ(cid:2)(cid:2)
by procedure EliminateEqIneq.
Consider now the partition π2 = {{x1},{x2, x3}}. Since
(x3) = x2, the conjunction of equalities and inequalities
fπ2
(¯x)) is the unsatisﬁable formula x1 = x2∧x1 (cid:3)= x2,
in β2( fπ2
which is not consistent with δπ2. On the other hand, the equal-
(¯x)) are consistent with δπ2.
ities and inequalities of β1( fπ2
Thus, in this case we have that σπ2 is the dependency
∃y (A(x1, x2, y)∧ B(x2, y)) ∧ C(x1) ∧

C(x2)∧ x1(cid:3)= x2→∃u (P(x1, x2, x2, u)∧u(cid:3)= x1),
. If we now consider partition π3 =
and σπ2 is added to Σ(cid:2)(cid:2)
{{x1},{x2},{x3}}, then no dependency is added since neither
(¯x)) is consistent with δπ3.
(¯x)) nor β2( fπ3
β1( fπ3
obtained after the described process 
is a set of CQC,(cid:3)=- to- UCQ(cid:3)=
dependencies, that also
satisﬁes that for every disjunct β(¯x) in the conclusion of a

Notice that the set Σ(cid:2)(cid:2)

Query language-based inverses of schema mappings

837

(cid:2)

(cid:2)

occurring
is existentially quantiﬁed. But
satisﬁes the following key property for

, and for every inequality x (cid:3)= x

dependency in Σ(cid:2)
in β(¯x ), it holds that x or x
more importantly, Σ(cid:2)(cid:2)
our algorithm.
Lemma 1 Let M(cid:2)(cid:2)
returned by EliminateEqIneq(Σ(cid:2)). ThenM(cid:2)(cid:2)
recovery of M.

be the ts-mapping speciﬁed by the set Σ(cid:2)(cid:2)
is a maximum

The proof of Lemma 1 is rather technical and can be found

in electronic Appendix A.6.
We continue now with the description of the procedure to
compute a CQ-maximum recovery ofM. In what follows, we
assume that Σ(cid:2)(cid:2)
as described
above, and that M(cid:2)(cid:2)
is the ts-mapping speciﬁed by Σ(cid:2)(cid:2)
Eliminating the inequalities in the conclusions of Σ(cid:2)(cid:2)

is the set constructed from Σ(cid:2)

.

In this step, we just drop all the remaining inequalities in the
disjunctions of the conclusions of the dependencies of Σ(cid:2)(cid:2)
.
It turns out that, although the obtained set of dependencies
may no longer deﬁne a maximum recovery of M, it does
deﬁne a CQ-maximum recovery of M. In fact, a stronger
result holds, namely that the obtained set of dependencies
deﬁnes a UCQ-maximum recovery of M.
Σ(cid:2)(cid:2)
dependencies in Σ(cid:2)(cid:2)
by Σ(cid:2)(cid:2)(cid:2)
. Then we have that:
Lemma 2 M(cid:2)(cid:2)(cid:2) ≡UCQ M(cid:2)(cid:2)
recovery of M.

From now on, assume that Σ(cid:2)(cid:2)(cid:2)
is the set obtained from
by dropping all the inequalities in the conclusions of the
, and thatM(cid:2)(cid:2)(cid:2)
is the ts-mapping speciﬁed

is a UCQ-maximum

and M(cid:2)(cid:2)(cid:2)

The proof of this lemma can be found in electronic

Before going to the last step of our procedure, it is worth
look. Every element

Appendix A.7.
recalling how the dependencies in Σ(cid:2)(cid:2)(cid:2)
of Σ(cid:2)(cid:2)(cid:2)
ϕ(¯x ) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) ∨ ··· ∨ βk (¯x),
where

is a dependency of the form:

1.
2. ϕ(¯x) and βi (¯x) (1 ≤ i ≤ k) are conjunctive queries with
3. C(¯x) is a conjunction of formulas C(x) for every variable

¯x is a tuple of distinct variables,
¯x as their tuple of free variables,
x in ¯x, and
δ(¯x) is a conjunction of inequalities x (cid:3)= x
pair of distinct variables x, x

(cid:2)

for every

in ¯x.

4.

(cid:2)

In the last step of our algorithm, we eliminate the disjunctions 
from the conclusions of the dependencies of Σ(cid:2)(cid:2)(cid:2)
, to
obtain a set of CQC,(cid:3)=- toCQ 
dependencies that speciﬁes a
CQ-maximum recovery of M.

Eliminating the disjunctions in the conclusions of Σ(cid:2)(cid:2)(cid:2)

We explain ﬁrst the machinery needed in this step of our algorithm.
 We borrow some notions and tools from graph theory,
in particular, properties about graph homomorphisms.

Given two instances J1 and J2 composed by constants
and null values, we deﬁne the product of J1 and J2, denoted
by J1 × J2, as the instance constructed by the following
: (C ∪ N) ×
procedure. Consider an injective function f
(C ∪ N) → (C ∪ N) such that (1)
f (a, a) = a for
every constant value a ∈ C, and (2) f (a, b) = n(a,b) is
a null value, whenever a or b is a null value, or a and b
are distinct constant values. Then for every kary relation
symbol R and every pair of facts R(a1, . . . , ak ) in J1 and
R(b1, . . . , bk ) in J2, the fact R( f (a1, b1), . . . , f (ak , bk )) is
included in the instance J1 × J2. For example, consider the
instances
J1 = {P(a, b), R(n1, a), R(n1, c)},
J2 = {P(a, c), R(n2, a), R(n2, c)},
where a, b, c are distinct constant values, and n1, n2 are distinct 
null values. Then J1 × J2 is the instance
{P(a, m1), R(m2, a), R(m2, c), R(m2, m3), R(m2, m4)},
where m1, m2, m3, m4 are distinct null values. In this case,
f (b, c) = m1,
we have used a function f such that
f (n1, n2) = m2,
f (a, c) = m3 and f (c, a) = m4.
Notice that the product of two instances could be the empty
instance. For example, if we consider J1 = {P(a, b)} and
J2 = {R(a, b)}, then J1 × J2 is the empty instance.
If we consider a schema with a single binary relation
and two instances J1 and J2 composed only by null values,
 the product J1 × J2 corresponds to the graph-theoretical 
Cartesian product [21]. As for graph products, the
operation × between instances satisﬁes several algebraic
properties. One of the most important properties is the
following.

Lemma 3 (c.f. [21]) Let J1, J2 be instances composed by
constant and null values.
(1) There exists a homomorphism from J1 × J2 to J1, and

a homomorphism from J1 × J2 to J2.
If there exists a homomorphism from J to J1 and a
homomorphism from J to J2, then there exists a homomorphism 
from J to J1 × J2.

(2)

The above lemma intuitively states that from the space of
all possible instances, J1 × J2 is the closest instance to both
J1 and J2, taking homomorphisms as our proximity criterion.
 Since the answering process of conjunctive queries can
be characterized in terms of homomorphisms [10], this property 
gives us the following intuition. If a tuple ¯t is an answer

123

838

to a conjunctive query Q over J1 and also over J2, then ¯t
should be an answer to Q over J1 × J2. And, conversely, if ¯t
is an answer of Q over J1 × J2, then it should be an answer
to Q over J1 and over J2. This is one of the key ingredients
for the last step of our algorithm, which is presented in this
section.

The notion of product of instances can also be applied to
conjunctive queries. Let Q1 and Q2 be two nary conjunctive
queries, and assume that ¯x is the tuple of free variables of Q1
and Q2. The product of Q1 and Q2, denoted by Q1 × Q2, is
deﬁned as a kary conjunctive query (with k ≤ n) constructed
as follows. Let f (·,·) be a one-to-one mapping from pairs of
variables to variables such that:

1.
2.

f (x, x) = x for every variable x in ¯x, and
f (y, z) is a fresh variable (mentioned neither in Q1 nor
in Q2) in any other case.

Then for every atoms R(y1, . . . , ym ) in Q1 and R(z1, . . . , zm )
in Q2, the atom R( f (y1, z1), . . . , f (ym , zm )) is included as
a conjunct in the query Q1× Q2. Furthermore, the set of free
variables of Q1 × Q2 is the set of variables from ¯x that are
mentioned in Q1 × Q2. For example, consider conjunctive
queries:
Q1(x1, x2) : P(x1, x2) ∧ R(x2, x1)
Q2(x1, x2) : ∃y (P(x1, y) ∧ R(y, x2)).
Then we have that Q1 × Q2 is the following conjunctive
query (with a single free variable x1):
(Q1 × Q2)(x1) : ∃z1∃z2 (P(x1, z1) ∧ R(z1, z2)).
In this case, we used a mapping f such that f (x1, x1) = x1,
f (x2, y) = z1 and f (x1, x2) = z2. As shown in the example,
 the free variables of Q1× Q2 do not necessarily coincide
with the free variables of Q1 and Q2. Notice that the product 
of two queries may be empty. For example, if Q1 is the
query ∃y1∃y2 P(y1, y2) and Q2 is the query ∃z1 R(z1, z1),
then Q1 × Q2 is empty.
We ﬁnally have all the necessary ingredients to construct
a set of dependencies Σ (cid:9) from Σ(cid:2)(cid:2)(cid:2)
, such that Σ (cid:9) deﬁnes a
CQ-maximum recovery of M and the dependencies in Σ (cid:9)
do not have disjunctions in their conclusions.
Procedure EliminateDisjunctions(Σ(cid:2)(cid:2)(cid:2)

)

1. Let Σ (cid:9) be empty.
2. For every dependency in Σ(cid:2)(cid:2)(cid:2)

of the form

ϕ(¯x) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) ∨ ··· ∨ βk (¯x),

123

M. Arenas et al.

do the following. If β1(¯x) × ··· × βk (¯x) is not empty,
then add to Σ (cid:9) the dependency
ϕ(¯x ) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) × ··· × βk (¯x).

3. Return Σ (cid:9).
For example, assume that Σ(cid:2)(cid:2)(cid:2)
A(x1, x2) ∧ C(x1) ∧ C(x2) ∧ x1 (cid:3)= x2

contains the dependency

→ [R(x1, x2) ∧ R(x1, x1)]
∨[∃y(P(x1, y) ∧ R(x2, x2))].

(cid:16)(cid:17)

(8)

Then we add to Σ (cid:9) the dependency
A(x1, x2) ∧ C(x1) ∧ C(x2) ∧ x1 (cid:3)= x2

→ ∃z(R(z, x2) ∧ R(z, z))

(9)

since ∃z(R(z, x2) ∧ R(z, z)) is the result of
[ R(x1, x2) ∧ R(x1, x1)] × [∃y(P(x1, y) ∧ R(x2, x2))].
Notice that the set Σ (cid:9) obtained as output of the above procedure 
is a set of CQC,(cid:3)=- toCQ 
dependencies. The following
lemma shows the key property of Σ (cid:9).
Lemma 4 Let M(cid:2)(cid:2)(cid:2)
and
M(cid:9) the ts-mapping speciﬁed by Σ (cid:9), where Σ (cid:9) is the set of
CQC,(cid:3)=- toCQ 
dependencies obtained as the result of the
call EliminateDisjunctions(Σ(cid:2)(cid:2)(cid:2)). Then M(cid:9) is CQ-equivalent 
with M(cid:2)(cid:2)(cid:2)

be the ts-mapping speciﬁed by Σ(cid:2)(cid:2)(cid:2)

.

We give some intuition of why this result holds (the complete 
proof of the lemma can be found in electronic Appendix 
A.8). Consider a set Γ1 containing dependency (8), and
a set Γ2 containing dependency (9). One of the main steps
in the proof of the lemma is based on computing the chase
with dependencies containing disjunctions in the conclusions
(like dependency (8)). In particular, if we want to chase an
instance with the set Γ1, we need to consider the disjunctive 
chase [15]. As in the classical (non-disjunctive) chase,
to apply a step of the disjunctive chase we need to select a
particular dependency of the form α → β1 ∨ ··· ∨ βk in the
set, but in this case we also need to select a particular disjunct 
βi in the conclusion of the dependency, and then apply
a standard chase step for dependency α → βi . The result of
the disjunctive chase is the set of all possible instances that
are obtained by considering all possible choices of disjuncts
in the conclusions (we include a detailed definition of the
disjunctive chase in electronic Appendix A.6).
Consider now the instance J = {A(a, b)}, with a, b
distinct constant values. If we consider the disjunctive
chase of instance J with set Γ1, we obtain a set V consisting 
of instances K1 = {R(a, b), R(a, a)} and K2 =
{P(a, n), R(b, b)}, where n is a null value. By the properties
of the disjunctive chase [15], we know that every solution

Query language-based inverses of schema mappings

(cid:2), n

(cid:2)

(cid:2), b), R(n

(cid:2))}, where n

K of J under Γ1 is such that there exists a homomorphism
from K1 to K , or there exists a homomorphism from K2
to K . Thus, when considering the conjunctive information
contained in the space of solutions of J under Γ1, we certainly 
know that the value b appears in the second component 
of relation R, and that some element appears in
a single tuple in both components of R. Notice that the
conjunctive information contained in V is captured by the
instance K1 × K2 = {R(n
is a null
value. If we now chase J with Γ2, we obtain the instance
K = {R(m, b), R(m, m)} with m a null value, which is homomorphically 
equivalent to K1 × K2. From this, it can be
formally proved that for every conjunctive query Q, the certain 
answers of Q under Γ1 coincides with the certain answers
of Q under Γ2.
The strategy in the proof of Lemma 4 is a generalization
of the above argument. Let Σ(cid:2)(cid:2)(cid:2)
and Σ (cid:9) be the sets of dependencies 
in the statement of the lemma and J an arbitrary
is a set of CQC,(cid:3)=- toUCQ

source instance. Recall that Σ(cid:2)(cid:2)(cid:2)
dependencies, thus the result of the (disjunctive) chase of
is a set of instances V = {K1, . . . , K(cid:8)}. Now
J with Σ(cid:2)(cid:2)(cid:2)
let K be the result of chasing J with Σ (cid:9). The key ingredient 
in the proof of Lemma 4 is the fact that K and
K1 × ··· × K(cid:8) are homomorphically equivalent. From this
and the properties of the product of instances, it can be
shown that for every conjunctive query Q the certain answers
of Q under Σ (cid:9) coincide with the certain answers of Q
under Σ(cid:2)(cid:2)(cid:2)

.

Putting it all together

The following is the complete algorithm that uses all the previous 
procedures to compute CQ-maximum recoveries of
st-mappings speciﬁed by CQC,(cid:3)=- toCQ 
dependencies.
Algorithm CQ- MaximumRecovery(M)
Input: An st-mapping M = (S, T, Σ ), where Σ is a set of
CQC,(cid:3)=- toCQ 
dependencies.
Output: A ts-mapping M(cid:9) = (T, S, Σ (cid:9)), where Σ (cid:9) is a set
of CQC,(cid:3)=- toCQ 
dependencies such that M(cid:9) is a CQ-maximum 
recovery of M.

1. Let Σ be the set of dependencies obtained from Σ by
dropping all the atoms of the form C(x) that appear in
the premises of Σ, and let M = (S, T, Σ ).
2. Let M(cid:2) = (T, S, Σ(cid:2)) be the ts-mapping obtained as the
output of algorithm MaximumRecovery(M) [4].
3. Let Σ(cid:2)(cid:2)
of EliminateEqIneq(Σ(cid:2)).
4. Let Σ(cid:2)(cid:2)(cid:2)

be the set of dependencies obtained as the output
be the set obtained from Σ(cid:2)(cid:2)

by dropping all the
inequalities that appear in the conclusions of the dependencies 
in Σ(cid:2)(cid:2)
of EliminateDisjunctions(Σ(cid:2)(cid:2)(cid:2)).

5. Let Σ (cid:9) be the set of dependencies obtained as the output

.

839
(cid:16)(cid:17)
6. Return M(cid:9) = (T, S, Σ (cid:9)).
Theorem 5 Let M be an st-mapping speciﬁed by a set of
CQC,(cid:3)=- toCQ 
dependencies. Then algorithm CQ- Maxi-
mumRecovery(M) computes a CQ-maximum recovery of
M speciﬁed by set of CQC,(cid:3)=- toCQ 
dependencies.
Proof From Lemma 1, we have that the mapping M(cid:2)(cid:2)
speciﬁed 
by the set of CQC,(cid:3)=- to- UCQ(cid:3)=
dependencies Σ(cid:2)(cid:2)
(computed 
in step 3) is a maximum recovery of M. Moreover, we
know from Lemmas 2 and 4 that the mapping M(cid:9) speciﬁed
by the set of CQC,(cid:3)=- toCQ 
dependencies Σ (cid:9) (computed
in step 5) is CQ-equivalent to M(cid:2)(cid:2)
. Thus, we conclude from
Proposition 4 (2) that M(cid:9) is a CQ-maximum recovery of M,
(cid:16)(cid:17)
from which the theorem follows.

We conclude this section by pointing out that the closure
property stated in Theorem 4 follows directly from Theorem 
5.

6 Optimality of the closure result

The closure result presented in the previous section depends
on both the mapping language and the class C used in the
notion of C-maximum recovery. Thus, a natural question
is whether this result could be strengthened by considering 
other alternatives for these parameters. In Sects. 6.1 and
6.2, we prove several negative results in this respect. These
results show that our choice of CQ-maximum recovery as
the semantics for inversion and CQC,(cid:3)=- toCQ 
as the mapping 
language is, in a technical sense, optimal for obtaining
a mapping language closed under inversion.
6.1 CQC,(cid:3)=- toCQ 
is the right language

Most of the dependencies considered in the data exchange
literature [4,11,12,15] are L1- toL2 
dependencies, where
L1 and L2 are fragments of UCQC,(cid:3)=
. In this section, we
show that among all of them, CQC,(cid:3)=- toCQ 
is the right
language for the notion of CQ-maximum recovery; if one
adds or removes features from this class of dependencies,
then closure under CQ-maximum recovery no longer holds.
We start by showing that both inequalities and predicate
C(·) are necessary for the closure property in Theorem 4.
Theorem 6

(1) There exists an st-mapping speciﬁed by a set of st-tgds
that has no CQ-maximum recovery speciﬁed by a set of
CQC- toCQ 
dependencies.

(2) There exists an st-mapping speciﬁed by a set of st-tgds
that has no CQ-maximum recovery speciﬁed by a set of
CQ(cid:3)=- toCQ 
dependencies.

123

840

M. Arenas et al.

Proof We show here mappings that satisfy conditions (1)
and (2), and give some intuition on why they satisfy these
properties. The complete proof of the theorem can be found
in Appendix A.9.

(1) Consider a mapping M speciﬁed by st-tgds:

A(x, y) → P(x, y),
B(x, x) → P(x, x).
Intuitively, in this case the only conjunctive information that
one can recover are the tuples coming from A whose elements
are distinct, as a fact of the form P(a, a) can be generated
by any of the two rules deﬁning the mapping. To specify this
we need inequalities. In fact, a CQ-maximum recovery for
M is the mapping speciﬁed by:
P(x, y) ∧ x (cid:3)= y → A(x, y).
In Appendix A.9, it is proved that M does not have a CQmaximum 
recovery speciﬁed by a set of CQC- toCQ 
dependencies.


(2) Consider a mapping M speciﬁed by st-tgds:

A(x) → ∃y P(y),
B(x) → P(x).
Intuitively, predicate C(·) is needed in a CQ-maximum recovery 
ofM to discriminate whether a value comes from relation
B in the source. In fact, a CQ-maximum recovery for M is
the mapping speciﬁed by:
P(x) ∧ C(x) → B(x).
In Appendix A.9, it is proved that M does not have a
CQ-maximum recovery speciﬁed by a set of CQ(cid:3)=- toCQ

(cid:16)(cid:17)
dependencies.
We have shown that both inequalities and predicate C(·)
are necessary for the closure property of Theorem 4. A
natural question at this point is whether a similar closure
property can be obtained if one adds some extra features to
CQC,(cid:3)=- toCQ.
 For example, it could be the case that the
language of CQC,(cid:3)=- to- CQ(cid:3)=
dependencies is closed under
CQ-maximum recovery. Unfortunately, the following proposition 
shows that if one includes disjunctions or inequalities
in the conclusions, then mappings do not necessarily admit
CQ-maximum recoveries, even if these features are added to
st-tgds.

set of CQ- toUCQ 
dependencies:
B(x) ∧ C1(x) → R1(x),
B(x) ∧ C2(x) → R2(x),
A(x) → R1(x) ∨ R2(x).
This mapping has as CQ-recoveries a mapping M1 speciﬁed
by R1(x) → C1(x)∧ B(x), and a mapping M2 speciﬁed by
R2(x) → C2(x) ∧ B(x). Given that neither M1 is better
than M2 nor M2 is better than M1 as a CQ-recovery of
M, one could try to ﬁnd a mapping M3 which is better
than both by considering the two dependencies R1(x) →
C1(x) ∧ B(x), R2(x) → C2(x) ∧ B(x) together. Although
it seems that M3 is more informative than both M1 and
M2, the problem is that M3 is not a CQ-recovery of M. To
see why this is the case, notice that for the source instance
I = {A(a)}, we have that B(a) belongs to every possible
solution for I under M ◦ M3. Thus, for the conjunctive
query Q given by ∃x B(x), we have that Q(I ) = false but
(Q, I ) = true, which shows that M3 does not
certainM◦M3
recover sound information according to Q. In fact, this is
a general phenomenon, as it can be proved that there is no
mapping which is a CQ-recovery of M and is better than
any other mapping in terms of its ability to recover sound
information for M according to the language of conjunctive
queries. Therefore, one concludes that M does not have a
CQ-maximum recovery.
Now for the case (2), consider an st-mappings given by
the following CQ- to- CQ(cid:3)=
B(x) ∧ C1(x) → R(x, x),
B(x) ∧ C2(x) → ∃y(R(x, y) ∧ x (cid:3)= y),
A(x) → ∃y R(x, y).
In this case one can provide a similar argument as in (1). Consider,
 for example, a mapping M1 speciﬁed by dependency
R(x, x) → C1(x) ∧ B(x), and a mapping M2 speciﬁed by
dependency R(x, y) ∧ x (cid:3)= y → C2(x) ∧ B(x). Both are
CQ-recoveries of M, but neither is better than the other. If
one tries to improve these mappings by considering a mapping 
M3 deﬁned by both dependencies R(x, x) → B(x) ∧
C1(x), R(x, y)∧ x (cid:3)= y → B(x)∧ C2(x) together, then one
can show that the resulting mapping is not a CQ-recovery
of M. To see why this is the case, just consider the source
(cid:16)(cid:17)
instance {A(1)} and the query ∃x B(x) as in case (1).

dependencies:

6.2 CQ-maximum recovery is the right notion

Proposition 5 There exist st-mappings speciﬁed by sets of
(1) CQ- toUCQ 
dependencies, (2) CQ- to- CQ(cid:3)=
dependencies,
 that have no CQ-maximum recoveries.

Proof We just present a sketch of the proof (the complete
proof can be found in electronic Appendix A.10). For the
case (1), we use an st-mapping M speciﬁed by the following

In this section, we consider several alternatives to CQ for the
semantics of inverse operators, and show that none of them
is appropriate to obtain a closure property as in Theorem 4.
We start with the notion of UCQ-maximum recovery. The
following result shows that to express the UCQ-maximum
recovery of a mapping given by a set of st-tgds, one needs

123

Query language-based inverses of schema mappings

841

dependencies with disjunctions in their conclusions even if
the full power of FO is allowed in the premises of the dependencies.

Proposition 6 There exists an st-mapping M speciﬁed by a
set of st-tgds such that:
(a) M has a UCQ-maximum recovery speciﬁed by a set of
(b) M does not have a UCQ-maximum recovery speciﬁed

CQ- toUCQ 
dependencies.

by a set of FOC- toCQ 
dependencies.

Proof Consider a source schema S = {A(·), B(·)}, a target
schema T = {T (·)}, and the st-mapping M = (S, T, Σ ),
where Σ consists of the following st-tgds:
A(x) → T (x),
B(x) → T (x).
Let M(cid:9) = (T, S, Σ (cid:9)) be a ts-mapping speciﬁed by the
CQ- toUCQ 
dependency
T (x) → A(x) ∨ B(x).
By using the tools developed in [4], it is straightforward to
show that M(cid:9) is a maximum recovery of M, which implies
that M(cid:9) is a UCQ-maximum recovery of M. In order to
prove that the disjunction in (10) is essential to obtain a UCQmaximum 
recovery ofM, we show that every mapping speciﬁed 
by a set of tgds without disjunctions in the conclusions
is strictly less informative than M(cid:9), even if one allows the
full power of FO in the premises of dependencies. The formalization 
of this argument can be found in Appendix A.11(cid:16)(cid:17)

(10)

Proposition 5 shows that there exist mappings speciﬁed
by CQ- toUCQ 
dependencies that have no CQ-maximum
recoveries and, hence, have no UCQ-maximum recoveries.
Thus, Propositions 5 and 6 show that if we use UCQ-maximum 
recovery as our notion of inverse, then we are doomed
to failure.

Now we consider the notion of CQ(cid:3)=

-maximum recovery.
By Theorem 6, we have that inequalities in the premises of
dependencies are needed to express CQ-maximum recoveries
of mappings given by st-tgds. Thus, if a mapping language
contains the class of st-tgds and is closed under CQ(cid:3)=
-maximum 
recovery, then it has to include inequalities in the
premises of dependencies. Our next result shows that in order
to express the CQ(cid:3)=
-maximum recovery of a mapping given
by a set of CQ(cid:3)=- toCQ 
dependencies, one needs to use
inequalities in the conclusions, even if the full power of FO
is allowed in the premises of the dependencies.
Proposition 7 There exists an st-mapping M speciﬁed by a
set of CQ(cid:3)=- toCQ 
dependencies such that:

(a) M has a CQ(cid:3)=
CQ- to- CQ(cid:3)=
(b) M does not have a CQ(cid:3)=

-maximum recovery speciﬁed by a set of
dependencies.

-maximum recovery speciﬁed

by a set of FOC- toCQ 
dependencies.

dependency:

Proof Consider a source schema S = {P(·,·)}, a target
schema T = {T (·)}, and the st-mapping M = (S, T, Σ ),
where Σ consists of the following CQ(cid:3)=- toCQ 
depen-
dency:
P(x, y) ∧ x (cid:3)= y → T (x).
Let M(cid:9) = (T, S, Σ (cid:9)) be a ts-mapping speciﬁed by the
CQ- to- CQ(cid:3)=
T (x) → ∃y (P(x, y) ∧ x (cid:3)= y).
By using the tools developed in [4], it is straightforward to
prove that M(cid:9) is a maximum recovery of M, which implies
thatM(cid:9) is a CQ(cid:3)=
-maximum recovery ofM. Moreover, it can
be shown, as in the proof of Proposition 6, that the inequality
in the conclusion of (11) is essential to obtain a CQ(cid:3)=
-maximum 
recovery of M, as every mapping speciﬁed by a set
of tgds without inequalities in the conclusions is strictly less
informative than M(cid:9) (even if the full power of FO is allowed
in the premises). The formalization of this argument can be
(cid:16)(cid:17)
found in Appendix A.12.

(11)

Proposition 5 shows that there exist mappings speciﬁed
by CQ- to- CQ(cid:3)=
dependencies that have no CQ-maximum
recoveries and, hence, have no CQ(cid:3)=
-maximum recoveries.
Thus, Propositions 5 and 7 show that if we use CQ(cid:3)=
-maximum 
recovery as our notion of inverse, then we cannot hope
for a closure result as in Theorem 4.
We conclude this section by pointing out that the negative 
results for UCQand 
CQ(cid:3)=
-maximum recoveries imply
a negative result for the notion of C-maximum recovery, for
every class C of queries containing UCQ or CQ(cid:3)=
. In particular,
 these results, together with the results in Sect. 6.1, show
that our choices of the notion CQ-maximum recovery as the
semantics for inversion and of CQC,(cid:3)=- toCQ 
as the language 
for deﬁning mappings are optimal to obtain a closure
result for inverting schema mappings, which is a fundamental
property toward the applicability of inversion in practice.

7 Concluding remarks

In this paper, we have revisited the problem of inverting
schema mappings paying special attention to the practical
limitations of the previous approaches. We proposed a general 
query language-based notion of inverse, the C-maximum
recovery with C a query language. By ﬁne-tuning the language 
C, we show that the notion of CQ-maximum recovery 
satisﬁes our main requirements. In particular, we proved

123

842

that every st-mapping speciﬁed by a set of CQC,(cid:3)=- toCQ

dependencies has a CQ-maximum recovery that can be speciﬁed 
in the same language. Interestingly, the language of
CQC,(cid:3)=- toCQ 
dependencies has several good properties,
being one of the most important the fact that the chase procedure 
can be used to exchange data with these dependencies
efﬁciently (in data complexity), ensuring its practical applicability 
in data exchange and integration. Our results show
that our choices of CQ-maximum recovery as the notion
of inverse, and CQC,(cid:3)=- toCQ 
dependencies as the mapping 
speciﬁcation language, are promising options toward the
practical implementation of inversion of schema mappings.
Fagin et al. have been argued that when studying inverses
of schema mappings in the data exchange context, incomplete
information naturally arise in source instances [16]. We have
made the assumption that source instances contain only constant 
values, thus, an important line of future work is how to
extend our results on closure properties and query languagebase 
notion of inverse to the setting in which incomplete
information is allowed in the source. Another interesting
issue is the integration between inversion and composition of
schema mappings. Closure properties for composition have
been obtained in the literature [6,14], but the languages used
do not coincide with our proposed language for closure of
inversion. Thus, a very important and also challenging topic
for future research is to ﬁnd a mapping language that is closed
under both operation.

Acknowledgments We thank the anonymous reviewers for their careful 
reading and for providing many useful comments. Arenas was supported 
by Fondecyt grant 1090565, Pérez by Fondecyt grant 11110404
and by VID grant U-Inicia 11/04 Universidad de Chile, and Reutter by
EPSRC grant G049165 and FET-Open project FoX.

References

1. Arenas, M., Barceló, P., Fagin, R., Libkin, L.: Locally consistent
transformations and query answering in data exchange. In: PODS,
pp. 229–240 (2004)

2. Arenas, M., Pérez, J., Reutter, J.L., Riveros, C.: Composition
and inversion of schema mappings. SIGMOD Rec. 38(3), 17–28
(2009)

3. Arenas, M., Pérez, J., Reutter, J.L., Riveros, C.:

Inverting
schema mappings: bridging the gap between theory and practice.
 PVLDB 2(1), 1018–1029 (2009)

4. Arenas, M., Pérez, J., Riveros, C.: The recovery of a schema map-
ping: bringing exchanged data back. TODS 34(4), 22:1–22:48
(2009)

5. Arenas, M., Pérez, J., Reutter, J.L.: Data exchange beyond complete 
data. In: PODS, pp. 83–94 (2011)

M. Arenas et al.

6. Arocena, P., Fuxman, A., Miller, R.J.: Composing local-as-view
mappings: closure and applications. In: ICDT, pp. 209–218 (2010)
7. Barceló, P.: Logical foundations of relational data exchange. SIGMOD 
Rec. 38(1), 49–58 (2009)

8. Bernstein, P.: Applying model management to classical meta data

problems. In: CIDR (2003)

9. Bernstein, P., Melnik, S.: Model management 2.0: manipulating

richer mappings. In: SIGMOD, pp. 1–12 (2007)

10. Chandra, A.K., Merlin, P.M.: Optimal implementation of conjunctive 
queries in relational data bases. In: STOC, pp. 77–90
(1977)

11. Fagin, R.: Inverting schema mappings. TODS 32(4), 25:1–25:53

(2007)

12. Fagin, R., Kolaitis, P.G., Miller, R.J., Popa, L.: Data exchange:

semantics and query answering. TCS 336(1), 89–124 (2005)

13. Fagin, R., Kolaitis, P.G., Nash, A., Popa, L.: Towards a theory of

schema-mapping optimization. In: PODS, pp. 33–42 (2008)

14. Fagin, R., Kolaitis, P.G., Popa, L., Tan, W.C.: Composing 
schema mappings: second-order dependencies to the rescue.
 TODS 30(4), 994–1055 (2005)

15. Fagin, R., Kolaitis, P.G., Popa, L., Tan, W.C.: Quasi-inverses of

schema mappings. TODS 33(2), 11:1–11:52 (2008)

16. Fagin, R., Kolaitis, P.G., Popa, L., Tan, W.C.: Reverse
data exchange: coping with nulls. ACM Trans. Database
Syst. 36(2), 11 (2011)

17. Fagin, R., Nash, A.: The structure of inverses in schema mappings.
 J. ACM 57(6), 31 (2010)

18. Fuxman, A., Kolaitis, P.G., Miller, R.J., Tan, W.C.: Peer data

exchange. In: PODS, pp. 160–171 (2005)

19. de Giacomo, G., Lembo, D., Lenzerini, M., Rosati, R.: On reconciling 
data exchange, data integration, and peer data management.
In: PODS, pp. 133–142 (2007)

20. Halevy, A.Y., Ives, Z., Madhavan, J., Mork, P., Suciu, D., Tatarinov,
I.: The piazza peer data management system. IEEE Trans. Knowl.
Data Eng. 16(7), 787–798 (2004)

21. Hell, P., Ne˘set˘ril, J.: Graphs and Homomorphisms. Oxford University 
Press, USA (2004)

22. Kolaitis, P.G.: Schema mappings, data exchange, and metadata

management. In: PODS, pp. 61–75 (2005)

23. Lenzerini, M.: Data integration: a theoretical perspective. In:

PODS, pp. 233–246 (2002)

24. Madhavan, J., Halevy, A.Y.: Composing mappings among data

sources. In: VLDB, pp. 572–583 (2003)

25. Maier, D., Mendelzon, A., Sagiv, Y.: Testing implications of data

dependencies. TODS 4(4), 455–469 (1979)

26. Melnik, S.: Generic Model Management: concepts and Algorithms.
Lecture Notes in Computer Science, vol. 2967. Springer, Berlin
(2004)

27. Melnik, S., Adya, A., Bernstein, P.A.: Compiling mappings to
bridge applications and databases. ACM Trans. Database Syst.
33(4), (2008)

28. Melnik, S., Bernstein, P.A., Halevy, A.Y., Rahm, E.: Supporting
executable mappings in model management. In: SIGMOD, pp.
167–178 (2005)
ten Cate, B., Kolaitis, P.G.: Structural characterizations of schemamapping 
languages. In: ICDT, pp. 63–72 (2009)

29.

123

