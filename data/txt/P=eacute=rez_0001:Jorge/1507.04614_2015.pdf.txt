5
1
0
2

 
l
u
J
 

9
1

 
 
]

B
D
.
s
c
[
 
 

2
v
4
1
6
4
0

.

7
0
5
1
:
v
i
X
r
a

LDQL: A Query Language for the Web of Linked Data

(Extended Version)⋆

Olaf Hartig1 and Jorge P´erez2

1 http://olafhartig.de/

2 Department of Computer Science, Universidad de Chile

jperez@dcc.uchile.cl

Abstract The Web of Linked Data is composed of tons of RDF documents interlinked 
to each other forming a huge repository of distributed semantic data.
Effectively querying this distributed data source is an important open problem
in the Semantic Web area. In this paper, we propose LDQL, a declarative language 
to query Linked Data on the Web. One of the novelties of LDQL is that
it expresses separately (i) patterns that describe the expected query result, and
(ii) Web navigation paths that select the data sources to be used for computing
the result. We present a formal syntax and semantics, prove equivalence rules,
and study the expressiveness of the language. In particular, we show that LDQL
is strictly more expressive than the query formalisms that have been proposed
previously for Linked Data on the Web. The high expressiveness allows LDQL
to deﬁne queries for which a complete execution is not computationally feasible
over the Web. We formally study this issue and provide a syntactic sufﬁcient condition 
to avoid this problem; queries satisfying this condition are ensured to have
a procedure to be effectively evaluated over the Web of Linked Data.

1 Introduction
In recent years an increasing amount of structured data has been published and interlinked 
on the World Wide Web (WWW) in adherence to the Linked Data principles [3].
These principles are based on standard Web technologies. In particular, (i) the Hypertext
Transfer Protocol (HTTP) is used to access data, (ii) HTTP-based Uniform Resource
Identiﬁers (URIs) are used as identiﬁers for entities described in the data, and (iii) the
Resource Description Framework (RDF) is used as data model. Then, any HTTP URI
in an RDF triple presents a data link that enables software clients to retrieve more data
by looking up the URI with an HTTP request. The adoption of these principles has lead
to the creation of a globally distributed dataspace: the Web of Linked Data.

The emergence of the Web of Linked Data makes possible an online execution of
declarative queries over up-to-date data from a virtually unbounded set of data sources,
each of which is readily accessible without any need for implementing source-specific
APIs or wrappers. This possibility has spawned research interest in approaches to query
Linked Data on the WWW as if it was a single (distributed) database. For an overview
on query execution techniques proposed in this context refer to [12].

The main contribution of this paper is the proposal of LDQL, a novel query language 
for the Web of Linked Data. The most important feature of LDQL is that it
clearly separates query components for selecting query-relevant regions of the Web of
Linked Data, from components for specifying the query result that has to be constructed
from the data in the selected regions. The most basic construction in LDQL are tuples
of the form hL, Qi where L is an expression used to select a set of relevant documents,
and Q is a query intended to be executed over the data in these documents as if they

⋆ This document is an extended version of a paper published in ISWC 2015 [13].

were a single RDF repository. In an abstract setting one can use several formalisms to
express L and Q. In our proposal, for the former part we introduce the notion of link
path expressions that are a form of nested regular expressions (with some other important 
features) used to navigate the link graph of the Web. For the latter, we use standard
SPARQL graph patterns. To begin evaluating these queries one needs to specify a set of
seed URIs. The language also possesses features to dynamically (at query time) identify
new seed URIs to evaluate portions of a query. Additionally, such queries can be combined 
by using conjunctions, disjunctions, and projection. We present a formal syntax
and semantics for LDQL, propose some rewrite rules, and study its expressive power.

While there does not exist a standard language for expressing queries over Linked
Data on the WWW, a few options have been proposed. In particular, a ﬁrst strand of research 
focuses on extending the scope of SPARQL such that an evaluation of SPARQL
queries over Linked Data has a well-deﬁned semantics [9,11,14,18]. A second strand
of research focuses on navigational languages [7,14]. Although these languages have
different motivations, a commonality of all these proposals is that, in contrast to LDQL,
the deﬁnition of query-relevant regions of the Web of Linked Data and the deﬁnition of
query-relevant data within the speciﬁed regions are mixed.

As our second main contribution we compare LDQL with three previously proposed 
formalisms for querying the Web of Linked Data: SPARQL under reachabilitybased 
query semantics [11], NautiLOD [7], and SPARQL Property Path patterns under
context-based semantics [14]. We formally prove that LDQL is strictly more expressive
than every one of these. We show that for every query Q in the previous languages, one
can effectively construct an LDQL query which is equivalent to Q. Moreover, for every
one of the previous languages, there exists an LDQL query that cannot be expressed in
that language. These results show that LDQL presents an interesting expressive power.
The downside of the expressiveness provided by LDQL is the existence of queries
for which a complete execution is not feasible in practice. To capture this issue formally,
we deﬁne a notion of Web-safeness for LDQL queries. Then, the obvious question that
arises is how to identify LDQL queries that are Web-safe. Our last technical contribution
is the identiﬁcation of a sufﬁcient syntactic condition for Web-safeness.

The rest of the paper is structured as follows. Section 2 introduces a data model
that provides the basis for deﬁning the semantics of LDQL. In Section 3 we formally
deﬁne the syntax and semantics of LDQL and show some simple algebraic properties.
In Section 4 we compare LDQL with the three mentioned languages, and in Section 5
we focus on Web-safeness. Section 6 concludes the paper and sketches future work.
Proofs of the formal results in this paper can be found in the Appendix.

A preliminary version of some of the results in this paper have been presented in a
workshop [10]. This paper is a substantial extension of [10] reﬁning the deﬁnition of
LDQL and introducing important changes to the syntax and the semantics of the language.
 Moreover, the comparison with previous proposals was not discussed in [10].

2 Data Model
In this section we introduce a structural data model that captures the concept of a Web
of Linked Data formally. As usual [7,9,11,14,18], for the deﬁnitions and analysis in this
paper, we assume that the Web is ﬁxed during the execution of any single query.

We use the RDF data model [5] as a basis for our model of a Web of Linked Data.
That is, we assume three pairwise disjoint, inﬁnite sets U (URIs), B (blank nodes), and
L (literals). An RDF triple is a tuple hs, p, oi ∈ T with T = (U ∪ B) × U × (U ∪ B ∪ L).
For any RDF triple t = hs, p, oi we write uris(t) to denote the set of all URIs in t.

Additionally, we assume another inﬁnite set D that is disjoint from U, B, and L,
respectively. We refer to elements in this set as documents and use them to represent the
concept of Web documents from which Linked Data can be extracted. Hence, we assume 
a function, say data, that maps each document d ∈ D to a ﬁnite set of RDF triples
data(d) ⊆ T such that the data of each document uses a unique set of blank nodes.

Given these preliminaries, we are ready to deﬁne a Web of Linked Data.

Deﬁnition 1. A Web of Linked Data is a tuple W = hD, adoci that consists of a set
of documents D ⊆ D and a partial function adoc : U → D that is surjective.

Function adoc of a Web of Linked Data W = hD, adoci captures the relationship
between the URIs that can be looked up in this Web and the documents that can be
retrieved by such lookups. Since not every URI can be looked up, the function is partial.
 For any URI u ∈ U with u ∈ dom(adoc) (i.e., any URI that can be looked up
in W ), document d = adoc(u) can be considered the authoritative source of data for u
in W (hence, the name adoc). To accommodate for documents that are authoritative
for multiple URIs, we do not require injectivity for function adoc. However, we require
surjectivity because we conceive documents as irrelevant for a Web of Linked Data if
they cannot be retrieved by any URI lookup in this Web.

Let W = hD, adoci be a Web of Linked Data. W is said to be ﬁnite [11] if its set D
of documents is ﬁnite. In this paper we assume that every Web of Linked Data is ﬁnite.
Given documents d, d′ ∈ D and a triple t ∈ data(d), we say that a URI u ∈ uris(t)
establishes a data link from d to d′, if adoc(u) = d′. As a ﬁnal concept, we formalize
the notion of a link graph associated to W. This graph has documents in D as nodes,
and directed edges representing data links between documents. Each edge is associated
with a label that identiﬁes both the particular RDF triple and the URI in this triple that
establishes the corresponding data link. These labels shall provide the basis for deﬁning
the navigational component of our query language.

Deﬁnition 2. The link graph of a Web of Linked Data W = hD, adoci, is a directed,
edge-labeled multigraph, GW = hD, EW i, with set of edges EW ⊆ D×(T ×U)×D deﬁned 
as EW = (cid:8)hdsrc, (t, u), dtgti | t ∈ data(dsrc), u ∈ uris(t) and dtgt = adoc(u)(cid:9).

For a link graph edge e = hdsrc, (t, u), dtgti, tuple (t, u) is the label of e. Moreover,

we sometimes write e ∈ GW to denote that e is an edge in the link graph GW .

Example 1. As a running example for this paper assume a simple Web of Linked Data
Wex = hDex, adocexi with three documents, dA, dB, and dC (i.e., Dex = {dA, dB, dC}).
The data in these documents are the following sets of RDF triples:

data(dA) = {huA, p1, uBi,
huB, p2, uCi};

data(dB) = {huB, p1, uCi};
data(dC) = {huA, p2, uCi};

Figure 1. The link graph GWex of our example Web of Linked Data Wex.

and for function adocex we have: adocex(uA) = dA, adocex(uB) = dB, adocex(uC) = dC,
and adocex(p1) = dA (i.e., dom(adocex) = {uA, uB, uC, p1}). This Web contains 10
data links. For instance, URI uA in the RDF triple huA, p2, uCi ∈ data(dC) establishes
a data link to document dA. Hence, the corresponding edge in the link graph of Wex is

(cid:10)dC, (huA, p2, uCi, uA), dA(cid:11). Figure 1 illustrates the link graph GWex with all 10 edges.
3 Deﬁnition of LDQL
This section deﬁnes our Linked Data query language, LDQL. LDQL queries are meant
to be evaluated over a Web of Linked Data and each such query is built from two types
of components: Link path expressions (LPEs) for selecting query-relevant documents of
the queried Web of Linked Data; and SPARQL graph patterns for specifying the query
result that has to be constructed from the data in the selected documents. For this paper,
we assume that the reader is familiar with the deﬁnition of SPARQL [8], including the
algebraic formalization introduced in [16,2]. In particular, for SPARQL graph patterns
we closely follow the formalization in [2] considering operators AND, OPT, UNION, FILTER,
and GRAPH, plus the operator BIND deﬁned in [8]. We begin this section by introducing
the most basic concept of our language, the notion of link patterns. We use link patterns
as the basis for navigating the link graph of a Web of Linked Data.

3.1 Link Patterns

A link pattern is a tuple in(cid:0)U ∪{ , +}(cid:1)×(cid:0)U ∪{ , +}(cid:1)×(cid:0)U ∪L∪{ , +}(cid:1). Link patterns 
are used to match link graph edges in the context of a designated context URI. The
despecial 
symbol + denotes a placeholder for the context URI. The special symbol
notes a wildcard that will drive the direction of the navigation. Before formalizing how
link graph edges actually match link patterns, we show some intuition. Consider the
link graph of Web Wex in Example 1 (see Fig. 1), and the link pattern h+, p1,
i. Intuitively,
 in the context of URI uA, the edge with label (huA, p1, uBi, uB) from document
i. Notice that in the matching,
dA to document dB, matches the link pattern h+, p1,
the context URI uA takes the place of symbol +, and uB takes the place of the wildcard
. Notice that uB also denotes the direction of the edge that matches the link
symbol
pattern. On the other hand, the edge with label (huA, p1, uBi, uA) from dA to dA, does
, the
not match h+, p1,
direction of the edge is not to uB. That is, when matching an edge labeled by (t, u) we
require URI u to be taking the place of a wildcard in the link pattern. When more than
one wildcard symbol is used, the link pattern can be matched by edges pointing to the

i; although uB can take the place of the wildcard symbol

direction of any of the URIs taking the place of a wildcard. For instance, in the context
of uA, the link pattern h
i is matched by edges hdA, (huB, p2, uCi, uB), dBi and
hdA, (huB, p2, uCi, uC), dCi. The next deﬁnition formalizes this notion of matching.

, p2,

Deﬁnition 3. A link graph edge with label (hx1, x2, x3i, u) matches a link pattern
hy1, y2, y3i in the context of a URI uctx if the following two properties hold:

1. there exists i ∈ {1, 2, 3} such that yi = and xi = u, and
2. for every i ∈ {1, 2, 3} either yi = + and xi = uctx, or yi = xi, or yi = .

One of the rationales for adopting the notion of a context URI and the + symbol
in our deﬁnition of link patterns, is to support cases in which link graph navigation
has to be focused solely on data links that are authoritative. A data link represented
by link graph edge hdsrc, (t, u), dtgti ∈ GW is authoritative in a Web of Linked Data
W = hD, adoci if dsrc = adoc(u′) for some URI u′ ∈ uris(t). Thus, if we ﬁx a context
URI uctx, a link pattern that uses the + symbol allows us to follow only authoritative
data links from document dctx = adoc(uctx).

3.2 LDQL Queries

The most basic construction in LDQL queries are tuples of the from hL, P i where L
is an expression used to select a set of documents from the Web of Linked Data, and
P is a SPARQL graph pattern to query these documents as if they were a single RDF
dataset. In an abstract setting, one can use any formalism to specify L as long as L
deﬁnes sets of RDF documents. In our proposal we use what we call link path expressions 
(LPEs) that are a form of nested regular expressions [17] over the alphabet of link
patterns. Every link path expression begins its navigation in a context URI, traverses
the Web, and returns a set of URIs; these URIs are used to construct an RDF dataset
with all the documents to be retrieved by looking up the URIs. This dataset is passed
to the SPARQL graph pattern to obtain the ﬁnal evaluation of the whole query. Besides
the basic constructions of the form hL, P i, in LDQL one can also use AND, UNION and
projection, to combine them. We also introduce an operator SEED that is used to dynamically 
change, at query time, the seed URI from which the navigation begins. The next
deﬁnition formalizes the syntax of LDQL queries and LPEs.

Deﬁnition 4. The syntax of LDQL is given by the following production rules in which
lp is an arbitrary link pattern, ?v is a variable, P is a SPARQL graph pattern (as per [2]),
V is a ﬁnite set of variables, and U is a ﬁnite set of URIs:

q := hlpe, P i | (SEED U q) | (SEED ?v q) | (q AND q) | (q UNION q) | πV q

lpe := ε | lp | lpe/lpe | lpe|lpe | lpe ∗ | [lpe] | h?v, qi

Any expression that satisﬁes the production q is an LDQL query, any expression that
satisﬁes the production lpe is a link path expression (LPE), and any LDQL query of
the form hlpe, P i is a basic LDQL query.

Before going into the formal semantics of LDQL and LPEs, we give some more
intuition about how these expressions are evaluated in a Web of Linked Data W. As
mentioned before, the most basic expression in LDQL is of the form hlpe, P i. To evaluate 
this expression over W we will need a set S of seed URIs. When evaluating hlpe, P i,
every one of the seed URIs in S will trigger a navigation of link graph GW via the link
path expression lpe starting on that seed. That is, the seed URIs are passed to lpe as
context URIs in which the LPE should be evaluated. These evaluations of lpe will result
in a set of URIs that are used to construct a dataset over which P is ﬁnally evaluated.

Regarding the navigation of link graph GW, the most basic form of navigation is to
follow a single link graph edge that matches a link pattern lp. When a navigation via
a link pattern lp is triggered from a context URI u, we proceed as follows. We ﬁrst
go to the authoritative document for u, that is adoc(u), and try to ﬁnd outgoing link
graph edges that match lp in the context of u (as explained in Section 3.1). Every one
of these matches deﬁnes a new context URI u′ from which the navigation can continue.
More complex forms of navigation are obtained by combining link patterns via classical 
regular expression operators such as concatenation /, disjunction |, and recursive
concatenation (·)∗. The nesting operator [·] is used to test for existence of paths. When
a context URI u is passed to an expression [lpe], it checks whether GW contains a path
from dctx = adoc(u) that matches lpe. If such a path exists, the navigation can continue 
from the same context URI u. The most involved form of navigation is by using
the expression h?v, qi with q an LDQL query. To evaluate this expression from context
URI u one ﬁrst has to pass u as a seed URI for q and recursively evaluate q from that
seed. This evaluation generates a set of solution mappings, and for every one of these
mappings its value on variable ?v is used as the new context URI from which the navigation 
continues. Finally, note that our notion of LPEs does not provide an operator for
navigating paths in their inverse direction. The reason for omitting such an operator is
that traversing arbitrary data links backwards is impossible on the WWW.

To formally deﬁne the semantics of LDQL we need to introduce some terminology.
We ﬁrst deﬁne a function datasetW (·) that from a set of URIs constructs an RDF
dataset with all the documents pointed to by those URIs in W. Formally, given a Web of
Linked Data W = hD, adoci and a set U of URIs, datasetW (U ) is an RDF dataset (as
per [8,2]) that has the set of triples {t ∈ data(adoc(u)) | u ∈ U ∩ dom(adoc)} as
default graph. Moreover, for every URI u ∈ U ∩ dom(adoc), datasetW (U ) contains
the named graph hu, data(adoc(u))i.

Example 2. Consider the Web Wex in Example 1 and the set of URIs U = {uA, uC}.
Then datasetWex(U ) has {huA, p1, uBi, huB, p2, uCi, huA, p2, uCi} as default graph, and
two named graphs, huA, {huA, p1, uBi, huB, p2, uCi}i and huC, {huA, p2, uCi}i.

In the formalization of the semantics of LDQL, we use the standard join operator ⋊⋉
over sets of solution mappings [8,16]. We also make use of the semantics of SPARQL
graph patterns over datasets as deﬁned in [2]. In particular, given an RDF dataset D, an
RDF graph G in D, and a SPARQL graph pattern P , we denote by [[P ]]D
G the evaluation
of P over G in D [2, Deﬁnition 13.3].

We are now ready to formally deﬁne the semantics of LDQL and LPEs. Given a Web
of Linked Data W and a set S of URIs, we formalize the evaluation of LDQL queries

over W from the seed URIs S, as a function [[·]]S
W that given an LDQL query, produces
a set of solution mappings. Similarly, the evaluation of LPEs over W from a context
URI u, is formalized as a function [[·]]u

W that given an LPE, produces a set of URIs.

Deﬁnition 5. Given a ﬁnite set S ⊆ U, the S-based evaluation of LDQL queries over a
W , is deﬁned recursively as follows:
Web of Linked Data W = hD, adoci, denoted by [[·]]S

W = [[P ]]D
W = [[q]]U
W ,

G where D = datasetW (cid:0)Su∈S[[lpe]]u

W(cid:1) with default graph G,

⋊⋉ {µu}(cid:1) where µu = {?v 7→ u} for all u ∈ U,

[[hlpe, P i]]S
[[(SEED U q)]]S
[[(SEED ?v q)]]S
[[(q1 UNION q2)]]S
[[(q1 AND q2)]]S
[[ πV q ]]S

W = Su∈U(cid:0)[[q]]{u}

W

W ∪ [[q2]]S
⋊⋉ [[q2]]S

W = [[q1]]S
W = [[q1]]S
W = {µ | there exists µ′ ∈ [[q]]S

W ,
W ,

W

W such that µ and µ′ are
compatible and dom(µ) = dom(µ′) ∩ V }.

Now for the semantics of LPEs, given a context URI uctx ∈ dom(adoc), the uctx-based
evaluation of LPEs over W, denoted by [[·]]uctx

W , is deﬁned recursively as follows:

[[ ε ]]uctx
[[lp]]uctx

W = {uctx},
W = {u ∈ U | there exist a link graph edge hdsrc, (t, u), dtgti ∈ GW , with
dsrc = adoc(uctx), that matches lp in the context of uctx},

[[lpe 1/lpe 2]]uctx
[[lpe 1|lpe 2]]uctx
[[lpe ∗]]uctx
[[ [lpe] ]]uctx
[[ h?v, qi ]]uctx

W ∪ [[lpe 2]]uctx
W ,

W | u′ ∈ [[lpe 1]]uctx

W = {u ∈ [[lpe 2]]u′
W = [[lpe 1]]uctx
W = {uctx} ∪ [[lpe]]uctx
W = {uctx | [[lpe]]uctx
W = {u ∈ U | there exists µ ∈ [[q]]{uctx}

W ∪ [[lpe/lpe]]uctx

W 6= ∅},

W },

W

W ∪ [[lpe/lpe/lpe]]uctx

W ∪ ... ,

such that µ(?v) = u}.

Moreover, if uctx /∈ dom(adoc), then [[lpe]]uctx

W = ∅ for every LPE.

, p1,

Example 3. Let lpe ex be the LPE h
i]. This LPE selects documents 
that can be reached via arbitrarily long paths of data links with predicate p1
and, additionally, have some outgoing data link with predicate p2. For our example
Web Wex and context URI uA, the LPE selects documents dA = adocex(uA) and
dC = adocex(uC). More precisely, we have [[lpe ex]]uA
= {uA, uC}. Note that docuWex

ment dB can also be reached via a p1–path, but it does not pass the p2–related test.

i∗/[h

, p2,

Example 4. Consider a set of URIs Sex = {uA} and a basic LDQL query hlpe ex, Bexi
whose LPE is lpe ex as introduced in Example 3 and whose SPARQL graph pattern is a
basic graph pattern that contains two triple patterns, Bex = {h?x, p1, ?yi, h?x, p2, ?zi}.
= {uA, uC} (cf. Example 3), datasetWex([[lpe ex]]uA
Given that we have [[lpe ex]]uA
)
Wex
Wex
has the default graph {huA, p1, uBi, huB, p2, uCi, huA, p2, uCi} (cf. Example 2). Then,
according to the query semantics, the result of query hlpe ex, Bexi over Wex using seeds
Sex consists of a single solution mapping, namely µ = {?x 7→ uA, ?y 7→ uB, ?z 7→ uC}.

Example 5. Consider an LDQL query qex = (cid:0)SEED ?x (cid:10)ε, h?x, p1, ?wi(cid:11)(cid:1) whose subquery 
is a basic LDQL query that has a single triple pattern as its SPARQL graph
pattern. Additionally, let q′
ex = (cid:10)lpe ex, {h?x, p1, ?yi, h?x, p2, ?zi}(cid:11) be the basic LDQL
query introduced in Example 4, and let q′′
ex be the conjunction of these two queries; i.e.,
q′′
ex = (qex AND q′
= {µ} with µ = {?x 7→ uA,
?y 7→ uB, ?z 7→ uC}. Furthermore, based on the data given in Example 1, it is easy to
see that [[qex]]Sex
= {µ1, µ2} with µ1 = {?x 7→ uA, ?w 7→ uB} and µ2 = {?x 7→ uB,
Wex
?w 7→ uC}. For the Sex-based evaluation of q′′
and
[[q′
have to be joined. Thus, we need to compute {µ1, µ2} ⋊⋉ {µ}, which results in
a single mapping µ′ = µ1 ∪ µ = {?x 7→ uA, ?w 7→ uC, ?y 7→ uB, ?z 7→ uC}.

ex over Wex, the result sets [[qex]]Sex
Wex

ex]]Sex
Wex

ex). By Example 4 we know that [[q′

ex]]Sex
Wex

3.3 Algebraic Properties of LDQL Queries

As a basis for the discussion in the next sections, we show some simple algebraic properties.
 We say that LDQL queries q and q′ are semantically equivalent, denoted by q ≡ q′,
if [[q]]S

W holds for every Web of Linked Data W and every ﬁnite set S ⊆ U.

W = [[q′]]S

Lemma 1. The operators AND and UNION are associative and commutative.

Lemma 2. Let q1, q2, q3 be LDQL queries, the following semantic equivalences hold:

(q1 AND (q2 UNION q3)) ≡ ((q1 AND q2) UNION (q1 AND q3))

πV (q1 UNION q2) ≡ (πV q1 UNION πV q2)

(SEED U (q1 UNION q2)) ≡ ((SEED U q1) UNION (SEED U q2))
(SEED ?v (q1 UNION q2)) ≡ ((SEED ?v q1) UNION (SEED ?v q2))

(1)
(2)
(3)
(4)

Lemma 1 allows us to write sequences of either AND or UNION without parentheses.
Our next result shows the power of the construction h?v, qi. In particular, it shows the
somehow surprising ﬁnding that link patterns lp, concatenation /, disjunction |, and the
test [·], are just syntactic sugar as they can be simulated by using ε, h?v, qi and (·)∗.

Proposition 1. For every LDQL query q, there exists an LDQL query q′ s.t. q ≡ q′ and
every LPE in q′ consists only of the symbol ε, the construction h?v, qi, and operator (·)∗.

Proof (Sketch). The proof is based on a recursive translation of link path expressions
beginning with link patterns. For instance, a link pattern of the form h+, p,
i is encoded 
by h?v, hε, (GRAPH ?u (?u, p, ?v))ii, and we can similarly encode all types of link
patterns. To encode / we make use of h?v, qi and the operator AND inside q as follows.
Consider an LPE r = r1/r2. It can be shown that r is equivalent to h?v, qi where q is:

(cid:0) hr1, (GRAPH ?x { })i AND (cid:0)SEED ?x hr2, (GRAPH ?v { })i(cid:1) (cid:1).

Similarly, to encode | we make use of UNION and to encode [·] we use projection.

Although not strictly necessary, we decided to keep link patterns and operators /, |,
and [·] since they represent a natural and intuitive way of expressing navigation paths.

4 Comparison with Previous Linked Data Query Formalisms
In this section, we compare LDQL with alternative formalisms to query Linked Data on
the WWW. There are some general query languages for the WWW (proposed before
the advent of Linked Data) that are related to our proposal; in particular, WebSQL [15],
which is similar in spirit to LDQL but different in the features that the languages posses.
Two main novelties of LDQL compared with WebSQL are the possibility to dynamically 
select seed URIs at query time, and the traversal of links according to properties
of the queried documents that can be deﬁned in the same LDQL query. Neither of these
are expressible in WebSQL. While a complete formal comparison between LDQL and
WebSQL is certainly very interesting, we leave it for future work and, instead, focus on
three more recent proposals of query formalisms for the Web of Linked Data [7,11,14].
We formally show that LDQL is strictly more expressive than every one of them.
4.1 Comparison with Property Paths under Context-Based Query Semantics
Property paths (PPs for short) were introduced in SPARQL 1.1 as a way of adding
navigational power to the language [8]. PPs are a form of regular expressions that are
evaluated over a single (local) RDF graph; a PP expression is used to retrieve pairs ha, bi
of nodes in the graph such that there is a path from a to b whose sequence of edge labels
belongs (as a string) to the regular language deﬁned by the expression. The syntax of
PP expressions is given by the following grammar3, where p, u1, u2, ... , uk are URIs.

pe := p | !(u1|u2| · · · |uk) | pe/pe | pe|pe | pe∗

A PP-pattern is deﬁned as a tuple of the form hα, pe, βi where pe is a PP expression,
and α and β are in U ∪ L ∪ V.

In [14] the authors adapted the semantics of PP-patterns so that they can be used
to query the Web of Linked Data. The proposed query semantics is called contextbased 
semantics [14]. To deﬁne this semantics, the authors ﬁrst introduce the notion
of a context selector for a Web of Linked Data W. This context selector is a function
CW(·) that given a URI u ∈ dom(adoc) returns the RDF triples in data(adoc(u))
that have u in the subject position. Formally, for every URI u ∈ dom(adoc) we have
CW(u) = {hs, p, oi ∈ data(adoc(u)) | s = u}. To simplify the exposition, the authors
extended the deﬁnition of CW(·) to also handle URIs not in dom(adoc), and literals
and blank nodes. For any such RDF term a they deﬁne CW(a) as the empty set.

The context-based semantics for PPs over the Web of Linked Data in [14] is a bag
semantics that follows closely the semantics for PPs deﬁned in the normative semantics
of SPARQL 1.1 [8]. Hence, both semantics use a procedure, the ArbitraryLengthPath
procedure [8], to deﬁne the semantics of the (·)∗ operator. It was shown in [1] that for
sets semantics, the normative semantics of PPs can be deﬁned by using standard techniques 
for regular expressions. To make the comparison with LDQL, in this paper we
adapt the context-based semantics for PPs presented in [14] by following the techniques
in [1], and consider only sets of mappings. To this end, we deﬁne a function [[·]]ctxt
W , that
given a PP-pattern, returns its evaluation under context-based semantics over the Web
of Linked Data W. In the deﬁnition, for a solution mapping µ and an RDF term α, we

3 In [14] the reverse path construction ˆpe is also considered. We do not consider it here as the

form of navigation of these reverse paths does not represent a traversal of the link graph.

use the notation µ[α] with the following meaning: µ[α] = µ(α) if α ∈ dom(µ), and
µ[α] = α in the other case. Similarly, µ[hs, p, oi] = hµ[s], µ[p], µ[o]i.

[[(α, p, β)]]ctxt
[[(α, !(u1| · · · |uk), β)]]ctxt

W = {µ | dom(µ) = {α, β} ∩ V and µ[hα, p, βi] ∈ CW (µ[α])}
W = {µ | dom(µ) = {α, β} ∩ V and exists p s.t.

µ[hα, p, βi] ∈ CW (µ[α]) and p /∈ {u1, ... , uk}}

[[(α, pe1/pe2, β)]]ctxt
[[(α, pe1|pe2, β)]]ctxt
[[(α, pe∗, β)]]ctxt

W = π{α,β}∩V(cid:0)[[(α, pe1, ?v)]]ctxt
W = [[(α, pe1, β)]]ctxt
W = {µ | dom(µ) = {α, β} ∩ V, µ[α] = µ[β] and µ[α] ∈ terms(W )}∪
W ∪ · · ·

W ⋊⋉ [[(?v, pe2, β)]]ctxt
W (cid:1)

W ∪ [[(α, pe/pe/pe, β)]]ctxt

W ∪ [[(α, pe2, β)]]ctxt

W

[[(α, pe, β)]]ctxt

W ∪ [[(α, pe/pe, β)]]ctxt

A PP-based SPARQL query [14] is an expression formed by combining PP-patterns
using the standard SPARQL operators AND, UNION, OPT, FILTER and so on, following the
standard semantics for these operators [2]. Our next results show that LDQL is strictly
more expressive than PP-based SPARQL queries under context-based semantics.

Theorem 1. There exists an LDQL query that cannot be expressed as a PP-based
SPARQL query under context-based semantics.

Proof (Sketch). One can show that LDQL query q =(cid:0)SEED U (cid:10)h+, p,

with U = {u} cannot be expressed by PPs under context-based semantics because
this semantics is “blind” to triples that are not authoritative. For instance, in a Web
W = h{d, d′}, adoci with data(d) = {hu, p, u′i}, data(d′) = {hu′, p, ui, hu, u, ui},
adoc(u) = d and adoc(u′) = d′, the evaluation of q is the solution mapping {?x 7→ u}.
Notice that the only authoritative triple in d′ is hu′, p, ui as d′ = adoc(u′) 6= adoc(u).
Hence, one can prove that PP-based SPARQL queries under context-based semantics
cannot access triple hu, u, ui in d′, and thus, will never have {?x 7→ u} as solution.

i, (?x, ?x, ?x)(cid:11)(cid:1)

Theorem 2. Let α, β ∈ U ∪ L ∪ V. Then, for every PP-pattern hα, pe, βi, there exists
an LDQL query q such that [[hα, pe, βi]]ctxt

W for every Web of Linked Data W.

W = [[q]]∅

Proof (Sketch). In the proof we provide a translation scheme from PPs to LDQL. One
major complication is that PPs can retrieve literals and, in general, values that are not in
dom(adoc), which are difﬁcult to handle by LPEs. For every PP-pattern h?x, pe, ?yi we
construct an LDQL query Qpe(?x, ?y). For example, for h?x, pe1/pe2, ?yi, our query is
π{?x,?y}(cid:0)Qpe1(?x, ?z) AND Qpe2 (?z, ?y)(cid:1), and for h?x, !(u1| · · · |uk), ?yi the translation
is (cid:0)SEED ?x (cid:10)ε,(cid:0)(?x, ?p, ?y) FILTER (?p 6= u1 ∧ · · · ∧ ?p 6= uk)(cid:1)(cid:11)(cid:1). To handle pe∗ we

need to use the construction h?v, qi of LPEs, plus (·)∗.

4.2 Comparison with NautiLOD
NautiLOD is a navigation language to traverse Linked Data on the WWW and to perform 
actions (such as sending emails) during the traversal [7]. We compare LDQL with
NautiLOD without action rules. The syntax of NautiLOD expressions (without actions)
is given by the following grammar (where p ∈ U and P is a SPARQL graph pattern).

ne := p | pˆ | h

i | ne/ne | ne|ne | ne∗ | ne[(ASK P )]

In terms of our data model4, the semantics of NautiLOD expressions over a Web of
Linked Data W = hD, adoci from URI u ∈ dom(adoc) is deﬁned recursively as follows.

[[ h

[[ p ]]u
[[ pˆ ]]u
i ]]u
[[ ne1/ne2 ]]u
[[ ne1| ne2 ]]u
[[ ne∗ ]]u
[[ ne[(ASK P )] ]]u

W = {u′ | hu, p, u′i ∈ data(adoc(u))}
W = {u′ | hu′, p, ui ∈ data(adoc(u))}
W = {u′ | hu, p, u′i ∈ data(adoc(u)) for some p ∈ U}
W = {u′′ | u′′ ∈ [[ ne2 ]]u′
W = [[ ne1 ]]u
W ∪ [[ ne2 ]]u
W = {u} ∪ [[ ne ]]u
W = {u′ | u′ ∈ [[ ne ]]u

W for some u′ ∈ [[ ne1 ]]u

W ∪ [[ ne/ne/ne ]]u

W ∪ [[ ne/ne ]]u

W with u′ ∈ dom(adoc)}

W

W , u′ ∈ dom(adoc) and [[P ]]data(adoc(u′)) 6= ∅}

W ∪ · · ·

We next show that for every NautiLOD expression there exists an equivalent LDQL
query. Notice that the evaluation of a NautiLOD expression is a set of URIs, whereas the
evaluation of an LDQL query is a set of mappings. Thus, to formally state our result we
compare NautiLOD with LDQL queries that have a single free variable. Let q(?x) be an
LDQL query with ?x as free variable. We say that q(?x) and a NautiLOD expression ne
are equivalent if for every Web of Linked Data W = hD, adoci and URIs u, u′ with
u ∈ dom(adoc) it holds that u′ ∈ [[ne]]u

W if and only if {?x 7→ u′} ∈ [[q(?x)]]{u}
W .

Theorem 3. For every NautiLOD expression ne, there exists an LDQL query q(?x),
with ?x a free variable, that is equivalent to ne.

i/h+, p2,

i∗. To translate h

Proof (Sketch). The proof begins with a simple translation that replaces every p ∈ U in
i. For instance, the expression p1/p∗
a NautiLOD expression by a link pattern h+, p,
2
is translated into h+, p1,
i and [(ASK P )] we use h?v, qi.
The complete translation poses several other complications (as described in the ap-
pendix). In particular, the last step of NautiLOD expressions must be translated by
using a SPARQL pattern and not an LPE. For this we use the following property. Given
a regular expression r that does not generate the empty word, one can always write r as
r1/a1| · · · |rk/ak where the ai’s are base symbols of the alphabet. Thus, we can translate 
r by using LPEs to translate the ri’s as outlined above; next, translate the ai’s by
using a method similar to the proof of Theorem 2, and ﬁnally use UNION for |.

Along the same lines of Theorem 1 one can prove the following result.

Theorem 4. There exists an LDQL query q(?x) that cannot be expressed in NautiLOD.

4.3 Comparison with SPARQL under Reachability-Based Query Semantics

In [11] the author introduces a family of reachability-based query semantics based on
which SPARQL graph patterns can be used as a query language for Linked Data on
the WWW. Similar to how the scope of the SPARQL part of a basic LDQL query is
restricted to particular documents, reachability-based semantics restrict the scope of

4 In [7], all URIs have an assigned set of RDF triples (which may be empty). In our data model
one can have URIs not in dom(adoc). Hence, to properly capture the semantics of NautiLOD
in terms of our data model we have to introduce conditions of the form “u′ ∈ dom(adoc).”

SPARQL queries to documents that can be reached by traversing a well-deﬁned set of
data links. To specify what data links belong to such a set, the notion of a reachability
criterion is used; that is, a function c : T × U × P → {true, false} where P denotes the
set of all SPARQL graph patterns. Then, given such a reachability criterion c, a ﬁnite
set S of URIs and a SPARQL graph pattern P , a document d ∈ D is (c, S, P )-reachable
in a Web of Linked Data W = hD, adoci if any of the following two conditions holds:

1. There exists a URI u ∈ S such that adoc(u) = d; or
2. there exists a link graph edge hdsrc, (t, u), dtgti ∈ GW such that (i) dsrc is (c, S, P )-

reachable in W, (ii) c(t, u, P ) = true, and (iii) dtgt = d.

Notice how the second condition restricts the notion of reachability by ignoring
data links that do not satisfy the given reachability criterion c. Concrete examples of
reachability criteria are cAll, cNone, and cMatch [11], where cAll selects all data links, and
cNone ignores all data links; i.e., cAll(t, u, P ) = true and cNone(t, u, P ) = false for all
tuples ht, u, P i ∈ T × U × P. In contrast to such an all-or-nothing strategy, criterion
cMatch returns true for every data link whose triple matches a triple pattern of the given
graph pattern; formally, cMatch(t, u, P ) = true if and only if there exists some solution
mapping µ such that µ[tp] = t for an arbitrary triple pattern tp that is contained in P .

Given the notion of a reachability criterion, it is possible to deﬁne a family of (reach-
ability-based) query semantics for SPARQL. To this end, let c be a reachability criterion,
let S be a ﬁnite set of URIs, and let P be a SPARQL graph pattern. Then, for any Web of
Linked Data W = hD, adoci, the S-based evaluation of P over W under c-semantics,
denoted by [[P ]]R(c,S)
W , is the set of solution mappings [[P ]]G where G is the RDF graph
that consists of all triples from all documents that are (c, S, P )-reachable in W.

While there exist an inﬁnite number of possible reachability criteria, in this paper
we focus on cAll, cNone, and cMatch. The following two results show that LDQL is strictly
more expressive than SPARQL graph patterns under any of these three query semantics.

Theorem 5. Let c ∈ {cAll, cNone, cMatch}. For every SPARQL graph pattern P there
exists an LDQL query q such that [[P ]]R(c,S)

W for every Web W and S ⊆ U.

= [[q]]S

W

Proof (Sketch). We only sketch the case of cAll-semantics. In this case, one can prove
that the LPE lpe cAll = h
i∗ simulates the reachability criterion cAll, and, thus,
[[P ]]R(cAll,S)

,
= [[hlpe cAll, P i]]S
W . One can also ﬁnd LPEs to simulate cNone and cMatch.

,

W

Theorem 6. Let c ∈ {cAll, cNone, cMatch}. There exists an LDQL query q for which there
does not exist a SPARQL pattern P such that [[P ]]R(c,S)
W for every W and S ⊆ U.

= [[q]]S

W

5 Web-Safeness of LDQL Queries
In this section we study the “Web-safeness” of LDQL queries, where, informally, we
call a query Web-safe if a complete execution of the query over the WWW is possible
in practice (which is not the case for all LDQL queries as we shall see). To provide a
more formal deﬁnition of this notion of Web-safeness we make the following observations.
 While the mathematical structures introduced by our data model capture the
notion of Linked Data on the WWW formally (and, thus, allow us to provide a formal

semantics for LDQL queries), in practice, these structures are not available completely
for the WWW. For instance, given that an inﬁnite number of strings can be used as
HTTP URIs [6], we cannot assume complete information about which URIs are in the
domain of the partial function adoc (i.e., can be looked up to retrieve some document)
and which are not; in fact, disclosing this information would require a process that systematically 
tries to look up every possible HTTP URI and, thus, would never terminate.
Therefore, it is also impossible to guarantee the discovery of every document in the
set D (without looking up an inﬁnite number of URIs). Consequently, any query whose
execution requires a complete enumeration of this set is not feasible in practice. Based
on these observations, we deﬁne Web-safeness of LDQL queries as follows.

Deﬁnition 6. An LDQL query q is Web-safe if there exists an algorithm that, for any
ﬁnite Web of Linked Data W = hD, adoci and any ﬁnite set S of URIs, computes [[q]]S
W
by looking up only a ﬁnite number of URIs without assuming an a priori availability of
any information about the sets D and dom(adoc).

ex, and q′′

ex = (qex AND q′

ex) is Web-safe, and so is q′

ex may ﬁrst compute [[lpe ex]]uA

Example 6. Recall our example queries qex, q′

ex (cf. Example 5). For query
qex = (cid:0)SEED ?x (cid:10)ε, h?x, p1, ?zi(cid:11)(cid:1), any URI u ∈ U may be used to obtain a nonempty

subset of the query result as long as a lookup of u retrieves a document whose data includes 
RDF triples that match hu, p1, ?zi. Therefore, without access to D or dom(adoc)
of the queried Web W = hD, adoci, the completeness of the computed query result
can be guaranteed only by checking each of the inﬁnitely many possible HTTP URIs.
Hence, query qex is not Web-safe. In contrast, although it contains qex as a subquery,
query q′′
ex = hlpe ex, Bexi. Given uA as seed
URI, a possible execution algorithm for q′
W by traversing
the queried Web W based on lpe ex. Thereafter, the algorithm retrieves documents by
looking up all URIs u ∈ [[lpe ex]]uA
W (or simply keeps these documents after the traver-
sal); and, ﬁnally, the algorithm evaluates pattern Bex over the union of the RDF data in
the retrieved documents. If W is ﬁnite (i.e., contains a ﬁnite number of documents), the
traversal process requires a ﬁnite number of URI lookups only, and so does the retrieval
of documents in the second step; the ﬁnal step does not look up any URI. To see that
q′′
ex is also Web-safe we note that after executing subquery q′
ex (e.g., by using the algorithm 
as outlined before), the execution of the other (non-Web-safe) subquery qex can
be reduced to a ﬁnite number of URI lookups, namely the URIs bound to variable ?x
in solution mappings obtained for subquery q′
ex. Although any other URI may also be
used to obtain solution mappings for qex, such solution mappings cannot be joined with
any of the solution mappings for q′

ex and, thus, are irrelevant for the result of q′′
ex.

The example illustrates that there exists an LDQL query that is not Web-safe. In
fact, it is not difﬁcult to see that the argument for the non-Web-safeness of query qex as
made in the example can be applied to any LDQL query of the form (SEED ?x q) where
subquery q is a (satisﬁable) basic LDQL query; that is, none of these queries is Websafe.
 However, the example also shows that more complex queries that contain such
non-Web-safe subqueries may still be Web-safe. Therefore, we now show properties to
identify LDQL queries that are Web-safe even if some of their subqueries are not. We
begin with queries of the forms hlpe, P i, πV q, (SEED U q), and (q1 UNION ... UNION qn).

Proposition 2. An LDQL query q is Web-safe if any of the following properties holds:

1. Query q is of the form hlpe, P i and lpe is Web-safe, where we call an LPE Web-safe
if either (i) it is of the form h?v, q′i and LDQL query q′ is Web-safe, or (ii) it is of
any form other than h?v, q′i and all its subexpressions (if any) are Web-safe LPEs;

2. Query q is of the form πV q′ or (SEED U q′), and subquery q′ is Web-safe; or
3. Query q is of the form (q1 UNION ... UNION qn) and each qi (1 ≤ i ≤ n) is Web-safe.

It remains to discuss LDQL queries of the form (q1 AND ... AND qm). Our discussion
of query q′′
ex in Example 6 suggests that such queries can be shown to be Web-safe if all
non-Web-safe subqueries are of the form (SEED ?v q) and it is possible to execute these
subqueries by using variable bindings obtained from other subqueries. A necessary condition 
for this execution strategy is that the variable in question (i.e., ?v) is guaranteed
to be bound in every possible solution mapping obtained from the other subqueries.

To allow for an automated veriﬁcation of this condition we adopt Buil-Aranda et
al.’s notion of strongly bound variables [4]. To this end, for any SPARQL graph pattern 
P , let sbvars(P ) denote the set of strongly bound variables in P as deﬁned by
Buil-Aranda et al. [4]. For the sake of space, we do not repeat the deﬁnition here. However,
 we emphasize that sbvars(P ) can be constructed recursively, and each variable in
sbvars(P ) is guaranteed to be bound in every possible solution for P [4, Proposition 1].
To carry over these properties to LDQL queries, we use the notion of strongly bound
variables in SPARQL patterns to deﬁne the following notion of strongly bound variables
in LDQL queries; thereafter, in Lemma 3, we show the desired boundedness guarantee.

Deﬁnition 7. The set of strongly bound variables in an LDQL query q, denoted by
sbvars(q), is deﬁned recursively as follows:

1. If q is of the form hlpe, P i, then sbvars(q) = sbvars(P ).
2. If q is of the form (q1 AND q2), then sbvars(q) = sbvars(q1) ∪ sbvars(q2).
3. If q is of the form (q1 UNION q2), then sbvars(q) = sbvars(q1) ∩ sbvars(q2).
4. If q is of the form πV q′, then sbvars(q) = sbvars(q′) ∩ V .
5. If q is of the form (SEED U q′), then sbvars(q) = sbvars(q′).
6. If q is of the form (SEED ?v q′), then sbvars(q) = sbvars(q′) ∪ {?v}.

Lemma 3. Let q be an LDQL query. For every ﬁnite set S of URIs, every Web of Linked
Data W, and every solution mapping µ ∈ [[q]]S

W , it holds that sbvars(q) ⊆ dom(µ).

We are now ready to show the following result.

Theorem 7. An LDQL query of the form (q1 AND q2 AND ... AND qm) is Web-safe if there
exists a total order ≺ over the set of subqueries {q1, q2, ... , qm} such that for each
subquery qi (1 ≤ i ≤ m), it holds that either (i) qi is Web-safe or (ii) qi is of the

form (SEED ?v q) where q is Web-safe and ?v ∈ Sqj ≺qi

sbvars(qj ).

Proof (Sketch). We prove Theorem 7 based on an iterative algorithm that generalizes
the execution of query q′′
ex as outlined in Example 6. That is, the algorithm executes the
subqueries q1 ... qm sequentially in the order ≺ such that each iteration executes one of
the subqueries by using the solution mappings computed during the previous iteration.

With the results in this section we have all ingredients to devise a procedure to
show Web-safeness for a large number of queries (including queries that are arbitrarily 
nested). However, as a potential limitation of such a procedure we note that Theorem 
7 can be applied only in cases in which all non-Web-safe subqueries are of the
form (SEED ?v q). For instance, the theorem cannot be applied to show that an LDQL

q1, q2 and q3 are Web-safe. On the other hand, for the semantically equivalent query

query of the form(cid:0)q1 AND (q2 UNION (SEED ?x q3))(cid:1) is Web-safe if ?x ∈ sbvars(q1) and
(cid:0)(q1 AND q2) UNION (q1 AND (SEED ?x q3))(cid:1) we can show Web-safeness based on Theorem 
7 (and Proposition 2). Fortunately, we may leverage the following fact to improve
the effectiveness of applying Theorem 7 in the procedure that we aim to devise.

Fact 1. If an LDQL query q is Web-safe, then so is any LDQL query q′ with q′ ≡ q.

As a consequence of Fact 1, we may use the equivalences in Lemma 2 to rewrite
a given query into an equivalent query that is more suitable for testing Web-safeness
based on our results. To this end, we introduce speciﬁc normal forms for LDQL queries:

Deﬁnition 8. An LDQL query is in UNION-free normal form if it is of the form
(q1 AND ... AND qm) with m ≥ 1 and each qi (1 ≤ i ≤ m) is either (i) a basic LDQL
query or (ii) of the form πV q, (SEED U q) or (SEED ?v q) such that subquery q is in
UNION-free normal form. An LDQL query is in UNION normal form if it is of the form
(q1 UNION ... UNION qn) with n ≥ 1 and each qi (1 ≤ i ≤ n) is in UNION-free normal form.

The following result is an immediate consequence of Lemma 2.

Corollary 1. Every LDQL query is equivalent to an LDQL query in UNION normal form.

In conjunction with Fact 1, Corollary 1 allows us to focus on LDQL queries in UNION
normal form without losing generality. We are now ready to specify our procedure that
applies the results in this paper to test a given LDQL query q for Web-safeness: First,
by using the equivalences in Lemma 2, the query has to be rewritten into a semantically 
equivalent LDQL query qnf = (q1 UNION ... UNION qn) that is in UNION normal form.
Next, the following test has to be repeated for every subquery qi (1 ≤ i ≤ n); recall that
mi ).
each of these subqueries is in UNION-free normal form; i.e., qi = (qi
mi that satisﬁes the conditions
The test is to ﬁnd an order for their subqueries qi
in Theorem 7. Every top-level subquery qi (1 ≤ i ≤ n) for which such an order exists,
is Web-safe (cf. Theorem 7). If all top-level subqueries are identiﬁed to be Web-safe by
this test, then qnf is Web-safe (cf. Proposition 2), and so is q (cf. Fact 1).

1 AND ... AND qi

1, ... , qi

The given conditions are sufﬁcient to show Web-safeness of LDQL. It remains open
whether there exists a (decidable) sufﬁcient and necessary condition for Web-safeness.

6 Concluding Remarks and Future Work

LDQL, the query language that we introduce in this paper, allows users to express
queries over Linked Data on the WWW. We deﬁned LDQL such that navigational features 
for selecting the query-relevant documents on the Web are separate from patterns
that are meant to be evaluated over the data in the selected documents. This separation
distinguishes LDQL from other approaches to express queries over Linked Data.

We focused on expressiveness, by comparing LDQL with previous formalisms, and
on the notion of Web-safeness. Several topics remain open for future work. One of
them is the complexity of query evaluation. A classical complexity analysis is easy to
perform if we assume that all the data and documents are available as if they were in a
centralized repository, and that they can be processed via a RAM machine model. We
conjecture that under this model, the data complexity of evaluating LDQL will be polynomial.
 Nevertheless, a more interesting complexity analysis should consider a model
that captures the inherent way of accessing the Web of Linked Data via HTTP requests,
the overhead of data communication and transfer, the distribution of data and documents,
 etc. A more practical direction for future research on LDQL is the development
of approaches to actually implement LDQL queries efﬁciently.
Acknowledgements P´erez is supported by the Millennium Nucleus Center for Semantic 
Web Research, Grant NC120004, and Fondecyt grant 1140790.
References
1. Arenas, M., Conca, S., P´erez, J.: Counting beyond a yottabyte, or how SPARQL 1.1 property

paths will prevent adoption of the standard. In: WWW 2012. pp. 629–638 (2012)

2. Arenas, M., Gutierrez, C., P´erez, J.: On the Semantics of SPARQL. In: Semantic Web Information 
Management - A Model-Based Perspective, chap. 13, pp. 281–307. Springer (2009)
3. Berners-Lee, T.: Linked Data. At http://www.w3.org/DesignIssues/LinkedData.html (2006)
4. Buil-Aranda, C., Arenas, M., Corcho, O.: Semantics and Optimization of the SPARQL 1.1

Federation Extension. In: Proc. 8th Extended Semantic Web Conf. (2011)

5. Cyganiak, R., Wood, D., Lanthaler, M.: RDF 1.1 Concepts and Abstract Syntax. W3C Recommendation 
(Feb 2014)

6. Fielding, R., Gettys, J., Mogul, J.C., Frystyk, H., Masinter, L., Leach, P.J., Berners-Lee, T.:

Hypertext Transfer Protocol – HTTP/1.1 (Jun 1999)

7. Fionda, V., Pirr`o, G., Gutierrez, C.: NautiLOD: A Formal Language for the Web of Data

Graph. ACM Transactions on the Web 9(1), 5:1–5:43 (2015)

8. Harris, S., Seaborne, A., Prud’hommeaux, E.: SPARQL 1.1 Query Language. W3C Recommendation 
(Mar 2013)

9. Harth, A., Speiser, S.: On Completeness Classes for Query Evaluation on Linked Data. In:

Proc. 26th AAAI Conf. (2012)

10. Hartig, O.: LDQL: A Language for Linked Data Queries. In AMW 2015
11. Hartig, O.: SPARQL for a Web of Linked Data: Semantics and Computability. In: Proc. 9th

Extended Semantic Web Conf. (2012)

12. Hartig, O.: An Overview on Execution Strategies for Linked Data Queries. DatenbankSpektrum 
13(2) (2013)

13. Hartig, O., P´erez, J.: LDQL: A Query Language for the Web of Linked Data. In: Proc. 14th

Int. Semantic Web Conf. (2015)

14. Hartig, O., Pirr`o, G.: A Context-Based Semantics for SPARQL Property Paths over the Web.

In: Proc. 12th Extended Semantic Web Conf. (2015)

15. Mendelzon, A. O., Mihaila, G. A., Milo T.: Querying the World Wide Web. In: PDIS (1996)
16. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL. ACM Transactions 
on Database Systems 34 (2009)

17. P´erez, J., Arenas, M., Gutierrez, C.: nSPARQL: A Navigational Language for RDF. J. Web

Sem. 8(4), 255–270 (2010)

18. Umbrich, J., Hogan, A., Polleres, A., Decker, S.: Link Traversal Querying for a Diverse Web

of Data. Semantic Web Journal (2014)

A Proofs

A.1 Proof of Lemma 1

We formalize the claims in Lemma 1 as follows: Let q1, q2, and q3 be LDQL queries,
the following semantic equivalences hold:

(q1 AND q2) ≡ (q2 AND q1)

(q1 UNION q2) ≡ (q2 UNION q1)

(q1 AND (q2 AND q3)) ≡ ((q1 AND q2) AND q3)

(q1 UNION (q2 UNION q3)) ≡ ((q1 UNION q2) UNION q3)

(5)
(6)
(7)
(8)

Since the deﬁnition of LDQL operators AND and UNION is equivalent to their SPARQL
counterparts, these semantic equivalences follow from corresponding equivalences for
SPARQL graph patterns as shown by P´erez et al. [16, Lemma 2.5].

A.2 Proof of Lemma 2

The equivalences follow directly from the deﬁnition of every operator.

A.3 Proof of Proposition 1

The proof is based on a recursive translation of link path expressions beginning with link
patterns. Let hy1, y2, y3i be a link pattern. We construct an LPE transL(hy1, y2, y3i) as
follows. Assume that y1 = , then we construct the LDQL query

q1 = (cid:10)ε, (GRAPH ?u (?out, Y2, Y3))(cid:11)

where (i) if y2 = + then Y2 =?u, (ii) if y2 ∈ U then Y2 = y2 and (iii) if y2 =
then Y2 =?y2. And similarly, if y3 = + then Y3 =?u, (ii) if y3 ∈ U then Y3 = y3
then que can construct query q2 =
and (iii) if y3 =
hε, (GRAPH ?u (Y1, ?out, Y3))i, and if ?y3 = query q3 = hε, (GRAPH ?u (Y1, Y2, ?out))i,
following a similar process as for q1. Now consider the query q which is the UNION of
the above queries for every yi = . Then LPE transL(hy1, y2, y3i) is constructed as

then Y3 =?y3. If ?y2 =

transL(hy1, y2, y3i) = h?out, qi.

It is not difﬁcult to prove that [[transL(hy1, y2, y3i)]]u

We now deﬁne the translation in general:

W = [[hy1, y2, y3i]]u

W .

– For the case of LPE r = r1/r2, we have that transL(r) = h?v, qi where q is:

(cid:0) htransL(r1), (GRAPH ?x { })i AND (cid:0)SEED ?x htransL(r2), (GRAPH ?v { })i(cid:1) (cid:1).

– For the case of LPE r = r1|r2, we have that transL(r) = h?v, qi where q is:
(cid:0) htransL(r1), (GRAPH ?v { })i UNION htransL(r2), (GRAPH ?v { })i (cid:1).

– For the case of LPE r = [r1], we have that transL(r) = h?v, qi where q is:

(cid:0) hε, (GRAPH ?v { })i AND π{?v}(cid:0)SEED ?v htransL(r1), (GRAPH ?x { })i(cid:1) (cid:1).
The general proof proceed by induction. We next prove that [[transL(r1|r2)]]u
W . The proof for the other cases are similar. Thus assume that u′ ∈ [[r1|r2]]u
[[r1|r2]]u
then we know that u′ ∈ [[r1]]u
we know that u′ ∈ [[transL(r1)]]u

W =
W ,
W then by induction hypothesis

W . If u′ ∈ [[r1]]u

W . Now notice that

W ∪ [[r2]]u

[[htransL(r1), (GRAPH ?v { })i]]{u}

W = [[(GRAPH ?v { })]]D

W we
Where D = datasetW ([[transL(r1)]]u
know that D has a dataset hu′, data(adoc(u′))i, which implies that {?v → u′} is a solution 
for [[(GRAPH ?v { })]]D, and thus {?v → u′} ∈ [[htransL(r1), (GRAPH ?v { })i]]{u}
W .
From this it is straightforward to conclude that u′ ∈ [[transL(r1|r2)]]u
W . The other direction 
is similar.

W ). Thus given that u′ ∈ [[transL(r1)]]u

A.4 Proof of Theorem 1

Consider the LDQL Q query given by

(cid:0)SEED u (cid:10)h+, p,

i, (?x, ?x, ?x)(cid:11)(cid:1)

with u, p ∈ U. Now assume that there exists a property path pattern P and a set of URIs
S such that

[[P ]]ctxt

W = [[Q]]S

W

for every Web of Linked Data W . Let u′ ∈ U. Consider now W1 having only two
documents d1 = {(u, p, u′)} and d2 = {(a, a, a)} and such that adoc(u) = d1 and
adoc(u′) = d2. Moreover, consider W2 having also two documents d1 = {(u, p, u′)}
and d3 = {(b, b, b)} such that adoc(u) = d1 and adoc(u′) = d3. First notice that for
every S we have that

[[Q]]S

W1 = {{?x → a}} 6= [[Q]]S

W2 = {{?x → b}}

Notice that CW1 (u) = CW2 (u) = {(u, p, u′)} and CW1 (u′) = CW2 (u′) = ∅. In
general, we have that for every term v 6= u it holds that CW1 (v) = CW2 (v) = ∅. This
essentially shows that the context selectors CW1 and CW2 are equivalent. Given that
the semantics of property paths is based on context selectors it is easy to prove that for
every PP-based SPARQL query R we have that [[R]]ctxt
W2 . This can be done by
induction in the construction of PP-based SPARQL queries. For example, the evaluation
of a base PP-pattern of the form (v, p, β), with v ∈ U and β ∈ U ∪ V over W1 is given
by

W1 = [[R]]ctxt

[[(v, p, β)]]ctxt

W1 = {µ | dom(µ) = {β} ∩ V and µ[hv, p, βi] ∈ CW1 (v)}

W2 since CW1 (v) = CW2 (v). All the other cases for the
which is equal to [[(v, p, β)]]ctxt
construction of property paths are equivalent. Moreover, since for the case of property
path patterns the evaluation is the same over W1 and over W2, we have that for a general

PP-based query using operator AND , UNION , OPT and so on, the evaluation is also the
same. Thus we have that

[[P ]]ctxt

W1 = [[P ]]ctxt

W2

but also that

[[Q]]S

W1 6= [[Q]]S

W2

which contradicts the fact that [[P ]]ctxt

W = [[Q]]S

W for every Web of Linked Data W .

A.5 Proof of Theorem 2

We associate to every property-path expression r, an LDQL query Qr(?x, ?y) with ?x
and ?y as free variables. The deﬁnition of Qr(?x, ?y) is by induction in the construction
of property-path expressions. In the construction, all the variables mentioned, besides
?x and ?y, are considered as fresh variables.

– If r ∈ U then Qr(?x, ?y) = (SEED ?x hε, (?x, r, ?y)i).
– If r = !(u1 | · · · | uk) with ui ∈ U then Qr(?x, ?y) is deﬁned as

(cid:18)SEED ?x (cid:10)ε,(cid:0)(?x, ?p, ?y) FILTER (?p 6= u1 ∧ · · · ∧?p 6= uk)(cid:1)(cid:11)(cid:19).

– If r = r1/r2 then Qr(?x, ?y) is deﬁned as

π{?x,?y}(cid:0)Qr1(?x, ?z) AND Qr2(?z, ?y)(cid:1).

– If r = r1|r2 then Qr(?x, ?y) is deﬁned as

– If r = r∗

1 then Qr(?x, ?y) is deﬁned as follows. First consider the LDQL query

(cid:0)Qr1(?x, ?y) UNION Qr2(?x, ?y)(cid:1).

Qε(?x, ?y) = π{?x,?y}(SEED ?f hε, P i)

where P is the following pattern

P =(cid:0)(?x, ?p, ?o) AND (?y, ?p, ?o) FILTER (?x =?y)(cid:1) UNION
(cid:0)(?s, ?x, ?o) AND (?s, ?y, ?o) FILTER (?x =?y)(cid:1) UNION
(cid:0)(?s, ?p, ?x) AND (?s, ?p, ?y) FILTER (?x =?y)(cid:1)

Now consider the LDQL query Qs(?v) deﬁned as

Qs(?v) = (cid:0)hε, (GRAPH ?u { })i AND Qr1(?u, ?v)(cid:1).

Then, query Qr(?x, ?y) is deﬁned by

Qε(?x, ?y) UNION(cid:0)(SEED ?x h(?v, Qs(?v))∗, (GRAPH ?z { })i) AND Qr1(?z, ?y)(cid:1)

We prove now that for every property path pattern (?x, r, ?y) we have that

[[(?x, r, ?y)]]ctxt

W = [[Qr(?x, ?y)]]∅

W .

The proof is by induction in the construction of Qr(?x, ?y). We proceed by cases.

– Assume that r ∈ U. Then µ ∈ [[Qr(?x, ?y)]]∅

W if and only if

µ ∈ [[(SEED ?x hε, (?x, r, ?y)i)]]∅

W .

Notice that this occurs if and only if there exists a mapping µ′ and a URI u such
that µ′ ∈ [[hε, (?x, r, ?y)i]]{u}
W , µ′ is compatible with the mapping {?x → u},
and µ = µ′ ∪ {?x → u}. Now, given that [[ε]]{u}
W = {u}, we have that µ′ ∈
[[hε, (?x, r, ?y)i]]{u}
W if and only if µ′ ∈ [[(?x, r, ?y)]]D with D the data set with
data(adoc(u)) as default graph. With all this we have that µ ∈ [[Qr(?x, ?y)]]∅
W if
and only if dom(µ) = {?x, ?y}, µ(?x) ∈ dom(adoc), and (µ(?x), r, µ(?y)) ∈
data(adoc(µ(?x))), which is exactly the property

µ((?x, r, ?y)) ∈ CW (µ(?x)).

This last property holds if and only if µ ∈ [[(?x, r, ?y)]]ctxt
W .

– For the case in which r = !(u1 | · · · | uk) with ui ∈ U, the proof is similar. We

have that

µ ∈ [[(cid:18)SEED ?x (cid:10)ε,(cid:0)(?x, ?p, ?y) FILTER (?p 6= u1 ∧ · · · ∧?p 6= uk)(cid:1)(cid:11)(cid:19)]]∅

W

if and only if µ is in the evaluation of

(cid:0)(?x, ?p, ?y) FILTER (?p 6= u1 ∧ · · · ∧?p 6= uk)(cid:1)

over the graph data(µ(?x)). This happens if and only if

µ((?x, p, ?y)) ∈ CW (µ(?x))for p /∈ {u1, ... , uk},

which is exactly the property

µ ∈ [[(?x, !(u1 | · · · | uk), ?y)]]ctxt
W .

– For the cases r = r1/r2, r = r1|r2, the semantics of the corresponding LDQL
query exactly matches the semantics of the property path expression. Just notice
that the semantics of AND is that of the join, and the semantics of UNION is that of
the set union.

– For the case of r = r∗

1 , ?y)]]ctxt

1 we have that µ ∈ [[(?x, r∗

W if and only if dom(µ) =
{?x, ?y} and (i) µ(?x) = µ(?y) and µ(?x), µ(?y) ∈ terms(W ), or (ii) µ ∈
W for some k > 0. For the case (i) it is easy to see that µ ∈
[[(?x, rk
[[Qε(?x, ?y)]]∅
W . Just notice that if µ(?x) is in terms(W ) then there exists a URI u ∈
dom(adoc) and a triple t in data(adoc(u)) such that µ(?x) appears in t. If µ(?x)
appears in the subject position, then we know that µ is compatible with a mapping in

1 , ?y)]]ctxt

[[(cid:0)(?x, ?p, ?o) AND (?y, ?p, ?o) FILTER (?x =?y)(cid:1)]]D where D is a dataset with a default 
graph in which t appears. Finally, given that Qε(?x, ?y) = π{?x,?y}(SEED ?f hε, P i)
and we know that u is a possible value for variable ?f , we obtain that µ ∈ [[Qε(?x, ?y)]]∅
W .
If µ(?x) appears in the predicate or object position, the proof is similar. For the case
(ii) we will show that

µ ∈ [[Qε(?x, ?y)]]∅

W ∪

k−1

[i=0

[[π{?x,?y}(cid:0)(SEED ?x h(?v, Qs(?v))i, (GRAPH ?z { })i) AND Qr1 (?z, ?y)(cid:1)]]∅
We will use an inductive argument. Assume k = 1, then µ ∈ [[(?x, r1, ?y)]]ctxt
W . By
the induction hypothesis on the construction of property paths, we have that µ ∈
[[Qr1(?x, ?y)]]∅
W . Now, if µ(?x) /∈ dom(adoc) then we have that µ(?x) = µ(?y)
and thus µ ∈ [[Qε(?x, ?y)]]∅

W . If µ(?x) ∈ dom(adoc), then it is easy to see that

W (9)

µ ∈ [[π{?x,?y}(cid:0)(SEED ?x hε, (GRAPH ?z { })i) AND Qr1(?z, ?y)(cid:1)]]∅
W , thus

This is because {?x → µ(?x), ?z → µ(?x)} ∈ [[(SEED ?x hε, (GRAPH ?z { })i)]]∅
W
which is compatible with µ. Now assume that µ ∈ [[(?x, rk+1

, ?y)]]ctxt

W

1

µ ∈ π{?x,?y}([[(?x, rk

1 , ?z)]]ctxt

W ⋊⋉ [[(?z, r1, ?y)]]ctxt

W ).

By induction hypothesis we have that

µ ∈ π{?x,?y}(cid:18)(cid:20)[[Qε(?x, ?z)]]∅

W ∪

k−1

[i=0

W(cid:21)
[[π{?x,?z}(cid:0)(SEED ?x h(?v, Qs(?v))i, (GRAPH ?u { })i) AND Qr1 (?u, ?z)(cid:1)]]∅
W(cid:19).

⋊⋉ [[Qr1 (?z, ?y)]]∅

Then we know that there exists j such that 0 ≤ j ≤ k − 1 such that

µ ∈ π{?x,?y}(cid:18)(cid:20)[[Qε(?x, ?z)]]∅

W ∪

W(cid:21)
[[π{?x,?z}(cid:0)(SEED ?x h(?v, Qs(?v))j, (GRAPH ?u { })i) AND Qr1 (?u, ?z)(cid:1)]]∅
W(cid:19).
⋊⋉ [[Qr1 (?z, ?y)]]∅

If µ ∈ π{?x,?y}(cid:0)[[Qε(?x, ?z)]]∅

W

apply the same argument as in the base case. Now assume that

⋊⋉ [[Qr1 (?z, ?y)]]∅

W(cid:1) = [[Qr1 (?x, ?y)]]∅

W we can

µ ∈ π{?x,?y}(cid:18)

[[π{?x,?z}(cid:0)(SEED ?x h(?v, Qs(?v))j, (GRAPH ?u { })i) AND Qr1 (?u, ?z)(cid:1)]]∅

W

⋊⋉ [[Qr1 (?z, ?y)]]∅

W(cid:19).

Then we know that there exists a mapping µ′ and µ′′ such that

µ′ ∈ [[π{?x,?z}(cid:0)(SEED ?x h(?v, Qs(?v))j , (GRAPH ?u { })i) AND Qr1(?u, ?z)(cid:1)]]∅

W

and

µ′′ ∈ [[Qr1(?z, ?y)]]∅
W

µ equals µ′ ∪ µ′′ restricted to variables ?x, ?y. Notice that µ′′ is compatible with
µ′ thus, we have that µ′(?z) = µ′′(?z). Now, if µ′′(?z) /∈ dom(adoc), since
µ′′ ∈ [[Qr1(?z, ?y)]]∅
W , then necessarily µ′′(?z) = µ′′(?y), and given that µ′ is
compatible with µ′′ we obtain that µ′(?z) = µ′′(?y). All this implies that

µ ∈ π{?x,?y}(cid:18)

[[π{?x,?z}(cid:0)(SEED ?x h(?v, Qs(?v))j, (GRAPH ?u { })i) AND Qr1 (?u, ?y)(cid:1)]]∅
and thus (9) holds. Assume now that µ′′(?z) ∈ dom(adoc). We will prove that

W(cid:19).

µ′ ∈ [[(SEED ?x h(?v, Qs(?v))j+1, (GRAPH ?z { })i)]]∅

W .

We know that

µ′ ∈ [[π{?x,?z}(cid:0)(SEED ?x h(?v, Qs(?v))j , (GRAPH ?u { })i) AND Qr1(?u, ?z)(cid:1)]]∅

Thus µ′ equals µ1 ∪ µ2 (restricted to variables ?x, ?z) where

W

µ1 ∈ [[(SEED ?x h(?v, Qs(?v))j , (GRAPH ?u { })i)]]∅

W

and

µ2 ∈ [[Qr1(?u, ?z)]]∅
W

Thus, regarding µ1 we know that there exists a sequence of URIs, u1, u2, ... uj
such that µ1(?x) = u1, µ1(?u) = uj and ui+1 ∈ [[(?v, Qs(?v))]]ui
W . Now, recall
that the deﬁnition of Qs(?v) is

Qs(?v) = (cid:0)hε, (GRAPH ?f { })i AND Qr1(?f, ?v)(cid:1).

Then essentially what we have is that

{?f → ui, ?v → ui+1} ∈ [[Qr1(?f, ?v)]]∅

W .

Moreover, since µ1 and µ2 are compatible, we know that µ1(?u) = µ2(?u) = uj
and since µ2 ∈ [[Qr1(?u, ?z)]]∅

W we know that

{?f → uj, ?v → µ2(?z)} ∈ [[Qr1(?f, ?v)]]∅

W .

Finally, given that we are assuming that µ′′(?z) = µ2(?z) is in dom(adoc) we have
that

{?x → µ1(?x), ?z → µ2(?z)} ∈ [[(SEED ?x h(?v, Qs(?v))j+1, (GRAPH ?z { })i)]]∅

W

which is what we wanted to prove. Thus we have that

µ′ ∈ [[(SEED ?x h(?v, Qs(?v))j+1, (GRAPH ?z { })i)]]∅

W .

and also that

µ′′ ∈ [[Qr1(?z, ?y)]]∅
W

and given that µ equals µ′ ∪ µ′′ restricted to variables ?x, ?y, we have that

µ ∈ [[π{?x,?y}(cid:0)(SEED ?x h(?v, Qs(?v))j+1, (GRAPH ?z { })i) AND Qr1 (?z, ?y)(cid:1)]]∅

W

and since j + 1 ≤ k we obtain

µ ∈ [[Qε(?x, ?y)]]∅

W ∪

k

[i=0

[[π{?x,?y}(cid:0)(SEED ?x h(?v, Qs(?v))i, (GRAPH ?z { })i) AND Qr1 (?z, ?y)(cid:1)]]∅

W

If one assumes that µ ∈ [[Qr(?x, ?y)]]ctxt
lines of the argument above, one can show that µ ∈ [[(?x, r∗

W then by an argument on exactly the same

W .
1 , ?y)]]ctxt

We have shown how to construct an equivalent LDQL query for every property path
pattern with two variables. If the triple does not have two variables, we need a slightly
different construction, in particular for the case in which (·)∗ is used. We now show
the details of the construction but leave the complete proof as an exercise (it can be
completed using the arguments of the previous part of this proof).

Consider a propery path pattern (α, r, β) where α is a URI or variable, and β is a
URI, variable or literal. Then for the cases r = p ∈ U, r =!(u1| · · · |uk), r = r1/r2,
r = r1|r2, we construct a query as Qr(α, β) where Qr(α, β) is query Qr(?x, ?y)
where all occurrences of ?x has been replaced by α and all occurrences of ?y has been
replaced by β. For the case of r = r∗
1 we need to do a slightly different construction.
For a pattern (u, r, ?y) we construct a query Pr(?y) as

hε, BIND(u AS ?y)i UNION(cid:0)(SEED {u} h(?v, Qs(?v))∗, (GRAPH ?z { })i) AND Qr1(?z, ?y)(cid:1)

For a pattern (?x, r, v) we construct a query Sv

r (?x) as

hε, BIND(u AS ?x)i UNION(cid:0)(SEED ?x h(?v, Qs(?v))∗, (GRAPH ?z { })i) AND T (?z)(cid:1)

where T (?z) is either Qr1(?z, v) or Sv
pattern (u, r, v) we construct a query Ur as

r1(?z) depending on the form of r1. Finally, for a

hε, (BIND(u AS ?x) AND BIND(v AS ?y)) FILTER (?x =?y)i UNION

(cid:0)(SEED {u} h(?v, Qs(?v))∗, (GRAPH ?z { })i) AND T (?z)(cid:1)

where T (?z) is either Qr1(?z, v) or Sv

r1 (?z) depending on the form of r1.

Finally consider a property path pattern (ℓ, r, β), where ℓ is a literal. Then for the
cases r = p ∈ U, r =!(u1| · · · |uk) we should translate it into an unsatisﬁable query.
One way of obtaining that query is, for example, with an expression

hε, (BIND(ℓ AS ?x) AND BIND(ℓ AS ?y)) FILTER (?x 6=?y)i

For the cases r = r1/r2 and r = r1|r2 we follow the same construction as if ℓ were a
URI but with the last base case. For the case of r = r∗
1, if β is a variable y we consider
the following query

and if β is a URI or literal the query

hε, BIND(ℓ AS ?y)i.

hε, (BIND(ℓ AS ?x) AND BIND(β AS ?y)) FILTER (?x =?y)i.

The correctness of this translation can be proved along the same lines as for the case of
property path pattern (?x, r, ?y).

A.6 Proof of Theorem 3

We proceed by induction showing how to translate every posible NautiLOD query. The
translation works in two parts. We ﬁrst deﬁne the following function transN (·) that
given a NautiLOD query, produces an LPE.

transN (p) = h+, p,
transN (pˆ) = h

i
, p, +i

transN (h

i) = (cid:0)?x,(cid:10)ε, (GRAPH ?u (?u, ?p, ?x))(cid:11)(cid:1)

transN (n1/n2) = transN (n1)/ transN (n2)
transN (n1|n2) = transN (n1)| transN (n2)

transN (n∗) = transN (n)∗

transN (n[(ASK P )]) = transN (n)/[(?x, hε, (GRAPH ?x P )i]

Before presenting the complete translations, we prove the following result. Let n be a
NautiLOD expression, then for every Web of Linked Data and URIs u, v ∈ dom(adoc)
we have that

v ∈ [[n]]u

W if and only if v ∈ [[transN (n)]]{u}
W .

The proof is by induction in the construction of the NautiLOD expression.

– for the case of p ∈ U we have that

[[p]]u

W = {u′ | (u, p, u′) ∈ data(adoc(u))}

notice that v ∈ dom(adoc) and v ∈ [[p]]u
document adoc(u) to document adoc(v) that matches h+, p,
and only if v ∈ [[h+, p,

W , which is what we wanted to prove.

W , if and only if there is a link from
i. This happens, if

i]]{u}

– the case for pˆ is similar but using h+, p,
– the case for h

i.
i]]u

i. Just notice that v ∈ [[h

W if and only if there exists a p ∈
U such that (u, p, v) ∈ data(adoc(u)). On the other hand we have that v ∈
W if and only if v ∈
[[transN (h
[[π?x(GRAPH ?u (?u, ?p, ?x))]]D where D = {data(adoc(u)), hu, data(adoc(u))i}.
Thus v ∈ [[transN (h
W if and only if there exists p such that (u, p, v) ∈
data(adoc(u)). This proves the desired property.

W = [[(cid:0)?x,(cid:10)ε, (GRAPH ?u (?u, ?p, ?x))(cid:11)(cid:1)]]{u}
i)]]{u}

i)]]{u}

– for the case of an expression n1/n2, we have that v in dom(adoc) is in [[n1/n2]]u
W
W and v ∈ [[n2]]v′
W .
W if
W , and thus v ∈

if and only if, there exists v′ ∈ dom(adoc) such that v′ ∈ [[n1]]u
The we can apply or induction hypothesis and we have that v ∈ [[n1/n2]]u
and only if v′ ∈ [[transN (n1)]]{u}
[[transN (n1/n2)]]{u}
W .

W and v ∈ [[transN (n2)]]{v′}

– cases n1|n2 and n∗ are direct from the deﬁnition of NautiLOD and LDQL.
– for the case of expression n[(ASK P )] we have that v ∈ [[n[(ASK P )]]]u

W if and only if
W , v ∈ dom(adoc) and [[P ]]data(adoc(v)) 6= ∅. On the other hand, we have

v ∈ [[n]]u
that v ∈ [[transN (n[(ASK P )])]]{u}

W if and only if

v ∈ [[transN (n)/[(?x, hε, (GRAPH ?x P )i]]]{u}
W .

This happens if and only if there exists a v′ such that v′ ∈ [[transN (n)]]{u}
W and
v ∈ [[[(?x, hε, (GRAPH ?x P )i]]]{v′}
W . From the last property and the semantics of
[·] in LDQL, we have that v = v′ and that [[(?x, hε, (GRAPH ?x P )i]]{v}
W 6= ∅.
The last holds if and only if [[π?x(GRAPH ?x P )]]D 6= ∅, with D the RDF dataset
{data(adoc(v)), hv, data(adoc(v))i}. Thus we have that v ∈ [[transN (n[(ASK P )])]]{u}
if and only if v ∈ [[transN (n)]]{u}
tion hypothesis we have v ∈ [[n]]u
we needed to prove.

W and [[P ]]data(adoc(u)) 6= ∅. Applying our inducW 
and [[P ]]data(adoc(u)) 6= ∅, which is exactly what

W

Notice that the hypothesis that v ∈ dom(adoc) was fundamental to prove the previous
result. Nevertheless, the output of a NautiLOD query can be a URI not in dom(adoc)
or even a literal, so we need to do a different translation in general. Thus, we use now
transN (·) to translate a general NautiLOD query. Given a NautiLOD expression n we
have two cases. Assume ﬁrst that n, as a regular expression, does not produce the empty
string ε. Then, by using reglar language results, we know that we can write an equivalent
expression n′ of the form

n1/e1 | · · · | nk/ek | m1[(ASK P1)] | · · · | mℓ[(ASK Pℓ)]

where every ni and mj is a NautiLOD query, and every ei is either of the form p, or pˆ,
or h
i. We are ready now to produce an LDQL query Qn(?x) which is equivalent to n.
The query is constructed as follows.

Qn(?x) = π{?x}(cid:18)htransN (n1), Q1i UNION · · · UNION htransN (nk), Qki UNION
htransN (m1), (GRAPH ?x P1)i UNION · · · UNION htransN (mℓ), (GRAPH ?x Pℓ)i(cid:19)

where query Qi depends on the form of ei:

– if ei = p then Qi = (GRAPH ?u (?u, p, ?x))
– if ei = pˆ then Qi = (GRAPH ?u (?x, p, ?u))
– if ei = h

i then Qi = (GRAPH ?u (?u, ?p, ?x))

W or v ∈ [[mi[(ASK Pi)]]]u

W . Then we
Now to prove the correctness of our construction, assume that v ∈ [[n]]u
W we know
know that v ∈ [[ni/ei]]u
W for some i. If v ∈ [[ni/ei]]u
W . Notice that, since v ∈ [[ei]]v′
that there exists a v′ such that v′ ∈ [[ni]]u
W ,
i then we know that v′ is in dom(adoc). Thus we can
and ei is either p, or pˆ, or h
W that v′ ∈ [[transN (ni)]]{u}
apply our previous result to conclude from v′ ∈ [[ni]]u
W .
Now if ei = p then from v ∈ [[ei]]v′
W we conclude that (v′, p, v) ∈ data(adoc(v′)) and
thus [[(?u, p, ?x)]]data(adoc(v′)) contains the mapping µ = {?u → v′, ?x → v}, then
[[(GRAPH ?u (?u, p, ?x))]]D has µ as solution, with D = {data(adoc(v′)), hv′, data(adoc(v′))i}.
Given that v′ ∈ [[transN (ni)]]{u}

W and v ∈ [[ei]]v′

W , we have that

µ = {?u → v′, ?x → v} ∈ [[htransN (ni), Qii]]{u}
W .

Finally, given that Qn(?x) only keep the ?x variable, we have that {?x → v} is in
[[Qn(?x)]]{u}
i the proof is the
essentially the same.

W , which is what we wanted to show. If ei = pˆ or ei = h

W . This implies that v is in [[mi]]u

Now assume that v ∈ [[mi[(ASK Pi)]]]u

W and that
[[Pi]]data(adoc(v)) 6= ∅. By the semantics of NautiLOD, we have that v is in dom(adoc)
(otherwise we could not have been able to evaluate P ), and thus we can apply our result 
above to obtain that v ∈ [[transN (mi)]]{u}
W . Now, given that [[Pi]]data(adoc(v)) 6= ∅
we have that [[(GRAPH ?x Pi)]]D 6= ∅ where D = {data(adoc(v)), hv, data(adoc(v))i}.
Moreover, we have that every mapping µ in [[(GRAPH ?x Pi)]]D is such that µ(?x) = v.
All these facts implies that mapping µ′ = {?x → v} is in [[htransN (mℓ), (GRAPH ?x Pℓ)i]]{u}
W ,
and thus µ′ is in [[Qn(?x)]]{u}

W which is exactly what we wanted to prove.

If we start by assuming that µ = {?x → v} is in [[Qn(?x)]]{u}

W , then following a

similar reasoning as above one concludes that v ∈ [[n]]u

W .

To complete the proof we have to cover the case in which n, as a regular expression,
 can produce the empty string. Then, by applying some classical regular languages
properties, one can rewrite n as ε|n′ with n′ an expression that does not produce the
empty string ε. Thus we can translate n into the LDQL query

hε, (GRAPH ?x { })i UNION Qn′(?x)

Notice that for every u ∈ data(adoc(v)) we have that [[hε, (GRAPH ?x { })i]]{u}
in a single mapping µ = {?x → u}.

W results

A.7 Proof of Theorem 4

Recall that NautiLOD can only express paths and no combination of those paths via
SPARQL operators is allowed. Thus, it is easy to prove that NautiLOD cannot express
operators such as SEED , AND , UNION that are natively allowed in LDQL. Thus to make
a stronger claim, we will prove that there exists simple LDQL query not using the
mentioned operators, that cannot be expressed using NautiLOD. The proof is similar to
the proof of Theorem 1.

Thus, consider the LDQL Q(?x) query given by

with p ∈ U. Now assume that there exists a NautiLOD expression n such that

(cid:10)h+, p,

i, (?x, ?x, ?x)(cid:11)

[[n]]v

W = [[Q(?x)]]{v}

W

for every Web of Linked Data W and v ∈ dom(adoc). Let u, u′, a, b be different
elements in U that are not mentioned in n. Consider now W1 having only two documents 
d1 = {(u, p, u′)} and d2 = {(a, a, a)} and such that adoc(u) = d1 and
adoc(u′) = d2. Moreover, consider W2 having also two documents d1 = {(u, p, u′)}
and d3 = {(b, b, b)} such that adoc(u) = d1 and adoc(u′) = d3. First notice that

[[Q(?x)]]{u}

W1 = {{?x → a}} 6= [[Q(?x)]]{u}

W2 = {{?x → b}}

W1 = [[n]]u

We now prove that [[n]]u
W2 which is a contradiction. To prove this, we show
that for every subexpression e of n, and for every possible URI v, it holds that [[e]]v
W1 =
W2. First notice that W1 and W2 has only two URIs in dom(adoc), namely, u and
[[e]]v
u′, thus, we only have to reason for the cases in which v = u or v = u′. We proceed by
induction.

– Assume that e = r ∈ U. Given that in W1 and W2 the URI u is associated with the
W2 . Moreover, given that r 6= a
W2 = ∅.
– Assume that e = rˆ with r ∈ U. Exactly the same argument as the above case

same document (document d1), then [[r]]u
and r 6= b (recall that n does not mention a or b), we have that [[r]]u′

W1 = [[r]]u′

W1 = [[r]]u

applies.

W1 = [[r]]u

– Assume that e = h

W2 . Now consider [[h

i. For the same reason as in the above two cases we have that
W1 if
[[r]]u
and only if, there exists some p such that (u′, p, v) ∈ data(adoc(u′)), but the only
triple in data(adoc(u′)) is (a, a, a) and since a 6= u′ we have that [[h
W1 = ∅.
W2 = ∅, completing this part of the proof.
For a similar reason we obtain that [[h
– The cases e = r1/r2, e = r1|r2 and e = r∗ follows from the base cases proved

W1 . Then we have that URI v is in [[h

i]]u′

i]]u′

i]]u′

i]]u′

above.

– Assume e = r[(ASK P )]. By deﬁnition we have that

[[r[(ASK P )]]]v

W = {v′ | v′ ∈ [[r]]v

W , v′ ∈ dom(adoc) and [[P ]]data(adoc(v′)) 6= ∅}

W1 = [[r]]v

W2 for v = u, u′. Thus we only
By induction hypothesis we have that [[r]]v
need to prove that the evaluation of P is always the same. given that data(adoc(u))
is the same document in W1 and W2, we have that for u the property holds. Now
consider [[P ]]d2 and [[P ]]d3 with d1 = {(a, a, a)} and d2 = {(b, b, b)}. Recall that
P does not mention a or b, thus we have that if µ ∈ [[P ]]d2 then the mapping µ′
obtained from µ by replacing every occurrence of a by b, is in [[P ]]d3, and vice
versa. Thus we have that [[P ]]d2 = ∅ if and only if [[P ]]d3 = ∅. This proves that
[[r[(ASK P )]]]v

W2 for v = u, u′.

W1 = [[r[(ASK P )]]]v
We have ﬁnished the proof that [[n]]u
equivalent to Q(?x).

W1 = [[n]]u

W2 thus contradicting the fact that n is

A.8 Proof of Theorem 5

Let P be an arbitrary SPARQL graph pattern, let W = hD, adoci be an arbitrary Web
of Linked Data, and let S be some ﬁnite set of URIs. To prove the theorem we use
the (basic) LDQL queries hlpe cAll , P i, hlpe cNone, P i, and hlpe cMatch, P i, with the following 
LPEs:

lpe cAll
lpe cNone
lpe cMatch

,

,

is h
is ε, and

i∗,

is (cid:0)h?s, q1i | h?p, q1i | h?o, q1i | ... | h?s, qmi | h?p, qmi | h?o, qmi(cid:1)∗ where

?s, ?p and ?o are fresh variables (not used in P ), m is the number of
triple patterns in P , and for each such triple pattern tpk (1 ≤ k ≤ m)
there exists a subquery qk of the form hε, Pki with a SPARQL pattern 
Pk that is constructed as follows: Pk contains the triple pattern
h?s, ?p, ?oi and—depending on the form of the corresponding triple pattern 
tpk = hsk, pk, oki—may contain additional FILTER operators; in particular,
 if sk /∈ V, then Pk contains FILTER ?s = sk; if pk /∈ V, then Pk
contains FILTER ?p = pk; and if ok /∈ V, then Pk contains FILTER ?o = ok.

Then, for each reachability criterion c ∈ {cAll, cNone, cMatch} with its corresponding

LPE lpe c as speciﬁed above, we have to show the following equivalence:

[[P ]]R(c,S)

W

= [[hlpe c, P i]]S

W .

(10)

By the deﬁnition of the reachability-based query semantics (cf. Section 4.3) and
the deﬁnition of LDQL query semantics (cf. Deﬁnition 5), it is sufﬁcient to prove the
following lemma to show that (10) holds for each c ∈ {cAll, cNone, cMatch}.

Lemma 4. For each c ∈ {cAll, cNone, cMatch}, the set of all documents that are (c, S, P )-
reachable in W is equivalent to the following set of documents:

Dc

LPE = {adoc(u) | u ∈ [[lpe c]]uctx

W for some uctx ∈ S}.

Notice that for each c ∈ {cAll, cNone, cMatch}, the set Dc

LPE is the set of documents
selected by evaluating lpe c over W using every URI in S as context URI. In the following,
 we prove Lemma 4 for each of the three reachability criteria, cAll, cNone, and cMatch.

cAll-semantics: To prove Lemma 4 for cAll we show that the set DcAll
and a superset of the set of all (cAll, S, P )-reachable documents in W.

LPE is both a subset

We begin with the former. Hence, for an arbitrary document in DcAll
show that this document is (cAll, S, P )-reachable in W. Let dLPE ∈ DcAll
document. Since dLPE ∈ DcAll

LPE we have to
LPE be such a
LPE, we know that there exist two URIs, uctx and u, such that

– uctx ∈ S,
– u ∈ [[lpe cAll ]]uctx
– dLPE = adoc(u).

W , and

Then, either we have uctx = u or uctx 6= u. In the following, we discuss these two cases.
If uctx = u, then dLPE = adoc(uctx) and, thus, document dLPE is (cAll, S, P )-reachable 
in W because it satisﬁes the ﬁrst of the two alternative conditions for reachability
as given in Section 4.3.

If uctx 6= u, then, given that u ∈ [[lpe cAll]]uctx

W , there exists a nonempty sequence of

link graph edges

hd1, (t1, u1), d′

1i ∈ GW ,

hd2, (t2, u2), d′

2i ∈ GW ,

... ,

hdn, (tn, un), d′

ni ∈ GW

such that

– d1 = adoc(uctx),
– d′
– d′

i = di+1 for all i ∈ {1, ... , n − 1}, and
n = dLPE (and un = u).

Then, since d1 = adoc(uctx) and uctx ∈ S, we have that document d1 is (cAll, S, P )-
reachable in W (the document satisﬁes the ﬁrst of the two conditions for reachability
as given in Section 4.3). As a consequence, we can use the fact that d′
i = di+1 for all
i ∈ {1, ... , n − 1} to show that all other documents connected by the sequence of link
graph edges are also (cAll, S, P )-reachable in W (they satisfy the second condition).
Therefore, due to d′

n = dLPE, document dLPE is (cAll, S, P )-reachable in W.

is (cAll, S, P )-reachable in W, we conclude that the set DcAll
(cAll, S, P )-reachable documents in W. It remains to show that DcAll

After showing that in both cases, uctx = u and uctx 6= u, document dLPE ∈ DcAll
LPE
LPE is a subset of the set of all
LPE is also a superset.
To this end, let dR be a document that is (cAll, S, P )-reachable in W. We have to
show that dR is in DcAll
LPE. We note that document dR may be (cAll, S, P )-reachable in
W because it satisﬁes either the ﬁrst or the second of the two alternative conditions for
reachability as given in Section 4.3. In the following, we discuss both cases.

If dR satisﬁes the ﬁrst condition, there exists a URI uR ∈ S such that adoc(uR) = dR.
W . Therefore, we can use URI uR

i∗, we also have uR ∈ [[lpe cAll]]uR

,

Since lpe cAll is h
as both uctx and u in the deﬁnition of DcAll

,

LPE, which shows that dR ∈ DcAll
LPE.

If dR satisﬁes the second condition, then there exist both a seed URI u0 ∈ S and a

nonempty sequence of link graph edges

hd1, (t1, u1), d′

1i ∈ GW ,

hd2, (t2, u2), d′

2i ∈ GW ,

... ,

hdn, (tn, un), d′

ni ∈ GW

such that

– d1 = adoc(u0),
– d′
– d′

i = di+1 for all i ∈ {1, ... , n − 1}, and
n = dR and, thus, dR = adoc(un).

Moreover, every such link graph edge hdj, (tj, uj), d′
in the context of URI uj−1 (1 ≤ j ≤ n). Therefore, since lpe cAll is h
un ∈ [[lpe cAll ]]u0
uctx in the deﬁnition of DcAll

i
i∗, we have
W . Then, with dR = adoc(un) and u0 ∈ S, we can use un as u and u0 as

LPE, which shows that dR ∈ DcAll
LPE.

ji matches link pattern h

In conclusion, independent of whether dR satisﬁes the ﬁrst or the second condition
for being (cAll, S, P )-reachable in W, we ﬁnd that dR ∈ DcAll
LPE is not only
a subset of all (cAll, S, P )-reachable documents in W, but also a superset thereof, which
shows that both sets are equivalent (as claimed in Lemma 4).

LPE. Hence, DcAll

,

,

,

,

cNone-semantics: To prove Lemma 4 for cNone we show that the set DcNone
subset and a superset of the set of all (cNone, S, P )-reachable documents in W.
To begin with the former, assume an arbitrary document in dLPE ∈ DcNone

to show that this document is (cNone, S, P )-reachable in W. Since dLPE ∈ DcAll
know that there exist two URIs, uctx and u, such that

LPE . We have
LPE, we

LPE is both a

– uctx ∈ S,
– u ∈ [[lpe cNone ]]uctx
– dLPE = adoc(u).

W , and

Given that lpe cNone is ε, by u ∈ [[lpe cNone]]uctx
W and Deﬁnition 5, we obtain that u =
uctx and, thus, dLPE = adoc(uctx). Therefore, document dLPE is (cNone, S, P )-reachable
in W because it satisﬁes the ﬁrst of the two alternative conditions for reachability as
given in Section 4.3. As a consequence, we can conclude that the set DcNone
LPE is a subset
of the set of all (cNone, S, P )-reachable documents in W.

To show that DcNone

LPE is also a superset, let dR be an arbitrary document that is
(cNone, S, P )-reachable in W. We have to show that dR is in DcNone
LPE . We note that dR can
be (cNone, S, P )-reachable in W only if it satisﬁes the ﬁrst of the two alternative conditions 
for reachability as given in Section 4.3 (for cNone, the second condition cannot be
satisﬁed by any document because cNone(t, u, P ) = false for all ht, u, P i ∈ T ×U ×P).
Therefore, given that dR satisﬁes the ﬁrst condition, there exists a URI uR ∈ S such
that adoc(uR) = dR. Since lpe cNone is ε, we also have uR ∈ [[lpe cNone]]uR
W . Therefore,
we can use URI uR as both uctx and u in the deﬁnition of DcNone
LPE and, thus, obtain that
dR ∈ DcNone
LPE is a superset of the set of all (cNone, S, P )-
reachable documents in W. Since we have shown before that DcNone
LPE is also a subset of
the set of all documents that are (cNone, S, P )-reachable in W, we conclude that both
sets are equivalent. Hence, Lemma 4 holds for reachability criterion cNone.

LPE , which shows that the set DcNone

cMatch-semantics:
that the set DcMatch
(cMatch, S, P )-reachable in W. As before, we begin with the former.

It remains to prove Lemma 4 for cMatch. To this end, we show
LPE is both a subset and a superset of the set of all documents that are

Let dLPE be an arbitrary document in DcAll

is (cMatch, S, P )-reachable in W. Since dLPE ∈ DcMatch
DcMatch

LPE (as given in Lemma 4) that there exist two URIs, uctx and u, such that

LPE. We have to show that this document
LPE , we know by the deﬁnition of

– uctx ∈ S,
– u ∈ [[lpe cMatch]]uctx
– dLPE = adoc(u).

W , and

Given that u ∈ [[lpe cMatch]]uctx
and a corresponding sequence of documents d0, d1, ... , dn such that

W , there exists a nonempty sequence of URIs u0, u1, ... , un

– di = adoc(ui) for each i ∈ {0, ... , n},
– u0 = uctx,
– un = u (and, thus, dn = dLPE), and
– for each i ∈ {1, ... , n}, there exists a triple pattern tpk in P (1 ≤ k ≤ m) such
W where ?v ∈ {?s, ?p, ?o} and qk is the LDQL query that

that ui ∈ [[h?v, qki]]ui−1
corresponds to tpk as speciﬁed in the deﬁnition of lpe cMatch above.

We show by induction over n that all n+1 documents, d0, d1, ... , dn, are (cMatch, S, P )-

reachable in W, and, thus, so is dLPE = dn.

Base case (n = 0): d0 is (cMatch, S, P )-reachable in W because d0 = adoc(u0),
u0 = uctx, and uctx ∈ S; i.e., d0 satisﬁes the ﬁrst condition as speciﬁed in Section 4.3.
Induction step (n > 0): By induction, we assume that document dn-1 is (cMatch, S, P )-
reachable in W. To show that dn is also (cMatch, S, P )-reachable in W we aim to show
that dn satisﬁes the second condition for reachability as given in Section 4.3. That
is, we aim to show that there exists a link graph edge hdsrc, (t, u), dtgti ∈ GW such
that (i) dsrc is (cMatch, S, P )-reachable in W, (ii) cMatch(t, u, P ) = true, (iii) u = un,
and (iv) dtgt = dn. Let dsrc be dn-1, which is (cMatch, S, P )-reachable in W by our
inductive hypothesis. Hence, it remains to show the existence of a link graph edge
hdn-1, (t, un), dni ∈ GW for which cMatch(t, un, P ) = true. To this end, we use the
fourth of the four aforementioned properties of the sequence of URIs u0, u1, ... , un.

Let tpk = hsk, pk, oki be a triple pattern in P such that un ∈ [[h?v, qki]]un−1

W where
?v ∈ {?s, ?p, ?o} and qk is the LDQL query that corresponds to tpk as speciﬁed in the
deﬁnition of lpe cMatch above; i.e., qk is a basic LDQL query of the form hε, Pki where
SPARQL pattern Pk contains the triple pattern h?s, ?p, ?oi and (i) if sk /∈ V, then Pk
contains FILTER ?s = sk, (ii) if pk /∈ V, then Pk contains FILTER ?p = pk, and (iii) if
ok /∈ V, then Pk contains FILTER ?o = ok.

Since un ∈ [[h?v, qki]]un−1

W , by Deﬁnition 5, there exists a solution mapping µ such
that µ ∈ [[qk]]{un−1}
and µ(?v) = un. Moreover, since qk is of the form hε, Pki, we
W
have µ ∈ [[Pk]]D
G where D = datasetW ({un−1}) with default graph G = data(dn−1).
Then, due to the construction of Pk, it is easily veriﬁed that there exists an RDF
triple t ∈ data(dn−1) such that µ[tpk] = t and un ∈ uris(t). As a consequence,
(i) cMatch(t, un, tpk) = true and (ii) by Deﬁnition 2, there exists a link graph edge

hdn−1, (t, un), dni ∈ GW . Finally, since tpk is a triple pattern in P , we also have
cMatch(t, un, P ) = true.
While this concludes showing that the set DcMatch
that are (cMatch, S, P )-reachable in W, we now show that it is also a superset thereof.

LPE is a subset of the set of all documents

Let dR be a document that is (cMatch, S, P )-reachable in W. We have to show that dR
LPE . Since dR is (cMatch, S, P )-reachable in W, there exist a nonempty sequence

is in DcMatch
of URIs u0, u1, ... , un, a corresponding sequence of documents

d0 = adoc(u0),

d1 = adoc(u1),

d2 = adoc(u2),

... ,

dn = adoc(un),

and a corresponding sequence of link graph edges

hd′

1, (t1, u1), d1i ∈ GW ,

hd′

2, (t2, u2), d2i ∈ GW ,

... ,

hd′

n, (tn, un), dni ∈ GW

such that

– u0 ∈ S,
– cMatch(ti, ui, P ) = true for all i ∈ {1, ... , n},
– d′
i = di−1 for all i ∈ {1, ... , n}, and
– dn = dR and, thus, dR = adoc(un).

We aim to show that each of the n + 1 documents, d0, d1, d2, ... , dn, is in DcMatch
LPE ,
and, thus, so is dR = dn. To this end, it is sufﬁcient to show that each of the n + 1 URIs,
u0, u1, ... , un, is in [[lpe cMatch]]u0
W . Then, with u0 ∈ S, for each i ∈ {0, ... , n} we can
use URI ui as u and u0 as uctx in the deﬁnition of DcMatch
LPE , which shows that document
di = adoc(ui) is in DcMatch

LPE . We use proof by induction.

lpe cMatch = (cid:0)lpe cMatch

to show that un is also in [[lpe cMatch]]u0
where lpe cMatch
step

step (cid:1)∗. Due to the existence of link graph edge hd′

Base case (n = 0): Since lpe cMatch is of the form (·)∗, we have u0 ∈ [[lpe cMatch]]u0
W .
Induction step (n > 0): By induction, we assume that un−1 ∈ [[lpe cMatch]]u0
W , it is sufﬁcient to show that un is in [[lpe cMatch

W . Then,
step ]]un−1
is h?s, q1i | h?p, q1i | h?o, q1i | ... | h?s, qmi | h?p, qmi | h?o, qmi such that
n, (tn, un), dni ∈ GW
with d′
n = dn−1, we know by Deﬁnition 2 that there exists a triple tn ∈ data(dn−1)
with un ∈ uris(tn). Moreover, since cMatch(tn, un, P ) = true, there exist both a triple
pattern tpk in P and a solution mapping µ such that µ[tpk] = tn. Then, given the
LDQL query qk = hε, Pki that is constructed for tpk as speciﬁed in the deﬁnition of
lpe cMatch, it easy to verify that there exists a solution mapping µ′ such that µ′ ∈ [[Pk]]D
G
and µ′(?v) = un, where ?v ∈ {?s, ?p, ?o} and D = datasetW ({un−1}) with default
graph G = data(dn−1). Then, by Deﬁnition 5, we also have µ′ ∈ [[qk]]{un−1}
and,
thus, un ∈ [[h?v, qki]]un−1
step , we also obtain
un ∈ [[lpe cMatch

W

W . Since h?v, qki is a disjunct in lpe cMatch

W

step ]]un−1

W and, thus, un ∈ [[lpe cMatch]]u0
W .

As argued before, as a consequence of un ∈ [[lpe cMatch]]u0

W (and u0 ∈ S), we can
show that document dR = adoc(un) is in DcMatch
LPE by using un as u and u0 as uctx in the
deﬁnition of DcMatch
LPE is not only a subset of the
set of all documents that are (cMatch, S, P )-reachable in W (as shown before), but also
a superset. Hence, both sets are equivalent and, thus, Lemma 4 holds for cMatch.

LPE (cf. Lemma 4). Therefore, the set DcMatch

A.9 Proof of Theorem 6

In the proof we use the following simple LDQL query Q(?x) given by

We prove ﬁrst that the reachability criterion cNone cannot express Q(?x). On the

(cid:10)h+, p,

i, (?x, ?x, ?x)(cid:11).

contrary, assume that there exists a SPARQL pattern P such that

[[P ]]R(cNone,S)

W

= [[Q(?x)]]S
W

for every S and W . Let u, u′, a, b be different elements in U that are not mentioned in P .
Consider now W1 having only two documents d1 = {(u, p, u′)} and d2 = {(a, a, a)}
and such that adoc(u) = d1 and adoc(u′) = d2. Moreover, consider W2 having also
two documents d1 = {(u, p, u′)} and d3 = {(b, b, b)} such that adoc(u) = d1 and
adoc(u′) = d3. First notice that

[[Q(?x)]]{u}

W1 = {{?x → a}} 6= [[Q(?x)]]{u}

W2 = {{?x → b}}

It is easy to see that [[P ]]R(cNone,{u})
. Just notice that from {u}, the
set of reachable documents following the cNone criterium is the same set {d1} in both
W1 and W2. Thus we have that [[P ]]R(cNone,{u})
6=
[[Q(?x)]]{u}

which is a contradiction.

= [[P ]]R(cNone,{u})

= [[P ]]R(cNone,{u})

but [[Q(?x)]]{u}

W1

W2

W1

W2

W1

W2

To continue with the proof, we now show that the reachability criterion cAll cannot
express Q(?x). To obtain a contradiction, assume that there exists a pattern P such that

[[P ]]R(cAll,S)

W

= [[Q(?x)]]S
W

for every S and W . Let u, u′, a, b be different elements in U that are not mentioned in P .
Consider now W1 = ({d1, d2, d3}, adoc1) having three documents d1 = {(u, p, u′)},
d2 = {(a, a, a)} and d3 = {(b, b, b)} and such that adoc1(u) = d1, adoc1(u′) = d2
and adoc1(a) = d3. Moreover, consider W2 = ({d1, d2, d3}, adoc2) having exactly the
same documents as W1, and such that adoc2(u) = d1, adoc2(u′) = d3 and adoc2(b) =
d2. First notice that

[[Q(?x)]]{u}

W1 = {{?x → a}} 6= [[Q(?x)]]{u}

W2 = {{?x → b}}.

Now notice that from {u}, the set of reachable documents in W1 following the cAll
criterium is the set {d1, d2, d3}; d1 is the document associated to u, d2 is reachable
from d1 via the URI u′, and d3 is reachable from d2 via the URI a. Moreover, the set
reachable documents from {u} in W2 is also {d1, d2, d3}; d1 is the document associated
to u, d3 is reachable from d1 via the URI u′, and d2 is reachable from d3 via URI b.
Given that the set of reachable documents is the same in both W1 and W2 we have
[[P ]]R(cAll,{u})
we obtain our
desired contradiction.

. Given that [[Q(?x)]]{u}

= [[P ]]R(cAll,{u})

6= [[Q(?x)]]{u}

W1

W2

W1

W2

We consider now the case of cMatch, and prove that it cannot express Q(?x). To

obtain a contradiction, assume that there exists a pattern P such that

[[P ]]R(cMatch,S)

W

= [[Q(?x)]]S
W

for every S and W . Let u, u′, u′′, a be different elements in U that are not mentioned
in P . Consider now W1 having two documents d1 = {(u, p, u′)} and d2 = {(a, a, a)}
and such that adoc(u) = d1 and adoc(u′) = d2. Moreover, consider W2 having also
two documents d′
1 and
adoc(u′) = d′

2 = {(a, a, a)} such that adoc(u) = d′

1 = {(u′′, p, u′)} and d′

2. First notice that

[[Q(?x)]]{u}

W1 = {{?x → a}} 6= [[Q(?x)]]{u}

W2 = ∅.

W2

W1

= [[P ]]R(cMatch,{u})

We prove now that [[P ]]R(cMatch,{u})
. Now given that d1 is the document 
associated to u in W1, we have that d1 is (cMatch, {u}, P )-reachable in W1. Similarly,
 we know that d′
1 is (cMatch, {u}, P )-reachable in W2. Moreover, given that P does
not mention u, u′ and u′′ we have that (u, p, u′) matches a triple pattern in P if and only
if (u′′, p, u′) matches a triple pattern in P . Thus we have that d2 is (cMatch, {u}, P )-
reachable in W1 if and only if d′
2 is (cMatch, {u}, P )-reachable in W2. Thus we have
only two cases, either

– {d1} is the set of (cMatch, {u}, P )-reachable documents in W1, and {d′

1} is the set

of (cMatch, {u}, P )-reachable documents in W2, or

– {d1, d2} is the set of (cMatch, {u}, P )-reachable documents in W1, and {d′

1, d′

2} is

the set of (cMatch, {u}, P )-reachable documents in W2.

W1

W2

In the ﬁrst case we have that [[P ]]R(cMatch,{u})
is obtained by evaluating P over graph
G1 = {(u, p, u′)}, and that [[P ]]R(cMatch,{u})
is obtained by evaluating P over graph
G2 = {(u′′, p, u′)}. Given that P does not mention u, u′ and u′′ we obtain that the
evaluation of P over G1 is the same as the evaluation of P over G2 which implies
that [[P ]]R(cMatch,{u})
is obtained
by evaluating P over graph G1 = {(u, p, u′), (a, a, a)}, and [[P ]]R(cMatch,{u})
is obtained 
by evaluating P over graph G2 = {(u′′, p, u′), (a, a, a)}. For the same reason
as above we have that the evaluation of P is the same over G1 and over G2 which
implies that [[P ]]R(cMatch,{u})
=
[[P ]]R(cMatch,{u})

. We have proved that [[P ]]R(cMatch,{u})
which is our desired contradiction.

. In the second case, [[P ]]R(cMatch,{u})

, while [[Q(?x)]]{u}

= [[P ]]R(cMatch,{u})

= [[P ]]R(cMatch,{u})

W1 6= [[Q(?x)]]{u}

W1

W1

W2

W2

W2

W1

W2

W2

W1

A.10 Proof of Proposition 2

Property 1 Let q be an arbitrary basic LDQL query of the form hlpe, P i such that
lpe is Web-safe. To show that q is Web-safe we provide Algorithm 1. In line 3 the
algorithm calls a subroutine, EXECLPE, that evaluates a given LPE in the context of
a given URI (cf. Algorithm 2). The correctness of the algorithm and its subroutine is
easily checked. Moreover, a trivial proof by induction on the possible structure of LPEs
can show that for any Web-safe LPE, the given subroutine looks up a ﬁnite number of
URIs only. The crux of such a proof is twofold: First, the evaluation of LPEs of the form
lpe ∗ (lines 26 to 34 in Algorithm 2) is guaranteed to reach a ﬁxed point for any ﬁnite
Web of Linked Data. Second, the evaluation of LPEs of the form h?v, qi (lines 38 to
42) uses an algorithm for subquery q that has the properties as required in Deﬁnition 6.
Due to the Web-safeness of the given LPE and, thus, of q, such an algorithm exists.

Φ := Φ ∪ EXECLPE(lpe, u)

Algorithm 1 Execution of a basic LDQL query hlpe, P i using a set S of URIs as seed.
1: Φ := a new empty set of URIs
2: for all u ∈ S do
3:
4: end for
5: G := a new empty set of RDF triples (i.e., an empty RDF graph)
6: N := a new empty set of pairs consisting of a URI and an RDF graph
7: for all u ∈ Φ do
8:
9:
10:
end if
11:
12: end for
13: return [[P ]]hG,N i

if looking up URI u results in retrieving a document, say d then

G := G ∪ data(d)
N := N ∪ {hu, data(d)i}

G

// [[P ]]hG,N i
// the standard (set-based) SPARQL evaluation function [2]

can be computed by using any algorithm that implements

G

Property 2 First, let q be an LDQL query of the form πV q′ such that subquery q′ is
Web-safe. Due to the Web-safeness of q′, there exists an algorithm for q′ that has the
properties as required in Deﬁnition 6. We may use this algorithm to construct an algorithm 
for q; that is, our algorithm for q calls the algorithm for q′, applies the projection
operator to the result, and returns the set of solution mappings resulting from this projection.
 Since the application of the projection operator does not involve URI lookups,
the constructed algorithm for q has the properties as required in Deﬁnition 6. Second,
let q be an LDQL query of the form (SEED U q′) such that q′ is Web-safe. Hence, there
exists an algorithm for q′ that has the properties as required in Deﬁnition 6. Then, showing 
the Web-safeness of q is trivial because the algorithm for q′ can also be used for q.

Property 3 Let q be an LDQL query of the form (q1 UNION ... UNION qn) such that
each subquery qi (1 ≤ i ≤ n) is Web-safe. Hence, for each subquery qi, there exists an
algorithm that has the properties as required in Deﬁnition 6. Then, the Web-safeness of
query q is easily shown by specifying another algorithm that calls the algorithms of the
subqueries sequentially and unions their results.

A.11 Proof of Lemma 3

Lemma 3 follows from Deﬁnition 7 and Buil-Aranda et al.’s result [4, Proposition 1].

A.12 Proof of Theorem 7

We prove Theorem 7 based on Algorithm 3, which is an iterative algorithm that generalizes 
the execution strategy outlined for query q′′
ex in Example 6. That is, the algorithm
executes the subqueries q1, q2, ... , qm sequentially in the order ≺ such that each iteration 
step (lines 2 to 24) executes one of the subqueries by using the solution mappings
computed during the previous step (which are passed on via the sets Ω0, Ω1, ... , Ωm).

Algorithm 2 EXECLPE(lpe, uctx)
1: if looking up URI uctx results in retrieving a document, say dctx then
2:
3:

return a new singleton set {uctx}

if lpe is ε then

4:
5:

6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:

17:
18:
19:
20:
21:

22:
23:
24:
25:

26:
27:
28:
29:
30:
31:
32:
33:
34:

35:
36:
37:

38:
39:

40:
41:
42:

43:

else if lpe is a link pattern lp = hy1, y2, y3i then

1, y′

2, y′

3i, where hy′

lp′ := hy′
occurrence of symbol + in lp is replaced by URI uctx
Φ := a new empty set of URIs
for all hx1, x2, x3i ∈ data(dctx) do

1, y′

2, y′

3i is a link pattern generated from lp such that any

if (y′

1 = x1 or y′
for all i ∈ {1, 2, 3} do

1 = ) and (y′

2 = x2 or y′

2 = ) and (y′

3 = x3 or y′

3 = ) then

if y′

i = and xi is a URI whose lookup retrieves a document then
Φ := Φ ∪ {xi}

end if
end for

end if
end for
return Φ

else if lpe is of the form lpe 1/lpe 2 then

Φ′ := EXECLPE(lpe1, uctx)
Φ := a new empty set of URIs
for all u′ ∈ Φ′ do Φ := Φ ∪ EXECLPE(lpe2, u′) end for
return Φ

else if lpe is of the form lpe 1|lpe 2 then

Φ1 := EXECLPE(lpe1, uctx)
Φ2 := EXECLPE(lpe2, uctx)
return Φ1 ∪ Φ2

else if lpe is of the form l∗ then

Φcur := EXECLPE(ε, uctx)
lpe ′ := l
repeat

Φprev := Φcur
Φcur := Φcur ∪ EXECLPE(lpe′, uctx)
lpe ′ := an LPE of the form lpe′/l

until Φcur = Φprev
return Φcur

else if lpe is of the form [lpe ′] then

Φ := EXECLPE(lpe′, uctx)
if Φ 6= ∅ then return a new singleton set {uctx} else return a new empty set end if

else if lpe is of the form h?v, qi then

Ω := EXEC(q, {uctx})

// where EXEC denotes an arbitrary algorithm that can be used
// to compute the {uctx}-based evaluation of q over the queried
// Web of Linked Data

Φ := a new empty set of URIs
for all µ ∈ Ω for which ?v ∈ dom(µ) and µ(?v) ∈ U do Φ := Φ ∪ {µ(?v)} end for
return Φ

end if

44: else
45:
46: end if

return a new empty set

Algorithm 3 Execution of an LDQL query q of the form (q1 AND q2 AND ... AND qm)
using a ﬁnite set S of URIs as seed.
Require: m ≥ 1
Require: LDQL query q is given as an array Q consisting of all subqueries of q such that
the order of the subqueries in this array satisﬁes the conditions as given in Theorem 7.

1: Ω0 := {µ∅}, where µ∅ is the empty solution mapping; i.e., dom(µ∅) = ∅
2: for j := 1, ... , m do

3:
4:

5:
6:
7:
8:
9:
10:
11:

12:
13:
14:

15:

16:
17:
18:
19:
20:
21:
22:
23:

Ωtmp := a new empty set of solution mappings
qj := the j-th subquery in array Q

if qj is of the form (SEED ?v q′) then

Utmp := a new empty set of URIs
for all µ ∈ Ωj−1 do

if µ(?v) is a URI then Utmp := Utmp ∪ {µ(?v)} end if

end for
for all u ∈ Utmp do

Ωtmp := Ωtmp ∪ EXEC(q′,{u}) // where EXEC denotes an arbitrary algorithm that
// can be used to compute the {u}-based evaluation
// of q′ over the queried Web of Linked Data

end for

else

Ωtmp := EXEC(qj, S)

end if

// where EXEC denotes an arbitrary algorithm that can
// be used to compute the S-based evaluation of qj
// over the queried Web of Linked Data

Ωj := a new empty set of solution mappings
for all µ ∈ Ωj−1 do

for all µ′ ∈ Ωtmp do

if µ and µ′ are compatible then

Ωj := Ωj ∪ {µjoin}, where µjoin = µ ∪ µ′

end if
end for

end for

24: end for
25: return Ωm

To prove that Algorithm 3 has the properties as required in Deﬁnition 6 we have to
show that the algorithm is sound and complete (i.e., for any ﬁnite set S of URIs and
W ) and that it is guaranteed to
any Web of Linked Data W, the algorithm returns [[q]]S
look up a ﬁnite number of URIs only. We show these properties by induction on the m
iteration steps performed by the algorithm. To this end, we assume that the indices as
used for the subqueries q1, q2, ... , qm reﬂect the order ≺, that is, subquery q1 is the ﬁrst
according to ≺, subquery q2 is the second, and so on.

Base Case (m = 1): By the conditions in Theorem 7, the ﬁrst subquery (according
to ≺) must be Web-safe and, thus, cannot be of the form (SEED ?v q′). Hence, the

algorithm enters the corresponding else-branch (line 14). Due to the Web-safeness of
q1, there exists an algorithm for subquery q1, say A1, that has the properties as required
in Deﬁnition 6. Algorithm 3 uses algorithm A1 to obtain Ωtmp = [[q1]]S
W (where W is
the queried Web of Linked Data), which requires only a ﬁnite number of URI lookups.
Thereafter, Algorithm 3 computes Ω1 = Ω0 ⋊⋉ Ωtmp (lines 16 to 23) and returns
Ω1 (line 25), which does not require any more URI lookups. Hence, for m = 1, the
algorithm looks up a ﬁnite number of URIs (if the queried Web of Linked Data is ﬁnite).
Since Ω0 contains only the empty solution mapping µ∅ (line 1), which is compatible
with any other solution mapping, we have Ω1 = Ωtmp and, thus, Ω1 = [[q1]]S

Induction Step (m > 1): By induction we assume that after completing the (m–1)-
th iteration, the algorithm has looked up a ﬁnite number of URIs only and the current
intermediate result Ωm−1 covers the conjunction of subqueries q1, q2, ... , qm−1; that is,
W . We show that the m-th iteration also looks
Ωm−1 = [[(q1 AND q2 AND ... AND qm−1)]]S
up a ﬁnite number of URIs only and that Ωm = [[(q1 AND q2 AND ... AND qm)]]S

W .

W .

If subquery qm is Web-safe, it is not difﬁcult to see these properties: Since qm is
Web-safe, there exists an algorithm for qm, say Am, that has the properties as required
in Deﬁnition 6. The corresponding call of algorithm Am in line 14 of Algorithm 3
looks up a ﬁnite number of URIs only, and the subsequent join computation in lines
16 to 23 does not require any more lookups. Moreover, the result of calling algorithm
Am in line 14 is Ωtmp = [[qm]]S
W and, since the subsequent join computation returns
Ωm = Ωm−1 ⋊⋉ Ωtmp, we have Ωm = [[(q1 AND q2 AND ... AND qm)]]S

W , as desired.

1 ∪ µ∗

It remains to discuss the case of subquery qm being of the form (SEED ?v q′),
where, by the conditions in Theorem 7, subquery q′ is Web-safe. Hence, there exists 
an algorithm for q′, say A′, that has the properties as required in Deﬁnition 6.
In this case, Algorithm 3 ﬁrst iterates over all solution mappings in Ωm−1 to populate 
a set Utmp with all URIs that any of these mappings binds to variable ?v (lines 6
to 9). Due to the ﬁniteness assumed for all queried Webs of Linked Data (cf. Definition 
6), Ωm−1 is ﬁnite. Hence, the resulting set Utmp contains a ﬁnite number of
URIs. Therefore, the subsequent loop in lines 10 to 12 calls algorithm A′ a ﬁnite
number of times and, thus, the m-th iteration looks up a ﬁnite number of URIs only.
To show the remaining claim, Ωm = [[(q1 AND q2 AND ... AND qm)]]S
W , we ﬁrst show
W . Let µjoin be an arbitrary solution mapping in
Ωm ⊆ [[(q1 AND q2 AND ... AND qm)]]S
Ωm; i.e., µjoin ∈ Ωm. By lines 17 to 23, there exist solution mappings µ and µ′ such that
[[q′]]{u}
W ,
(i) µ ∈ Ωm−1 = [[(q1 AND q2 AND ... AND qm−1)]]S
(iii) µ and µ′ are compatible, and (iv) µjoin = µ ∪ µ′. Then, by Deﬁnition 5, we have
W .
µjoin ∈ [[(q1 AND q2 AND ... AND qm)]]S
W . Assume an arbitrary soluFinally,
 we show Ωm ⊇ [[(q1 AND q2 AND ... AND qm)]]S
tion mapping µ∗ ∈ [[(q1 AND q2 AND ... AND qm)]]S
W . Then, by Deﬁnition 5, there exist
two solution mappings µ∗
2 such that (i) µ∗
W ,
1 ∈ [[(q1 AND q2 AND ... AND qm−1)]]S
(ii) µ∗
2 are compatible, and (iv) µ∗ = µ∗
W , (iii) µ∗
2. By our induction 
hypothesis, we have µ∗
1 ∈ Ωm−1. Then, given lines 17 to 23, we have to show
that µ∗
2 ∈ Ωtmp where Ωtmp is the set of solution mappings computed during the m-th
[[q′]]{u}
W }.
2 ∈ Ωtmp we show that there exists a URI u ∈ Utmp such that µ∗
2

W
where Utmp = {u ∈ U | µ(?v) = u for some µ ∈ [[(q1 AND q2 AND ... AND qm−1)]]S
Hence, to show that µ∗

iteration. Since qm is of the form (SEED ?v q′), it holds that Ωtmp = Su∈Utmp

W , (ii) µ′ ∈ Ωtmp = Su∈Utmp

W and, thus, Ωm ⊆ [[(q1 AND q2 AND ... AND qm)]]S

1 and µ∗
1 and µ∗

2 ∈ [[qm]]S

W , by Deﬁnition 5, solution mapping µ∗

2) and µ∗

2 ∈ [[qm]]S

W . Since µ∗

is in [[q′]]{u}
?v to a URI, say u∗; i.e., ?v ∈ dom(µ∗
by Lemma 3 and the condition in Theorem 7 (i.e., ?v ∈ Sqk≺qm
1 also has a binding for variable ?v, and, since µ∗

mapping µ∗
these bindings are the same, that is, µ∗
holds that u∗ ∈ Utmp. Then, by Deﬁnition 5, we obtain that µ∗
that µ∗

1(?v) = µ∗

2 binds variable
2(?v) = u∗ with u∗ ∈ U. Furthermore,
sbvars(qk)), solution
2 are compatible,
2(?v) it
W , which shows
W .

2(?v). Hence, for URI u∗ = µ∗

2 ∈ [[q′]]{u}

1 and µ∗

2 ∈ Ωtmp and, thus, we can conclude that Ωm ⊇ [[(q1 AND q2 AND ... AND qm)]]S

A.13 Proof of Corollary 1

Corollary 1 is an immediate consequence of Lemma 2.

