The Inverse of a Schema Mapping
Jorge Pérez

Department of Computer Science, Universidad de Chile
Blanco Encalada 2120, Santiago, Chile
jperez@dcc.uchile.cl

Abstract

The inversion of schema mappings has been identiﬁed as one of the fundamental operators for the
development of a general framework for data exchange, data integration, and more generally, for
metadata management. Given a mapping M from a schema S to a schema T, an inverse of M
is a new mapping that describes the reverse relationship from T to S, and that is semantically
consistent with the relationship previously established by M. In practical scenarios, the inversion
of a schema mapping can have several applications. For example, in a data exchange context, if
a mapping M is used to exchange data from a source to a target schema, an inverse of M can
be used to exchange the data back to the source, thus reversing the application of M.

The formalization of a clear semantics for the inverse operator has proved to be a very
diﬃcult task. In fact, during the last years, several alternative notions of inversion for schema
mappings have been proposed in the literature. This chapter provides a survey on the diﬀerent
formalizations for the inverse operator and the main theoretical and practical results obtained so
far. In particular, we present and compare the main proposals for inverting schema mappings that
have been considered in the literature. For each one of them we present their formal semantics
and characterizations of their existence. We also present algorithms to compute inverses and
study the language needed to express such inverses.

1998 ACM Subject Classiﬁcation H.2.5 [Heterogeneous Databases]: Data translation

Keywords and phrases Schema mappings, data exchange, inverse

Digital Object Identiﬁer 10.4230/DFU.Vol5.10452.69

1

Introduction

A schema mapping is a speciﬁcation that describes how data from a source schema is to
be mapped to a target schema. Schema mappings are of fundamental importance in data
management today. In particular, they have proved to be the essential building block for
several data-interoperability tasks such as data exchange, data integration and peer data
management.

In recent years, the research on the schema mapping area has mainly focused on performing 
data-interoperability tasks using schema mappings. However, as Bernstein [12] pointed
out, many information-system problems involve not only the design and integration of complex 
application artifacts, but also their subsequent manipulation. Notice that the creation
of a schema mapping may imply considerable work by an expert who needs to know the
semantics of the schema components. Only an expert can establish a meaningful high-level
correspondence between those components. Thus, a schema mapping reﬂects the knowledge 
of the expert about the relationship between the schemas. This knowledge could, in
principle, be reused beyond the interoperability tasks for which the mapping was initially
created. Driven by these considerations, Bernstein [12] proposed a general framework for
managing and reusing schema mappings.

© Jorge Pérez;
licensed under Creative Commons License CC-BY

Data Exchange, Integration, and Streams. Dagstuhl Follow-Ups, Volume 5, ISBN 978-3-939897-61-3.
Editors: Phokion G. Kolaitis, Maurizio Lenzerini, and Nicole Schweikardt; pp. 69–95

Dagstuhl Publishing
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Germany

70

The Inverse of a Schema Mapping

In Bernstein’s framework [12], schema mappings are ﬁrst class citizens, and high-level
algebraic operators are used to manipulate and reuse them. One of the most fundamental
operators in schema mapping management is the inversion of schema mappings. Given a
mapping M from a schema A to a schema B, an inverse of M is a new mapping that
describes the reverse relationship from B to A, and that is semantically consistent with the
relationship previously established by M. Notice that this is a very general idea of what an
inverse of a schema mapping should be. In fact, even the formalization of a clear semantics
for the inverse operator has proved to be a very diﬃcult task [16, 17, 20, 21, 10, 11, 22, 6].
This chapter provides a survey on the diﬀerent formalizations in the literature for the inverse
operator on schema mappings and the study of the theoretical problems that arise. Before
going into the details of these works, let us give a bit more intuition on how the inverse of
schema mappings can be useful in practice.

In practical scenarios, the inversion of schema mappings can have several applications.
In a data exchange context [18], if a mapping M is used to exchange data from a source to
a target schema, an inverse of M can be used to exchange the data back to the source, thus
reversing the application of M. As a second application, consider a peer data management
system (PDMS) [14, 26].
In a PDMS, a peer can act as a data source, a mediator, or
both, and the system relates peers by establishing mappings between the peers’ schemas.
Mappings between peers are usually directional, and are used to reformulate queries. For
example, if there is a mapping M from peer P1 to peer P2 and a query over P2, a PDMS
can use M to reformulate the query by using P1 as a source. Hence, an inverse of M would
allow the PDMS to reformulate a query over P1 in terms of P2, thus considering this time
P2 as a source. Another application is schema evolution, where the inverse together with
the composition play a crucial role [13, 23]. Consider a mapping M between schemas A and
B, and assume that schema A evolves into a schema A0. This evolution can be expressed
as a mapping M0 between A and A0. Thus, the relationship between the new schema A0
and schema B can be intuitively obtained by inverting mapping M0 and then composing
the result with mapping M.

As we have mentioned before, in the study of the inverse operator, one of the key issues
is to provide a good semantics for this operator, which turned out to be a diﬃcult problem.
After deﬁning a semantics, some of the important questions that need to be answered are:

Existence For which classes of mappings is the inverse guaranteed to exist?
Expressiveness What is the mapping language needed to specify an inverse?
Algorithmic How can we eﬀectively construct an inverse?

In this chapter, we present and compare the main proposals for inverting schema mappings 
that have been considered in the literature, and for each one of them we present the
main results regarding these three issues.
In Section 2 we present the notion of inverse
proposed by Fagin [16], that we call here Fagin-inverse1, which is the ﬁrst formal notion of
inverse proposed in the literature. In Section 3 we present the notion of quasi-inverse [20, 21]
which is obtained by relaxing the notion of Fagin-inverse. Section 4 presents the notions
of recovery and maximum recovery [10, 11] which were proposed as alternative notions for
inverting schema mappings. In Section 5 we present procedures to compute inverses and
discuss expressiveness issues, more importantly, the issue of what the language needed to

1 Fagin [17] named his notion just as inverse of a schema mapping. Since in this chapter we are introducing 
several diﬀerent semantics for the inverse operator, we reserve the term inverse to refer to this
operator in general, and use the name Fagin-inverse for the notion proposed by Fagin [17].

J. Pérez

71

express inverses is.
In Section 6 we present a relaxation of the notions of recovery and
maximum recovery based on certain answers, which gives alternative deﬁnitions of inverses
when one is focused on retrieving information with a particular class of queries. In Section 7
we report on extensions to the previous notions that deal with incomplete information in
source instances. Conclusions are presented in Section 8. We begin by giving a bit of general
notation for the chapter.

Preliminary notions and notation
In the study of the inverse operator, we use a general notion of schema mapping (or just
mapping in our context). We assume that a mapping from schema S to schema T is simply
a set of pairs (I, J) where I is an instance of S and J is an instance of T. As usual in data
exchange, given a mapping M from S to T and an instance I of S, we denote by SolM(I)
the set of solutions for I under M, that is SolM(I) = {J | (I, J) ∈ M}.

Notice that a mapping in this general setting is just a binary relation, and thus one
can deﬁne some general operators over mappings that inherits from binary relations. One
such particular operator that plays a crucial role in this chapter is mapping composition.
Let M be a mapping from S to T, and M0 a mapping from T to R. The composition of
M and M0, denoted by M ◦ M0, is deﬁned as the composition of binary relations, that is
M ◦ M0 = {(I, K) | there exists J such that (I, J) ∈ M and (J, K) ∈ M0} [33, 19].

∀¯x∀¯y(cid:0)ϕ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z)(cid:1)

We usually specify mappings by using logical languages. One particular language of special 
interest is the language of source-to-target tuple-generating dependencies (st-tgds) [18].
An st-tgd from S to T is a First-Order formula of the form

(1)
in which ¯x, ¯y and ¯z are tuple of variables, ϕ(¯x, ¯y) is a conjunction of relational atoms over S
(mentioning all the variables ¯x and ¯y), and ψ(¯x, ¯z) is a conjunction of relational atoms over T
(mentioning all the variables ¯x and ¯z). The left-hand side of the implication in formula (1) is
called the premise, and the right-had side the conclusion of the st-tgd. For simplicity, we omit
the universal quantiﬁers when writing st-tgds. That is, we just write ϕ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z)
for an st-tgd of the form (1). Given an st-tgd σ of the form ϕ(¯x, ¯y) → ∃¯z ψ(¯x, ¯z) from S
to T, and a pair (I, J) with I an instance of S and J an instance of T, we say that (I, J)
satisﬁes σ if for every pair of tuples ¯a, ¯b such that I satisﬁes ϕ(¯a,¯b), there exists a tuple ¯c
such that J satisﬁes ψ(¯a, ¯c).
We say that a mapping M from S to T is speciﬁed by a set Σ of st-tgds, if for every pair
of instances I of S and J of T we have that (I, J) ∈ M if and only if (I, J) satisﬁes every sttgd 
in Σ. We consider two types of values when deﬁning mappings, constant and null values,
and we assume the existence of a special predicate C(·) to diﬀerentiate them. In particular,
C(u) holds if and only if u is a constant value. As is usual in the data exchange context [18],
when deﬁning a mapping from S to T speciﬁed by st-tgds we assume that source instances
(instances of S) contain only constant values, while target instances (instances of T) may
contain constant and null values. Notice that an inverse of M is a mapping M0 from T to
S, and thus M0 has constant and null values in its source schema (schema T), while only
constants in its target schema (schema S). In Section 7 we drop this assumption, and study
inversion of mappings that may contain constant and nulls in source and target instances.

Fagin-inverse

2
The ﬁrst notion of inverse in the literature was proposed by Fagin [16]. This notion is based
on the algebraic intuition that a mapping composed with its inverse should be equal to

Chapter 03

72

The Inverse of a Schema Mapping

the identity. Since we can unambiguously deﬁne the composition of two schema mappings
(based on the composition of binary relations), we only needed to deﬁne a notion of identity
for schema mappings.

Fagin was specially interested in deﬁning an inverse for mappings speciﬁed by st-tgds
thus, he deﬁned an intuitive identity in terms of st-tgds as follows. Let S be a schema, and
ˆS = { ˆR | R ∈ S}, that is, ˆS is a copy of S. The set of copying st-tgds over S is deﬁned as

ΣS-copy = { R(x1, . . . , xk) → ˆR(x1, . . . , xk) | R is a k-ary relation symbol in S}.

The idea is that ΣS-copy essentially copies every source relation from the source to the target.
Notice that we need to use ˆS = { ˆR | R ∈ S} in the deﬁnition of ΣS-copy and not simply
S since, otherwise, the semantics of the tgds would be trivial. Consider now the mapping
MS-copy from S to ˆS, which is speciﬁed by ΣS-copy. Given the deﬁnition of mapping MS-copy,
it its a natural identity in our context, and thus, the notion of Fagin-inverse is formulated
as follows.
(cid:73) Deﬁnition 1 ([16]). Let M be a mapping from S to T, and M0 a mapping from T to ˆS.
Then M0 is a Fagin-inverse of M if M ◦ M0 = MS-copy.

Notice that in the above deﬁnition, a Fagin-inverse of a mapping from S to T is not
a mapping from T to S but from T to ˆS. This is because we were specially interested
in deﬁning the identity mapping with a set of st-tgds. But we can reformulate the above
notion to use only schema S. Let I, J be instances of S and ˆJ be a copy of J over schema ˆS.
Then we have that (I, ˆJ) ∈ MS-copy if and only if I ⊆ J. Thus we can redeﬁne the identity
mapping as a mapping IdS from S to S given by

IdS = {(I, J) | I, J are instances of S and I ⊆ J}.

With this new identity mapping we can reformulate the notion of Fagin-inverse as follows.
(cid:73) Deﬁnition 2 ([16]). Let M be a mapping from S to T, and M0 a mapping from T to S.
Then M0 is a Fagin-inverse of M if M ◦ M0 = IdS.

In the rest of the chapter we use Deﬁnition 2 for the notion of Fagin-inverse. Moreover,
if mapping M has a Fagin-inverse, then we say that M is Fagin-invertible. It is important
to notice that IdS is not exactly the identity relation over instances of schema S. In [17],
Fagin formally justiﬁed the use of IdS as the identity when inverting mappings speciﬁed by
st-tgds, instead of the more natural IdS = {(I, I) | I is an instance of S}. As Fagin proved,
no composition of st-tgds can be equal to IdS (see Proposition 5.2 in [17]).
(cid:73) Example 3. Let S be a source schema composed of a binary relation A(·,·), and T a target
schema with a ternary relation B(·,·,·). Consider now the mapping M from S to T speciﬁed
by the st-tgd A(x, y) → B(x, x, y). Then the mapping M1 speciﬁed by B(x, u, y) → A(x, y)
is a Fagin-inverse of M.
To see why M1 is a Fagin-inverse of M, assume that (I, J) ∈ M ◦ M1. We know that
there exists an instance K of schema T such that (I, K) ∈ M and (K, J) ∈ M1. Then, if
A(a, b) is a fact in I with a and b arbitrary values, then B(a, a, b) is a fact in K, which, by
the deﬁnition of M1 implies that A(a, b) is a fact in J. We have shown that every fact in I
is also a fact in J, and thus I ⊆ J. On the other hand, assume that I ⊆ J, and consider the
instance L of T such that B(a, a, b) is a fact in L if and only if A(a, b) is a fact in I. Then it
is straightforward that (I, L) ∈ M and (L, J) ∈ M1, which implies that (I, J) ∈ M ◦ M1.
We have shown that (I, J) ∈ M◦M1 if and only if I ⊆ J, thus implying that M◦M1 = IdS.

J. Pérez

73

Consider now the mapping M2 speciﬁed by B(u, x, y) → A(x, y), and the mapping M3
speciﬁed by B(x, x, y) → A(x, y). Then both M2 and M3 are also Fagin-inverses of M. This
example shows that Fagin-inverses need not to be unique up to logical equivalence [17]. (cid:74)
In the above example it was quite simple to obtain a Fagin-inverse. In fact, as mapping
M3 shows, just reversing the arrows in the deﬁnition of M generates a Fagin-inverse. In
the following examples, we show that Fagin-inverses are not always as easy to construct.
In particular, Example 4 shows that reversing the arrows does not always produce a Fagininverse,
 and Example 5 shows that in some cases we need inequalities when specifying
Fagin-inverses.
(cid:73) Example 4 ([17]). Consider a schema S with two unary relations A(·) and B(·), and a
schema T with three unary relations S(·), T(·), and U(·). Let M be the mapping speciﬁed
by the following set of st-tgds

A(x) → S(x)
A(x) → T(x)
B(x) → U(x)
B(x) → T(x)

Let M0 be the mapping obtained from the speciﬁcation of M by just reversing the arrows,
that is, M0 is speciﬁed by the set of tgds S(x) → A(x), T(x) → A(x), U(x) → B(x) and
T(x) → B(x). It is easy to see that M0 is not a Fagin-inverse of M. Consider the instance
I = {A(1)}. Then for every K ∈ SolM(I) we have that T(1) is a fact in K. Thus, given
that T(x) → B(x) is in the speciﬁcation of M0, we have that for every J ∈ SolM0(K) it
holds that B(1) is a fact in J. This implies that for every J such that (I, J) ∈ M ◦ M0 it
holds that B(1) is a fact in J, and thus, (I, I) 6∈ M ◦ M0, which shows that M ◦ M0 6= IdS.
The problem in this case is that dependencies A(x) → T(x) and B(x) → T(x) are
somehow mixing the data of relations A and B in target relation T. Thus, to obtain a
Fagin-inverse of M, we cannot use T to recover the data of relations A and B. In fact, a
Fagin-inverse of M can be constructed by using only target relations S and U as follows:

S(x) → A(x)
U(x) → B(x)

It can be easily shown that the mapping deﬁned by the above dependencies is a Fagin-inverse
of M.
(cid:74)
(cid:73) Example 5 ([21]). Consider a schema S with a binary relation A(·,·) and a unary relation
B(·), and a schema T with a binary relation S(·,·) and two unary relations T(·) and U(·).
Let M be the mapping speciﬁed by the following set of st-tgds

A(x, y) → S(x, y)
B(x) → S(x, x)
B(x) → T(x)
A(x, x) → U(x)

Notice that in this case the mapping is translating tuples of the form A(a, a) and B(a) into
the same target relation S, thus, as in Example 4, mapping M is somehow mixing the source
information when translating it to the target. In this case we can solve this issue by using

Chapter 03

74

The Inverse of a Schema Mapping

inequalities to specify a Fagin-inverse of M. Consider the mapping M0 speciﬁed by the
following dependencies

S(x, y) ∧ x 6= y → A(x, y)

T(x) → B(x)
U(x) → A(x, x)

Then, it can be shown that M0 is a Fagin-inverse of M. In fact, Fagin et al. showed [20, 21]
that inequalities are strictly needed to specify Fagin-inverses of mappings given by st-tgds
(cid:74)
(we make this statement precise in Section 5).

On the existence of Fagin-inverses
As we explained in the introduction, a ﬁrst important question to answer for every deﬁnition
of inverse of schema mappings, is for which class of mappings the inverse is guaranteed to
exist. As we show next, there are several mappings speciﬁed by st-tgds that do not admit
Fagin-inverses.

Consider the following mappings speciﬁed by st-tgds (in every case, source and target

schemas are implicit in the dependencies).

M1 :
M2 :
M3 :

A(x, y) → S(x)
A(x, y) → S(x) ∧ T(y)

A(x) → S(x)
B(x) → S(x)

(2)

As pointed out by Fagin [17], Fagin-invertibility for a mapping intuitively coincide with no
loss of information. Thus, considering this intuition, none of the above mappings should
be Fagin-invertible. For instance, mapping M1 is only transferring the ﬁrst component
of relation A from source to target, and thus, we are losing the second component when
transferring the source data. In the case of M2, although it is actually transferring both
components of A from source to target, these components are being stored in independent
relations in the target thus loosing the relationships that they had in the source. For M3
the problem is a little bit diﬀerent.
In this case all the data in both A and B is being
transferred but, since all the information is stored in the same relation in the target, it is
impossible to reconstruct the initial source instances.

The question is how to formally prove that the above mappings have no Fagin-inverses?
To answer this, Fagin [16] proposed a very simple condition that a mapping speciﬁed by
st-tgds needs to satisfy in order to have a Fagin-inverse. This property is called the uniquesolutions 
property and is formalized as follows.
(cid:73) Deﬁnition 6 ([16]). A mapping M from S to T satisﬁes the unique-solutions property if
for every pair of instances I1, I2 of S, it holds that SolM(I1) = SolM(I2) implies I1 = I2.
(cid:73) Theorem 7 ([16]). Let M be a mapping from S to T speciﬁed by st-tgds. If M has a
Fagin-inverse then M satisﬁes the unique-solutions property.

The proof of the theorem is very simple. Assume that we have a mapping M and that
M0 is a Fagin-inverse of M. Now let I1 and I2 be instances such that SolM(I1) = SolM(I2).
Since M0 is a Fagin-inverse of M, we know that M◦M0 = IdS and thus (I2, I2) ∈ M◦M0.

J. Pérez

75

This implies that there exists an instance K such that (I2, K) ∈ M and (K, I2) ∈ M0.
Now, since SolM(I1) = SolM(I2) and K ∈ SolM(I2), we have that (I1, K) ∈ M and then
(I1, I2) ∈ M ◦ M0 = IdS which implies that I1 ⊆ I2. With a symmetric argument we can
show that I2 ⊆ I1 and thus I1 = I2.
With this tool we can formally prove that the mappings in (2) have no Fagin-inverses.
For the case of M1, consider instances I1 = {A(1, 2)} and I2 = {A(1, 3)}. The instances
are diﬀerent but SolM1(I1) = SolM2(I2). For the case of M2 we can use instances I1 =
{A(1, 2), A(3, 4)} and I2 = {A(1, 4), A(3, 2)} which satisfy that SolM2(I1) = SolM2(I2). For
the mapping M3 and the instances I1 = {A(1)} and I2 = {B(1)}, we have that SolM3(I1) =
SolM3(I2). Thus neither M1 nor M2 nor M3 satisfy the unique-solutions property which
implies that they have no Fagin-inverse.

The natural question at this point is whether the unique-solutions property is also a
suﬃcient condition to test Fagin-invertibility for mappings speciﬁed by st-tgds. It can be
shown that it is not [21]2. Fortunately, Fagin et al. [20] introduced another property, called
the subset property, which characterizes Fagin-invertibility for the case of mappings speciﬁed
by st-tgds.
(cid:73) Deﬁnition 8 ([20]). A mapping M from S to T satisﬁes the subset property if for every
pair of instances I1, I2 of S we have that SolM(I1) ⊆ SolM(I2) implies I2 ⊆ I1.
(cid:73) Theorem 9 ([20]). Let M be a mapping from S to T speciﬁed by st-tgds. Then M has a
Fagin-inverse if and only if M satisﬁes the subset property.

We have shown that there are several mappings speciﬁed by st-tgds that have no Fagininverse,
 thus the question at this point is whether we can ﬁnd some relaxed notions that can
give natural and useful reverse mappings when Fagin-inverses do not exist. In the next two
sections we introduce the notions of quasi-inverse [20, 21] and maximum recovery [10, 11]
proposed to deal with this issue.

3 Quasi-inverse

As we have shown in the previous section, there are many simple mappings speciﬁed by sttgds 
that do not possess Fagin-inverses. Nevertheless, in many cases there are very simple
and natural ways of specifying useful reverse mappings. Thus, there is a need for a weaker
notion of inverse to handle these cases. Towards solving this problem, Fagin et al. [20]
proposed the notion of a quasi-inverse of a schema mapping.

Intuitively, the notion of quasi-inverse is obtained from the notion of Fagin-inverse by not
diﬀerentiating between source instances that are equivalent for data-exchange purposes. Let
M be a mapping from S to T, and deﬁne the equivalence relation ∼M between instances
of S as follows: I1 ∼M I2 if and only if SolM(I1) = SolM(I2). That is, I1 and I2 are
considered equivalent if they have the same space of solutions under M. For instance, for
the mapping M speciﬁed by the st-tgds A(x, y) → S(x), and the instances I1 = {A(1, 2)}
and I2 = {A(1, 3)}, we have that I1 ∼M I2.
Informally, M0 is a quasi-inverse of M if the equation M ◦ M0 = IdS holds modulo
∼M. To make this statement precise, let us introduce some notation. Let D be a binary

2 Fagin proved that for LAV mappings, that is, mappings speciﬁed by st-tgds in which only one atom is
mentioned in the premises of dependencies, the unique-solutions property is necessary and suﬃcient to
characterize Fagin-invertibility [17].

Chapter 03

76

The Inverse of a Schema Mapping

1 and I0

1, I2 ∼M I0

2 such that I1 ∼M I0

relation over instances of a source schema S (that is, a mapping from S to S), and let M
be a mapping from S to a schema T. Then we deﬁne the relation D[∼M] as follows:
D[∼M] = {(I1, I2) | there exists I0
1, I0
2 and (I0
Now we can formally introduce the notion of quasi-inverse of a schema mapping.
(cid:73) Deﬁnition 10 ([20]). Let M be a mapping from S to T, and M0 a mapping from T to
S. Then M0 is a quasi-inverse of M if (M ◦ M0)[∼M] = IdS[∼M].
(cid:73) Example 11. Consider a source schema S = {A(·,·)} and a target schema T = {S(·)},
and let M be the mapping from S to T speciﬁed by A(x, y) → S(x). We showed in the
previous section that M has no Fagin-inverse. Consider now the mapping M0 speciﬁed by
S(x) → ∃u A(x, u). We now show that M0 is a quasi-inverse of M. To see why this is the
case, consider ﬁrst the inclusion:
IdS[∼M] ⊆ (M ◦ M0)[∼M].

If (I1, I2) ∈ IdS[∼M], then there exist instances I0
2) ∈ IdS. Thus, we have that I0
and (I0
1, I0
fact in J0
1 if and only if A(a, b) is a fact in I0
1) ∈ M, and also that (J0
(I0
1, J0
1 ⊆ I0
that I0
2 we have that (J0
1, I0
Hence, we conclude that (I0
1, I0
(since I1 ∼M I0
1 and I2 ∼M I0
remains to prove that the following inclusion holds:

(3)
2 of S such that I1 ∼M I0
1, I2 ∼M I0
2
1 be an instance of T such that S(a) is a
1 (for arbitrary values a and b). Then we have that
1) ∈ M0 by the deﬁnitions of M and M0. Moreover, given
1, I0
2) ∈ M0.
2) also satisﬁes the tgds deﬁning M0, and thus (J0
2) ∈ (M ◦ M0), which implies that (I1, I2) ∈ (M ◦ M0)[∼M]
2). Thus, we have shown that inclusion (3) holds, and it only

1, I0
2. Let J0

1 ⊆ I0

2) ∈ D}.

1, I0

1, I0

(M ◦ M0)[∼M] ⊆ IdS[∼M].

2 and (I0
1, K) ∈ M and (K, I0

If (I1, I2) ∈ (M ◦ M0)[∼M], then there exist instances I0
I2 ∼M I0
that (I0
every fact A(a, b) in I0
last property we conclude that the instance I ? = I0
since I2 ∼M I0
have that I1 ∼M I0
Thus, we have shown that (4) holds, which proves that M0 is a quasi-inverse of M.

(4)
2 of S such that I1 ∼M I0
1,
2) ∈ (M◦M0). Thus, we have that there exists an instance K of T such
2) ∈ M0. By the deﬁnitions of M and M0 we conclude that for
1, there exists an element c such that A(a, c) is a fact in I0
2. From this
2 is such that I ? ∼M I0
2. Moreover,
2 ∼M I ?, we have that I2 ∼M I ?. Notice that I0
1 ⊆ I ?, and thus we
1, I ?) ∈ IdS, which implies that (I1, I2) ∈ IdS[∼M].
(cid:74)

1, I2 ∼M I ? and (I0

2 and I0

1 ∪ I0

1, I0

As the previous example shows, there are mappings that are not Fagin-invertible but
have a quasi-inverse. This, plus the following result, show that the notion of quasi-inverse is
a strict generalization of the notion of Fagin-inverse. In particular, the result shows that if
a mapping has a Fagin-inverse, then the notions of Fagin-inverse and quasi-inverse coincide.
(cid:73) Theorem 12 ([20]). Let M be a mapping from S to T speciﬁed by st-tgds, and assume
that M has a Fagin-inverse. Then M0 is a Fagin-inverse of M if and only if M0 is a
quasi-inverse of M.

It is not diﬃcult to see why the theorem holds. Let M be a mapping from S to T,
and assume that M is speciﬁed by st-tgds and has a Fagin-inverse.
If M0 is a Fagininverse 
of M then M ◦ M0 = IdS, which implies that (M ◦ M0)[∼M] = IdS[∼M], and
thus M0 is a quasi-inverse of M. Assume now that M0 is a quasi-inverse of M, that is,
(M ◦ M0)[∼M] = IdS[∼M]. Given that M has a Fagin-inverse, from Theorem 7 we know
that M satisﬁes the unique-solutions property. Thus, we have that for every pair of instances

J. Pérez

77

I1, I2 of S, it holds that if I1 ∼M I2 (or equivalently SolM(I1) = SolM(I2)) then I1 = I2.
Notice that this implies that (M ◦ M0)[∼M] = M ◦ M0 and IdS[∼M] = IdS. Thus, since
(M ◦ M0)[∼M] = IdS[∼M] we obtain that M ◦ M0 = IdS which implies that M0 is a
Fagin-inverse of M.

On the existence of quasi-inverses
Consider the mappings in (2) in the previous section. In Example 11 we showed that for
mapping M1 speciﬁed by A(x, y) → S(x), the mapping speciﬁed by S(x) → ∃u A(x, u) is
a quasi-inverse. Consider M2, which is speciﬁed by A(x, y) → S(x) ∧ T(y). In this case
it can be proved that the mapping speciﬁed by S(x) ∧ T(y) → ∃u A(x, u) ∧ ∃v A(v, y) is
a quasi-inverse of M2. Moreover, for the case of mapping M3 speciﬁed by A(x) → S(x)
and B(x) → S(x), it can be proved that S(x) → A(x) ∨ B(x) is a quasi-inverse. Although
none of these mappings admit a Fagin-inverse, all of them admit a quasi-inverse. This gives
rise to the interesting question of whether every mapping speciﬁed by sets of st-tgds has
a quasi-inverse. Unfortunately, it was shown by Fagin et al. [20, 21] that the answer is
negative. To formalize this result we next introduce a property that characterizes when a
mapping speciﬁed by st-tgds has a quasi-inverse. This property is obtained by relaxing the
subset-property that characterizes Fagin-inverses.
(cid:73) Deﬁnition 13 ([20]). A mapping M from S to T satisﬁes the (∼M)-subset property, when
for every pair I1, I2 of instances of S, if SolM(I1) ⊆ SolM(I2) then there exist instances I0
1
and I0
(cid:73) Theorem 14 ([20]). Let M be a mapping from S to T speciﬁed by st-tgds. Then M has
a quasi-inverse if and only if M satisﬁes the (∼M)-subset property.

2 such that I1 ∼M I0

1, I2 ∼M I0

2 and I0

2 ⊆ I0
1.

With the above tool we can show that there are mappings speciﬁed by st-tgds that do

not have a quasi-inverse.
(cid:73) Example 15 ([20, 21]). Consider a source schema S consisting of a binary relation A(·,·),
a target schema T consisting of a binary relation S(·,·) and a unary relation T(·), and the
mapping M from S to T speciﬁed by the st-tgd

A(x, z) ∧ A(z, y) → S(x, y) ∧ T(z).

(5)
Fagin et al. showed [20, 21] that M does not satisfy the (∼M)-subset property, from which
follows that M has no quasi-inverse. We next show why M does not satisfy the (∼M)-subset
property.

Let I1, I2 be instances of S such that:
I1 = {A(1, 4), A(4, 3), A(1, 2), A(2, 5), A(4, 2)}
I2 = {A(1, 2), A(2, 3)}

Moreover, let J1, J2 be the following instances over T:
J1 = {S(1, 3), S(1, 2), S(1, 5), S(4, 5), T(2), T(4)}
J2 = {S(1, 3), T(2)}

That is, J1 and J2 are the canonical solutions [18, 3] of I1 and I2, respectively.
In this
case, given the deﬁnition of M, it is not diﬃcult to see that they are also minimal and
characterizes their space of solutions. For instance, we have that K ∈ SolM(I1) if and only
if J1 ⊆ K. Similarly for I2 we have that K ∈ SolM(I2) if and only if J2 ⊆ K. Thus, given

Chapter 03

78

The Inverse of a Schema Mapping

that J2 ⊆ J1, we conclude that SolM(I1) ⊆ SolM(I2). Next we show that there are no
2 of S such that I1 ∼M I0
1, which implies that M does
instances I0
not satisfy the (∼M)-subset property.
I1 ∼M I0
under M, respectively. That is

For the sake of contradiction, assume that there exist instances I0

2 be the canonical solutions for I0

2 of S such that
1 and I0
2

1, I2 ∼M I0

1, and let J0

1, I2 ∼M I0

2 and I0

2 ⊆ I0

1, I0

1, I0

2 and I0

2 ⊆ I0

1, J0

1 = {S(a, b) | there exists c s.t. A(a, c), A(c, b) ∈ I0
1} ∪
J0
1},
{T(c) | there exist a, b s.t. A(a, c), A(c, b) ∈ I0
2 = {S(a, b) | there exists c s.t. A(a, c), A(c, b) ∈ I0
2} ∪
J0
2},
{T(c) | there exist a, b s.t. A(a, c), A(c, b) ∈ I0
2, we have that SolM(I2) = SolM(I0
2) and, therefore, J2 = J0

Given that I2 ∼M I0
deﬁnition of M. Thus, given that S(1, 3) ∈ J2, we have that S(1, 3) ∈ J0
exists an element m such that A(1, m), A(m, 3) ∈ I0
should be a fact in J0
we have that A(1, 2), A(2, 3) ∈ I0

2 by the
2 and, hence, there
2. Notice that this implies that T(m)
2 = J2, we obtain that m must be equal to 2. Thus,
2 ⊆ I0

2. Now given that I0

2 and then since J0

1, we conclude that:

A(2, 3) ∈ I0
1.

1) and, therefore, J1 = J0

1, we have that SolM(I1) = SolM(I0

1 and then since J0
1 implying that S(4, 4) ∈ J0
1 concluding that S(4, 3) ∈ J0
2 and S(4, 3) 6∈ J1.

(6)
Given that I1 ∼M I0
1 by the
deﬁnition of M. Thus, given that S(4, 5) ∈ J1, we have that S(4, 5) ∈ J0
1 and, hence, there
exists an element n such that A(4, n), A(n, 5) ∈ I0
1. Notice that this implies that T(n) should
be a fact in J0
1 = J1, we obtain that n must be equal to either 2 or 4.
We show that in both cases we obtain a contradiction. Assume that n = 4, then we have
that A(4, 4) ∈ I0
1 which leads to a contradiction since J1 = J0
1
and S(4, 4) /∈ J1. Assume that n = 2, then A(4, 2), A(2, 5) ∈ I0
1. But we know from (6)
that A(2, 3) ∈ I0
1 (since A(4, 2) ∈ I0
1), from which we obtain a
(cid:74)
contradiction since J1 = J0
Although numerous non-Fagin-invertible schema mappings possess natural and useful
quasi-inverses, the previous example shows that there still exist simple mappings speciﬁed
by st-tgds that have no quasi-inverse. This leaves as an open problem the issue of ﬁnding a
notion of inversion for st-tgds which ensures that every mapping in this class is invertible.
This is the main motivation for the introduction of the notion of inversion discussed in the
following section.

Recovery and Maximum Recovery

4
In this section we introduce the notions of recovery and maximum recovery proposed by
Arenas et al. [10] as alternative notions for inverting mappings. As we show in this section,
the notion of maximum recovery strictly generalizes the notion of Fagin-inverses, but has
the desirable property that every mapping speciﬁed by st-tgds admits a maximum recovery,
thus solving the open problem left by the notion of quasi-inverse.
Let us start by considering the mapping M in Example 15, that is, M is speciﬁed by
A(x, z) ∧ A(z, y) → S(x, y) ∧ T(z). Notice that although mapping M does not have a
quasi-inverse, there is a very natural reverse mapping in this case. Consider the mapping
M0 deﬁned by the tgds

S(x, y) → ∃u(cid:0)A(x, u) ∧ A(u, y)(cid:1)
T(z) → ∃v∃w(cid:0)A(v, z) ∧ A(z, w)(cid:1)

J. Pérez

79

M0 is essentially doing its best eﬀort to recover the data initially stored in the source schema.
This is the main intuition behind the notions of recovery and maximum recovery. Intuitively,
a recovery of M is a mapping that is capable of recovering sound data with respect to M,
and a maximum recovery of M is a mapping that is capable to recover the maximum amount
of sound data with respect to M. We next formalize both notions.
Let M be a mapping from a schema S to a schema T, and IdS the identity mapping over

S, that is,

IdS = {(I, I) | I is an instance of S}.

Notice the diﬀerence between IdS and IdS; mapping IdS is the classical identity of binary
relations. When trying to invert M, the ideal would be to ﬁnd a mapping M0 from T to S
such that, M ◦ M0 = IdS. If such a mapping exists, we know that if we use M to exchange
data, the application of M0 gives as result exactly the initial source instance. Unfortunately,
in most cases this ideal is impossible to reach. For example, it is impossible to obtain such
an inverse if M is speciﬁed by a set of st-tgds [16]. The main problem with such an ideal
deﬁnition of inverse is that, in general, no matter what M0 we choose, we will have not one
but many solutions for a source instance under M ◦ M0.
If for a mapping M, there is no mapping M1 such that M ◦ M1 = IdS, at least we
would like to ﬁnd a schema mapping M2 that does not forbid the possibility of recovering
the initial source data. That is, we would like that for every source instance I, the space
of solutions for I under M ◦ M2 contains I itself. Such a schema mapping M2 is called a
recovery of M.
(cid:73) Deﬁnition 16 ([10]). Let M be a mapping from S to T and M0 a mapping from T to S.
Then M0 is a recovery of M if (I, I) ∈ M ◦ M0 for every instance I of S.
(cid:73) Example 17. Let S = {A(·,·)}, and T = {S(·,·), T(·)}. Consider the mapping M in
Example 15, that is M is a mapping from S to T speciﬁed by the following st-tgd:

A(x, z) ∧ A(z, y) → S(x, y) ∧ T(z),

Let M1 be a mapping from T to S speciﬁed by tgd:

S(x, y) → ∃u(cid:0)A(x, u) ∧ A(u, y)(cid:1).

(7)

It is straightforward to prove that M1 is a recovery of M. Let I be an arbitrary instance
of S, and J the canonical solution [18] for I, that is,

J = {S(a, b) | there exists c s.t. A(a, c), A(c, b) ∈ I} ∪

{T(c) | there exist a, b s.t. A(a, c), A(c, b) ∈ I}.

Then in this case we have that (I, J) ∈ M and (J, I) ∈ M1, from which we conclude that
(I, I) ∈ M ◦ M1. This implies that M1 is a recovery of M. Similarly, if M2 is a mapping
from T to S speciﬁed by tgd:

T(z) → ∃v∃w(cid:0)A(v, z) ∧ A(z, w)(cid:1),

then we also have that M2 is a recovery of M. On the other hand, if M3 is a mapping from
T to S speciﬁed by tgd:

S(x, y) ∧ T(z) → A(x, z) ∧ A(z, y),

(8)
then we have that M3 is not a recovery of M. To see why this is the case, consider the
instance I = {A(1, 1), A(2, 2)}. Next we show that (I, I) 6∈ M ◦ M3. ForL the sake of

Chapter 03

80

The Inverse of a Schema Mapping

contradiction, assume that (I, I) ∈ M◦M3, and let K be an instance such that (I, K) ∈ M
and (K, I) ∈ M3. Given that (I, K) satisﬁes st-tgd (7), we have that S(1, 1), S(2, 2) and
T(1), T(2) are facts in K. But then given that (K, I) satisﬁes tgd (8), we conclude that
(cid:74)
A(1, 2), and A(2, 1) are facts in I, which is a contradiction.
Being a recovery is a sound but mild requirement. Indeed, a schema mapping M from
S to T always has as recoveries, for example, mappings M1 = {(J, I) | J is an instance
of T and I is an instance of S}, and M2 = M−1 = {(J, I) | (I, J) ∈ M}. If one has to
choose between M1 and M2 as a recovery of M, then one would probably choose M2 since
the space of possible solutions for a source instance I under M ◦ M2 is smaller than under
M ◦ M1. In fact, if there exists a mapping M3 such that M ◦ M3 = IdS, then one would
deﬁnitely prefer M3 over M1 and M2.
In general, if M0 is a recovery of M, then the smaller the space of solutions generated by
M◦M0, the more informative M0 is about the initial source instances. This notion induces
an order among recoveries. If M1 and M2 are recoveries of M and M ◦ M2 ⊆ M ◦ M1
then we say that M2 is more(-or-equally) informative than M1 as a recovery of M. This
naturally gives rise to the notion of maximum recovery. If for a mapping M there exists a
recovery M0 that is more informative than any other recovery of M, then M0 is the best
option to bring exchanged data back, among all the recoveries. Intuitively, such a mapping
M0 recovers the maximum amount of sound information. Such a mapping M0 is called a
maximum recovery of M.
(cid:73) Deﬁnition 18 ([10]). Let M be a mapping from S to T, and M0 a mapping from T to
S. Then M0 is a maximum recovery of M if:
1. M0 is a recovery of M, and
2.

for every recovery M00 of M, it holds that M ◦ M0 ⊆ M ◦ M00.
Notice that the deﬁnition of maximum recovery implies a quantiﬁcation over all the
possible recoveries of a mapping M. Thus, the process of proving that a particular mapping 
is indeed a maximum recovery of M seems to be very a diﬃcult task (compare it
with the deﬁnitions of Fagin-inverse, quasi-inverse and recovery). Fortunately, Arenas et
al. [11] provide a toolbox to deal with maximum recoveries.
In particular, the following
general characterization is useful to prove that a mapping is a maximum recovery of another
mapping.
(cid:73) Theorem 19 ([11]). Let M be a mapping from S to T and M0 a mapping from T to S.
Then M0 is a maximum recovery of M if and only if M = M ◦ M0 ◦ M.
(cid:73) Example 20. Let S = {A(·,·)}, and T = {S(·,·), T(·)}. Consider again the mapping M
in Example 15 speciﬁed by:

A(x, z) ∧ A(z, y) → S(x, y) ∧ T(z),

and let M0 be the mapping from T to S speciﬁed by the following tgds:

S(x, y) → ∃u(cid:0)A(x, u) ∧ A(u, y)(cid:1),
T(z) → ∃v∃w(cid:0)A(u, z) ∧ A(z, w)(cid:1),

Next we use Theorem 19 to show that M0 is a maximum recovery of M. Given that M0
is a recovery of M (see Example 17), we have that M ⊆ M ◦ M0 ◦ M. Thus, by using
Theorem 19, in order to show that M0 is a maximum recovery of M, we only need to show
that M ◦ M0 ◦ M ⊆ M.

J. Pérez

81

Let (I, J) ∈ M ◦ M0 ◦ M. To prove that (I, J) ∈ M, we need to show that (I, J)
satisﬁes the st-tgd that speciﬁes M. Let A(a, b) and A(b, c) be facts in I, with a, b, c
arbitrary elements. Then we need to prove that S(a, c), T(b) ∈ J. To prove this, ﬁrst notice
that given that (I, J) ∈ M ◦ M0 ◦ M, there exist instances K of T and L of S such that
(I, K) ∈ M, (K, L) ∈ M0 and (L, J) ∈ M. Thus, given that A(a, b), A(b, c) ∈ I and
(I, K) ∈ M, we conclude that S(a, c), T(b) ∈ K. Hence, from the deﬁnition of M0 and the
fact that (K, L) ∈ M0, we conclude that there exist elements d, e and f such that

A(a, d), A(d, c), A(e, b), A(b, f) ∈ L.

Therefore, given that (L, J) ∈ M, we conclude that S(a, c), T(b) ∈ J which was to be
(cid:74)
shown.

As for the case of the quasi-inverse, it can be shown that the notion of maximum recovery

strictly generalizes the notion of Fagin-inverse for mappings speciﬁed by st-tgds.
(cid:73) Theorem 21 ([10]). Let M be a mapping from S to T speciﬁed by st-tgds, and assume
that M has a Fagin-inverse. Then, M0 is a Fagin-inverse of M if and only if M0 is a
maximum recovery of M.

The relationship between maximum recoveries and quasi-inverses is a little bit more

complicated and is given in the following result.
(cid:73) Theorem 22 ([10]). Let M be a mapping from S to T speciﬁed by st-tgds, and assume
that M has a quasi-inverse.
1. If M0 is a maximum-recovery of M then M0 is a quasi-inverse of M.
2. If M0 is a quasi-inverse and a recovery of M, then M0 is a maximum recovery of M.

On the existence of maximum recoveries
One of the main results regarding maximum recoveries is that they exist for every mapping
speciﬁed by st-tgds [10]. To show this, we next introduce the notion of witness solution that
can be used to characterize when a general mapping has a maximum recovery.
(cid:73) Deﬁnition 23 ([10]). Let M be a mapping from S to T and I an instance of S. Then
an instance J ∈ SolM(I) is a witness solution for I under M, if for every other instance I0
such that J ∈ SolM(I0) it holds that SolM(I) ⊆ SolM(I0).

Witness solutions are in a sense identiﬁers for spaces of solutions.

In particular, if
there are two instances I1 and I2 that share a witness solution, then SolM(I1) = SolM(I2).
Arenas et al. [10], proved the following general characterization of the existence of maximum
recoveries.
(cid:73) Theorem 24 ([10]). Let M be a general mapping from S to T (not necessarily speciﬁed
by st-tgds). Then M has a maximum recovery if and only if every instance I of S has a
witness solution under M.

It should be noticed that as opposed to the characterizations for the existence of Fagininverses 
and quasi-inverse shown in Theorems 9 and 14, respectively, the characterization
for maximum recoveries can be applied to general mappings, not necessarily speciﬁed by
st-tgds. We can now use Theorem 24 to show that mappings speciﬁed my st-tgds always
have maximum recovery. For this we need to recall the notion of universal solutions in data
exchange [18]. Universal solutions were introduced as desirable solutions for data exchange.

Chapter 03

82

The Inverse of a Schema Mapping

Essentially, a universal solution for an instance I under a mapping M is, in a precise sense,
the most general solution for I and can be embedded in any other solution for I [18]. In
particular, for mappings speciﬁed by st-tgds, universal solutions can be obtained by using
the chase procedure (see Chapter 1, for a comprehensive study of the chase procedure).
In our context, the two most important properties of universal solutions are stated in the
following lemma.
(cid:73) Lemma 25 ([10, 18]). Let M be a mapping from S to T speciﬁed by st-tgds.
1. If J is a universal solution for I under M then J is a witness solution for I under M.
2. For every instance I of S there exists a universal solution for I under M.

Then from Theorem 24 and Lemma 25 we obtain the following.

(cid:73) Corollary 26 ([10]). Every mapping M speciﬁed by st-tgds has a maximum recovery.

5

Computing Inverses

Up to this point we have presented three alternative notions for inverting mappings. For
every one of them we have discussed their formal deﬁnitions, characterizations and the existence 
problem. But we have not discussed the most important practical problem regarding
inverses of schema mappings: how to compute an inverse. In this section we present a general 
algorithm that can be used to compute all the notions of inverses introduced so far.
We also discuss expressiveness issues. In particular, what is the language needed to express
these inverses which is directly related to the language used in the output of the algorithm.

5.1 An algorithm for inverting mappings
The algorithm presented in this section is based on query rewriting and thus we ﬁrst introduce 
the necessary terminology and some preliminary results. A fundamental notion in
this section is the notion of certain answers. Given a mapping M from S to T, a source
instance I, and a query QT over T, the set of certain answers of QT over I, denoted by
certainM(QT, I) is the set

certainM(QT, I) = \

QT(J).

J∈SolM(I)

That is, a tuple ¯a is a certain answer if ¯a ∈ QT(J) for every solution J of I. With the
notion of certain answers we can deﬁne the notion of source rewritability. Given a mapping
M from S to T, and a query QT over T, we say that QS over S is a source rewriting of QT
under M if for every instance I of S it holds that

QS(I) = certainM(QT, I).

That is, if QS is a source rewriting of QT, in order to compute the certain answers of QT
one only needs to compute QS(I).

The computation of a source rewriting of a conjunctive query is a basic step in the
ﬁrst algorithm presented in this section. This problem has been extensively studied in the
database area [30, 31, 15, 1, 35] and, in particular, in the data integration context [24, 25, 29].
It can be shown that given a mapping M from S to T speciﬁed by a set of st-tgds, and a
conjunctive query QT over T, then a rewriting of QT over the source can always be expressed

J. Pérez

83

as a union of conjunctive queries with equality predicates (UCQ=). As an example, consider
a mapping given by the following tgds:

A(x, y) → S(x, y),
B(x) → S(x, x),

and let QT be the target query given by formula S(x, y). Then a rewriting of QT over the
source is given by A(x, y) ∨ (B(x) ∧ x = y), which is a query in UCQ=. Notice that in this
rewriting, we do need disjunction and the equality x = y. Moreover, it is known that source
rewritings of conjunctive queries can be computed in exponential time. We formalize the
above discussion in the following lemma.
(cid:73) Lemma 27 ([11]). There exists a procedure Source-Rew that given a set Σ of st-tgds
from S to T, and a conjunctive query QT over T, computes (in exponential time) a query
in UCQ= which is a source rewriting of QT under the mapping M speciﬁed by Σ.

The following algorithm, proposed in [11], uses procedure Source-Rew to compute
inverses. In particular, the algorithm computes a maximum recovery of the input mapping.
In the algorithm we use the special predicate C(·) that diﬀerentiates constant values from
labeled null values (that is C(u) holds if and only if u is a constant value). We also use
C(¯x), with ¯x a tuple of variables (x1, . . . , xk), as a shorthand of C(x1) ∧ ··· ∧ C(xk).
Algorithm Inverse
Input: A mapping M from S to T speciﬁed by a set Σ of st-tgds.
Output: A mapping M0 from T to S speciﬁed by a set Σ0 of tgds with disjunctions, equalities
and predicate C(·).
1. Start with Σ0 as the empty set.
2. For every st-tgd ϕ(¯x) → ∃¯y ψ(¯x, ¯y) in Σ, do the following:

a. Let QT be the conjunctive query deﬁned by formula ∃¯y ψ(¯x, ¯y).
b. Use Source-Rew to compute a formula α(¯x) in UCQ= that is a source rewriting of
c. Add dependency ∃¯y ψ(¯x, ¯y) ∧ C(¯x) → α(¯x) to Σ0.
3. Return the mapping M0 from T to S speciﬁed by Σ0.

QT under mapping M.

(cid:73) Example 28. Let S = {A(·,·), B(·)}, and T = {S(·,·)}, and let M be the mapping for S
to T speciﬁed by the st-tgds

A(x, y) → S(x, y),
B(x) → S(x, x).

With input M, algorithm Inverse ﬁrst considers the st-tgd A(x, y) → S(x, y) and computes
a source rewriting of S(x, y). From the discussion previous to the algorithm we know that
A(x, y) ∨ (B(x) ∧ x = y) is a source rewriting of S(x, y). Thus the algorithm includes in
Σ0 the dependency S(x, y) ∧ C(x) ∧ C(y) → A(x, y) ∨ (B(x) ∧ x = y). Then the algorithm
considers dependency B(x) → S(x, x) and computes a source rewriting of S(x, x) which
is given by the source query A(x, x) ∨ B(x). Then the algorithm includes dependency
S(x, x) ∧ C(x) → A(x, x) ∨ B(x) in Σ0. Finally, the output of the algorithm is the mapping
M0 speciﬁed by the dependencies

S(x, y) ∧ C(x) ∧ C(y) → A(x, y) ∨ (B(x) ∧ x = y),

S(x, x) ∧ C(x) → A(x, x) ∨ B(x).

(cid:74)

Chapter 03

84

The Inverse of a Schema Mapping

(cid:73) Theorem 29 ([6, 11]). Let M be a mapping speciﬁed by st-tgds. Then with input M,
algorithm Inverse computes a maximum recovery of M.

By Theorems 21 and 22 we obtain the following corollary regarding the computation of

Fagin-inverses and quasi-inverses.
(cid:73) Corollary 30. Let M be a mapping speciﬁed by st-tgds. If M has a Fagin-inverse (quasi-
inverse), then with input M, algorithm Inverse computes a Fagin-inverse (quasi-inverse)
of M.

In general, the set Σ0 constructed in algorithm Inverse is of exponential size. Notice
that this directly depends on the size of the source rewritings computed by Source-Rew
which are in general exponential. Nevertheless, there are cases for which this process can be
done more eﬃciently. In particular, if mapping M is speciﬁed by a set of st-tgds that do not
use existential quantiﬁcation in the conclusions of dependencies, also called full st-tgds [18],
then Step (2b) of algorithm Inverse can be accomplished in polynomial time [11, 34].
For the case of the Fagin-inverse, Arenas et al. [7] proposed an alternative algorithm
that uses target rewritings. Let M be a mapping from S to T speciﬁed by st-tgds, and
QS a conjunctive query over S. Then, a query QT is a target rewriting of QS under M if
certainM(QT, I) = QS(I) for every source instance I. That is, QT is a target rewriting of
QS if and only if QS is a source rewriting of QT. Although the notions of source and target
rewriting are tightly related, their associated algorithmic problems are not equivalent. For
example, as opposed to the case of source rewritings, for a conjunctive query QS a target
rewriting does not always exist [7]. Nevertheless, Arenas et al. [7] showed that if M is a
mapping speciﬁed by st-tgds that has a Fagin-inverse, then every conjunctive source query
is target rewritable. Moreover, it can be proved that a target rewriting can be computed in
exponential time and can be expressed as a union of conjunctive queries with equalities and
inequalities (UCQ=,6=) [7, 34]. We formalize this in the following lemma.
(cid:73) Lemma 31 ([7, 34]). There exists a procedure Target-Rew that given a set Σ of st-tgds
from S to T, and a conjunctive query QS over S that is target rewritable, computes (in
exponential time) a query in UCQ=,6= which is a target rewriting of QS under the mapping
M speciﬁed by Σ.

With this procedure we can present the following algorithm to compute Fagin-inverses
(which is implicit in the work by Arenas et al. [7](Proposition 5.3)). In the algorithm we
also use the following property. A tgd from S to T of the form ϕ1(¯x) ∨ ϕ2(¯x) → ψ(¯x)
is equivalent to the set of tgds {ϕ1(¯x) → ψ(¯x), ϕ2(¯x) → ψ(¯x)}. That is, one can always
eliminate disjunctions from the premises of tgds. Another property that we use is that
equalities in the premises of tgds can always be eliminated by making the necessary variable
replacements. That is, the dependency ϕ(¯x) ∧ x = y → ψ(¯x) is equivalent to ϕ(¯x0) → ψ(¯x0)
where ¯x0 is the tuple obtained from ¯x by replacing every occurrence of y by x.

Algorithm Fagin-Inverse
Input: A mapping M from S to T speciﬁed by a set Σ of st-tgds that has a Fagin-inverse.
Output: A mapping M0 from T to S speciﬁed by a set Σ0 of tgds with inequalities and
predicate C(·).
1. Start with Σ0 as the empty set.
2. For every source k-ary relation symbol R do the following:

a. Let x = (x1, . . . , xk) be a k-tuple of distinct variables, and QS the conjunctive query

deﬁned by formula R(¯x).

J. Pérez

85

b. Use Target-Rew to compute a formula α(¯x) in UCQ=,6= that is a target rewriting
c. For every disjunct β(¯x) of α(¯x) add dependency β(¯x) ∧ C(¯x) → R(¯x) to Σ0.

of QS under mapping M.

3. Eliminate all the equality predicates in Σ0 by making the necessary variable replacements
4. Return the mapping M0 from T to S speciﬁed by Σ0.

(and eliminating the remaining predicates C(x) for every replaced variable x).

(cid:73) Example 32. Let S = {A(·,·), B(·)} and T = {S(·,·), T(·), U(·)}, and let M be the
mapping in Example 5, that is, M is speciﬁed by the set of st-tgds

A(x, y) → S(x, y)
B(x) → S(x, x)
B(x) → T(x)
A(x, x) → U(x)

With input M, algorithm Fagin-Inverse ﬁrst considers relation symbol A and in Step (2b)
and computes a target rewriting of A(x, y).
It can be shown that the query given by
(S(x, y) ∧ x 6= y) ∨ (U(x) ∧ x = y) is a target rewriting of A(x, y). Then in Step (2c) the
algorithm adds dependencies

S(x, y) ∧ x 6= y ∧ C(x) ∧ C(y) → A(x, y)
U(x) ∧ x = y ∧ C(x) ∧ C(y) → A(x, y)

to the set Σ0. Then the algorithm considers relation symbol B and computes a target
rewriting of B(x).
It can be proved that T(x) is a target rewriting in this case, thus,
the algorithm adds dependency T(x) ∧ C(x) → B(x). Finally, in Step (4) the algorithm
eliminates the equalities by variable replacements to obtain the set of dependencies

S(x, y) ∧ x 6= y ∧ C(x) ∧ C(y) → A(x, y)
U(x) ∧ C(x) → A(x, x)
T(x) ∧ C(x) → B(x)

Notice that the obtained mapping is almost exactly the mapping that is claimed to be a
Fagin-inverse of M in Example 5.
(cid:74)

The correctness of algorithm Fagin-Inverse is stated in the following theorem.

(cid:73) Theorem 33 ([7, 34]). Let M be a mapping speciﬁed by st-tgds that has a Fagin-inverse.
Then with input M, algorithm Fagin-Inverse computes a Fagin-inverse of M.

It should be pointed out that the ﬁrst algorithms proposed to compute quasi-inverses [21],
and maximum recoveries [10], used ad-hoc techniques and were far more complicated that
the one that we presented in this section. The algorithms that we have presented were
proposed by Arenas et al. [11, 6, 7] and are based on query rewriting procedures which makes
them suitable for optimizations and can be beneﬁted from the vast amount of work on query
rewriting in the data integration and data exchange contexts. Fagin et al. [21] also proposed a
simple algorithm to compute Fagin-inverses based on the chase procedure. We do not explain
all the details of this algorithm but describe the main idea. We assume some familiarity with
the chase procedure for tgds (see Chapter 1 for details on the chase procedure). For every
source atom R(¯x), the algorithm by Fagin et al. [21] considers all the atoms obtained by
considering all possible combinations of equalities among the variables in ¯x. Those atoms are

Chapter 03

86

The Inverse of a Schema Mapping

called prime atoms in [21]. For example, for a source relation R(·,·,·) the algorithm considers
the prime atoms R(x1, x1, x1), R(x1, x1, x2), R(x1, x2, x2), R(x1, x2, x1), and R(x1, x2, x3).
Assume that a Fagin-inverse is to be computed for a mapping M speciﬁed by a set Σ of sttgds.
 Moreover, given a prime atom α, let chaseΣ(α) be the result of chasing α with Σ. Then
for every prime atom α the algorithm generates a formula σα of the form β∧δ∧γ → α, where
β is the conjunction of all the target atoms in chaseΣ(α), δ is a conjunction of inequalities
of the form x 6= y for every pair of diﬀerent variables mentioned in α, and γ is a conjunction
of formulas C(x) for every variable x mentioned in α. Fagin et al. [21] proved that if M
has a Fagin-inverse, then the set of formulas {σα | α is a prime source atom} speciﬁes a
Fagin-inverse of M [21].

5.2 Languages for expressing inverses
In this section we study the question of what the language needed to express inverses is. In
particular we survey the results in the literature that justify the languages used as output
in the algorithms of the previous section. In particular a ﬁrst result which is immediately
obtained from the algorithms is the following.
(cid:73) Theorem 34 ([20, 10]). Let M be a mapping from S to T speciﬁed by st-tgds.
1. M has a maximum recovery speciﬁed by a set of tgds from T to S with disjunctions and

equalities in the conclusions and predicate C(·) in the premises.

2. If M has a Fagin-inverse (quasi-inverse), then there exists a Fagin-inverse (quasi-inverse)
of M speciﬁed by a set of tgds from T to S with disjunctions and equalities in the conclusions 
and predicate C(·) in the premises.

3. If M has a Fagin-inverse, there exists a Fagin-inverse of M speciﬁed by a set of tgds

from T to S with inequalities and predicate C(·) in the premises.
Parts 1) and 2) of the theorem follow from algorithm Inverse, while part 3) follows
from algorithm Fagin-Inverse. Fagin et al. [20, 21] use a slightly diﬀerent language to
specify quasi-inverses of mappings speciﬁed by st-tgds. In particular, they use tgds with
inequalities and predicate C(·) in the premises and disjunctions (without equalities) in the
conclusions. It is not diﬃcult to see that in the output of algorithm Inverse one can replace
the equalities in the conclusions of dependencies by inequalities in the premises as is outlined
in the following example.
(cid:73) Example 35. Consider the mapping M in Example 28, that is, M is speciﬁed by the
dependencies A(x, y) → S(x, y) and B(x) → S(x, x).
In that example, we compute a
maximum recovery M0 of M speciﬁed by the set of dependencies

S(x, y) ∧ C(x) ∧ C(y) → A(x, y) ∨ (B(x) ∧ x = y),

S(x, x) ∧ C(x) → A(x, x) ∨ B(x).

(9)

Notice that from (9) we can generate two formulas depending on whether x = y or x 6= y
obtaining the set

S(x, y) ∧ C(x) ∧ C(y) ∧ x 6= y → A(x, y),
S(x, y) ∧ C(x) ∧ C(y) ∧ x = y → A(x, y) ∨ B(x),
S(x, x) ∧ C(x) → A(x, x) ∨ B(x).

(10)
(11)

J. Pérez

87

Finally we can use variable substitutions to eliminate the equality in (10). In that case the
obtained dependency is equivalent to (11), and thus the ﬁnal set of dependencies is

S(x, y) ∧ C(x) ∧ C(y) ∧ x 6= y → A(x, y),

S(x, x) ∧ C(x) → A(x, x) ∨ B(x).

(cid:74)
It was shown by Arenas et al. [6](Lemma 4.2) that if from the output of algorithm
Inverse we eliminate the equalities with the process outlined in the above example, then
the obtained mapping is still a maximum recovery of M. By a diﬀerent procedure Fagin et
al. [20] showed that for mappings speciﬁed by st-tgds that has a quasi-inverse, there exists a
quasi inverse speciﬁed by a set of tgds with inequalities and predicate C(·) in the premises
and disjunctions in the conclusions. Thus we have the following.
(cid:73) Theorem 36 ([6, 20]). Let M be a mapping from S to T speciﬁed by st-tgds.
1. M has a maximum recovery speciﬁed by a set of tgds from T to S with inequalities and
predicate C(·) in the premises and disjunctions in the conclusions.
2. If M has a quasi-inverse, then there exists a quasi-inverse of M speciﬁed by a set of tgds
from T to S with inequalities and predicate C(·) in the premises and disjunctions in the
conclusions.
We know what languages are suﬃcient to specify inverses but, are all the features of these
languages strictly needed to specify inverses? For example, do we really need disjunctions to
specify maximum recoveries and quasi-inverses? Do we really need predicate C(·) to specify
Fagin-inverses? In what follows we answer these questions.
predicate C(·) is strictly necessary to specify Fagin-inverses.
(cid:73) Theorem 37 (Necessity of C(·) [20]). There exists a mapping M speciﬁed by st-tgds that
has a Fagin-inverse but does not have a Fagin-inverse speciﬁed by tgds with inequalities in
the premises and disjunctions in the conclusions (without using predicate C(·)).

(cid:73) Example 38. Consider the mapping M speciﬁed by the st-tgds A(x, y) → ∃z (cid:0)S(x, z) ∧
S(z, y)(cid:1). It can be shown that M is Fagin-invertible. In fact, the mapping M0 speciﬁed

The ﬁrst result that we report was proved by Fagin et al. [20, 21], and states that

by S(x, z) ∧ S(z, y) ∧ C(x) ∧ C(y) → A(x, y) is a Fagin-inverse of M. Fagin et al. [20]
show that M does not have a Fagin-inverse that does not use C(·). To see the intuition
of the failure, lets show that if we delete the C(·) predicates in the deﬁnition of M0, the
resulting mapping is no longer a Fagin-inverse of M. Thus consider the mapping M00
speciﬁed by S(x, z)∧ S(z, y) → A(x, y) and assume that M00 is a Fagin-Inverse of M. Then
for every source instance I we have that (I, I) ∈ M ◦ M00. Now consider the instance
I = {A(1, 2), A(2, 1)}. Since (I, I) ∈ M ◦ M00 we know that there exists an instance K
such that (I, K) ∈ M and (K, I) ∈ M00. Thus, by the deﬁnition of M, we have that there
exists elements a, b such that S(1, a), S(a, 2), S(2, b), S(b, 1) ∈ K. Then by deﬁnition of M00
we have that A(a, b), A(b, a) ∈ I and thus, either a = 1 and b = 2, or a = 2 and b = 1.
Assume ﬁrst that a = 1 and b = 2, then we have that S(1, 1), S(2, 2) ∈ K which implies that
A(1, 1), A(2, 2) ∈ I which is a contradiction. If we assume that a = 2 and b = 1 we obtain
the same contradiction. Notice that we cannot obtain this contradiction with M0 since I has
as solution under M the instance K0 = {A(1, n), A(n, 2), A(2, m), A(m, 2)} with n and m
diﬀerent null values. Moreover, K0 has I as solution under M0 and thus (I, I) ∈ M◦M0. (cid:74)
One can prove a stronger result for the case of maximum recoveries, namely that predicate

C(·) is needed even if we allow the full power of First-Order logic.

Chapter 03

88

The Inverse of a Schema Mapping

(cid:73) Theorem 39 (Necessity of C(·) for maximum recoveries [10]). There exists a mapping M
speciﬁed by st-tgds that has no maximum recovery speciﬁed by First-Order sentences that do
not use predicate C(·).

The following result shows that we need either inequalities in the premises or equalities in
the conclusions of dependencies in order to specify Fagin-inverses. This immediately implies
the necessity of these features to specify quasi-inverses and maximum recoveries.
(cid:73) Theorem 40 (Necessity of either = or 6= [20]). There exists a mapping M speciﬁed by
st-tgds that has a Fagin-inverse but does not have a Fagin-inverse speciﬁed by tgds with
predicate C(·) in the premises and disjunctions in the conclusions.

Fagin et al. [21] use the mapping M in Example 32 to show the necessity of either
inequalities in the premises of equalities in the conclusions to specify Fagin-inverses. The
only remaining property that we need to prove is that disjunctions are necessary for quasiinverses 
and maximum recoveries.
(cid:73) Theorem 41 (Necessity of ∨ [34, 20]).
1. There exists a mapping M speciﬁed by st-tgds that has no maximum recovery speciﬁed

by tgds with predicate C(·) in the premises and equalities in the conclusions.

2. There exists a mapping M speciﬁed by st-tgds that has a quasi-inverse but has no quasiinverse 
speciﬁed by tgds with inequalities and predicate C(·) in the premises.

6 Query Language-Based Inverses of Schema Mappings

In the data exchange scenario, the standard procedure used to exchange data with a mapping
is based on the chase procedure [18] (See Chapter 1 for a comprehensive study of the chase
procedure in data exchange). More precisely, given a mapping M and a source database
I, a canonical translation of I according to M is computed by chasing I with the set of
dependencies deﬁning M [18]. Thus, when computing an inverse of M, it would be desirable
from a practical point of view to obtain a mapping M0 where the chase procedure can be
used to exchange data. Unfortunately, the notions of inverse that we have introduced in the
previous sections, express inverses in some mapping languages which include features that
are diﬃcult to use in practice. The most important of those issues is the use of disjunctions
in the conclusion of the mapping rules.

To provide a solution for the aforementioned issue, Arenas et. al [6] introduce a querylanguage 
based notion of inverse called C-maximum recovery, with C a class of queries. The
idea is that when one focuses on particular query languages one can obtain inverses with
better properties regarding the languages needed to specify these inverses. In particular,
Arenas et al. [6] proved that when one focuses on conjunctive queries, one can obtain inverses
that can be expressed in a chaseable language.

The main intuition behind the notion proposed by Arenas et al. [6] is to use queries
to measure the amount of information that a mapping M0 can recover with respect to a
mapping M. Let M be a mapping from S to T, M0 a mapping from T to S. Notice that
M ◦ M0 is a mapping that goes from S to T and then to S again. Thus one can measure
the amount of information recovered by M0 by using queries over S. Let Q be a query over
S, then we say that M0 recovers sound information w.r.t. Q under M if for every instance
I it holds that

certainM◦M0(Q, I) ⊆ Q(I).

J. Pérez

89

Thus, by posing the query Q over the space of solutions for I under M ◦ M0, one can only
obtain tuples that are already in the evaluation of Q over the original instance I. This
notion can be generalized to a class C of queries, which gives rise to the notion of C-recovery.
(cid:73) Deﬁnition 42 ([6]). Let M be a mapping from S to T, M0 a mappings from T to S, and
C a class of queries over S. Then M0 is a C-recovery of M if for every query Q ∈ C and
every source instance I it holds that

certainM◦M0(Q, I) ⊆ Q(I).
As for the deﬁnition of maximum recovery, one can compare diﬀerent C-recoveries. Let
M0 and M00 be C-recoveries of M, and suppose that for every query Q ∈ C and source
instance I, it holds that

certainM◦M00(Q, I) ⊆ certainM◦M0(Q, I) ⊆ Q(I).

Clearly, the mapping M0 is better than M00 to recover information w.r.t. queries in C, since
certainM◦M0(Q, I) is closer to Q(I) than certainM◦M00(Q, I). This discussion naturally
gives rise to the notion of C-maximum recovery.
(cid:73) Deﬁnition 43 ([6]). Let M be a mapping from S to T, and C a class of queries over S.
Then M0 is a C-maximum recovery of M if
1. M0 is a C-recovery of M, and
2.

for every C-recovery M00 of M, it holds that certainM◦M00(Q, I) ⊆ certainM◦M0(Q, I).
Before stating some general results regarding C-maximum recoveries and the relationship
with the notions presented in the previous sections, let us show some examples on what is the
inﬂuence of the class C of queries in the notion of C-maximum recovery. Before presenting
the example, we note that if M0 is a maximum recovery of M, then M0 is a C-maximum
recovery of M for every class C of queries [8]. This is not diﬃcult to show given the set of
tools for maximum recoveries proposed by Arenas et al. [11] (see [34, 8] for details on the
relationship between maximum recoveries and C-maximum recoveries).
(cid:73) Example 44. Let M be speciﬁed by these two st-tgds:

A(x, y) → R(x, y),

B(x) → R(x, x).

It can be shown that mapping M1 speciﬁed by dependency:

R(x, y) → A(x, y) ∨ (cid:0)B(x) ∧ x = y(cid:1)

is a UCQ-maximum recovery of M (in fact M1 is a maximum recovery of M). To specify
M1, we have used a disjunction in the conclusion of the dependency. This disjunction is
unavoidable if we use UCQ to retrieve information [8]. On the other hand, if we focus on
CQ to retrieve information, then, intuitively, there is no need for disjunctions in the righthand 
side of the rules as conjunctive queries cannot extract disjunctive information. In fact,
it can be shown that a CQ-maximum recovery of M is speciﬁed by dependency:

R(x, y) ∧ x 6= y → A(x, y).
(cid:74)
The example suggests that the notion of CQ-maximum recovery is a strict generalization 
of the notion of UCQ-maximum recovery. More importantly, it shows that for diﬀerent
choices of the class of queries used, we obtain diﬀerent notions of inverses of schema mappings.
 The following results show that one can actually characterize the notions of Fagininverse 
and quasi-inverse for particular classes of queries. In the theorem we use UCQ6= to
denote the class of unions of conjunctive queries with inequalities.

Chapter 03

90

The Inverse of a Schema Mapping

(cid:73) Theorem 45 ([6, 8]). Let M be a mapping speciﬁed by a set of st-tgds.
1. Assume that M has a Fagin-inverse. Then M0 is a Fagin-inverse of M if and only if
M0 is a UCQ6=-maximum recovery of M.
2. Assume that M has a quasi-inverse. There exists a class CM that depends on M such
that M0 is a quasi-inverse of M if and only if M0 is a CM-maximum recovery of M.
Arenas et al. [6, 8] provide several tools to work with C-maximum recoveries including
characterizations for the mappings that admit C-maximum recoveries and a general necessary
and suﬃcient condition for the existence of C-maximum recoveries. We refer the reader
to [34, 8] for a comprehensive study of C-maximum recoveries, and in particular, for a
deﬁnition of the class CM used in part 2) of Theorem 45.

The language of CQ-maximum recoveries
Arenas et al. [6] study several properties about C-maximum recoveries when one focuses
on CQ as the class C of queries.
In particular, they provide an algorithm to compute
CQ-maximum recoveries for st-tgds showing the following theorem.
(cid:73) Theorem 46 ([6]). Every mapping speciﬁed by a set of st-tgds has a CQ-maximum recovery,
 which is speciﬁed by a set of tgds with inequalities and predicate C(·) in the premises.
Notice that the language needed to express CQ-maximum recoveries of st-tgds has the
same good properties as st-tgds for data exchange. In particular, the language is chaseable
in the sense that the standard chase procedure can be used to obtain a canonical solution.
Thus, compared to the notions of Fagin-inverse, quasi-inverse, and maximum recovery, the
notion of CQ-maximum recovery has two advantages: (1) every mapping speciﬁed by sttgds 
has a CQ-maximum recovery (which is not the case for Fagin-inverses and quasi-
inverses), and (2) such a CQ-maximum recovery can be speciﬁed in a mapping language with
good properties for data exchange (which is not the case for quasi-inverses and maximum
recoveries).

The algorithm proposed by Arenas et al. [6] to compute CQ-maximum recoveries is based
on the algorithm for computing maximum recoveries reported in the previous section. After
computing a maximum recovery, the algorithm does a post-processing step to eliminate the
disjunctions in the conclusions of the dependencies by using a notion of conjunctive-query
products [6, 34]. Given two conjunctive queries Q1 and Q2, the product query Q1 × Q2 is,
intuitively, the closest conjunctive query to both Q1 and Q2 in terms of homomorphisms.
Let us to introduce some terminology to formalize this notion.
Let Q1 and Q2 be two n-ary conjunctive queries, and assume that ¯x is the tuple of free
variables of Q1 and Q2. The product of Q1 and Q2, denoted by Q1×Q2, is deﬁned as a k-ary
conjunctive query (with k ≤ n) constructed as follows. Let f(·,·) be a one-to-one function
from pairs of variables to variables such that:
1. f(x, x) = x for every variable x in ¯x, and
2. f(y, z) is a fresh variable (mentioned neither in Q1 nor in Q2) in any other case.
Then for every pair of atoms R(y1, . . . , ym) in Q1 and R(z1, . . . , zm) in Q2, the atom
R(f(y1, z1), . . . , f(ym, zm)) is included as a conjunct in the query Q1 × Q2. Furthermore,
the set of free variables of Q1 × Q2 is the set of variables from ¯x that are mentioned in
Q1 × Q2. For example, consider conjunctive queries:

Q1(x1, x2)
Q2(x1, x2)

: P(x1, x2) ∧ R(x1, x1),
: ∃y (P(x1, y) ∧ R(x2, x2)).

J. Pérez

91

Then we have that Q1 × Q2 is the conjunctive query:
: ∃z1∃z2 (P(x1, z1) ∧ R(z2, z2)).

(Q1 × Q2)(x1)

In this case, we have used a function f such that f(x1, x1) = x1, f(x2, y) = z1, and
f(x1, x2) = z2. As shown in the example, the free variables of Q1 × Q2 do not necessarily 
coincide with the free variables of Q1 and Q2. The deﬁnition of the product of queries
is motivated by the standard notion of Cartesian product of graphs. In fact, if Q1 and Q2
are Boolean queries constructed by using a single binary relation E(·,·), then the product
Q1 × Q2 exactly resembles the graph-theoretical Cartesian product [27].
The product of queries is the key ingredient in the algorithm CQ-Max-Recovery proposed 
by Arenas et al. [6] to compute CQ-maximum recoveries. Given a mapping M speciﬁed 
by st-tgds, CQ-Max-Recovery ﬁrst uses algorithm Inverse to compute a maximum
recovery M0 of M. Then it eliminates equalities in the conclusions of the dependencies deﬁning 
M0 by adding the necessary inequalities in the premises of the dependencies (as outlined
in Example 35). Finally, the algorithm replaces the remaining disjunctions Q1∨Q2∨···∨Qk
in the conclusions of the tgds, by the conjunctive query Q1× Q2×···× Qk. The ﬁnal output
of CQ-Max-Recovery is a set of tgds with inequalities and predicate C(·) in the premises
(without disjunctions in the conclusions).
(cid:73) Example 47. Assume that the output of Inverse contains the dependency

A(x, y) ∧ C(x) ∧ C(y) → (cid:0)P(x, y) ∧ R(x, x)(cid:1) ∨ ∃z(cid:0)P(x, z) ∧ R(y, y)(cid:1).
A(x, y) ∧ C(x) ∧ C(y) → ∃u∃v(cid:0)P(x, u) ∧ R(v, v)(cid:1),
since ∃u∃v (P(x, u)∧R(v, v)) is the product of P(x, y)∧R(x, x) and ∃z(cid:0)P(x, z)∧R(y, y)(cid:1). (cid:74)

Then algorithm CQ-Max-Recovery replaces this dependency by

Arenas et al. [6] also study the minimality of the language used to express CQ-maximum
recoveries, showing that inequalities and predicate C(·) are both needed to express the CQmaximum 
recoveries of mappings speciﬁed by st-tgds. Arenas et al. [8] also show that the
class CQ is optimal to obtain the desired result of a notion of inverse with good properties
for data exchange. In particular, if one uses either CQ6= or UCQ6= in the deﬁnition of Cmaximum 
recovery, then the language needed to express inverses is no longer chaseable [8].

Inversion in the Presence of Null Values in Source Instances

7
Fagin et al. [22] made the observation that almost all the literature about data exchange
and, in particular, the literature about inverses of schema mappings, assume that source
instances do not contain null values. Most of the results regarding inverses that we have
reported so far are proved for the case of mappings in which the source instances contain
only constant values while target instances may contain constant and null values. Fagin
et al. [22] go a step further and propose new reﬁned notions for inverting mappings that
consider nulls in the source. In particular, they propose the notions of extended inverse,
and of extended recovery and maximum extended recovery. In this section, we review the
deﬁnitions of the latter two notions and compare them with the previously proposed notions
of recovery and maximum recovery (for a comprehensive study of the notion of extended
inverse see the work by Fagin et al. [22]).

The ﬁrst observation to make is that since null values are intended to represent missing
or unknown information, they should not be treated naively as constants [28]. In fact, as

Chapter 03

92

The Inverse of a Schema Mapping

shown by Fagin et al. [22], if one treats nulls in that way, the existence of a maximum
recovery for mappings given by st-tgds is no longer guaranteed.
(cid:73) Example 48. Consider a source schema S = {A(·), B(·)} and a target schema T = {S(·)},
and let M be a mapping speciﬁed by the st-tgds

A(x) → ∃uS(u)
B(x) → S(x)

From Theorem 24, we know that if source instances only contain constant values, then M
has a maximum recovery. This property holds since, under this assumption, every source
instance I has a witness solution (see Deﬁnition 23 and Theorem 24). For example, for the
instance I = {A(1)} the target instance J = {S(n)}, with n a null value, is a witness solution
of I. In fact, if I0 is any source instance such that J ∈ SolM(I) then SolM(I) ⊆ SolM(I0).
Assume now that instances of S may contain constant and null values. Then we have that
J is no longer a witness solution of I under M. To see this consider the source instance
I0 = {B(n)}. Then we have that J ∈ SolM(I0) but, for example J0 = {S(2)} is a solution
for I but not for I0, therefore SolM(I) 6⊆ SolM(I0), and thus J is not a witness solution of
I. In fact, it can be proved that if source instances may contain null values then I has no
witness solution under M implying that M has no maximum recovery if null are allowed in
(cid:74)
the source.

Notice that in the above example, nulls in the source are considered as constants when
evaluating the tgds. Since nulls should not be treated naively when exchanging data, Fagin
et al. [22] proposed a new way to deal with null values based on homomorphisms. Recall
that given instances I and I0 containing constant and null values, a homomorphism from I
to I0 is a function h that is the identity over constant values, maps nulls to constants or null
values, and is such that if R(a1, . . . , ak) is a fact in I, then R(h(a1), . . . , h(ak)) is a fact in
I0. Intuitively, in order to treat null values and constants diﬀerently, Fagin et al. [22] close
mappings under homomorphisms. This idea is supported by the fact that nulls are intended
to represent unknown data, thus, it should be possible to replace them by arbitrary values.
Formally, the authors introduce the following concept.
(cid:73) Deﬁnition 49 ([22]). Let M be a mapping. The homomorphic extension of M, denoted
by e(M), is the mapping

e(M) = {(I, J) | there exist I0, J0 such that (I0, J0) ∈ M and there exist

homomorphisms from I to I0 and from J0 to J }.

The idea is that for a mapping M that has nulls in source and target instances, one
does not have to consider M but e(M) as the mapping to deal with for exchanging data
and computing mapping operators since e(M) treats nulls in a meaningful way [22]. The
following result shows that with this new semantics one can avoid anomalies as the one
shown in Example 48.
(cid:73) Theorem 50 ([22]). For every mapping M speciﬁed by a set of st-tgds and with nulls in
source and target instances, e(M) has a maximum recovery.

As mentioned above, Fagin et al. [22] go a step further by introducing new notions
of inverse for mappings that consider nulls in the source. More speciﬁcally, the authors
introduce the following deﬁnitions

J. Pérez

93

(cid:73) Deﬁnition 51 ([22]). Let M be a mapping from S to T, in which source and target
instances may contain null values. Mapping M0 is an extended recovery of M if (I, I) ∈
e(M) ◦ e(M0), for every instance I of S. Then given an extended recovery M0 of M, the
mapping M0 is a maximum extended recovery of M if for every extended recovery M00 of
M, it holds that e(M) ◦ e(M0) ⊆ e(M) ◦ e(M00).

At a ﬁrst glance, one may think that the notions of maximum recovery and maximum
extended recovery are incomparable. Nevertheless, as shown by Arenas et al. [5] there is a
tight connection between these two notions.
(cid:73) Theorem 52 ([5]). Let M be a mapping that may have nulls values in source and target
instances. Then M has a maximum extended recovery if and only if e(M) has a maximum
recovery. Moreover, M0 is a maximum extended recovery of M if and only if e(M0) is a
maximum recovery of e(M).

One of the main result of Fagin et al. [22] regarding maximum extended recoveries is
that every mapping speciﬁed by st-tgds having nulls in source and target instances has a
maximum extended recovery. This result is implied by Theorems 50 and 52, and we formalize
it in the following theorem.
(cid:73) Theorem 53 ([22]). Let M be a mapping speciﬁed by st-tgds in which source and target
instances may contain null values. Then M has a maximum extended recovery.

It was left as an open problem to identify what is the exact language needed to express
maximum extended recoveries [22].
In fact, it is even open whether maximum extended
recoveries can be speciﬁed if the full power of First-Order logic is allowed to construct
mappings.

Conclusions

8
As many information-system problems involve not only the design and integration of complex
application artifacts, but also their subsequent manipulation, the deﬁnition and implementation 
of some operators for schema mappings has been identiﬁed as a fundamental issue to
be solved [12, 13]. Nowadays, the community recognizes the need to develop techniques to
manipulate these mappings’ speciﬁcations and, in particular, the inverse of a schema mapping 
has been identiﬁed as one of the fundamental operators to be studied in this area. In
this chapter, we have surveyed the main deﬁnition for the inverse operator proposed in the
literature and the results that have been obtained in the last years.

One very important and challenging problem is the interplay between the inverse operator
and other schema mapping operators, in particular the composition of schema mappings [33,
19]. Arenas et al. [9] proved that the mapping that results from composing mappings
speciﬁed by st-tgds is not always invertible (even considering the relaxed notion of CQmaximum 
recovery). This opens the question on good notions for inversion and composition
of schema mappings, and a language for expressing mappings, suitable to deal with the
interplay between the two operators [5]. A ﬁrst attempt and a partial solution for this
problem was given in [9].

The deﬁnition of the appropriate semantics for the inverse operator has proven to be a
non-trivial task, in which many sensible decisions had to be taken. In fact, the answer to
each of these decisions has given rise to diﬀerent semantics for the inverse operator. Some
general questions that one might want to answer include whether we want inverses that are
guaranteed to be consistent in a general scenario, or do we settle for relaxed notions that

Chapter 03

94

The Inverse of a Schema Mapping

allow only answering conjunctive queries (or other restricted classes of queries)? Certainly,
the latter question involves a tradeoﬀ, since the more general operators usually require more
expressive languages, and their computation is more complex.

The spread of new semantics for the schema mappings, either modiﬁed semantics for
mappings speciﬁed by standard logical speciﬁcations over the relational model [32, 22], or
mappings for data models beyond the relational model, such as XML, which need diﬀerent
mapping speciﬁcation languages [4, 2, 36], originates several challenges. Under these new
scenarios, previously deﬁned mapping operators have to be re-studied. This shows the
importance of having general notions of inverse that are not tied to a particular schema
mapping semantic, language or data model. Among the notions that we have presented,
only the notion of maximum recovery is deﬁned in a general setting and can be applied
to abstract mappings independent of the mapping speciﬁcation language, the semantics
used for logical speciﬁcations, or the data model used. Nevertheless, there is not yet clear
consensus about which semantics for the inverse operator is the appropriate one in general,
and we think that particular applications would need to use diﬀerent inverses depending on
their speciﬁc needs. We hope the deﬁnitions and results presented in this chapter would be
useful to compare the proposals for inverses, their characteristics, and their applicability in
diﬀerent contexts.

1

2

References
S. Abiteboul and O. Duschka. Complexity of answering queries using materialized views.
In PODS, pages 254–263, 1998.
S. Amano, L. Libkin, and F. Murlak. XML schema mappings. In PODS, pages 33–42,
2009.

3 M. Arenas, P. Barceló, R. Fagin, and L. Libkin. Locally consistent transformations and

query answering in data exchange. In PODS, pages 229–240, 2004.

4 M. Arenas and L. Libkin. XML data exchange: Consistency and query answering. J. ACM,

55(2), 2008.

5 M. Arenas, J. Pérez, J. L. Reutter, and C. Riveros. Composition and inversion of schema

mappings. SIGMOD Record, 38(3):17–28, 2009.

6 M. Arenas, J. Pérez, J. L. Reutter, and C. Riveros. Inverting schema mappings: Bridging

the gap between theory and practice. PVLDB, 2(1):1018–1029, 2009.

7 M. Arenas, J. Pérez, J. L. Reutter, and C. Riveros. Foundations of schema mapping

management. In PODS, pages 227–238, 2010.

8 M. Arenas, J. Pérez, J. L. Reutter, and C. Riveros. Query language based inverses of schema
mappings: Semantics, computation, and closure properties. VLDB J., 21(6):823–842, 2012.
9 M. Arenas, J. Pérez, J. L. Reutter, and C. Riveros. The language of plain SO-tgds: Composition,
 inversion and structural properties. J. Comput. Syst. Sci., 79(6):763–784, 2013.
10 M. Arenas, J. Pérez, and C. Riveros. The recovery of a schema mapping: bringing exchanged 
data back. In PODS, pages 13–22, 2008.

11 M. Arenas, J. Pérez, and C. Riveros. The recovery of a schema mapping: bringing ex12


13

changed data back. TODS, 34(4), 2009.
P. Bernstein. Applying model management to classical meta data problems.
2003.
P. Bernstein and S. Melnik. Model management 2.0: manipulating richer mappings. In
SIGMOD, pages 1–12, 2007.

In CIDR,

14 G. de Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. On reconciling data exchange,

data integration, and peer data management. In PODS, pages 133–142, 2007.

J. Pérez

95

15 O. Duschka and M. Genesereth. Answering recursive queries using views. In PODS, pages

109–116, 1997.

16 R. Fagin. Inverting schema mappings. In PODS, pages 50–59, 2006.
17 R. Fagin. Inverting schema mappings. TODS, 32(4), 2007.
18 R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data exchange: semantics and query

answering. TCS, 336(1):89–124, 2005.

19 R. Fagin, P. G. Kolaitis, L. Popa, and W.-C. Tan. Composing schema mappings: Secondorder 
dependencies to the rescue. TODS, 30(4):994–1055, 2005.

20 R. Fagin, P. G. Kolaitis, L. Popa, and W.-C. Tan. Quasi-inverses of schema mappings. In

21 R. Fagin, P. G. Kolaitis, L. Popa, and W. C. Tan. Quasi-inverses of schema mappings.

22 R. Fagin, P. G. Kolaitis, L. Popa, and W.-C. Tan. Reverse data exchange: coping with

PODS, pages 123–132, 2007.

TODS, 33(2), 2008.

nulls. In PODS, pages 23–32, 2009.

23 R. Fagin, P. G. Kolaitis, L. Popa, and W.-C. Tan. Schema mapping evolution through
composition and inversion. In Z. Bellahsene, A. Bonifati, and E. Rahm, editors, Schema
Matching and Mapping, pages 191–222. Springer, 2011.

24 A. Halevy. Theory of answering queries using views. SIGMOD Record, 29(1):40–47, 2000.
25 A. Halevy. Answering queries using views: A survey. VLDB J., 10(4):270–294, 2001.
26 A. Halevy, Z. Ives, J. Madhavan, P. Mork, D. Suciu, and I. Tatarinov. The piazza peer

data management system. IEEE Trans. Knowl. Data Eng., 16(7):787–798, 2004.
P. Hell and J. Ne˘set˘ril. Graphs and Homomorphisms. Oxford University Press, 2004.

27
28 T. Imielinski and W. Lipski. Incomplete information in relational databases. Journal of

the ACM, 31(4):761–791, 1984.

29 M. Lenzerini. Data integration: a theoretical perspective. In PODS, pages 233–246, 2002.
30 A. Levy, A. Mendelzon, Y. Sagiv, and D. Srivastava. Answering queries using views. In

PODS, pages 95–104, 1995.

31 A. Levy, A. Rajaraman, and J. Ordille. Querying heterogeneous information sources using

32
33

34

36

source descriptions. In VLDB, pages 251–262, 1996.
L. Libkin. Data exchange and incomplete information. In PODS, pages 60–69, 2006.
S. Melnik. Generic Model Management: concepts and Algorithms, volume 2967 of Lecture
Notes in Computer Science. Springer, 2004.
J. Pérez. Schema Mapping Management in Data Exchange Systems. PhD thesis, Escuela
de Ingeniería, Pontiﬁcia Universidad Católica de Chile, 2011.

35 R. Pottinger and A. Halevy. Minicon: A scalable algorithm for answering queries using

views. VLDB J., 10(2-3):182–198, 2001.
J. Terwilliger, P. Bernstein, and S. Melnik. Full-ﬁdelity ﬂexible object-oriented XML access.
PVLDB, 2(1):1030–1041, 2009.

Chapter 03

