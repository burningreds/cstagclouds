0
1
0
2

 
r
a

M
4

 

 
 
]

B
D
.
s
c
[
 
 

4
v
2
7
3
3

.

0
1
9
0
:
v
i
X
r
a

Composition and Inversion of Schema Mappings∗

Marcelo Arenas

PUC Chile

marenas@ing.puc.cl

Jorge P´erez
PUC Chile
jperez@ing.puc.cl

Juan Reutter

U. of Edinburgh
juan.reutter@ed.ac.uk

Cristian Riveros
Oxford University

cristian.riveros@comlab.ox.ac.uk

1 Introduction

A schema mapping is a speciﬁcation that describes how
data from a source schema is to be mapped to a target
schema. Schema mappings have proved to be essential
for data-interoperability tasks such as data exchange and
data integration. The research on this area has mainly focused 
on performing these tasks. However, as Bernstein
pointed out [7], many information-system problems involve 
not only the design and integration of complex application 
artifacts, but also their subsequent manipulation.
Driven by this consideration, Bernstein proposed in [7]
a general framework for managing schema mappings. In
this framework, mappings are usually speciﬁed in a logical 
language, and high-level algebraic operators are used
to manipulate them [7, 17, 34, 13, 8].

Two of the most fundamental operators in this framework 
are the composition and inversion of schema mappings.

Intuitively, the composition can be described as
follows. Given a mapping M1 from a schema A to a
schema B, and a mapping M2 from B to a schema E, the
composition of M1 and M2 is a new mapping that describes 
the relationship between schemas A and E. This
new mapping must be semantically consistent with the relationships 
previously established by M1 and M2. On
the other hand, an inverse of M1 is a new mapping that
describes the reverse relationship from B to A, and is semantically 
consistent with M1.

In practical scenarios, the composition and inversion
of schema mappings can have several applications. In a
data exchange context [14], if a mapping M is used to
exchange data from a source to a target schema, an inverse 
of M can be used to exchange the data back to the
source, thus reversing the application of M. As a second 
application, consider a peer-data management system
(PDMS) [10, 25]. In a PDMS, a peer can act as a data
source, a mediator, or both, and the system relates peers

∗Database Principles Column. Column editor: Leonid Libkin,
School of Informatics, University of Edinburgh, Edinburgh, EH8 9AB,
UK. E-mail: libkin@inf.ed.ac.uk.

by establishing directional mappings between the peers
schemas. Given a query formulated on a particular peer,
the PDMS must proceed to retrieve the answers by reformulating 
the query using its complex net of semantic mappings.
 Performing this reformulation at query time may be
quite expensive. The composition operator can be used to
essentially combine sequences of mappings into a single
mapping that can be precomputed and optimized for query
answering purposes. Another application is schema evolution,
 where the inverse together with the composition
play a crucial role [8]. Consider a mapping M between
schemas A and B, and assume that schema A evolves
into a schema A′. This evolution can be expressed as a
mapping M′ between A and A′. Thus, the relationship
between the new schema A′ and schema B can be obtained 
by inverting mapping M′ and then composing the
result with mapping M.

In the recent years, a lot of attention has been paid
to the development of solid foundations for the composition 
[33, 17, 37] and inversion [13, 20, 4, 3] of schema
mappings. In this paper, we review the proposals for the
semantics of these crucial operators. For each of these
proposals, we concentrate on the three following prob-
lems: the deﬁnition of the semantics of the operator, the
language needed to express the operator, and the algorithmic 
issues associated to the problem of computing the operator.
 It should be pointed out that we primarily consider
the formalization of schema mappings introduced in the
work on data exchange [14]. In particular, when studying
the problem of computing the composition and inverse of
a schema mapping, we will be mostly interested in computing 
these operators for mappings speciﬁed by source-
to-target tuple-generating dependencies [14]. Although
there has been an important amount of work about different 
ﬂavors of composition and inversion motivated by
practical applications [9, 35, 39], we focus on the most
theoretically-oriented results [33, 17, 13, 20, 4, 3].

Organization of the paper. We begin in Section 2 with
the terminology that will be used in the paper. We then
continue in Section 3 reviewing the main results for the

composition operator proposed in [17]. Section 4 contains 
a detailed study of the inverse operators proposed
in [13, 20, 4]. In Section 5, we review a relaxed approach
to deﬁne the semantics for the inverse and composition
operators that parameterizes these notions by a querylanguage 
[33, 3]. Finally, some future work is pointed out
in Section 6, and the proofs of the new results presented
in this survey are given in Appendix A.

2 Basic notation

In this paper, we assume that data is represented in the
relational model. A relational schema R, or just schema,
is a ﬁnite set {R1, . . . , Rn} of relation symbols, with each
Ri having a ﬁxed arity ni. An instance I of R assigns to
i .
each relation symbol Ri of R a ﬁnite ni-ary relation RI
The domain of an instance I, denoted by dom(I), is the
set of all elements that occur in any of the relations RI
i . In
addition, Inst(R) is deﬁned to be the set of all instances
of R.

As usual in the data exchange literature, we consider
database instances with two types of values: constants and
nulls. More precisely, let C and N be inﬁnite and disjoint
sets of constants and nulls, respectively.
If we refer to
a schema S as a source schema, then Inst(S) is deﬁned
to be the set of all instances of S that are constructed by
using only elements from C, and if we refer to a schema
T as a target schema, then instances of T are constructed
by using elements from both C and N.

Schema mappings and solutions. Schema mappings
are used to deﬁne a semantic relationship between two
schemas. In this paper, we use a general representation of
mappings; given two schemas R1 and R2, a mapping M
from R1 to R2 is a set of pairs (I, J), where I is an instance 
of R1, and J is an instance of R2. Further, we say
that J is a solution for I under M if (I, J) ∈ M. The set
of solutions for I under M is denoted by SolM(I). The
domain of M, denoted by dom(M), is deﬁned as the set
of instances I such that SolM(I) 6= ∅.

Dependencies. As usual, we use a class of dependencies 
to specify schema mappings [14]. Let L1, L2 be
query languages and R1, R2 be schemas with no relation
symbols in common. A sentence Φ over R1 ∪ R2 is an
L1-TO-L2 dependency from R1 to R2 if Φ is of the form
∀¯x (ϕ(¯x) → ψ(¯x)), where (1) ¯x is the tuple of free variables 
in both ϕ(¯x) and ψ(¯x); (2) ϕ(¯x) is an L1-formula
over R1; and (3) ψ(¯x) is an L2-formula over R2. Furthermore,
 we usually omit the outermost universal quantiﬁers 
from L1-TO-L2 dependencies and, thus, we write
ϕ(¯x) → ψ(¯x) instead of ∀¯x (ϕ(¯x) → ψ(¯x)). Finally, the

semantics of an L1-TO-L2 dependency is deﬁned as usual
(e.g., see [14, 4]).

If S is a source schema and T is a target schema,
an L1-TO-L2 dependency from S to T is called an
L1-TO-L2 source-to-target dependency (L1-TO-L2 st-
dependency), and an L1-TO-L2 dependency from T to
S is called an L1-TO-L2 target-to-source dependency
(L1-TO-L2 ts-dependency). Notice that the fundamental 
class of source-to-target tuple-generating dependencies
(st-tgds) [14] corresponds to the class of CQ-TO-CQ stdependencies.


When considering a mapping speciﬁed by a set of dependencies,
 we use the usual semantics given by logical 
satisfaction. That is, if M is a mapping from R1
to R2 speciﬁed by a set Σ of L1-TO-L2 dependencies,
we have that (I, J) ∈ M if and only if I ∈ Inst(R1),
J ∈ Inst(R2), and (I, J) satisﬁes Σ.
Query Answering. In this paper, we use CQ to denote the
class of conjunctive queries and UCQ to denote the class
of unions of conjunctive queries. Given a query Q and
a database instance I, we denote by Q(I) the evaluation
of Q over I. Moreover, we use predicate C(·) to differentiate 
between constants and nulls, that is, C(a) holds
if and only if a is a constant value. We use =, 6=, and
C as superscripts to denote a class of queries enriched
with equalities, inequalities, and predicate C(·), respectively.
 Thus, for example, UCQ=,C is the class of unions
of conjunctive queries with equalities and predicate C(·).
As usual, the semantics of queries in the presence of
schema mappings is deﬁned in terms of the notion of certain 
answer. Assume that M is a mapping from a schema
R1 to a schema R2. Then given an instance I of R1 and
a query Q over R2, the certain answers of Q for I under
M, denoted by certainM(Q, I), is the set of tuples that
belong to the evaluation of Q over every possible solution
for I under M, that is, T{Q(J) | J is a solution for I

under M}.
Proviso. In this survey, only ﬁnite sets of dependencies
are considered.

3 Composition of Schema Mappings

The composition operator has been identiﬁed as one of the
fundamental operators for the development of a framework 
for managing schema mappings [7, 34, 36]. The
goal of this operator is to generate a mapping M13 that
has the same effect as applying successively two given
mappings M12 and M23, provided that the target schema
of M12 is the same as the source schema of M23.
In
[17], Fagin et al. study the composition for the widely

used class of st-tgds. In particular, they provide solutions
to the three fundamental problems for mapping operators
considered in this paper, that is, they provide a formal semantics 
for the composition operator, they identify a mapping 
language that is appropriate for expressing this operator,
 and they study the complexity of composing schema
mappings. In this section, we present these solutions.

In [17, 34], the authors propose a semantics for the
composition operator that is based on the semantics of this
operator for binary relations:

Deﬁnition 3.1 ([17, 34]) Let M12 be a mapping from a
schema R1 to a schema R2, and M23 a mapping from R2
to a schema R3. Then the composition of M12 and M23
is deﬁned as M12 ◦ M23 = {(I1, I3) | ∃I2 : (I1, I2) ∈
M12 and (I2, I3) ∈ M23}.
Then Fagin et al. consider in [17] the natural question of
whether the composition of two mappings speciﬁed by sttgds 
can also be speciﬁed by a set of these dependencies.
Unfortunately, they prove in [17] that this is not the case,
as shown in the following example.
Example 3.2. (from [17]) Consider a schema R1 consisting 
of one binary relation Takes, that associates a student
name with a course she/he is taking, a schema R2 consisting 
of a relation Takes1, that is intended to be a copy of
Takes, and of an additional relation symbol Student,
that associates a student with a student id; and a schema
R3 consisting of a binary relation symbol Enrollment,
that associates a student id with the courses this student is
taking. Consider now mappings M12 and M23 speciﬁed
by the following sets of st-tgds:

Σ12 = {Takes(n, c) → Takes1(n, c),

Takes(n, c) → ∃s Student(n, s)},
Σ23 = {Student(n, s) ∧ Takes1(n, c) →

Enrollment(s, c)}.

Mapping M12 requires that a copy of every tuple in
Takes must exist in Takes1 and, moreover, that each
student name n must be associated with some student id
s in the relation Student. Mapping M23 requires that
if a student with name n and id s takes a course c, then
(s, c) is a tuple in the relation Enrollment. Intuitively,
in the composition mapping one would like to replace the
name n of a student by a student id in, and then for each
course c that is taken by n, one would like to include the
tuple (in, c) in the table Enrollment. Unfortunately,
as shown in [17], it is not possible to express this relationship 
by using a set of st-tgds. In particular, a st-tgd of the
form:

Takes(n, c) → ∃y Enrollment(y, c)

(1)

does not express the desired relationship, as it may associate 
a distinct student id y for each tuple (n, c) in Takes
and, thus, it may create several identiﬁers for the same
student name. (cid:3)

The previous example shows that in order to express
the composition of mappings speciﬁed by st-tgds, one has
to use a language more expressive than st-tgds. However,
the example gives little information about what the right
language for composition is. In fact, the composition of
mappings M12 and M23 in this example can be deﬁned
in ﬁrst-order logic (FO):

∀n∃y∀c (Takes(n, c) → Enrollment(y, c)),

which may lead to the conclusion that FO is a good alternative 
to deﬁne the composition of mappings speciﬁed
by st-tgds. However, a complexity argument shows that
this conclusion is wrong. More speciﬁcally, given mappings 
M12 = (R1, R2, Σ12) and M23 = (R2, R3, Σ23),
where Σ12 and Σ23 are sets of st-tgds, deﬁne the
composition problem for M12 and M23, denoted by
COMPOSITION(M12, M23), as the problem of verifying,
 given I1 ∈ Inst(R1) and I3 ∈ Inst(R3), whether
(I1, I3) ∈ M12 ◦ M23.
If the composition of M12
with M23 is deﬁned by a set Σ of formulas in some
logic, then COMPOSITION(M12, M23) is reduced to the
problem of verifying whether a pair of instances (I1, I3)
satisﬁes Σ.
In particular, if Σ is a set of FO formulas,
 then the complexity of COMPOSITION(M12, M23)
is in LOGSPACE, as the complexity of verifying whether
a ﬁxed set of FO formulas is satisﬁed by an instance is
in LOGSPACE [40]. Thus, if for some mappings M12
and M23, the complexity of the composition problem is
higher than LOGSPACE, one can conclude that FO is not
capable of expressing the composition. In fact, this higher
complexity is proved in [17].

Theorem 3.3 ([17]) For every pair of mappings M12,
M23 speciﬁed by st-tgds, COMPOSITION(M12, M23) is
12 and M⋆
in NP. Moreover, there exist mappings M⋆
23
speciﬁed by st-tgds such that COMPOSITION(M⋆
12, M⋆
23)
is NP-complete.

Theorem 3.3 not only shows that FO is not the right
language to express the composition of mappings given
by st-tgds, but also gives a good insight on what needs
to be added to st-tgds to obtain a language closed under
composition. Given that COMPOSITION(M12, M23) is
in NP, we know by Fagin’s Theorem that the composition 
can be deﬁned by an existential second-order logic
formula [12, 27].
In fact, Fagin et al. use this property 
in [17] to obtain the right language for composition.

More speciﬁcally, Fagin et al. extend st-tgds with existential 
second-order quantiﬁcation, which gives rise to the
class of SO-tgds [17]. Formally, given schemas R1 and
R2 with no relation symbols in common, a second-order
tuple-generating dependency from R1 to R2 (SO-tgd) is a
formula of the form ∃ ¯f (∀¯x1(ϕ1 → ψ1)∧· · ·∧∀¯xn(ϕn →
ψn)), where (1) each member of ¯f is a function symbol,
(2) each formula ϕi (1 ≤ i ≤ n) is a conjunction of relational 
atoms of the form S(y1, . . . , yk) and equality atoms
of the form t = t′, where S is a k-ary relation symbol of
R1 and y1, . . ., yk are (not necessarily distinct) variables
in ¯xi, and t, t′ are terms built from ¯xi and ¯f , (3) each formula 
ψi (1 ≤ i ≤ n) is a conjunction of relational atomic
formulas over R2 mentioning terms built from ¯xi and ¯f ,
and (4) each variable in ¯xi (1 ≤ i ≤ n) appears in some
relational atom of ϕi.

In [17], Fagin et al. show that SO-tgds are the right dependencies 
for expressing the composition of mappings
given by st-tgds. First, it is not difﬁcult to see that every 
set of st-tgds can be transformed into an SO-tgd. For
example, set Σ12 from Example 3.2 is equivalent to the
following SO-tgd:

∃f(cid:18)∀n∀c (Takes(n, c) → Takes1(n, c)) ∧

∀n∀c (Takes(n, c) → Student(n, f (n, c)))(cid:19).

Second, Fagin et al. show that SO-tgds are closed under
composition.

Theorem 3.4 ([17]) Let M12 and M23 be mappings
speciﬁed by SO-tgds. Then the composition M12 ◦ M23
can also be speciﬁed by an SO-tgd.

It should be noticed that the previous theorem can also be
applied to mappings that are speciﬁed by ﬁnite sets of SOtgds,
 as these dependencies are closed under conjunction.
Moreover, it is important to notice that Theorem 3.4 implies 
that the composition of a ﬁnite number of mappings
speciﬁed by st-tgds can be deﬁned by an SO-tgd, as every
set of st-tgds can be expressed as an SO-tgd.

Theorem 3.5 ([17]) The composition of a ﬁnite number
of mappings, each deﬁned by a ﬁnite set of st-tgds, is deﬁned 
by an SO-tgd.

Example 3.6. Let M12 and M23 be the mappings deﬁned
in Example 3.2. The following SO-tgd correctly speciﬁes
the composition of these two mappings:

∃g(cid:18)∀n∀c (Takes(n, c) → Enrollment(g(n), c))(cid:19).

(cid:3)

Third, Fagin et al. prove in [17] that the converse of Theorem 
3.5 also holds, thus showing that SO-tgds are exactly 
the right language for representing the composition
of mappings given by st-tgds.

Theorem 3.7 ([17]) Every SO-tgd deﬁnes the composition 
of a ﬁnite number of mappings, each deﬁned by a
ﬁnite set of st-tgds.

Finally, Fagin et al. in [17] also study the complexity 
of composing schema mappings. More speciﬁcally,
they provide an exponential-time algorithm that given two
mappings M12 and M23, each speciﬁed by an SO-tgd,
returns a mapping M13 speciﬁed by an SO-tgd and equivalent 
to the composition of M12 and M23. Furthermore,
they show that exponentiality is unavoidable in such an
algorithm, as there exist mappings M12 and M23, each
speciﬁed by a ﬁnite set of st-tgds, such that every SO-tgd
that deﬁnes the composition of M12 and M23 is of size
exponential in the size of M12 and M23.

In [37], Nash et al. also study the composition problem
and extend the results of [17]. In particular, they study the
composition of mappings given by dependencies that need
not be source-to-target, and for all the classes of mappings
considered in that paper, they provide an algorithm that
attempts to compute the composition and give sufﬁcient
conditions that guarantee that the algorithm will succeed.

3.1 Composition under closed world semantics


In [28], Libkin proposes an alternative semantics for
schema mappings and, in particular, for data exchange.
Roughly speaking, the main idea in [28] is that when exchanging 
data with a set Σ of st-tgds and a source instance 
I, one generates a target instance J such that every 
tuple in J is justiﬁed by a formula in Σ and a set
of tuples from I. A target instance J that satisﬁes the
above property is called a closed-world solution for I under 
Σ [28].
In [29], Libkin and Sirangelo propose the
language of CQ-SkSTDs, that slightly extends the syntax 
of SO-tgds, and study the composition problem under
the closed-world semantics for mappings given by sets of
CQ-SkSTDs. Due to the lack of space, we do not give
here the formal deﬁnition of the closed-world semantics,
but instead we give an example that shows the intuition
behind it (see [29] for a formal deﬁnition of the semantics
and of CQ-SkSTDs).
Example 3.8. Let σ be the SO-tgd of Example 3.6. Formula 
σ is also a CQ-SkSTD [29]. Consider now a source

instance I such that TakesI = {(Chris, logic)}, and the
instances J1 and J2 such that:

EnrollmentJ1 = {(075, logic)}
EnrollmentJ2 = {(075, logic), (084, algebra)}

Notice that both (I, J1) and (I, J2) satisfy σ (considering 
an interpretation for function g such that g(Chris) =
075). Thus, under the semantics based on logical satisfaction 
[17], both J1 and J2 are solutions for I. The crucial 
difference between J1 and J2 is that J2 has an unjustiﬁed 
tuple [28]; tuple (075, logic) is justiﬁed by tuple
(Chris, logic), while (084, algebra) has no justiﬁcation. In
fact, J1 is a closed-world solution for I under σ, but J2 is
not [28, 29]. (cid:3)

Given a set Σ of CQ-SkSTDs from R1 to R2, we say
that M is speciﬁed by Σ under the closed-world semantics,
 denoted by M = cws(Σ, R1, R2), if M = {(I, J) |
I ∈ Inst(R1), J ∈ Inst(R2) and J is a closed-world solution 
for I under Σ}. Notice that, as Example 3.8 shows,
the mapping speciﬁed by a formula (or a set of formu-
las) under the closed-world semantics is different from the
mapping speciﬁed by the same formula but under the semantics 
of [17]. Thus, it is not immediately clear whether
a closure property like the one in Theorem 3.4 can be directly 
translated to the closed-world semantics.
In this
respect, Libkin and Sirangelo [29] show that the language
of CQ-SkSTDs is closed under composition.

Theorem 3.9 ([29]) Let M12 = cws(Σ12, R1, R2) and
M23 = cws(Σ23, R2, R3), where Σ12 and Σ23 are sets of
CQ-SkSTDs. Then there exists a set Σ13 of CQ-SkSTDs
such that M12 ◦ M23 = cws(Σ13, R1, R3).

4 Inversion of Schema Mappings

In the recent years, the problem of inverting schema mappings 
has received a lot of attention. In particular, the issue 
of providing a good semantics for this operator turned
out to be a difﬁcult problem. Three main proposals for
inverting mappings have been considered so far in the lit-
erature: Fagin-inverse [13], quasi-inverse [20] and maximum 
recovery [5]. In this section, we present and compare
these approaches.

Some of the notions mentioned above are only appropriate 
for certain classes of mappings. In particular, the
following two classes of mappings are used in this section
when deﬁning and comparing inverses. A mapping M
from a schema R1 to a schema R2 is said to be total if
dom(M) = Inst(R1), and is said to be closed-down on
the left if whenever (I, J) ∈ M and I ′ ⊆ I, it holds that
(I ′, J) ∈ M.

Furthermore, whenever a mapping is speciﬁed by a set
of formulas, we consider source instances as just containing 
constants values, and target instances as containing
constants and null values. This is a natural assumption in
a data exchange context, since target instances generated
as a result of exchanging data may be incomplete, thus,
null values are used as place-holders for unknown information.
 In Section 4.3, we consider inverses for alternative 
semantics of mappings and, in particular, inverses for
the extended semantics that was proposed in [18] to deal
with incomplete information in source instances.

4.1 Fagin-inverse and quasi-inverse

We start by considering the notion of inverse proposed
by Fagin in [13], and that we call Fagin-inverse in this
paper1. Roughly speaking, Fagin’s deﬁnition is based on
the idea that a mapping composed with its inverse should
be equal to the identity schema mapping. Thus, given a
schema R, Fagin ﬁrst deﬁnes an identity mapping Id as
{(I1, I2) | I1, I2 are instances of R and I1 ⊆ I2}. Then
a mapping M′ is said to be a Fagin-inverse of a mapping
M if M◦M′ = Id. Notice that Id is not the usual identity
relation over R. As explained in [13], Id is appropriate as
an identity for mappings that are total and closed-down
on the left and, in particular, for the class of mappings
speciﬁed by st-tgds.
Example 4.1. Let M be a mapping speciﬁed by st-tgds
S(x) → U (x) and S(x) → V (x).
Intuitively, M is
Fagin-invertible since all the information in the source relation 
S is transferred to both relations U and V in the target.
 In fact, the mapping M′ speciﬁed by ts-tgd U (x) →
S(x) is a Fagin-inverse of M since M ◦ M′ = Id. Moreover,
 the mapping M′′ speciﬁed by ts-tgd V (x) → S(x)
is also a Fagin-inverse of M, which shows that there need
not be a unique Fagin-inverse. (cid:3)

A ﬁrst fundamental question about any notion of inverse 
is for which class of mappings is guaranteed to exist.
 The following example from [13] shows that Fagininverses 
are not guaranteed to exist for mappings speciﬁed
by st-tgds.
Example 4.2. Let M be a mapping speciﬁed by st-tgd
S(x, y) → T (x).
Intuitively, M has no Fagin-inverse
since M only transfers the information about the ﬁrst
component of S. In fact, it is formally proved in [13] that
this mapping is not Fagin-invertible. (cid:3)

1Fagin [13] named his notion just as inverse of a schema mapping.
Since we are comparing different semantics for the inverse operator, we
reserve the term inverse to refer to this operator in general, and use the
name Fagin-inverse for the notion proposed in [13].

As pointed out in [20], the notion of Fagin-inverse is
rather restrictive as it is rare that a schema mapping possesses 
a Fagin-inverse. Thus, there is a need for weaker
notions of inversion, which is the main motivation for the
introduction of the notion of quasi-inverse of a schema
mapping in [20].

The idea behind quasi-inverses is to relax the notion
of Fagin-inverse by not differentiating between source instances 
that have the same space of solutions. More precisely,
 let M be a mapping from a schema R1 to a schema
R2. Instances I1 and I2 of R1 are data-exchange equivalent 
w.r.t. M, denoted by I1 ∼M I2, if SolM(I1) =
SolM(I2). For example, for the mapping M in Example 
4.2, we have that I1 ∼M I2, with I1 = {S(1, 2)} and
I2 = {S(1, 3)}. Then M′ is said to be a quasi-inverse of
M if the property M ◦ M′ = Id holds modulo the equivalence 
relation ∼M. Formally, given a mapping N from
R to R, mapping N [∼M, ∼M] is deﬁned as

{(I1, I2) ∈ Inst(R) × Inst(R) | exist I ′
2 and (I ′

1, I2 ∼M I ′

I1 ∼M I ′

1, I ′
1, I ′

2 with
2) ∈ N }

Then a mapping M′ is said to be a quasi-inverse of a mapping 
M if (M ◦ M′)[∼M, ∼M] = Id[∼M, ∼M].
Example 4.3. Let M be a mapping speciﬁed by st-tgd
S(x, y) → T (x).
It was shown in Example 4.2 that
M does not have a Fagin-inverse. However, mapping
M′ speciﬁed by ts-tgd T (x) → ∃y S(x, y) is a quasiinverse 
of M [20]. Notice that for the source instance
I1 = {S(1, 2)}, we have that I1 and I2 = {S(1, 3)} are
both solutions for I1 under the composition M ◦ M′. In
fact, for every I such that I ∼M I1, we have that I is a
solution for I1 under M ◦ M′. (cid:3)

In [20], the authors show that if a mapping M is Fagininvertible,
 then a mapping M′ is a Fagin-inverse of M
if and only if M′ is a quasi-inverse of M. Example 4.3
shows that the opposite direction does not hold. Thus, the
notion of quasi-inverse is a strict generalization of the notion 
of Fagin-inverse. Furthermore, the author provides in
[20] a necessary and sufﬁcient condition for the existence
of quasi-inverses for mappings speciﬁed by st-tgds, and
use this condition to show the following result:
Proposition 4.4 ([20]) There is a mapping M speciﬁed
by a single st-tgd that has no quasi-inverse.

Thus, although numerous non-Fagin-invertible schema
mappings possess natural and useful quasi-inverses [20],
there are still simple mappings speciﬁed by st-tgds that
have no quasi-inverse. This leaves as an open problem the
issue of ﬁnding an appropriate notion of inversion for sttgds,
 and it is the main motivation for the introduction of
the notion of inversion discussed in the following section.

4.2 Maximum recovery

We consider now the notion of maximum recovery introduced 
by Arenas et al. in [4]. In that paper, the authors
follow a different approach to deﬁne a notion of inversion.
In fact, the main goal of [4] is not to deﬁne a notion of inverse 
mapping, but instead to give a formal deﬁnition for
what it means for a mapping M′ to recover sound information 
with respect to a mapping M. Such a mapping
M′ is called a recovery of M in [4]. Given that, in general,
 there may exist many possible recoveries for a given
mapping, Arenas et al. introduce an order relation on recoveries 
in [4], and show that this naturally gives rise to
the notion of maximum recovery, which is a mapping that
brings back the maximum amount of sound information.
Let M be a mapping from a schema R1 to a schema
R2, and Id the identity schema mapping over R1, that is,
Id = {(I, I) | I ∈ Inst(R1)}. When trying to invert M,
the ideal would be to ﬁnd a mapping M′ from R2 to R1
such that M◦M′ = Id . Unfortunately, in most cases this
ideal is impossible to reach (for example, for the case of
mappings speciﬁed by st-tgds [13]). If for a mapping M,
there is no mapping M1 such that M ◦ M1 = Id, at least
one would like to ﬁnd a schema mapping M2 that does
not forbid the possibility of recovering the initial source
data. This gives rise to the notion of recovery proposed
in [4]. Formally, given a mapping M from a schema
R1 to a schema R2, a mapping M′ from R2 to R1 is
a recovery of M if (I, I) ∈ M ◦ M′ for every instance
I ∈ dom(M) [4].

In general, if M′ is a recovery of M, then the smaller
the space of solutions generated by M ◦ M′, the more
informative M′ is about the initial source instances. This
naturally gives rise to the notion of maximum recovery;
given a mapping M and a recovery M′ of it, M′ is said
to be a maximum recovery of M if for every recovery M′′
of M, it holds that M ◦ M′ ⊆ M ◦ M′′ [4].
Example 4.5. In [20], it was shown that the schema mapping 
M speciﬁed by st-tgd

E(x, z) ∧ E(z, y) → F (x, y) ∧ M (z)

has neither a Fagin-inverse nor a quasi-inverse. However,
it is possible to show that the schema mapping M′ speciﬁed 
by ts-tgds:

F (x, y) → ∃u (E(x, u) ∧ E(u, y)),

M (z) → ∃v∃w (E(v, z) ∧ E(z, w)),

is a maximum recovery of M. Notice that, intuitively, the
mapping M′ is making the best effort to recover the initial
data transferred by M. (cid:3)

In [4], Arenas et al. study the relationship between the
notions of Fagin-inverse, quasi-inverse and maximum recovery.

It should be noticed that the ﬁrst two notions
are only appropriate for total and closed-down on the left
mappings [13, 4]. Thus, the comparison in [4] focus on
these mappings. More precisely, it is shown in [4] that
for every mapping M that is total and closed-down on
the left, if M is Fagin-invertible, then M′ is a Fagininverse 
of M if and only if M′ is a maximum recovery 
of M. Thus, from Example 4.5, one can conclude
that the notion of maximum recovery strictly generalizes
the notion of Fagin-inverse. The exact relationship between 
the notions of quasi-inverse and maximum recovery 
is a bit more involved. For every mapping M that is
total and closed-down on the left, it is shown in [4] that if
M is quasi-invertible, then M has a maximum recovery
and, furthermore, every maximum recovery of M is also
a quasi-inverse of M.

In [4], the authors provide a necessary and sufﬁcient
condition for the existence of a maximum recovery. It is
important to notice that this is general condition as it can
be applied to any mapping, as long as it is deﬁned as a
set of pairs of instances. This condition is used in [4] to
prove that every mapping speciﬁed by a set of st-tgds has
a maximum recovery.

Theorem 4.6 ([4]) Every mapping M speciﬁed by a ﬁnite 
set of st-tgds has a maximum recovery.

4.3 Inverses for alternative semantics

When mappings are speciﬁed by sets of logical formulas,
 we have considered the usual semantics of mappings
based on logical satisfaction. However, some alternative
semantics have been considered in the literature, such as
the closed world semantics [28], the universal semantics 
[14], and the extended semantics [18]. Although some
of the notions of inverse discussed in the previous sections
can be directly applied to these alternative semantics, the
positive and negative results on the existence of inverses
need to be reconsidered in these particular cases. In this
section, we focus on this problem for the universal and
extended semantics of mappings.

4.3.1 Universal solutions semantics

Recall that a homomorphism from an instance J1 to an instance 
J2 is a function h : dom(J1) → dom(J2) such that
(1) h(c) = c for every constant c ∈ dom(J1), and (2) for
every fact R(a1, . . . , ak) in J1, fact R(h(a1), . . . , h(ak))
is in J2. Given a mapping M and a source instance I, a
target instance J ∈ SolM(I) is a universal solution for

I under M if for every J ′ ∈ SolM(I), there exists a
homomorphism from J to J ′. It was shown in [14, 15]
that universal solutions have several desirable properties
for data exchange. In view of this fact, an alternative semantics 
based on universal solutions was proposed in [15]
for schema mappings. Given a mapping M, the mapping
u(M) is deﬁned as the set of pairs

{(I, J) | J is a universal solution for I under M}.

Mapping u(M) was introduced in [15] in order to give
a clean semantics for answering target queries after exchanging 
data with mapping M. By combining the results 
on universal solutions for mappings given by st-tgds
in [14] and the results in [5] on the existence of maximum
recoveries, one can easily prove the following:

Proposition 4.7 Let M be a mapping speciﬁed by a set of
st-tgds. Then u(M) has a maximum recovery. Moreover,
the mapping (u(M))−1 = {(J, I) | (I, J) ∈ u(M)} is a
maximum recovery of u(M).

4.3.2 Extended solutions semantics

A more delicate issue regarding the semantics of mappings 
was considered in [18].
In this paper, Fagin et
al. made the observation that almost all the literature about
data exchange and, in particular, the literature about inverses 
of schema mappings, assume that source instances
do not have null values. Since null values in the source
may naturally arise when using inverses of mappings to
exchange data, the authors relax the restriction on source
instances allowing them to contain values in C ∪ N. In
fact, the authors go a step further and propose new reﬁned
notions for inverting mappings that consider nulls in the
source. In particular, they propose the notions of extended
inverse, and of extended recovery and maximum extended
recovery. In this section, we review the deﬁnitions of the
latter two notions and compare them with the previously
proposed notions of recovery and maximum recovery.

The ﬁrst observation to make is that since null values
are intended to represent missing or unknown information,
they should not be treated naively as constants [26]. In
fact, as shown in [18], if one treats nulls in that way, the
existence of a maximum recovery for mappings given by
st-tgds is no longer guaranteed.
Example 4.8. Consider a source schema {S(·, ·)} where
instances may contain null values, and let M be a mapping 
speciﬁed by st-tgd S(x, y) → ∃z (T (x, z)∧T (z, y)).
Then M has no maximum recovery if one considers a
na¨ıve semantics where null elements are used as constants
in the source [18]. (cid:3)

Since nulls should not be treated naively when exchanging 
data, in [18] the authors proposed a new way
to deal with null values.
Intuitively, the idea in [18] is
to close mappings under homomorphisms. This idea is
supported by the fact that nulls are intended to represent
unknown data, thus, it should be possible to replace them
by arbitrary values. Formally, given a mapping M, deﬁne
e(M), the homomorphic extension of M, as the mapping:

{(I, J) | ∃(I ′, J ′) : (I ′, J ′) ∈ M and there exist

homomorphisms from I to I ′ and from J ′ to J}.

Thus, for a mapping M that has nulls in source and target
instances, one does not have to consider M but e(M) as
the mapping to deal with for exchanging data and computing 
mapping operators, since e(M) treats nulls in a meaningful 
way [18]. The following result shows that with this
new semantics one can avoid anomalies as the one shown
in Example 4.8.
Theorem 4.9 ([19]) For every mapping M speciﬁed by a
set of st-tgds and with nulls in source and target instances,
e(M) has a maximum recovery.

As mentioned above, Fagin et al. go a step further in
[18] by introducing new notions of inverse for mappings
that consider nulls in the source. More speciﬁcally, a
mapping M′ is said to be an extended recovery of M
if (I, I) ∈ e(M) ◦ e(M′), for every source instance I.
Then given an extended recovery M′ of M, the mapping 
M′ is said to be a maximum extended recovery of
M if for every extended recovery M′′ of M, it holds that
e(M) ◦ e(M′) ⊆ e(M) ◦ e(M′′) [18].

At a ﬁrst glance, one may think that the notions of maximum 
recovery and maximum extended recovery are incomparable.
 Nevertheless, the next result shows that there
is a tight connection between these two notions. In particular,
 it shows that the notion proposed in [18] can be
deﬁned in terms of the notion of maximum recovery.

Theorem 4.10 A mapping M has a maximum extended
recovery if and only if e(M) has a maximum recovery.
Moreover, M′ is a maximum extended recovery of M if
and only if e(M′) is a maximum recovery of e(M).

In [18], it is proved that every mapping speciﬁed by a set
of st-tgds and considering nulls in the source has a maximum 
extended recovery. It should be noticed that this
result is also implied by Theorems 4.9 and 4.10.

Finally, another conclusion that can be drawn from the
above result is that, all the machinery developed in [4, 5]
for the notion of maximum recovery can be applied over
maximum extended recoveries, and the extended semantics 
for mappings, thus giving a new insight about inverses
of mappings with null values in the source.

4.4 Computing the inverse

Up to this point, we have introduced and compared three
notions of inverse proposed in the literature, focusing
mainly on the fundamental problem of the existence of
such inverses. In this section, we study the problem of
computing these inverses. More speciﬁcally, we present
some of the algorithms that have been proposed in the literature 
for computing them, and we study the languages
used in these algorithms to express these inverses.

Arguably, the most important problem to solve in this
area is the problem of computing inverses of mappings
speciﬁed by st-tgds. This problem has been studied for the
case of Fagin-inverse [20, 21], quasi-inverse [20], maximum 
recovery [4, 3, 5] and maximum extended recovery
[18, 19]. In this section, we start by presenting the algorithm 
proposed in [5] for computing maximum recoveries
of mappings speciﬁed by st-tgds, which by the results of
Sections 4.1 and 4.2 can also be used to compute Fagininverses 
and quasi-inverses for this class of mappings. Interestingly,
 this algorithm is based on query rewriting,
which greatly simpliﬁes the process of computing such
inverses.

Let M be a mapping from a schema R1 to a schema
R2 and Q a query over schema R2. Then a query Q′
is said to be a rewriting of Q over the source if Q′ is a
query over R1 such that for every I ∈ Inst(R1), it holds
that Q′(I) = certainM(Q, I). That is, to obtain the set
of certain answers of Q over I under M, one just has to
evaluate its rewriting Q′ over instance I.

The computation of a rewriting of a conjunctive query
is a basic step in the ﬁrst algorithm presented in this section.
 This problem has been extensively studied in the
database area [31, 32, 11, 1, 38] and, in particular, in the
data integration context [24, 23, 30]. The following algorithm 
uses a query rewriting procedure QUERYREWRITING 
to compute a maximum recovery of a mapping M
speciﬁed by a set Σ of st-tgds.
In the algorithm, if
¯x = (x1, . . . , xk), then C(¯x) is a shorthand for C(x1) ∧
· · · ∧ C(xk).
Algorithm MAXIMUMRECOVERY(M)
Input: M = (S, T, Σ), where Σ is a set of st-tgds.
Output: M′ = (T, S, Σ′), where Σ′
is a set of
CQC-TO-UCQ= ts-dependencies and M′ is a maximum
recovery of M.
1. Start with Σ′ as the empty set.
2. For every dependency of the form ϕ(¯x) → ∃¯y ψ(¯x, ¯y)
in Σ, do the following:

(a) Let Q be the query deﬁned by ∃¯y ψ(¯x, ¯y).
(b) Use QUERYREWRITING(M, Q) to compute a formula 
α(¯x) in UCQ= that is a rewriting of ∃¯y ψ(¯x, ¯y)
over the source.

(c) Add dependency ∃¯y ψ(¯x, ¯y) ∧ C(¯x) → α(¯x) to Σ′.
(cid:3)

3. Return M′ = (T, S, Σ′).

Theorem 4.11 ([4, 5]) Let M = (S, T, Σ), where Σ
is a set of st-tgds. Then MAXIMUMRECOVERY(M)
computes a maximum recovery of M in exponential
time in the size of Σ, which is speciﬁed by a set of
CQC-TO-UCQ= dependencies. Moreover,
if M is
then the output of
Fagin-invertible (quasi-invertible),
MAXIMUMRECOVERY(M) is a Fagin-inverse (quasi-
inverse) of M.

It is important to notice that the algorithm MAXIMUMRECOVERY 
returns a mapping that is a Fagin-inverse of
an input mapping M whenever M is Fagin-invertible, but
it does not check whether M indeed satisﬁes this condition 
(and likewise for the case of quasi-inverse). In fact, it
is not immediately clear whether the problem of checking
if a mapping given by a set of st-tgds has a Fagin-inverse
is decidable. In [21], the authors solve this problem showing 
the following:

Theorem 4.12 ([21]) The problem of verifying whether a
mapping speciﬁed by a set of st-tgds is Fagin-invertible is
coNP-complete.

Interestingly, it is not known whether the previous problem 
is decidable for the case of the notion of quasi-inverse.
One of the interesting features of algorithm MAXIMUMRECOVERY 
is the use of query rewriting, as it allows 
to reuse in the computation of an inverse the large
number of techniques developed to deal with the problem
of query rewriting. However, one can identify two drawbacks 
in this procedure. First, algorithm MAXIMUMRECOVERY 
returns a mapping that is speciﬁed by a set of
CQC-TO-UCQ= dependencies. Unfortunately, this type
of mappings are difﬁcult to use in the data exchange context.

In particular, it is not clear whether the standard
chase procedure could be used to produce a single canonical 
target database in this case, thus making the process of
exchanging data and answering queries much more complicated.
 Second, the output mapping of MAXIMUMRECOVERY 
can be of exponential size in the size of the input
mapping. Thus, a natural question at this point is whether
simpler and smaller inverse mappings can be computed.
In the rest of this section, we show some negative results
in this respect, and also some efforts to overcome these
limitations by using more expressive mapping languages.
The languages needed to express Fagin-inverses and
quasi-inverses are investigated in [20, 21]. In the respect,
the ﬁrst negative result proved in [20] is that there exist 
quasi-invertible mappings speciﬁed by st-tgds whose

quasi-inverse cannot be speciﬁed by st-tgds. In fact, it is
proved in [20] that the quasi-inverse of a mapping given
by st-tgds can be speciﬁed by using CQ6=,C-TO-UCQ dependencies,
 and that inequality, predicate C(·) and disjunction 
are all unavoidable in this language in order to
express such quasi-inverse. For the case of Fagin-inverse,
it is shown in [20] that disjunctions are not needed, that
is, the class of CQ6=,C-TO-CQ dependencies is expressive 
enough to represent the Fagin-inverse of a Fagininvertible 
mapping speciﬁed by a set of st-tgds.
In
[13, 21], it is proved a second negative result about the
languages needed to express Fagin-inverses, namely that
there is a family of Fagin-invertible mappings M speciﬁed 
by st-tgds such that the size of every Fagin-inverse of
M speciﬁed by a set of CQ6=,C-TO-CQ dependencies is
exponential in the size of M. Similar results are proved
in [4, 5] for the case of maximum recoveries of mappings
speciﬁed by st-tgds. More speciﬁcally, it is proved in [4]
that the maximum recovery of a mapping given by st-tgds
can be speciﬁed by using CQC-TO-UCQ= dependencies,
and that equality, predicate C(·) and disjunction are all
unavoidable in this language in order to express such maximum 
recovery. Moreover, it is proved in [5] that there is
a family of mappings M speciﬁed by st-tgds such that
the size of every maximum recovery of M speciﬁed by
a set of CQC-TO-UCQ= dependencies is exponential in
the size of M.

In view of the above negative results, Arenas et al. explore 
in [3] the possibility of using a more expressive
language for representing inverses.
In particular, they
explore the possibility of using some extensions of the
class of SO-tgds to express this operator.
In fact, Arenas 
et al. provide in [3] a polynomial-time algorithm that
given a mapping M speciﬁed by a set of st-tgds, returns
a maximum recovery of M, which is speciﬁed in a language 
that extends SO-tgds (see [3] for a precise deﬁnition 
of this language). It should be noticed that the algorithm 
presented in [3] was designed to compute maximum
recoveries of mappings speciﬁed in languages beyond
st-tgds, such as the language of nested mappings [22]
and plain SO-tgds (see Section 5 for a deﬁnition of the
class of plain SO-tgds). Thus, the algorithm proposed
in [3] can also be used to compute in polynomial time
Fagin-inverses (quasi-inverses) of Fagin-invertible (quasi-
invertible) mappings speciﬁed by st-tgds, nested mappings 
and plain SO-tgds. Interestingly, a similar approach
was used in [19] to provide a polynomial-time algorithm
for computing the maximum extended recovery for the
case of mappings deﬁned by st-tgds.

5 Query-based notions of composition 
and inverse

As we have discussed in the previous sections, to express 
the composition and the inverse of schema mappings
given by st-tgds, one usually needs mapping languages
that are more expressive than st-tgds, and that do not have
the same good properties for data exchange as st-tgds.

As a way to overcome this limitation, some weaker notions 
of composition and inversion have been proposed in
the recent years, which are based on the idea that in practice 
one may be interested in querying exchanged data by
using only a particular class of queries. In this section, we
review these notions.

5.1 A query-based notion of composition

In this section, we study the notion of composition
w.r.t. conjunctive queries (CQ-composition for short) introduced 
by Madhavan and Halevy [33]. This semantics
for composition can be deﬁned in terms of the notion of
conjunctive-query equivalence of mappings that was introduced 
in [33] for studying CQ-composition and generalized 
in [16] when studying optimization of schema
mappings. Two mappings M and M′ from S to T are
said to be equivalent w.r.t. conjunctive queries, denoted
by M ≡CQ M′, if for every conjunctive query Q, the set
of certain answers of Q under M coincides with the set of
certain answers of Q under M′. Formally, M ≡CQ M′ if
for every conjunctive query Q over T and every instance
I of S, it holds that certainM(Q, I) = certainM′ (Q, I).
Then CQ-composition can be deﬁned as follows: M3 is a
CQ-composition of M1 and M2 if M3 ≡CQ M1 ◦ M2.
the notion of CQcomposition 
is whether the class of st-tgds is closed under
this notion. This problem was implicitly studied by Fagin
et al. [16] in the context of schema mapping optimization.
 In [16], the authors consider the problem of whether
a mapping speciﬁed by an SO-tgd is CQ-equivalent to a
mapping speciﬁed by st-tgds. Thus, given that the composition 
of a ﬁnite number of mappings given by st-tgds
can be deﬁned by an SO-tgd [17], the latter problem is
a reformulation of the problem of testing whether st-tgds
are closed under CQ-composition. In fact, by using the
results and the examples in [16], one can easily construct
mappings M1 and M2 given by st-tgds such that the CQcomposition 
of M1 and M2 is not deﬁnable by a ﬁnite set
of st-tgds.

A fundamental question about

A second fundamental question about the notion of
CQ-composition is what is the right language to express
it. Although this problem is still open, in the rest of this

section we shed light on this issue. By the results in [17],
we know that the language of SO-tgds is enough to represent 
the CQ-composition of st-tgds. However, as motivated 
by the following example, some features of SO-tgds
are not needed to express the CQ-composition of mappings 
given by st-tgds.
Example 5.1. (from [17]) Consider a schema R1 consisting 
of one unary relation Emp that stores employee names,
a schema R2 consisting of a binary relation Mgr1 that assigns 
a manager to each employee, and a schema R3 consisting 
of a binary relation Mgr intended to be a copy of
Mgr1 and of a unary relation SelfMgr, that stores employees 
that are manager of themselves. Consider now
mappings M12 and M23 speciﬁed by the following sets
of st-tgds:

Σ12 = { Emp(e) → ∃m Mgr1(e, m) },
Σ23 = { Mgr1(e, m) → Mgr(e, m),

Mgr1(e, e) → SelfMgr(e) }.

Mapping M12 intuitively states that every employee must
be associated with a manager. Mapping M23 requires
that a copy of every tuple in Mgr1 must exists in Mgr,
and creates a tuple in SelfMgr whenever an employee is
the manager of her/himself. It was shown in [17] that the
mapping M13 given by the following SO-tgd:
∃f(cid:0)∀e(Emp(e) → Mgr(e, f (e)))∧
represents the composition M12 ◦ M23. Moreover, the
authors prove in [17] that the equality in the above formula 
is strictly necessary to represent that composition.
However, it is not difﬁcult to prove that the mapping M′
13
given by the following formula:

∀e(Emp(e) ∧ e = f (e) → SelfMgr(e))(cid:1)

(2)

∃f(cid:0)∀e(Emp(e) → Mgr(e, f (e)))(cid:1)
is CQ-equivalent to M13, and thus, M′
composition of M12 and M23. (cid:3)

(3)

13 is a CQWe 
say that formula (3) is a plain SO-tgd. Formally, a
plain SO-tgd from R1 to R2 is an SO-tgd satisfying the
following restrictions: (1) equality atoms are not allowed,
and (2) nesting of functions is not allowed. Notice that,
just as SO-tgds, this language is closed under conjunction
and, thus, we talk about a mapping speciﬁed by a plain
SO-tgd (instead of a set of plain SO-tgds). The following
result shows that even though the language of plain SOtgds 
is less expressive than the language of SO-tgds, they
are equally expressive in terms of CQ-equivalence.

Lemma 5.2 For every SO-tgd σ, there exists a plain SOtgd 
σ′ such that σ ≡CQ σ′.

It is easy to see that every mapping speciﬁed by a set
of st-tgds can be speciﬁed with a plain SO-tgd. Moreover,
the following theorem shows that this language is closed
under CQ-composition, thus showing that this class of dependencies 
has good properties within the framework of
CQ-equivalence.

Theorem 5.3 Let M12 and M23 be mappings speciﬁed
by plain SO-tgds. Then the CQ-composition of M12 and
M23 can be speciﬁed with a plain SO-tgd.

Thus, the CQ-composition of a ﬁnite number of mappings,
 each speciﬁed by a set of st-tgds, is deﬁnable by
a plain SO-tgd. It should be noticed that Theorem 5.3 is
a consequence of Lemma 5.2 and the fact that the class of
SO-tgds is closed under composition [17].

Besides the above mentioned results, the language of
plain SO-tgds also has good properties regarding inversion.
 In particular, it is proved in [3] that every plain SOtgd 
has a maximum recovery, and, moreover, it is given
in that paper a polynomial-time algorithm to compute it.
Thus, it can be argued that this class of dependencies is
more suitable for inversion than SO-tgds, as there exist
SO-tgds that do not admit maximum recoveries.

5.2 A query-based notion of inverse

In [3], the authors propose an alternative notion of inverse
by focusing on conjunctive queries. In particular, the authors 
ﬁrst deﬁne the notion of CQ-recovery as follows. A
mapping M′ is a CQ-recovery of M if for every instance
I and conjunctive query Q, it holds that

certainM◦M′ (Q, I) ⊆ Q(I).

Intuitively, this equation states that M′ recovers sound information 
for M w.r.t. conjunctive queries since for every
instance I, by posing a conjunctive query Q against the
space of solutions for I under M ◦ M′, one can only recover 
data that is already in the evaluation of Q over I.
A CQ-maximum recovery is then deﬁned as a mapping
that recovers the maximum amount of sound information
w.r.t. conjunctive queries. Formally, a CQ-recovery M′
of M is a CQ-maximum recovery of M if for every other
CQ-recovery M′′ of M, it holds that

certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I),

for every instance I and conjunctive query Q.

In [3], the authors study several properties about CQmaximum 
recoveries. In particular, they provide an algorithm 
to compute CQ-maximum recoveries for st-tgds
showing the following:

Theorem 5.4 ([3]) Every mapping speciﬁed by a set of sttgds 
has a CQ-maximum recovery, which is speciﬁed by a
set of CQC,6=-TO-CQ dependencies.

Notice that the language needed to express CQ-maximum
recoveries of st-tgds has the same good properties as sttgds 
for data exchange.
In particular, the language is
chaseable in the sense that the standard chase procedure
can be used to obtain a canonical solution. Thus, compared 
to the notions of Fagin-inverse, quasi-inverse, and
maximum recovery, the notion of CQ-maximum recovery
has two advantages: (1) every mapping speciﬁed by sttgds 
has a CQ-maximum recovery (which is not the case
for Fagin-inverses and quasi-inverses), and (2) such recovery 
can be speciﬁed in a mapping language with good
properties for data exchange (which is not the case for
quasi-inverses and maximum recovery).

In [3], the authors also study the minimality of the language 
used to express CQ-maximum recoveries, showing
that inequalities and predicate C(·) are both needed to express 
the CQ-maximum recoveries of mappings speciﬁed
by st-tgds.

6 Future Work

As many information-system problems involve not only
the design and integration of complex application artifacts,
 but also their subsequent manipulation, the deﬁnition 
and implementation of some operators for metadata
management has been identiﬁed as a fundamental issue to
be solved [7]. In particular, composition and inverse have
been identiﬁed as two of the fundamental operators to be
studied in this area, as they can serve as building blocks
of many other operators [34, 36]. In this paper, we have
presented some of the results that have been obtained in
the recent years about the composition and inversion of
schema mappings.

Many problems remain open in this area. Up to now,
XML schema mapping languages have been proposed and
studied [6, 2, 39], but little attention has been paid to the
formal study of XML schema mapping operators. For the
case of composition, a ﬁrst insight has been given in [2],
showing that the previous results for the relational model
are not directly applicable over XML. Inversion of XML
schema mappings remains an unexplored ﬁeld.

Regarding the relational model, we believe that the future 
effort has to be focused in providing a unifying framework 
for these operators, one that permits the successful
application of them. A natural question, for instance, is
whether there exists a schema mapping language that is
closed under both composition and inverse. Needless to

say, this uniﬁed framework will permit the modeling of
more complex algebraic operators for schema mappings.

Acknowledgments

We would like to thank L. Libkin and R. Fagin for many
useful comments. The authors were supported by: Arenas
- Fondecyt grant 1090565; P´erez - Conicyt Ph.D. Scholarship.


References
[1] S. Abiteboul and O. Duschka. Complexity of Answering Queries

Using Materialized Views. In PODS, pages 254–263, 1998.

[2] S. Amano, L. Libkin, and F .Murlak. XML schema mappings. In

PODS, pages 33-42, 2009.

[3] M. Arenas, J. P´erez, J. Reutter, and C. Riveros. Inverting schema
mappings: bridging the gap between theory and practice. In VLDB,
pages 1018–1029, 2009.

[4] M. Arenas, J. P´erez, and C. Riveros. The recovery of a schema
mapping: bringing exchanged data back. In PODS, pages 13–22,
2008.

[5] M. Arenas, J. P´erez, and C. Riveros. The recovery of a schema
mapping: bringing exchanged data back. To appear in TODS,
2009.

[6] M. Arenas and L. Libkin XML data exchange: Consistency and

query answering. JACM, 55(2), 2008.

[7] P. A. Bernstein. Applying model management to classical meta

data problems. In CIDR, 2003.

[8] P. A. Bernstein, S. Melnik. Model management 2.0: manipulating

richer mappings. In SIGMOD, pages 1-12, 2007.

[9] P. A. Bernstein, T. Green, S. Melnik, and A. Nash. Implementing

mapping composition, VLDB J. 17(2): 333-353, 2008.

[10] G. Giacomo, D. Lembo, M. Lenzerini, R. Rosati. On reconciling
In

data exchange, data integration, and peer data management.
PODS, pages 133–142, 2007.

[11] O. Duschka, M. Genesereth. Answering Recursive Queries Using

Views. In PODS, pages 109–116, 1997

[12] R. Fagin. Generalized ﬁrst-order spectra and polynomial-time recognizable 
sets. Complexity of Computation, ed. R. Karp, SIAMAMS 
Proceedings 7, 1974, pages 43–73.

[13] R. Fagin. Inverting schema mappings. TODS, 32(4), 2007.

[14] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data exchange:

semantics and query answering. TCS, 336(1):89–124, 2005.

[15] R. Fagin, P. G. Kolaitis, and L. Popa. Data exchange: getting to

[19] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan. Reverse data ex-
change: coping with nulls. Extended version of [18], submitted
for publication.

[20] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan. Quasi-inverses of

schema mappings. In TODS, 33(2), 2008.

[21] R. Fagin, A. Nash. The structure of inverses schema mappings.

IBM Research Report RJ10425, version 4, April 2008.

[22] A. Fuxman, M. Hern´andez, H. Ho, R. Miller, P. Papotti, L. Popa
Nested Mappings: Schema Mapping Reloaded In VLDB, pages
67–78, 2006

[23] A. Y. Halevy. Answering queries using views: A survey. VLDB J.

10(4): 270–294 (2001)

[24] A. Halevy. Theory of Answering Queries using Views. SIGMOD

Record 29(1), pages 40–47, 2000.

[25] A. Halevy, Z. Ives, J. Madhavan, P. Mork, D. Suciu, I. TatariIEEE 
TKDE

nov. The Piazza Peer Data Management System.
16(7):787–798 (2004)

[26] T. Imielinski and W. Lipski Jr. Incomplete information in relational

databases. JACM, 31(4):761–791, 1984.

[27] L. Libkin. Elements of Finite Model Theory. Springer, 2004.

[28] L. Libkin. Data exchange and incomplete information. In PODS,

pages 60–69, 2006.

[29] L. Libkin, C. Sirangelo. Data Exchange and Schema Mappings in

Open and Closed Worlds In PODS, pages 139–148, 2008.

[30] M. Lenzerini. Data Integration: A Theoretical Perspective..

In

PODS, pages 233–246, 2002.

[31] A. Levy, A. Mendelzon, Y. Sagiv and D. Srivastava. Answering

Queries Using Views. In PODS, pages 95–104, 1995.

[32] A. Levy, A. Rajaraman and J. Ordille. Querying Heterogeneous
Information Sources using Source Descriptions. In VLDB, pages
251–262, 1996.

[33] J. Madhavan and A. Y. Halevy. Composing mappings among data

sources. In VLDB, pages 572–583, 2003.

[34] S. Melnik. Generic model management: concepts and algorithms.

Volume 2967 of LNCS, Springer, 2004.

[35] S. Melnik, A. Adya, P. A. Bernstein. Compiling mappings to

bridge applications and databases. In TODS 33(4), 2008.

[36] S. Melnik, P. A. Bernstein, A. Y. Halevy, and E. Rahm. Supporting
executable mappings in model management. In SIGMOD, pages
167–178, 2005.

[37] A. Nash, P. A. Bernstein, S. Melnik. Composition of mappings

given by embedded dependencies. In TODS 32(1), 2007.

[38] R. Pottinger, A. Y. Halevy. MiniCon: A scalable algorithm for
answering queries using views. VLDB J. 10(2-3): 182–198 (2001)

[39] J. F. Terwilliger, P. A. Bernstein, and S. Melnik. Full-Fidelity Flexible 
Object-Oriented XML Access. In VLDB, pages 1030–1041,
2009.

the core, TODS 30(1):174–210, 2005.

[40] M. Y. Vardi. The Complexity of Relational Query Languages. In

[16] R. Fagin, P. G. Kolaitis, A. Nash, L. Popa. Towards a theory of

schema-mapping optimization. In PODS, pages 33–42, 2008.

STOC, pages 137–146, 1982.

[17] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan. Composing schema
TODS,

second-order dependencies to the rescue.

mappings:
30(4):994–1055, 2005.

[18] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan. Reverse data ex-

change: coping with nulls. In PODS, pages 23–32, 2009.

A Proofs and Intermediate Results

In this section, we provide proofs for the new results reported in this survey. Some of these proofs are related with the
notion of maximum recovery proposed in [4], and its relationship with some other notions of inverse. The main tool
used in this section regarding maximum recoveries is described in the following proposition.

Proposition A.1 ([4]) M′ is a maximum recovery of M if and only if M′ is a recovery of M and for every (I1, I2) ∈
M ◦ M′, it holds that SolM(I2) ⊆ SolM(I1).

It should be noticed that the above is a characterization of the notion of maximum recovery for a mapping M that is
total, that is, if M is a mapping from R1 to R2, then dom(M) = Inst(R1).2

A.1 Proof of Proposition 4.7

Let M be a mapping speciﬁed by a set of st-tgds. We know by [14] that every source instance has a universal solution
under M, and, thus, u(M) is a total mapping. Next we show that u(M) and u(M)−1 satisfy the condition of
Proposition A.1, which implies that u(M)−1 is a maximum recovery of u(M).

It is straightforward to show that u(M)−1 is a recovery of u(M) and, hence, it only remains to prove that for every

tuple (I1, I2) ∈ u(M) ◦ u(M)−1, it holds that:

Solu(M)(I2) ⊆ Solu(M)(I1).

Assume that (I1, I2) ∈ u(M) ◦ u(M)−1. Then there exists a target instance J such that (I1, J) ∈ u(M) and
(J, I2) ∈ u(M)−1. Thus, given that every solution in u(M) is a universal solution in M, we have that J is a universal
solution for both instances I1 and I2 in M. Hence, we have by Proposition 2.6 in [14] that SolM(I1) = SolM(I2)
and, thus, Solu(M)(I2) ⊆ Solu(M)(I1), which was to be shown.

Proof of Proposition 4.10

We ﬁrst introduce some notation to simplify the exposition. Let I1 and I2 be instances of the same schema R with
values in C ∪ N. Recall that a homomorphism from I1 to I2 is a function h : dom(I1) → dom(I2) such that, for
every constant value a ∈ C, it holds that h(a) = a, and for every R ∈ R and every tuple (a1, . . . , ak) ∈ RI1, it holds
(h(a1), . . . , h(ak)) ∈ RI2. Consider a binary relation → deﬁned as follows:

→ = {(I1, I2) | there exists a homomorphism from I1 to I2}.

In [18], relation → was introduced to simplify the deﬁnition of the extended semantics of a mapping. In fact, given a
mapping M, we have that

Notice that the relation → is idempotent, that is, it holds that (→ ◦ →) = →. In particular, we have that

e(M) = → ◦ M ◦ → .

→ ◦ e(M) = e(M),
e(M) ◦ → = e(M).

(4)
(5)

Thus, if I1, I2, J are instances such that (I1, I2) ∈ → and (I2, J) ∈ e(M), then (I1, J) ∈ e(M). Hence, if
(I1, I2) ∈ →, then it holds that Sole(M)(I2) ⊆ Sole(M)(I1). We use this property in this proof.

Before proving the proposition, we make an additional observation. The extended recovery of a mapping M is
deﬁned in [18] only for the case when the domain of e(M) is the set of all source instances. More precisely, a mapping
M′ is said to be an extended recovery of M in [18] if for every source instance I, it holds that (I, I) ∈ e(M)◦ e(M′).

2In [4], the authors provide more general characterizations for mappings that are not necessarily total by considering the notion of reduced

recovery.

Thus, it is only meaningful to compare the notions of (maximum) extended recovery and (maximum) recovery for the
class of mappings M such that e(M) is the set of all source instances. For this reason, if M is a mapping from a
schema R1 to a schema R2, then we assume in this proof that dom(e(M)) = Inst(R1). It should be noticed that this
implies by Proposition A.1 that:

M′ is a maximum recovery of e(M)

if and only if

M′ is a recovery of e(M) and for every (I1, I2) ∈ e(M) ◦ M′, it holds that Sole(M)(I2) ⊆ Sole(M)(I1).

We extensively use this property in this proof.

Now we are ready to prove Proposition 4.10. Let M be a mapping from a schema S to a schema T, and assume
that source instances are composed by null and constant values. We ﬁrst show that e(M) has a maximum recovery if
and only if M has a maximum extended recovery.

(⇒) Assume that e(M) has a maximum recovery, and let M′ be a maximum recovery of e(M). We show next that
M′ is also a maximum extended recovery of M. Since M′ is a recovery of e(M), we have that (I, I) ∈ e(M) ◦ M′
for every instance I of S. Moreover, from (5) we have that e(M) ◦ M′ = e(M) ◦ → ◦ M′ and, thus, (I, I) ∈
e(M) ◦ → ◦ M′ for every instance I of S. Thus, given that (I, I) ∈ → for every instance I of S, we obtain that
(I, I) ∈ e(M) ◦ → ◦ M′ ◦ → = e(M) ◦ e(M′) for every instance I of S, which implies that M′ is an extended
recovery of M.

Now, let M′′ be an extended recovery of M. Then, as above, we obtain that (I, I) ∈ e(M) ◦ e(M′′) for every
instance I of S. Thus, we have that e(M′′) is a recovery of e(M). Recall that M′ is a maximum recovery of e(M)
and, hence, we have that e(M) ◦ M′ ⊆ e(M) ◦ e(M′′), which implies that e(M) ◦ M′◦ → ⊆ e(M) ◦ e(M′′) ◦ →.
Therefore, given that e(M) = e(M) ◦ → and e(M′′) ◦ → = e(M′′) by (5), we have that e(M) ◦ → ◦ M′ ◦ → ⊆
e(M) ◦ e(M′′), which implies that e(M) ◦ e(M′) ⊆ e(M) ◦ e(M′′). Thus, we have shown that M′ is an extended
recovery of M, and that for every other extended recovery M′′ of M, it holds that e(M) ◦ e(M′) ⊆ e(M) ◦ e(M′′),
which implies that M′ is a maximum extended recovery of M.

(⇐) Now assume that M has a maximum extended recovery, and let M′ be a maximum extended recovery of M.

Next we show that e(M′) is a maximum recovery of e(M).

Given that M′ is an extended recovery of M, we have that (I, I) ∈ e(M) ◦ e(M′) for every instance I of S,
which implies that e(M′) is a recovery of e(M). Thus, by Proposition A.1, to prove that e(M′) is a maximum
recovery of e(M), it is enough to show that Sole(M)(I2) ⊆ Sole(M)(I1) for every (I1, I2) ∈ e(M) ◦ e(M′). Let
(I1, I2) ∈ e(M) ◦ e(M′). To prove that Sole(M)(I2) ⊆ Sole(M)(I1), we make use of the following mapping M⋆
from T to S:

M⋆ = {(J, I) | I is an instance of S and (I1, J) /∈ e(M)} ∪

{(J, I) | (I1, J) ∈ e(M) and Sole(M)(I) ⊆ Sole(M)(I1)}.

We show ﬁrst that M⋆ is an extended recovery of M, that is, we show that for every instance I of S, it holds that
(I, I) ∈ e(M)◦e(M⋆). First, assume that Sole(M)(I) ⊆ Sole(M)(I1), and consider an arbitrary instance J ⋆ such that
(I, J ⋆) ∈ e(M). Notice that (I1, J ⋆) ∈ e(M) since Sole(M)(I) ⊆ Sole(M)(I1). Thus, we have that (J ⋆, I) ∈ M⋆
and, hence, (J ⋆, I) ∈ e(M⋆). Therefore, given that (I, J ⋆) ∈ e(M) and (J ⋆, I) ∈ e(M⋆), we conclude that
(I, I) ∈ e(M) ◦ e(M⋆). Second, assume that Sole(M)(I) 6⊆ Sole(M)(I1). Then there exists an instance J ⋆ such that
(I, J ⋆) ∈ e(M) and (I1, J ⋆) /∈ e(M). By deﬁnition of M⋆, we have that (J ⋆, I) ∈ M⋆ and, thus, (J ⋆, I) ∈ e(M⋆).
Thus, we also conclude that (I, I) ∈ e(M) ◦ e(M⋆) in this case.

We are now ready to prove that for every (I1, I2) ∈ e(M) ◦ e(M′), it holds that Sole(M)(I2) ⊆ Sole(M)(I1). Let
(I1, I2) ∈ e(M) ◦ e(M′). Given that M′ is a maximum extended recovery of M and M⋆ is an extended recovery
of M, we have that e(M) ◦ e(M′) ⊆ e(M) ◦ e(M⋆) and, therefore, (I1, I2) ∈ e(M) ◦ e(M⋆). Thus, given that
2 of S such that (I1, J) ∈
e(M)◦e(M⋆) = e(M)◦M⋆◦ → by (5), we conclude that there exist instances J of T and I ′
e(M), (J, I ′
2, I2) ∈ →. Hence, by deﬁnition of M⋆, we have that Sole(M)(I ′
2) ⊆ Sole(M)(I1) (since
2, I2) ∈ →, and, therefore, we conclude
(I1, J) ∈ e(M)). But we also have that Sole(M)(I2) ⊆ Sole(M)(I ′
that Sole(M)(I2) ⊆ Sole(M)(I1), which was to be shown.

2) ∈ M⋆ and (I ′

2) since (I ′

Up to this point, we have shown that e(M) has a maximum recovery if and only if M has a maximum extended

recovery. In fact, from the preceding proof, we conclude that:

(a) if e(M) has a maximum recovery M′, then M′ is a maximum extended recovery of M, and

(b) if M has a maximum extended recovery M′, then e(M′) is a maximum recovery of e(M).

Next we prove the second part of Proposition 4.10, that is, we prove that a mapping M′ is a maximum extended
recovery of M if and only if e(M′) is a maximum recovery of e(M). It should be noticed that the “only if” direction
corresponds to property (b) above and, thus, we only need to show that if e(M′) is a maximum recovery of e(M),
then M′ is a maximum extended recovery of M.

Assume that e(M′) is a maximum recovery of e(M). Then we have that e(M′) is a recovery of e(M) and, thus,
M′ is an extended recovery of M. Now let M′′ be an extended recovery of M. Then we have that e(M′′) is a
recovery of e(M) and, hence, e(M) ◦ e(M′) ⊆ e(M) ◦ e(M′′) since e(M′) is a maximum recovery of e(M).
Therefore, we conclude that M′ is an extended recovery of M, and for every extended recovery M′′ of M, it holds
that e(M) ◦ e(M′) ⊆ e(M) ◦ e(M′′), which means that M′ is a maximum extended recovery of M. This completes
the proof of the proposition.

