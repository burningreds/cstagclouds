LDQL: A Query Language for the Web

of Linked Data

Olaf Hartig1 and Jorge P´erez2(B)

1 Hasso-Plattner-Institute for IT Systems Engineering, Potsdam, Germany

2 Department of Computer Science, Universidad de Chile, Santiago, Chile

http://olafhartig.de/

jperez@dcc.uchile.cl

Abstract. The Web of Linked Data is composed of tons of RDF documents 
interlinked to each other forming a huge repository of distributed
semantic data. Eﬀectively querying this distributed data source is an
important open problem in the Semantic Web area. In this paper, we propose 
LDQL, a declarative language to query Linked Data on the Web.
One of the novelties of LDQL is that it expresses separately (i) patterns 
that describe the expected query result, and (ii)Web navigation
paths that select the data sources to be used for computing the result.
We present a formal syntax and semantics, prove equivalence rules, and
study the expressiveness of the language. In particular, we show that
LDQL is strictly more expressive than the query formalisms that have
been proposed previously for Linked Data on the Web. The high expressiveness 
allows LDQL to deﬁne queries for which a complete execution
is not computationally feasible over the Web. We formally study this
issue and provide a syntactic suﬃcient condition to avoid this problem;
queries satisfying this condition are ensured to have a procedure to be
eﬀectively evaluated over the Web of Linked Data.

1 Introduction

In recent years an increasing amount of structured data has been published
and interlinked on the World Wide Web (WWW) in adherence to the Linked
Data principles [3]. These principles are based on standard Web technologies. In
particular, (i) the Hypertext Transfer Protocol (HTTP) is used to access data,
(ii) HTTP-based Uniform Resource Identiﬁers (URIs) are used as identiﬁers
for entities described in the data, and (iii) the Resource Description Framework 
(RDF) is used as data model. Then, any HTTP URI in an RDF triple
presents a data link that enables software clients to retrieve more data by looking 
up the URI with an HTTP request. The adoption of these principles has lead
to the creation of a globally distributed dataspace: the Web of Linked Data.

The emergence of the Web of Linked Data makes possible an online execution 
of declarative queries over up-to-date data from a virtually unbounded
set of data sources, each of which is readily accessible without any need for
implementing source-specific APIs or wrappers. This possibility has spawned
c(cid:2) Springer International Publishing Switzerland 2015
M. Arenas et al. (Eds.): ISWC 2015, Part I, LNCS 9366, pp. 73–91, 2015.
DOI: 10.1007/978-3-319-25007-6 5

74

O. Hartig and J. P´erez

research interest in approaches to query Linked Data on the WWW as if it was
a single (distributed) database. For an overview on query execution techniques
proposed in this context refer to [12].

The main contribution of this paper is the proposal of LDQL, a novel query
language for the Web of Linked Data. The most important feature of LDQL is
that it clearly separates query components for selecting query-relevant regions
of the Web of Linked Data, from components for specifying the query result
that has to be constructed from the data in the selected regions. The most basic
construction in LDQL are tuples of the form (cid:2)L, Q(cid:3) where L is an expression used
to select a set of relevant documents, and Q is a query intended to be executed
over the data in these documents as if they were a single RDF repository. In
an abstract setting one can use several formalisms to express L and Q. In our
proposal, for the former part we introduce the notion of link path expressions that
are a form of nested regular expressions (with some other important features)
used to navigate the link graph of the Web. For the latter, we use standard
SPARQL graph patterns. To begin evaluating these queries one needs to specify
a set of seed URIs. The language also possesses features to dynamically (at query
time) identify new seed URIs to evaluate portions of a query. Additionally, such
queries can be combined by using conjunctions, disjunctions, and projection. We
present a formal syntax and semantics for LDQL, propose some rewrite rules,
and study its expressive power.

While there does not exist a standard language for expressing queries over
Linked Data on the WWW, a few options have been proposed. In particular, a
ﬁrst strand of research focuses on extending the scope of SPARQL such that an
evaluation of SPARQL queries over Linked Data has a well-deﬁned semantics [9,
11,14,18]. A second strand of research focuses on navigational languages [7,14].
Although these languages have diﬀerent motivations, a commonality of all these
proposals is that, in contrast to LDQL, the deﬁnition of query-relevant regions
of the Web of Linked Data and the deﬁnition of query-relevant data within the
speciﬁed regions are mixed.

As our second main contribution we compare LDQL with three previously
proposed formalisms for querying the Web of Linked Data: SPARQL under
reachability-based query semantics [11], NautiLOD [7], and SPARQL Property
Path patterns under context-based semantics [14]. We formally prove that LDQL
is strictly more expressive than every one of these. We show that for every query
Q in the previous languages, one can eﬀectively construct an LDQL query which
is equivalent to Q. Moreover, for every one of the previous languages, there exists
an LDQL query that cannot be expressed in that language. These results show
that LDQL presents an interesting expressive power.

The downside of the expressiveness provided by LDQL is the existence of
queries for which a complete execution is not feasible in practice. To capture
this issue formally, we deﬁne a notion of Web-safeness for LDQL queries. Then,
the obvious question that arises is how to identify LDQL queries that are Websafe.
 Our last technical contribution is the identiﬁcation of a suﬃcient syntactic
condition for Web-safeness.

LDQL: A Query Language for the Web of Linked Data

75

The rest of the paper is structured as follows. Section 2 introduces a data
model that provides the basis for deﬁning the semantics of LDQL. In Section 3
we formally deﬁne the syntax and semantics of LDQL and show some simple
algebraic properties. In Section 4 we compare LDQL with the three mentioned
languages, and in Section 5 we focus on Web-safeness. Section 6 concludes the
paper and sketches future work. Proofs of the formal results in this paper can
be found in an extended version of the paper [13].

A preliminary version of some of the results in this paper have been presented
in a workshop [10]. This paper is a substantial extension of [10] reﬁning the
deﬁnition of LDQL and introducing important changes to the syntax and the
semantics of the language. Moreover, the comparison with previous proposals
was not discussed in [10].

2 Data Model

In this section we introduce a structural data model that captures the concept
of a Web of Linked Data formally. As usual [7,9,11,14,18], for the deﬁnitions
and analysis in this paper, we assume that the Web is ﬁxed during the execution
of any single query.
We use the RDF data model [5] as a basis for our model of a Web of Linked
Data. That is, we assume three pairwise disjoint, inﬁnite sets U (URIs), B (blank
nodes), and L (literals). An RDF triple is a tuple (cid:2)s, p, o(cid:3) ∈ T with T = (U ∪
B) × U × (U ∪ B ∪ L). For any RDF triple t = (cid:2)s, p, o(cid:3) we write uris(t) to denote
the set of all URIs in t.
Additionally, we assume another inﬁnite set D that is disjoint from U, B,
and L, respectively. We refer to elements in this set as documents and use them
to represent the concept of Web documents from which Linked Data can be
extracted. Hence, we assume a function, say data, that maps each document
d ∈ D to a ﬁnite set of RDF triples data(d) ⊆ T such that the data of each
document uses a unique set of blank nodes.

Given these preliminaries, we are ready to deﬁne a Web of Linked Data.

Deﬁnition 1. A Web of Linked Data is a tuple W = (cid:2)D, adoc(cid:3) that consists
of a set of documents D ⊆ D and a partial function adoc : U → D that is
surjective.

Function adoc of a Web of Linked Data W = (cid:2)D, adoc(cid:3) captures the relationship 
between the URIs that can be looked up in this Web and the documents
that can be retrieved by such lookups. Since not every URI can be looked up, the
function is partial. For any URI u ∈ U with u ∈ dom(adoc) (i.e., any URI that
can be looked up in W ), document d = adoc(u) can be considered the authoritative 
source of data for u in W (hence, the name adoc). To accommodate for
documents that are authoritative for multiple URIs, we do not require injectivity 
for function adoc. However, we require surjectivity because we conceive
documents as irrelevant for a Web of Linked Data if they cannot be retrieved by
any URI lookup in this Web.

76

O. Hartig and J. P´erez

Fig. 1. The link graph GWex of our example Web of Linked Data Wex.

Let W = (cid:2)D, adoc(cid:3) be a Web of Linked Data. W is said to be ﬁnite [11]
if its set D of documents is ﬁnite. In this paper we assume that every Web of
Linked Data is ﬁnite. Given documents d, d(cid:3) ∈ D and a triple t ∈ data(d), we
say that a URI u ∈ uris(t) establishes a data link from d to d(cid:3), if adoc(u) = d(cid:3).
As a ﬁnal concept, we formalize the notion of a link graph associated to W.
This graph has documents in D as nodes, and directed edges representing data
links between documents. Each edge is associated with a label that identiﬁes
both the particular RDF triple and the URI in this triple that establishes the
corresponding data link. These labels shall provide the basis for deﬁning the
navigational component of our query language.
Deﬁnition 2. The link graph of a Web of Linked Data W = (cid:2)D, adoc(cid:3),
is a directed, edge-labeled multigraph, GW = (cid:2)D, EW(cid:3), with set of edges
(cid:2)(cid:2)dsrc, (t, u), dtgt(cid:3) | t ∈ data(dsrc), u ∈
EW ⊆ D × (T × U) × D deﬁned as EW =
(cid:3)
uris(t) and dtgt = adoc(u)

For a link graph edge e = (cid:2)dsrc, (t, u), dtgt(cid:3), tuple (t, u) is the label of e.
Moreover, we sometimes write e ∈ GW to denote that e is an edge in the link
graph GW .
Example 1. As a running example for this paper assume a simple Web of Linked
Data Wex = (cid:2)Dex, adocex(cid:3) with three documents, dA, dB, and dC (i.e., Dex =
{dA, dB, dC}). The data in these documents are the following sets of RDF triples:

.

data(dA) = {(cid:2)uA, p1, uB(cid:3),
(cid:2)uB, p2, uC(cid:3)};

data(dB) = {(cid:2)uB, p1, uC(cid:3)};
data(dC) = {(cid:2)uA, p2, uC(cid:3)};

and for function adocex we have: adocex(uA) = dA, adocex(uB) = dB, adocex(uC) =
dC, and adocex(p1) = dA (i.e., dom(adocex)={uA, uB, uC, p1}). This Web contains
10 data links. For instance, URI uA in the RDF triple (cid:2)uA, p2, uC(cid:3) ∈ data(dC)
establishes a data link to document dA. Hence, the corresponding edge in the
(cid:4)
. Figure 1 illustrates the link graph
link graph of Wex is
GWex with all 10 edges.

dC, ((cid:2)uA, p2, uC(cid:3), uA), dA

(cid:5)

3 Deﬁnition of LDQL

This section deﬁnes our Linked Data query language, LDQL. LDQL queries are
meant to be evaluated over a Web of Linked Data and each such query is built

LDQL: A Query Language for the Web of Linked Data

77

from two types of components: Link path expressions (LPEs) for selecting que-
ry-relevant documents of the queried Web of Linked Data; and SPARQL graph
patterns for specifying the query result that has to be constructed from the
data in the selected documents. For this paper, we assume that the reader is
familiar with the deﬁnition of SPARQL [8], including the algebraic formalization 
introduced in [2,16]. In particular, for SPARQL graph patterns we closely
follow the formalization in [2] considering operators AND, OPT, UNION, FILTER, and
GRAPH, plus the operator BIND deﬁned in [8]. We begin this section by introducing
the most basic concept of our language, the notion of link patterns. We use link
patterns as the basis for navigating the link graph of a Web of Linked Data.

3.1 Link Patterns
(cid:6)U ∪ { , +}(cid:7) × (cid:6)U ∪ { , +}(cid:7) × (cid:6)U ∪ L ∪ { , +}(cid:7)
.
A link pattern is a tuple in
Link patterns are used to match link graph edges in the context of a designated
context URI. The special symbol + denotes a placeholder for the context URI.
denotes a wildcard that will drive the direction of the
The special symbol
navigation. Before formalizing how link graph edges actually match link patterns,
we show some intuition. Consider the link graph of Web Wex in Example 1 (see
(cid:3). Intuitively, in the context of URI uA, the
Fig. 1), and the link pattern (cid:2)+, p1,
edge with label ((cid:2)uA, p1, uB(cid:3), uB) from document dA to document dB, matches
(cid:3). Notice that in the matching, the context URI uA
the link pattern (cid:2)+, p1,
takes the place of symbol +, and uB takes the place of the wildcard symbol
. Notice that uB also denotes the direction of the edge that matches the link
pattern. On the other hand, the edge with label ((cid:2)uA, p1, uB(cid:3), uA) from dA to
dA, does not match (cid:2)+, p1,
(cid:3); although uB can take the place of the wildcard
, the direction of the edge is not to uB. That is, when matching an edge
symbol
labeled by (t, u) we require URI u to be taking the place of a wildcard in the link
pattern. When more than one wildcard symbol is used, the link pattern can be
matched by edges pointing to the direction of any of the URIs taking the place
of a wildcard. For instance, in the context of uA, the link pattern (cid:2)
(cid:3) is
matched by edges (cid:2)dA, ((cid:2)uB, p2, uC(cid:3), uB), dB(cid:3) and (cid:2)dA, ((cid:2)uB, p2, uC(cid:3), uC), dC(cid:3). The
next deﬁnition formalizes this notion of matching.
Deﬁnition 3. A link graph edge with label ((cid:2)x1, x2, x3(cid:3), u) matches a link
pattern (cid:2)y1, y2, y3(cid:3) in the context of a URI uctx if the following two properties
hold:
1. there exists i ∈ {1, 2, 3} such that yi = and xi = u, and
2. for every i ∈ {1, 2, 3} either yi = + and xi = uctx, or yi = xi, or yi = .

, p2,

One of the rationales for adopting the notion of a context URI and the +
symbol in our deﬁnition of link patterns, is to support cases in which link graph
navigation has to be focused solely on data links that are authoritative. A data
link represented by link graph edge (cid:2)dsrc, (t, u), dtgt(cid:3) ∈ GW is authoritative in a
Web of Linked Data W = (cid:2)D, adoc(cid:3) if dsrc = adoc(u(cid:3)) for some URI u(cid:3) ∈ uris(t).
Thus, if we ﬁx a context URI uctx, a link pattern that uses the + symbol allows
us to follow only authoritative data links from document dctx = adoc(uctx).

78

O. Hartig and J. P´erez

3.2 LDQL Queries
The most basic construction in LDQL queries are tuples of the from (cid:2)L, P(cid:3) where
L is an expression used to select a set of documents from the Web of Linked
Data, and P is a SPARQL graph pattern to query these documents as if they
were a single RDF dataset. In an abstract setting, one can use any formalism
to specify L as long as L deﬁnes sets of RDF documents. In our proposal we
use what we call link path expressions (LPEs) that are a form of nested regular
expressions [17] over the alphabet of link patterns. Every link path expression
begins its navigation in a context URI, traverses the Web, and returns a set of
URIs; these URIs are used to construct an RDF dataset with all the documents
to be retrieved by looking up the URIs. This dataset is passed to the SPARQL
graph pattern to obtain the ﬁnal evaluation of the whole query. Besides the
basic constructions of the form (cid:2)L, P(cid:3), in LDQL one can also use AND, UNION and
projection, to combine them. We also introduce an operator SEED that is used
to dynamically change, at query time, the seed URI from which the navigation
begins. The next deﬁnition formalizes the syntax of LDQL queries and LPEs.

Deﬁnition 4. The syntax of LDQL is given by the following production rules
in which lp is an arbitrary link pattern, ?v is a variable, P is a SPARQL graph
pattern (as per [2]), V is a ﬁnite set of variables, and U is a ﬁnite set of URIs:
q := (cid:2)lpe, P(cid:3) | (SEED U q) | (SEED ?v q) | (q AND q) | (q UNION q) | πV q
lpe := ε | lp | lpe/lpe | lpe|lpe | lpe

∗ | [lpe] | (cid:2)?v, q(cid:3)

Any expression that satisﬁes the production q is an LDQL query, any expression 
that satisﬁes the production lpe is a link path expression (LPE), and
any LDQL query of the form (cid:2)lpe, P(cid:3) is a basic LDQL query.

Before going into the formal semantics of LDQL and LPEs, we give some
more intuition about how these expressions are evaluated in a Web of Linked
Data W. As mentioned before, the most basic expression in LDQL is of the
form (cid:2)lpe, P(cid:3). To evaluate this expression over W we will need a set S of seed
URIs. When evaluating (cid:2)lpe, P(cid:3), every one of the seed URIs in S will trigger a
navigation of link graph GW via the link path expression lpe starting on that
seed. That is, the seed URIs are passed to lpe as context URIs in which the LPE
should be evaluated. These evaluations of lpe will result in a set of URIs that
are used to construct a dataset over which P is ﬁnally evaluated.
Regarding the navigation of link graph GW, the most basic form of navigation 
is to follow a single link graph edge that matches a link pattern lp. When
a navigation via a link pattern lp is triggered from a context URI u, we proceed 
as follows. We ﬁrst go to the authoritative document for u, that is adoc(u),
and try to ﬁnd outgoing link graph edges that match lp in the context of u (as
explained in Section 3.1). Every one of these matches deﬁnes a new context URI
u(cid:3) from which the navigation can continue. More complex forms of navigation
are obtained by combining link patterns via classical regular expression operators 
such as concatenation /, disjunction |, and recursive concatenation (·)∗.

LDQL: A Query Language for the Web of Linked Data

79

The nesting operator [·] is used to test for existence of paths. When a context
URI u is passed to an expression [lpe], it checks whether GW contains a path from
dctx = adoc(u) that matches lpe. If such a path exists, the navigation can continue 
from the same context URI u. The most involved form of navigation is by
using the expression (cid:2)?v, q(cid:3) with q an LDQL query. To evaluate this expression
from context URI u one ﬁrst has to pass u as a seed URI for q and recursively
evaluate q from that seed. This evaluation generates a set of solution mappings,
and for every one of these mappings its value on variable ?v is used as the new
context URI from which the navigation continues. Finally, note that our notion
of LPEs does not provide an operator for navigating paths in their inverse direction.
 The reason for omitting such an operator is that traversing arbitrary data
links backwards is impossible on the WWW.
To formally deﬁne the semantics of LDQL we need to introduce some terminology.
 We ﬁrst deﬁne a function datasetW (·) that from a set of URIs constructs 
an RDF dataset with all the documents pointed to by those URIs
in W. Formally, given a Web of Linked Data W = (cid:2)D, adoc(cid:3) and a set U
of URIs, datasetW (U) is an RDF dataset (as per [2,8]) that has the set of
triples {t ∈ data(adoc(u)) | u ∈ U ∩ dom(adoc)} as default graph. Moreover,
for every URI u ∈ U ∩ dom(adoc), datasetW (U) contains the named graph
(cid:2)u, data(adoc(u))(cid:3).
Example 2. Consider the Web Wex
in Example 1 and the set of URIs
U = {uA, uC}. Then datasetWex(U) has {(cid:2)uA, p1, uB(cid:3),(cid:2)uB, p2, uC(cid:3),(cid:2)uA, p2, uC(cid:3)}
as default graph, and two named graphs, (cid:2)uA,{(cid:2)uA, p1, uB(cid:3),(cid:2)uB, p2, uC(cid:3)}(cid:3) and
(cid:2)uC,{(cid:2)uA, p2, uC(cid:3)}(cid:3).

In the formalization of the semantics of LDQL, we use the standard join operator 
(cid:2)(cid:3) over sets of solution mappings [8,16]. We also make use of the semantics
of SPARQL graph patterns over datasets as deﬁned in [2]. In particular, given
an RDF dataset D, an RDF graph G in D, and a SPARQL graph pattern P , we
denote by [[P ]]D

G the evaluation of P over G in D [2, Deﬁnition 13.3].

We are now ready to formally deﬁne the semantics of LDQL and LPEs. Given
a Web of Linked Data W and a set S of URIs, we formalize the evaluation of
LDQL queries over W from the seed URIs S, as a function [[·]]S
W that given an
LDQL query, produces a set of solution mappings. Similarly, the evaluation of
LPEs over W from a context URI u, is formalized as a function [[·]]u
W that given
an LPE, produces a set of URIs.
Deﬁnition 5. Given a ﬁnite set S ⊆ U, the S-based evaluation of LDQL
queries over a Web of Linked Data W =(cid:2)D, adoc(cid:3), denoted by [[·]]S
W , is deﬁned
recursively as follows:

80

O. Hartig and J. P´erez

[[(cid:2)lpe, P(cid:3)]]
S
D
W = [[P ]]
G where D = datasetW
U
S
W = [[q]]
W ,
[[(SEED U q)]]
(cid:3)
S
[[(SEED ?v q)]]
W =
S
[[(q1 UNION q2)]]
W = [[q1]]
S
[[(q1 AND q2)]]
W = [[q1]]
W = {μ | there exists μ(cid:3)∈ [[q]]
S
[[ πV q ]]

(cid:2)
W (cid:2)(cid:3) {μu}(cid:4)
{u}
[[q]]
u∈U
W ∪ [[q2]]
S
S
W (cid:2)(cid:3) [[q2]]

S
W ,
S
W ,

S

(cid:2)(cid:3)

u∈S[[lpe]]u

W

(cid:4)

with default graph G,

where μu = {?v (cid:4)→ u} for all u ∈ U,

compatible and dom(μ) = dom(μ(cid:3)

W such that μ and μ(cid:3)
) ∩ V }.

are

Now for the semantics of LPEs, given a context URI uctx ∈ dom(adoc), the
uctx-based evaluation of LPEs over W, denoted by [[·]]uctx
W , is deﬁned recursively
as follows:

uctx
W ,

W

uctx

uctx

, p1,

uctx

uctx

uctx

uctx

uctx

uctx

, p2,

[[ ε ]]
[[lp]]

W ∪ [[lpe 2]]

uctx

W ∪ ... ,

uctx

W ∪ [[lpe/lpe/lpe]]

uctx

such that μ(?v) = u}.

W ∪ [[lpe/lpe]]
W (cid:9)= ∅},

W = {uctx},
W = {u ∈ U | there exist a link graph edge (cid:2)dsrc, (t, u), dtgt(cid:3) ∈ GW , with
dsrc = adoc(uctx), that matches lp in the context of uctx},
W | u(cid:3) ∈ [[lpe 1]]
u(cid:2)

W },

[[lpe 1/lpe 2]]
[[lpe 1|lpe 2]]
[[lpe∗
]]
[[ [lpe] ]]
[[(cid:2)?v, q(cid:3) ]]

{uctx}
W = ∅ for every LPE.
(cid:3)∗/[(cid:2)

W = {u ∈ [[lpe 2]]
uctx
W = [[lpe 1]]
W = {uctx} ∪ [[lpe]]
uctx
W = {uctx | [[lpe]]
W = {u ∈ U | there exists μ ∈ [[q]]
Moreover, if uctx /∈ dom(adoc), then [[lpe]]uctx
(cid:3)]. This LPE selects docExample 
3. Let lpe ex be the LPE (cid:2)
uments that can be reached via arbitrarily long paths of data links with predicate 
p1 and, additionally, have some outgoing data link with predicate p2. For
our example Web Wex and context URI uA, the LPE selects documents dA =
= {uA, uC}.
adocex(uA) and dC = adocex(uC). More precisely, we have [[lpe ex]]uA
Wex
Note that document dB can also be reached via a p1–path, but it does not pass
the p2–related test.
Example 4. Consider a set of URIs Sex = {uA} and a basic LDQL
, Bex(cid:3) whose LPE is lpe ex as introduced in Example 3 and
query (cid:2)lpe ex
whose SPARQL graph pattern is a basic graph pattern that contains
two triple patterns, Bex = {(cid:2)?x, p1, ?y(cid:3),(cid:2)?x, p2, ?z(cid:3)}. Given that we have
[[lpe ex]]uA
) has the default
graph {(cid:2)uA, p1, uB(cid:3),(cid:2)uB, p2, uC(cid:3),(cid:2)uA, p2, uC(cid:3)} (cf. Example 2). Then, according
Wex
to the query semantics, the result of query (cid:2)lpe ex
, Bex(cid:3) over Wex using seeds Sex
consists of a single solution mapping, namely μ = {?x (cid:10)→ uA, ?y (cid:10)→ uB, ?z (cid:10)→ uC}.
ε,(cid:2)?x, p1, ?w(cid:3)(cid:5)(cid:7)
(cid:6)
Example 5. Consider an LDQL query qex =
SEED ?x
whose
subquery is a basic LDQL query that has a single triple pattern as its SPARQL
,{(cid:2)?x, p1, ?y(cid:3),(cid:2)?x, p2, ?z(cid:3)}(cid:5)
graph pattern. Additionally, let q(cid:3)
be the
basic LDQL query introduced in Example 4, and let q(cid:3)(cid:3)
ex be the conjunction
of these two queries; i.e., q(cid:3)(cid:3)
ex). By Example 4 we know that

= {uA, uC} (cf. Example 3), datasetWex([[lpe ex]]uA

ex =

lpe ex
ex = (qex AND q(cid:3)

Wex

(cid:4)

(cid:4)

LDQL: A Query Language for the Web of Linked Data

81

= {μ} with μ = {?x (cid:10)→ uA, ?y (cid:10)→ uB, ?z (cid:10)→ uC}. Furthermore, based
[[q(cid:3)
ex]]Sex
Wex
= {μ1, μ2} with
on the data given in Example 1, it is easy to see that [[qex]]Sex
μ1 = {?x (cid:10)→ uA, ?w (cid:10)→ uB} and μ2 = {?x (cid:10)→ uB, ?w (cid:10)→ uC}. For the Sex-based
Wex
and [[q(cid:3)
evaluation of q(cid:3)(cid:3)
have to be joined.
Thus, we need to compute {μ1, μ2} (cid:2)(cid:3) {μ}, which results in a single mapping
μ(cid:3) = μ1 ∪ μ = {?x (cid:10)→ uA, ?w (cid:10)→ uC, ?y (cid:10)→ uB, ?z (cid:10)→ uC}.

ex over Wex, the result sets [[qex]]Sex
Wex

ex]]Sex
Wex

3.3 Algebraic Properties of LDQL Queries

As a basis for the discussion in the next sections, we show some simple algebraic 
properties. We say that LDQL queries q and q(cid:3) are semantically equivalent,
denoted by q ≡ q(cid:3), if [[q]]S
W holds for every Web of Linked Data W and
every ﬁnite set S ⊆ U.
Lemma 1. The operators AND and UNION are associative and commutative.

W = [[q(cid:3)]]S

Lemma 2. Let q1, q2, q3 be LDQL queries, the following semantic equivalences
hold:

πV (q1 UNION q2) ≡ (πV q1 UNION πV q2)

(q1 AND (q2 UNION q3)) ≡ ((q1 AND q2) UNION (q1 AND q3))
(SEED U (q1 UNION q2)) ≡ ((SEED U q1) UNION (SEED U q2))
(SEED ?v (q1 UNION q2)) ≡ ((SEED ?v q1) UNION (SEED ?v q2))

(1)
(2)
(3)
(4)

Lemma 1 allows us to write sequences of either AND or UNION without parentheses.
 Our next result shows the power of the construction (cid:2)?v, q(cid:3). In particular,
it shows the somehow surprising ﬁnding that link patterns lp, concatenation /,
disjunction |, and the test [·], are just syntactic sugar as they can be simulated
by using ε, (cid:2)?v, q(cid:3) and (·)∗.
Proposition 1. For every LDQL query q, there exists an LDQL query q(cid:3) s.t.
q ≡ q(cid:3) and every LPE in q(cid:3) consists only of the symbol ε, the construction (cid:2)?v, q(cid:3),
and operator (·)∗.
Proof (Sketch). The proof is based on a recursive translation of link path expressions 
beginning with link patterns. For instance, a link pattern of the form
(cid:3) is encoded by (cid:2)?v,(cid:2)ε, (GRAPH ?u (?u, p, ?v))(cid:3)(cid:3), and we can similarly
(cid:2)+, p,
encode all types of link patterns. To encode / we make use of (cid:2)?v, q(cid:3) and the
operator AND inside q as follows. Consider an LPE r = r1/r2. It can be shown
that r is equivalent to (cid:2)?v, q(cid:3) where q is:
(cid:2)
SEED ?x (cid:2)r2, (GRAPH ?v { })(cid:3)(cid:4) (cid:4)

(cid:2) (cid:2)r1, (GRAPH ?x { })(cid:3) AND

Similarly, to encode | we make use of UNION and to encode [·] we use projection.
Although not strictly necessary, we decided to keep link patterns and operators 
/, |, and [·] since they represent a natural and intuitive way of expressing
navigation paths.

.

82

O. Hartig and J. P´erez

4 Comparison with Previous Linked Data Query

Formalisms

In this section, we compare LDQL with alternative formalisms to query Linked
Data on the WWW. There are some general query languages for the WWW (proposed 
before the advent of Linked Data) that are related to our proposal; in
particular, WebSQL [15], which is similar in spirit to LDQL but diﬀerent in the
features that the languages posses. Two main novelties of LDQL compared with
WebSQL are the possibility to dynamically select seed URIs at query time, and
the traversal of links according to properties of the queried documents that can
be deﬁned in the same LDQL query. Neither of these are expressible in WebSQL.
While a complete formal comparison between LDQL and WebSQL is certainly
very interesting, we leave it for future work and, instead, focus on three more
recent proposals of query formalisms for the Web of Linked Data [7,11,14]. We
formally show that LDQL is strictly more expressive than every one of them.

4.1 Comparison with Property Paths Under Context-Based Query

Semantics

Property paths (PPs for short) were introduced in SPARQL 1.1 as a way of
adding navigational power to the language [8]. PPs are a form of regular expressions 
that are evaluated over a single (local) RDF graph; a PP expression is used
to retrieve pairs (cid:2)a, b(cid:3) of nodes in the graph such that there is a path from a
to b whose sequence of edge labels belongs (as a string) to the regular language
deﬁned by the expression. The syntax of PP expressions is given by the following
grammar1, where p, u1, u2, ... , uk are URIs.

pe := p | !(u1|u2|···|uk) | pe/pe | pe|pe | pe

∗

A PP-pattern is deﬁned as a tuple of the form (cid:2)α, pe, β(cid:3) where pe is a PP expression,
 and α and β are in U ∪ L ∪ V.

In [14] the authors adapted the semantics of PP-patterns so that they can
be used to query the Web of Linked Data. The proposed query semantics is
called context-based semantics [14]. To deﬁne this semantics, the authors ﬁrst
introduce the notion of a context selector for a Web of Linked Data W. This
context selector is a function CW(·) that given a URI u ∈ dom(adoc) returns the
RDF triples in data(adoc(u)) that have u in the subject position. Formally, for
every URI u ∈ dom(adoc) we have CW(u) = {(cid:2)s, p, o(cid:3) ∈ data(adoc(u)) | s = u}.
To simplify the exposition, the authors extended the deﬁnition of CW(·) to also
handle URIs not in dom(adoc), and literals and blank nodes. For any such RDF
term a they deﬁne CW(a) as the empty set.

1 In [14] the reverse path construction ˆpe is also considered. We do not consider it
here as the form of navigation of these reverse paths does not represent a traversal
of the link graph.

LDQL: A Query Language for the Web of Linked Data

83

The context-based semantics for PPs over the Web of Linked Data in [14] is
a bag semantics that follows closely the semantics for PPs deﬁned in the normative 
semantics of SPARQL 1.1 [8]. Hence, both semantics use a procedure, the
ArbitraryLengthPath procedure [8], to deﬁne the semantics of the (·)∗ operator.
It was shown in [1] that for sets semantics, the normative semantics of PPs can
be deﬁned by using standard techniques for regular expressions. To make the
comparison with LDQL, in this paper we adapt the context-based semantics for
PPs presented in [14] by following the techniques in [1], and consider only sets
of mappings. To this end, we deﬁne a function [[·]]ctxt
W , that given a PP-pattern,
returns its evaluation under context-based semantics over the Web of Linked
Data W. In the deﬁnition, for a solution mapping μ and an RDF term α, we use
the notation μ[α] with the following meaning: μ[α] = μ(α) if α ∈ dom(μ), and
μ[α] = α in the other case. Similarly, μ[(cid:2)s, p, o(cid:3)] = (cid:2)μ[s], μ[p], μ[o](cid:3).

[[(α, p, β)]]ctxt
[[(α, !(u1|···|uk), β)]]ctxt

W = {μ | dom(μ) = {α, β} ∩ V and μ[(cid:2)α, p, β(cid:3)] ∈ CW
W = {μ | dom(μ) = {α, β} ∩ V and exists p s.t.

(μ[α])}

[[(α, pe1/pe2, β)]]ctxt
[[(α, pe1|pe2, β)]]ctxt
[[(α, pe∗, β)]]ctxt

μ[(cid:2)α, p, β(cid:3)] ∈ CW

(μ[α]) and p /∈ {u1, ... , uk}}
W (cid:2)(cid:3) [[(?v, pe2, β)]]ctxt
W

(cid:4)

(cid:2)
[[(α, pe1, ?v)]]ctxt
W ∪ [[(α, pe2, β)]]ctxt

W = π{α,β}∩V
W = [[(α, pe1, β)]]ctxt
W = {μ | dom(μ) ={α, β} ∩ V, μ[α] = μ[β] and μ[α]∈ terms(W )}∪
W ∪ ···

W ∪[[(α, pe/pe/pe, β)]]ctxt

W ∪[[(α, pe/pe, β)]]ctxt

[[(α, pe, β)]]ctxt

W

A PP-based SPARQL query [14] is an expression formed by combining PPpatterns 
using the standard SPARQL operators AND, UNION, OPT, FILTER and so
on, following the standard semantics for these operators [2]. Our next results
show that LDQL is strictly more expressive than PP-based SPARQL queries
under context-based semantics.

Theorem 1. There exists an LDQL query that cannot be expressed as a PPbased 
SPARQL query under context-based semantics.

(cid:4)(cid:2)+, p,

(cid:6)
SEED U

(cid:5)(cid:7)

(cid:3),
Proof (Sketch). One can show that LDQL query q =
with U = {u} cannot be expressed by PPs under context-
(?x, ?x, ?x)
based semantics because this semantics is “blind” to triples that are not authoritative.
 For instance, in a Web W = (cid:2){d, d(cid:3)}, adoc(cid:3) with data(d) = {(cid:2)u, p, u(cid:3)(cid:3)},
data(d(cid:3)) = {(cid:2)u(cid:3), p, u(cid:3),(cid:2)u, u, u(cid:3)}, adoc(u) = d and adoc(u(cid:3)) = d(cid:3), the evaluation of
q is the solution mapping {?x (cid:10)→ u}. Notice that the only authoritative triple in
d(cid:3) is (cid:2)u(cid:3), p, u(cid:3) as d(cid:3) = adoc(u(cid:3)) (cid:12)= adoc(u). Hence, one can prove that PP-based
SPARQL queries under context-based semantics cannot access triple (cid:2)u, u, u(cid:3) in
d(cid:3), and thus, will never have {?x (cid:10)→ u} as solution.
Theorem 2. Let α, β ∈ U ∪ L ∪ V. Then, for every PP-pattern (cid:2)α, pe, β(cid:3), there
exists an LDQL query q such that [[(cid:2)α, pe, β(cid:3)]]ctxt
W for every Web of Linked
Data W.

W = [[q]]∅

84

O. Hartig and J. P´erez

Proof (Sketch). In the proof we provide a translation scheme from PPs to LDQL.
One major complication is that PPs can retrieve literals and, in general, values
that are not in dom(adoc), which are diﬃcult to handle by LPEs. For every
PP-pattern (cid:2)?x, pe, ?y(cid:3) we construct an LDQL query Qpe(?x, ?y). For example,
, ?y(cid:3), our query is π{?x,?y}
for (cid:2)?x, pe1
/pe2
, and for
(cid:6)
(cid:2)?x, !(u1|···|uk), ?y(cid:3) the translation is
(?x, ?p, ?y) FILTER (?p (cid:12)= u1∧
SEED ?x
(cid:7)(cid:5)(cid:7)
. To handle pe∗ we need to use the construction (cid:2)?v, q(cid:3) of LPEs,
···∧ ?p (cid:12)= uk)
plus (·)∗.

(cid:7)
Qpe1(?x, ?z) AND Qpe2(?z, ?y)

ε,

(cid:4)

(cid:6)

(cid:6)

4.2 Comparison with NautiLOD
NautiLOD is a navigation language to traverse Linked Data on the WWW and
to perform actions (such as sending emails) during the traversal [7]. We compare
LDQL with NautiLOD without action rules. The syntax of NautiLOD expressions 
(without actions) is given by the following grammar (where p ∈ U and P
is a SPARQL graph pattern).
ne := p | pˆ | (cid:2)

(cid:3) | ne/ne | ne|ne | ne

∗ | ne[(ASK P )]

In terms of our data model2, the semantics of NautiLOD expressions over a Web
of Linked Data W = (cid:2)D, adoc(cid:3) from URI u ∈ dom(adoc) is deﬁned recursively
as follows.

∗

W

W with u(cid:3)∈ dom(adoc)}

W = {u(cid:3) | (cid:2)u, p, u(cid:3)(cid:3) ∈ data(adoc(u))}
[[ p ]]u
W = {u(cid:3) | (cid:2)u(cid:3), p, u(cid:3) ∈ data(adoc(u))}
[[ pˆ ]]u
[[(cid:2)
(cid:3) ]]u
W = {u(cid:3) | (cid:2)u, p, u(cid:3)(cid:3) ∈ data(adoc(u)) for some p ∈ U}
W ={u(cid:3)(cid:3)| u(cid:3)(cid:3)∈[[ ne2 ]]u(cid:2)
[[ ne1/ne2 ]]u
[[ ne1| ne2 ]]u
W ∪ [[ ne2 ]]u
W = [[ ne1 ]]u
W = {u} ∪ [[ ne ]]u
]]u
W = {u(cid:3) | u(cid:3) ∈ [[ ne ]]u
[[ ne[(ASK P )] ]]u

W for some u(cid:3)∈[[ ne1 ]]u

W ∪ [[ ne/ne/ne ]]u

W ∪ [[ ne/ne ]]u

[[ ne

W , u(cid:3) ∈ dom(adoc) and [[P ]]data(adoc(u(cid:2)))

(cid:12)= ∅}
We next show that for every NautiLOD expression there exists an equivalent
LDQL query. Notice that the evaluation of a NautiLOD expression is a set of
URIs, whereas the evaluation of an LDQL query is a set of mappings. Thus, to
formally state our result we compare NautiLOD with LDQL queries that have
a single free variable. Let q(?x) be an LDQL query with ?x as free variable. We
say that q(?x) and a NautiLOD expression ne are equivalent if for every Web of
Linked Data W = (cid:2)D, adoc(cid:3) and URIs u, u(cid:3) with u ∈ dom(adoc) it holds that
u(cid:3)∈ [[ne]]u
Theorem 3. For every NautiLOD expression ne, there exists an LDQL query
q(?x), with ?x a free variable, that is equivalent to ne.

W if and only if {?x (cid:10)→ u(cid:3)} ∈ [[q(?x)]]

{u}
W .

W ∪ ···

2 In [7], all URIs have an assigned set of RDF triples (which may be empty). In our
data model one can have URIs not in dom(adoc). Hence, to properly capture the
semantics of NautiLOD in terms of our data model we have to introduce conditions
of the form “u(cid:3) ∈ dom(adoc).”

LDQL: A Query Language for the Web of Linked Data

85

(cid:3)/(cid:2)+, p2,

(cid:3)∗. To translate (cid:2)

2 is translated into (cid:2)+, p1,

Proof (Sketch). The proof begins with a simple translation that replaces every
(cid:3). For instance, the
p ∈ U in a NautiLOD expression by a link pattern (cid:2)+, p,
(cid:3) and
expression p1/p∗
[(ASK P )] we use (cid:2)?v, q(cid:3). The complete translation poses several other complications 
(as described in the extended version [13]). In particular, the last step of
NautiLOD expressions must be translated by using a SPARQL pattern and not
an LPE. For this we use the following property. Given a regular expression r that
does not generate the empty word, one can always write r as r1/a1|···|rk/ak
where the ai’s are base symbols of the alphabet. Thus, we can translate r by
using LPEs to translate the ri’s as outlined above; next, translate the ai’s by
using a method similar to the proof of Theorem 2, and ﬁnally use UNION for |.

Along the same lines of Theorem 1 one can prove the following result.

Theorem 4. There exists an LDQL query q(?x) that cannot be expressed in
NautiLOD.

4.3 Comparison with SPARQL Under Reachability-Based Query

Semantics

In [11] the author introduces a family of reachability-based query semantics based
on which SPARQL graph patterns can be used as a query language for Linked
Data on the WWW. Similar to how the scope of the SPARQL part of a basic
LDQL query is restricted to particular documents, reachability-based semantics
restrict the scope of SPARQL queries to documents that can be reached by
traversing a well-deﬁned set of data links. To specify what data links belong
to such a set, the notion of a reachability criterion is used; that is, a function
c : T × U × P → {true, false} where P denotes the set of all SPARQL graph
patterns. Then, given such a reachability criterion c, a ﬁnite set S of URIs and
a SPARQL graph pattern P , a document d ∈ D is (c, S, P )-reachable in a Web
of Linked Data W = (cid:2)D, adoc(cid:3) if any of the following two conditions holds:
1. There exists a URI u ∈ S such that adoc(u) = d; or
2. there exists a link graph edge (cid:2)dsrc, (t, u), dtgt(cid:3) ∈ GW such that (i) dsrc is

(c, S, P )-reachable in W, (ii) c(t, u, P ) = true, and (iii) dtgt = d.

Notice how the second condition restricts the notion of reachability by
ignoring data links that do not satisfy the given reachability criterion c. Concrete 
examples of reachability criteria are cAll, cNone, and cMatch [11], where cAll
selects all data links, and cNone ignores all data links; i.e., cAll(t, u, P ) = true
and cNone(t, u, P ) = false for all tuples (cid:2)t, u, P(cid:3) ∈ T × U × P. In contrast
to such an all-or-nothing strategy, criterion cMatch returns true for every data
link whose triple matches a triple pattern of the given graph pattern; formally,
cMatch(t, u, P ) = true if and only if there exists some solution mapping μ such
that μ[tp] = t for an arbitrary triple pattern tp that is contained in P .

Given the notion of a reachability criterion, it is possible to deﬁne a family
of (reachability-based) query semantics for SPARQL. To this end, let c be a

86

O. Hartig and J. P´erez

reachability criterion, let S be a ﬁnite set of URIs, and let P be a SPARQL
graph pattern. Then, for any Web of Linked Data W = (cid:2)D, adoc(cid:3), the S-based
evaluation of P over W under c-semantics, denoted by [[P ]]R(c,S)
W , is the set of
solution mappings [[P ]]G where G is the RDF graph that consists of all triples
from all documents that are (c, S, P )-reachable in W.

While there exist an inﬁnite number of possible reachability criteria, in this
paper we focus on cAll, cNone, and cMatch. The following two results show that
LDQL is strictly more expressive than SPARQL graph patterns under any of
these three query semantics.
Theorem 5. Let c ∈ {cAll, cNone, cMatch}. For every SPARQL graph pattern P
there exists an LDQL query q such that [[P ]]R(c,S)
W for every Web W and
S ⊆ U.
Proof (Sketch). We only sketch the case of cAll-semantics. In this case, one can
prove that the LPE lpe cAll = (cid:2)
(cid:3)∗ simulates the reachability criterion cAll,
and, thus, [[P ]]R(cAll,S)
W . One can also ﬁnd LPEs to simulate cNone
and cMatch.
Theorem 6. Let c ∈ {cAll, cNone, cMatch}. There exists an LDQL query q for
which there does not exist a SPARQL pattern P such that [[P ]]R(c,S)
W for
every W and S ⊆ U.

,
= [[(cid:2)lpe cAll , P(cid:3)]]S

= [[q]]S

W

= [[q]]S

,

W

W

5 Web-Safeness of LDQL Queries

In this section we study the “Web-safeness” of LDQL queries, where, informally,
we call a query Web-safe if a complete execution of the query over the WWW
is possible in practice (which is not the case for all LDQL queries as we shall
see). To provide a more formal deﬁnition of this notion of Web-safeness we make
the following observations. While the mathematical structures introduced by
our data model capture the notion of Linked Data on the WWW formally (and,
thus, allow us to provide a formal semantics for LDQL queries), in practice, these
structures are not available completely for the WWW. For instance, given that
an inﬁnite number of strings can be used as HTTP URIs [6], we cannot assume
complete information about which URIs are in the domain of the partial function 
adoc (i.e., can be looked up to retrieve some document) and which are not;
in fact, disclosing this information would require a process that systematically
tries to look up every possible HTTP URI and, thus, would never terminate.
Therefore, it is also impossible to guarantee the discovery of every document in
the set D (without looking up an inﬁnite number of URIs). Consequently, any
query whose execution requires a complete enumeration of this set is not feasible 
in practice. Based on these observations, we deﬁne Web-safeness of LDQL
queries as follows.

Deﬁnition 6. An LDQL query q is Web-safe if there exists an algorithm that,
for any ﬁnite Web of Linked Data W = (cid:2)D, adoc(cid:3) and any ﬁnite set S of URIs,

LDQL: A Query Language for the Web of Linked Data

87

(cid:6)

SEED ?x

(cid:4)

ε,(cid:2)?x, p1, ?z(cid:3)(cid:5)(cid:7)

ex, and q(cid:3)(cid:3)

ex = (cid:2)lpe ex

W by looking up only a ﬁnite number of URIs without assuming

computes [[q]]S
an a priori availability of any information about the sets D and dom(adoc).
Example 6. Recall our example queries qex, q(cid:3)
ex (cf. Example 5). For
, any URI u ∈ U may be used to obtain
query qex =
a nonempty subset of the query result as long as a lookup of u retrieves a
document whose data includes RDF triples that match (cid:2)u, p1, ?z(cid:3). Therefore,
without access to D or dom(adoc) of the queried Web W = (cid:2)D, adoc(cid:3), the completeness 
of the computed query result can be guaranteed only by checking each
of the inﬁnitely many possible HTTP URIs. Hence, query qex is not Web-safe.
In contrast, although it contains qex as a subquery, query q(cid:3)(cid:3)
ex) is
, Bex(cid:3). Given uA as seed URI, a possible execution
Web-safe, and so is q(cid:3)
algorithm for q(cid:3)
W by traversing the queried Web W
based on lpe ex. Thereafter, the algorithm retrieves documents by looking up all
URIs u ∈ [[lpe ex]]uA
W (or simply keeps these documents after the traversal); and,
ﬁnally, the algorithm evaluates pattern Bex over the union of the RDF data in
the retrieved documents. If W is ﬁnite (i.e., contains a ﬁnite number of docu-
ments), the traversal process requires a ﬁnite number of URI lookups only, and
so does the retrieval of documents in the second step; the ﬁnal step does not
look up any URI. To see that q(cid:3)(cid:3)
ex is also Web-safe we note that after executing
subquery q(cid:3)
ex (e.g., by using the algorithm as outlined before), the execution of
the other (non-Web-safe) subquery qex can be reduced to a ﬁnite number of URI
lookups, namely the URIs bound to variable ?x in solution mappings obtained
for subquery q(cid:3)
ex. Although any other URI may also be used to obtain solution 
mappings for qex, such solution mappings cannot be joined with any of the
solution mappings for q(cid:3)

ex and, thus, are irrelevant for the result of q(cid:3)(cid:3)
ex.

ex may ﬁrst compute [[lpe ex]]uA

ex = (qex AND q(cid:3)

The example illustrates that there exists an LDQL query that is not Websafe.
 In fact, it is not diﬃcult to see that the argument for the non-Web-safeness
of query qex as made in the example can be applied to any LDQL query of the
form (SEED ?x q) where subquery q is a (satisﬁable) basic LDQL query; that
is, none of these queries is Web-safe. However, the example also shows that
more complex queries that contain such non-Web-safe subqueries may still be
Web-safe. Therefore, we now show properties to identify LDQL queries that are
Web-safe even if some of their subqueries are not. We begin with queries of the
forms (cid:2)lpe, P(cid:3), πV q, (SEED U q), and (q1 UNION ... UNION qn).
Proposition 2. An LDQL query q is Web-safe if any of the following properties
holds:
1. Query q is of the form (cid:2)lpe, P(cid:3) and lpe is Web-safe, where we call an LPE
Web-safe if either (i) it is of the form (cid:2)?v, q(cid:3)(cid:3) and LDQL query q(cid:3) is Websafe,
 or (ii) it is of any form other than (cid:2)?v, q(cid:3)(cid:3) and all its subexpressions (if
any) are Web-safe LPEs;
2. Query q is of the form πV q(cid:3) or (SEED U q(cid:3)), and subquery q(cid:3) is Web-safe; or
3. Query q is of the form (q1 UNION ... UNION qn) and each qi (1 ≤ i ≤ n) is

Web-safe.

88

O. Hartig and J. P´erez

It remains to discuss LDQL queries of the form (q1 AND ... AND qm). Our
discussion of query q(cid:3)(cid:3)
ex in Example 6 suggests that such queries can be shown
to be Web-safe if all non-Web-safe subqueries are of the form (SEED ?v q) and
it is possible to execute these subqueries by using variable bindings obtained
from other subqueries. A necessary condition for this execution strategy is that
the variable in question (i.e., ?v) is guaranteed to be bound in every possible
solution mapping obtained from the other subqueries.

To allow for an automated veriﬁcation of this condition we adopt Buil-Aranda
et al.’s notion of strongly bound variables [4]. To this end, for any SPARQL
graph pattern P , let sbvars(P ) denote the set of strongly bound variables in P
as deﬁned by Buil-Aranda et al. [4]. For the sake of space, we do not repeat
the deﬁnition here. However, we emphasize that sbvars(P ) can be constructed
recursively, and each variable in sbvars(P ) is guaranteed to be bound in every
possible solution for P [4, Proposition 1]. To carry over these properties to LDQL
queries, we use the notion of strongly bound variables in SPARQL patterns
to deﬁne the following notion of strongly bound variables in LDQL queries;
thereafter, in Lemma 3, we show the desired boundedness guarantee.

Deﬁnition 7. The set of strongly bound variables in an LDQL query q,
denoted by sbvars(q), is deﬁned recursively as follows:
1. If q is of the form (cid:2)lpe, P(cid:3), then sbvars(q) = sbvars(P ).
2. If q is of the form (q1 AND q2), then sbvars(q) = sbvars(q1) ∪ sbvars(q2).
3. If q is of the form (q1 UNION q2), then sbvars(q) = sbvars(q1) ∩ sbvars(q2).
4. If q is of the form πV q(cid:3), then sbvars(q) = sbvars(q(cid:3)) ∩ V .
5. If q is of the form (SEED U q(cid:3)), then sbvars(q) = sbvars(q(cid:3)).
6. If q is of the form (SEED ?v q(cid:3)), then sbvars(q) = sbvars(q(cid:3)) ∪ {?v}.
Lemma 3. Let q be an LDQL query. For every ﬁnite set S of URIs, every
Web of Linked Data W, and every solution mapping μ ∈ [[q]]S
W , it holds that
sbvars(q) ⊆ dom(μ).

We are now ready to show the following result.

Theorem 7. An LDQL query of the form (q1 AND q2 AND ... AND qm) is Websafe 
if there exists a total order ≺ over the set of subqueries {q1, q2, ... , qm} such
that for each subquery qi (1 ≤ i ≤ m), it holds that either (i) qi is Web-safe or
(ii) qi is of the form (SEED ?v q) where q is Web-safe and ?v ∈ (cid:8)
qj≺qi sbvars(qj).
Proof (Sketch). We prove Theorem 7 based on an iterative algorithm that generalizes 
the execution of query q(cid:3)(cid:3)
ex as outlined in Example 6. That is, the algorithm
executes the subqueries q1 ... qm sequentially in the order ≺ such that each iteration 
executes one of the subqueries by using the solution mappings computed
during the previous iteration.

With the results in this section we have all ingredients to devise a procedure
to show Web-safeness for a large number of queries (including queries that are
arbitrarily nested). However, as a potential limitation of such a procedure we note

LDQL: A Query Language for the Web of Linked Data

89

(cid:6)

(cid:7)
q1 AND (q2 UNION (SEED ?x q3))

that Theorem 7 can be applied only in cases in which all non-Web-safe subqueries
are of the form (SEED ?v q). For instance, the theorem cannot be applied to show
is Web-safe
that an LDQL query of the form
if ?x ∈ sbvars(q1) and q1, q2 and q3 are Web-safe. On the other hand, for the
we can
semantically equivalent query
show Web-safeness based on Theorem 7 (and Proposition 2). Fortunately, we may
leverage the following fact to improve the eﬀectiveness of applying Theorem 7
in the procedure that we aim to devise.
Fact 1. If an LDQL query q is Web-safe, then so is any LDQL query q(cid:3) with
q(cid:3) ≡ q.

(cid:7)
(q1 AND q2) UNION (q1 AND (SEED ?x q3))

(cid:6)

As a consequence of Fact 1, we may use the equivalences in Lemma 2 to
rewrite a given query into an equivalent query that is more suitable for testing
Web-safeness based on our results. To this end, we introduce speciﬁc normal
forms for LDQL queries:

Deﬁnition 8. An LDQL query is in union-free normal form if it is of the
form (q1 AND ... AND qm) with m ≥ 1 and each qi (1 ≤ i ≤ m) is either (i) a
basic LDQL query or (ii) of the form πV q, (SEED U q) or (SEED ?v q) such that
subquery q is in UNION-free normal form. An LDQL query is in union normal
form if it is of the form (q1 UNION ... UNION qn) with n≥1 and each qi (1≤ i≤ n)
is in UNION-free normal form.

The following result is an immediate consequence of Lemma 2.

Corollary 1. Every LDQL query is equivalent to an LDQL query in UNION normal 
form.

In conjunction with Fact 1, Corollary 1 allows us to focus on LDQL queries
in UNION normal form without losing generality. We are now ready to specify our
procedure that applies the results in this paper to test a given LDQL query q for
Web-safeness: First, by using the equivalences in Lemma 2, the query has to be
rewritten into a semantically equivalent LDQL query qnf =(q1 UNION ... UNION qn)
that is in UNION normal form. Next, the following test has to be repeated for every
subquery qi (1 ≤ i ≤ n); recall that each of these subqueries is in UNION-free normal 
form; i.e., qi = (qi
mi). The test is to ﬁnd an order for their
subqueries qi
mi that satisﬁes the conditions in Theorem 7. Every top-level
subquery qi (1 ≤ i ≤ n) for which such an order exists, is Web-safe (cf. Theo1

rem 7). If all top-level subqueries are identiﬁed to be Web-safe by this test, then
qnf is Web-safe (cf. Proposition 2), and so is q (cf. Fact 1).

1 AND ... AND qi

The given conditions are suﬃcient to show Web-safeness of LDQL. It remains
open whether there exists a (decidable) suﬃcient and necessary condition for
Web-safeness.

, ... , qi

90

O. Hartig and J. P´erez

6 Concluding Remarks and Future Work

LDQL, the query language that we introduce in this paper, allows users to
express queries over Linked Data on the WWW. We deﬁned LDQL such that
navigational features for selecting the query-relevant documents on the Web are
separate from patterns that are meant to be evaluated over the data in the
selected documents. This separation distinguishes LDQL from other approaches
to express queries over Linked Data.

We focused on expressiveness, by comparing LDQL with previous formalisms,
and on the notion of Web-safeness. Several topics remain open for future work.
One of them is the complexity of query evaluation. A classical complexity analysis 
is easy to perform if we assume that all the data and documents are available
as if they were in a centralized repository, and that they can be processed via
a RAM machine model. We conjecture that under this model, the data complexity 
of evaluating LDQL will be polynomial. Nevertheless, a more interesting
complexity analysis should consider a model that captures the inherent way of
accessing the Web of Linked Data via HTTP requests, the overhead of data communication 
and transfer, the distribution of data and documents, etc. A more
practical direction for future research on LDQL is the development of approaches
to actually implement LDQL queries eﬃciently.

Acknowledgments. P´erez is supported by the Millennium Nucleus Center for Semantic 
Web Research, Grant NC120004, and Fondecyt grant 1140790.

References

1. Arenas, M., Conca, S., P´erez, J.: Counting beyond a yottabyte, or how SPARQL 1.1
property paths will prevent adoption of the standard. In: WWW 2012, pp. 629–638
(2012)

2. Arenas, M., Gutierrez, C., P´erez, J.: On the semantics of SPARQL. In: Semantic
Web Information Management - A Model-Based Perspective, chap. 13, pp. 281–307.
Springer (2009)

3. Berners-Lee, T.: Linked Data

(2006).

http://www.w3.org/DesignIssues/

LinkedData.html

4. Buil-Aranda, C., Arenas, M., Corcho, O.: Semantics and optimization of the
SPARQL 1.1 federation extension. In: Antoniou, G., Grobelnik, M., Simperl, E.,
Parsia, B., Plexousakis, D., De Leenheer, P., Pan, J. (eds.) ESWC 2011, Part II.
LNCS, vol. 6644, pp. 1–15. Springer, Heidelberg (2011)

5. Cyganiak, R., Wood, D., Lanthaler, M.: RDF 1.1 Concepts and Abstract Syntax.

W3C Recommendation, February 2014

6. Fielding, R., Gettys, J., Mogul, J.C., Frystyk, H., Masinter, L., Leach, P.J.,

Berners-Lee, T.: Hypertext Transfer Protocol - HTTP/1.1, June 1999

7. Fionda, V., Pirr`o, G., Gutierrez, C.: NautiLOD: A Formal Language for the Web

of Data Graph. ACM Transactions on the Web 9(1), 5:1–5:43 (2015)

8. Harris, S., Seaborne, A., Prud’hommeaux, E.: SPARQL 1.1 Query Language. W3C

Recommendation, March 2013

LDQL: A Query Language for the Web of Linked Data

91

9. Harth, A., Speiser, S.: On completeness classes for query evaluation on linked data.

In: Proc. 26th AAAI Conf. (2012)

10. Hartig, O.: LDQL: a language for linked data queries. In: AMW 2015 (2015)
11. Hartig, O.: SPARQL for a web of linked data: semantics and computability. In:
Simperl, E., Cimiano, P., Polleres, A., Corcho, O., Presutti, V. (eds.) ESWC 2012.
LNCS, vol. 7295, pp. 8–23. Springer, Heidelberg (2012)

12. Hartig, O.: An Overview on Execution Strategies for Linked Data Queries.

Datenbank-Spektrum 13(2) (2013)

13. Hartig, O., P´erez, J.: LDQL: A Query Language for the Web of Linked
Data (Extended Version). CoRR abs/1507.04614 (2015). http://arxiv.org/abs/
1507.04614

14. Hartig, O., Pirr`o, G.: A context-based semantics for SPARQL property paths over

the web. In: Proc. 12th Extended Semantic Web Conf. (2015)

15. Mendelzon, A.O., Mihaila, G.A., Milo T.: Querying the world wide web. In: PDIS

(1996)

16. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and complexity of SPARQL. In:
Cruz, I., Decker, S., Allemang, D., Preist, C., Schwabe, D., Mika, P., Uschold, M.,
Aroyo, L.M. (eds.) ISWC 2006. LNCS, vol. 4273, pp. 30–43. Springer, Heidelberg
(2006)

17. P´erez, J., Arenas, M., Gutierrez, C.: nSPARQL: A Navigational Language for RDF.

J. Web Sem. 8(4), 255–270 (2010)

18. Umbrich, J., Hogan, A., Polleres, A., Decker, S.: Link Traversal Querying for a

Diverse Web of Data. Semantic Web Journal (2014)

