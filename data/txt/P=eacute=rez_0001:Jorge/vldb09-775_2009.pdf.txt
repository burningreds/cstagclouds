Inverting Schema Mappings:

Bridging the Gap between Theory and Practice

Marcelo Arenas

PUC Chile

marenas@ing.puc.cl

Jorge P´erez
PUC Chile

jperez@ing.puc.cl

Juan Reutter
PUC Chile

jlreutte@puc.cl

Cristian Riveros

R&M Tech

criveros@rmt.cl

ABSTRACT
The inversion of schema mappings has been identiﬁed as
one of the fundamental operators for the development of a
general framework for metadata management. In fact, during 
the last years three alternative notions of inversion for
schema mappings have been proposed (Fagin-inverse [10],
quasi-inverse [14] and maximum recovery [2]). However, the
procedures that have been developed for computing these
operators have some features that limit their practical applicability.
 First, these algorithms work in exponential time
and produce inverse mappings of exponential size. Second,
these algorithms express inverses in some mappings languages 
which include features that are diﬃcult to use in
practice. A typical example is the use of disjunction in the
conclusion of the mapping rules, which makes the process of
exchanging data much more complicated.

In this paper, we propose solutions for the two problems
mentioned above. First, we provide a polynomial time algorithm 
that computes the three inverse operators mentioned
above given a mapping speciﬁed by a set of tuple-generating
dependencies (tgds). This algorithm uses an output mapping 
language that can express these three operators in a
compact way and, in fact, can compute inverses for a much
larger class of mappings. Unfortunately, it has already been
proved that this type of mapping languages has to include
some features that are diﬃcult to use in practice and, hence,
this is also the case for our output mapping language. Thus,
as our second contribution, we propose a new and natural
notion of inversion that overcomes this limitation. In particular,
 every mapping speciﬁed by a set of tgds admits an
inverse under this new notion that can be expressed in a
mapping language that slightly extends tgds, and that has
the same good properties for data exchange as tgds. Finally,
 as our last contribution, we provide an algorithm for
computing such inverses.

1.

INTRODUCTION

A schema mapping is a speciﬁcation that describes how

Permission to copy without fee all or part of this material is granted provided
that the copies are not made or distributed for direct commercial advantage,
the VLDB copyright notice and the title of the publication and its date appear,
and notice is given that copying is by permission of the Very Large Data
Base Endowment. To copy otherwise, or to republish, to post on servers
or to redistribute to lists, requires a fee and/or special permission from the
publisher, ACM.
VLDB ‘09, August 24-28, 2009, Lyon, France
Copyright 2009 VLDB Endowment, ACM 000-0-00000-000-0/00/00.

data from a source schema is to be mapped to a target
schema. Schema mappings have proved to be essential for
several data-interoperability tasks such as data exchange
[11], data integration [21] and peer data management [6,
17]. The research on this area has mainly focused on performing 
these tasks, and has produced several applications
that work with declarative speciﬁcations of schema mappings 
[15, 17]. However, as Bernstein pointed out in [3],
many information-system problems involve not only the design 
and integration of complex application artifacts, but
also their subsequent manipulation. Driven by this consideration,
 Bernstein proposed in [3] a general framework
for managing schema mappings. In this framework, schema
mappings are usually speciﬁed in a logical language, and
high-level algebraic operators like match, merge and compose 
are used to manipulate them [3, 23, 24, 4].

One of the operators in Bernstein’s framework is the inverse 
of a schema mapping, that has recently received considerable 
attention [10, 14, 4, 2]. Consider a mapping M
from a schema A to a schema B.
Intuitively, an inverse
of M is a new mapping that describes the reverse relationship 
from B to A, and is semantically consistent with the
relationship previously established by M.

In practical scenarios, the inverse of a mapping can have
several applications. In a data exchange context [11], if a
mapping M is used to exchange data from a source to a
target schema, an inverse of M can be used to exchange
the data back to the source, thus reverting the application
of M. As a second application, consider a peer-data management 
system (PDMS) [6, 17].
In a PDMS, a peer can
act as a data source, a mediator, or both, and the system
relates peers by establishing mappings between the peers
schemas. Mappings between peers are usually directional,
and are used to reformulate queries. For example, if there is
a mapping M from peer P1 to peer P2 and a query over P2,
a PDMS can use M to reformulate the query by using P1 as
a source. Hence, an inverse of M would allow the PDMS to
reformulate a query over P1 in terms of P2, thus considering 
this time P2 as a source. Another application is schema
evolution, where the inverse together with the composition
play a crucial role [4]. Consider a mapping M between
schemas A and B, and assume that schema A evolves into
a schema A′. This evolution can be expressed as a mapping
M′ between A and A′. Thus, the relationship between the
new schema A′ and schema B can be obtained by inverting
mapping M′ and then composing the result with mapping
M.

All the previous work on inverting schema mappings have

been motivated by foundational issues [10, 14, 2], being one
of the most delicate the deﬁnition of a good semantics for
inversion. In fact, up to now little attention has been paid
to the study of practical issues regarding inverting schema
mappings.

In the data exchange scenario, the standard procedure
used to exchange data with a mapping is based on the chase
procedure [11]. More precisely, given a mapping M and a
source database I, a canonical translation of I according to
M is computed by chasing I with the set of dependencies
deﬁning M [11]. Thus, when computing an inverse of M, it
would be desirable from a practical point of view to obtain
a mapping M′ where the chase procedure can be used to
exchange data.

Closely related with the above issue, there is a representation 
issue. For example, in a PDMS schema mappings are
usually expressed in terms of tuple-generating dependencies
(tgds), or, equivalently, global-and-local-as-view constraints
(GLAV). Hence, it would be desirable that the inverse of a
schema mapping could also be expressed as a set of tgds or
GLAV constraints, thus maintaining mappings in a manageable 
setting.

Orthogonal to the previous issues, the eﬃciency of the
algorithms used for computing inverses is also crucial.
If
one wants to use the inverse operator in practice, research
on the feasibility of implementing these algorithms must be
carried out.

In this paper, we study the practical issues mentioned
above. But before showing into detail our contributions, we
take a closer look at the inverse notions proposed in the
literature, and the features of these notions that limit their
practical applicability.

The ﬁrst proposal of an inverse operator, that we call here
Fagin-inverse, was proposed by Fagin in [10]. Arguably,
this notion is too strong for practical purposes, as most
of the schema mappings used in practice do not admit a
Fagin-inverse. As shown by Fagin et al.
in their subsequent 
work [14], the fact that some mappings do not admit
a Fagin-inverse should not lead to the conclusion that for
these mappings no data can be recovered. In fact, Fagin et
al. responded to the existence issue by proposing in [14] the
notion of quasi-inverse of a schema mapping. Under this new
notion, numerous schema mappings that do not have Fagininverses 
possess natural and useful quasi-inverses [14]. Nevertheless,
 there are still simple mappings speciﬁed by tgds
that have no quasi-inverse. And not only that, there exists 
an additional issue about the type of mappings needed
to specify quasi-inverses.
In [14], the authors provide an
algorithm to compute quasi-inverses of mappings given by
tgds whenever such an inverse exists. The output of this
algorithm is a set of dependencies similar to tgds, but that
include disjunctions in the conclusions of the dependencies.
Moreover, they proved that disjunctions are unavoidable in
order to represent quasi-inverses. Notice that this type of
mappings are diﬃcult to use in the data exchange context.
In particular, it is not clear whether the standard chase procedure 
could be used to produce a single canonical target
database in this case, thus making the process of exchanging 
data and answering queries much more complicated. 1

1Some extensions of the chase procedure to deal with disjunctive 
dependencies have been proposed in the literature 
[7]. Nevertheless, these extensions have not been developed 
for the data exchange tasks mentioned here.

In [2], Arenas et al. proposed another notion of inverse
for schema mappings, which was called maximum recovery.
One of the main properties of this new notion is that every
mapping speciﬁed by a set of tgds has a maximum recovery.
 Since maximum recoveries always exist for the most
common mappings, from a practical point of view this notion 
is an improvement over the notions of Fagin-inverse and
quasi-inverse. Nevertheless, as shown in [2], the maximum
recovery of a mapping speciﬁed by a set of tgds cannot always 
be represented as a set of tgds. In fact, the authors
proved in [2] that disjunctions are unavoidable to represent
maximum recoveries and, hence, one cannot hope to always
obtain a representation of a maximum recovery with good
properties for data exchange.

Regarding the eﬃciency issue mentioned above, the proposed 
algorithms for computing the notions of Fagin-inverse,
quasi-inverse and maximum recovery produce inverses of exponential 
size for the case of mappings speciﬁed by tgds. In
fact, it was proved in the extended version of [2] that for the
mapping languages considered in [10, 14, 2], there exists a
mapping given by a set of tgds such that every maximum
recovery of this mapping is of exponential size.
1.1 Contributions

In this paper, we revisit the problem of inverting schema
mappings, motivated by some of the practical limitations
of the previous notions of inversion. In particular, we propose 
solutions for all the limitations mentioned above. More
precisely, the following are our main contributions.
A query language-based notion of inverse. One of
our conceptual contributions is the proposal of a new and
natural notion of inversion for schema mappings. Assume
that a mapping M is used to exchange data from source
to target. Then we measure the amount of exchanged data
that can be recovered back in the source according to a class
of queries. Intuitively, our new notion of inverse focuses on
recovering the maximum amount of information with respect
to a class C of queries, which gives rise to the notion of Cmaximum 
recovery.

We study the connection of the notion of C-maximum
recovery with the previously proposed notions of inverse.
In particular, we show that C-maximum recoveries capture
these notions for diﬀerent choices of the class C of queries.
And more importantly, by focusing on the class of conjunctive 
queries, we show that the notion of C-maximum recovery
can be used to overcome some of the practical limitations
mentioned above.
CQ-maximum recovery. Let CQ be the class of conjunctive 
queries. We show in this paper that the notion of
CQ-maximum recovery has two desirable properties, namely
that every mapping speciﬁed by a set of tgds admits an inverse 
under this new notion, and that this mapping can be
expressed in a language that has the same good properties
for data exchange as tgds. In particular, we provide an algorithm 
that given a mapping M speciﬁed by a set of tgds,
produces a CQ-maximum recovery of M speciﬁed by a set
of tgds extended with two features: inequalities and a builtin 
predicate C(·) to diﬀerentiate constants from null values.
These two features are included only in the premises of the
dependencies, thus obtaining a language as good as tgds for
data exchange purposes. We also prove that inequalities and
predicate C(·) are both essential to express CQ-maximum
recoveries of mappings given by tgds.

A polynomial-time algorithm for computing inverses.
 As we mentioned before, an orthogonal issue regarding 
the notions of inverse proposed so far is the eﬃciency 
of the algorithms developed to compute them [10,
14, 2]. In this paper, we present the ﬁrst polynomial time
algorithm for computing inverses of schema mappings. In
fact, our algorithm can be used to compute Fagin-inverses,
quasi-inverses, and maximum recoveries of mappings given
by tgds. And moreover, our algorithm works not only for
mappings speciﬁed by tgds, but also for mappings speciﬁed
in a much richer language that contains most of the schema
mapping languages used in practice (for example, nested
mappings [15]).

As we mentioned before,

it has already been proved
that a language capable of expressing Fagin-inverses, quasiinverses,
 and maximum recoveries has to include some features 
that are diﬃcult to use in practice. Thus, our gain in
time complexity comes with the price of a stronger and less
manageable mapping language for expressing inverses.
In
fact, our algorithm uses an output language that is similar
to the language of second-order tgds proposed in [13], but
with some extra features.

The organization of the paper corresponds with the previous 
list of contributions. We begin by deﬁning the terminology 
used trough the paper.

2. BASIC NOTATION

Our study assumes that data is represented in the relational 
model. A relational schema, or just schema, is a ﬁnite
set {R1, . . . , Rn} of relation symbols. As usual in the data
exchange literature, we consider database instances with two
types of values: constants and nulls. If we refer to a schema
S as a source schema, then we restrict all instances of S to
consist only of constant values. On the other hand, we allow
null values in the instances of any target schema T.

Schema mappings and solutions. Schema mappings are
used to deﬁne a semantic relationship between two schemas.
In this paper, we use a general representation of mappings;
given two schemas R1 and R2, a mapping M from R1 to
R2 is a set of pairs (I, J), where I is an instance of R1, and
J is an instance of R2. Further, we say that J is a solution
for I under M if (I, J) is in M.

As usual, we use the class of tuple-generating dependencies
(tgds) to specify schema mappings [11]. A set Σ of tuple
generating dependencies from a schema R1 to a schema R2
is a set of formulas of the form:

ϕ(¯x) → ∃¯y ψ(¯x, ¯y)

where ϕ(¯x) is a conjunction of relational atoms over R1, and
ψ(¯x, ¯y) is a conjunction of relational atoms over R2. For
example, the following is a tuple-generating dependency:

R(x, y) ∧ S(y, z) → ∃u T (x, z, u).

The semantics of tgds is deﬁned as follows. We say that
a pair (I, J) of instances satisﬁes a set Σ of tgds if it holds
that, for every rule in this set of the form ϕ(¯x) → ∃¯y ψ(¯x, ¯y)
and every tuple of elements ¯a from I, if I satisﬁes ϕ(¯a), then
there exists a tuple ¯b of elements from J such that J satisﬁes
ψ(¯a, ¯b).

Composition of mappings. The notion of composition
has shown to be of fundamental importance in deﬁning the

notion of inverse of a schema mapping [10, 14, 2]. Let M12
be a schema mapping from R1 to R2, and M23 a schema
mapping from R2 to R3. Then the composition of M12 and
M23, denoted by M12 ◦ M23, is deﬁned as the standard
composition of binary relations, that is, as the set of all
pairs of instances (I, J) such that I is an instance of R1,
J is an instance of R3, and there exists an instance K of
R2 such that (I, K) belongs to M12, and (K, J) belongs to
M23.
Query Answering. In this paper, we use CQ to denote
the class of conjunctive queries and UCQ to denote the class
of unions of conjunctive queries. Given a query Q and a
database instance I, we denote by Q(I) the evaluation of
Q over I. Moreover, we use predicate C(·) to diﬀerentiate
between constants and nulls, that is, C(a) holds if and only
if a is a constant value.

As usual, the semantics of queries in the presence of
schema mappings is deﬁned in terms of the notion of certain
answer. Assume that M is a mapping from a schema R1 to
a schema R2. Then given an instance I of R1 and a query Q
over R2, the certain answers of Q for I under M, denoted
by certainM(Q, I), is the set of tuples that belong to the
evaluation of Q over every possible solution for I under M,
that is, T{Q(J) | J is a solution for I under M}.

3. QUERY LANGUAGE-BASED INVERSES

OF SCHEMA MAPPINGS

Intuitively, an inverse of a schema mapping M is a reverse 
mapping that undoes the application of M. Any natural 
notion of inverse should capture the intuition that, if
M describes how to exchange data from a source to a target
schema, the inverse of M must describe how to recover the
initial data back in the source (or, at least, part of it). Moreover,
 one should impose a soundness requirement; we would
like to recover only sound information, that is, information
that was already present before the exchange.

A natural question at this point is how one can formally
deﬁne the idea of recovering sound information. In this paper,
 we give a formal deﬁnition of recovering sound information 
with respect to a query language, and use this notion
to deﬁne our query-language based notion of inverse of a
schema mapping.

Before giving any formal deﬁnition, let us present the intuition 
of our notions with one example.

Example 3.1. Let S be a source schema composed by
binary relations R(·, ·) and S(·, ·), T a target schema composed 
by a binary relation T (·, ·), and assume that schemas
S and T are related by a mapping M given by the tgd:

R(x, y) ∧ S(y, z) → T (x, z).

(1)

Thus, target relation T stores the join of source relations R
and S. Consider now the reverse mapping M′ relating T
and S through the dependency:

T (x, y) → ∃u R(x, u).

(2)

This dependency states that whenever an element is in the
ﬁrst component of relation T in the target database, it must
also be in the ﬁrst component of relation R in the source
database. Thus, given the deﬁnition of mapping M, one
can intuitively conclude that mapping M′ recovers sound
information with respect to M. The previous intuition can
be formalized by considering the composition of M with

M′, which represents the idea of using M′ to bring back
to the source the information that was exchanged by using
It is important to notice that M ◦ M′ is a
mapping M.
round-trip mapping from S to S and, therefore, one can use
queries over S to measure the amount of recovered information.
 In particular, one can claim in this example that
M′ recovers sound information with respect to M since for
every source instance I and query Q over S, if a tuple ¯t belongs 
to the certain answers of Q for I under M ◦ M′, then
¯t also belongs to the evaluation of Q over I.

Let us give an example of the previous discussion with
a concrete scenario. Assume that I is a source database
{R(1, 2), R(3, 4), S(2, 5)}, and Q is a source conjunctive
query ∃y R(x, y). If we directly evaluate Q over I, we obtain 
the set of answers Q(I) = {1, 3}. On the other hand,
if we evaluate Q over the set of instances obtained by exchanging 
data from I through M ◦ M′, then we obtain the
set of answers {1}, which is contained in Q(I). Thus, when
computing the certain answers for I we obtain a subset of
the direct evaluation of the query over I, that is

certainM◦M′ (Q, I) ⊆ Q(I).

(3)

2

In general, we say that a mapping M′ is a Q-recovery of a
mapping M whenever equation (3) holds for every source
database I. For example, for the mappings M and M′
deﬁned by dependencies (1) and (2), respectively, we have
that M′ is a Q-recovery of M for query Q(x) = ∃y R(x, y).
But moreover, it can be shown that M′ is a Q-recovery of
M for every query Q.
Indeed, this is the reason why we
claim that M′ recovers sound information with respect to
M in this case. But in some cases one may be interested
in retrieving sound information not for every possible query
but for a class of queries of interest (for instance, for the
class of conjunctive queries). This gives rise to the following
notion of C-recovery, where C is a class of queries.

Definition 3.2. Let C be a class of queries, M a mapping 
from schema S to schema T, and M′ a mapping from
T to S. Then M′ is a C-recovery of M if for every query
Q ∈ C over S and every instance I of S, it holds that:

certainM◦M′ (Q, I) ⊆ Q(I).

Being a C-recovery is a sound but mild requirement. Thus,
it is natural to ask whether one can compare mappings according 
to their ability to recover sound information, and
then whether there is a natural way to deﬁne a notion of
best possible recovery according to a given query language.
It turns out that there is simple and natural way to do this,
as we show in the following example.

Example 3.3. Let M and M′ be the mappings given by
dependencies (1) and (2), respectively, and M′′ a mapping
speciﬁed by dependency:

T (x, y) → ∃u (R(x, u) ∧ S(u, y)).

As we mentioned above, M′ recovers sound information
with respect to M as it is a Q-recovery of M for every
query Q. Furthermore, it can be shown that this property
also holds for mapping M′′. But not only that, it can also
be shown that for every query Q and source instance I, it
holds that:

certainM◦M′ (Q, I) ⊆ certainM◦M′′ (Q, I) ⊆ Q(I).

For instance, if I = {R(1, 2), R(3, 4), S(2, 5)} and Q(x, y) is
conjunctive query ∃z (R(x, z) ∧ S(z, y)), then we have that
Q(I) = {(1, 5)} and certainM◦M′′ (Q, I) = {(1, 5)}, while
certainM◦M′ (Q, I) = ∅.

Hence, every tuple that is retrieved by posing query Q over
the space of solutions for I under M ◦ M′ is also retrieved
by posing this query over the space of solutions for I under
M ◦ M′′. Thus, we can claim that M′′ is better than M′
recovering sound information with respect to M. 2

The above discussion gives rise to a simple way to compare 
two Q-recoveries M′ and M′′ of a mapping M; a
mapping M′′ recovers as much information as M′ does for
M under Q if for every source instance I, it holds that
certainM◦M′ (Q, I) ⊆ certainM◦M′′ (Q, I). With this way of
comparing inverse mappings, it is simple to deﬁne a notion
of best possible recovery according to a query language.

Definition 3.4. Let C be a class of queries and M1 a
C-recovery of a mapping M. Then M1 is a C-maximum
recovery of M if for every C-recovery M2 of M, it holds
that:

certainM◦M2 (Q, I) ⊆ certainM◦M1 (Q, I)

for every query Q in C and source database I.

That is, M1 is a C-maximum recovery of a mapping M,
if by exchanging data from I through M ◦ M1, one can
retrieve by using queries from C as much information as by
exchanging data from I through M ◦ M2, for any other
C-recovery M2 of M. For instance, for the mappings M
and M′′ mentioned in Example 3.3, it holds that M′′ is an
All-maximum recovery of M, where All is the class of all
queries.

It is important to notice that the choice of a query language 
makes a diﬀerence in the deﬁnition of C-maximum
recovery. For example, assume that M is mapping given by
the following dependencies:

A(x) → D(x),
B(x) → D(x) ∧ E(x).

In this case, it can be shown that the mapping M′ given by
the following dependencies is an All-maximum recovery of
M:

D(x) → A(x) ∨ B(x),
E(x) → B(x).

Unfortunately, the ﬁrst dependency includes a disjunction
on the conclusion, which makes the processes of exchanging 
data and computing certain answers much more complicated.
 On the other hand, if one is interested in retrieving
information by using only conjunctive queries, then mapping 
M′ as well as a mapping M′′ given by the following
tgd are both CQ-maximum recoveries of M:

E(x) → B(x).

Thus, by focusing on certain query languages in the deﬁnition 
of C-maximum recovery, one can avoid employing in
mapping languages features that are diﬃcult to use in practice.
 This observation motivates the search for a class of
queries that gives rise to an inverse notion meeting the two
requirements mentioned in the introduction, namely that
every mapping speciﬁed by a set of tgds admits an inverse

under this new notion, and that this mapping can be expressed 
in a language that has the same good properties
for data exchange as tgds. A natural starting point in this
search is the class of conjunctive queries, as this class is
widely used in practice and, in particular, has been extensively 
studied in the context of data exchange [11]. In fact,
from the results in [2], it is straightforward to prove that every 
mapping speciﬁed by a set of tgds has a CQ-maximum
recovery. Hence, it remains to show that CQ-maximum recoveries 
are expressible in a mapping language with good
properties for data exchange. This is done in Section 4. But
before going into the details of this result, we show in the
next section that the general notion of C-maximum recovery
is of independent interest, as it can be used to characterize 
the previous notions of inverse proposed in the literature
[10, 14, 2].
3.1 Comparison with previous notions

In the last years, three diﬀerent notions of inverse have
been proposed for schema mappings: Fagin-inverse [10],
quasi-inverse [14] and maximum recovery [2]. The latter notion 
was motivated by the idea of deﬁning an optimal way
of retrieving sound information. In this sense, the notion of
C-maximum recovery is inspired by the concept of maximum
recovery, as a C-maximum recovery tries to ﬁnd an optimal
way to retrieve sound information according to the query
language C. In fact, it can be easily proved that if M′ is
a maximum recovery of M, then M′ is an All-maximum
recovery of M, where All is the class of all queries. The
other two notions of inverse mentioned above are deﬁned
in a rather diﬀerent way, and at a ﬁrst glance they do not
seem to be related with the query language approach proposed 
in this paper. However, they can be characterized in
terms of the notion of C-maximum recovery for some speciﬁc 
choices of the query language C, as we show next. This
result is of independent interest as it shows that the concept
of C-maximum recovery provides a uniﬁed framework for the
notions of inversion proposed in the literature.

We start by considering the notion of Fagin-inverse proposed 
in [10]. Roughly speaking, Fagin’s deﬁnition is based
on the idea that a mapping composed with its inverse
should be equal to the identity schema mapping. To deﬁne
this notion, Fagin ﬁrst deﬁnes an identity mapping Id as
{(I1, I2) | I1, I2 are source instances and I1 ⊆ I2}, which
is an appropriate identity for the mappings speciﬁed by
tgds [10]. Then a mapping M′ is said to be a Fagin-inverse
of a mapping M if M ◦ M′ = Id. The following theorem
states that whenever a Fagin-inverse exists, it coincides with
the notion of UCQ6=-maximum recovery, where UCQ6= is
the class of unions of conjunctive queries with inequalities.

Theorem 3.5. Let M be a mapping speciﬁed by a set of
tgds, and assume that M has a Fagin-inverse. Then the
following statements are equivalent:

• M′ is a Fagin-inverse of M.
• M′ is a UCQ6=-maximum recovery of M.

We continue by considering the notion of quasi-inverse [14].
The idea behind quasi-inverses is to relax the notion of
Fagin-inverse by not diﬀerentiating between instances that
are data-exchange equivalent. Two instances I1, I2, are
data-exchange equivalent w.r.t. a mapping M, denoted by
I1 ∼M I2, if the space of solutions of I1 under M coincides

with the space of solutions of I2 under M [14]. Given a
mapping M1 from S to S, mapping M1[∼M, ∼M] is deﬁned
as {(I1, I2) | ∃(I ′
2) ∈
M1}. Then M′ is a quasi-inverse of M if (M ◦ M′)[∼M
, ∼M] = Id[∼M, ∼M].

2) : I1 ∼M I ′

1, I ′

1, I ′

1, I2 ∼M I ′

2 and (I ′

Theorem 3.6. Let M be a mapping speciﬁed by a set of
tgds, and assume that M has a quasi-inverse. Then there
exists a subclass C of UCQ6= such that the following statements 
are equivalent:

• M′ is a quasi-inverse of M.
• M′ is a C-maximum recovery of M.

The class of queries C in the above theorem depends on the
mapping M, and can be eﬀectively obtained from M.

4. COMPUTING CQ-MAXIMUM

RECOVERIES

In this section, we present an algorithm for computing
CQ-maximum recoveries. Given a mapping speciﬁed by a
set of tgds, our algorithm generates a CQ-maximum recovery 
speciﬁed by a set of tgds extended with inequalities and
the predicate C(·) in the premises of dependencies (recall
that C(a) holds if a is a constant value). Although our algorithm 
does not produce a set of standard tgds, the output
of our algorithm is a mapping that has the same good properties 
for data exchange as tgds.
In particular, the set of
dependencies is chaseable, that is, the standard chase procedure 
can be used to obtain a single canonical database.
Furthermore, we show in Section 4.2 that inequalities and
the predicate C(·) are unavoidable in order to represent CQmaximum 
recoveries of mappings given by tgds.

We begin this section by describing some of the tools
needed in our algorithm. The ﬁrst of such tools is query
rewriting. Consider a mapping M between schemas S and
T and a query Q over schema T. We say that a query Q′
over S is a rewriting of Q over the source if for every source
database I, the set Q′(I) is exactly the set of certain answers
of Q over I with respect to M, that is,

Q′(I) = certainM(Q, I).

In our algorithm, we need to compute rewritings for conjunctive 
queries. It is known that given a mapping M speciﬁed
by a set of tgds and a conjunctive query Q over the target
schema, a rewriting of Q over the source always exists [1,
5]. Moreover, it can be shown that if Q is a conjunctive
query, then a rewriting of Q over the source can always be
expressed as a union of conjunctive queries with the equality 
predicates (UCQ=). As an example, consider a mapping
given by the following tgds:

A(x, y) → P (x, y),
B(x) → P (x, x),

and let Q be the target query P (x, y). Then a rewriting of
Q over the source is given by A(x, y) ∨ (B(x) ∧ x = y), which
is a query in UCQ=. Notice that in this rewriting, we do
need disjunction and the equality x = y.

The following observations are useful for our algorithm.
Let Q be a query in UCQ=. Every equality of the form
x = y that occurs in Q is safe in the sense that x or y must
occur in a relational atom in Q. Also, by using the appropriate 
variable substitutions, one can eliminate all equalities in

Q between two existentially quantiﬁed variables, or between
a free variable and an existentially quantiﬁed variable. For
example, the query ∃u (P (x, y, u) ∧ y = u) is equivalent to
P (x, y, y), and the query ∃u∃v (P (x, u, v) ∧ u = v) is equivalent 
to ∃u P (x, u, u). On the other hand, equalities between
free variables cannot be simply eliminated, as in the above
query A(x, y) ∨ (B(x) ∧ x = y). Thus, from now on, we
assume that if an equality x = y occurs in a query Q of the
class UCQ=, then both x and y are free variables in Q.

A second tool that we use in our algorithm is the notion
of conjunctive-query equivalence of mappings. Two mappings 
M1 and M2 are said to be equivalent with respect to
conjunctive queries, denoted by M1 ≡CQ M2, if for every
conjunctive query Q, the set of certain answers of Q under
M1 coincides with the set of certain answers of Q under M2.
More precisely, we have that M1 ≡CQ M2 if for every conjunctive 
query Q over the target and every source database
I, it holds that certainM1 (Q, I) = certainM2 (Q, I). The
notion of conjunctive-query equivalence was introduced by
Madhavan and Halevy [22] when studying the composition
of schema mappings, and has also been used for schema
mapping optimization in [12]. The following lemma relates
the notions of CQ-maximum recovery and conjunctive-query
equivalence, and is used in the formulation of our algorithm.

Lemma 4.1. Let M′ be a CQ-maximum recovery of M,
and assume that M′ ≡CQ M′′. Then M′′ is also a CQmaximum 
recovery of M.

For the sake of readability, in this section we omit the existentially 
quantiﬁed variables in the consequents of tgds.
Thus, we use notation ϕ(¯x) → ψ(¯x) for a tgd, where ϕ(¯x)
is a conjunction of relational atoms over S and ψ(¯x) is a
conjunctive query over T (that is, ψ(¯x) = ∃¯y α(¯x, ¯y)).
4.1 A CQ-maximum recovery algorithm

The basic strategy of our algorithm is as follows. Given a
mapping M speciﬁed by a set of tgds, we start by computing 
a maximum recovery M1 of M by using the algorithm
presented in [2]. Since the output mapping M1 is a maximum 
recovery of M, we know by the results in Section 3
that M1 is also a CQ-maximum recovery of M. However,
the mapping M1 may have disjunctions and equalities in
the conclusions of the dependencies specifying it. Thus, our
algorithm performs a series of transformations on M1 that
eliminate these disjunctions and equalities, while preserving
conjunctive-query equivalence. To be more precise, we ﬁrst
use a procedure that eliminates the equalities from M1 to
produce a mapping M2 that is also a maximum recovery of
M, and then we use some graph-theoretical techniques to
produce a mapping M⋆ from M2 such that M⋆ ≡CQ M2
and the dependencies specifying M⋆ do not include disjunctions 
in the conclusions. By using Lemma 4.1, we conclude
that the resulting mapping M⋆ is also a CQ-maximum recovery 
of M.

Computing a maximum recovery
We start by presenting the algorithm for computing maximum 
recoveries of mappings given by tgds developed in the
full version of [2]. The algorithm relies on query rewriting in
order to compute a maximum recovery. In particular, we assume 
that given a set Σ of tgds and a conjunctive query Q(¯x)
over the target schema of Σ, Rewrite(Σ, Q(¯x)) produces a
query in UCQ= that is a rewriting of Q over the source.

The study of conjunctive query rewriting has produced several 
techniques that can be used in the implementation of
Rewrite [8, 26, 16]. Therefore, we use the process of query
rewriting as a black box in our algorithm.

Algorithm: MaximumRecovery(Σ) [2]
Input: A set Σ of tgds
Output: A set Σ′ that deﬁnes a maximum recovery of Σ

1. Let Σ′ be empty.
2. For every tgd ϕ(¯x) → ψ(¯x) in Σ do the following:

2.1. Let α(¯x) be the output of Rewrite(Σ, ψ(¯x)).
2.2. Add dependency ψ(¯x) ∧ C(¯x) → α(¯x) to Σ′.

3. Return the set Σ′.

2

Notice that predicate C(·) is used to diﬀerentiate constant
from nulls in the reverse mapping produced by the algorithm
MaximumRecovery. In fact, this predicate has been used
to ensure that only constant values are returned back to
the source database. It has been shown that C(·) is essential 
in expressing maximum recoveries of mappings given by
tgds [2] (as well as in Fagin-inverses and quasi-inverses [14]).
We show later that predicate C is also essential in order to
express CQ-maximum recoveries. Another important issue
is the form of the conclusion of the dependencies in the output 
of algorithm MaximumRecovery. Notice that formula
α(¯x) constructed in Step 2.1 is a union of conjunctive queries
with equalities, since it is obtained by rewriting the conjunctive 
query ψ(¯x). It follows then that the mapping generated
by the algorithm is speciﬁed by dependencies with disjunctions 
and equalities in their conclusions, which have to be
eliminated in order to obtain an inverse mapping with the
same good properties for data exchange as tgds. We show
how to do this in the remaining of this section.

Eliminating equalities
We now proceed to eliminate the equalities that occur in
the conclusions of the dependencies generated by algorithm
MaximumRecovery. The elimination algorithm replaces
these equalities by inequalities in the premises of the dependencies.
 As an example, consider the following dependency.

P (x, y) → A(x, y) ∨ (B(x) ∧ x = y).

It is not diﬃcult to see that the above dependency is logically
equivalent to the following set of dependencies:

P (x, y) ∧ x 6= y → A(x, y),

P (x, x) → A(x, x) ∨ B(x).

To formally describe this process, we need to introduce some
terminology. Let ¯x = (x1, . . . , xn) be a tuple of distinct
variables, and assume that π is a partition of the variables
in ¯x. Then π(xi) is the set of variable in ¯x that are assigned
to the same class by π. For example, if ¯x = (x1, x2, x3) and
π is the partition {{x1}, {x2, x3}}, then π(x3) = {x2, x3}.
Let fπ : {x1, . . . , xn} → {x1, . . . , xn} be a function such
that fπ(xi) = xj if j is the minimum index over all the
indexes of the variables in π(xi). That is, fπ is a function
that selects a unique representative from every class in π.
For example, if ¯x = (x1, x2, x3, x4, x5) and π is the partition
{{x1, x4}, {x2, x5}, {x3}}, then fπ(x1) = x1, fπ(x2) = x2,
fπ(x3) = x3, fπ(x4) = x1, fπ(x5) = x2. Moreover, given a
formula α(¯x), we denote by α(fπ(¯x)) the formula obtained

from α(¯x) by replacing every variable xi by fπ(xi), and we
denote by δπ a formula obtained by taking the conjunction of
the inequalities fπ(xi) 6= fπ(xj) whenever fπ(xi) and fπ(xj)
are distinct variables. For instance, in the above example
we have that δπ is the formula x1 6= x2 ∧ x1 6= x3 ∧ x2 6= x3.
Finally, given a conjunction of equalities α and a conjunction
of inequalities β, we say α is consistent with β if there is
an assignment of values to the variables in α and β that
satisﬁes all the equalities and inequalities in these formulas.
For example, x1 = x2 is consistent with x1 6= x3, while
x1 = x2 ∧ x2 = x3 is not consistent with x1 6= x3. It should
be noticed that this consistency problem can be solved in
polynomial time.

Algorithm: EliminateEqualities(Σ′)
Input: A set Σ′ of dependencies of the form ψ(¯x) ∧ C(¯x) →
α(¯x), with ψ(¯x) a conjunction of relational atoms and α(¯x)
a query in UCQ=.
Output: A set Σ′′ of dependencies of the form ρ(¯y)∧C(¯y)∧
δ(¯y) → γ(¯y), with ρ(¯y) a conjunction of relational atoms,
δ(¯y) a conjunction of inequalities and γ(¯y) a union of conjunctive 
queries (without equalities).

1. Let Σ′′ be empty.
2. For every dependency σ in Σ′ of the form ψ(¯x) ∧ C(¯x) →

α(¯x), and for every partition π of ¯x do the following:

– Let α(¯x) = β1(¯x) ∨ · · · ∨ βk(¯x).
– Construct a formula γ from α(fπ(¯x)) as follows. For

every i ∈ {1, . . . , k}:

– If the equalities in βi(fπ(¯x)) are consistent with δπ,
then drop the equalities in βi(fπ(¯x)) and add the
resulting formula as a disjunct in γ.

– If γ has at least one disjunct, then add to Σ′′ the

dependency ψ(fπ(¯x)) ∧ C(fπ(¯x)) ∧ δπ → γ.

3. Return the set Σ′′.

2

For example, assume that the following dependency is in Σ′:

A(x1, x2, x3) ∧ C(x1) ∧ C(x2) ∧ C(x3) →

[ P (x1, x2) ∧ R(x1, x1) ∧ x2 = x3 ] ∨
[ ∃y (P (x1, y) ∧ R(x2, x3)) ] ∨
[ P (x1, x2) ∧ R(x2, x3) ∧ x1 = x3 ],

and let π be the partition {{x1}, {x2, x3}}. Then we have
that fπ(x1) = x1, fπ(x2) = fπ(x3) = x2 and δπ is the
formula x1 6= x2. Next we show now how formula γ is constructed 
from this partition in the Step 2 of the algorithm.
In the ﬁrst disjunct, after replacing variables according to
fπ we obtain the formula P (x1, x2) ∧ R(x1, x1) ∧ x2 = x2.
Thus, given that x2 = x2 is consistent with δπ, we add
P (x1, x2) ∧ R(x1, x1) as a disjunct in γ. Similarly for the
second disjunct, we replace variables according to fπ to obtain 
formula ∃y (P (x1, y) ∧ R(x2, x2)), which is added as a
disjunct in γ. Finally, for the third disjunct, by applying
fπ we obtain P (x1, x2) ∧ R(x2, x2) ∧ x1 = x2. But equality
x1 = x2 is not consistent with δπ and, hence, no further
disjunct is added to γ. Notice that γ contains at least one
disjunct, thus, we add to Σ′′ dependency:

A(x1, x2, x2) ∧ C(x1) ∧ C(x2) ∧ x1 6= x2 →
[P (x1, x2) ∧ R(x1, x1)] ∨ [∃y (P (x1, y) ∧ R(x2, x2))].

(4)

The following lemma states a key property of the algorithm
EliminateEqualities, namely that the transformations in
the algorithm preserve the property of being a maximum
recovery.

Lemma 4.2. Let Σ be a set of tgds, Σ′ the output of
MaximumRecovery(Σ), and Σ′′ the output of Elimina-
teEqualities(Σ′). Then the mapping speciﬁed by Σ′′ is a
maximum recovery of the mapping speciﬁed by Σ.

Eliminating disjunctions
Let Σ′′ be the set obtained by the successive application
of algorithms MaximumRecovery and EliminateEqualities 
to a set of tgds. Then, every dependency in Σ′′ is of
the form:

ψ(¯x) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) ∨ · · · ∨ βk(¯x),

where ψ(¯x) and each βi(¯x) are conjunctive queries, and δ(¯x)
is a conjunction of inequalities x 6= x′ for every pair of distinct 
variables x, x′ in ¯x. In the last step of our algorithm,
we eliminate the disjunctions in the conclusions of the dependencies.
 Next we describe the machinery used to obtain
a set Σ⋆ that is CQ-equivalent to Σ′′, but such that the conclusions 
of the dependencies of Σ⋆ are conjunctive queries.
Let Q1 and Q2 be two n-ary conjunctive queries, and assume 
that ¯x is the tuple of free variables of Q1 and Q2. The
product of Q1 and Q2, denoted by Q1 × Q2, is deﬁned as a
k-ary conjunctive query (with k ≤ n) constructed as follows.
Let f (·, ·) be a one-to-one function from pairs of variables
to variables such that: (1) f (x, x) = x for every variable x
in ¯x, and (2) f (y, z) is a fresh variable (mentioned neither
in Q1 nor in Q2) in any other case. Then for every pair
of atoms R(y1, . . . , ym) in Q1 and R(z1, . . . , zm) in Q2, the
atom R(f (y1, z1), . . . , f (ym, zm)) is included as a conjunct
in the query Q1 × Q2. Furthermore, the set of free variables
of Q1 × Q2 is the set of variables from ¯x that are mentioned
in Q1 × Q2. For example, consider conjunctive queries:

Q1(x1, x2) = P (x1, x2) ∧ R(x1, x1),
Q2(x1, x2) = ∃y (P (x1, y) ∧ R(x2, x2)).

Then we have that Q1 × Q2 is the conjunctive query:

(Q1 × Q2)(x1) = ∃z1∃z2 (P (x1, z1) ∧ R(z2, z2)).

In this case, we have used a function f such that f (x1, x1) =
x1, f (x2, y) = z1, and f (x1, x2) = z2. As shown in the
example, the free variables of Q1 × Q2 do not necessarily
coincide with the free variables of Q1 and Q2. Notice that
the product of two queries may be empty. For example, if
Q1 = ∃y1∃y2P (y1, y2) and Q2 = ∃z1R(z1, z1), then Q1 × Q2
is empty.

The deﬁnition of the product of queries is motivated by
the standard notion of Cartesian product of graphs. In fact,
if Q1 and Q2 are Boolean queries constructed by using a
single binary relation E(·, ·), then the product Q1 × Q2 exactly 
resembles the graph-theoretical Cartesian product [18].
Moreover, the product Q1 × Q2 is a new query that has homomorphisms 
to both Q1 and Q2, and such that for every
other query Q⋆ that has a homomorphism to Q1 and Q2,
it holds that Q⋆ has a homomorphism to Q1 × Q2. In this
sense, Q1 × Q2 is the “closest” query to both Q1 and Q2.
Thus, the product of queries is useful in preserving the information 
that can be retrieved by using conjunctive queries

and, as such, it plays a key role in the following algorithm
that eliminates disjunctions.

Algorithm: EliminateDisjunctions(Σ′′)
Input: A set Σ′′ of dependencies of the form ψ(¯x) ∧ C(¯x) ∧
δ(¯x) → β1(¯x) ∨ · · · ∨ βk(¯x), with ψ(¯x) a conjunction of relational 
atoms, δ(¯x) a conjunction of inequalities x 6= x′ for
every pair of distinct variables x, x′ in ¯x, and each βi(¯x) a
conjunctive query.
Output: A conjunctive-query equivalent set Σ⋆ of dependencies 
of the form ψ(¯x) ∧ C(¯x) ∧ δ(¯x) → γ(¯x), with ψ(¯x)
and δ(¯x) as above, and γ(¯x) a conjunctive query.

1. Let Σ⋆ be empty.
2. For every dependency of the form ψ(¯x) ∧ C(¯x) ∧ δ(¯x) →

β1(¯x) ∨ · · · ∨ βk(¯x) in Σ′′ do the following:

– if β1(¯x) × · · · × βk(¯x) is not empty, then add the following 
dependency to Σ⋆:

ψ(¯x) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) × · · · × βk(¯x).

3. Return the set Σ⋆.

2

For example, assume that dependency (4) is in Σ′′. Then
since [ P (x1, x2) ∧ R(x1, x1) ] × [ ∃y (P (x1, y) ∧ R(x2, x2)) ]
is the query ∃z1∃z2 (P (x1, z1) ∧ R(z2, z2)), the following dependency 
is included in Σ⋆:

A(x1, x2, x2) ∧ C(x1) ∧ C(x2) ∧ x1 6= x2 →

Algorithm: CQ-MaximumRecovery(Σ)
Input: A set Σ of tgds
Output: A set Σ⋆ of tgds with inequalities and predicate
C in their premises, that deﬁnes a CQ-maximum recovery
of Σ.

1. Let Σ′ be the output of MaximumRecovery(Σ).
2. Let Σ′′ be the output of EliminateEqualities(Σ′).
3. Let Σ⋆ be the output of EliminateDisjunctions(Σ′′).
4. Return Σ⋆.

2

The following theorem states the correctness of the above
algorithm. The theorem is a direct consequence of Lemmas 
4.1, 4.2, and 4.3.

Theorem 4.4. Let Σ be a set of tgds and Σ⋆ the output of
algorithm CQ-MaximumRecovery(Σ). Then the mapping
speciﬁed by Σ⋆ is a CQ-maximum recovery of the mapping
speciﬁed by Σ.
4.2 The language of CQ-maximum recoveries
At this point, a natural question is to which extent the
extra features of the rules in the set Σ⋆ returned by algorithm 
CQ-MaximumRecovery are really needed. Theorem
4.5 states that inequalities and predicate C in the premises
of the output dependencies are both needed if we want to
express CQ-maximum recoveries of mappings given by tgds.

Theorem 4.5. Let M be a mapping speciﬁed by a set of

∃z1∃z2 (P (x1, z1) ∧ R(z2, z2)).

(5)

tgds. Then the following hold.

The crucial property of algorithm EliminateDisjunctions
is stated in the following lemma.

Lemma 4.3. Let Σ⋆ be the set of dependencies obtained
as output of EliminateDisjunctions(Σ′′). Then the mapping 
speciﬁed by Σ′′ is conjunctive-query equivalent to the
mapping speciﬁed by Σ⋆.

Let us give some intuition of why this result holds. Assume 
that J is the instance {A(1, 2, 2)}. Then every solution
of J under the dependency (4) necessarily contains the tuples 
P (1, 2), R(1, 1) (corresponding to the ﬁrst disjunct) or
the tuples P (1, u), R(2, 2) for some value u (corresponding
to the second disjunct). Thus, the conjunctive information
that all the solutions of J share is that: the value 1 appears 
in the ﬁrst component of a tuple of relation P , and
some element appears in both components of the same tuple 
of relation R. If we now consider the space of solutions
for J under dependency (5), we obtain that every solution
contains the tuples P (1, u), R(v, v) for some values u and
v. That is, the conjunctive information shared by all the
solutions of J under dependency (4) is exactly the same as
under dependency (5). In fact, (as stated in Lemma 4.3),
it can be formally proved that if M1 and M2 are the mappings 
speciﬁed by dependencies (4) and (5), respectively,
then M1 ≡CQ M2, that is, for every instance J and conjunctive 
query Q over the target of these mappings, it holds
that certainM1 (Q, J) = certainM2 (Q, J).

Putting it all together
The following is the complete version of the algorithm that
computes CQ-maximum recoveries expressed in a language
with good properties for data exchange.

(1) M has a CQ-maximum recovery speciﬁed by a set
of tgds with inequalities and predicate C in their
premises.

(2) Statement (1) is not necessarily true if we disallow either 
inequalities or predicate C in the premises of dependencies.


Part (1) of the theorem follows directly from the properties
of the algorithm CQ-MaximumRecovery. In [14], Fagin
et al. prove that inequalities and predicate C are needed
to express Fagin-inverses of tgds. It should be pointed out
that part (2) of the above theorem cannot be obtained as a
corollary of the results in [14], as the notion of CQ-maximum
recovery is strictly weaker than the notion of Fagin-inverse.
In fact, there exist mappings M1 and M2 such that: M1
is speciﬁed by a set of tgds and has a Fagin-inverse, M2 is
a CQ-maximum recovery of M1, but M2 is not a Fagininverse 
of M1.

5. COMPUTING INVERSES IN

POLYNOMIAL TIME

As we mentioned before, during the last years people have
proposed several notions of inversion of schema mappings
[10, 14, 2]. One of the limitations of all these proposals is
that they have only provided algorithms for computing inverses 
that work in exponential time and produce inverse
mappings of exponential size. In this section, we overcome
this limitation by providing the ﬁrst polynomial time algorithm 
for the three notions of inversion proposed in [10, 14,
2], and also for the notion of CQ-maximum recovery proposed 
in this paper.

The algorithm proposed in this section uses an intermediate 
mapping language that has some form of second-order
quantiﬁcation, and which was inspired by the language proposed 
in [13] for expressing the composition of two schema
mappings. In particular, to compute an inverse of a mapping 
given by a set Σ of tgds, the algorithm ﬁrst translate in
linear time Σ into a speciﬁcation Σ′ written in this secondorder 
language, and then it computes an inverse for Σ′. In
fact, the algorithm is capable of computing in polynomial
time an inverse for an arbitrary mapping speciﬁed in this
second-order language. This result is particularly interesting
as there exist mapping languages that are used in practice
and have not been taken into account in the previous work
on inversion, and for which an inverse can be computed by
translating them into this second-order language. For example,
 this is the case for nested mappings [15], which extend
tgds with several desirable features and are used in Clio [19],
the IBM data exchange tool. Next we introduce our secondorder 
language, and then we present our polynomial time
algorithm for computing inverses.
5.1 Plain SO-tgds

The limitations of tgds as a mapping language for data
exchange has been recognized in some studies [13, 5].
In
fact, the following example from [13] shows a practical case
in which tgds are not powerful enough to capture the desired
semantics of data exchange.

Example 5.1. Consider the following schemas: A source
schema S consisting of one binary relation Takes, that associates 
a student name with a course she/he is taking, and a
target schema T consisting of a binary relation Enrollment,
that associates a student id with a course that she/he is
taking. Intuitively, when translating data from S to T, one
would like to replace the name n of a student by a student id
in, and then for each course c that is taken by n, one would
like to include the tuple (in, c) in the table Enrollment. Unfortunately,
 as it is shown in [13], it is not possible to express
this relationship by using a set of tgds. In particular, a tgd
of the form:

Takes(n, c) → ∃y Enrollment(y, c)

(6)

does not express the desired relationship as it may associate
a distinct student id y for each tuple (n, c) in Takes and,
thus, it may create several identiﬁers for the same student
name. 2

One way to overcome the limitation of tgds in the previous
example is by adding a way to associate to each student
name n a unique identiﬁer in.
In fact, this can be done
by including a function f that associate with each student
name n an id f (n):

Takes(n, c) → Enrollment(f (n), c).

(7)

We note that this rule expresses the desired relationship in
Example 5.1, as for every course c taken by a student with
name n, the tuple (f (n), c) is in the table Enrollment.

The possibility of using function symbols in tgds was identiﬁed 
in [13] as a way to overcome the limitations of tgds for
expressing the composition of schema mappings. In this section,
 we take advantage of this idea, and introduce a mapping 
language that also uses function symbols (called plain
SO-tgds), and which is extensively used in our inversion algorithm.
 But before introducing this language, we need to

deﬁne the notion of plain term. Given a tuple ¯x of variables
and a tuple ¯f of function symbols, a plain term built from
¯x and ¯f is either a variable x in ¯x, or a term of the form
f (x1, . . . , xk) where each variable xi is in ¯x and f is in ¯f .

We now deﬁne the notion of plain SO-tgd. Given schemas
S and T with no relation symbols in common, a plain
second-order tgd from S to T (plain SO-tgd) is a formula
of the form:

∃ ¯f ˆ ∀¯x1(ϕ1 → ψ1) ∧ · · · ∧ ∀¯xn(ϕn → ψn) ˜,

(8)

where (a) each member of ¯f is a function symbol, (b) each
formula ϕi is a conjunction of formulas of the form S(y1, . . .,
yk), where S is a relation symbol of S and y1, . . ., yk are (not
necessarily distinct) variables in ¯xi, and (c) each formula ψi
is a conjunction of formulas of the form T (t1, . . . , tℓ), where
T is a relation symbol of T and t1, . . ., tℓ are plain terms
built from ¯xi and ¯f . For the sake of readability, we usually 
omit the second-order quantiﬁer ∃ ¯f and the ﬁrst-order
quantiﬁers ∀¯x1, . . ., ∀¯xn from a plain SO-tgd of the form
(8), as they are clear from the context. Thus, for example,
rule (7) is a plain SO-tgd, as well as the following rule:

S(x, y) → T (x, f (x, y)) ∧ U (g(x), y).

The semantics of plain SO-tgds is deﬁned as follows. Assume
that I is a source instance and J is a target instance. An
interpretation of a k-ary function f in (I, J) is a function
that maps every tuple (a1, . . . , ak) of elements in I to an
element in J.

Example 5.2. Assume that instance I = {Takes(n1, c1),
Takes(n1, c2), Takes(n2, c1)} and J = {Enrollment(id1, c1),
Enrollment(id1, c2), Enrollment(id2, c1)}. Then a possible
interpretation in (I, J) of a unary function f is f (n1) = id1,
f (n2) = id2, f (c1) = c1 and f (c2) = c2. 2

Then we say that a pair (I, J) of instances satisﬁes a plain
SO-tgd of the form (8) if there exists an interpretation in
(I, J) of each function in ¯f such that (I, J) satisﬁes each
dependency ∀¯xi(ϕi → ψi) with this interpretation. For example,
 if I and J are the instances shown in Example 5.2,
then (I, J) satisﬁes plain SO-tgd (7) as (I, J) satisﬁes this
dependency with the interpretation for f given in Example
5.2.

It is not diﬃcult to see that every set of tgds can be transformed 
in linear time into a plain SO-tgd. For example, tgd
(6) is equivalent to the following plain SO-tgd:

Takes(n, c) → Enrollment(f (n, c), c).

Notice that the above dependency says that for every tuple 
(n, c) in the table Takes, there exists a value f (n, c)
in the target such that the tuple (f (n, c), c) is in the table
Enrollment, which corresponds to the intended semantics of
tgd (6). Moreover, every nested mapping [15] can be translated 
in polynomial time into a plain SO-tgd. Thus, as the
algorithm presented in this section is capable of inverting in
polynomial time schema mappings given by plain SO-tgds, it
can be used to eﬃciently compute inverses for the mappings
most commonly used in practice [11, 15]. But not only that,
as the language of plain SO-tgds is strictly more expressive
than nested mappings, our algorithm can also be used to
compute inverses for other mappings of practical interest.

We conclude this section by noticing that the language of
plain SO-tgds is similar to the second-order language proposed 
in [13]. However, the language proposed in [13] is too

powerful in the sense that there exist mappings speciﬁed in
this language that are not invertible under any of the inverse
notions proposed in the data exchange literature [10, 14, 2].
On the contrary, every mapping speciﬁed by plain SO-tgds
admits a maximum recovery which can be computed by using 
the inversion algorithm proposed in this section.
5.2 A polynomial time inversion algorithm

As we have mentioned before, there are three preponderant 
notions of inverse for schema mappings: Fagin-inverse
[10], quasi-inverse [14] and maximum recovery [2]. All the
algorithms for computing these three notions work in exponential 
time and produce inverses of exponential size.
In
fact, it was proved in the extended version of [2] that for
the mapping languages considered in all those papers, there
exists a mapping given by a set of tgds such that every maximum 
recovery of this mapping is of exponential size. In this
section, we overcome these limitations and present a polynomial 
time algorithm that computes maximum recoveries of
mappings given by sets of tgds, and uses a diﬀerent mapping
language from those considered in [10, 14, 2] to express inverses.
 It should be noticed that this algorithm can also be
used to compute Fagin-inverses and quasi-inverses for sets of
tgds, as from the results in [2], we know that every mapping
M given by a set of tgds admits a maximum recovery, and if
M admits a Fagin-inverse (quasi-inverse), then every maximum 
recovery of M is also a Fagin-inverse (quasi-inverse)
of M. Interestingly, this algorithm can also be used to deal
with the notion of CQ-maximum recovery introduced in this
paper, as every maximum recovery is also a CQ-maximum
recovery.

More precisely, in this section we present a polynomial
time algorithm that, given a set of plain SO-tgds, returns
a maximum recovery that is expressed in a language that
extends plain SO-tgds with some extra features. Since every
set of tgds can be transformed in linear time into a plain SOtgd,
 we obtained our desired result.

We start by giving some of the intuition behind the algorithm.
 Consider the following plain SO-tgd:

R(x, y, z) → T (x, f (y), f (y), g(x, z)).

(9)

When exchanging data with an SO dependency like (9),
the standard assumption is that every application of a
function symbol generates a fresh value [13]. For example,
 consider a source instance {R(1, 2, 3)}. When we exchange 
data with (9), we obtain a canonical target instance
{T (1, a, a, b)}, where a = f (2), b = g(1, 3), and a 6= b. The
intuition behind our algorithm is to produce a reverse mapping 
that focuses on this canonical target instance to recover
as much source data as possible. Thus, in order to invert a
dependency like (9), we consider three unary functions f1, g1
and g2. The idea is that f1 represents the inverse of f , while
(g1, g2) represents the inverse of g. Notice that since g has
two arguments, we need to use two functions to represent
its inverse. Thus, considering the above example, the intended 
meaning of the functions is f1(a) = 2, g1(b) = 1, and
g2(b) = 3. With this in mind, we can represent an inverse
of the plain SO-tgd (9) with a dependency of the form:

T (u, v, v, w) → R(u, f1(v), g2(w)) ∧ u = g1(w).

(10)

Notice that, if we use dependency (10) to exchange data
back from instance {T (1, a, a, b)}, we obtain an instance
{R(1, f1(a), g2(b))}. The equality u = g1(w) has been added

in order to ensure the correct interpretation of g1 as the inverse 
function of g.
In the example, the equality ensures
that g1(b) is 1.

In order to obtain a correct algorithm we need another
technicality, that we describe next. We have mentioned
that when exchanging data with SO dependencies, we assume 
that every application of a function produces a fresh
value. In the above example, we have that value a is the
result of applying f to 2, thus, we know that value a cannot 
be obtained with any other function. In particular, a
cannot be obtained as an application of function g. Thus,
when exchanging data back we should ensure that at most
one inverse function is applied to every possible target value.
We do that by using an additional unary function f⋆. In the
above example, whenever we apply function f1 to some value
v, we require that f1(v) = f⋆(v) and that g1(v) 6= f⋆(v).
Similarly, whenever we apply function g1 to some value w,
we require that g1(w) = f⋆(w) and that f1(w) 6= f⋆(w).
Thus, for example, if we apply f1 to value a, we require that
f1(a) = f⋆(a) and that g1(a) 6= f⋆(a). Notice that this forbids 
the application of g1 to a, since, if that were the case, we
would require that g1(a) = f⋆(a), which contradicts the previous 
requirement g1(a) 6= f⋆(a). Our algorithm adds these
equalities and inequalities as conjuncts in the conclusions of
dependencies. Considering the example, our algorithm adds

f1(v) = f⋆(v) ∧ g1(v) 6= f⋆(v) ∧
g1(w) = f⋆(w) ∧ f1(w) 6= f⋆(w)

to the conclusion of dependency (10).

Before presenting our algorithm, we make some observations.
 First, notice that plain SO-tgds are closed under 
conjunction and, thus, a set of plain SO-tgds is equivalent 
to a single plain SO-tgd. For this reason, we assume 
that our algorithm has as input a single plain SO-tgd
λ = ∃ ¯f (σ1 ∧ · · · ∧ σ2). Second, although we have assumed in
the above explanation that every application of a function
generates a fresh value, we remark that this assumption has
only been used as a guide in the design of our algorithm.
In fact, it is shown in Theorem 5.3 that the algorithm presented 
in this section produces inverses for the general case,
where no assumption about the function symbols is made.

Preliminary procedures
We start by ﬁxing some notation. Given a plain SO-tgd λ,
we denote by Fλ the set of function symbols that occur in λ.
We also consider a set of function symbols F ′
λ constructed as
follows. For every n-ary function symbol f in Fλ, the set F ′
λ
contains n unary function symbols f1, . . . , fn. Additionally,
F ′
λ contains a unary function symbol f⋆. For example, for
plain SO-tgd (9), Fλ = {f, g} and F ′

λ = {f1, g1, g2, f⋆}.

We describe the procedures CreateTuple, EnsureInv,
and Safe. These procedures are the building blocks of the
algorithm that computes an inverse of a plain SO-tgd.

Procedure CreateTuple(¯t) receives as input a tuple
¯t = (t1, . . . , tn) of plain terms. Then it builds an n-tuple
of variables ¯u = (u1, . . . , un) such that, if ti = tj then ui
and uj are the same variable, and they are distinct variables 
otherwise. For example, consider the conclusion of
dependency (9). In the argument of relation T we have the
tuple of terms ¯t = (x, f (y), f (y), g(x, z)). In this case, we
have that procedure CreateTuple(¯t) returns a tuple of the
form (u, v, v, w). Notice that we have used this tuple as the
argument of T in the premise of dependency (10).

Tuple ¯u created with CreateTuple is used as an input
in the following two procedures. We now formalize the procedure 
to obtain a formula that guarantees the correct use
of the inverse function symbols.

Procedure: EnsureInv(λ, ¯u, ¯s)
Input: A plain SO-tgd λ, an n-tuple ¯u = (u1, . . . , un) of
(not necessarily distinct) variables, and an n-tuple of plain
terms ¯s built from Fλ and a tuple of ¯y variables.
Output: A formula Qe consisting of conjunctions of equalities 
between terms built from F ′

λ and ¯u, ¯y.

1. Let ¯s = (s1, . . . , sn).
2. Construct formula Qe as follows. For every i ∈ {1, . . . , n}

do the following:

– If si is a variable y, then add equality ui = y as a

conjunct in Qe.

– If si is a term of the form f (y1, . . . , yk), then add the

conjunction of equalities

f1(ui) = y1 ∧ · · · ∧ fk(ui) = yk

to Qe, where f1, . . . , fk are the k unary functions in
F ′

λ associated with f .

3. Return Qe.

2

As an example,
let λ be the dependency (9), ¯s =
(x, f (y), f (y), g(x, z)) the tuple of terms in the conclusion
of λ, and ¯u = (u, v, v, w). When running the procedure
EnsureInv(λ, ¯u, ¯s), we have that u4 = w and s4 = g(x, z).
Thus,
in the loop of Step 2, the conjunction g1(w) =
x ∧ g2(w) = z is added to formula Qe. The ﬁnal output of
the algorithm in this case is:

u = x ∧ f1(v) = y ∧ g1(w) = x ∧ g2(w) = z.

(11)

We need to describe one more procedure, which guarantees 
that it could not be the case that a value in the target
was generated by two distinct functions.

Procedure: Safe(λ, ¯u, ¯s)
Input: A plain SO-tgd λ, an n-tuple ¯u = (u1, . . . , un) of not
necessarily distinct variables, and an n-tuple of plain terms
¯s built from Fλ and a tuple of variables ¯y.
Output: A formula Qs consisting of equalities and inequalities 
between terms built from F ′

λ and ¯u.

1. Let ¯s = (s1, . . . , sn).
2. Construct formula Qs as follows. For every i ∈ {1, . . . , n}

do the following:

– If si is a term of the form f (y1, . . . , yk), then add the

following conjuncts to Qs:
– The equality f⋆(ui) = f1(ui).
– The inequality f⋆(ui) 6= g1(ui), for every function

symbol g in Fλ diﬀerent from f .

3. Return Qs.

2

Considering λ as the dependency (9), ¯s the tuple of terms
(x, f (y), f (y), g(x, z)) and ¯u = (u, v, v, w), the algorithm
Safe(λ, ¯u, ¯s) returns:

f1(v) = f⋆(v) ∧ g1(v) 6= f⋆(v) ∧

g1(w) = f⋆(w) ∧ f1(w) 6= f⋆(w).

(12)

Notice that all the procedures presented so far work in

polynomial time with respect to the size of their inputs.

Building the inverse
We need some additional notation before presenting the algorithm 
for computing inverses of plain SO-tgds. Let ¯t and
¯s be n-tuples of plain terms. Then we say that ¯t is subsumed
by ¯s (or ¯s subsumes ¯t) if, whenever the i-th component of
¯t contains a variable, the i-th component of ¯s also contains
a variable. Notice that if ¯s subsumes ¯t, then whenever the
i-th component of ¯s contains a non-atomic term, the i-th
component of ¯t also contains a non-atomic term. For example,
 the tuple of terms (x, f (y), f (y), g(x, z)) is subsumed by
(u, v, h(u), h(v)).

The following algorithm computes a maximum recovery
of a plain SO-tgd λ in polynomial time. As a consequence
of the results in [2] and the discussion in Section 3.1, the
algorithm can also be used to compute Fagin-inverses, quasiinverses,
 as well as CQ-maximum recoveries.

Algorithm: PolySOInverse(λ)
Input: A plain SO-tgd λ = ∃ ¯f (σ1 ∧ · · · ∧ σn).
Output: An SO dependency λ′ that speciﬁes a maximum
recovery of λ

1. Let Σ = {σ1, . . . , σn}, and Σ′ be empty.
2. (Normalize Σ) For every i ∈ {1, . . . , n} do:

– If σi

is of the form ϕ(¯x) → R1(¯t1) ∧ . . . ∧ Rℓ(¯tℓ),
then replace σi by ℓ dependencies ϕ(¯x) → R1(¯t1), . . . ,
ϕ(¯x) → Rℓ(¯tℓ).

3. (Construct Σ′) For every σ of the form ϕ(¯x) → R(¯t) in
the normalized set Σ, where ¯t = (t1, . . . , tm) is a tuple of
plain terms, do the following:

a. Let ¯u = CreateTuple(¯t).
b. Let prem σ(¯u) be a formula deﬁned as the conjunction
of the atom R(¯u) and the formulas C(ui) for every i
such that ti is a variable.

c. Create a set of formulas Γσ as follows. For every dependency 
ψ(¯y) → R(¯s) in Σ such that ¯s subsumes ¯t,
do the following:

– Let Qe = EnsureInv(λ, ¯u, ¯s).
– Let Qs = Safe(λ, ¯u, ¯s).
– Add to Γσ the formula ∃¯y ` ψ(¯y) ∧ Qe ∧ Qs ´

d. Add to Σ′ the dependency:

prem σ(¯u) → γσ(¯u)

where γσ(¯u) is the disjunction of the formulas in Γσ.

4. Return the SO dependency λ′ = ∃ ¯f ′ (V Σ′), where ¯f ′ is

a tuple containing the function symbols in F ′
λ.

2

Let λ be the plain SO-tgd (9).

In Step 3 of algorithm
PolySOInverse(λ) we have to consider a single dependency 
σ = R(x, y, z) → T (x, f (y), f (y), g(x, z)). Let ¯t
be the tuple of terms (x, f (y), f (y), g(x, z)). Recall that
CreateTuple(¯t) is a tuple of the form (u, v, v, w) and, thus,

premσ(¯u) = T (u, v, v, w) ∧ C(u)

is built in Step 3.b. Notice that C(u) has been added since
the ﬁrst component of ¯t is the variable x. Then in Step
3.c, we need to consider just dependency σ. Notice that ¯t
subsumes itself and, hence, formula

∃x∃y∃z (R(x, y, z) ∧ Qe ∧ Qp)

is added to the set Γσ, where Qe is the formula (11) and Qp
is the formula (12). Finally, the formula:

T (u, v, v, w) ∧ C(u) →

∃x∃y∃z `R(x, y, z) ∧ u = x ∧ f1(v) = y ∧

g1(w) = x ∧ g2(w) = z ∧ Qp´

(13)

is the output of the algorithm. Notice that dependency (13)
is equivalent to:

T (u, v, v, w) ∧ C(u) →

R(u, f1(v), g2(w)) ∧ g1(w) = u ∧ Qp,

which speciﬁes a maximum recovery of λ.

Theorem 5.3. Let M be a mapping speciﬁed by a plain
SO-tgd λ. Algorithm PolySOInverse(λ) computes in polynomial 
time an SO dependency λ′ that speciﬁes a maximum
recovery of M.

From the results in [2], we obtain the following corollary.

Corollary 5.4. Let M be a mapping speciﬁed by a plain
SO-tgd λ. If M has a Fagin-inverse (quasi-inverse), then
algorithm PolySOInv(λ) computes in polynomial time a
Fagin-inverse (quasi-inverse) of M.

It is important to notice that since every set of tgds can be
transformed into a plain SO-tgd in linear time, our algorithm
can be used to compute Fagin-inverses, quasi-inverses, and
maximum recoveries for sets of tgds. This is the ﬁrst polynomial 
time algorithm capable of doing this. However, the gain
in time complexity comes with the price of a stronger and
less manageable mapping language for expressing inverses.

6. CONCLUDING REMARKS

In this paper, we have revisited the problem of inverting
schema mappings paying special attention to some practical 
concerns. We consider two orthogonal limitations of the
previous approaches, namely, the language needed to represent 
inverses and the eﬃciency of the algorithms to compute
them. We have proposed solutions to both of these problems.

In particular, one of our main contributions is the
development of a polynomial time algorithm to compute all
the notions of inverses of schema mappings proposed in the
literature. This is the ﬁrst eﬃcient algorithm capable of
computing these notions.

7. ACKNOWLEDGMENTS

We are very grateful to the anonymous referees for their
helpful comments. The authors were supported by: Arenas
- Fondecyt grants 1070732 and 1090565; P´erez - Conicyt
Ph.D. Scholarship.

8. REFERENCES
[1] M. Arenas, P. Barcel´o, R. Fagin, and L. Libkin.

Locally consistent transformations and query
answering in data exchange. PODS, pp. 229–240, 2004.

[2] M. Arenas, J. P´erez, and C. Riveros. The recovery of

a schema mapping: bringing exchanged data back.
PODS, pp. 13-22, 2008.

[3] P. Bernstein. Applying model management to classical

meta data problems. CIDR, 2003.

[4] P. Bernstein, S. Melnik. Model management 2.0:

manipulating richer mappings. SIGMOD, pp 1-12,
2007.

[5] B. ten Cate, P. Kolaitis. Structural Characterizations
of Schema-Mapping Languages. To be in ICDT, 2009.

[6] G. Giacomo, D. Lembo, M. Lenzerini, R. Rosati. On
reconciling data exchange, data integration, and peer
data management. PODS, pp. 133-142, 2007.

[7] A. Deutsch and V. Tannen. Optimization Properties

for Classes of Conjunctive Regular Path Queries.
DBPL, pp. 21–39, 2001.

[8] O. Duschka, M. Genesereth. Answering Recursive

Queries Using Views. PODS, pp. 109-116, 1997

[9] R. Fagin. Horn clauses and database dependencies.

JACM, 29(4):952–985, 1982.

[10] R. Fagin. Inverting schema mappings. TODS, 32(4),

2007.

[11] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa.

Data exchange: semantics and query answering. TCS,
336(1):89–124, 2005.

[12] R. Fagin, P. G. Kolaitis, A. Nash, L. Popa. Towards a

theory of schema-mapping optimization. PODS, pp.
33–42, 2008.

[13] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan.
Composing schema mappings: second-order dependencies 
to the rescue. TODS, 30(4):994-1055, 2005.
[14] R. Fagin, P. Kolaitis, L. Popa, and W.-C. Tan. Quasiinverses 
of schema mappings. PODS, pp. 123-132,
2007.

[15] A. Fuxman, M. Hern´andez, H. Ho, R. Miller,
P. Papotti,L. Popa Nested Mappings: Schema
Mapping Reloaded VLDB, pp. 67-78, 2006

[16] A. Y. Halevy. Answering queries using views: A

survey. VLDB J. 10(4): 270-294 (2001)

[17] A. Halevy, Z. Ives, J. Madhavan, P. Mork, D. Suciu, I.

Tatarinov. The Piazza Peer Data Management
System. IEEE TKDE 16(7):787-798 (2004)

[18] P. Hell and J. Nesetril. Graphs and Homomorphisms.

Oxford University Press, 2004.

[19] M. A. Hern´andez, H. Ho, L. Popa, A. Fuxman, R. J.

Miller, T. Fukuda and P. Papotti. Creating Nested
Mappings ICDE, pp. 1487-1488, 2007.

[20] T. Imielinski and W. Lipski Jr. Incomplete
information in relational databases. JACM,
31(4):761-791, 1984.

[21] M. Lenzerini. Data Integration: A Theoretical

Perspective.. PODS, pp. 233–246, 2002.

[22] J. Madhavan and A. Y. Halevy. Composing mappings

among data sources. VLDB, pp. 572–583, 2003.

[23] S. Melnik. Generic model management: concepts and

algorithms. Volume 2967 of LNCS, Springer, 2004.

[24] S. Melnik, P. Bernstein, A. Y. Halevy, and E. Rahm.

Supporting executable mappings in model
management. SIGMOD, pp. 167–178, 2005.

[25] A. Nash, P. Bernstein, S. Melnik. Composition of

mappings given by embedded dependencies. PODS
pp. 172–183, 2005.

[26] R. Pottinger, A. Y. Halevy. MiniCon: A scalable

algorithm for answering queries using views. VLDB J.
10(2-3): 182-198 (2001)

