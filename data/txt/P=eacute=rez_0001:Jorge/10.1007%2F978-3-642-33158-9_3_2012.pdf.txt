Federation and Navigation in SPARQL 1.1

Marcelo Arenas1 and Jorge P´erez2

1 Department of Computer Science, Pontiﬁcia Universidad Cat´olica de Chile

2 Department of Computer Science, Universidad de Chile

Abstract. SPARQL is now widely used as the standard query language for RDF.
Since the release of its ﬁrst version in 2008, the W3C group in charge of the
standard has been working on extensions of the language to be included in the
new version, SPARQL 1.1. These extensions include several interesting and very
useful features for querying RDF.

In this paper, we survey two key features of SPARQL 1.1: Federation and
navigation capabilities. We ﬁrst introduce the SPARQL standard presenting its
syntax and formal semantics. We then focus on the formalization of federation
and navigation in SPARQL 1.1. We analyze some classical theoretical problems
such as expressiveness and complexity, and discuss algorithmic properties. Moreover,
 we present some important recently discovered issues regarding the normative 
semantics of federation and navigation in SPARQL 1.1, speciﬁcally, on the
impossibility of answering some unbounded federated queries and the high computational 
complexity of the evaluation problem for queries including navigation
functionalities. Finally, we discuss on possible alternatives to overcome these issues 
and their implications on the adoption of the standard.

1 Introduction

Jointly with the RDF release in 1998 as a W3C Recommendation, the natural problem
of querying RDF data was raised. Since then, several designs and implementations of
RDF query languages have been proposed. In 2004, the RDF Data Access Working
Group, part of the W3C Semantic Web Activity, released a ﬁrst public working draft
of a query language for RDF, called SPARQL. Since then, SPARQL has been rapidly
adopted as the standard for querying Semantic Web data. In January 2008, SPARQL
became a W3C Recommendation [28]. But this recommendation is not the last step
towards the deﬁnition of the right language for querying RDF, and the W3C groups
involved in the design of the language are currently working on the new version of
the standard, the upcoming SPARQL 1.1 [16]. This new version will include several
interesting and useful features for querying RDF.

Among the multiple design issues to be considered, there are two important problems 
that have been in the focus of attention: Federation and Navigation. Since the
release of the ﬁrst version of SPARQL, the Web has witnessed a constant growth in the
amount of RDF data publicly available on-line. Several of these RDF repositories also
provide SPARQL interfaces to directly querying their data, which has led the W3C to
standardize a set of protocols plus some language constructs to access RDF repositories

T. Eiter and T. Krennwallner (Eds.): Reasoning Web 2012, LNCS 7487, pp. 78–111, 2012.
c(cid:2) Springer-Verlag Berlin Heidelberg 2012

Federation and Navigation in SPARQL 1.1

79

by means of what are called SPARQL endpoints. All these constructs are part of the
federation extensions of SPARQL [27], planned to be included in the new version of
the standard [16]. Somewhat orthogonally, we have the issue of navigating data. It has
been largely recognized that navigational capabilities are of fundamental importance
for data models with explicit tree or graph structure, like XML and RDF. Nevertheless,
the ﬁrst release of SPARQL included very limited navigational capabilities. This is one
of the motivations of the W3C to include the property-path feature in the upcoming version 
of the SPARQL standard. Property paths are essentially regular expressions, that
retrieve pairs of nodes from an RDF graph that are connected by paths conforming to
those expressions, and provide a very powerful formalism to query RDF data.

In this paper, intended to be a companion for a short course during the 8th Reasoning
Web Summer School, we survey some recent developments regarding federation and
navigation in SPARQL 1.1. We ﬁrst present an introduction to the SPARQL standard
presenting its syntax and formal semantics. We then focus on the formalization of the
federation and navigation features. We analyze classical theoretical problems such as
expressiveness and complexity, and discuss some algorithmic properties.

The formalization of the SPARQL language presented in this paper is based on the
ofﬁcial SPARQL 1.1 speciﬁcation published on January 2012 [16].1 In this paper, we
present some important recently discovered issues regarding this normative semantics,
speciﬁcally, on the impossibility of answering some unbounded federated queries [7,8]
and the high computational complexity of the evaluation problem for queries including
navigation functionalities [5,19]. It should be noticed that the semantics of SPARQL
1.1 is currently under discussion, and the standardization group is still receiving input
from the community. Hence, some of the issues surveyed in this paper will probably be
revisited in the ﬁnal version of the standard, thus, we also discuss on possible alternatives 
(some of them currently under discussion) and their implications on the adoption
of the standard.

The rest of paper is organized as follows. In Section 2, we introduce the query language 
SPARQL, and we formalize its syntax and semantics including the SPARQL
1.1 federation extension. In Section 3, we study some boundedness issues associated
to this federation extension, and, in particular, we introduce the notions of serviceboundedness 
and service-safeness. In Section 4, we formalize the navigation functionalities 
of SPARQL 1.1. In Section 5, we present some results on the complexity of
evaluating these expressions, and we also present some alternatives to deal with the
high complexity of the evaluation problem. Finally, we give some concluding remarks
in Section 6.

2 The Query Language SPARQL

In this section, we give an algebraic formalization of SPARQL including the SPARQL
1.1 federation extension. For now, we do not consider other features of SPARQL 1.1
such as property paths [16], but we introduce them later in Section 4. We also consider
a set semantics for SPARQL, and extend it to a bag semantics in Section 4.

1 As of June 2012, this is the last version ofﬁcially published by the W3C.

80

M. Arenas and J. P´erez

We restrict ourselves to SPARQL over simple RDF, that is, we disregard higher entailment 
regimes (see [14]) such as RDFS or OWL. Our starting point is the existing
formalization of SPARQL described in [23], to which we add the operators SERVICE
and BINDINGS proposed in [27].2

We introduce ﬁrst the necessary notions about RDF. Assume there are pairwise disjoint 
inﬁnite sets I, B, and L (IRIs [12], Blank nodes, and Literals, respectively). Then
a triple (s, p, o) ∈ (I ∪ B) × I × (I ∪ B ∪ L) is called an RDF triple, where s is called
the subject, p the predicate and o the object. An RDF graph is a set of RDF triples.
Moreover, assume the existence of an inﬁnite set V of variables disjoint from the above
sets, and leave UNBOUND to be a reserved symbol that does not belong to any of the
previously mentioned sets.

2.1 Syntax

The ofﬁcial syntax of SPARQL [26] considers operators OPTIONAL, UNION, FILTER,
GRAPH, SELECT and concatenation via a point symbol (.), to construct graph pattern
expressions. Operators SERVICE and BINDINGS are introduced in the SPARQL 1.1
federation extension, the former for allowing users to direct a portion of a query to a particular 
SPARQL endpoint, and the latter for transferring results that are used to constrain
a query. The syntax of the language also considers { } to group patterns, and some implicit 
rules of precedence and association. In order to avoid ambiguities in the parsing,
we follow the approach proposed in [23], and we ﬁrst present the syntax of SPARQL
graph patterns in a more traditional algebraic formalism, using operators AND (.),
UNION (UNION), OPT (OPTIONAL), FILTER (FILTER), GRAPH (GRAPH) and
SERVICE (SERVICE), then we introduce the syntax of BINDINGS queries, which
use the BINDINGS operator (BINDINGS), and we conclude by deﬁning the syntax
of SELECT queries, which use the SELECT operator (SELECT). More precisely, a
SPARQL graph pattern expression is deﬁned recursively as follows:
(1) A tuple from (I ∪ L ∪ V ) × (I ∪ V ) × (I ∪ L ∪ V ) is a graph pattern (a triple

pattern).

(2) If P1 and P2 are graph patterns, then expressions (P1 AND P2), (P1 OPT P2),

and (P1 UNION P2) are graph patterns.

(P FILTER R) is a graph pattern.

(3) If P is a graph pattern and R is a SPARQL built-in condition, then the expression
(4) If P is a graph pattern and a ∈ (I ∪ V ), then (GRAPH a P ) is a graph pattern.
(5) If P is a graph pattern and a ∈ (I ∪ V ), then (SERVICE a P ) is a graph pattern.
As we will see below, despite the similarity between the syntaxes of GRAPH and
SERVICE operators, they behave semantically quite differently.

For the exposition of this paper, we leave out further more complex graph patterns
from SPARQL 1.1 including aggregates, and subselects (property paths will be formalized 
in Section 4), but only mention one additional feature which is particularly
relevant for federated queries, namely, BINDINGS queries. A SPARQL BINDINGS
query is deﬁned as follows:

2 It is important to notice that SPARQL 1.1 is still under development, and BINDINGS will

likely be renamed to VALUES in future speciﬁcations.

Federation and Navigation in SPARQL 1.1

81
(6) If P is a graph pattern, W ∈ V n is a nonempty sequence of pairwise distinct
variables of length n > 0 and {A1, . . . , Ak} is a nonempty set of sequences
Ai ∈ (I ∪ L ∪ {UNBOUND})n, then (P BINDINGS W {A1, . . . , Ak}) is
a BINDINGS query.

Finally, a SPARQL SELECT query is deﬁned as:

(7) If P is either a graph pattern or a BINDINGS query, and W is a set of variables,

then (SELECT W P ) is a SELECT query.

It is important to notice that the rules (1)–(4) above were introduced in [23], while
rules (5)–(7) were introduced in [7,8] to formalize the federation extension of SPARQL
proposed in [27].
We used the notion of built-in conditions for the FILTER operator above. A
SPARQL built-in condition is constructed using elements of the set (I ∪ L ∪ V ) and
constants, logical connectives (¬, ∧, ∨), the binary equality predicate (=) as well as
unary predicates like bound, isBlank, isIRI, and isLiteral.3 That is: (1) if ?X, ?Y ∈ V
and c ∈ (I ∪ L), then bound(?X), isBlank(?X), isIRI(?X), isLiteral(?X), ?X = c
and ?X =?Y are built-in conditions, and (2) if R1 and R2 are built-in conditions, then
(¬R1), (R1 ∨ R2) and (R1 ∧ R2) are built-in conditions.

Let P be either a graph pattern or a BINDINGS query or a SELECT query. In what
follows, we use var(P ) to denote the set of variables occurring in P . In particular, if t
is a triple pattern, then var(t) denotes the set of variables occurring in the components
of t. Similarly, for a built-in condition R, we use var(R) to denote the set of variables
occurring in R.

2.2 Semantics

To deﬁne the semantics of SPARQL queries, we need to introduce some extra terminology 
from [23]. A mapping μ from V to (I ∪ B ∪ L) is a partial function μ : V →
(I ∪ B ∪ L). Abusing notation, for a triple pattern t, we denote by μ(t) the pattern
obtained by replacing the variables in t according to μ. The domain of μ, denoted by
dom(μ), is the subset of V where μ is deﬁned. We sometimes write down concrete
mappings in square brackets, for instance, μ = [?X → a, ?Y → b] is the mapping with
dom(μ) = {?X, ?Y } such that, μ(?X) = a and μ(?Y ) = b. Two mappings μ1 and
μ2 are compatible, denoted by μ1 ∼ μ2, when for all ?X ∈ dom(μ1) ∩ dom(μ2), it is
the case that μ1(?X) = μ2(?X), i.e. when μ1 ∪ μ2 is also a mapping. Intuitively, μ1
and μ2 are compatible if μ1 can be extended with μ2 to obtain a new mapping, and vice
versa [23]. We will use the symbol μ∅ to represent the mapping with empty domain
(which is compatible with any other mapping).

Let Ω1 and Ω2 be sets of mappings. Then the join of, the union of, the difference

between and the left outer-join between Ω1 and Ω2 are deﬁned as follows [23]:
3 For simplicity, we omit here other features such as comparison operators (‘<’, ‘>’,‘≤’,‘≥’),
data type conversion and string functions, see [26, Section 11.3] for details. It should be noted
that the results of the paper can be easily extended to the other built-in predicates in SPARQL.

82

M. Arenas and J. P´erez

Ω1 (cid:2)(cid:3) Ω2 = {μ1 ∪ μ2 | μ1 ∈ Ω1,
Ω1 ∪ Ω2 = {μ | μ ∈ Ω1 or μ ∈ Ω2},
Ω1 (cid:4) Ω2 = {μ ∈ Ω1 | ∀μ
Ω1 Ω2 = (Ω1 (cid:2)(cid:3) Ω2) ∪ (Ω1 (cid:4) Ω2).

μ2 ∈ Ω2 and μ1 ∼ μ2},
(cid:3)},

(cid:3) ∈ Ω2 : μ (cid:10)∼ μ

Next we use these operators to give semantics to graph pattern expressions, BINDINGS
queries and SELECT queries. More speciﬁcally, we deﬁne this semantics in terms of an
evaluation function (cid:2)· (cid:3)G, which takes as input any of these types of queries and returns
a set of mappings, depending on the active dataset DS and the active graph G within
DS.

Here, we use the notion of a dataset from SPARQL, i.e. a dataset

DS = {(def , G), (g1, G1), . . . , (gk, Gk)},

with k ≥ 0 is a set of pairs of symbols and graphs associated with those symbols,
(cid:10)∈ I and the rewhere 
the default graph G is identiﬁed by the special symbol def
maining so-called “named” graphs (Gi) are identiﬁed by IRIs (gi ∈ I). Without loss
of generality (there are other ways to deﬁne the dataset such as via explicit FROM
and FROM NAMED clauses), we assume that any query is evaluated over a ﬁxed
dataset DS and that any SPARQL endpoint that is identiﬁed by an IRI c ∈ I evaluates
its queries against its own dataset DSc = {(def , Gc), (gc,1, Gc,1), . . . , (gc,kc, Gc,kc)}.
That is, we assume given a partial function ep from the set I of IRIs such that for
every c ∈ I, if ep(c) is deﬁned, then ep(c) = DSc is the dataset associated with
the endpoint accessible via IRI c. Moreover, we assume (i) a function graph(g, DS)
which – given a dataset DS = {(def , G), (g1, G1), . . . , (gk, Gk)} and a graph name
g ∈ {def , g1, . . . , gk} – returns the graph corresponding to symbol g within DS, and
(ii) a function names(DS) which given a dataset DS as before returns the set of names
{g1, . . . , gk}.

The evaluation of a graph pattern P over a dataset DS with active graph G, denoted

by (cid:2)P (cid:3)G, is deﬁned recursively as follows:
(1) If P is a triple pattern t, then (cid:2)P (cid:3)G = {μ | dom(μ) = var(t) and μ(t) ∈ G}.
(2) If P is (P1 AND P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G (cid:2)(cid:3) (cid:2)P2(cid:3)G.
(3) If P is (P1 OPT P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G
(cid:2)P2(cid:3)G.
(4) If P is (P1 UNION P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G ∪ (cid:2)P2(cid:3)G.
(5) If P is (GRAPH c P1) with c ∈ I ∪ V , then

⎧

⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎩

(cid:2)P (cid:3)G =

(cid:6)

graph(c,DS)

(cid:2)P1(cid:3)DS
{μ∅}
μ ∪ μc | ∃g ∈ names(DS) :

μc = [c → g],
μ ∈ (cid:2)P1(cid:3)DS

graph(g,DS) and μc ∼ μ

if c ∈ names(DS)
if c ∈ I \ names(DS)

(cid:7)

if c ∈ V

(6) If P is (SERVICE c P1) with c ∈ I ∪ V , then

Federation and Navigation in SPARQL 1.1

83

⎧

⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎩

(cid:2)P (cid:3)G =

(cid:6)

graph(def ,ep(c))

(cid:2)P1(cid:3)ep(c)
{μ∅}
μ ∪ μc | ∃s ∈ dom(ep) :
μc = [c → s],
μ ∈ (cid:2)P1(cid:3)ep(s)

graph(def ,ep(s)) and μc ∼ μ

if c ∈ dom(ep)
if c ∈ I \ dom(ep)

(cid:7)

if c ∈ V

(7) If P is (P1 FILTER R), then (cid:2)P (cid:3)G = {μ ∈ (cid:2)P1(cid:3)G | μ |= R}.
In the previous deﬁnition, the semantics of the FILTER operator is based on the deﬁnition 
of the notion of satisfaction of a built-in condition by a mapping. More precisely,
given a mapping μ and a built-in condition R, we say that μ satisﬁes R, denoted by
μ |= R, if: 4
- R is bound(?X) and ?X ∈ dom(μ);
- R is isBlank(?X), ?X ∈ dom(μ) and μ(?X) ∈ B;
- R is isIRI(?X), ?X ∈ dom(μ) and μ(?X) ∈ I;
- R is isLiteral(?X), ?X ∈ dom(μ) and μ(?X) ∈ L;
- R is ?X = c, ?X ∈ dom(μ) and μ(?X) = c;
- R is ?X =?Y , ?X ∈ dom(μ), ?Y ∈ dom(μ) and μ(?X) = μ(?Y );
- R is (¬R1), and it is not the case that μ |= R1;
- R is (R1 ∨ R2), and μ |= R1 or μ |= R2;
- R is (R1 ∧ R2), μ |= R1 and μ |= R2.
Moreover, the semantics of BINDINGS queries is deﬁned as follows. Given a sequence
W = [?X1, . . . , ?Xn] of pairwise distinct variables, where n ≥ 1, and a sequence
A = [a1, . . . , an] of values from (I ∪ L ∪ {UNBOUND}), let μW (cid:4)→ A be a mapping
with domain {?Xi | i ∈ {1, . . . , n} and ai ∈ (I∪L)} and such that μW (cid:4)→ A(?Xi) = ai
for every ?Xi ∈ dom(μW (cid:4)→ A). Then
(8) If P = (P1 BINDINGS W {A1, . . . , Ak}) is a BINDINGS query:

(cid:2)P (cid:3)G = (cid:2)P1(cid:3)G (cid:2)(cid:3) {μW (cid:4)→ A1 , . . . , μW (cid:4)→ Ak}.

Finally, the semantics of SELECT queries is deﬁned as follows. Given a mapping μ :
V → (I ∪ B ∪ L) and a set of variables W ⊆ V , the restriction of μ to W , denoted by
μ|W , is a mapping such that dom(μ|W
(?X) = μ(?X) for
every ?X ∈ (dom(μ) ∩ W ). Then
(9) If P = (SELECT W P1) is a SELECT query, then:

) = (dom(μ) ∩ W ) and μ|W

(cid:2)P (cid:3)G = {μ|W

| μ ∈ (cid:2)P1(cid:3)G}.

4 For the sake of presentation, we use here the two-valued semantics for built-in conditions from
[23], instead of the three-valued semantics including errors used in [26]. It should be noticed
that the results of the paper can be easily extended to this three-valued semantics.

84

M. Arenas and J. P´erez

It is important to notice that the rules (1)–(5), (7) and (9) were introduced in [23], while
rules (6) and (8) were proposed in [7,8] to formalize the semantics for the operators
SERVICE and BINDINGS introduced in [27]. Intuitively, if c ∈ I is the IRI of a
SPARQL endpoint, then the idea behind the deﬁnition of (SERVICE c P1) is to evaluate 
query P1 in the SPARQL endpoint speciﬁed by c. On the other hand, if c ∈ I is
not the IRI of a SPARQL endpoint, then (SERVICE c P1) leaves all the variables in
P1 unbound, as this query cannot be evaluated in this case. This idea is formalized by
making μ∅ the only mapping in the evaluation of (SERVICE c P1) if c (cid:10)∈ dom(ep). In
the same way, (SERVICE ?X P1) is deﬁned by considering that variable ?X is used to
store IRIs of SPARQL endpoints. That is, (SERVICE ?X P1) is deﬁned by assigning
to ?X all the values s in the domain of function ep (in this way, ?X is also used to store
the IRIs from where the values of the variables in P1 are coming from). Finally, the idea
behind the deﬁnition of (P1 BINDINGS W {A1, . . . , Ak}) is to constrain the values
of the variables in W to the values speciﬁed in A1, . . ., Ak.

The goal of the rules (6) and (8) is to deﬁne in an unambiguous way what the result 
of evaluating an expression containing the operators SERVICE and BINDINGS
should be. As such, these rules should not be considered as a straightforward basis for
an implementation of the language. In fact, a direct implementation of the rule (6),
that deﬁnes the semantics of a pattern of the form (SERVICE ?X P1), would involve
evaluating a particular query in every possible SPARQL endpoint, which is obviously
infeasible in practice. In the next section, we face this issue and, in particular, we introduce 
a syntactic condition on SPARQL queries that ensures that a pattern of the form
(SERVICE ?X P1) can be evaluated by only considering a ﬁnite set of SPARQL endpoints,
 whose IRIs are actually taken from the RDF graph where the query is being
evaluated.

3 Federation

As we pointed out in the previous section, the evaluation of a pattern of the form
(SERVICE ?X P ) is infeasible unless the variable ?X is bound to a ﬁnite set of
IRIs. This notion of boundedness is one of the most signiﬁcant and unclear concepts
in the SPARQL federation extension. In fact, since agreement on such a boundedness 
notion could not yet be found, the current version of the speciﬁcation of this
extension [27] does not specify a formalization of the semantics of queries of the
form (SERVICE ?X P ). Here, we present the formalization of this concept proposed
in [7,8], and we study the complexity issues associated with it.

3.1 The Notion of Boundedness

Assume that G is an RDF graph that uses triples of the form (a, service address, b) to
indicate that a SPARQL endpoint with name a is located at the IRI b. Moreover, let P
be the following SPARQL query:

Federation and Navigation in SPARQL 1.1

85

(cid:8)

SELECT {?X, ?N, ?E}

(cid:8)

(cid:9)(cid:9)

(?X, service address, ?Y ) AND (SERVICE ?Y (?N, email, ?E))

.

Query P is used to compute the list of names and email addresses that can be retrieved
from the SPARQL endpoints stored in an RDF graph. In fact, if μ ∈ (cid:2)P (cid:3)G, then μ(?X)
is the name of a SPARQL endpoint stored in G, μ(?N ) is the name of a person stored
in that SPARQL endpoint and μ(?E) is the email address of that person. It is important 
to notice that there is a simple strategy that ensures that query P can be evaluated
in practice: ﬁrst compute (cid:2)(?X, service address, ?Y )(cid:3)G, and then for every μ in this
set, compute (cid:2)(SERVICE a (?N, email, ?E))(cid:3)G with a = μ(?Y ). More generally,
SPARQL pattern (SERVICE ?Y (?N, email, ?E)) can be evaluated over DS in this
case as only a ﬁnite set of values from the domain of G need to be considered as the
possible values of ?Y . This idea naturally gives rise to the following notion of boundedness 
for the variables of a SPARQL query. In the deﬁnition of this notion, dom(G)
refers to the domain of a graph G, that is, the set of elements from (I ∪ B ∪ L) that
are mentioned in G; dom(DS) refers to the union of the domains of all graphs in the
dataset DS; and ﬁnally, dom(P ) refers to the set of elements from (I ∪ L) that are
mentioned in P .
Deﬁnition 1 (Boundedness [7,8]). Let P be a SPARQL query and ?X ∈ var(P ).
Then ?X is bound in P if one of the following conditions holds:

– P is either a graph pattern or a BINDINGS query, and for every dataset DS,
every RDF graph G in DS and every μ ∈ (cid:2)P (cid:3)G: ?X ∈ dom(μ) and μ(?X) ∈
(dom(DS) ∪ names(DS) ∪ dom(P )).

– P is a SELECT query (SELECT W P1) and ?X is bound in P1.

In the evaluation of a graph pattern (GRAPH ?X P ) over a dataset DS, variable ?X
necessarily takes a value from names(DS). Thus, the GRAPH operator makes such
a variable ?X to be bound. Given that the values in names(DS) are not necessarily
mentioned in the dataset DS, the previous deﬁnition ﬁrst imposes the condition that
?X ∈ dom(μ), and then not only considers the case μ(?X) ∈ dom(DS) but also the
case μ(?X) ∈ names(DS). In the same way, the BINDINGS operator can make a
variable ?X in a query P to be bound by assigning to it a ﬁxed set of values. Given
that these values are not necessarily mentioned in the dataset DS where P is being
evaluated, the previous deﬁnition also considers the case μ(?X) ∈ dom(P ). As an
example of the above deﬁnition, we note that variable ?Y is bound in the graph pattern

P1 = ((?X, service address, ?Y ) AND (SERVICE ?Y (?N, email, ?E))),

as for every dataset DS, every RDF graph G in DS and every mapping μ ∈ (cid:2)P1(cid:3)G, we
know that ?Y ∈ dom(μ) and μ(?Y ) ∈ dom(DS). Moreover, we also have that variable
?Y is bound in (SELECT {?X, ?N, ?E} P1) as ?Y is bound in graph pattern P1.

A natural way to ensure that a SPARQL query P can be evaluated in practice is by
imposing the restriction that for every sub-pattern (SERVICE ?X P1) of P , it holds

86

M. Arenas and J. P´erez

that ?X is bound in P . However, the following theorem shows that such a condition is
undecidable and, thus, a SPARQL query engine would not be able to check it in order
to ensure that a query can be evaluated.

Theorem 1 ([7,8]). The problem of verifying, given a SPARQL query P and a variable
?X ∈ var(P ), whether ?X is bound in P is undecidable.
The fact that the notion of boundedness is undecidable prevents one from using it as a
restriction over the variables in SPARQL queries. To overcome this limitation, it was
introduced in [7,8] a syntactic condition that ensures that a variable is bound in a pattern
and that can be efﬁciently veriﬁed.

Deﬁnition 2 (Strong boundedness [7,8]). Let P be a SPARQL query. Then the set of
strongly bound variables in P , denoted by SB(P ), is recursively deﬁned as follows:

– if P = t, where t is a triple pattern, then SB(P ) = var(t);
– if P = (P1 AND P2), then SB(P ) = SB(P1) ∪ SB(P2);
– if P = (P1 UNION P2), then SB(P ) = SB(P1) ∩ SB(P2);
– if P = (P1 OPT P2), then SB(P ) = SB(P1);
– if P = (P1 FILTER R), then SB(P ) = SB(P1);
– if P = (GRAPH c P1), with c ∈ I ∪ V , then

(cid:10)∅
c ∈ I,
SB(P1) ∪ {c} c ∈ V ;
– if P = (SERVICE c P1), with c ∈ I ∪ V , then SB(P ) = ∅;
– if P = (P1 BINDINGS W {A1, . . . , An}), then

SB(P ) =

SB(P ) = SB(P1) ∪

{?X | ?X is included in W and for
every i ∈ {1, . . . , n} : ?X ∈ dom(μW (cid:4)→Ai)};

– if P = (SELECT W P1), then SB(P ) = (W ∩ SB(P1)).
The previous deﬁnition recursively collects from a SPARQL query P a set of variables 
that are guaranteed to be bound in P . For example, if P is a triple pattern t, then
SB(P ) = var(t) as one knows that for every variable ?X ∈ var(t), every dataset DS
and every RDF graph G in DS, if μ ∈ (cid:2)t(cid:3)G, then ?X ∈ dom(μ) and μ(?X) ∈ dom(G)
(which is a subset of dom(DS)). In the same way, if P = (P1 AND P2), then SB(P ) =
SB(P1) ∪ SB(P2) as one knows that if ?X is bound in P1 or in P2, then ?X is bound
in P . As a ﬁnal example, notice that if P = (P1 BINDINGS W {A1, . . . , An})
and ?X is a variable mentioned in W such that ?X ∈ dom(μW (cid:4)→Ai) for every
i ∈ {1, . . . , n}, then ?X ∈ SB(P ). In this case, one knows that ?X is bound in P since
(cid:2)P (cid:3)G = (cid:2)P1(cid:3)G (cid:2)(cid:3) {μW(cid:4)→A1 , . . . , μW (cid:4)→An} and ?X is in the domain of each one of
the mappings μW (cid:4)→Ai, which implies that μ(?X) ∈ dom(P ) for every μ ∈ (cid:2)P (cid:3)G. In
the following proposition, it is formally shown that our intuition about SB(P ) is correct,
in the sense that every variable in this set is bound in P .

Federation and Navigation in SPARQL 1.1

87
Proposition 1 ([7,8]). For every SPARQL query P and variable ?X ∈ var(P ), if
?X ∈ SB(P ), then ?X is bound in P .
Given a SPARQL query P and a variable ?X ∈ var(P ), it can be efﬁciently veriﬁed
whether ?X is strongly bound in P . Thus, a natural and efﬁciently veriﬁable way to ensure 
that a SPARQL query P can be evaluated in practice is by imposing the restriction
that for every sub-pattern (SERVICE ?X P1) of P , it holds that ?X is strongly bound
in P . However, this notion still needs to be modiﬁed in order to be useful in practice, as
shown by the following examples.

Example 1. Assume ﬁrst that P1 is the following graph pattern:

(cid:11)
(?X, service description, ?Z) UNION

P1 =

(cid:8)

(?X, service address, ?Y ) AND

(SERVICE ?Y (?N, email, ?E))

.

(cid:9)(cid:12)

That is, either ?X and ?Z store the name of a SPARQL endpoint and a description
of its functionalities, or ?X and ?Y store the name of a SPARQL endpoint and the
IRI where it is located (together with a list of names and email addresses retrieved
from that location). Variable ?Y is neither bound nor strongly bound in P1. However,
 there is a simple strategy that ensures that P1 can be evaluated over a dataset
DS and an RDF graph G in DS: ﬁrst compute (cid:2)(?X, service description, ?Z)(cid:3)G, then
compute (cid:2)(?X, service address, ?Y )(cid:3)G, and ﬁnally for every μ in the set of mappings
(cid:2)(?X, service address, ?Y )(cid:3)G, compute (cid:2)(SERVICE a (?N, email, ?E))(cid:3)G with a =
μ(?Y ). In fact, the reason why P1 can be evaluated in this case is that ?Y is bound (and
strongly bound) in the following sub-pattern of P1:

((?X, service address, ?Y ) AND (SERVICE ?Y (?N, email, ?E))).

As a second example, assume that DS is a dataset and G is an RDF graph in DS that
uses triples of the form (a1, related with, a2) to indicate that the SPARQL endpoints located 
at the IRIs a1 and a2 store related data. Moreover, assume that P2 is the following
graph pattern:

(cid:11)

P2 =

(?U1, related with, ?U2) AND
(cid:8)

(cid:8)

SERVICE ?U1

(?N, email, ?E) OPT

(SERVICE ?U2 (?N, phone, ?F ))

.

(cid:9)(cid:9)(cid:12)

When this query is evaluated over the dataset DS and the RDF graph G in DS, it
returns for every tuple (a1, related with, a2) in G, the list of names and email addresses

88

M. Arenas and J. P´erez

that that can be retrieved from the SPARQL endpoint located at a1, together with the
phone number for each person in this list for which this data can be retrieved from the
SPARQL endpoint located at a2 (recall that pattern (SERVICE ?U2 (?N, phone, ?F ))
is nested inside the ﬁrst SERVICE operator in P2). To evaluate this query over an RDF
graph, ﬁrst it is necessary to determine the possible values for variable ?U1, and then
to submit the query ((?N, email, ?E) OPT (SERVICE ?U2 (?N, phone, ?F ))) to each
one of the endpoints located at the IRIs stored in ?U1. In this case, variable ?U2 is
bound (and also strongly bound) in P2. However, this variable is not bound in the graph
pattern ((?N, email, ?E) OPT (SERVICE ?U2 (?N, phone, ?F ))), which has to be
evaluated in some of the SPARQL endpoints stored in the RDF graph where P2 is
being evaluated, something that is infeasible in practice. It is important to notice that
the difﬁculties in evaluating P2 are caused by the nesting of SERVICE operators (more
precisely, by the fact that P2 has a sub-pattern of the form (SERVICE ?X1 Q1), where
Q1 has in turn a sub-pattern of the form (SERVICE ?X2 Q2) such that ?X2 is bound
(cid:15)(cid:16)
in P2 but not in Q1).

In the following section, the concept of strongly boundedness is used to deﬁne a notion
that ensures that a SPARQL query containing the SERVICE operator can be evaluated 
in practice, and which takes into consideration the ideas presented in the above
examples.

3.2 The Notion of Service-Safeness: Considering Sub-Patterns and Nested

SERVICE Operators

The goal of this section is to provide a condition that ensures that a SPARQL query containing 
the SERVICE operator can be safely evaluated in practice. To this end, we ﬁrst
need to introduce some terminology. Given a SPARQL query P , deﬁne T (P ) as the
parse tree of P . In this tree, every node corresponds to a sub-pattern of P . An example
of a parse tree of a pattern Q is shown in Figure 1. In this ﬁgure, u1, u2, u3, u4, u5, u6
are the identiﬁers of the nodes of the tree, which are labeled with the sub-patterns of
Q. It is important to notice that in this tree we do not make any distinction between the

u1 : ((?Y, a, ?Z) UNION ((?X, b, c) AND (SERVICE ?X (?Y, a, ?Z))))

u2 : (?Y, a, ?Z)

u3 : ((?X, b, c) AND (SERVICE ?X (?Y, a, ?Z)))

u4 : (?X, b, c)

u5 : (SERVICE ?X (?Y, a, ?Z))

u6 : (?Y, a, ?Z)

Fig. 1. Parse tree T (Q) for the graph pattern Q = ((?Y, a, ?Z) UNION ((?X, b, c)
AND (SERVICE ?X (?Y, a, ?Z))))

Federation and Navigation in SPARQL 1.1

89

different operators in SPARQL, we just use the child relation to store the structure of
the sub-patterns of a SPARQL query.
Tree T (P ) is used to deﬁne the notion of service-boundedness, which extends the
concept of boundedness, introduced in the previous section, to consider variables that
are bound inside sub-patterns and nested SERVICE operators. It should be noticed that
these two features were identiﬁed in the previous section as important for the deﬁnition
of a notion of boundedness (see Example 1).

Deﬁnition 3 (Service-boundedness [7,8]). A SPARQL query P is service-bound if
for every node u of T (P ) with label (SERVICE ?X P1), it holds that:
(1) there exists a node v of T (P ) with label P2 such that v is an ancestor of u in T (P )

and ?X is bound in P2;

(2) P1 is service-bound.

For example, query Q in Figure 1 is service-bound. In fact, condition (1) of Deﬁnition 3
is satisﬁed as u5 is the only node in T (Q) having as label a SERVICE graph pattern, in
this case (SERVICE ?X (?Y, a, ?Z)), and for the node u3, it holds that: u3 is an ancestor 
of u5 in T (P ), the label of u3 is P = ((?X, b, c) AND (SERVICE ?X (?Y, a, ?Z)))
and ?X is bound in P . Moreover, condition (2) of Deﬁnition 3 is satisﬁed as the subpattern 
(?Y, a, ?Z) of the label of u5 is also service-bound.

The notion of service-boundedness captures our intuition about the condition that a
SPARQL query containing the SERVICE operator should satisfy. Unfortunately, the
following theorem shows that such a condition is undecidable and, thus, a SPARQL
query engine would not be able to check it in order to ensure that a query can be evaluated.


Theorem 2 ([7,8]). The problem of verifying, given a SPARQL query P , whether P is
service-bound is undecidable.

As for the case of the notion of boundedness, the fact that the notion of serviceboundedness 
is undecidable prevents one from using it as a restriction over the
variables used in SERVICE calls. To overcome this limitation, in the deﬁnition of
service-boundedness, the restriction that the variables used in SERVICE calls are
bound is replaced by the decidable restriction that they are strongly bound. In this
way, one obtains a syntactic condition over SPARQL queries that ensures that they
are service-bound, and which can be efﬁciently veriﬁed.

Deﬁnition 4 (Service-safeness [7,8]). A SPARQL query P is service-safe if for every
node u of T (P ) with label (SERVICE ?X P1), it holds that:
(1) there exists a node v of T (P ) with label P2 such that v is an ancestor of u in T (P )

and ?X ∈ SB(P2);
(2) P1 is service-safe.

As a corollary of Proposition 1, one obtains the following proposition.

Proposition 2 ([7,8]). If a SPARQL query P is service-safe, then P is service-bound.

90

M. Arenas and J. P´erez

The notion of service-safeness is used in the system presented in [7,8] to verify that a
SPARQL query can be evaluated in practice. More precisely, that system uses a bottomup 
algorithm over the parse tree T (Q) of a SPARQL query Q for validating the servicesafeness 
condition. This procedure traverses the parse tree T (Q) twice for ensuring
that Q can be correctly evaluated. In the ﬁrst traversal, for each node identiﬁer u of
T (Q), the algorithm computes the set of strongly bound variables for the label P of
u. For example, in the parse tree shown in Figure 1, the variable ?X is identiﬁed as
the only strongly bound variable for the label of the node with identiﬁer u3. In the
second traversal, the bottom-up algorithm uses these sets of strongly bound variables
to check two conditions for every node identiﬁer u of T (Q) with label of the form
(SERVICE ?X P ): whether there exists a node v of T (Q) with label P
such that v
is an ancestor of u in T (Q) and ?X is strongly bound in P
, and whether P is itself
service-safe. If these two conditions are fulﬁlled, then the algorithm returns true to
indicate that Q is service-safe. Otherwise, the procedure returns no.

(cid:3)

(cid:3)

4 Navigation

Navigational features have been largely recognized as fundamental for graph database
query languages. This fact has motivated several authors to propose RDF query languages 
with navigational capabilities [22,1,18,4,2], and, in fact, it was the motivation
to include the property-path feature in the upcoming version of the SPARQL standard,
SPARQL 1.1 [16]. Property paths are essentially regular expressions, that are used to
retrieve pairs of nodes from an RDF graph if they are connected by paths conforming
to those expressions. In the following two sections, we introduce the syntax of property 
paths, and some of the main results on the semantics and complexity of these
expressions.

We focus on the semantics for property paths presented in the last published version
of the speciﬁcation [16] (January 2012), and that has been considered as the semantics
for property paths since early stages of the standardization process (ﬁrst introduced in
October 2010). As a disclaimer, it should be noticed that recently (beginning of 2012),
the normative semantics of property paths is being heavily discussed in the W3C mailing 
lists [38], and, thus, this semantics will probably change in the future. This discussion 
was initiated by two recently published articles on this subject [5,19], which show
some efﬁciency problems in the original design of property paths. Thus, although this
design may change, from a pedagogical point of view, as well as from a historical point
of view, it is important and interesting to present the semantics that have lasted for more
than a year as the ofﬁcial semantics of property paths, the rationale behind its deﬁnition
and its main features, and the issues that may lead to its replacement in the near future.
The normative semantics of property paths in SPARQL 1.1 poses several interesting 
research issues. Although property paths are syntactically nothing else but classical
regular expressions, SPARQL 1.1 deﬁnes a bag (or multiset) semantics for these expressions.
 That is, when evaluating property-path expressions, one can obtain several
duplicates for the same solution, essentially one duplicate for every different path in
the graph satisfying the expression. Since RDF graphs containing cycles may lead to
an inﬁnite number of paths satisfying a particular expression, the ofﬁcial speciﬁcation

Federation and Navigation in SPARQL 1.1

91

deﬁnes the semantics of property paths by means of a particular counting procedure,
which handles cycles in a way that ensures that the ﬁnal count is ﬁnite. In this section,
we consider the formalization of this procedure that was presented in [5].

In order to formally introduce the semantics of property paths, we ﬁrst formalize the
bag semantics of SPARQL operators in Section 4.1. Then based on this formalization,
we introduce in Section 4.2, the semantics of property paths in SPARQL 1.1.

4.1 Bag Semantics for SPARQL 1.1

In this section, we introduce a bag (or multiset) semantics for SPARQL, that is, the evaluation 
of a query is deﬁned as a set of mappings in which every element μ is annotated
with a positive integer that represents the cardinality of μ in the bag. As we will see,
cardinality of solutions is a crucial part of the normative semantics of property paths in
SPARQL 1.1 [16].

Formally, we represent a bag of mappings as a pair (Ω, cardΩ), where Ω is a set
of mappings and cardΩ is a function such that cardΩ(μ) is the cardinality of μ in
Ω (we assume that cardΩ(μ) > 0 for every μ ∈ Ω, and cardΩ(μ
(cid:3)) = 0 for every
(cid:3) (cid:10)∈ Ω). With this notion, we have the necessary ingredients to deﬁne the semantics
μ
of SPARQL 1.1 queries. For the sake of readability, we repeat here the deﬁnitions presented 
in Section 2.2 but now including the computation of cardinalities. Since our main
focus in this section are the navigational features in SPARQL 1.1, we do not consider
GRAPH and SERVICE operators. Thus, we focus on points (1), (2), (3), (4), and (7)
presented in Section 2.2. More precisely, let G be an RDF graph and P a graph pattern:
(1) If P is a triple pattern t, then (cid:2)P (cid:3)G = {μ | dom(μ) = var(t) and μ(t) ∈ G}.
(2) If P is (P1 AND P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G (cid:2)(cid:3) (cid:2)P2(cid:3)G. Moreover, for every μ ∈

Moreover, for every μ ∈ (cid:2)P (cid:3)G, it holds that card(cid:2)P (cid:3)G

(μ) = 1.

(cid:2)P (cid:3)G we have that card(cid:2)P (cid:3)G

(μ) is given by the expression:

(cid:13)

⎡

⎣

(cid:13)

μ1∈(cid:2)P1(cid:3)G

μ2∈(cid:2)P2(cid:3)G : μ=μ1∪μ2

(cid:8)

card(cid:2)P1(cid:3)G

(μ1) · card(cid:2)P2(cid:3)G

⎤

(cid:9)

(μ2)

⎦ .

(3) If P is (P1 OPT P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G
(cid:2)P (cid:3)G, if μ ∈ (cid:2)(P1 AND P2)(cid:3)G, then card(cid:2)P (cid:3)G
if μ (cid:10)∈ (cid:2)(P1 AND P2)(cid:3)G, then card(cid:2)P (cid:3)G

(μ) = card(cid:2)P1(cid:3)G

(μ).

(cid:2)P2(cid:3)G. Moreover, for every μ ∈
(μ), and
(μ) = card(cid:2)(P1 AND P2)(cid:3)G

(4) If P is (P1 UNION P2), then (cid:2)P (cid:3)G = (cid:2)P1(cid:3)G ∪ (cid:2)P2(cid:3)G. Moreover, for every μ ∈

(cid:2)P (cid:3)G, it holds that card(cid:2)P (cid:3)G

(μ) = card(cid:2)P1(cid:3)G

(μ) + card(cid:2)P2(cid:3)G

(μ).

The evaluation of a SPARQL 1.1 query Q over an RDF graph G, denoted by (cid:2)Q(cid:3)G,
is deﬁned as follows. If Q is a SPARQL 1.1 query (SELECT W P ), then (cid:2)Q(cid:3)G =
{μ|W

| μ ∈ (cid:2)P (cid:3)G} and for every μ ∈ (cid:2)Q(cid:3)G:

card(cid:2)Q(cid:3)G

(μ) =

(cid:13)

μ(cid:2)∈(cid:2)P (cid:3)G : μ=μ
(cid:2)
|W

card(cid:2)P (cid:3)G

(μ

(cid:3)).

92

M. Arenas and J. P´erez

(μ) = card(cid:2)P (cid:3)G

then (cid:2)Q(cid:3)G = (cid:2)P (cid:3)G and
If Q is a SPARQL 1.1 query (SELECT * P ),
(μ) for every μ ∈ (cid:2)Q(cid:3)G. If Q is a SPARQL 1.1 query
card(cid:2)Q(cid:3)G
(SELECT DISTINCT W P ), then (cid:2)Q(cid:3)G = {μ|W
| μ ∈ (cid:2)P (cid:3)G} and for every
μ ∈ (cid:2)Q(cid:3)G, we have that card(cid:2)Q(cid:3)G
(μ) = 1. Finally, if Q is a SPARQL 1.1 query
(SELECT DISTINCT * P ), then (cid:2)Q(cid:3)G = (cid:2)P (cid:3)G and for every μ ∈ (cid:2)Q(cid:3)G, we have
that card(cid:2)Q(cid:3)G

(μ) = 1.

To conclude the deﬁnition of the semantics of SPARQL 1.1, we need to deﬁne the
semantics of ﬁlter expressions. Given an RDF graph G and a graph pattern expression
P = (P1 FILTER R), we have that (cid:2)P (cid:3)G = {μ ∈ (cid:2)P1(cid:3)G | μ |= R}, and for every
μ ∈ (cid:2)P (cid:3)G, we have that card(cid:2)P (cid:3)G

(μ) = card(cid:2)P1(cid:3)G

(μ).

4.2 Syntax and Semantics of SPARQL 1.1 Property Paths

In this section, we use the framework presented in the previous section to formalize the
semantics of property paths. According to [16], a property paths is recursively deﬁned
as follows: (1) if a ∈ I, then a is a property path, and (2) if p1 and p2 are property
paths, then p1|p2, p1/p2 and p
∗
1 are property paths. Thus, from a syntactical point of
view, property paths are regular expressions over the vocabulary I, being | disjunction,
/ concatenation and ( )∗
the Kleene star. It should be noticed that the deﬁnition of
property paths in [16] includes some additional features that are common in regular
expressions, such as p? (zero or one occurrences of p) and p+ (one or more occurrences
of p). In this paper, we focus on the core operators |, / and ( )∗
, as they sufﬁce to prove
the infeasibility of the evaluation of property paths in SPARQL 1.1.
A property-path triple is a tuple t of the form (u, p, v), where u, v ∈ (I ∪ V ) and p is
a property path. SPARQL 1.1 includes as atomic formulas triple patterns and propertypath 
triples. Thus, to complete the deﬁnition of the semantics of SPARQL 1.1, we need
to specify how property-path triples are evaluated over RDF graphs, that is, we need to
extend the deﬁnition of the function (cid:2)·(cid:3)G to include property-path triples.
To deﬁne the semantics of property-path triples, we follow closely the standard speciﬁcation 
[16]. Assume that u, v ∈ (I ∪ V ), W = ({u, v} ∩ V ) and p is a property
path. Notice that if u, v ∈ I, then W = ∅. Then the evaluation of property-path
triple t = (u, p, v) over an RDF graph G, denoted by (cid:2)t(cid:3)G, is deﬁned recursively
as follows. If p = a, where a ∈ I, then (u, p, v) is a triple pattern and (cid:2)t(cid:3)G and
(·) are deﬁned as in Section 4.1. Otherwise, we have that either p = p1|p2 or
card(cid:2)t(cid:3)G
∗
p = p1/p2 or p = p
1, where p1, p2 are property paths, and (cid:2)t(cid:3)G is deﬁned as follows.
First, if p = p1|p2, then (cid:2)t(cid:3)G is deﬁned in [16] as the result of evaluating the pattern
((u, p1, v) UNION (u, p2, v)) over G. Thus, we have that:

(cid:2)t(cid:3)G = {μ | μ ∈ (cid:2)(u, p1, v)(cid:3)G or μ ∈ (cid:2)(u, p2, v)(cid:3)G},

and for every μ ∈ (cid:2)t(cid:3)G, we have that:

card(cid:2)t(cid:3)G

(μ) = card(cid:2)(u,p1,v)(cid:3)G

(μ) + card(cid:2)(u,p2,v)(cid:3)G

(μ).

Second, if p = p1/p2, then assuming that ?X is a variable such that ?X (cid:10)∈ W , we have
that (cid:2)t(cid:3)G is deﬁned in [16] as the result of ﬁrst evaluating the pattern ((u, p1, ?X) AND

Federation and Navigation in SPARQL 1.1

93

(?X, p2, v)) over G, and then projecting over the variables of property-path triple t (and,
thus, projecting out the variable ?X). Thus, we have that:
(cid:2)t(cid:3)G = {(μ1∪μ2)|W
and for every μ ∈ (cid:2)t(cid:3)G, we have that:

| μ1 ∈ (cid:2)(u, p1, ?X)(cid:3)G, μ2 ∈ (cid:2)(?X, p2, v)(cid:3)G and μ1 ∼ μ2},

card(cid:2)t(cid:3)G

(μ) =
(cid:2)

(cid:3) (cid:2)

(cid:4)

μ1∈(cid:2)(u,p1,?X)(cid:3)G

μ2∈(cid:2)(?X,p2,v)(cid:3)G
μ=(μ1∪μ2)|W

card(cid:2)(u,p1,?X)(cid:3)G

(μ1) · card(cid:2)(?X,p2,v)(cid:3)G

(μ2)

(cid:5)(cid:6)
.

Finally, if p = p
ALP shown in Figure 2. More precisely,

∗
1, then (cid:2)t(cid:3)G is deﬁned in [16] in terms of the procedures COUNT and

(cid:2)t(cid:3)G = {μ | dom(μ) = W and COUNT(μ(u), p1, μ(v), G) > 0}.

Moreover, for every μ ∈ (cid:2)t(cid:3)G, it holds that

card(cid:2)t(cid:3)G

(μ) = COUNT(μ(u), p1, μ(v), G).

Procedure ALP in Figure 2 is taken from [16]. It is important to notice that lines 5
and 6 in ALP formalize, in our terminology, the use of a procedure call eval in the

Function COUNT(a, path, b, G)
Input: a, b ∈ I, path is a property path and G is an RDF graph.
1: Result := empty list
2: Visited := empty set
3: ALP(a, path, Result, Visited, G)
4: n := number of occurrences of b in Result
5: return n

Procedure ALP(a, path, Result, Visited, G)
Input: a ∈ I, path is a property path, Result is a list of elements from I, Visited is a set of
elements from I and G is an RDF graph.
1: if a ∈ Visited then
2:
3: end if
4: add a to Visited, and add a to Result
5: Ω := (cid:2)(a, path, ?X)(cid:3)G
6: let Next be the list of elements b = μ(?X) for μ ∈ Ω, such that the number of occurrences
7: for each c ∈ Next do
8:
9: end for
10: remove a from Visited

ALP(c, path, Result, Visited, G)

return

of b in Next is cardΩ(μ)

Fig. 2. Procedures used in the evaluation of property-path triples of the form (u, path

∗, v)

94

M. Arenas and J. P´erez

(μ), where t = (u, p

deﬁnition of ALP in [16]. According to [16], procedure ALP has to be used as follows
∗
to compute card(cid:2)t(cid:3)G
1, v). Assuming that Result is the empty list
and Visited is the empty set, ﬁrst one has to invoke ALP(μ(u), p, Result, Visited, G),
then one has to check whether μ(v) appears in the resulting list Result, and if this is the
(μ) is set as the number of occurrences of μ(v) in the list Result. For
case then card(cid:2)t(cid:3)G
the sake of readability, we have encapsulated in the auxiliary procedure COUNT these
steps to compute card(cid:2)t(cid:3)G
(μ) from procedure ALP, and we have deﬁned (cid:2)t(cid:3)G by using
COUNT, thus formalizing the semantics proposed by the W3C in [16].

The idea behind algorithm ALP is to incrementally construct paths that conform to a
∗
1, that is, to construct sequences of nodes a1, a2, . . ., an from
property path of the form p
an RDF graph G such that each node ai+1 is reachable from ai in G by following the
path p1, but with the important feature (implemented through the use of the set Visited)
that each node ai is distinct from all the previous nodes aj selected in the sequence
(thus avoiding cycles in the sequence a1, a2, . . ., an).

5 The Complexity of Evaluating Property-Path SPARQL Queries

In this section, we show some of the results presented in [5,19] on the complexity of
evaluating property paths according to the semantics proposed by the W3C, as well
as several other alternative semantics. We ﬁrst present in Section 5.1 an experimental
study on the impact of counting property paths. As observed in [5,19], current implementations 
of SPARQL 1.1 show a strikingly poor performance when evaluating even
the most simple queries. Then in Section 5.2, the computational complexity of the evaluation 
problem for property paths is studied, providing a formal explanation on the
poor performance of the implementations. Later in Section 5.3, we present some alternative 
semantics for property paths based on more classical ways of navigating graph
databases. Finally, in Section 5.4, we show some results stating that when repeated solutions 
are not considered, then one can obtain efﬁcient evaluation methods for property
paths.

5.1 Experimental Evaluation

This section is based on the experimental study performed in [5]. The idea is to provide 
the reader with a sense of the practical impact in query evaluation of using property 
paths, by comparing the performance of several important implementations of
SPARQL.

The SPARQL 1.1 engines considered in the evaluation are the following [5]:

– ARQ – version 2.8.8, 21 April 2011 [33]: ARQ is a java implementation of

SPARQL for the Jena Semantic Web Framework [10].

– RDF::Query – version 2.907, 1 June 2011 [35]: RDF::Query is a perl module that

implements SPARQL 1.1.

– KGRAM – version 3.0, September 2011 [34]: KGRAM is an implementation of an
abstract machine that uniﬁes graph match and SPARQL 1.1 [11]. The engine is accessed 
via the Corese (COnceptual REsource Search Engine) libraries implemented
in java.

Federation and Navigation in SPARQL 1.1

95

@prefix : <http://example.org/> .
:a0 :p :a1, :a2, :a3, :a4, :a5, :a6, :a7 .
:a1 :p :a0, :a2, :a3, :a4, :a5, :a6, :a7 .
:a2 :p :a0, :a1, :a3, :a4, :a5, :a6, :a7 .
:a3 :p :a0, :a1, :a2, :a4, :a5, :a6, :a7 .
:a4 :p :a0, :a1, :a2, :a3, :a5, :a6, :a7 .
:a5 :p :a0, :a1, :a2, :a3, :a4, :a6, :a7 .
:a6 :p :a0, :a1, :a2, :a3, :a4, :a5, :a7 .
:a7 :p :a0, :a1, :a2, :a3, :a4, :a5, :a6 .

Fig. 3. RDF graph representing a clique with 8 nodes

– Sesame – version 2.5.1, 23 September 2011 [36]: Sesame is a framework for processing 
RDF data implemented in java, and provides a set of libraries to access data
and execute SPARQL 1.1 queries.

The tests were run in a dedicated machine with the following conﬁguration: Debian
6.0.2 Operating System, Kernel 2.6.32, CPU Intel Xeon X3220 Quadcore with
2.40GHz, and 4GB PC2-5300 RAM. All tests were run considering main memory storage.
 This should not be considered as a problem since the maximum size of the input
RDF graphs that we used was only 25.8 KB. A timeout of 60 minutes was considered.
For each test, the number reported is the average of the results obtained by executing
the test (at least) 4 times. No experiment showed a signiﬁcant standard deviation [5].

The Clique Experiment. The ﬁrst experiment reported in [5] considered cliques (complete 
graphs) of different sizes, from a clique with 2 nodes (containing 2 triples) to a
clique with 13 nodes (156 triples). For example, a clique with 8 nodes in N3 notation is
shown in Figure 3. The ﬁrst query to be tested, is the following query

Cliq-1: SELECT * WHERE { :a0 (:p)* :a1 }.

This query essentially tests if the nodes :a0 and :a1 are connected. Since this query has
no variables, the solution is an empty tuple, which, for example, in ARQ is represented
|, and in Sesame by the string [] (when the query solution is printed
by the string |
to the standard output). RDF::Query does not support queries without variables, thus
for this implementation the following query was tested:

CliqF-1: SELECT * WHERE { :a0 (:p)* ?x

FILTER (?x = :a1) }.

Table 1 shows the result obtained for this experiment in terms of the time (in seconds)
and the number of solutions produced as output, when the input is a clique with n nodes.
The symbol “–” in the table means timeout of one hour. Figure 4 shows a plot of the
same data.

The impact of using nested stars was also tested [5]. In particular, the following

queries were tested:

Cliq-2: SELECT * WHERE { :a0 ((:p)*)* :a1 }
Cliq-3: SELECT * WHERE { :a0 (((:p)*)*)* :a1 }

For these expressions containing nested stars, Sesame produces a run-time error (we
have reported this bug in the Sesame’s mailing list), and KGRAM does not produce

96

M. Arenas and J. P´erez

Table 1. Time in seconds and number of solutions for query Cliq-1 (CliqF-1 for RDF::Query)

n
ARQ RDFQ Kgram Sesame Solutions
0.90
16
1.18
5
0.76
0.57
1.44
65
1.19
1.24
0.60
6
5.09
1.37
326
2.36
0.95
7
1,957
1.73
34.01
1.38
9.09
8
13,700
2.31 295.88
5.38 165.28
9
109,601
4.15 2899.41 228.68
–
10
31.21
–
986,410
–
11
– 9,864,101
–
12 1422.30
–
–
–
–
13

–
–
–

1000

100

10

1

×
(cid:2)
+ + + + + +
∗
× × × ×
(cid:2) (cid:2) (cid:2) (cid:2)
∗
∗
2

×
(cid:2)
∗
6

∗

∗
4

+

ARQ
RDFQ
KGram
Sesame

+
×
∗
(cid:2)

×

∗

+

×
(cid:2)

∗

+

+

10

12

14

16

×

(cid:2)

∗
+

8

Fig. 4. Time in seconds for processing Cliq-1 w.r.t. the clique size n (time axis in log-scale)

the expected output according to the ofﬁcial SPARQL 1.1 speciﬁcation [16]. Thus, for
these cases it is only meaningful to test ARQ and RDF::Query (we use FILTER for
RDF::Query, as we did for the case of query CliqF-1). The results are shown in Table 2.
As described in [5], the experimental results show the infeasibility of evaluating
property paths including the star operator in the the four tested implementations. We
emphasize only here the unexpected impact of nesting stars: for query Cliq-3 both implementations 
tested fail for an RDF graph representing a clique with only 4 nodes,
which contains only 12 triples and has a size of 126 bytes in N3 notation. Although
in this example the nesting of the star operator does not seem to be natural, it is well
known that nesting is indeed necessary to represent some regular languages [13]. It is
also notable how the number of solutions increase w.r.t. the input size. For instance, for
query Cliq-1, ARQ returns more than 9 million solutions for a clique with 12 nodes
(ARQ’s output in this case has more than 9 million lines containing the string | |).
We show in Section 5 that the duplication of solutions is indeed the main source of
complexity when evaluating property paths.

The Foaf Experiment. The second experiment presented in [5] use real data
crawled from the Web. It considered the foaf:knows property, as it has been used as

Table 2. Time in seconds and number of solutions for queries Cliq-2 (left) and Cliq-3 (right)

Federation and Navigation in SPARQL 1.1

97

n ARQ RDFQ Solutions
1
2
6
3
305
4
418,576
5 97.06
–
–
6

0.76
1.40
1.19
0.84
1.65 19.38
–
–

n ARQ RDFQ Solutions
1
2 1.20
42
3 1.42
4
–
–

0.77
6.85
–

a paradigmatic property for examples regarding path queries (notice that it is in several
of the examples used to describe property paths in the ofﬁcial SPARQL 1.1 speciﬁcation 
[16]).

The dataset for this experiment is constructed using the SemWeb Client Library [40],
which is part of the Named Graph API for Jena. This library provides a command-line
tool semwebquery that can be used to query the Web of Linked Data. The tool receives
as input a SPARQL query Q, an integer value k and a URI u. When executed, it ﬁrst
retrieves the data from u, evaluates Q over this data, and follows the URIs mentioned
in it to obtain more data. This process is repeated k times (see [17] for a description
of this query approach). The data is constructed by using a CONSTRUCT query to retrieve 
URIs linked by foaf:knows properties with Axel Polleres’ foaf document as
the starting URI5. The parameter k was set as 3, which already produce a ﬁle of 1.5MB
containing more than 33,000 triples. To obtain a ﬁle of reasonable size, the data was
ﬁltered by removing all triples that mention URIs from large Social Networks sites (in
particular, URIs from MyOpera.com and SemanticTweet.com were removed), and then
the strongly connected component to which Axel Polleres’ URI belongs was extracted,
obtaining a ﬁle of 25.8 KB. From this ﬁle, the authors constructed several test cases
by deleting subsets of nodes and then recomputing the strongly connected component.
With this process 8 different test cases from 9.2 KB to 25.8 KB were constructed. The
descriptions of these ﬁles are shown in Table 3. Just as an example of the construction 
process, ﬁle D is constructed from ﬁle E by deleting the node corresponding to
Richard Cyganiack’s URI, and then computing the strongly connected component to
which Axel’s URI belong.

The following query is used in this experiment:

Foaf-1: SELECT * WHERE { axel:me (foaf:knows)* ?x }.

which asks for the network of friends of Axel Polleres. Since the graphs in the test
cases are strongly connected, this query retrieves all the nodes in the graph (possibly
with duplicates). The time to process the query, the number of solutions produced, and
the size of the output produced by ARQ are shown in Table 4 (ﬁle E is the last ﬁle
shown in the table, as all implementations exceed the timeout limit for the larger ﬁles).
As for the case of the clique experiment, one of the most notable phenomenon is the
large increase in the output size.

5 http://www.polleres.net/foaf.rdf

98

M. Arenas and J. P´erez

Table 3. Description of the ﬁles (name, number of nodes, number of RDF triples, and size in
disk) used in the foaf experiment

File #nodes #triples size (N3 format)
A
B
C
D
E
F
G
H

9.2KB
10.9KB
11.4KB
13.2KB
14.8KB
17.2KB
20.5KB
25.8KB

119
143
150
176
201
237
281
360

38
43
47
52
54
57
68
76

Table 4. Time in seconds, number of solutions, and output size for query Foaf-1

File ARQ RDFQ Kgram Sesame Solutions Size (ARQ)
5.13 75.70 313.37
A
2MB
–
8.20 325.83
8.4MB
B
120MB
–
–
65.87
C
587MB
–
–
D 292.43
–
–
–
–
E

29,817
–
–
122,631
– 1,739,331
– 8,511,943
–
–

5.2 Intractability of SPARQL 1.1 in the Presence of Property Paths

In this section, we study the computational complexity of the problem of evaluating
SPARQL 1.1 queries containing property paths. Speciﬁcally, we study the complexity
(·), as this computation embodies the main task
of computing the function card(cid:2)t(cid:3)G
needed to evaluate a property-path triple. For the sake of readability, we focus here on
computing such functions for property-path triples of the form (a, p, b) where a, b ∈
I. Notice that this is not a restriction, as for every property path triple t and every
mapping μ whose domain is equal to the set of variables mentioned in t, it holds that
(μ∅) (recall that μ∅ is the mapping with empty domain).
card(cid:2)t(cid:3)G
Thus, we study the following counting problem:

(μ) = card(cid:2)μ(t)(cid:3)G

PROBLEM : COUNTW3C

INPUT : an RDF graph G, elements a, b ∈ I and a property path p
OUTPUT : card(cid:2)(a,p,b)(cid:3)G

(μ∅).

It is important to notice that property paths are part of the input of the previous problem
and, thus, we are formalizing the combined complexity of the evaluation problem [31].
As it has been observed in many scenarios, and, in particular, in the context of evalu-
(·), it is natural to
ating SPARQL [24], when computing a function like card(cid:2)(a,p,b)(cid:3)G
assume that the size of p is considerably smaller than the size of G. This assumption is
very common when studying the complexity of a query language. In fact, it is named

Federation and Navigation in SPARQL 1.1

99

data complexity in the database literature [31], and it is deﬁned in our context as the
(·) for a ﬁxed property-path p. More precisely,
complexity of computing card(cid:2)(a,p,b)(cid:3)G
assume given a ﬁxed property path p, and consider the following counting problem:

PROBLEM : COUNTW3C(p)

INPUT : an RDF graph G, elements a, b ∈ I
OUTPUT : card(cid:2)(a,p,b)(cid:3)G

(μ∅).

To pinpoint the complexity of COUNTW3C and COUNTW3C(p), where p is a property
path, we need to consider the complexity class #P (we refer the reader to [30] for its
formal deﬁnition). A function f is said to be in #P if there exists a non-deterministic
Turing Machine M that works in polynomial time such that for every string w, the value
of f on w is equal to the number of accepting runs of M with input w. A prototypical 
#P-complete problem is the problem of computing, given a propositional formula
ϕ, the number of truth assignments satisfying ϕ. Clearly #P is a class of intractable
computation problems [30].

In [5], the authors prove the following complexity result stating the intractability of

property path evaluation.

Theorem 3 ([5]). The problem COUNTW3C(p) is in #P for every property path p.
Besides, COUNTW3C(c

∗) is #P-complete, where c ∈ I.

Theorem 3 shows that the problem of evaluating property paths under the semantics
proposed by the W3C is intractable in data complexity. In fact, it shows that one will
not be able to ﬁnd efﬁcient algorithms to evaluate even simple property paths such as
∗
c

, where c is an arbitrary element of I.
The proof of Theorem 3 reveals that the complexity of the problem COUNTW3C(p)
depends essentially on the way the star symbol is used in p. More precisely, the star
height of a property path p, denoted by sh(p), is the maximum depth of nesting of
the star symbols appearing in p [13], that is: (1) sh(p) = 0 if p ∈ I, (2) sh(p) =
max{sh(p1), sh(p2)} if p = p1|p2 or p = p1/p2, and (3) sh(p) = sh(p1) + 1 if p = p
∗
1.
Then for every positive integer k, deﬁne SHk as the class of property paths p such that
sh(p) ≤ k, and deﬁne COUNTW3C(SHk) as the problem of computing, given an RDF
graph G, elements a, b ∈ I and a property path p ∈ SHk, the value card(cid:2)(a,p,b)(cid:3)G
(μ∅).
Then Theorem 3 can be generalized as follows:
Theorem 4 ([5]). COUNTW3C(SHk) is #P-complete for each k ≥ 1.
We now move to the study of the combined complexity of the problem COUNTW3C.
In [5], the authors formalized the clique experiment presented in Section 5.1, and then
provided lower bounds in this scenario for the number of occurrences of a mapping in
the result of the procedure (ALP) used by the W3C to deﬁne the semantics of property
paths [16]. Interestingly, these lower bounds show that the poor behavior detected in the
experiments is not a problem with the tested implementations, but instead a characteristic 
of the semantics of property paths proposed in [16]. These lower bounds provide
strong evidence that evaluating property paths under the semantics proposed by the
W3C is completely infeasible, as they show that COUNTW3C is not even in #P.

100

M. Arenas and J. P´erez

Fix an element c ∈ I and an inﬁnite sequence {ai}i≥1 of pairwise distinct elements
from I, which are all different from c. Then for every n ≥ 2, let clique(n) be an RDF
graph forming a clique with nodes a1, . . . , an and edge label c, that is, clique(n) =
{(ai, c, aj) | i, j ∈ {1, . . . , n} and i (cid:10)= j}. Moreover, for every property path p, deﬁne
(μ∅).
COUNTCLIQUE(p, n) as card(cid:2)(a1,p,an)(cid:3)clique(n)
Lemma 1 ([5]). For every property path p and n ≥ 2:

COUNTCLIQUE(p∗, n) =

Let p0 = c and ps+1 = p
From Lemma 1, we obtain that:

n−1(cid:2)

(n − 2)! · COUNTCLIQUE(p, n)k

(n − k − 1)!
s, for every s ≥ 0. For example, p1 = c
∗

k=1

∗

and p3 = ((c

∗)∗)∗

.

n−1(cid:2)

(n − 2)! · COUNTCLIQUE(ps, n)k

,

k=1

(n − k − 1)!

COUNTCLIQUE(ps+1, n) =

(1)
for every s ≥ 0. This formula can be used to obtain the number of occurrences of the
mapping with empty domain in the answer to the property-path triple (a1, ps, an) over
the RDF graph clique(n). For instance, the formula states that if a system implements
the semantics proposed by the W3C [16], then with input clique(8) and (a1, (c
, a8),
the empty mapping would have to appear more than 79 · 1024 times in the output.
Thus, even if a single byte is used to store the empty mapping6, then the output would
be of more than 79 Yottabytes in size! Table 5 shows more lower bounds obtained with
formula (1). Notice that these numbers coincide with the results obtained in the reported
experiments (Tables 1 and 2). Also notice that, for example, for n = 6 and s = 2 the
lower bound is of more than 28 billions, and for n = 4 and s = 3 is of more than
56 millions, which explains why the tested implementations exceeded the timeout for
queries Cliq-2 and Cliq-3 (Table 2).

∗)∗

Most notably, Table 5 allows one to provide a cosmological lower bound for evaluating 
property paths: if one proton is used to store the mapping with empty domain, with
input clique(6) (which contains only 30 triples) and the property-path triple

(a1, (((c

∗)∗)∗)∗

, a6),

every system implementing the semantics proposed by the W3C [16] would have to
return a ﬁle that would not ﬁt in the observable universe!

From Lemma 1, the following double-exponential lower bound can be provided for

the complexity of COUNTCLIQUE(ps, n).
Lemma 2 ([5]). For every n ≥ 2 and s ≥ 1:

COUNTCLIQUE(ps, n) ≥ (n − 2)!(n−1)s−1

From this bound, we obtain that COUNTW3C is not in #P. Besides, from the proof
of Theorem 3, it can be shown that COUNTW3C is in the complexity class #EXP,
which is deﬁned as #P but considering non-deterministic Turing Machines that work in
exponential time.

6 Recall that the empty mapping μ∅ is represented as the four-bytes string | | in ARQ, and as

the two-bytes string [] in Sesame.

Federation and Navigation in SPARQL 1.1

101

Table 5. Number of occurrences of the mapping with empty domain in the answer to propertypath 
triple (a1, ps, an) over the RDF graph clique(n), according to the semantics for property
paths proposed by the W3C in [16]

s n COUNTCLIQUE(ps, n) s n COUNTCLIQUE(ps, n)
1 3 2
2 3 6
3 3 42
4 3 1806
1 4 5
2 4 305
3 4 56931605
4 4 > 1023

1 5 16
2 5 418576
3 5 > 1023
4 5 > 1093
1 6 65
2 6 28278702465
3 6 > 1053
4 6 > 10269

Theorem 5 ([5]). COUNTW3C is in #EXP and not in #P.

It is open whether COUNTW3C is #EXP-complete.

The Complexity of the Entire Language. We consider now the data complexity of
the evaluation problem for the entire language. More precisely, we use the results presented 
in the previous section to show the major impact of using property paths on the
complexity of evaluating SPARQL 1.1 queries. The evaluation problem is formalized
as follows. Given a ﬁxed SPARQL 1.1 query Q, deﬁne EVALW3C(Q) as the problem
of computing, given an RDF graph G and a mapping μ, the value card(cid:2)Q(cid:3)G

(μ).

It is easy to see that the data complexity of SPARQL 1.1 without property paths is
polynomial. However, from Theorem 3, we obtain the following corollary that shows
that the data complexity is considerably higher if property paths are included, for the
case of the semantics proposed by the W3C [16]. The following corollary states that
EVALW3C(Q) is in the complexity class FP#P, which is the class of functions that can
be computed in polynomial time if one has access to an efﬁcient subroutine for a #Pcomplete 
problem (or, more formally, one has an oracle for a #P-complete problem).

Corollary 1 ([5]). EVALW3C(Q) is in FP#P, for every SPARQL 1.1 query Q. Moreover,
 there exists a SPARQL 1.1 query Q0 such that EVALW3C(Q0) is #P-hard.

5.3 Intractability for Alternative Semantics that Count Paths

In [5,19], the authors consider some alternative semantics for property paths that take
into account the cardinality of solutions. In this section, we focus on the two alternative
semantics proposed in [5], showing that both leads to intractability.

The usual graph theoretical notion of path has been extensively and successfully used
when deﬁning the semantics of queries including regular expressions [21,9,2,25,6].
Nevertheless, given that the W3C SPARQL 1.1 Working Group is interested in counting
paths, the classical notion of path in a graph cannot be naively used to deﬁne a semantics 
for property-path queries, given that cycles in an RDF graph may lead to an inﬁnite

102

M. Arenas and J. P´erez

number of different paths. In this section, we consider two alternatives to deal with this
problem that were introduced in [5]. We consider a semantics for property paths based
on classical paths that is only deﬁned for acyclic RDF graphs, and we consider a general
semantics that is based on simple paths (which are paths in a graph with no repeated
nodes). In both cases, the query evaluation based on counting is intractable [5]. Next
we formalize these two alternative semantics and present their complexity.
A path π in an RDF graph G is a sequence a1, c1, a2, c2, . . . , an, cn, an+1 such that
n ≥ 0 and (ai, ci, ai+1) ∈ G for every i ∈ {1, . . . , n}. Path π is said to be from a
to b in G if a1 = a and an+1 = b, it is said to be nonempty if n ≥ 1, and it is said
to be a simple path, or just s-path, if ai (cid:10)= aj for every distinct pair i, j of elements
from {1, . . . , n + 1}. Finally, given a property path p, path π is said to conform to p if
c1c2 ··· cn is a string in the regular language deﬁned by p.

Classical Paths over Acyclic RDF Graphs. We ﬁrst deﬁne the semantics of a propertypath 
triple considering classical paths, that we denote by (cid:2)·(cid:3)path
G . Notice that we have to
take into consideration the fact that the number of paths in an RDF graph may be inﬁnite,
 and thus we deﬁne this semantics only for acyclic graphs. More precisely, an RDF
graph G is said to be cyclic if there exists an element a mentioned in G and a nonempty
path π in G from a to a, and otherwise it is said to be acyclic. Then assuming that G
is acyclic, the evaluation of a property-path triple t over G in terms of classical paths,
G , is deﬁned as follows. Let t = (u, p, v) and W = ({u, v} ∩ V ), then
denoted by (cid:2)t(cid:3)path

(cid:2)t(cid:3)path

G

= {μ | dom(μ) = W and there exists a

path from μ(u) to μ(v) in G that conforms to p},

and for every μ ∈ (cid:2)t(cid:3)path
from μ(u) to μ(v) in G that conform to p.

G , the value card(cid:2)t(cid:3)path

G

(μ) is deﬁned as the number of paths

Similarly as we deﬁned the problem COUNTW3C in Section 5.2, we deﬁne the problem 
COUNTPATH as the following counting problem.

PROBLEM : COUNTPATH

INPUT : an acyclic RDF graph G, elements a, b ∈ I and a property path p
OUTPUT : card(cid:2)(a,p,b)(cid:3)path

(μ∅).

G

G

We also deﬁne, given a ﬁxed property path p, the problem COUNTPATH(p) as the the
problem of computing, given an acyclic RDF graph G and elements a, b ∈ I, the value
card(cid:2)(a,p,b)(cid:3)path

(μ∅).

To pinpoint the exact complexity of the problems COUNTPATH and COUNTPATH(p),
we need to consider two counting complexity classes: #L and SPANL. We introduce
these classes here, and we refer the reader to [3] for their formal deﬁnitions. #L is the
counting class associated with the problems that can be solved in logarithmic space in
a non-deterministic Turing Machine (NTM). In fact, a function f is said to be in this
class if there exists an NTM M that works in logarithmic space such that for every string
w, the value of f on w is equal to the number of accepting runs of M with input w.

Federation and Navigation in SPARQL 1.1

103

A prototypical #L-complete problem is the problem of computing, given a deterministic
ﬁnite automaton A and a string w, the number of strings that are accepted by A and
whose length is smaller than the length of w [3]. SPANL is deﬁned in a similar way to
#L, but considering logarithmic-space NTMs with output. More precisely, a function
f is said to be in this class if there exists such TM M such that for every string w,
the value of f on w is equal to the number of different outputs of M with input w.
A prototypical SPANL-complete problem is the problem of computing, given a nondeterministic 
ﬁnite automaton A and a string w, the number of strings that are accepted
by A and whose length is smaller than the length of w [3]. Although classes #L and
SPANL look alike, they are quite different in terms of complexity: #L is known to be
included in FP, the class of functions that can be computed in polynomial time, while
it is known that SPANL is a class of intractable computation problems, if SPANL ⊆ FP,
then P = NP.

It was proved in [5] that even for the simple case considered in this section, the

problem of evaluating property paths is intractable.
Theorem 6 ([5]). COUNTPATH is SPANL-complete.
Interestingly, one can show that at least in terms of data complexity, the problem of
evaluating property paths is tractable if their semantics is based on the usual notion of
path.
Theorem 7 ([5]). COUNTPATH(p) is in #L for every property path p. Moreover, there
exists a property path p0 such that COUNTPATH(p0) is #L-complete.
Although COUNTPATH(p) is tractable, it only considers acyclic RDF graphs, and thus
leaves numerous practical cases uncovered.

Simple Paths. We continue our investigation by considering the alternative semantics
for property paths that is deﬁned in terms of simple paths. Notice that even for cyclic
RDF graphs, the number of simple paths is ﬁnite, and thus, this semantics is properly
deﬁned for every RDF graph. Formally, assume that G is an RDF graph, t = (u, p, v)
is a property-path triple and W = ({u, v} ∩ V ). The evaluation of t over G in terms of
s-paths, denoted by (cid:2)t(cid:3)s-path

, is deﬁned as:

G

(cid:2)t(cid:3)s-path

G

= {μ | dom(μ) = W and there exists an s-path

from μ(u) to μ(v) in G that conforms to p},

and for every μ ∈ (cid:2)t(cid:3)s-path
(μ) is deﬁned as the number of spaths 
from μ(u) to μ(v) in G that conform to p. For the case of s-paths, we deﬁne the
problem COUNTSIMPLEPATH as follows.

, the value card(cid:2)t(cid:3)s-path

G

G

PROBLEM : COUNTSIMPLEPATH

INPUT : an RDF graph G, elements a, b ∈ I and a property path p
OUTPUT : card(cid:2)(a,p,b)(cid:3)s-path

(μ∅).

G

As for the previous cases, we deﬁne the counting problem COUNTSIMPLEPATH(p) as
COUNTSIMPLEPATH for a ﬁxed property path p. The following result shows that these
problems are also intractable.

M. Arenas and J. P´erez

104
Theorem 8 ([5,19]). The problem COUNTSIMPLEPATH is in #P. Moreover, if c ∈ I,
then the problem COUNTSIMPLEPATH(c

∗) is #P-complete.

Notice that the data complexity of evaluating property paths according to the s-path semantics 
is the same as evaluating them according to the W3C semantics. The difference
is in the combined complexity that is radically higher for the W3C semantics: for the
case of the semantics based on s-paths the combined complexity is in #P, while for the
W3C semantics it is not in #P (Theorem 5).

5.4 An Existential Semantics for Evaluating Property Paths

We have shown in the previous section that evaluating property-path triples according
to the semantics proposed in [16] is essentially infeasible, being the core of this problem 
the necessity of counting different paths. We have also shown that the version in
which one counts simple-paths is infeasible too. As described in [5], a possible solution
to this problem is to not use a semantics that requires counting paths, but instead a more
traditional existential semantics for property-path triples. That is, one just checks if two
nodes are connected (or not) by a path that conforms to a property-path expression,
without considering whether there are several paths connecting two nodes. This existential 
semantics has been used for years in graph databases [21,9,6], in XML [20,15],
and even on RDF [2,25] previous to SPARQL 1.1. In this section, we introduce this
semantics and study the complexity of evaluating property paths, and also SPARQL 1.1
queries, under it based on the results presented in [5]. We also compare this proposal
with the current ofﬁcial semantics for property paths, and present some experimental
results.
The most natural way to deﬁne an existential semantics for property paths is to
consider the existential version of the semantics (cid:2)·(cid:3)path
G . More precisely, assume that
u, v ∈ (I ∪ V ), W = ({u, v} ∩ V ), t = (u, p, v) is a property-path triple, and G is an
RDF graph. Then deﬁne (cid:2)t(cid:3)

as:

∃(path)
G

∃(path)
G

(cid:2)t(cid:3)

= {μ | dom(μ) = W and there exists a path

from μ(u) to μ(v) in G that conforms to p}.

Moreover, deﬁne the cardinality of every mapping μ in (cid:2)t(cid:3)
just as 1. Notice
that with the semantics (cid:2)t(cid:3)
, we are essentially discarding all the duplicates from
(cid:2)t(cid:3)path
G . This allows us to consider general graphs (not necessarily acyclic graph as in
Section 5). To study the complexity of evaluating property paths under this semantics,
we deﬁne the decision problem EXISTSPATH.

∃(path)
G

∃(path)
G

PROBLEM : EXISTSPATH

INPUT : an RDF graph G, elements a, b ∈ I and a property path p
OUTPUT : is card

(μ∅) = 1?

(cid:2)(a,p,b)(cid:3)

∃(path)
G

∃(path)
That is, the problem EXISTSPATH is equivalent to checking if μ∅ is in (cid:2)(a, p, b)(cid:3)
G

.

Federation and Navigation in SPARQL 1.1

105

Notice that with EXISTSPATH, we are measuring the combined complexity of evaluating 
paths under the existential semantics. The following result shows that EXISTSPATH
is tractable. This is a corollary of some well-known results on graph databases (e.g. see
Section 3.1 in [25]). In the result, we use |G| to denote the size of an RDF graph G and
|p| to denote the size of a property-path p.
Proposition 3. EXISTSPATH can be solved in time O(|G| · |p|).

G

Discarding Duplicates from the Standard and Simple-Paths Semantics. A natural 
question at this point is whether there exists a relationship between the existential
semantics deﬁned in the previous section and the semantics that can be obtained by discarding 
duplicates from (cid:2)t(cid:3)G and (cid:2)t(cid:3)s-path
for a property-path triple t. As shown in [5],
a relationship does exists, which can be considered as an important step towards the
optimization of property-paths evaluation.
Assume that G is an RDF graph and t is a property-path triple. Then we deﬁne
(cid:2)t(cid:3)∃
G as having exactly the same mappings as in (cid:2)t(cid:3)G, but with the cardinality of every
mapping in (cid:2)t(cid:3)∃
as having exactly the
∃(s-path)
same mappings as in (cid:2)t(cid:3)s-path
G
deﬁned as 1. Thus, in this section, we study the decision problems EXISTSW3C and
EXISTSSIMPLEPATH, which are deﬁned as follows:

G deﬁned just as 1. Similarly, we deﬁne (cid:2)t(cid:3)

, but with the cardinality of every mapping in (cid:2)t(cid:3)

∃(s-path)
G

G

PROBLEM : EXISTSW3C

INPUT : an RDF graph G, elements a, b ∈ I and a property path p

QUESTION : is card(cid:2)(a,p,b)(cid:3)∃

G

(μ∅) = 1?

PROBLEM : EXISTSSIMPLEPATH

INPUT : an RDF graph G, elements a, b ∈ I and a property path p

(cid:2)(a,p,b)(cid:3)

∃(s-path)
G

QUESTION : is card

(μ∅) = 1?

∃(path)
G

G if and only if μ ∈ (cid:2)t(cid:3)

The following result shows that, somehow surprisingly, the semantics (cid:2)·(cid:3)∃
G coincides
with (cid:2)·(cid:3)
. Thus, even though the ofﬁcial semantics of property paths is given in
terms of a particular procedure [16], when one does not count paths, it coincides with
the classical existential semantics based on the usual notion of path.
Theorem 9 ([5]). For every RDF graph G, mapping μ and property-path triple t it
holds that μ ∈ (cid:2)t(cid:3)∃
As a corollary of Propositions 3 and Theorem 9, one obtains that:
Theorem 10 ([5]). EXISTSW3C can be solved in time O(|G| · |p|).
The situation is radically different for the case of simple paths. From some well-known
results on graph databases [21], one can prove that EXISTSSIMPLEPATH is an intractable 
problem, even for a ﬁxed property-path. More precisely, for a ﬁxed propertypath 
p, the decision problem EXISTSSIMPLEPATH(p) has as input an RDF graph G and
elements a, b ∈ I, and the question is whether card
Proposition 4 ([21,5,19]). The problem EXISTSSIMPLEPATH is in NP. Moreover, the
problem EXISTSSIMPLEPATH((c/c)∗) is NP-complete, where c ∈ I.

∃(path)
G

(μ∅) = 1.

∃(s-path)
G

(cid:2)(a,p,b)(cid:3)

.

106

M. Arenas and J. P´erez

Existential Semantics and SPARQL 1.1. We have shown that when bags are considered 
for the semantics of property paths, the evaluation becomes intractable, even in
data complexity. However, the previous version of SPARQL, that did not include path
queries, considered a bag semantics for the mapping operators (AND, OPT, UNION,
FILTER and SELECT), which has proved to be very useful in practice. Thus, a natural 
question is whether one can construct a language with functionalities to express
interesting queries about paths in RDF graphs, with bag semantics for the mappings
operators, and that, at the same time, can be efﬁciently evaluated. In this section, we
give a positive answer to this question. It was shown in [5] that if one combines existential 
semantics for property paths and bag semantics for the SPARQL 1.1 operators,
one obtains the best of both worlds and still has tractable data complexity. Moreover, it
was also shown in [5] that considering simple paths is not an option as the evaluation
problem is still intractable in data complexity.

We start by formalizing this alternative way of evaluating SPARQL 1.1 queries that
considers existential semantics for property-path triples. Given a SPARQL 1.1 query
Q, deﬁne (cid:2)Q(cid:3)∃
G exactly as (cid:2)Q(cid:3)G is deﬁned in Sections 4.1 and 4.2, but evaluating
property-paths triples according to the semantics (cid:2)·(cid:3)∃
G deﬁned in Section 5.4 (that is,
(cid:2)t(cid:3)G is replaced by (cid:2)t(cid:3)∃
and
(cid:2)Q(cid:3)
, we
are not discarding all duplicates but only the duplicates that are generated when evaluating 
property paths. Thus, these semantics are still bag semantics and, therefore, we
consider the computation problems associated to them to study their complexity.

G if t is a property-path triple), and likewise for (cid:2)Q(cid:3)
and (cid:2)Q(cid:3)

. Notice that for the three semantics (cid:2)Q(cid:3)∃

∃(s-path)
∃(s-path)
G
G

∃(path)
G

∃(path)
G

G, (cid:2)Q(cid:3)

Let Q be a SPARQL 1.1 query. We deﬁne ﬁrst the following computation problem.

PROBLEM : EVALEXISTSW3C(Q)

INPUT : an RDF graph G, and a mapping μ

OUTPUT : card(cid:2)Q(cid:3)∃

(μ)

G

Moreover, we also consider the computation problems EVALEXISTSSIMPLEPATH(Q)
and EVALEXISTSPATH(Q), deﬁned as EVALEXISTSW3C(Q) but consider as output
the values card

(μ), respectively.

(μ) and card

∃(s-path)
G

(cid:2)Q(cid:3)

∃(path)
G

(cid:2)Q(cid:3)

PROBLEM : EVALEXISTSSIMPLEPATH(Q)

INPUT : an RDF graph G, and a mapping μ

OUTPUT : card

∃(s-path)
G

(cid:2)Q(cid:3)

(μ)

PROBLEM : EVALEXISTSPATH(Q)

INPUT : an RDF graph G, and a mapping μ

OUTPUT : card

(cid:2)Q(cid:3)

∃(path)
G

(μ)

Notice that in these three problems, we are considering the data complexity of SPARQL
1.1 under the respective semantics.

Notably, the next result shows that the just deﬁned semantics (cid:2)·(cid:3)∃

are
tractable, in terms of data complexity. This result is a consequence of Theorem 10 and

G and (cid:2)·(cid:3)

∃(path)
G

Federation and Navigation in SPARQL 1.1

107

Proposition 3. In the formulation of this result we use the class FP, which is deﬁned as
the class of all functions that can be computed in polynomial time (and thus, it is a class
of tractable functions).

∃(s-path)
G

Theorem 11 ([5]). EVALEXISTSW3C(Q) and EVALEXISTSPATH(Q) are in FP for
every SPARQL 1.1 query Q.
We conclude this section by showing that for the case of the semantics (cid:2)·(cid:3)
, the
data complexity is unfortunately still high. To study this problem we need the complex-
(cid:11)NP and FPNP[O(log n)], which are deﬁned in terms of oracles as for the
ity classes FP
(cid:11)NP
case of the complexity class FP#P used in Corollary 1. More precisely, the class FP
contains all the functions that can be computed in polynomial time by a procedure that
is equipped with an efﬁcient subroutine (oracle) for an NP-complete problem, with the
restriction that all the calls to the subroutine should be made in parallel, that is, no call
to the subroutine can depend on the result of a previous call to this subroutine [32].
The class FPNP[O(log n)] is deﬁned in the same way, but with the restriction that the
subroutine for an NP-complete problem can be called only a logarithmic number of
(cid:11)NP are considered to be intractable. Moretimes.
 Both classes FPNP[O(log n)] and FP
over, it is known that FPNP[O(log n)] ⊆ FP
(cid:11)NP, but it is open whether this containment
is strict [29].

(cid:11)NP for every SPARQL 1.1
Theorem 12 ([5]). EVALEXISTSSIMPLEPATH(Q) is in FP
query Q. Moreover, there exists a query Q0 such that Q0 mentions only operators AND
and SELECT, and EVALEXISTSSIMPLEPATH(Q0) is FPNP[O(log n)]-hard.

Theorem 12 shows that simple paths are not a good option even if duplicates are
not considered. The exact complexity of EVALEXISTSSIMPLEPATH(Q) is an open
problem [5].

5.5 Optimizing Property Path Queries with DISTINCT

As discussed in the previous section, SPARQL 1.1 is tractable in terms of data complexity 
if one considers the existential semantics (cid:2)·(cid:3)∃
for property paths.
The goal of this section is to show the impact of using these semantics in practice,
by reporting on some experimental results obtained with two implementations that

G and (cid:2)·(cid:3)

∃(path)
G

Table 6. Time in seconds for processing Foaf-1D

Input ARQ RDFQ Kgram Sesame Psparql Gleen
0.29 1.39
0.30 1.32
0.30 1.34
0.31 1.38
0.33 1.38
0.35 1.42
0.44 1.50
0.45 1.52

2.37
2.24
47.31
2.60 204.95
6.43
6.88 3222.47 80.73
– 394.61
–
–
–
–
–
–
–
–

A
B
C
D 24.42
–
E
–
F
–
G
–
H

–
–
–
–
–
–
–
–

108

M. Arenas and J. P´erez

Table 7. Time in seconds for queries Cliq-1D, Cliq-2D, and Cliq-3D

n
ARQ RDFQ Kgram Sesame Psparql Gleen
0.18 1.24
1.68
32.61
8
2.00 213.99
0.20 1.23
9
0.20 1.25
3.65 2123.90 227.66
10
0.23 1.25
–
29.71
11
0.24 1.24
–
12 1394.06
–
–
0.27 1.24
13

1.39
9.08
5.34 166.82
–
–
–
–

–
–
–

Cliq-1D

n ARQ RDFQ Psparql Gleen
0.14 1.23
2
0.14 1.23
3
0.14 1.23
4
0.15 1.22
5 97.06
0.16 1.23
–
6
–
0.16 1.23
7

0.76
1.40
1.19
0.84
1.65 19.38
–
–
–

Cliq-2D

n ARQ RDFQ Psparql Gleen
0.14 1.24
2 1.18
0.14 1.23
3 1.41
–
0.15 1.24
4
0.15 1.24
–
5
0.16 1.24
–
6
–
0.16 1.24
7

0.77
6.78
–
–
–
–

Cliq-3D

∃(path)
G

extends SPARQL 1.0 with existential path semantics: Psparql (version 3.3) [37], and
Gleen (version 0.6.1) [39]. These two implementations evaluate SPARQL queries according 
to (cid:2)·(cid:3)
, although they use a slightly different syntax for path queries. We
also show that SPARQL 1.1 queries can be highly optimized by making use of the
SELECT DISTINCT feature. This result is of highly practical interest since, as shown
by the experiments, no current implementation of SPARQL 1.1 is taking advantage of
queries that use SELECT DISTINCT.

We begin by stating the relationship between the existential semantics and the standard 
semantics in the presence of DISTINCT. It is important to notice that in the
following result we consider the fragment of SPARQL 1.1 introduced in Section 4. In
particular, we do not consider some features of SPARQL 1.1 introduced in [16], such
as subqueries and aggregates.

Theorem 13 ([5]). Let P be a SPARQL 1.1 graph pattern, G an RDF graph and W a
set of variables. Then we have that:

∃(path)
(cid:2)(SELECT DISTINCT W P )(cid:3)G = (cid:2)(SELECT DISTINCT W P )(cid:3)
G
∃(path)
(cid:2)(SELECT DISTINCT * P )(cid:3)G = (cid:2)(SELECT DISTINCT * P )(cid:3)
G

In view of this theorem, in [5] the authors present an experimental evaluation considering 
all the queries presented in Section 5.1, but using the SELECT DISTINCT feature,
that is:

Cliq-1D: SELECT DISTINCT * WHERE { :a0 (:p)* :a1 }
Cliq-2D: SELECT DISTINCT * WHERE { :a0 ((:p)*)* :a1 }
Cliq-3D: SELECT DISTINCT * WHERE { :a0 (((:p)*)*)* :a1 }
Foaf-1D: SELECT DISTINCT * WHERE { axel:me (foaf:knows)* ?x }

Federation and Navigation in SPARQL 1.1

109

Tables 6 and 7, taken from [5], show the results of this experiment. Although all the
tested systems return the same results for these queries, the differences in efﬁciency between 
the SPARQL 1.1 implementations and the implementations that use an existential
semantics are dramatic.

6 Concluding Remarks

SPARQL is now widely used as the standard RDF query language. The new version of
the language, SPARQL 1.1, has been in the process of standardization since 2009, and
it is going to include several features not presented in the previous version. Even before
SPARQL 1.1 becomes a standard, the research community has been investigating some
properties of the language, providing valuable feedback to the groups in charge of the
standardization process.

In this paper, we have focused on two of the most interesting and useful features
introduced in SPARQL 1.1: federation and navigation. These features not only add expressiveness 
to the language but also pose several interesting and challenging research
questions. We presented a formalization of these new features and studied their expressiveness 
and complexity, showing some theoretical and empirical results. We also
presented some recently discovered issues that can have a signiﬁcant impact on the
adoption of the new standard, and we discussed on possible alternatives and their implications.
 As of the beginning of year 2012, these issues are being carefully discussed
in the groups in charge of the standard.

Acknowledgments. Several of the results surveyed in this paper were presented in
some articles of the authors and their co-authors Carlos Buil-Aranda, Sebasti´an Conca,
Oscar Corcho, Claudio Gutierrez and Axel Polleres. Marcelo Arenas was supported by
Fondecyt grant 1110287, and Jorge P´erez by Fondecyt grant 11110404 and by VID
grant U-Inicia 11/04 Universidad de Chile.

References

1. Alkhateeb, F., Baget, J.-F., Euzenat, J.: Constrained regular expressions in SPARQL. In:

SWWS, pp. 91–99 (2008)

2. Alkhateeb, F., Baget, J.-F., Euzenat, J.: Extending SPARQL with regular expression patterns

3.

(for querying RDF). JWS 7(2), 57–73 (2009)
`Alvarez, C., Jenner, B.: A very hard log-space counting class. Theor. Comput. Sci. 107(1),
3–30 (1993)

4. Anyanwu, K., Maduko, A., Sheth, A.P.: Sparq2l: towards support for subgraph extraction

queries in rdf databases. In: WWW, pp. 797–806 (2007)

5. Arenas, M., Conca, S., P´erez, J.: Counting beyond a yottabyte, or how SPARQL 1.1 property

paths will prevent adoption of the standard. In: WWW, pp. 629–638 (2012)

6. Barcel´o, P., Hurtado, C.A., Libkin, L., Wood, P.T.: Expressive languages for path queries

over graph-structured data. In: PODS, pp. 3–14 (2010)

7. Buil-Aranda, C., Arenas, M., Corcho, O.: Semantics and Optimization of the SPARQL 1.1
Federation Extension. In: Antoniou, G., Grobelnik, M., Simperl, E., Parsia, B., Plexousakis,
D., De Leenheer, P., Pan, J. (eds.) ESWC 2011, Part II. LNCS, vol. 6644, pp. 1–15. Springer,
Heidelberg (2011)

110

M. Arenas and J. P´erez

8. Buil-Aranda, C., Arenas, M., Corcho, ´O., Polleres, A.: Federating queries in SPARQL 1.1:

Syntax, semantics and evaluation. Submitted for Journal Publication

9. Calvanese, D., Giacomo, G.D., Lenzerini, M., Vardi, M.Y.: Rewriting of regular expressions

and regular path queries. In: PODS, pp. 194–204 (1999)

10. Carroll, J.J., Dickinson, I., Dollin, C., Reynolds, D., Seaborne, A., Wilkinson, K.: Jena:
implementing the semantic web recommendations. In: WWW (Alternate Track Papers &
Posters), pp. 74–83 (2004)

11. Corby, O., Faron-Zucker, C.: The kgram abstract machine for knowledge graph querying. In:

Web Intelligence, pp. 338–341 (2010)

12. Durst, M., Suignard, M.: Rfc 3987, internationalized resource identiﬁers (iris) (2005)
13. Eggan, L.C.: Transition graphs and the star-height of regular events. The Michigan Mathematical 
Journal 10(4), 385–397 (1963)

14. Glimm, B., Ogbuji, C.: Sparql 1.1 entailment regimes (2010)
15. Gottlob, G., Koch, C., Pichler, R.: Efﬁcient algorithms for processing XPath queries.

TODS 30(2), 444–491 (2005)

16. Harris, S., Seaborne, A.: SPARQL 1.1 query language. W3C Working Draft, (January 5,

2012), http://www.w3.org/TR/2012/WD-sparql11-query-20120105/

17. Hartig, O., Bizer, C., Freytag, J.-C.: Executing SPARQL Queries over the Web of Linked
Data. In: Bernstein, A., Karger, D.R., Heath, T., Feigenbaum, L., Maynard, D., Motta, E.,
Thirunarayan, K. (eds.) ISWC 2009. LNCS, vol. 5823, pp. 293–309. Springer, Heidelberg
(2009)

18. Kochut, K.J., Janik, M.: SPARQLeR: Extended Sparql for Semantic Association Discovery.
In: Franconi, E., Kifer, M., May, W. (eds.) ESWC 2007. LNCS, vol. 4519, pp. 145–159.
Springer, Heidelberg (2007)

19. Losemann, K., Martens, W.: The complexity of evaluating path expressions in sparql. In:

PODS, pp. 101–112 (2012)

20. Marx, M.: Conditional XPath. TODS 30(4), 929–959 (2005)
21. Mendelzon, A.O., Wood, P.T.: Finding regular simple paths in graph databases. SIAM J.

Comput. 24(6), 1235–1258 (1995)

22. Olson, M., Ogbuji, U.: The Versa speciﬁcation,

http://uche.ogbuji.net/tech/rdf/versa/etc/versa-1.0.xml

23. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL. In: Cruz, I.,
Decker, S., Allemang, D., Preist, C., Schwabe, D., Mika, P., Uschold, M., Aroyo, L.M. (eds.)
ISWC 2006. LNCS, vol. 4273, pp. 30–43. Springer, Heidelberg (2006)

24. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and complexity of SPARQL. TODS 34(3)

(2009)

25. P´erez, J., Arenas, M., Gutierrez, C.: nSPARQL: A navigational language for RDF. JWS 8(4),

255–270 (2010)

26. Prud’hommeaux, E., Seaborne, A.: SPARQL query language for RDF (January 2008)
27. Prud’hommeaux, E., Buil-Aranda, C.: SPARQL 1.1 federated query. W3C Working Draft

(November 17, 2011),
http://www.w3.org/TR/2011/+WD-sparql11-federated-
query-20111117/

28. Prud’hommeaux, E., Seaborne, A.: SPARQL query language for RDF. W3C Recommendation 
(January 15 (2008), http://www.w3.org/TR/rdf-sparql-query/

29. Selman, A.L.: A taxonomy of complexity classes of functions. J. Comput. Syst. Sci. 48(2),

357–381 (1994)

30. Valiant, L.G.: The complexity of computing the permanent. Theor. Comput. Sci. 8, 189–201

(1979)

31. Vardi, M.Y.: The complexity of relational query languages (extended abstract). In: STOC,

pp. 137–146 (1982)

Federation and Navigation in SPARQL 1.1

111

32. Wagner, K.W.: More complicated questions about maxima and minima, and some closures

of NP. Theor. Comput. Sci. 51, 53–80 (1987)

33. ARQ, http://sourceforge.net/projects/jena/files/ARQ/
34. KGRAM, http://www-sop.inria.fr/edelweiss/software/corese/
35. RDF: Query, http://search.cpan.org/˜gwilliams/RDF-Query
36. Sesame, http://sourceforge.net/projects/sesame/
37. Psparql, http://exmo.inrialpes.fr/software/psparql/
38. RDF data access working group mailing list,

http://lists.w3.org/Archives/Public/public-rdf-dawg-comments/
39. Gleen, http://sig.biostr.washington.edu/projects/ontviews/gleen/
40. Semantic Web Client Library,

http://www4.wiwiss.fu-berlin.de/bizer/ng4j/semwebclient/

