A Complete Proofs and Intermediate Results

A.1 Proof of Proposition 1 (2)

We have already shown that M′ is not a UCQ-maximum recovery 
of M. To complete the proof, we show that M′ is actually a
CQ6=-maximum recovery of M. Notice that for every instance I of
S, if J = chaseΣ′ (chaseΣ(I)), then J is a solution for I under
M ◦ M′ and J ⊆ I. Thus, given that every query in CQ6= is monotone,
 we conclude that certainM◦M′ (Q, I) ⊆ Q(J) ⊆ Q(I) for
every query Q in CQ6= over S. Therefore, we have that M′ is a
CQ6=-recovery of M. Hence, to ﬁnish the proof we have to show
that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I) for every CQ6=-
recovery M′′ of M, query Q in CQ6= over S, and instance I of S.

Let M′′ be a CQ6=-recovery of M, Q a query in CQ6= over
S and I an instance of S. We consider two cases to show that
certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I).
(I) Assume that one of the conjuncts of Q is of the form either D(x) or
E(x). We show next that certainM◦M′′ (Q, I) = ∅, from which we
conclude that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I). Without
loss of generality, assume that D(x) is one of the conjunct of Q, and
let I ′ be an instance of S such that DI ′
= (DI ∪ EI )
and F I ′
= F I . Then we have that SolM(I) = SolM(I ′), which
implies that SolM◦M′′ (I) = SolM◦M′′ (I ′). Thus, we have that
certainM◦M′′ (Q, I) = certainM◦M′′ (Q, I ′). Given that D(x) is
one of the conjuncts of Q, Q is a query in CQ6= and DI ′
= ∅,
we have that Q(I ′) = ∅. Therefore, given that M′′ is a CQ6=-
recovery of M, we have that certainM◦M′′ (Q, I ′) = ∅ and, hence,
certainM◦M′′ (Q, I) = ∅.
(II) Assume that all of the conjuncts of Q are of the form R(x). Next
we show that Q(I) ⊆ certainM◦M′ (Q, I), from which we conclude
that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I) (since M′′ is a
CQ6=-recovery of M).

= ∅, EI ′

It is straightforward to prove that for every I ′ ∈ SolM◦M′ (I),
it holds that RI ⊆ RI ′
. Thus, given that all of the conjuncts of Q
are of the form R(x) and Q is a query in CQ6=, we conclude that
Q(I) ⊆ Q(I ′) for every I ′ ∈ SolM◦M′ (I). Therefore, we have that
Q(I) ⊆ certainM◦M′ (Q, I).

A.2 Proof of Proposition 3

In the proof of the proposition, we need the following technical lemma.
Interestingly, this lemma shows that both PM and CM identify the
space of solutions associated to a mapping M. This result is of independent 
interest, since, in general, such characterizations of spaces of
solutions are difﬁcult to obtain.

Lemma 1 Let M = (S, T, Σ), where Σ is a set of st-tgds. Then
for every pair I1, I2 of instances over S, the following conditions are
equivalent: (1) SolM(I2) ⊆ SolM(I1), (2) for every query Q ∈ PM:
Q(I1) ⊆ Q(I2), (3) for every query Q ∈ CM: Q(I1) ⊆ Q(I2).

Proof (1) ⇒ (2) Assume that SolM(I2) ⊆ SolM(I1), and let
Q ∈ PM. Next we show that Q(I1) ⊆ Q(I2). Assume that
ϕ(¯x) → ψ(¯x) is an st-tgd in Σ such that Q is a source rewriting
of ψ(¯x) w.r.t M. Given that SolM(I2) ⊆ SolM(I1), we have that
certainM(Q′, I1) ⊆ certainM(Q′, I2) for every query Q′. In particular,
 this last property holds for the query deﬁned by formula ψ(¯x).
Thus, given that Q is a source rewriting of ψ(¯x) w.r.t M, we conclude
that Q(I1) ⊆ Q(I2).

(2) ⇒ (3) Assume that Q(I1) ⊆ Q(I2), for every Q ∈ PM.
We use an inductive argument to prove that for every Q ∈ CM,
it holds that Q(I1) ⊆ Q(I2). Let Q ∈ CM. If Q ∈ PM, then
Q(I1) ⊆ Q(I2) by hypothesis. Assume that the property holds for

1

queries Q1, Q2 in CM. If Q is the conjunction Q1 and Q2, then
Q(I1) = Q1(I1) ∩ Q2(I1). Thus, given that by induction hypothesis 
Q1(I1) ⊆ Q1(I2) and Q2(I1) ⊆ Q2(I2), we conclude that
Q(I1) = Q1(I1) ∩ Q2(I1) ⊆ Q1(I2) ∩ Q2(I2) = Q(I2). If Q
is the disjunction of Q1 and Q2, then it is possible to conclude that
Q(I1) ⊆ Q(I2) as in the previous case. If Q is obtained from Q1 by
existentially quantifying some of the free variables of Q1, then from
the fact that Q1(I1) ⊆ Q1(I2), it is straightforward to conclude that
Q(I1) ⊆ Q(I2). Similarly, if Q is obtained from Q1 by substituting
some variables, then it is easy to conclude that Q(I1) ⊆ Q(I2) from
the fact that Q1(I1) ⊆ Q1(I2). Finally, assume that (x1, . . . , xk) is
the tuple of free variables of Q1 (with k ≥ 2), and assume that Q is
obtained from Q1 by adding the inequality xi 6= xj with i 6= j. Let
¯a = (a1, . . . , ak) ∈ Q(I1). Then ¯a ∈ Q1(I1) and ai 6= aj . Thus,
from the fact that Q1(I1) ⊆ Q1(I2), we conclude that ¯a ∈ Q1(I2)
and, hence, ¯a ∈ Q(I2) since ai 6= aj . Therefore, we conclude that
Q(I1) ⊆ Q(I2).

(3) ⇒ (1) Let I1, I2 be instances of S such that for every
Q ∈ CM, it holds that Q(I1) ⊆ Q(I2). Next we show that
SolM(I2) ⊆ SolM(I1). Assume that J ∈ SolM(I2). To prove that
J ∈ SolM(I1), we need to prove that (I1, J) |= Σ. Let σ ∈ Σ be a
dependency of the form ϕ(¯x) → ψ(¯x), and assume that I1 |= ϕ(¯a)
for some tuple ¯a of constant values. We need to show that J |= ψ(¯a).
Given I1 |= ϕ(¯a), we know that for every J ′ ∈ SolM(I1), it holds
that J ′ |= ψ(¯a) and, hence, ¯a ∈ certainM(Qψ, I1), where Qψ is the
conjunctive query deﬁned by ψ(¯x). Assume that Q′ ∈ CM is a source
rewriting of Qψ w.r.t. M. Since Q′(I1) = certainM(Qψ, I1), we
obtain that ¯a ∈ Q′(I1). Thus, given that Q′(I1) ⊆ Q′(I2) by hypothesis,
 we conclude that ¯a ∈ Q′(I2). But then given that Q′ is a source
rewriting of Qψ, we conclude that ¯a ∈ certainM(Qψ, I2). That is, for
every K ∈ SolM(I2), it holds that ¯a ∈ Qψ(K). In particular, given
that J ∈ SolM(I2), we have that ¯a ∈ Qψ(J) and, thus, J |= ψ(¯a),
⊓⊔
which was to be shown. This concludes the proof of the lemma.

In the proof of Proposition 3, we also use the following observation.
 Let M = (S, T, Σ), where Σ is a set of st-tgds, and assume
that I is an instance of S and J is the result of chasing I with Σ.
It is known that for every conjunctive query Q over T, it holds that
certainM(Q, I) = Q(J)↓, where Q(J)↓ is deﬁned as the set of tuples 
of constants that belong to Q(J) [12]. Thus, if Q′ is a source
rewriting of a conjunctive query Q, then Q′(I) = Q(J)↓.

We now move to the proof of Proposition 3. Let M = (S, T, Σ)
be a quasi-invertible mapping, where Σ is a set of st-tgds. Next we
show that M′ is a quasi-inverse of M if and only if M′ fully recovers
CM for M.

(⇒) Assume that M′ is a quasi-inverse of M. We need to show
that M′ fully recovers CM, that is, we need to show that for every
Q ∈ CM and instance I of S, we have certainM◦M′ (Q, I) = Q(I).
Let Q be a query in CM and I an instance of S. First, we show that
certainM◦M′ (Q, I) ⊆ Q(I). Given that (I, I) ∈ IdS[∼M, ∼M]
and M′
is a quasi-inverse of M, we have that (I, I) ∈ (M ◦
M′)[∼M, ∼M]. Thus, there exist instances I ′, I ′′ of S such that
SolM(I) = SolM(I ′) = SolM(I ′′) and (I ′, I ′′) ∈ M ◦ M′.
Since SolM(I) = SolM(I ′) and (I ′, I ′′) ∈ M ◦ M′, we know
that (I, I ′′) ∈ M ◦ M′. Now, since SolM(I) = SolM(I ′′) and
Q ∈ CM, we have that Q(I) = Q(I ′′) by Lemma 1. Thus, we conclude 
that certainM◦M′ (Q, I) ⊆ Q(I) since I ′′ ∈ SolM◦M′ (I) and
Q(I ′′) = Q(I). Second, we show that Q(I) ⊆ certainM◦M′ (Q, I).
Let (I, J) ∈ M ◦ M′. Then we have that (I, J) ∈ (M ◦ M′)[∼M
, ∼M]. Thus, given that M′ is a quasi-inverse of M, we conclude
that (I, J) ∈ IdS[∼M, ∼M] and, hence, there exist instances I1, I2
of S such that SolM(I) = SolM(I1), SolM(J) = SolM(I2)
and (I1, I2) ∈ IdS. Therefore, we have that I1 ⊆ I2, which implies 
that Q(I1) ⊆ Q(I2) since Q is a monotone query. Thus, given
SolM(I) = SolM(I1) and SolM(J) = SolM(I2), we conclude by
Lemma 1 that Q(I) = Q(I1), Q(J) = Q(I2) and Q(I) ⊆ Q(J).
We have shown that, if (I, J) ∈ M ◦ M′, then Q(I) ⊆ Q(J), from

2

which we deduce that Q(I) ⊆ certainM◦M′ (Q, I). This concludes
the proof that M′ fully recovers Q.

(⇐) Assume that M′ fully recovers CM for M. We need to show
that M′ is a quasi-inverse of M, for which we prove the following
properties:

1) and SolM(I2) = SolM(I ′

1, I ′

2 of S such
2), and

(a) If (I1, I2) ∈ M ◦ M′, then there exist instances I ′

that SolM(I1) = SolM(I ′
I ′
1 ⊆ I ′
2.

(b) For every instance I of S, there exists an instance I ′ of S such that

SolM(I) = SolM(I ′) and (I, I ′) ∈ M ◦ M′.

Properties (a) and (b) are enough to conclude that M′ is a quasi-inverse
of M. To see why this is the case, we consider two cases.

– First, we show that (M ◦ M′)[∼M, ∼M] ⊆ IdS[∼M, ∼M]. If
(I, J) ∈ (M ◦ M′)[∼M, ∼M], then there exist instances I1, I2
of S such that SolM(I) = SolM(I1), SolM(J) = SolM(I2)
and (I1, I2) ∈ M ◦ M′. Thus, we conclude by (a) that there
exist instances I ′
1),
SolM(I2) = SolM(I ′
2. Therefore, we have that
SolM(I) = SolM(I ′
2) ∈
IdS (by deﬁnition of IdS), from which we conclude that (I, J) ∈
IdS[∼M, ∼M].

2), and I ′
1), SolM(J) = SolM(I ′

2 of S such that SolM(I1) = SolM(I ′

2) and (I ′

1 ⊆ I ′

1, I ′

1, I ′

– Second, we show that IdS[∼M, ∼M] ⊆ (M ◦ M′)[∼M, ∼M
]. If (I, J) ∈ IdS[∼M, ∼M], then there exist instances I1, I2
of S such that SolM(I) = SolM(I1), SolM(J) = SolM(I2)
and I1 ⊆ I2 (given that (I1, I2) ∈ IdS). We know by (b) that
there exists an instance I ′
2 of S such that SolM(I2) = SolM(I ′
2)
and (I2, I ′
2) ∈ M ◦ M′. Thus, there exists an instance K of T
such that (I2, K) ∈ M and (K, I ′
2) ∈ M′. But then given that
M is deﬁned by a set of st-tgds and I1 ⊆ I2, we conclude that
(I1, K) ∈ M and, hence, (I1, I ′
2) ∈ M ◦ M′. Therefore, we
have that SolM(I) = SolM(I1), SolM(J) = SolM(I ′
2) and
(I1, I ′
2) ∈ M ◦ M′, from which we conclude that (I, J) ∈ (M ◦
M′)[∼M, ∼M].

We now show that (a) and (b) hold. To prove (a), let (I1, I2) ∈
M ◦ M′. Since M′ fully recovers CM, we know that for every Q ∈
CM, it holds that Q(I1) = certainM◦M′ (Q, I1). Thus, given that
certainM◦M′ (Q, I1) ⊆ Q(I2) for every query Q (since (I1, I2) ∈
M◦M′), we conclude that Q(I1) ⊆ Q(I2) for every Q ∈ CM. Hence,
by Lemma 1 we have that SolM(I2) ⊆ SolM(I1). Given that M
is quasi-invertible, we know that M satisﬁes the (∼M, ∼M)-subset
property [15] and, thus, from the fact that SolM(I2) ⊆ SolM(I1), we
conclude that there exist instances I ′
2 of S such that SolM(I1) =
SolM(I ′
2. This completes the
proof of (a).

1), SolM(I2) = SolM(I ′

2), and I ′

1 ⊆ I ′

1, I ′

To prove (b), it is important to notice that in the proof of (a), we
have shown that if (I1, I2) ∈ M ◦ M′, then Q(I1) ⊆ Q(I2) for every
Q ∈ CM. Now we show that (b) holds. Let I be an arbitrary instance
of S. For every query Q ∈ PM, deﬁne a Boolean query QI as follows.
If Q is a k-ary query (k ≥ 1) and m = |Q(I)|, then:

QI = ∃¯x1 · · · ∃¯xm+1(cid:20)

Q(¯x1) ∧ · · · ∧ Q(¯xm+1) ∧ ^1≤i<j≤m+1

¯xi 6= ¯xj(cid:21),

stands for the formula Wk

where ¯xi is a fresh k-ary tuple of pairwise distinct variables, and ¯u 6= ¯v
ℓ=1 ui 6= vi, for k-tuples ¯u = (u1, . . . , uk)
and ¯v = (v1, . . . , vk). It is straightforward to see that QI ∈ CM.
Notice that, if QI (I ′) = true for an instance I ′ of S, then |Q(I)| <
|Q(I ′)|. And conversely, if QI (I ′) = false for an instance I ′ of S,
then |Q(I ′)| ≤ |Q(I)|. If Q is a Boolean query, we consider two cases
to deﬁne QI . If Q(I) = false, then QI = Q. If Q(I) = true, then
QI is a Boolean query in CM that is always false (such a query can

be generated by adding a condition of the form x 6= x to any of the
queries in PM). Consider now the query:

Q⋆ = _Q∈PM

QI .

Notice that Q⋆ is in CM. Given that M′ fully recovers CM for M,
we have that M′ fully recovers Q⋆ for M. Thus, given that Q⋆(I) =
false, we have that certainM◦M′ (Q⋆, I) = false. Therefore, there
exists an instance I ⋆ of S such that (I, I ⋆) ∈ M ◦ M′ and Q⋆(I ⋆) =
false. That is, QI (I ⋆) = false for every Q ∈ PM. Now, let Q ∈
PM. Notice that from the facts that (I, I ⋆) ∈ M ◦ M′ and M′ fully
recovers Q, we know that Q(I) ⊆ Q(I ⋆). If Q is a k-ary query (k ≥
1), then given that QI (I ⋆) = false, we have that |Q(I ⋆)| ≤ |Q(I)|.
Thus, given that Q(I) ⊆ Q(I ⋆), we conclude that Q(I) = Q(I ⋆).
Moreover, if Q is a Boolean query and Q(I) = true, then from the
fact that Q(I) ⊆ Q(I ⋆), we conclude that Q(I ⋆) = true. Moreover,
if Q(I) = false, then we have that QI = Q and, therefore, Q(I ⋆) =
false since QI (I ⋆) = false. Thus, we have shown that for every Q ∈
PM, it holds that Q(I) = Q(I ⋆). Hence, we conclude by Lemma
1 that SolM(I) = SolM(I ⋆). Therefore, we have that there exists
an instance I ⋆ of S such that (I, I ⋆) ∈ M ◦ M′ and SolM(I) =
SolM(I ⋆), which was to be shown. This concludes the proof of (b)
and, thus, the proof of the proposition.

A.3 Proof of Theorem 2

First, notice that if M′ is a quasi-inverse of M, then from Proposition 
3 we have that M′ fully recovers CM for M, which implies that
M′ is a CM-maximum recovery of M. Second, assume that M′ is a
CM-maximum recovery of M. Given that M is quasi-invertible, there
exists a quasi-inverse M⋆ of M. Thus, we have from Proposition 3
that M⋆ fully recovers CM for M. Hence, we have that M⋆ is a CMrecovery 
of M and, therefore, we conclude, from the fact that M′ is a
CM-maximum recovery of M, that for every query Q in CM and every
instance I of S: certainM◦M⋆ (Q, I) ⊆ certainM◦M′ (Q, I). Thus,
we deduce that M′ fully recovers CM for M from the fact that M⋆
fully recovers CM for M. Hence, considering again Proposition 3, we
deduce that M′ is a quasi-inverse of M, which concludes the proof.

A.4 Proof of Theorem 3

(1) Assume that a mapping M′′ recovers sound information for M
under Q. Next we show that for every instance I of R1, it holds that
certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I).

Given that M′

is a maximum recovery of M, we have that
SolM◦M′ (I) 6= ∅ since (I, I) ∈ M ◦ M′. Let I ′ be an arbitrary
element of SolM◦M′ (I). From Proposition 3.8 (3) in [4] and the fact
that M′ is a maximum recovery of M, we conclude that SolM(I ′) ⊆
SolM(I). Thus, we have that SolM◦M′′ (I ′) ⊆ SolM◦M′′ (I) and,
hence, certainM◦M′′ (Q, I) ⊆ certainM◦M′′ (Q, I ′). Therefore,
given that M′′ recovers sound information for M under Q, we have
that certainM◦M′′ (Q, I ′) ⊆ Q(I ′), from which we conclude that
certainM◦M′′ (Q, I) ⊆ Q(I ′).

From the previous discussion, we conclude that for every instance
J ∈ SolM◦M′ (I), it is the case that certainM◦M′′ (Q, I) ⊆ Q(J).
Thus, we have that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I),
which was to be shown.

(2) Assume that there exists a mapping M′′ that fully recovers
Q for M. Next we show that this fact implies that M′ fully recovers 
Q for M. Let I be an instance of R1. We need to show that
Q(I) = certainM◦M′ (Q, I). Given that M′ is a maximum recovery 
of M, it holds that certainM◦M′ (Q, I) ⊆ Q(I) and, hence, we
only need to show that Q(I) ⊆ certainM◦M′ (Q, I). Given that M′′

fully recovers Q for M, we have that M′′ recovers sound information
for M under Q and, hence, we conclude by (1) that for every instance
I ′ of R1: certainM◦M′′ (Q, I ′) ⊆ certainM◦M′ (Q, I ′). In particular,
 we have that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I).
Thus, we deduce that Q(I) ⊆ certainM◦M′ (Q, I) since Q(I) =
certainM◦M′′ (Q, I) (given that M′′ fully recovers Q for M). This
concludes the proof of the theorem.

A.5 Proof of Proposition 4

First notice that since M′ is a maximum recovery of M, from Theorem 
3 we have that M′ is a C-maximum recovery of M.

(1) Assume that (M ◦ M′′) ≡C (M ◦ M′). Then by deﬁnition
of C-equivalence, we have that for every query Q ∈ C over R1 and instance 
I of R1: certainM◦M′ (Q, I) = certainM◦M′′ (Q, I). Thus,
from the fact that M′ is a C-maximum recovery of M, we conclude
that M′′ is a C-maximum recovery of M.

To prove the opposite direction, assume that M′′ is a C-maximum
recovery of M. Since M′ is also a C-maximum recovery of M, we
obtain that for every instance I of R1 and query Q ∈ C over R1,
it holds that certainM◦M′ (Q, I) = certainM◦M′′ (Q, I). Hence,
(M ◦ M′′) ≡C (M ◦ M′).

(2) Assume that M′′ ≡C M′. Next we show that (M ◦ M′′) ≡C
(M ◦ M′), from which we conclude that M′′ is a C-maximum recovery 
of M, given the fact proved in (1) and that M′ is a maximum
recovery of M. Let I be an instance of R1 and Q a query in C over R1.
Next we show that certainM◦M′′ (Q, I) = certainM◦M′ (Q, I),
from which we conclude that (M ◦ M′′) ≡C (M ◦ M′).

We show ﬁrst that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I).
Let ¯a ∈ certainM◦M′′ (Q, I), and assume that J is an instance
of R1 such that (I, J) ∈ M ◦ M′. Then there exists an instance
K of R2 such that (I, K) ∈ M and (K, J) ∈ M′. Given that
M′ ≡C M′′ and SolM′ (K) 6= ∅, we conclude that SolM′′ (K) 6=
∅. Thus, given that ¯a ∈ certainM◦M′′ (Q, I) and (I, K) ∈ M,
we obtain that ¯a ∈ certainM′′ (Q, K). Hence, from the fact that
M′ ≡C M′′, we conclude that ¯a ∈ certainM′ (Q, K). Therefore,
 given that (K, J) ∈ M′, we have that ¯a ∈ Q(J). We have
proved that for every instance J of R1 such that (I, J) ∈ M ◦
M′, it holds that certainM◦M′′ (Q, I) ⊆ Q(J). Hence, we obtain
that certainM◦M′′ (Q, I) ⊆ certainM◦M′ (Q, I), which was to be
shown.

By using a similar argument as in the previous paragraph, we
obtain that certainM◦M′ (Q, I) ⊆ certainM◦M′′ (Q, I). This concludes 
the proof of the proposition.

A.6 Proof of Lemma 1

One of the main tools used in this proof is the disjunctive chase deﬁned
by Fagin et al. [15]. Let Σ be a set of FOC-TO-UCQ dependencies
from schema R1 to schema R2. For every instance I of R1, let JI be
an instance of R2 constructed with the following procedure. For every
dependency σ ∈ Σ of the form

ϕ(¯x) → ∃¯y1 β1(¯x, ¯y1) ∨ · · · ∨ ∃¯yk β1(¯x, ¯yk)

with ¯x = (x1, . . . , xm) a tuple of distinct variables, and for every mtuple 
¯a of elements such that I |= ϕ(¯a), do the following. Choose an
index i ∈ {1, . . . , k}. Assume that ¯yi = (y1, . . . , yℓ), then choose an
ℓ-tuple ¯n of distinct fresh null values, and include all the conjuncts of
βi(¯a, ¯n) in JI . We call JI a chase of I with Σ. Notice that different
instances are obtained by different choices of indexes in the process.
Consider the set V = {J 1
I } of all the instances that correspond 
to a chase of I. Then we say that V is the (disjunctive) chase
of I with Σ, and write V = chaseΣ(I) [15]. As for the classical

I , . . . , J p

3

(non-disjunctive) chase, the disjunctive chase satisﬁes several desirable
properties. In particular, it can be shown, that for every pair of instances
I, J, if (I, J) |= Σ, then there exists an instance K ∈ chaseΣ(I) and
a homomorphism from K to J [15]. By using the results in [12], it is
also straightforward to prove that, if I is an instance composed only by
constant values and Q is a union of conjunctive queries, then the set of
certain answers of I under Σ, equals the set of tuples that belongs to
Q(K)↓, for all K ∈ chaseΣ(I).

We also make use of the following technical result proved in [15]
(Proposition 6.7). Assume that Γ1 is a set of FO-TO-CQ dependencies 
and Γ2 a set of CQC,6=-TO-UCQ dependencies. Let M1 be the
st-mapping speciﬁed by Γ1 and M2 the ts-mapping speciﬁed by Γ2.
In [15] the authors proved that, if I is a source instance, J the result of
chasing I with Γ1, and V = {K1, K2, . . . , Kℓ} the result of chasing
J with Γ2, then for every I ′ such that (I, I ′) ∈ M1 ◦ M2 there exists 
a homomorphism from some K ∈ V to I ′. By following the proof
in [15], one can see that the mentioned result also holds when Γ2 is
a set of CQC,6=-TO-UCQ6= dependencies, provided that the inequalities 
in the conclusions of the dependencies of Γ2 always mention an
existentially quantiﬁed variable (inequalities that mention existentially
quantiﬁed variables do not affect the normal chase procedure). Thus,
we can apply this result to Σ and Σ′′.

We continue now with the proof of the lemma. Recall that M′
is the mapping speciﬁed by Σ′ and is a maximum recovery of M.
We show now that M′′ is also a maximum recovery of M. For this
it is enough to show that M ◦ M′ = M ◦ M′′(see the deﬁnition
of maximum recovery in Section 4). First, it is straightforward to see
that, if (J, I) |= Σ′ then (J, I) |= Σ′′, from which we obtain that
M ◦ M′ ⊆ M ◦ M′′. Then it only remains to prove that M ◦ M′′ ⊆
M ◦ M′.

Before proving that M ◦ M′′ ⊆ M ◦ M′, we make the following
observation about Σ′′. Notice that for every dependency σ in Σ′′, and
for every variable x that simultaneously occurs in the premise and the
conclusion of σ, we have that C(x) occurs in the premise of σ. This
property is enough to conclude that, if (J, K) |= Σ′′ with J and K
arbitrary instances composed by constants and null values, and there
exists a homomorphism from K to K ′, then (J, K ′) |= Σ′′. That is,
Σ′′ is closed under target homomorphisms [13].

In order to prove that M◦M′′ ⊆ M◦M′, let (I1, I2) ∈ M◦M′′.
Assume that J is the result of chasing I1 with Σ, and V the result of
chasing J with Σ′′. From the discussion above, we know that there
exists an instance K ∈ V and a homomorphism from K to I2. We also
know that (J, K) |= Σ′′. Then given that Σ′′ is closed under target
homomorphisms, we have that (J, I2) |= Σ′′, and then (J, I2) ∈ M′′
since I2 is a valid source instance. We show now that (J, I2) |= Σ′
and then (J, I2) ∈ M′. Let σ be a dependency of Σ′ of the form
∃¯yψ(¯x, ¯y) ∧ C(¯x) → α(¯x) with ¯x = (x1, . . . , xn) a tuple of distinct
variables. Assume that there exists an n-tuple ¯a = (a1, . . . , an) of
elements from dom(J) such that J |= ∃¯yψ(¯a, ¯y) ∧ C(¯a). We have
to show that I2 |= α(¯a). Recall that Σ′ is the output of the algorithm 
MAXIMUMRECOVERY of [4] applied to Σ. It was shown in [4]
that, if J is the result of chasing I1 with Σ, then (J, I1) |= Σ′.
Then since J |= ∃¯yψ(¯a, ¯y) ∧ C(¯a), we have that I1 |= α(¯a).
Now, consider a partition π¯a of {x1, . . . , xn} constructed by considering 
the equivalence classes [xi]π ¯a = {xj
| aj = ai} for
1 ≤ i ≤ n. Notice that, by the construction of the partition π¯a, if
in the tuple fπ ¯a (¯x) = (fπ ¯a (x1), . . . , fπ ¯a (xn)) we assign to every
variable xj its corresponding value aj for 1 ≤ j ≤ n, we obtain
exactly the tuple ¯a. Also notice that this same assignment satisﬁes
the formula δπ ¯a . Then since I1 |= α(¯a) = β1(¯a) ∨ · · · ∨ βk(¯a),
we have that there exists an index i with 1 ≤ i ≤ k such that
βi(fπ ¯a (¯x)) ∧ δπ ¯a is satisﬁable by using the assignment xj → aj
for 1 ≤ j ≤ n. Then we know that dependency σπ ¯a of the form
∃¯yψ(fπ ¯a (¯x), ¯y) ∧ C(fπ ¯a (¯x)) ∧ δπ ¯a → α′(fπ ¯a (¯x)) is added to the set
Σ′′. Finally, since (J, I2) |= Σ′′ we know that (J, I2) |= σπ ¯a . Then
given that J satisﬁes the formula ∃¯yψ(¯a, ¯y)∧C(¯a)∧δπ ¯a we know that

4

I2 |= α′(¯a), and from this is straightforward to see that I2 |= α(¯a).
This was to be shown. Then since (I1, J) ∈ M and (J, I2) ∈ M′ we
obtain that (I1, I2) ∈ M ◦ M′.

We have shown that M ◦ M′ ⊆ M ◦ M′′ and that M ◦ M′′ ⊆
M ◦ M′, which implies that M ◦ M′ = M ◦ M′′. Then since M′
is a maximum recovery of M we obtain that M′′ is also a maximum
recovery of M. That is, we have that Σ′′ speciﬁes a maximum recovery
of M.

A.7 Proof of Lemma 2

In this proof we also use the notion of disjunctive chase introduced in
the proof of Lemma 1 in Section A.6. Recall that all the inequalities in
the disjuncts of the conclusions of the dependencies in Σ′′ are of the
form x 6= x′ where x or x′ is an existentially quantiﬁed variable. Also
notice that, when chasing an instance with Σ′′ we select a fresh null
value for every existentially quantiﬁed variable. These facts are enough
to conclude that the result of chasing with Σ′′ is the same as the result
of chasing with Σ′′′ (up to isomorphic images of null values). By using
this last property we can show that M′′′ is a UCQ-maximum recovery
of M.

We show now that M′′′ ≡UCQ M′′. Notice that from this fact and
since M′′ is a maximum recovery of M, we obtain from Proposition 4
that M′′′ is a UCQ-maximum recovery of M. First notice that the
domain of M′′ as well as the domain of M′′′ is the set of all target
instances (all the instances composed by constants and null values).
Then in order to prove that M′′′ ≡UCQ M′′, we need to show that for
every target instance J and every query Q that is a union of conjunctive
queries, it holds that certainM′′ (Q, J) = certainM′′′ (Q, J).

Let J be a target instance, and V = {K1, . . . , Kℓ} the result 
of chasing J with Σ′′. Notice that every dependency σ in Σ′′
is such that, for every variable x that occurs simultaneously in the
premise and the conclusion of σ, the atom C(x) also occurs in the
premise of σ. From this last fact and the properties of V, it follows directly 
from the results in [12] that certainM′′ (Q, J) = Q(K1)↓ ∩
· · · ∩ Q(Kℓ)↓, for every query Q that is a union of conjunctive
queries. Finally, since the result of chasing with Σ′′ is the same as
the result of chasing with Σ′′′, we have that certainM′′′ (Q, J) =
Q(K1)↓ ∩ · · · ∩ Q(Kℓ)↓ = certainM′′ (Q, J). Then we have that
certainM′′′ (Q, J) = certainM′′ (Q, J) for every target instance J
and union of conjunctive queries Q, and then M′′′ ≡UCQ M′′.

A.8 Proof of Lemma 4

In this proof we make use of another useful algebraic operation among
instances. The null-disjoint union of instances J1 and J2, denoted by
J1 ⊎ J2, is the instance constructed by ﬁrst renaming the nulls in J1
and J2 such that they do not share null values, and then taking the settheoretical 
union of the instances. The next lemma states an algebraic
property of × and ⊎ that we use in this proof.

Lemma 2 (c.f. [21]) Let J1, J2, and J3 be instances composed by
constant and null values. Then (J1 × J2) ⊎ J3 is homomorphically
equivalent to (J1 ⊎ J3) × (J2 ⊎ J3).

We show now that M⋆ ≡CQ M′′′. We prove ﬁrst the following.
Let J be an instance composed by null and constant values. Assume
that V = {K1, . . . , Kℓ} is the result of chasing J with Σ′′′, and K the
result of chasing J with Σ⋆. Then we claim that K is homomorphically
equivalent to K1 × · · · × Kℓ.

To prove the above mentioned property we ﬁrst reformulate the
process of chasing with Σ′′′ by using the operation ⊎ between instances.
 Recall that every dependency σ in Σ′′′ is of the form

ϕ(¯x) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) ∨ · · · ∨ βk(¯x).

Let J be an instance and consider the set AJ of all the pairs (¯a, σ) such
that: (1) ¯a is a tuple of elements in dom(J), (2) σ ∈ Σ′′′ is a dependency 
of the above form, and (3) J |= ϕ(¯a) ∧ C(¯a) ∧ δ(¯a). The idea is
that the set AJ contains all the possible assignments to the premises of
the dependencies in Σ′′′, such that the premises hold in J. Notice that,
if a pair (¯a, σ) belongs to AJ , then since C(¯a) ∧ δ(¯a) holds, we have
that ¯a is a tuple of distinct constant values. We deﬁne now the notion of
choice function. Consider a function f from AJ to the natural numbers,
such that for every (¯a, σ) it holds that f (¯a, σ) ∈ {1, . . . , k}, whenever
σ has k disjuncts in its conclusion. Choice functions are used to select
a particular disjunct when we apply a dependency to instance J while
computing a disjunctive chase. Let FJ be the set of all choice functions
with domain AJ . Notice that, since J is a ﬁnite instance and Σ′′′ is a
ﬁnite set of dependencies, AJ and FJ are ﬁnite sets. We need an additional 
notion. Given a conjunctive query β(¯x) and an assignment ¯a for
the variables ¯x, we denote by Iβ(¯a) the instance constructed by considering 
the atoms of β(¯a), where every existentially quantiﬁed variable
has been replaced by a fresh null value. We can formally deﬁne now
the process of chasing with Σ′′′ in terms of AJ and FJ .

For every f ∈ FJ we denote by Kf the instance:

Kf = ] {Iβi(¯a) | (¯a, σ) ∈ AJ , βi(¯x) is a disjunct

in the conclusion of σ, and i = f (¯a, σ)}.

It is clear that Kf as deﬁned above, is a chase of J with Σ′′′. Then the
(disjunctive) chase of J with Σ′′′ is the set V = {Kf | f ∈ FJ }.

We now reformulate the chase of J with Σ⋆ by using the operations 
⊎ and × between instances. Let σ be a dependency in Σ⋆ of the
form

ϕ(¯x) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) × · · · × βk(¯x).

Notice that, if ¯a is a tuple in dom(J) such that J |= ϕ(¯a)∧C(¯a)∧δ(¯a),
then the atoms of β1(¯a) × · · · × βk(¯a), where every existentially quantiﬁed 
variable has been replaced by a fresh null value, are added to
the chase of J with Σ⋆. That is, the instance Iβ1(¯a)×···×βk(¯a) is
added to the chase of J with Σ⋆. The crucial observation here is
that, since ¯a is a tuple of distinct constant values, then the instance
Iβ1(¯a)×···×βk(¯a), equals the product of instances Iβ1(¯a) ×· · ·×Iβk(¯a)
(up-to isomorphic image of null values). It should be noticed that
this last property does not hold if ¯a is a tuple where some values 
are repeated. For example, if β1(x1, x2) = R(x1, x1, x2) and
β2(x1, x2) = R(x1, x2, x2) then β1(x1, x2) × β2(x1, x2) is the
query ∃u R(x1, u, x2). Now if we consider tuple ¯a = (a, a), then we
have that Iβ1(a,a)×β2(a,a) is the instance {R(a, n, a)} with n a null
value, while Iβ1(a,a) × Iβ2(a,a) = {R(a, a, a)}. On the other hand if
we consider the tuple ¯a = (a, b) with a and b different values, we have
that Iβ1(a,b)×β2(a,b) = Iβ1(a,b) × Iβ2(a,b) = {R(a, m, b)} with m a
null value.

Consider A⋆

J the set of pairs deﬁned as for Σ′′′ but considering
the dependencies in Σ⋆. Notice that dependencies in Σ⋆ do not have
disjunctions, thus, to deﬁne the chase with Σ⋆ we do not need choice
functions as for Σ′′′. Then we can reformulate the chase of J with Σ⋆
in terms of A⋆

J , ⊎ and × as follows

K = ] {Iβ1(¯a) × · · · × Iβk(¯a) | (¯a, σ) ∈ A⋆

J and

β1(¯x) × · · · × βk(¯x) is the conclusion of σ}.

To conclude the proof of the claim, we must show that the product
of the instances in V = {Kf | f ∈ FJ }, is homomorphically equivalent 
to instance K above. Fix a pair (¯a′, σ′) in AJ and assume that
k′ (¯x′) is the conclusion of σ′. Notice that, if for a
β′
1(¯x′) ∨ · · · ∨ β′
particular function f ′ ∈ FJ it is the case that f ′(¯a′, σ′) = i′, then we

can write Kf ′ as

Iβ′

i′ (¯a′) ⊎ (cid:18) ] {Iβi(¯a) | (¯a, σ) ∈ AJ r {(¯a′, σ′)}, βi(¯x)

is a disjunct in σ, and i = f ′(¯a, σ)} (cid:19).

In the above expression we have separated the pair (¯a′, σ′) from AJ
and thus, since f ′(¯a′, σ′) = i′ we have to explicitly include instance
i′ (¯a′) in the union that deﬁnes Kf ′ . Notice that every function f ∈
Iβ′
FJ can be seen as a choice function over domain AJ r {(¯a′, σ′)} plus
an assignment for (¯a′, σ′) in the set {1, . . . , k′}. Then we can write the
product of all the instances in V = {Kf | f ∈ FJ } as

k′
×

f ∈FJ

i′ (¯a′) ⊎

(cid:20) Iβ′

i′=1(cid:20) ×
(cid:18) ] {Iβi(¯a) | (¯a, σ) ∈ AJ r {(¯a′, σ′)}, βi(¯x)

is a disjunct in σ, and i = f (¯a, σ)}(cid:19) (cid:21) (cid:21).

Thus, we consider separately every one of the possible choices (between 
1 and k′) that the functions in FJ can make for the pair (¯a′, σ′).
By applying Lemma 2, we know that the above instance is homomorphically 
equivalent to

k′
×

i′ (¯a′) ⊎

i′=1(cid:20) Iβ′
(cid:18) ×
f ∈FJ ] {Iβi(¯a) | (¯a, σ) ∈ AJ r {(¯a′, σ′)}, βi(¯x)

is a disjunct in σ, and i = f (¯a, σ)}(cid:19) (cid:21).

By applying Lemma 2 again, we obtain that this last instance is homomorphically 
equivalent to

(cid:0)Iβ′
1(¯a′) × · · · × Iβ′
(cid:18) ×
f ∈FJ ] {Iβi(¯a) | (¯a, σ) ∈ AJ r {(¯a′, σ′)}, βi(¯x)

k′ (¯a′)(cid:1) ⊎

is a disjunct in σ, and i = f (¯a, σ)}(cid:19).

If we continue separating one by one the elements in AJ , we ﬁnally
obtain that the above instance is homomorphically equivalent to

] {Iβ1(¯a) × · · · × Iβk(¯a) | (¯a, σ) ∈ AJ and

β1(¯x) ∨ · · · ∨ βk(¯x) is the conclusion of σ}.

It is straightforward to see that this last instance is homomorphically
equivalent to K. Just notice that, if for a dependency σ ∈ Σ′′′ of the
form ϕ(¯x) ∧ C(¯x) ∧ δ(¯x) → β1(¯x) ∨ · · · ∨ βk(¯x), we do not include a
corresponding dependency in Σ⋆, then β1(¯x) × · · · × βk(¯x) is empty,
which implies that Iβ1(¯a) × · · · × Iβk(¯a) is the empty instance for
every tuple ¯a of distinct constant values. Thus we have shown that K is
homomorphically equivalent to K1×· · ·×Kℓ with V = {K1, . . . , Kℓ}
the result of chasing J with Σ′′′. This completes the proof of the claim.
We are ready now to prove that M⋆ ≡CQ M′′′. Let J be a target
instance (composed by constant and null values), V = {K1, . . . , Kℓ}
the result of chasing J with Σ′′′, and K the result of chasing J

5

with Σ⋆. Notice that every dependency σ in Σ′′′ is such that for
every variable x that occurs simultaneously in the premise and the
conclusion of σ, the atom C(x) also occurs in the premise of σ.
From this last fact and the properties of V, it follows directly that
certainM′′′ (Q, J) = Q(K1)↓ ∩ · · · ∩ Q(Kℓ)↓, for every conjunctive 
query Q. Similarly, for M⋆ we have that, for every conjunctive
query it holds that certainM⋆ (Q, J) = Q(K)↓. Then we only have
to prove that Q(K)↓ = Q(K1)↓ ∩· · ·∩Q(Kℓ)↓, for every conjunctive
query Q. Let Q be an n-ary conjunctive query with free variables ¯x. We
ﬁrst show that Q(K)↓ ⊆ Q(K1)↓ ∩ · · · ∩ Q(Kℓ)↓. Let ¯a be an n-ary
tuple such that ¯a ∈ Q(K)↓. Since K is homomorphically equivalent
to the product K1 × . . . Kℓ we know that there exists a homomorphism
from K to every Ki with 1 ≤ i ≤ ℓ, and then ¯a ∈ Q(Ki)↓ for every
1 ≤ i ≤ ℓ. Now, to show that Q(K1)↓ ∩ · · · ∩ Q(Kℓ)↓ ⊆ Q(K)↓, assume 
that ¯a ∈ Q(K1)↓ ∩ · · · ∩ Q(Kℓ)↓. Then we know that, for every
Ki with 1 ≤ i ≤ ℓ there exists a homomorphism h from the atoms in
Q to Ki, such that h(¯x) = ¯a. Then by the properties of the product of
instances (see Lemma 3), we know that there exists a homomorphism
h′ from the atoms in Q to K, such that h(¯x) = ¯a, and thus, since ¯a is
a tuple of constant values, we obtain that ¯a ∈ Q(K)↓. We have shown
that Q(K)↓ = Q(K1)↓ ∩ · · · ∩ Q(Kℓ)↓ for every conjunctive query
Q, which implies that M⋆ ≡CQ M′′′. This concludes the proof.

A.9 Proof of Theorem 6

(1) Let S = {A(·, ·), B(·, ·)}, T = {P (·, ·)} and M = (S, T, Σ),
where Σ = {A(x, y) → P (x, y), B(x, x) → P (x, x)}. Next we
show that M does not have a CQ-maximum recovery speciﬁed by a
set of CQC-TO-CQ dependencies.

For the sake of contradiction, assume that there exists a mapping
M′ speciﬁed by a set Σ′ of CQC-TO-CQ dependencies such that M′
is a CQ-maximum recovery of M. Next we show that this leads to a
contradiction by considering two cases.
(I) Assume that Σ′ is empty. Then, for every instance J of T and K
of S, we have that (J, K) |= Σ′. Thus, by the deﬁnition of Σ, we
conclude that for every pair of source instances I and I ′, it holds that
(I, I ′) ∈ M ◦ M′. Let M′′ be a ts-mapping speciﬁed by dependency
P (x, y) ∧ x 6= y → A(x, y). It is straightforward to prove that M′′ is
a recovery of M, which implies that M′′ is a CQ-recovery of M.
Consider now instance I = {A(a, b), B(a, b)} where a 6= b, and
Boolean query Q = ∃x∃y A(x, y). We have that Q(I) = true =
certainM◦M′′ (Q, I) but certainM◦M′ (Q, I) = false, and thus
certainM◦M′′ (Q, I) 6⊆ certainM◦M′ (Q, I) which is a contradiction 
with our assumption that M′ is a CQ-maximum recovery of M.

(II) Assume that Σ′ is nonempty. Consider the source instances I1 =
{A(a, a)} and I2 = {B(a, a)}, and let J = {P (a, a)}. Notice that
J is the canonical universal solution for both I1 and I2 under Σ. Assume 
that K is the result of chasing J with Σ′. Notice that K could
not be a valid source instance (it may contain null values). Nevertheless,
 since J is composed only by constant values, and by using the
properties of the chase [12, 14, 15], we know that for every Q that is
a union of conjunctive queries, it holds that certainM◦M′ (Q, I1) =
certainM◦M′ (Q, I2) = Q(K)↓. We use this last fact and the fact
that Σ′ is nonempty, to derive a contradiction.

Given that Σ′ is nonempty, there exists a CQC-TO-CQ dependency 
ϕ(x1, . . . xm) → ∃y1 · · · ∃yn ψ(x1, . . . , xm, y1, . . . , yn) that
belongs to Σ′. Thus, we have that (J, K) satisﬁes this constraint.
But this implies that K is nonempty since J = {P (a, a)} and J |=
ϕ(a, . . . , a) (since a is a constant and ϕ is a query in CQC over T).

Given that K is nonempty, we have that AK 6= ∅ or BK 6= ∅.
If AK 6= ∅, then let QA be Boolean query ∃x∃yA(x, y). We know
that certainM◦M′ (QA, I2) = QA(K). Thus, given that AK 6= ∅,
we conclude that certainM◦M′ (QA, I2) = true. But this leads to a

6

contradiction since we assume that M′ is a CQ-recovery of M and
QA(I2) = false. If BK 6= ∅, then we obtain a similar contradiction by
considering Boolean query QB = ∃x∃yB(x, y) and source instance
I1. This concludes the proof of the ﬁrst part of the theorem.

(2) Let S = {A(·), B(·)}, T = {P (·)} and M = (S, T, Σ), where
Σ is the following set of st-tgds:

Σ = {A(x) → ∃yP (y), B(x) → P (x)}.

Next we show that M does not have a CQ-maximum recovery speciﬁed 
by a set of CQ6=-TO-CQ dependencies. For the sake of contradiction,
 assume that M′ is a mapping speciﬁed by a set Σ′ of
CQ6=-TO-CQ dependencies such that M′ is a CQ-maximum recovery 
of M.

Let M⋆ be a mapping (T, S, Σ⋆), where Σ⋆ is the set of ts-tgds
{P (x) ∧ C(x) → B(x)}. Next we show that M⋆ is a CQ-recovery of
M. Let I be an instance of S and Q a conjunctive query over S, and
assume that J = chaseΣ⋆ (chaseΣ(I)). It is straightforward to prove
that AJ = ∅ and BJ = BI . Thus, we have that J ⊆ I, which implies
that Q(J) ⊆ Q(I). Given that J ∈ SolM◦M⋆ (I) in this case, we
conclude that certainM◦M⋆ (Q, I) ⊆ Q(I), which implies that M⋆
is a CQ-recovery of M.

It

Let I1 and I2 be instances of S such that I1 = {A(a)}
and I2 = {B(a)}, where a is an arbitrary element of C,
and QB be Boolean query ∃xB(x).
is straightforward to
prove that certainM◦M⋆ (QB , I2) = true. Thus, we have that
certainM◦M′ (QB , I2) = true since M⋆ is a CQ-recovery of M
and M′ is a CQ-maximum recovery of M. Next we use this fact to
prove that certainM◦M′ (QB , I1) = true. Let J ∈ SolM◦M′ (I1).
Then there exists an instance K of T such that (I1, K) |= Σ and
(K, J) |= Σ′. Let f : dom(K) ∪ dom(J) → C be a one-to-one
mapping such that f (u) = a for some u ∈ dom(K). We note that
such a function exists since K is not empty. By the deﬁnition of Σ,
we have that (I2, f (K)) |= Σ. Furthermore, given that Σ′ is a set
of CQ6=-TO-CQ dependencies, we have that (f (K), f (J)) |= Σ′.
Thus, we have that (I2, f (J)) ∈ M ◦ M′, from which we conclude
that f (J) |= ∃xB(x) (since certainM◦M′ (QB , I2) = true). Therefore,
 given that J and f (J) are isomorphic instances (not considering
predicate C), we have that J |= ∃xB(x). We conclude that for every
J ∈ SolM◦M′ (I1), it holds that J |= ∃xB(x). Thus, we have that
certainM◦M′ (QB , I1) = true. But this leads to a contradiction since
QB(I1) = false and M′ is assumed to be a CQ-maximum recovery
of M. This concludes the proof of the theorem.

A.10 Proof of Proposition 5

In order to prove (1), let S = {A(·), B(·), C1(·), C2(·)}, T =
{R1(·), R2(·)}, and M = (S, T, Σ) an st-mapping speciﬁed by the
following set Σ of CQ-TO-UCQ st-dependencies:

B(x) ∧ C1(x) → R1(x),
B(x) ∧ C2(x) → R2(x),

A(x) → R1(x) ∨ R2(x).

We show next that M does not have a CQ-maximum recovery. In order
to obtain a contradiction, assume that M′ is a CQ-maximum recovery
of M. Let M1 be the mapping from T to S given by dependency
R1(x) → C1(x) ∧ B(x). It is not difﬁcult to see that M1 is a CQrecovery 
of M. Just notice that for every instance I of S we have that
J = {R1(a) | B(a) ∈ I and C1(a) ∈ I} ∪ {R2(a) | A(a) ∈ I} is
in SolM(I). Moreover, I ∈ SolM1 (J), and thus I ∈ SolM◦M1 (I)
which implies that certainM◦M1 (Q, I) ⊆ Q(I) for every query Q.
Similarly, for the mapping given by dependency R2(x) → C2(x) ∧
B(x), we have that M2 is a CQ-recovery of M. Thus, since M′ is a

CQ-maximum recovery of M, we have that for every instance I of S
and conjunctive query Q it holds that

certainM◦M1 (Q, I) ⊆ certainM◦M′ (Q, I) ⊆ Q(I), and
certainM◦M2 (Q, I) ⊆ certainM◦M′ (Q, I) ⊆ Q(I).

(1)

(2)

Let I1 = {B(a), C1(a)}, and Q1 the query in CQ given by
B(x) ∧ C1(x). Notice that certainM◦M1 (Q1, I1) = Q1(I1) = {a}
and thus, from (1), we have that certainM◦M′ (Q1, I1) = {a}.
Therefore, we have that for every instance J ∈ SolM◦M′ (I1) it
holds that {B(a), C1(a)} ⊆ J. Similarly, for the instance I2 =
{B(a), C2(a)} and query Q2 given by B(x) ∧ C2(x), we have that
certainM◦M2 (Q2, I2) = Q2(I2) = {a} and thus, from (2), we have
certainM◦M′ (Q2, I2) = {a}, which implies that for every instance
J ∈ SolM◦M′ (I2) it holds that {B(a), C2(a)} ⊆ J.

Consider now instance I3 = {A(a)}. It is not difﬁcult to see that
SolM(I3) = SolM(I1) ∪ SolM(I2), and thus SolM◦M′ (I3) =
SolM◦M′ (I1) ∪ SolM◦M′ (I2). We have shown before that every instance 
in SolM◦M′ (I1) contains the facts B(a), C1(a) and that every 
instance in SolM◦M′ (I2) contains the facts B(a), C2(a), which
implies that every instance in SolM◦M′ (I3) = SolM◦M′ (I1) ∪
SolM◦M′ (I2) contains the fact B(a). Thus consider the query
Q in CQ given by B(x). By the discussion above we have that
certainM◦M′ (Q, I3) = {a} but Q(I3) = ∅ which is a contradiction 
with the assumption that M′ is a CQ-recovery of M.
the Proposition,

let S =
{A(·), B(·), C1(·), C2(·)}, T = {R(·, ·)}, and M = (S, T, Σ)
an st-mapping speciﬁed by the following set Σ of CQ-TO-CQ6= st-
dependencies:

Now to prove property (2) of

B(x) ∧ C1(x) → R(x, x),
B(x) ∧ C2(x) → ∃y(R(x, y) ∧ x 6= y),

A(x) → ∃yR(x, y).

We show next that M does not have a CQ-maximum recovery. In order 
to obtain a contradiction, assume that M′ is a CQ-maximum recovery 
of M. Let M1 be the mapping from T to S given by dependency 
R(x, x) → C1(x) ∧ B(x), and M2 given by R(x, y) ∧ x 6=
y → C2(x) ∧ B(x). As for the case (1), it is not difﬁcult to prove
that M1 and M2 are CQ-recoveries of M. If we consider instances
I1 = {B(a), C1(a)}, I2 = {B(a), C2(a)}, and I3 = {A(a)}, exactly 
as for part (1), it can be shown that B(a) is a fact in every solution 
in SolM◦M′ (I1) ∪ SolM◦M′ (I2), and that SolM◦M′ (I3) =
SolM◦M′ (I1) ∪ SolM◦M′ (I2), which implies that for the conjunctive 
query Q(x) = B(x) it holds that certainM◦M′ (Q, I3) = {a}
but Q(I3) = ∅, which is our desired contradiction. This concludes the
proof of the proposition.

A.11 Proof of Proposition 6

Let S = {A(·), B(·)}, T = {T (·)} and M = (S, T, Σ), where
Σ = {A(x) → T (x), B(x) → T (x)}.

(a) Let M⋆ = (T, S, Σ⋆) where Σ⋆ is the set of CQ-TO-UCQ dependencies


Σ⋆ = {T (x) → A(x) ∨ B(x)}.

By using the tools in [4], it is easy to show that M⋆ is a maximum
recovery of M, which implies that M⋆ is a UCQ-maximum recovery
of M.

(b) For the sake of contradiction, assume that there exists a mapping
M′ speciﬁed by a set Σ′ of FOC-TO-CQ dependencies such that M′
is a UCQ-maximum recovery of M. Moreover, let I1 be an instance
of S such that:

7

Then since J is composed only by constant values and Σ′ is a set of
FOC-TO-CQ, we have that every instance K ′ that is a homomorphic
image of K, is such that (J, K ′) |= Σ′. Consider the homomorphism
h that maps every null in K into a. Notice that h(K) is composed
only by constant values and that (J, h(K)) |= Σ′, then (J, h(K)) ∈
M′. Thus, we have that (I, h(K)) ∈ M ◦ M′. Now, let Q be the
query in CQ6= given by ∃x∃y (P (x, y) ∧ x 6= y). From (3), we have
that P h(K) ⊆ {(a, a)} and, hence, Q(h(K)) = false. We conclude
that certainM◦M′ (Q, I) = false. Now, it is easy to prove that for
M⋆ deﬁned in (a), we have certainM◦M⋆ (Q, I) = true. Therefore,
we have that certainM◦M′ (Q, I) ( certainM◦M⋆ (Q, I) = Q(I),
which contradicts the fact that M′ is a CQ6=-maximum recovery of
M since M⋆ is a CQ6=-recovery of M. This concludes the proof of
the proposition.

AI1
BI1

=
=

{a},
{b},

where a, b are distinct constants. First, we prove that for every instance
I2 ∈ SolM◦M′ (I1), it holds that a ∈ AI2 or a ∈ BI2 . For the
sake of contradiction, assume that I2 does not satisfy this condition.
Then let Q1(x) be the query A(x) ∨ B(x), and assume that M⋆ is
the mapping deﬁned in (a). We have that a 6∈ Q1(I2) and, therefore,
a 6∈ certainM◦M′ (Q1, I1). On the other hand, we have by deﬁnition
of M⋆ that a ∈ certainM◦M⋆ (Q1, I1). Thus, we conclude that M′
is not a UCQ-maximum recovery of M, as M⋆ is a UCQ-recovery
of M and certainM◦M⋆ (Q1, I1) 6⊆ certainM◦M′ (Q1, I1), which
contradicts our initial assumption.

Second, we prove that for every instance I2 ∈ SolM◦M′ (I1),
it holds that a, b ∈ AI2 or a, b ∈ BI2 . Let I2 ∈ SolM◦M′ (I1)
and assume that J is an instance of T such that (I1, J) ∈ M and
(J, I2) ∈ M′. Moreover, assume that K is the result of chasing J with
Σ′. By the result in the previous paragraph, we have that a ∈ AK
or a ∈ BK . Assume without loss of generality that a ∈ AK . Then
there exists a dependency ϕ(¯x) → ψ(¯x) in Σ′ and a tuple ¯c of elements 
from J such that J |= ϕ(¯c) and A(a) is a conjunct in ψ(¯c).
Thus, given that (J, I2) |= Σ′ and ψ(¯x) is a conjunctive query, we
conclude that a ∈ AI2 . Let f : dom(J) → dom(J) be a bijection 
deﬁned as f (a) = b, f (b) = a and f (c) = c for every
c ∈ (dom(J) \ {a, b}). Given that a, b are constants, we have that
f is an automorphism of J. Therefore, given that ϕ(¯x) is a of formula
in FOC (recall that Σ′ is a set of FOC-TO-CQ dependencies), we conclude 
that J |= ϕ(f (¯c)), where f (¯c) is the tuple obtained by replacing
each element c in ¯c by its image f (c). We conclude that I2 |= ψ(f (¯c))
since (J, I2) |= Σ′. Thus, given that A(a) is a conjunct in ψ(¯c), we
have that A(f (a)) = A(b) is a conjunct in ψ(f (¯c)) and, therefore,
b ∈ AI2 (since ψ(¯x) is a conjunctive query). Hence, from the assumption 
that a ∈ AK , we have proved that a, b ∈ AI2 (analogously, from
the assumption that a ∈ BK , it is possible to prove that a, b ∈ BI2 ),
which was to be shown.

Now let Q2(x, y) be the query (A(x) ∧ A(y)) ∨ (B(x) ∧
B(y)). In the previous paragraph, we prove that for every instance
I2 ∈ SolM◦M′ (I1), it holds that a, b ∈ AI2 or a, b ∈ BI2 ,
from which we conclude that (a, b) ∈ certainM◦M′ (Q2, I1). But
(a, b) 6∈ Q2(I1) as AI1 = {a} and BI1 = {b}, which implies that
certainM◦M′ (Q2, I1) 6⊆ Q2(I1). Therefore, we have that M′ is
not a UCQ-recovery of M, which contradicts our assumption that M′
is a UCQ-maximum recovery of M. This concludes the proof of the
proposition.

A.12 Proof of Proposition 7

Let S = {P (·, ·)}, T = {T (·)} and M = (S, T, Σ), where Σ is the
following set of CQ6=-TO-CQ dependencies:

Σ = {P (x, y) ∧ x 6= y → T (x)}.

(a) Let M⋆ = (T, S, Σ⋆) be a ts-mapping speciﬁed by the following
set of CQ-TO-CQ6= dependencies:

Σ⋆ = {T (x) → ∃y (P (x, y) ∧ x 6= y)}.

By using the tools in [4] it is easy to prove that M⋆ is a maximum
recovery of M, and thus M⋆ is a CQ6=-maximum recovery of M.

We now prove (b). For the sake of contradiction, assume that there
exists a mapping M′ speciﬁed by a set of FOC-TO-CQ dependencies
such that M′ is a CQ6=-maximum recovery of M. Moreover, let I be
an instance of S such that P I = {(a, b)}, where a 6= b, and J a target
instance such that T J = {a}. Then we have that (I, J) |= Σ, and
then (I, J) ∈ M. Let K be the chase of J with Σ′. Thus, given that
dom(J) = {a}, we have that

dom(K) ∩ C ⊆ {a}.

(3)

