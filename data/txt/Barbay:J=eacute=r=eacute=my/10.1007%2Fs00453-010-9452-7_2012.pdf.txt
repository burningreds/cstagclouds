Algorithmica (2012) 62:224–257
DOI 10.1007/s00453-010-9452-7

Succinct Representation of Labeled Graphs

Jérémy Barbay · Luca Castelli Aleardi · Meng He ·
J. Ian Munro

Received: 19 January 2009 / Accepted: 2 September 2010 / Published online: 16 September 2010
© Springer Science+Business Media, LLC 2010

Abstract In many applications, the properties of an object being modeled are stored
as labels on vertices or edges of a graph. In this paper, we consider succinct representation 
of labeled graphs. Our main results are the succinct representations of
labeled and multi-labeled graphs (we consider planar triangulations, planar graphs
and k-page graphs) to support various label queries efﬁciently. The additional space
cost to store the labels is essentially the information-theoretic minimum. As far as we
know, our representations are the ﬁrst succinct representations of labeled graphs. We
also have two preliminary results to achieve the main contribution. First, we design
a succinct representation of unlabeled planar triangulations to support the rank/select
of edges in ccw (counter clockwise) order in addition to the other operations supported 
in previous work. Second, we design a succinct representation for a k-page

The preliminary version of this paper was published in Proceedings of the 18th International
Symposium on Algorithms and Computation (ISAAC 2007) [1]. This work was supported by
NSERC of Canada, the Canada Research Chairs program, the ERC under the agreement “ERC StG
208471—ExploreMap”. The work was done when the ﬁrst author was in Cheriton School of
Computer Science, University of Waterloo, Canada, and part of the second author’s work was done
during his visit to the Computer Science Department of Université Libre de Bruxelles, Belgium.

J. Barbay
Department of Computer Science (DCC), University of Chile, Santiago, Chile
e-mail: jeremy.barbay@dcc.uchile.cl

L. Castelli Aleardi
LIX, Ecole Polytechnique, Palaiseau, France
e-mail: amturing@lix.polytechnique.fr
M. He ((cid:2)) · J.I. Munro
Cheriton School of Computer Science, University of Waterloo, 200 University Avenue West,
Waterloo, Ontario, N2L 3G1 Canada
e-mail: mhe@uwaterloo.ca

J.I. Munro
e-mail: imunro@uwaterloo.ca

Algorithmica (2012) 62:224–257

225

graph when k is large to support various navigational operations more efﬁciently. In
particular, we can test the adjacency of two vertices in O(lg k) time, while previous
work uses O(k) time.
Keywords Succinct data structures · Data structures · Graph · Planar graph · Planar
triangulation · Book embedding · k-page graph

1 Introduction

Graphs are fundamental combinatorial objects in mathematics and in computer science.
 They are widely used to represent various types of data, such as the link structure 
of the web, geographic maps, and surface meshes in computer graphics. As modern 
applications often process large graphs, the problem of designing space-efﬁcient
data structures to represent graphs has attracted a great deal of attention. In particular
the idea of succinct data structures has been applied to various classes of graphs [6–
10, 18, 22].

Previous work focused on succinct graph representations which efﬁciently support 
testing the adjacency between two vertices and listing the edges incident with
a vertex [7, 8, 22]. However, in many applications, such connectivity information is
associated with labels on the edges or vertices of the graph, and the space required to
encode those labels dominates the space used to encode the connectivity information,
even when the encoding of the labels is compressed [17]. For example, when surface
meshes are associated with properties such as color and texture information, more
bits per vertex are required to encode those labels than to encode the graph itself. We
address this problem by designing succinct representations of labeled graphs, where
labels from alphabet [σ]1 are associated with edges or vertices. These representations
support label-based connectivity queries efﬁciently, such as retrieving the neighbors
associated with a given label. Our results are under the word RAM model with word
size (lg n) bits. We assume that all the graphs are simple graphs.

We investigate three important classes of graphs: planar triangulations, planar
graphs and k-page graphs. Planar graphs, and in particular planar triangulations,
correspond to the connectivity information underlying surface meshes. Triangulated
meshes are one of the most fundamental representations for geometric objects: in
computational geometry they are one natural way to represent surface models, and
in computer graphics triangles are the basic geometric primitive for efﬁcient rendering.
 k-page graphs have applications in several areas, such as sorting with parallel
stacks [28], fault-tolerant processor arrays [26] and VLSI (very large scale integra-
tion) design [11].

The rest of the paper is organized as follows. Section 2 gives a brief review of previous 
work. We describe existing results that we use and/or improve upon in Sect. 3.
In Sect. 4, we present succinct indexes for triangulated planar graphs with labels associated 
with their vertices or edges, and use them to design succinct indexes for

1We use [σ] to denote the set {1, 2, . . . , σ} of references to arbitrary labels, as indeed the alphabet of
labels.

226

Algorithmica (2012) 62:224–257

multi-labeled general planar graphs. To achieve these results, we describe a succinct
representation of unlabeled planar triangulations which supports the rank/select of
edges in ccw (counter clockwise) order in addition to the other operations supported
in previous work. We present a succinct encoding for k-page graphs with labels associated 
with their edges in Sect. 5. To achieve this result, we design a succinct representation 
for a k-page graph when k is large, which supports various navigational
operations more efﬁciently. We conclude with a discussion of our results in Sect. 6.

2 Previous Work

Here we brieﬂy review related work on succinct unlabeled graphs. As graphs in practice 
often have particular combinatorial properties, researchers usually exploit these
properties to design succinct representations.

Jacobson [18] was the ﬁrst to propose a succinct representation of planar graphs.
His approach is based on the concept of book embedding by Bernhart and Kainen [5].
A k-page embedding is a topological embedding of a graph with the vertices along the
spine and edges distributed across k pages, each of which is an outerplanar graph. The
minimum number of pages, k, for a particular graph has been called the pagenumber
or book thickness. Jacobson showed how to represent a k-page graph using O(kn)
bits to support adjacency tests in O(lg n) bit probes,2 and listing the neighbors of a
vertex x in O(d(x) lg n + k) bit probes, where d(x) is the degree of x.
Munro and Raman [22] improved Jacobson’s results under the word RAM model
by showing how to represent a graph using 2kn + 2m + o(kn + m) bits to support 
adjacency tests and the computation of the degree of a vertex in O(k) time,
and the listing of all the neighbors of a given vertex in O(d + k) time. Gavoille
and Hanusse [14] proposed a different tradeoff. They proposed an encoding in
2(m + i) lg k + 4(m + i) + o(km) bits, where i is the number of isolated vertices,
to support the adjacency test in O(k) time. As any planar graph can be embedded
in at most 4 pages [30], these results can be applied to planar graphs directly. In
particular, a planar graph can be represented using 8n + 2m + o(n) bits to support
adjacency tests and the computation of the degree of a vertex in O(1) time, and the
listing of all the neighbors of a given vertex x in O(d(x)) time (i.e. constant time per
neighbor) [22].

A different line of research based on the spanning trees of planar graphs was taken
by Chuang et al. [10]. They designed a succinct representation of planar graphs of n
vertices and m edges in 2m + (5 + )n + o(m + n) bits, for any constant  > 0, to
support the operations on planar graphs in asymptotically the same amount of time as
the approach described in the previous paragraph. Chiang et al. [9] further reduced the
space cost to 2m+2n+ o(m+ n) bits. When a planar graph is triangulated, Chuang et
al. [10] showed how to represent it using 2m + n + o(m + n) bits. Yamanaka and
Nakano [29] further showed how to represent a planar triangulation using 2m+ o(m)
bits to provide the same support for operations.

2We use log2 x to denote the logarithmic base 2 and lg x to denote (cid:2)log2 x(cid:3). Occasionally this matters.

Algorithmica (2012) 62:224–257

227

Based on a partition algorithm, Castelli Aleardi et al. [7] proposed a succinct representation 
of planar triangulations with a boundary. Their data structure uses 2.175
bits per triangle to support various operations efﬁciently. Castelli Aleardi et al. [8] further 
extended this approach to design succinct representations of 3-connected planar
graphs and triangulations using 2 bits per edge and 1.62 bits per triangle respectively,
which asymptotically match the respective entropy of these two types of graphs.

Blandford et al. [6] considered the problem of representing graphs with small
separators (the graph separator considered in their main result is a vertex separator,
 i.e. a set of vertices whose removal separates the graph into two approximately
equally sized parts). This is useful because many graphs in practice, including planar 
graphs [20], have small separators. They designed a succinct representation using
O(n) bits that supports adjacency tests and the computation of the degree of a vertex
in O(1) time, and the listing of all the neighbors of a given vertex x in O(d(x)) time.
Finally, Farzan and Munro [13] considered general directed graphs, and showed
(cid:2)
how to represent a directed graph using (1+ )
bits, for any arbitrarily small
constant  > 0, to support adjacency tests and the computation of the degree of a vertex 
in O(1) time, as well as the listing of the neighbors of a vertex x in O(d(x)) time.
This space cost is within a multiplicative 1 +  factor of the information-theoretic
lower bound. They also showed that it is impossible to represent a directed graph
bits to provide the same support for operations, by proving
using lg
a lower bound for this problem. Similar upper and lower bounds can be proved for
undirected graphs.

(cid:3) + o

(cid:2)
n2
m

(cid:2)
n2
m

(cid:2)
lg

(cid:3)(cid:3)

(cid:2)
n2
m

lg

(cid:3)(cid:3)

3 Preliminaries

3.1 Bit Vectors

A key structure for the design of many succinct data structures, and for the research
work in this paper, is a bit vector B of length n supporting rank and select operations.
The positions in B are numbered 1, 2, . . . , n. We consider the following operations
for α ∈ {0, 1}:
– rankB (α, x), the number of occurrences of α in B[1..x];
– selectB (α, r), the position of the rth occurrence of α in B.
We omit the subscript B when it is clear from the context. Lemma 1 summarizes
previous results on succinct representations of bit vectors, in which part (a) is from
Jacobson [18] and Clark and Munro [12], while part (b) is from Raman et al. [25].

Lemma 1 A bit vector B of length n with v 1s can be represented using either:
(cid:3) + O(n lg lg n/ lg n) bits, to support the ac-
(a) n + o(n lg lg n/ lg n) bits, or (b) lg
cess to each bit, rank and select in O(1) time.

n
v

(cid:2)

3.2 Balanced Parentheses

Another structure we use is a balanced parenthesis sequence S of length 2n, where
there are n opening parentheses and n closing parentheses. The following operations
are considered:

228

Algorithmica (2012) 62:224–257

– rank_openS (i), the number of opening parenthesis in S[1..i];
– rank_closeS (i), the number of closing parenthesis in S[1..i];
– select_openS (i), the position of the ith opening parenthesis in S;
– select_closeS (i), the position of the ith closing parenthesis in S;
– find_openS (i), the matching opening parenthesis for the closing parenthesis at

position i;

– find_closeS (i), the matching closing parenthesis for the opening parenthesis

at position i;
– excessS (i), the number of opening parentheses minus the number of closing
parentheses in S[1..i];
– encloseS (i), the closest enclosing (matching parenthesis) pair of a given matching 
parenthesis pair whose opening parenthesis is at position i.

The subscript S is omitted when it is clear from the context.

Munro and Raman [22] considered the problem of representing a balanced parenthesis 
sequence succinctly, and their result is:

Lemma 2 [22] A sequence of balanced parentheses S of length 2n can be represented 
using 2n + o(n) bits to support the operations rank_open, rank_close,
select_open, select_close, find_close, find_open, excess and
enclose in O(1) time.

3.3 Multiple Parentheses

(cid:5)

(cid:5)

(cid:5)

)i

(cid:5)

)2

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

)1

,

(2

,

(1

,

, . . . ,

(cid:5)}. We call

Chuang et al. [10] proposed the succinct representation of multiple parentheses,
a string of O(1) types of parentheses that may be unbalanced. Thus a multiple
parenthesis sequence of p types of parentheses is a sequence over the alphabet
{(cid:5)
type-i opening parenthesis and
type-i closing parenthesis, respectively. This is a generalization of balanced parentheses.
 The operations considered are:
– m_rankS (α, i), the number of occurrences of parentheses α in S[1..i];
– m_selectS (α, i), the position of the ith occurrence of parenthesis α;
– m_firstS (α, i), the position of the ﬁrst occurrence of parenthesis α after the ith

and

(p

,

)p

(cid:5)

(cid:5)

(i

position in S;

– m_lastS (α, i), the position of the last occurrence of parenthesis α before the ith
position in S;
– m_matchS (i), the position of the parenthesis matching S[i];
– m_encloseS (k, i1, i2), the position of the closest matching parenthesis pair of
type k which encloses S[i1] and S[i2].
We omit the subscript S when it is clear from the context. Chuang et al. [10]

showed how to support the above operations:

Lemma 3 [10] Consider a string S of O(1) types of parentheses that is stored explicitly.
 There is an auxiliary data structure using o(|S|) bits that supports the operations
listed above in O(1) time.

Algorithmica (2012) 62:224–257

229

We show how to improve this result in Lemma 12, and propose an encoding for
the case in which the number of types of parentheses is non-constant in Theorem 7.

3.4 Succinct Indexes for Strings and Binary Relations

Barbay et al. [2, 3] showed how to achieve data abstraction in succinct data structures
by designing succinct indexes. Given an abstract data type (ADT) to access the given
data, the goal is to design auxiliary data structures (i.e. succinct indexes) that occupy
asymptotically less space than the information-theoretic lower bound on the space
required to encode the given data, and support an extended set of operations using
the basic operators deﬁned in the ADT. They considered a string S of length n over
an alphabet of arbitrary size σ that support the following operations:
– string_rankS (α, x), the number of occurrences of α in S[1..x];
– string_selectS (α, r), the position of the rth occurrence of α in the string;
– string_accessS (x), the character at position x in the string.
The subscript S is omitted when it is clear from the context. They deﬁned the interface 
of the ADT of a string through the operator string_access, and designed 
a succinct index of n · o(lg σ ) + O(n) bits that provides efﬁcient support
for string_rank and string_select using string_access to access the
string.
They also extended the problem to n objects where each object can be associated
with a subset of labels from [σ], this association being deﬁned by a binary relation R
of t pairs from [n]×[σ]. The operations include:
– object_selectR(x, i), the ith label associated with x in lexicographic order,
and +∞ if no such label exists;
– label_rankR(α, x), the number of objects labeled α up to (and including) x;
– label_selectR(α, r), the position of the rth object labeled α;
– label_accessR(x, α), whether object x is associated with label α.

The subscript R is omitted when it is clear from the context. They deﬁned the
interface of the ADT of a binary relation through the operator object_select
and designed a succinct index of t · o(lg σ ) bits to support other operators efﬁciently.
As we use this result extensively in our paper, we summarize it in the following
lemma (they assumed that each object is associated with at least one label):

Lemma 4 [2] Given support for object_select in f (n, σ, t ) time on a binary
relation R formed by t pairs from an object set [n] and a label set [σ], there
is a succinct index using t · o(lg σ ) + O(t ) bits that supports label_rank in
O((lg lg lg σ )2(f (n, σ, t )+lg lg σ )) time, label_select in O(lg lg lg σ (f (n, σ, t )
+ lg lg σ )) time, and label_access in O(lg lg lg σ · f (n, σ, t ) + lg lg σ ) time.

Barbay et al. [2] further showed how to use succinct indexes to represent a binary

relation using space close to the information-theoretic minimum (i.e. lg
Lemma 5 [2] A binary relation R formed by t pairs from an object set [n] and
(cid:3) + t · o(lg σ ) + O(t ) bits to supa 
label set [σ] can be represented using lg
port object_select in O(1) time, label_rank in O(lg lg σ (lg lg lg σ )2) time,

(cid:2)
nσ
t

bits):

(cid:3)

(cid:2)
nσ
t

230

Algorithmica (2012) 62:224–257

Fig. 1 A triangulated planar graph of 12 vertices with its canonical spanning tree T0 (on the left). On the
right, it shows the triangulation induced with a realizer, as well as the local condition

label_select in O(lg lg σ lg lg lg σ ) time, and label_access in O(lg lg σ )
time.

They showed that the techniques used to prove Lemmas 4 and 5 also apply to the
more general case in which each object is associated with zero or more labels. In this
more general case, they demonstrated that the space costs in both lemmas are only
increased by O(n) bits, while the support for the operations remains the same.

3.5 Realizers and Planar Triangulations

Our general approach, in much of this paper, is based on the idea of realizers (also
known as Schnyder trees or Schnyder woods) of planar triangulations (see Fig. 1 for
an example).
Deﬁnition 1 [27] A realizer of a planar triangulation T is a partition of the set of
the internal edges into three sets T0, T1 and T2 of directed edges, such that for each
internal vertex v the following conditions hold:

– v has exactly one outgoing edge in each of the three sets T0, T1 and T2;
– local condition: the edges incident with v in counterclockwise (ccw) order are:
one outgoing edge in T0, zero or more incoming edges in T2, one outgoing edge in
T1, zero or more incoming edges in T0, one outgoing edge in T2, and ﬁnally zero
or more incoming edges in T1.

From local conditions of the deﬁnition, it is possible to state a more global structural 
property (characterizing very ﬁnely the notion of planarity for triangulations)
which is expressed in terms of a spanning condition as below (we use it extensively
in Sect. 4):
Lemma 6 [27] Consider a planar triangulation T of n vertices, with exterior face
(v0, v1, vn−1). Then T always admits a realizer R = (T0, T1, T2) and each set of
edges in Ti is a spanning tree of all internal vertices. More precisely:
– T0 is a spanning tree of T \ {v1, vn−1};
– T1 is a spanning tree of T \ {v0, vn−1};
– T2 is a spanning tree of T \ {v0, v1}.

Algorithmica (2012) 62:224–257

231

As we consider undirected planar triangulations, we orient each internal edge
when we compute the realizers. If we reverse the direction of each edge in Ti, we
get a different set of directed edges. We use T
to denote this set. We also use the
i
following lemma in this paper:
Lemma 7 [27] If T0, T1 and T2 deﬁne a realizer of a planar triangulation T , then
for i ∈ {0, 1, 2}, there is no directed cycle in the set Ti ∪ T
−1
i+2 (indices are
modulo 3).

∪ T

−1

−1
i+1

4 Planar Triangulations

4.1 Three New Traversal Orders on a Planar Triangulation

A key notion in the development of our results is that of three new traversal orders
of planar triangulations based on realizers. Let T be a planar triangulation of n vertices 
and m edges, with exterior face (v0, v1, vn−1). We denote a realizer of T by
(T0, T1, T2) following Deﬁnition 1. By Lemma 6, T0, T1 and T2 are three spanning
trees of the internal vertices of T , rooted at v0, v1 and vn−1, respectively. We add
the edges (v0, v1) and (v0, vn−1) to T0, and call the resulting tree, T0, the canonical
spanning tree of T [10]. In this section, we identify each vertex by its rank in canonical 
ordering, which is the ccw preorder rank in T0 (i.e. vertex i or vi denotes the ith
vertex in canonical ordering). We use (x, y) to indicate the edge between vertices x
and y. We will be describing planar graphs/triangulations and their tree decomposition.
 As an aid to remind the reader of the context, we will tend to use the term node
when discussing a tree and vertex in the context of the full planar graph. For example,
we may make such a statement as “vertex x is a leaf node of the canonical spanning
tree, T0, of graph T ”.
Deﬁnition 2 The zeroth order, π0, is deﬁned on all the vertices of T and is simply
given by the preorder traversal of T0 starting at v0 in counterclockwise order (ccw
order).
The ﬁrst order, π1, is deﬁned on the vertices of T \ v0 and corresponds to a
traversal of the edges of T1 as follows. Perform a preorder traversal of the contour
of T0 in a ccw manner. During this traversal, when visiting a node v, we enumerate
consecutively its incident edges (v, u1), . . . , (v, ui ) in T1, where v appears before ui
in π0. The traversal of the edges of T1 naturally induces an order on the nodes of T1:
each node (different from v1) is uniquely associated with its parent edge in T1.
The second order, π2, is deﬁned on the vertices of T \ {v0, v1} and can be computed 
in a similar manner by performing a preorder traversal of T0 in clockwise order
(cw order). When visiting the contour of T0 in cw order, the edges in T2 incident with
a node v are listed consecutively to induce an order on the nodes of T2.

Figure 2 gives an example of the above three orders in a planar triangulation. Note
that the orders π1 and π2 do not correspond to previously studied traversal orders on
the trees T1 and T2, as they are dependent on T0 through π0. To show that all the
internal vertices are listed in π1 and π2, it sufﬁces to prove the following lemma.

232

Algorithmica (2012) 62:224–257

Fig. 2 A planar triangulation induced with one realizer. The three orders π0, π1 and π2, as well as the
order induced by a DFUDS traversal [4] of T0 are also shown

Fig. 3 Region R in the proofs
of Lemmas 8 and 10

Lemma 8 Given an edge (vi , vj ), where i < j , if it is in T1, then vi is vj ’s parent in
T1. If this edge is in T2, then vj is vi’s parent in T2.

Proof We consider only the case in which the edge (vi , vj ) is in T1; the claim for the
case in which (vi , vj ) is in T2 can be proved similarly.
As the case in which i = 1 is trivial, and there is no edge in T1 that is incident with
v0 or vn−1, we need only consider the case in which vi and vj are internal vertices.
We ﬁrst prove that vi is not vj ’s ancestor in T0. Assume to the contrary that vi
is vj ’s ancestor in T0. Recall that the edges in T0, T1 and T2 are oriented toward the
parent nodes incident with them. Then there is a directed path from vj to vi in T0. As
there is an edge in T1 between vi and vj , there is a directed cycle from vj to vi and
then back to vj using edges from the set T0 ∪ T
−1
(depending
1
on the direction of the edge (vi , vj )), which contradicts Lemma 7.

or the set T

∪ T

−1
1

−1
0

Let vk be the lowest common ancestor of vi and vj in T0. As i < j and vi is not
vj ’s ancestor in T0, the path from vi to vk in T0, the path from vj to vk in T0 and the
edge (vi , vj ) deﬁne a closed region R (see Fig. 3). Assume to the contrary that vj is
vi’s parent in T1. Then, according to the local condition in Deﬁnition 1, the parent
of vj in T2 is either inside R or on the boundary of R. As there is a directed path
from vj to vn−1 and vn−1 is neither inside R or on its boundary, we conclude that
there exists a vertex vt either in the path from vi to vk in T0, or in the path from vj
to vk in T0, that is vj ’s ancestor in T2. In the former case, there is a directed cycle
vi , . . . , vt , . . . , vj , vi consisting of edges in the set T0 ∪ T
. In the latter case,
there is a directed cycle vj , . . . , vt , . . . , vj consisting of edges in the set T0 ∪ T
−1
.
2
(cid:2)
Either of these two observations contradicts Lemma 7.

∪ T

−1
1

−1
2

Algorithmica (2012) 62:224–257

233

The following lemma is crucial, as it puts in correspondence the labels of the

neighbors of a vertex with a ﬁnite number of substrings.

Lemma 9 For any vertex x, its children in T1 listed in ccw order have consecutive
ranks in π1. Similarly, x’s children in T2 listed in cw order have consecutive ranks
in π2. In the case of T0, the children of x are listed consecutively by a DFUDS (i.e.
Depth First Unary Degree Sequence [4]) traversal3 of T0.

Proof This lemma follows directly from the local condition and the ccw traversal
performed on T0 to construct π1 and π2. To be speciﬁc, the edges between x and its
children in T1 are all incoming edges incident with x in T1, and because of the local
condition in Deﬁnition 1, they are encountered consecutively when listing the edges
incident with x in ccw order (and just before visiting the outgoing edge of x in T0).
(cid:2)
A similar argument holds for π2 and π0.

4.2 Representing Planar Triangulations

We consider the following operations on unlabeled planar triangulations:

– adjacency(x, y), whether vertices x and y are adjacent;
– degree(x), the degree of vertex x;
– select_neighbor_ccw(x, y, r), the rth neighbor of vertex x starting from
vertex y in ccw order if x and y are adjacent, and ∞ otherwise;
– rank_neighbor_ccw(x, y, z), the number of neighbors of vertex x between
(and including) the vertices y and z in ccw order if y and z are both neighbors of
x, and ∞ otherwise;
– j (i), given the rank of a vertex in π0, returns the rank of the same vertex in πj
(j ∈ {1, 2});
−1
– 
j (i), given the rank of a vertex in πj , returns the rank of the same vertex in π0
(j ∈ {1, 2}).
To represent a planar triangulation T , we compute a realizer (T0, T1, T2) of T
following Lemma 6. We then encode the three trees T0, T1 and T2 using a multiple
parenthesis sequence S of 2(m + 1) parentheses of three types. S is obtained by
performing a preorder traversal of the canonical spanning tree T0 = T0 ∪ (v0, v1) ∪
(v0, vn−1) and using different types of parentheses to describe the edges of T0, T1 and
T2. We use parentheses of the ﬁrst type, namely
, to encode the tree T0, and
other types of parentheses,
, to encode the edges of T1 and T2. We use
S0, S1 and S2 to denote the subsequences of S that contain all the parentheses of the
ﬁrst, second, and the third types, respectively. We construct S as follows (see Fig. 4
for an example).

and

(cid:5)}(cid:5)

(cid:5)

(cid:5)
(

(cid:5)

(cid:5)
)

(cid:5)[(cid:5)

,

(cid:5)](cid:5)

,

(cid:5){(cid:5)

,

3In the DFUDS sequence of a tree, a node of degree d is represented by d opening parentheses followed by
a closing parenthesis. All the nodes are listed in preorder in the sequence, and an extra opening parenthesis
is added to the beginning of the sequence. Each node is numbered by its opening parenthesis in its parent’s
description, and this number is called the DFUDS rank. The DFUDS traversal visits the nodes of a tree by
their DFUDS ranks. Figure 2 also shows the DFUDS ranks of the nodes in T0.

234

Algorithmica (2012) 62:224–257

Fig. 4 The multiple parenthesis string encoding of the planar triangulation in Fig. 2

Let v0, . . . , vn−1 be the ccw preorder of the nodes of T0. Then the string S0 is
simply the balanced parenthesis encoding of the tree T0 [22]: S0 can be obtained by
performing a ccw preorder traversal of the contour of T0, writing down an opening
parenthesis when an edge of T0 is traversed for the ﬁrst time, and a closing parenthesis
when it is visited for the second time. During the traversal of T0, we insert in S a pair
for
of parentheses
each edge in T2. More precisely, when visiting the edges incident with a vertex vi in
ccw order, we insert:

for each edge of T1, and a pair of parentheses

and

and

(cid:5){(cid:5)

(cid:5)}(cid:5)

(cid:5)[(cid:5)

(cid:5)](cid:5)

– A

for each edge (vi , vj ) in T1, where i < j , before the parenthesis

corresponding 
to vi;

(cid:5)[(cid:5)
(cid:5)](cid:5)
(cid:5)}(cid:5)
(cid:5){(cid:5)

ing to vj ;

ing to vi;

(cid:5)

(cid:5)
)

(cid:5)

(cid:5)

(cid:5)
(

(cid:5)
(

correspond-

correspond-

(cid:5)

(cid:5)
)

corre-

– A

for each edge (vi , vj ) in T1, where i < j , after the parenthesis

– A

for each edge (vi , vj ) in T2, where i > j , after the parenthesis

– A

for each edge (vi , vj ) in T2, where i > j , before the parenthesis

,
(cid:5)
(

(cid:5){(cid:5)

(cid:5)](cid:5)
,
or

sponding to vj .
(cid:5)}(cid:5)
(cid:5)[(cid:5)
The relative order of the parentheses
and
inserted between two con-
(cid:5)
(cid:5)
(cid:5)
, does not matter. For the simplicity
secutive parentheses of the other type, i.e.
)
of the proofs in this section, we assume that when we insert a parenthesis pair for an
edge in T1 or T2, we always ensure that the positions of this pair in S either enclose
or are enclosed in those for an edge that shares the same parent node in the same
tree. There are n− 2 and n− 3 edges in T1 and T2, respectively, so the subsequences
S1 and S2 are balanced parenthesis sequences of lengths 2(n − 2) and 2(n − 3), respectively.
 As S0 is the balanced parenthesis encoding of T0, the length of S0 is 2n.
Therefore, the string S is of length 2n+ 2(n− 2)+ 2(n− 3) = 2(3n− 5) = 2(m+ 1),
consisting of three types of parenthesis.

We ﬁrst observe some basic properties of the string S. Recall that a vertex vi can be
referred to by its preorder rank in T0, and by the position of the matching parenthesis
pair of the ﬁrst type corresponding to it. We use pi and qi to denote the positions
of the opening and closing parentheses of this pair in S respectively. Let pf be the
position of the opening parenthesis in S corresponding to the ﬁrst child of vi in T0,
and ql be the position of the closing parenthesis in S corresponding to the last child
of vi in T0.

Algorithmica (2012) 62:224–257

235

Property 1 The following basic facts hold:

– Two vertices vi and vj are adjacent if and only if there is one common incident

edge (vi , vj ) in exactly one of the trees T0, T1 or T2;
– pi < pf < ql < qi;
– The number of edges incident with vi and not belonging to the tree T0 is (pf −
pi − 1) + (qi − ql − 1);
– If vi is not a leaf in T0, between the occurrences of the
vertices vi and vi+1 (note that the
is exactly one
to the vertices vi and the

that correspond to the
corresponding to vi+1 is at position pf ), there
that corresponds

. Similarly, there is exactly one

at position ql.

between the

(cid:5){(cid:5)

(cid:5)](cid:5)

(cid:5)
(

(cid:5)
(

(cid:5)
)

(cid:5)
)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

We now prove the following lemma that is important to our representation:

Lemma 10 In the process of constructing S, the two parentheses of the second type
inserted for each edge in T1 form a matching parenthesis pair in S. Similarly, the two
parentheses of the third type inserted for each edge in T2 form a matching parenthesis
pair in S.

(cid:5)

(cid:5)
)

(cid:5)](cid:5)

(cid:5)[(cid:5)

and a

in S is before that of parenthesis

Recall that for each edge (vi , vj ) in T1, where i < j , we insert a

Proof We prove the lemma for parentheses of the second type; the claim for parentheses 
of the third type follows similarly.
(cid:5)](cid:5)
into S. We ﬁrst prove that between these two parentheses, the position of parenthesis
(cid:5)[(cid:5)
. As the case in which i = 1 is trivial, and no
edge in T1 is incident with v0 or vn−1, we need only consider the case in which vi
and vj are internal vertices. By the process of constructing S, it sufﬁces to prove that
the closing parenthesis
corresponding to vi appears before the opening parenthesis
(cid:5)
(cid:5)
corresponding to vj . Assume to the contrary that this is not true. As the parenthesis
(
(cid:5)
(cid:5)
corresponding to vi appears before the parenthesis
corresponding to vj (this
(
is because i < j ), we conclude that the parenthesis pair corresponding to vi in S0
encloses the pair corresponding to vj . Thus vi is an ancestor of vj in T0. Therefore,
there is a directed path from vj to vi using edges from the set T0. By Lemma 8, vi is
vj ’s parent in T1, so the edge (vi , vj ) is oriented toward vi. Hence there is a directed
cycle vj , . . . , vi , vj using edges from the set T0 ∪ T
, which contradicts Lemma 7.
It now sufﬁces to prove that the two parenthesis pairs of the second type inserted
for two different edges in T1 either do not intersect, or one is enclosed in the other.
Let (vi , vj ) (i < j ) and (vp, vq ) (p < q) be two edges that are not incident with the
same node in T1 (the case in which these two edges are incident with the same node in
T1 is trivial). As shown in the proof of Lemma 8, we have that vi is not vj ’s ancestor
in T0, and that vp is not vq’s ancestor in T0. Let vk be the lowest common ancestor
of vi and vj in T0. We deﬁne the region R as in the proof of Lemma 8 (see Fig. 3).
Without the loss of generality, we assume that p < i. There are two cases.

−1
1

(cid:5)
(

(cid:5)

We ﬁrst consider the case in which vp is vi’s ancestor. If vp is also vj ’s ancestor,
then the parenthesis pair of the ﬁrst type corresponding to vp encloses the pairs corresponding 
to vi and vj . By the process we use to construct S, the two parenthesis
pairs of the second type inserted for edges (vi , vj ) and (vp, vq ) do not intersect. If
vp is not vj ’s ancestor, then it is in the path from vi to vk in T0, excluding vi and vk.

236

Algorithmica (2012) 62:224–257

(cid:5)[(cid:5)

(cid:5)

(cid:5)

We observe that the parenthesis
inserted for (vp, vq ) is after the one inserted for
(vi , vj ). By the local condition in Deﬁnition 1 and the planarity of the graph, vq is
either inside region R, or is in the path from vj to vk in T0. Therefore, q < j . Thus the
parenthesis
corresponding to vj .
Hence the parenthesis
inserted for (vp, vq ) is before the one inserted for (vi , vj ).
Therefore, the parenthesis pair of the second type inserted for (vp, vq ) is enclosed in
the pair inserted for (vi , vj ).

corresponding to vq is before the parenthesis

(cid:5)](cid:5)

(cid:5)
(

(cid:5)
(

(cid:5)
(cid:5)
)
(cid:5)[(cid:5)

We next consider the case in which vp is not vi’s ancestor. In this case, the parenthesis

corresponding to vp appears before that corresponding to vi. Thus the parenthesis

inserted for (vp, vq ) appears before the one inserted for (vi , vj ). As vp is
outside R, by the planarity of the graph, vq is either outside R, or on R’s boundary.
We also observe that vq cannot be in the path from vj to vk in T0, because otherwise,
by the local condition in Deﬁnition 1, vp is either in R or in the path from vi to vk in
T0. Therefore, vq is either before vi in canonical order, or is a descendant of vi, or is
after vj in canonical order. In the ﬁrst two cases, the parenthesis pairs of the second
type inserted for (vp, vq ) and (vi , vj ) do not intersect. In the last case, the parenthesis
(cid:2)
pair of the second type inserted for (vi , vj ) is enclosed by that for (vp, vq ).

Observe that S0 is the balanced parenthesis encoding of the tree T0 [22], so if we
store S0 and construct the auxiliary data structures for S0 as in [9, 21–23], we can
support a set of navigational operators on T0. S can be represented using Lemma 3 in
2m(cid:2)log2 6(cid:3) + o(m) = 6m + o(m) bits. However, this encoding does not support the
computation of an arbitrary word in S0, so we cannot navigate in the tree T0 without
storing S0 explicitly, which will cost essentially 2 additional bits per node. To reduce
this space redundancy, and to decrease the term 2m(cid:2)log2 6(cid:3) to 2m log2 6 + o(m), we

have the following lemma.

(cid:5)
(

or S[i] = (cid:5)

Lemma 11 The string S can be stored in 2m log2 6 + o(m) bits to support the operators 
listed in Sect. 3.3 in O(1) time, as well as the computation of an arbitrary word
or (lg(n)) bits of the balanced parenthesis sequence of T0 in O(1) time.
Proof We construct a bit vector B1 of 2(m + 1) bits, so that B1[i] = 1 iff S[i]
= (cid:5)
. We construct another bit vector B2 of 2m + 2 − 2n bits for the 0s
in B2 (recall that there are 2n parentheses of the ﬁrst type), so that B2[i] = 1 iff the
(cid:5)](cid:5)
(cid:5)[(cid:5)
parenthesis corresponds to the ith 0 in B1 is either
. We store B1 and B2 using
or
Part (b) of Lemma 1 to support rank/select operations on them. The space cost of stor-
(cid:3)+ o(m). To analyze the above
(cid:2)
(cid:3)+ o(m)+ lg
2m+2−2n
2n−4
ing B1 and B2 is thus lg
2 log2 n + O(1) [15,
space cost, we use the equality log2 n! = n log2 n − n log2 e + 1
Sect. 4.6.4]. We have (note that m = 3n − 6):

(cid:2)
2m+2

(cid:5)
)

n

log2

(cid:4)
2m + 2
2n
(cid:4)

= log2
= log2

(cid:4)

(cid:5)

+ log2
(cid:5)
6n − 10
+ log2
2n
(6n − 10)!
(2n)!(4n − 10)! ×

(cid:5)
(cid:4)
2m + 2 − 2n
2n − 4
(cid:5)
(cid:4)
4n − 10
2n − 4
(2n − 4)!(2n − 6)!

(4n − 10)!

(cid:5)

Algorithmica (2012) 62:224–257

237

2n log2(2n) − 2n log2 e + 1

log2(2n)

2

log2(6n)

(cid:5)

+ O(1)

(6n − 10)!

= log2

(2n)!(2n − 4)!(2n − 6)!
(6n)!
((2n)!)3

< log2
= log2(6n)! − 3 log2(2n)!
= 6n log2(6n) − 6n log2 e + 1
− 3
= 6n log2 3 − log2 n + O(1)
< 6n log2 3 + O(1)
= 2m log2 3 + O(1)

(cid:4)

2

Therefore, the two bit vectors B1 and B2 occupy 2m log2 3 + o(m) bits.
In addition, we store S0, S1 and S2 using Lemma 2. The space cost of storing these
three sequences is 2n+ o(n)+ 2(n− 2)+ o(n)+ 2(n− 3)+ o(n) = 2m+ o(m) bits.
Thus the total space cost is 2m log2 6 + o(m) bits.

B1 and B2 can be used to compute the rank/select operations over S if we treat
each type of (opening and closing) parentheses as the same character. For example, to
compute the number of parentheses of the third type in S[1..i], we can ﬁrst compute
the number of 0s in S[1..i] (j denotes the result). Then the number of parentheses
of the third type in S[1..i] is rankB2 (0, j ). Other rank/select operations can be supported 
similarly. On the other hand, S0, S1 and S2 can be used to support operations
on the parentheses of the same type. By representing all these data structures, the
operations listed in Sect. 3.3 can be easily supported in constant time. As we store
S0 explicitly in our representation, we can trivially support the computation of an
(cid:2)
arbitrary word of S0.

The same approach can be directly applied to a sequence of O(1) types of parentheses 
that may be unbalanced.

Lemma 12 Consider a multiple parenthesis sequence M of n parenthesis of p types,
where p = O(1). M can be stored using n log(2p) + o(n) bits to support the operators 
listed in Sect. 3.3 in O(1) time, as well as the computation of an arbitrary word,
or (lg(n)) bits of the balanced parenthesis sequence of the parentheses of a given
type in M in O(1) time.

Proof Let ni be the number of parentheses of type i in M. Let li = (cid:6)
j=i nj . Thus
l1 = n and lp = np. For i = 1, 2, . . . , p − 1, we construct a bit vector Bi[1..li], where
Bi[k] = 1 iff the kth parenthesis among the parentheses of types i, i + 1, . . . , p in M
is of type i. We store all the Bis using Part (b) of Lemma 1. Thus the space cost of all
(cid:3) +
the Bis is
o(n). To analyze the above space cost, we again use the equality log2 n! = n log2 n −

(cid:3) + 1 + o(n)

(cid:3) + o(li )
(cid:8)

p−1
i=1 log2

(cid:8) = (cid:6)

(cid:7)
log2

p−1
i=1

(cid:6)

(cid:6)

li
ni

(cid:2)

(cid:7)

p−1
i=1

lg

li
ni

(cid:2)

li
ni

<

(cid:2)

p

238

Algorithmica (2012) 62:224–257

n log2 e + 1

2 log2 n + O(1) [15] (let H

∗
0 (M) be the zeroth order entry of M when we
replace each occurrence of the parentheses of the same type by one distinct character).
We have:

(cid:4)

(cid:5)

log2

p(cid:9)
i=1
= log2

(cid:4)

(cid:5)

li
ni

li!

li
ni

p(cid:10)
i=1
p(cid:10)
i=1
p(cid:10)
i=1
(cid:4)

= log2

= log2

ni!(li − ni )!
li!
ni!li+1!
n2!l3! × ··· × lp−1!
n1!l2! × l2!
l1!
np−1!lp!
n!
n1! × n2! × ··· × np!

(cid:5)

= log2
= log2
= log2 n! − p(cid:9)
i=1
= n log2 n − n log2 e + 1
(cid:4)
− p(cid:9)
i=1

log2(ni!)

2

= n log2 n − n log2 e + 1
−

(cid:11)

2

= n log2 n − p(cid:9)
i=1
(cid:4)
= p(cid:9)
ni log2
i=1
0 (M) + O(log2 n)
= nH
∗
≤ n log2 p + O(log2 n)

ni

n

p(cid:9)
i=1

1
2

(ni log2 ni ) − n log2 e + p(cid:9)
i=1
(ni log2 ni ) + O(log2 n)
(cid:5)

+ O(log2 n)

ni log2 ni − ni log2 e + 1

2

(cid:5)

+ O(1)

log2 ni

log2 n

log2 n

(cid:12)

+ O(1)

log2 ni

Thus the space cost of all the Bis is n log2 p + o(n) bits.

Algorithmica (2012) 62:224–257

239

i

(cid:5)

(cid:5)

(cid:5)
i. Then we have n

≤ 2ni. To encode M

(cid:5)
i, of Mi that is a balanced parenthesis sequence. Let n

Let Mi be the subsequence of M that contains all the parentheses of type i. Note
that Mi may be unbalanced. We use the approach of Chuang et al. [10] to encode all
the Mis while supporting all the operations on balanced parentheses listed in Sect. 3.2
on them. More precisely, we insert one or more opening parentheses before the beginning 
of Mi and one or more closing parentheses after the end of Mi to get the
(cid:5)
shortest superstring, M
i denote
(cid:5)
i while allowing the computhe 
length of M
[j] in constant time, we need only store Mi
tation of any O(lg n)-bit substring of M
and the numbers of opening and closing parentheses we insert before and after Mi
respectively, which occupy ni + 2 lg n bits. We also build the auxiliary data structures
(cid:5)
for M
i ) bits to encode
Mi while supporting all the operations on balanced parentheses listed in Sect. 3.2 on
Mi. Hence the space cost of all the Mis is n + o(n) bits. Therefore, the total space
cost of all the data structures is n log2(2p) + o(n) bits.
As we can perform rank/select operations for each type of parentheses in M using
Bis, and we can support all the operations on balanced parentheses listed in Sect. 3.2
on Mis, the algorithms used in the proof of Lemma 11 can be used to support the
operators listed in Sect. 3.3 on M in O(1) time. An arbitrary word of the parenthesis
(cid:2)
sequence of type i in M can be computed using Mi.

i using Lemma 2. Thus it takes ni + 2 lg n + O(n
(cid:5)

(cid:5)
i lg lg n

(cid:5)
i / lg n

i

j (i) efﬁciently (j ∈ {1, 2}).
−1

The following theorem shows how to support the navigational operations on triangulations.
 While the space used here is a little more than that of Chiang et al. [9] (see
Sect. 2), the explicit use of the three parenthesis sequences seems crucial to exploiting
the realizers to support j (i) and 
Theorem 1 A planar triangulation T of n vertices and m edges can be represented 
using 2m log2 6 + o(m) bits to support operators adjacency, degree,
select_neighbor_ccw, rank_neighbor_ccw as well as the j (i) and
j (i) (j ∈ {1, 2}) in O(1) time.
−1

Proof We construct the string S for T as shown in this section, and store it using
2m log2 6 + o(m) bits by Lemma 11. Recall that S0 is the balanced parenthesis encoding 
of T0, and that we can compute an arbitrary word of S0 from S. Thus we can
construct additional auxiliary structures using o(n) = o(m) bits [9, 21–23] to support
the navigational operations on T0. As each vertex is denoted by its rank in canonical
ordering, vertex x corresponds to the xth opening parenthesis in S0. We now show
that these data structures are sufﬁcient to support the navigational operations on T .
To compute adjacency(x, y), recall that x and y are adjacent iff one is the
parent of the other in one of the trees T0, T1 and T2. As S0 encodes the balanced
parenthesis sequence of T0, we can trivially check whether x (or y) is the parent of y
(or x) using the enclose operator on S0. To test adjacency in T1, we recall that x
, is an incoming
is the parent of y iff the (only) outgoing edge of y, denoted by a
(cid:5)](cid:5)
(cid:5)[(cid:5)
edge of x, denoted by a
in S,
(cid:5)](cid:5)
given by m_first(
, m_select(y,
)), and compute the index, i, of its matching
(cid:5)[(cid:5)
, in S. We then check whether the nearest succeeding closing
opening parenthesis,
(cid:5)[(cid:5)
parenthesis
of the
, i), matches the xth

(cid:5)
retrieved, located using m_first(

(cid:5)](cid:5)
after the yth

. It then sufﬁces to retrieve the ﬁrst

(cid:5)
(

(cid:5)
)

(cid:5)
)

(cid:5)
(

(cid:5)

(cid:5)

(cid:5)

240

Algorithmica (2012) 62:224–257

opening parenthesis
similar approach to test the adjacency in T2.

in S. If it does, then x is the parent of y in T1. We use a

(cid:5)

(cid:5)
(

To compute degree(x), let d0, d1 and d2 be the degrees (number of adjacent
nodes including the parent) of x in the trees T0, T1 and T2 respectively, so that the
sum of these three values is the answer. To compute d0, we use S0 and the algorithm
to compute the degree of a node in an ordinal tree using its balanced parenthesis representation 
by Chiang et al. [9] (this is done using an operator called wrapped(i)
on S0, which returns the number of matching parenthesis pairs whose closest enclosing 
matching parenthesis pair has an opening parenthesis at position i). To compute 
d1 + d2, if x has children in T0, we ﬁrst compute the indices, i1 and i2, of the
xth and the x + 1th
in S, and the indices, j1 and j2, of the (n − x)th and the
(n − x + 1)th
in S in constant time. By the third item of Property 1, we have the
property d1 + d2 = (i2 − i1 − 1) + (j2 − j1 − 1). The case in which x is a leaf in T0
can be handled similarly.

(cid:5)
(

(cid:5)
)

(cid:5)

(cid:5)

(cid:5)

(cid:5)
)

(cid:5)[(cid:5)

To support select_neighbor_ccw and rank_neighbor_ccw, we make
use of the local condition of realizers in Deﬁnition 1. The local condition tells us
that, given a vertex x, its neighbors, when listed in ccw order, form the following six
types of vertices: x’s parent in T0, x’s children in T2, x’s parent in T1, x’s children
in T0, x’s parent in T2, and x’s children in T1. The ith child of x in ccw order in T0
can be computed in constant time, and the number of siblings before a given child
of x in ccw order can also be computed in constant time using the algorithms of
Lu and Yeh [21]. The children of x in T1 correspond to the parentheses
inserted
before the parenthesis
corresponding to x when we construct S. In addition, by
the construction of S, if u and v are both children of x, and u occurs before v in π1,
then u is also before v in ccw order among x’s children in T1. The children of x in
T2 have a similar property. Thus the operators supported on S allow us to perform
rank/select on x’s children in T1 and T2 in ccw order. As we can also compute the
number of each type of neighbors of x in constant time, this allows us to support
select_neighbor_ccw and rank_neighbor_ccw in O(1) time.
(cid:5)](cid:5)

in S,
(cid:5)
(cid:5)
which is m_select(i,
). We then locate the position, k, of the ﬁrst
after position
(
, j ). After that, we locate the matching parenthesis of S[k]
(cid:5)](cid:5)
j , which is m_first(
using m_match(k) (p denotes the result). S[p] is the parenthesis
(cid:5)[(cid:5)
that corresponds
to the edge between vi and its parent in T1, and by the construction algorithm of S,
the rank of S[p] is the answer, which is m_rank(p,
(cid:5)[(cid:5)
−1
). The computation of 
is
−1
1
can be supported similarly. (cid:2)
exactly the inverse of the above process. 2 and 
2

To compute 1(i), we ﬁrst locate the position, j , of the ith occurrence of

(cid:5)
(

(cid:5)

4.3 Vertex Labeled Planar Triangulations

We now consider a vertex labeled planar triangulation. Let n and m denote the numbers 
of its vertices and edges respectively, σ denote the number of labels, and t denote
the total number of vertex-label pairs. As with binary relations [2, 3], we assume that
each vertex is associated with at least one label.4

4As our approach reduces the support of operations on vertex labeled planar triangulations to the support
of operations on binary relations, the same technique for binary relations [2, 3] can be used to generalize
our results to the case in which each vertex is associated with zero or more labels.

Algorithmica (2012) 62:224–257

241

In addition to unlabeled operators, we present a set of operators that allow efﬁcient
navigation in a vertex labeled planar triangulation (these are natural extensions to
navigational operators on multi-labeled trees):

– lab_degree(α, x), the number of neighbors of vertex x that are labeled α;
– lab_select_ccw(α, x, y, r), the rth vertex labeled α among neighbors of vertex 
x after vertex y in ccw order, if y is a neighbor of x, and ∞ otherwise;
– lab_rank_ccw(α, x, y, z), the number of neighbors of vertex x labeled α between 
vertices y and z in ccw order if y and z are neighbors of x, and ∞ otherwise.
We deﬁne the interface of the ADT of vertex labeled planar triangulations through
the operator vertex_label(v, r), which returns the rth label in lexicographic order 
associated with vertex v (i.e. the vth vertex in canonical ordering).

Recall that Lemma 11 encodes the string S constructed in Sect. 4.2 to support the
computation of an arbitrary word of S0, which is the balanced parenthesis sequence of
the tree T0. In this section, we consider the DFUDS sequence [4] of T0, as the DFUDS
order traversal visits the children of a node consecutively. We have the following
lemma.

Lemma 13 The string S can be stored in (2 log2 6+ )m+ o(m) bits, for any  such

that 0 <  < 1, to support the operators listed in Sect. 3.3 in O(1) time, as well as
the computation of an arbitrary word, or (lg n) bits of the balanced parenthesis
sequence, and of the DFUDS sequence of T0 in O(1) time.

Proof We construct the same data structures as in Lemma 11, except when we encode
S0 we use the TC representation of the tree T0 [16]. More precisely, we encode S0
using (2 + )n + o(n) bits, for any  such that 0 <  < 1, and this encoding supports
the computation of an arbitrary word of the balanced parenthesis sequence, and the
DFUDS sequence of T0 in constant time. As we can compute an arbitrary word of the
original sequence of S0 in constant time and all the other structures are the same as in
Lemma 11, we can still support the operators listed in Sect. 3.3 in constant time. (cid:2)

We now construct succinct indexes for vertex labeled planar triangulations.

Theorem 2 Consider a multi-labeled planar triangulation T of n vertices, associated 
with σ labels in t pairs (t ≥ n). Given the support of vertex_label in
f (n, σ, t ) time on the vertices of T , there is a succinct index using t · o(lg σ ) + O(t )
bits which supports lab_degree, lab_select_ccw and lab_rank_ccw in
O((lg lg lg σ )2(f (n, σ, t ) + lg lg σ )) time.

Proof The main idea is to combine our succinct representation of planar triangulations 
with three instances of the succinct indexes for related binary relations.
We represent the combinatorial structure of T using Theorem 1, in which we
use Lemma 13 to store S. Thus we can construct the auxiliary data structures for
the DFUDS representation of T0 [2–4, 19]. Observe that ranks of the vertices (for
simplicity we consider only internal vertices) in three different orders, namely the
DFUDS order of the nodes of T0, π1 and π2, form three binary relations, R0, R1 and
R2, with the labels associated with the corresponding vertices.

242

Algorithmica (2012) 62:224–257

We adopt the same strategy used previously for multi-labeled trees [2, 3]. We can
convert between the ranks of the vertices between π0, π1 and π2 in constant time by
Theorem 1. We can also convert between the preorder ranks of the nodes in T0 (note
that they are in the order of π0) and the DFUDS ranks of the nodes in T0 in constant
time [2, 3]. Therefore, we can use the operator vertex_label to support the ADT
of R0, R1 and R2. Thus, for each of the three binary relations R0, R1 and R2 we
construct a succinct index of t · o(lg σ ) bits using Lemma 4.

To compute lab_degree(α, x), we ﬁrst check whether x’s parents in T0, T1 and
T2 are labeled α. The DFUDS rank of x’s parent in T0 can be computed in constant
time. The rank in π1 (or π2) of x’s parent in T1 (or T2) can also be computed in
constant time, as shown in the proof of Theorem 1. Thus we can check whether x’s
parents in T0, T1 and T2 are labeled α by performing label_access operation on
R0, R1 and R2. We now need compute the numbers of x’s children in T0, T1 and T2
that are associated with label α. By Lemma 9, x’s children in T0, T1 and T2 are listed
consecutively in DFUDS order of T0, π1 and π2, respectively. Compute the DFUDS
rank, s, of x’s ﬁrst child in T0 in constant time. Then the DFUDS ranks of x’s children
in T0 are in the range [s..s+ d0− 1], where d0 is the number of x’s children within T0.
Thus we can compute the number of x’s children in T0 that are associated with label
α by performing label_rank on R0. To get the ranks in π1 of x’s children in T1,
we locate the ﬁrst and last occurrences of parenthesis
inserted for the edges in T1
whose parent node is x, and compute their ranks, f and l, among all the occurrences
of parenthesis
in S. As the ranks in π1 of x’s children in T1 are in the range
[f..l], we can compute the number of x’s children in T1 that are associated with label
α by performing label_rank on R1. The number of x’s children in T2 that are
associated with label α can be computed similarly.

(cid:5)[(cid:5)

(cid:5)[(cid:5)

To support lab_select_ccw and lab_rank_ccw, by the local condition in
Deﬁnition 1 and the algorithms in the above paragraph, it sufﬁces to show that we
can support the label-based rank/select of the children of a given node in ccw order
in the three trees T0, T1 and T2, respectively. As we can compute the ranges of the
DFUDS ranks in T0, the ranks in π1 and the ranks in π2 of x’s children in T0, T1 and
T2, respectively, these operations can be supported by performing label_rank and
label_select operations on R0, R1 and R2.
Finally, we observe that the space requirement of our representation is dominated
by the cost of the succinct indexes for the binary relations, each using t · o(lg σ ) +
(cid:2)
O(t ) bits.

When σ is non-constant, the size of the succinct index constructed above becomes
t · o(lg σ ) bits. To design a succinct representation of vertex labeled graphs using the
above theorem, we have the following corollary:
Corollary 1 A multi-labeled planar triangulation T of n vertices, associated with
(cid:3) + t · o(lg σ ) + O(t ) bits
σ labels in t pairs (t ≥ n) can be represented using lg
to support vertex_label in O(1) time, and lab_degree, lab_select_ccw
and lab_rank_ccw in O((lg lg lg σ )2 lg lg σ ) time.

nσ
t

(cid:2)

Proof We use Lemma 5 to encode the binary relation between the vertices in
(cid:3) + t · o(lg σ ) + O(t ) bits to support
canonical order and the set of labels in lg

(cid:2)
nσ
t

Algorithmica (2012) 62:224–257

243

object_select on it in constant time. Observe that the above operator directly
supports vertex_label on T . We then build the succinct indexes of t · o(lg σ )
bits for T using Theorem 2 and the corollary directly follows.
(cid:2)

As the information-theoretic lower bound of encoding the relation between the
(cid:3)
(cid:2)
nσ
t

set of vertices and the set of labels in a vertex labeled planar triangulation is lg
bits, our result is close to the information-theoretic minimum of representing a vertex
labeled planar triangulation.

4.4 Edge Labeled Planar Triangulations

In this section, we consider an edge labeled planar triangulation with n vertices and m
edges. Let σ denote the number of labels, and t denote the total number of edge-label
pairs. We adopt the assumption that each edge is associated with at least one label.
We deﬁne the interface of the ADT of edge labeled planar triangulations through the
operator edge_label(x, y, r), which returns the rth label associated to the edge
between the vertices x and y in lexicographic order if they are adjacent, or 0 otherwise.


We consider the following operations:

– lab_adjacency(α, x, y), whether there is an edge labeled α between vertices

x and y;

– lab_degree_edge(α, x), the number of edges incident with vertex x that are

labeled α;
– lab_select_edge_ccw(α, x, y, r), the rth edge labeled α among edges incident 
with vertex x after edge (x, y) in ccw order, if y is a neighbor of x, and ∞
otherwise;

– lab_rank_edge_ccw(α, x, y, z), the number of edges incident with vertex x
labeled α between edges (x, y) and (x, z) in ccw order if y and z are neighbors of
x, and ∞ otherwise.
We construct the following succinct index for edge labeled planar triangulations.
Theorem 3 Consider a multi-labeled planar triangulation T of n vertices and m
edges, in which the edges are associated with σ labels in t pairs (t ≥ m). Given the
support of edge_label in f (n, σ, t ) time on the edges of T , there is a succinct
index using t · o(lg σ )+ O(t ) bits which supports lab_adjacency in O(lg lg lg σ ·
f (n, σ, t )+lg lg σ ) time, and lab_degree_edge, lab_select_edge_ccw and
lab_rank_edge_ccw in O((lg lg lg σ )2(f (n, σ, t ) + lg lg σ )) time.
Proof We represent the combinatorial structure of T using Theorem 1, in which we
use Lemma 13 to store S. We also construct the auxiliary data structures for the
DFUDS representation of T0 [2–4, 19].

We number the edges in T0, T1 and T2 by the ranks of their child nodes in DFUDS
(cid:5)
(cid:5)
order of T0, π1 and π2, respectively, and denote these three orders of edges by π
0, π
(cid:5)
1
and π
0 is the edge between
v5 (i.e. the 8th node in DFUDS order of T0) and v2. We observe that the ranks of the

(cid:5)
2, respectively. For example, in Fig. 2, the 8th edge in π

244

Algorithmica (2012) 62:224–257

2 and the label set [σ] form three binary relations R
(cid:5)

(cid:5)
2, respectively. To support object_select(x, r) on R

2 are from the sets [n−1], [n−2] and [n−3], respectively. Thus
(cid:5)
(cid:5)
(cid:5)
1 and π
0, π
edges in π
(cid:5)
(cid:5)
(cid:5)
(cid:5)
the edges in π
0, R
1 and π
0, π
(cid:5)
1
and R
0, let y be the vertex
whose DFUDS rank in T0 is x. We locate y’s parent z, and edge_label(y, z, r) is
(cid:5)
(cid:5)
the result. The support for object_select on R
2 is similar. Therefore,
1 and R
(cid:5)
(cid:5)
we can use edge_label to support the ADT of R
2. For each of these
0, R
three binary relations, we construct a succinct index of t · o(lg σ ) + O(t ) bits using
Lemma 4.

(cid:5)
1 and R

(cid:5)
0

To compute lab_adjacency(α, x, y), we ﬁrst use the algorithm in the proof
of Theorem 1 to check whether x and y are adjacent, and if they are, which
of the three trees (T0, T1 and T2) has the edge (x, y). If x is y’s parent in T0,
(cid:5)
we compute y’s DFUDS rank (i.e. the rank of edge (x, y) in π
0), u, in T0, and
label_accessR
(u, α) is the answer. The case in which x is y’s child in T0, and
the case in which the edge (x, y) is in T1 or T2 can be handled similarly. Thus, we
can support lab_adjacency in O(lg lg lg σ · f (n, σ, t ) + lg lg σ ) time.
(cid:5)
0, π

To support the other three operations, we observe that the edges between a given
(cid:5)
(cid:5)
vertex x and its children in T0, T1 and T2 have consecutive ranks in π
1 and π
2,
(cid:5)
respectively. We also have x’s children in T0 and T1 are listed in ccw order in π
0 and
(cid:5)
1, respectively, and x’s children in T2 are listed in cw order in π2. Thus we can use
π
algorithms similar to those in Theorem 2 to support these operations.
Finally, we observe that the space requirement of our representation is dominated
by the cost of the succinct indexes for the binary relations, each using t · o(lg σ ) +
(cid:2)
O(t ) bits.

To design a succinct representation of edge labeled graphs using the above theo-

(cid:2)
mσ

t

rem, we have the following corollary.
Corollary 2 A multi-labeled planar triangulation T of n vertices and m edges,
in which the edges are associated with σ labels in t pairs (t ≥ m), can be
(cid:3) + t · o(lg σ ) + O(t ) bits to support edge_label
represented using lg
in O(1) time, lab_adjacency in O(lg lg σ ) time, and lab_degree_edge,
lab_select_edge_ccw and lab_rank_edge_ccw in O((lg lg lg σ )2 lg lg σ )
time.
Proof We represent the combinatorial structure of T using Theorem 1, in which we
use Lemma 13 to store S. Let m1, m2 and m3 denote the number of edges in T0, T1
and T2, respectively. Let t1, t2 and t3 denote the total numbers of edge-label pairs
(cid:5)
(cid:5)
in T0, T1 and T2, respectively. We encode the three binary relations R
1 and R
2
deﬁned in Theorem 3 using Lemma 5. The space cost of encoding them in bits is
(cid:3) + ti · o(lg σ ) + O(ti )
(cid:8)
(cid:6)
2
i=0
<
(cid:2)
mσ
et
To support edge_label(x, y, r), we check which of the three trees, T0, T1 and
(cid:5)
3. We then
(cid:5)
2 to compute the result. The other opera-
(cid:2)

(cid:7)
lg
(cid:3) + t · o(lg σ ) + O(t ), which dominates the overall space cost.
(cid:5)
1 or π

T2, contains (x, y), and we compute the rank of this edge in π
perform object_select on R
tions can be supported using Theorem 3.

(cid:3) + ti · o(lg σ ) + O(ti )

(cid:5)
1 or R

(cid:8) = (cid:6)

(cid:7)
log2

(cid:2)
mi σ

ti

(cid:5)
0, R

2
i=0

(cid:2)
mi σ

ti

lg

(cid:5)
0, R

(cid:5)
0, π

Algorithmica (2012) 62:224–257

4.5 Extensions to Planar Graphs

245

We now extend the techniques of Sects. 4.2, 4.3 and 4.4 to general planar graphs. As
any planar graph can be embedded in the plane (i.e. drawn in the plane without edge
intersections), it sufﬁces to represent plane graphs which are planar graphs already
embedded in the plane.
Consider a plane graph G of n vertices and m edges. To use our results on planar
triangulations, we construct a planar triangulation T for G using the following approach.
 We ﬁrst surround G with a large triangle such that all the vertices and edges
of G are in the interior of this triangle. We add the three vertices of this triangle and
(cid:5)
the three edges between them into G, and denote the resulting graph G
. Finally, we
(cid:5)
triangulate each interior face of G
that is a polygon with more than three vertices.
The resulting graph is the planar triangulation T .
be the number of vertices and edges of T , respectively. Then we
(cid:5) = 3n + 3. We denote the three vertices on the exterior face
have n
of T by v0, v1 and vn+2. We denote the vertices of G by their ranks in the canonical
ordering of T . Thus the vertices of G are v2, v3, . . . , vn+1. The three orders π0, π1
and π2 on the vertices of G are simply given by these three orders on the vertices of
T . Recall that we use (T0, T1, T2) to denote the realizer of T , and T0 to denote its
canonical spanning tree.

(cid:5)
(cid:5) = n + 3 and m

Let n

(cid:5)
and m

We ﬁrst extend Theorem 1 to represent unlabeled plane graphs.

(2 log2 6 + ) + o(m
(cid:5)

Theorem 4 A plane graph G of n vertices and m edges can be represented using 
3n(2 log2 3 + 3 + ) + o(n) bits to support operators adjacency, degree,
−1
select_neighbor_ccw, rank_neighbor_ccw as well as j (i) and 
j (i)
(j ∈ {1, 2}) in O(1) time.
Proof We construct the planar triangulation T for G using the above approach.
We then represent T using Theorem 1, in which we use Lemma 13 to encode the
) =
(cid:5)
string S constructed to encode T . Thus T is encoded in m
3n(2 log2 6 + ) + o(n) bits. In addition, we construct the following three bit vectors
to indicate which edge in T is present in G:
– A bit vector B0[1..n + 2], where B0[i] = 1 iff the edge between the ith vertex in
DFUDS order of T0 and its parent in T0 is present in G;
– A bit vector B1[1..n + 1], where B1[i] = 1 iff the edge between the ith vertex in
π1 and its parent in T1 is present in G;
– A bit vector B2[1..n], where B2[i] = 1 iff the edge between the ith vertex in π2
and its parent in T2 is present in G.
We encode these three bit vectors in 3n + o(n) bits using Part (a) of Lemma 1. Thus
the total space cost is 3n(2 log2 6+ )+ 3n+ o(n) = 3n(2 log2 3+ 3+ )+ o(n) bits.
To compute adjacency(x, y), we ﬁrst check whether x and y are adjacent in T .
If they are not, we return false. If they are, the algorithm in the proof of Theorem 1
also tells us which of the three trees, T0, T1 and T2, has the edge (x, y) of T . If x is
y’s parent in T0, we compute y’s DFUDS rank, j , in T0. If B0[j] = 1, then the edge
(x, y) is in G, so we return true. We return false otherwise. The case in which y is x’s

246

Algorithmica (2012) 62:224–257

parent in T0, and the case in which the edge (x, y) of T is in T1 or T2 can be handled
similarly.

To compute degree(x), we observe that the algorithm in the above paragraph can
be used to check whether x and its parents in T0, T1 and T2 are adjacent in G. Thus
it sufﬁces to compute the number of x’s children in T0, T1 and T2 that are adjacent to
x in G. To count the number, u, of x’s children in T0 that are adjacent to x in G, we
compute the DFUDS ranks, p and q, of the ﬁrst and the last child of x in T0. Then u
is equal to the number of 1s in B0[p..q], which can be computed in constant time by
performing rank on B0. The number of x’s children in T1 or T2 that are adjacent to
x in G can be computed similarly.

To use the algorithms in the proof of Theorem 1 to support select_neighbor_
ccw and rank_neighbor_ccw, it sufﬁces to support these two operations: given
a vertex x, select its ith child in T0 (T1 or T2) that is adjacent to it in G; given a
vertex x and a child, y, of it in T0 (T1 or T2) that is adjacent to x in G, compute
the number of y’s left siblings that are adjacent to x in G. To support these two
operations, we ﬁrst compute the DFUDS ranks in T0 (ranks in π1 or π2) of the ﬁrst
and last children of x in T0 (T1 or T2). From these, we can locate the substring of B0
(B1 or B2) corresponding to the children of x in T0 (T1 or T2), and perform rank/select
operations on it to support these two operations in constant time.

Finally, we observe that the algorithms in the proof of Theorem 1 to support j
(cid:2)

−1
j on planar triangulations can be used here directly.

and 

We construct the following succinct indexes for vertex labeled plane graphs.

Theorem 5 Consider a multi-labeled plane graph G of n vertices, associated with
σ labels in t pairs (t ≥ n). Given the support of vertex_label in f (n, σ, t )
time on the vertices of G, there is a succinct index using t · o(lg σ ) + O(t )
bits which supports lab_degree, lab_select_ccw and lab_rank_ccw in
O((lg lg lg σ )2(f (n, σ, t ) + lg lg σ )) time.

Proof We represent the combinatorial structure of G using Theorem 4. The vertices 
of G in canonical order and the set of labels [σ] form a binary relation L. As
vertex_label directly supports object_select on L, we construct a succinct
index of t · o(lg σ ) + O(t ) bits using Lemma 4 for L.

In addition, we construct three binary relations, L0, L1 and L2, between the ranks
of the vertices of G in three different orders and the set of labels. In L0, the ith
object corresponds to the ith vertex in DFUDS order of T0. If this vertex and its
parent in T0 are adjacent in G, we associate its labels with the ith object. Otherwise,
we do not associate any label with this object. As we can perform constant time
conversions between the canonical order of a vertex and its DFUDS rank in T0, and
we can also check whether a node and its parent in T0 are adjacent in G, we can
use vertex_label to support object_select on L0. We construct L1 and L2
using the same approach, except that the ith object in L1 and L2 corresponds to the
ith vertex in π1 and π2, respectively. We can also use vertex_label to support
object_select on them. We construct a succinct index of t · o(lg σ ) + O(t ) bits
using Lemma 4 for each of these three binary relations. Note that although Lemma 4

Algorithmica (2012) 62:224–257

247

assumes that each object is associated with at least one label, the techniques created
to prove it still applies to the more general case in which an object is associated with
zero or more labels (see Sect. 3.4). Furthermore, the result is the same asymptotically
if t > n, which is true here.

As we can perform conversions between the DFUDS rank of T0, π0, π1 and π2,
we can perform label_access on L to check whether the parent of a given vertex
in T0, T1 or T2 is associated with a given label (if this vertex and the parent are
adjacent in G). We also observe that if a vertex and one of its children in T0, T1 or
T2 are not adjacent in G, then the object in L0, L1 or L2 that corresponds to the
child is not associated with any label. Thus we can use the algorithms in the proof
of Theorem 2 to support lab_degree, lab_select_ccw and lab_rank_ccw,
(cid:2)
and this theorem follows.

To design a succinct representation for a vertex labeled plane graph based on the
above theorem, we can use the approach in the proof of Corollary 1, and the following
corollary is immediate.

Corollary 3 A multi-labeled plane graph G of n vertices, associated with σ labels
(cid:3) + t · o(lg σ ) + O(t ) bits to supin 
t pairs (t ≥ n) can be represented using lg
port vertex_label in O(1) time, and lab_degree, lab_select_ccw and
lab_rank_ccw in O((lg lg lg σ )2 lg lg σ ) time.

nσ
t

(cid:2)

We now design succinct indexes for edge labeled plane graphs.

time,

Theorem 6 Consider a multi-labeled plane graph G of n vertices and m edges, in
which the edges are associated with σ labels in t pairs (t ≥ m). Given the support of
edge_label in f (n, σ, t ) time on the edges of T , there is a succinct index using t ·
o(lg σ )+ O(n+ t ) bits which supports lab_adjacency in O(lg lg lg σf (n, σ, t )+
and lab_degree_edge, lab_select_edge_ccw and
lg lg σ )
lab_rank_edge_ccw in O((lg lg lg σ )2(f (n, σ, t ) + lg lg σ )) time.
Proof We add labels to the edges of the planar triangulation T constructed in this
section for G as follows. For each edge of T that is in G, we label it with its labels in
G. For each edge of T that is not in G, we do not associate it with any label. We also
construct B0, B1 and B2 as in the proof of Theorem 4. As we can check whether an
edge of T is in G in constant time, we can support edge_label on T in f (n, σ, t )
time using B0, B1 and B2. We use Theorem 3 to construct a succinct index for the
edge-labeled version of T .
To analyze the space cost, we observe that to encode the succinct indexes for the
three binary relations in the proof of Theorem 3, we need t · o(lg σ ) + O(t + m
(cid:5)
)
bits in total (see the last paragraph in Sect. 3.4). It requires O(n) bits to encode the
combinatorial structure of T . Each of the three bit vectors B0, B1 and B2 occupies
n + o(n) bits. Thus the overall space cost is t · o(lg σ ) + O(t + n) bits.
Observe that although we add more edges when constructing T , none of
them is associated with any labels. Therefore, the operations lab_adjacency,
lab_degree_edge, lab_select_edge_ccw and lab_rank_edge_ccw can
be used directly to support the same operations on G, and the theorem follows. (cid:2)

248

Algorithmica (2012) 62:224–257

To design a succinct representation for an edge labeled plane graph based on the

above theorem, we have the following corollary.

t

time,

(cid:2)
mσ

Corollary 4 A multi-labeled plane graph G of n vertices and m edges, in which
the edges are associated with σ labels in t pairs (t ≥ m), can be represented
(cid:3) + t · o(lg σ ) + O(t + n) bits to support edge_label in O(1)
using lg
time, lab_adjacency in O(lg lg σ )
and lab_degree_edge,
lab_select_edge_ccw and lab_rank_edge_ccw in O((lg lg lg σ )2 lg lg σ )
time.
Proof We encode the combinatorial structure of the planar triangulation T using
Theorem 1. We construct an edge-labeled version of T as in the proof of Theorem 6.
(cid:5)
(cid:5)
(cid:5)
Compute the realizer (T0, T1, T2) of T . Let m
2 and m
1, m
3 denote the numbers of
edges of T in T0, T1 and T2, respectively. Let m1, m2 and m3 denote the numbers of
edges of G in T0, T1 and T2, respectively. Let t1, t2 and t3 denote the total numbers of
edge-label pairs in T0, T1 and T2, respectively. We use the notion of the three orders,
(cid:5)
(cid:5)
2 deﬁned on the edges of T as in the proof of Theorem 6. We construct
0, π
π
the three bit vectors B0, B1 and B2 as in the proof of Theorem 4.
Consider the edges of G that are in T0. Observe that each of them corresponds
(cid:5)
to a 1 in B0. These edges in the order of π
0 and the set of labels form a binary
(cid:5)
relation and we use E
0 to denote it. We use the approach of Barbay et al. [2,
(cid:3) + O(lg lg(nσ )) bits
Proof of Theorem 7] to encode E
to support object_select on it in constant time. Similarly, we deﬁne two bi-
(cid:5)
nary relations E
2 between the edges of G in T1 and T2 in the orders of
(cid:5)
(cid:5)
2, respectively, and the set of labels. We use the same approach to en1 
and π
π
code them. Thus the total space used to encode these three binary relations is
(cid:3) + O(lg lg(nσ ))
(cid:3) + O(lg lg(nσ ))
(cid:6)
2
i=0
bits.

0 in O(m1 + t1) + lg
(cid:5)

(cid:3) ≤ O(m + t ) + lg

(cid:2)
O(mi + ti ) + lg

(cid:5)
1 and E

(cid:5)
1 and π

(cid:2)
m1σ

(cid:2)
mi σ

(cid:2)

ti

t1

mσ

t

To use Theorem 6 to prove this corollary, it sufﬁces to support edge_label(x,
y, r) on G. As the case in which x and y are not adjacent in G is trivial, we consider
only the case in which they are adjacent. We ﬁrst consider the case in which the edge
(x, y) is in T0. Assume, without the loss of generality, that x is y’s parent in T0. Let j
(cid:5)
be y’s DFUDS rank in T0. In this case, the edge (x, y) is numbered j in π
0, which corresponds 
to the (k = rankB0 (1, j ))th edge in E
(k, r)
is the result. The case in which the edge (x, y) is in T1 or T2 can be handled similarly.
(cid:3) + O(lg lg(nσ )),
(cid:2)

The overall space is t · o(lg σ ) + O(t + n) + O(m + t ) + lg

(cid:3) + t · o(lg σ ) + O(t + n) bits as t ≥ m.

(cid:5)
0. Thus object_selectE

which is lg

(cid:2)
mσ

mσ

(cid:5)
0

(cid:2)

t

t

5 k-Page Graphs

5.1 Multiple Parentheses

To present our result on multiple parentheses, we ﬁrst consider the following opera-
(cid:5)
S (α, i), which returns the number of characters α in
tion on strings: string_rank
S[1..i] if S[i] = α (the result is undeﬁned otherwise). This is a less powerful version
of string_rank. We have the following lemma.

Algorithmica (2012) 62:224–257

249

Lemma 14 A string S of length n over alphabet [σ] can be represented using
n(H0(S) + o(lg σ ) + O(1)) bits to support string_access and string_rank
in O(lg lg σ ) time, and string_rank
and string_select in O(1) time. Given
a character α ∈ [σ], this representation also supports the computation of the number
of characters in S that are lexicographically smaller than α in O(1) time.
Alternatively, S can be represented using n(H0(S)+  lg σ + o(lg σ )+ O(1)) bits
for any constant  such that 0 <  < 1 to support string_access in O(1) time,
while providing the same support for all the other operations above.

(cid:5)

Proof To prove the result in the ﬁrst paragraph of this lemma, we use the approach
of Barbay et al. [2, Lemma 12] to encode the string S in n(H0(S) + o(lg σ ) + O(1))
bits. This encoding supports string_access and string_rank in O(lg lg σ )
time, and string_select in O(1) time. Thus we need only show how to sup-
(cid:5)
port string_rank
(α, i), and how to compute the number of characters of S that
are lexicographically smaller than a given character α. In the approach of [2], S is
conceptually treated as an n × σ table E, in which E[α][x] = 1 iff S[x] = α. The
auxiliary structures constructed support the computation of rank(1, i) on an arbitrary 
row, E[α], of E in constant time, if E[α][i] = 1. This can be directly used to
support string_rank
(α, i) in constant time. The number of characters in S that
are lexicographically smaller than α is equal to the number, p, of 1s in the ﬁrst α − 1
rows of E. Each row of E is further divided into blocks of length σ as noted in [2],
and the cardinality of each block is deﬁned as the number of 1s in it. An auxiliary
structure is used to encode the cardinality of each block in row major order, and we
can perform rank/select operations on this auxiliary structure to compute p in constant 
time.

(cid:5)

To prove the second claim of this lemma, observe that the result of Barbay et
al. [2] used in the previous paragraph makes use of a succinct index they designed
for strings. In this index, the string S is divided into substrings called chunks of length
σ , and a permutation π is deﬁned for each chunk. The support for string_access
−1. An auxiliary structure, P , of O(σ lg σ/ lg lg σ )
is then reduced to the access to π
bits is constructed using the approach of Munro et al. [24] for each chunk, so that
−1 can be retrieved in O(1) time and O(lg lg σ ) time reany 
element of π and π
spectively, when string_select is supported in constant time. Thus with this
structure, string_access can be performed in O(lg lg σ ) time. If we increase the
−1 can be computed in consize 
of P to σ lg σ bits, then each element of π and π
stant time [24], so that string_access can be supported in O(1) time. The total
space cost of such auxiliary data structures for all the chunks then becomes n lg σ
bits, which accounts for the increase in the overall space cost of our representation
(cid:2)
of S.

We now consider the succinct representations of multiple parenthesis sequences
of p types of parentheses, where p is not a constant. We consider the following
operation on a multiple parenthesis sequence S[1..2n] in addition to those deﬁned in
Sect. 3.3:

– m_access(i), the parenthesis at position i;
– m_rank

(cid:5)
S (i), the rank of the parenthesis at position i among parentheses of the

same type in S.

250

Algorithmica (2012) 62:224–257

We have the following theorem.

,

)p

(p

Theorem 7 A multiple parenthesis sequence of 2n parentheses of p types, in which
the parentheses of any given type are balanced, can be represented using 2n lg p +
n· o(lg p)+ O(n) bits to support m_access, m_rank
(cid:5)
and m_match in O(lg lg p)
time, and m_select in O(1) time. Alternatively, (2 + )n lg p + n · o(lg p) + O(n)
bits are sufﬁcient to support these operations in O(1) time, for any constant  such
that 0 <  < 1.
Proof We store the sequence as a string P over alphabet {(cid:5)
(cid:5)} using the result in the ﬁrst paragraph of Lemma 14. P occupies at most
(cid:5)
(cid:5)
(cid:5)
2n(lg(2p) + o(lg p) + O(1)) = 2n(lg p + o(lg p) + O(1)) bits.
For each integer i such that 1 ≤ i ≤ p, we construct a balanced parenthesis sequence 
Bi, where Bi[j] is an opening parenthesis iff the j th parenthesis of type i in
P is open. We denote the number of parentheses of type i by ni. Then the length of Bi
is ni. To store all these sequences, we concatenate them to get a balanced parenthesis
sequence B, and we store B in 2n + o(n) bits using Lemma 2. In order to locate Bi
in B, it sufﬁces to compute the numbers of characters in P that are lexicographically
smaller than
, which is supported in constant time by Lemma 14. This
allows us to perform find_open and find_close operations on Bi in constant
time.

(i+1

, . . . ,

and

(1

)1

(2

)2

(i

,

,

,

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(i) = string_rank

The operation m_access can be supported by calling string_access on
(cid:5)
P once, so it can be supported in O(lg lg p) time. To support m_rank
(i), we
ﬁrst compute the parenthesis, α, at position i using m_access in O(lg lg p)
(α, i). We also have m_select(α, i) =
time. Then m_rank
string_select(α, i). Finally, to support m_match(i), we ﬁrst ﬁnd out which
parenthesis is at position i using m_access. Assume, without loss of generality, it is
an opening parenthesis, and let
be this parenthesis. Then the index of the entry in
Bj that corresponds to this parenthesis is q = select_openBj (m_rank
, i)),
and we have m_match(i) = m_select(
(cid:5)

, find_closeBj (q)).

To support all these operations in constant time, it sufﬁces to support string_
access on P in constant time. This can be achieved by using the result in the second
(cid:2)
paragraph of Lemma 14. The total space is thus increased by n lg p bits.

(cid:5)
(

)j

(j

(j

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

5.2 k-Page Graphs for Large k

On unlabeled k-page graphs, we consider the operators adjacency and degree
deﬁned in Sect. 4.2, and the operator neighbors(x), returning the neighbors of x.
As mentioned in Sect. 2, previous results on representing k-page graphs [14, 22]
succinctly support adjacency in O(k) time. The lower-order term in the space
cost of the result of Gavoille and Hanusse [14] is o(km), which is dominant when
k is large. Thus previous results mainly deal with the case in which k is small. We
consider large k.

In this section, we denote each vertex of a k-page graph by its rank along the spine
of the book (i.e. vertex x is the xth vertex along the spine). We deﬁne the span of
an edge between vertices x and y to be |y − x|. An edge between vertices x and y,
where x < y, is a right edge of x and a left edge of y. We show the following result.

Algorithmica (2012) 62:224–257

251

Theorem 8 A k-page graph G of n vertices and m edges can be represented using 
n + 2m lg k + m · o(lg k) + O(m) bits to support adjacency in O(lg k lg lg k)
time, degree in O(1) time, and neighbors(x) in O(d(x) lg lg k) time where d(x)
is the degree of x. Alternatively, it can be represented in n + (2 + )m lg k + m ·
o(lg k)+ O(m) bits to support adjacency in O(lg k) time, degree in O(1) time,
and neighbors(x) in O(d(x)) time, for any constant  such that 0 <  < 1.
Proof We construct a bit vector B of n+ m bits to encode the degree of each vertex in
unary as in [18], in which vertex x corresponds to the xth 1 followed by d(x) 0s. We
encode B in n + m + o(n + m) bits using part (a) of Lemma 1 to support rank/select
operations. We construct a multiple parenthesis sequence S of 2m parentheses of k
types as follows. For each vertex x ∈ {1, 2, . . . , n}, we write down the following four
groups of parentheses as a substring of S in the order speciﬁed below:
1. For each page i ∈ {1, 2, . . . , k}, if there are j left edges of x on this page where

j > 0, we write down j − 1 copies of the symbol
(cid:5)
)p1
and write down the sorted sequence, i.e. in the sorted sequence,
fore
maximum span of the left edges of x on page pv.

2. Assume that the left edges of x are on pages p1, p2, . . . , pl. We sort the sequence
by the maximum span of the left edges of x on these pages
appears beif 
the maximum span of the left edges of x on page pu is less than the

)p2
(cid:5)

, . . . ,

)pu

)pv

)pl

,
(cid:5)

)i

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(cid:5)

.

(cid:5)

(cid:5)

(cid:5)

(cid:5)

3. Similarly, we assume that the right edges of x are on pages q1, q2, . . . , qr . We sort
by the maximum span of the right edges of x on

the sequence
these pages and write down the sorted sequence in descending order.
(cid:5)

4. For each page i ∈ {1, 2, . . . , k}, if there are j
(cid:5)
.

right edges of x on this page where

(cid:5) − 1 copies of

> 0, we write down j

, . . . ,

(q1

(q2

(pl

j

,

(cid:5)

(cid:5)

(cid:5)

(cid:5)

(i

Although the sequence, S, appears similar to the sequence in Theorem 2 of [14],
it differs in the order we store the parentheses corresponding to the edges of a given
vertex. It also has 2m parentheses of k types, and we encode it using Theorem 7 in
2m lg k + m · o(lg k) + O(m) bits. Finally we construct a bit vector B
of 2m bits in
(cid:5)[i] = 1 iff S[i] is a closing parenthesis, and encoding it in 2m + o(m) bits
which B
using part (a) of Lemma 1 to support rank/select operations. Thus the total space cost
is n + 2m lg k + m · o(lg k) + O(m) bits.

(cid:5)

With the above deﬁnitions and structures, the algorithm [14] that checks whether
there is an edge between vertices x and y on page p can be described as follows
(assume, without loss of generality, that x < y). Let w be the index of the parenthesis
in S that corresponds to the right edge of x with the largest span on page p. Observe
that this position corresponds to the ﬁrst occurrence of the character (p in S after
position rankB (0, selectB (1, x)). We assume that w is given and design the following 
algorithm, which is used in the next paragraph to support adjacency. We
retrieve the index, t, of the closing parenthesis that matches S[w] in O(lg lg k) time,
and if it corresponds to a left edge of y (this is true iff rankB (1, t ) = y), then there is
an edge between x and y. Similarly, we retrieve the parenthesis in S that corresponds
to the left edge of y with the largest span on page p (again, we assume that the index
of the occurrence of the parenthesis corresponding to it is given), and if its matching
opening parenthesis corresponds to a right edge of x, then x and y are adjacent. If the

252

Algorithmica (2012) 62:224–257

above process cannot ﬁnd an edge between x and y, then x and y are not adjacent on
page p. All these steps take O(lg lg k) time.

To compute adjacency(x, y) (assume, without loss of generality, that x < y),
we ﬁrst observe that by Step 2 of the construction algorithm for S, the opening parentheses 
that correspond to the right edges of x with the largest spans among the right
edges of x on the same pages form a substring of S. We can compute the starting
position of this substring using B and B
in constant time. Because these parentheses
are sorted by the spans of the edges they correspond to, we can perform a doubling
search to check whether one of these edges connects x and y. In each step of the doubling 
search, we perform the algorithm in the previous paragraph in O(lg lg k) time.
There are at most k such parentheses, so we perform the algorithm O(lg k) times.
Similarly, we perform doubling search on the left edges of y with the largest spans
among the left edges of y on the same pages. Thus we can test the adjacency between
two vertices in O(lg k lg lg k) time.

(cid:5)

The degree of any vertex can be easily computed in constant time using B. We can
also use the algorithms presented in previous work [14] to compute neighbors(x).
More precisely, for each opening or closing parenthesis corresponding to an edge
incident with x, we ﬁnd its matching parenthesis to locate the other vertex that it is
incident with. This takes O(d(x) lg lg k) time on our data structures.
Finally, to improve the time efﬁciency, we can store S using (2 + )m lg k + m ·
o(lg k) + O(m) bits using Theorem 7 to achieve the other tradeoff.
(cid:2)

5.3 Edge Labeled k-Page Graphs

On edge labeled k-page graphs, we consider lab_adjacency and lab_degree_
edge deﬁned in Sect. 4.4, as well as the following operation: lab_edges(α, x),
the edges incident with vertex x that are labeled α. We deﬁne the interface of the
ADT of edge labeled k-page graphs through the operator edge_label, as deﬁned
in Sect. 4.4.

We ﬁrst design a succinct index for an edge labeled graph with one page, i.e. an

outerplanar graph.

Lemma 15 Consider a multi-labeled outerplanar graph G of n vertices and
m edges, in which the edges are associated with σ labels in t pairs (t ≥ m).
Given the support of edge_label in f (n, σ, t ) time on the edges of G, there
index using t · o(lg σ ) + O(t ) + n + o(n) bits which supports
is a succinct
lab_adjacency in O(lg lg lg σf (n, σ, t ) + lg lg σ ) time, lab_degree_edge in
O((lg lg lg σ )2(f (n, σ, t )+ lg lg σ )) time, and lab_edges(α, x) in O(d(lg lg lg σ )2
× (f (n, σ, t ) + lg lg σ )) time, where d = lab_degree_edge(α, x).
Proof We construct a bit vector B of n + m bits to encode the degree of each vertex
in unary as in the proof of Theorem 8, and use part (a) of Lemma 1 to encode it. We
construct a balanced parenthesis sequence P as follows. List the vertices from left to
right along the spine, and each vertex is represented by zero or more closing parentheses 
followed by zero or more opening parentheses, where the numbers of closing
and opening parentheses are equal to the numbers of its left and right edges respectively.
 The edges ordered by the positions of the corresponding opening parentheses

Algorithmica (2012) 62:224–257

253

Fig. 5 An example of the succinct representation of a labeled graph with one page. For simplicity, each
edge is associated with exactly one label in this example

and the set of labels form a binary relation R. Similarly, the edges ordered by the
positions of the corresponding closing parentheses and the set of labels form a binary
relation L. Figure 5 gives an example.

To compute object_selectR(x, r), we ﬁrst ﬁnd the two vertices y
and z (y < z) incident with the edge corresponding to the xth opening parenthesis
in P . As this parenthesis corresponds to the ith 0 in B, where i = selectP (
(cid:5)
, x),
we have y = rankB (1, i). We ﬁnd the closing parenthesis that matches this
opening parenthesis in P using find_close, and z can be computed similarly.
As object_selectR(x, r) = edge_label(y, z, r), we can support object_
select on R in f (n, σ, t ) time. The support for object_select on L is similar.
We then build a succinct index of t · o(lg σ ) + O(t ) bits for either of L and R using
Lemma 4. These data structures occupy t · o(lg σ ) + O(t ) + n + o(n) bits in total as
t ≥ m.

(cid:5)
(

To compute lab_adjacency(α, x, y), we ﬁrst use the algorithm of Jacobson 
[18] to check whether x and y are adjacent. If they are, we retrieve the position 
of the opening parenthesis in P that corresponds to the edge between x and
y, compute its rank, v, among opening parenthesis, and we return the result of
label_access(v, α) on R. This takes O(lg lg lg σf (n, σ, t ) + lg lg σ ) time.

To compute lab_degree_edge(α, x), we need compute the number, l, of left
edges of x labeled α, and the number, r, of right edges of x labeled α. To compute 
l, we ﬁrst compute the positions l1 and l2 such that each parenthesis in the
substring P[l1..l2] is a closing parenthesis that corresponds to a left edge of x, using
rank/select operations on B and P in constant time. We then use label_rank and
label_select on L to compute the number of objects associated with α between
and including objects l1 and l2 in O((lg lg lg σ )2(f (n, σ, t )+ lg lg σ )) time. Similarly
we can compute r by performing rank/select operations on B, P and R, and the sum
of l and r yields the result. To further list all the edges of x that are labeled α, we
perform label_rank and label_select on L and R to retrieve the positions of
the corresponding parentheses in P , and perform rank and select operations on B to
(cid:2)
retrieve the vertices incident with these edges.

We now use the above lemma to design a succinct representation of edge labeled

outerplanar graph.

254

Algorithmica (2012) 62:224–257

Lemma 16 An outerplanar graph of n vertices and m edges in which the edges are
associated with σ labels in t pairs (t ≥ m) can be represented using n + o(n) +
(cid:2)
mσ
lg

(cid:3) + t · o(lg σ ) + O(t ) bits to support:

t

– edge_label in O(1) time;
– lab_adjacency in O(lg lg σ ) time;
– lab_degree_edge in O((lg lg lg σ )2 lg lg σ ) time;
– lab_edges(α, x) in O(d(lg lg lg σ )2 lg lg σ ) time,
where d = lab_degree_edge(α, x).

Proof We construct B and P as in the proof of Lemma 15. We use Lemma 5 to
(cid:3)+
represent the binary relation R deﬁned in the proof of Lemma 15. This costs lg
t · o(lg σ )+ O(t ) bits. Given two adjacent vertices x and y, we can locate the opening
parenthesis corresponding to the edge between x and y using P and B in constant
time. Thus we can use object_select on R to directly support edge_label,
which in turn supports object_select on L. Hence we can construct a succinct
index of t · lg σ bits for the binary relation L deﬁned in the proof of Lemma 15, and
(cid:2)
this lemma immediately follows.

mσ

(cid:2)

t

To represent an edge labeled k-page graph, we can use Lemma 16 to represent
each page and combine all the pages represented in this way to support operations.
Alternatively, we can use Theorem 8 and an approach similar to Lemma 16 to achieve
a different tradeoff to improve the time efﬁciency for large k. As we consider general
k, the auxiliary data structures may occupy more space than the labels themselves.
Thus we choose to directly show our succinct representations instead of presenting a
succinct index ﬁrst. Note that for sufﬁciently small k, this approach can still be used
to construct a succinct index.

t

mσ

Theorem 9 A k-page graph G of n vertices and m edges, in which the edges are
associated with σ labels in t pairs (t ≥ m), can be represented using k(n + o(n)) +
(cid:2)
(cid:3) + t · o(lg σ ) + O(t ) bits to support:
lg
– edge_label in O(k) time;
– lab_adjacency in O(lg lg σ + k) time;
– lab_degree_edge in O(k(lg lg lg σ )2 lg lg σ ) time;
– lab_edges(α, x) in O(d(lg lg lg σ )2 lg lg σ + k) time,
where d = lab_degree_edge(α, x).
Alternatively, it can be represented using n + o(n) + (2 + )m(lg k + o(lg k)) +
(cid:2)
(cid:3) + t · o(lg σ ) + O(t ) bits, for any constant  such that 0 <  < 1, to support:
mσ

t

lg
– edge_label in O(1) time;
– lab_adjacency in O(lg lg σ + lg k) time;
– lab_degree_edge in O((lg lg lg σ )2 lg lg σ ) time;
– lab_edges(α, x) in O(d(lg lg lg σ )2 lg lg σ ) time,
where d = lab_degree_edge(α, x).

Proof To prove the ﬁrst result, we use Lemma 16 to represent each page. Assume
that mi edges are embedded in the ith page, and that there are ti edge-label pairs

Algorithmica (2012) 62:224–257

255

ti

i=1

(cid:2)
lg

(cid:2)
mi σ

(cid:3) + ti · o(lg σ )

between them and the alphabet set. The total space cost in bits is k(n + o(n)) +
(cid:3) + t · o(lg σ ) + O(t ).
(cid:6)
k
To support the above operations on G, we perform them on each page. Note that to
perform lab_adjacency on a page, it only takes constant time if the edge between
these two vertices is not embedded in this page. It is then easy to show that the above
running time of each operation is correct.

(cid:3) + O(t ) ≤ k(n + o(n)) + lg

mσ

(cid:2)

t

(cid:5)

To prove the second result, we use the second result of Theorem 8 to encode
the combinatorial structure of G. Recall that in its proof, we construct a multiple
. To encode the labels, we use
parenthesis sequence S, and two bit vectors B and B
an approach similar to that used in the proof of Lemma 16. We observe that the
edges of G sorted by the positions of the corresponding opening parentheses (of any
type) in S and the set of labels form a binary relation, and we denote this relation
. Similarly, the edges of G sorted by the positions of the corresponding closing
by R
(cid:5)
. We
parentheses (of any type) in S and the set of labels form a binary relation L
(cid:3) + t · o(lg σ ) + O(t ) bits.
use Lemma 5 to represent the binary relation R
Observe that for the ith closing parenthesis in S, we can locate the position of the
matching opening parenthesis using m_match, and compute the number of opening
. This can be performed in constant time. Thus
parentheses preceding it in S using B
(cid:5)
to directly support object_select on L
.
we can use object_select on R
We construct a succinct index of t · lg σ bits using Lemma 4 for the binary relation
(cid:3)+
. All these data structures occupy n+ o(n)+ (2+ )m lg k+ m· o(lg k)+ lg
(cid:5)
L
(cid:3)+ t · o(lg σ )+ O(t )
t · o(lg σ )+ O(t ) = n+ o(n)+ (2+ )m(lg k + o(lg k))+ lg
bits, as k ≤ m.

(cid:2)
mσ

(cid:2)
mσ

(cid:2)
mσ

in lg

(cid:5)
(cid:5)

(cid:5)

t

(cid:5)

t

t

With the above data structures, the algorithms in the proof of Lemma 15 can be
(cid:2)

easily modiﬁed to support the operations on G, and the theorem follows.5

As a planar graph can be embedded in at most 4 pages [30], we have the following

corollary.

t

(cid:2)
mσ

(cid:3) + t · o(lg σ ) + O(t ) bits to support:

Corollary 5 An edge-labeled planar graph of n vertices and m edges, in which the
edges are associated with σ labels in t pairs (t ≥ m), can be represented using n +
o(n) + lg
– edge_label in O(1) time;
– lab_adjacency in O(lg lg σ ) time;
– lab_degree_edge in O((lg lg lg σ )2 lg lg σ ) time;
– lab_edges(α, x) in O(d(lg lg lg σ )2 lg lg σ ) time,
where d = lab_degree_edge(α, x).

Proof When we prove the second result in Theorem 9, we use the second result in
Theorem 7 to encode the multiple parenthesis sequence S. Theorem 7 applies to
the case in which the number of types of parentheses is non-constant. To prove this

5The ﬁrst result of Theorem 8 can also be applied here using the same approach to achieve a different
tradeoff. However, if we do so, the space cost will remain asymptotically the same, while the support for
operations will be less efﬁcient, as m_match cannot be performed in constant time. Thus we present only
the better tradeoff using the second result of Theorem 8.

256

Algorithmica (2012) 62:224–257

theorem, as a planar graph can be embedded in at most 4 pages, the number of type
of parentheses in S is 4. Thus we can use Lemma 3 to represent S and the corollary
(cid:2)
directly follows.

An alternative approach to obtain a similar result is to compute an embedding
of the planar graph ﬁrst, and then use Corollary 4 to represent it. The space cost is
(cid:3) + t · o(lg σ ) bits. Thus Corollary 4 is more suitable
increased to O(t + n) + lg
when we need to support label-based rank/select operations in ccw order on edge
labeled planar graphs that are already embedded in the plane.

(cid:2)
mσ

t

6 Discussion

In this paper, we have presented a framework for succinct representation of properties
of graphs in the form of labels. Our main results are the succinct representations of
labeled and multi-labeled graphs (we consider vertex/edge labeled planar triangulations,
 vertex/edge labeled planar graphs, as well as edge labeled k-page graphs) to
support various label queries efﬁciently. The additional space cost to store the labels
is essentially the information-theoretic minimum. As far as we know, our representations 
are the ﬁrst succinct representations of labeled graphs. We have also presented
two preliminary results on unlabeled graphs to achieve the main results. First, we
have designed a succinct representation of unlabeled planar triangulations and plane
graphs to support the rank/select of edges in ccw (counter clockwise) order in addition 
to other operations supported in previous work [7–10]. Second, we have designed
a succinct representation for a k-page graph when k is large to support various navigational 
operations more efﬁciently. In particular, we can test the adjacency of two
vertices in O(lg k) time, while previous work uses O(k) time [14, 22].

We expect that our approach can be extended to support some of the other types of
graphs, which is an open research topic. Another open problem is to represent vertex
labeled k-page graphs succinctly.

Our ﬁnal comment is that because Theorems 2, 3, 5 and 6 provide succinct indexes
for vertex/edge labeled planar triangulations and planar graphs, we can in fact store
the labels in compressed form as Barbay et al. [2, 3] did to compress strings, while
still providing the same support for operations. This also applies to Theorem 9, for
which we apply succinct indexes for binary relations to encode the labels.

References

1. Barbay, J., Castelli Aleardi, L., He, M., Munro, J.I.: Succinct representation of labeled graphs. In:
Proceedings of the 18th International Symposium on Algorithms and Computation. LNCS, vol. 4835,
pp. 316–328. Springer, Berlin (2007)

2. Barbay, J., He, M., Munro, J.I., Rao, S.S.: Succinct

indexes for strings, binary relations
and multi-labeled trees. Manuscript http://www.cs.uwaterloo.ca/~mhe/research/manuscript/sisabr.
pdf

3. Barbay, J., He, M., Munro, J.I., Rao, S.S.: Succinct indexes for strings, binary relations and multilabeled 
trees. In: Proceedings of the 18th Annual ACM-SIAM Symposium on Discrete Algorithms,
pp. 680–689 (2007)

Algorithmica (2012) 62:224–257

257

4. Benoit, D., Demaine, E.D., Munro, J.I., Raman, R., Raman, V., Rao, S.S.: Representing trees of higher

degree. Algorithmica 43(4), 275–292 (2005)

5. Bernhart, F., Kainen, P.C.: The book thickness of a graph. J. Combin. Theory, Ser. B 27(3), 320–331

(1979)

6. Blandford, D.K., Blelloch, G.E., Kash, I.A.: Compact representations of separable graphs. In: Proceedings 
of the 14th Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 679–688 (2003)

7. Castelli Aleardi, L., Devillers, O., Schaeffer, G.: Succinct representation of triangulations with a
boundary. In: Proceedings of the 9th Workshop on Algorithms and Data Structures. LNCS, vol. 3608,
pp. 134–145. Springer, Berlin (2005)

8. Castelli Aleardi, L., Devillers, O., Schaeffer, G.: Succinct representations of planar maps. Theor.

Comput. Sci., 408(2–3), 174–187 (2008)

9. Chiang, Y.-T., Lin, C.-C., Lu, H.-I.: Orderly spanning trees with applications. SIAM J. Comput. 34(4),

924–945 (2005)

10. Chuang, R.C.-N., Garg, A., He, X., Kao, M.-Y., Lu, H.-I.: Compact encodings of planar graphs via
canonical orderings and multiple parentheses. In: Proceedings of the 25th International Colloquium
on Automata, Languages and Programming, pp. 118–129 (1998)

11. Chung, F.R.K., Leighton, F.T., Rosenberg, A.L.: Embedding graphs in books: a layout problem with

applications to VLSI design. SIAM J. Algebr. Discrete Methods 8(1), 33–58 (1987)

12. Clark, D.R., Munro, J.I.: Efﬁcient sufﬁx trees on secondary storage. In: Proceedings of the 7th Annual

ACM-SIAM Symposium on Discrete Algorithms, pp. 383–391 (1996)

13. Farzan, A., Munro, J.I.: Succinct representations of arbitrary graphs. In: 16th Annual European Symposium 
on Algorithms, pp. 393–404 (2008)

14. Gavoille, C., Hanusse, N.: On compact encoding of pagenumber k graphs. Discrete Math. Theor.

Comput. Sci. 10(3), 23–34 (2008)

15. He, M.: Succinct indexes. PhD thesis, University of Waterloo, December (2007)
16. He, M., Munro, J.I., Rao, S.S.: Succinct ordinal trees based on tree covering. In: Proceedings of the

34st International Colloquium on Automata, Languages and Programming, pp. 509–520 (2007)

17. Isenburg, M., Snoeyink J.: Face ﬁxer: compressing polygon meshes with properties. In: Proceedings

of the 27th Annual Conference on Computer Graphics, pp. 263–270 (2000)

18. Jacobson G.: Space-efﬁcient static trees and graphs. In: Proceedings of the 30th Annual IEEE Symposium 
on Foundations of Computer Science, pp. 549–554 (1989)

19. Jansson, J., Sadakane, K., Sung, W.-K.: Ultra-succinct representation of ordered trees. In: Proceedings

of the 18th Annual ACM-SIAM Symposium on Discrete Algorithms, pp. 575–584 (2007)

20. Lipton, R.J., Tarjan, R.E.: A separator theorem for planar graphs. SIAM J. Appl. Math. 36(2), 177–

189 (1979)

21. Lu, H.-I., Yeh, C.-C.: Balanced parentheses strike back. ACM Trans. Algorithms 4(3), 1–13 (2008)
22. Munro, J.I., Raman, V.: Succinct representation of balanced parentheses and static trees. SIAM J.

Comput. 31(3), 762–776 (2001)

23. Munro, J.I., Rao, S.S.: Succinct representations of functions. In: Proceedings of the 31st International

Colloquium on Automata, Languages and Programming, pp. 1006–1015 (2004)

24. Munro, J.I., Raman, R., Raman, V., Rao, S.S.: Succinct representations of permutations. In: Proceedings 
of the 30th International Colloquium on Automata, Languages and Programming, pp. 345–356
(2003)

25. Raman, R., Raman, V., Satti, S.R.: Succinct indexable dictionaries with applications to encoding k-ary

trees, preﬁx sums and multisets. ACM Trans. Algorithms 3(4), 43 (2007)

26. Rosenberg, A.L.: The DIOGENES design methodology: toward automatic physical layout. In: Proceedings 
of the International Workshop on Parallel Algorithms & Architectures, pp. 335–348 (1986)
27. Schnyder, W.: Embedding planar graphs on the grid. In: Proceedings of the 1st Annual ACM-SIAM

Symposium on Discrete Algorithms, pp. 138–148 (1990)

28. Tarjan, R.E.: Sorting using networks of queues and stacks. J. ACM 19(2), 341–346 (1972)
29. Yamanaka, K., Nakano, S.-I.: A compact encoding of plane triangulations with efﬁcient query supports.
 In: 2nd Annual Workshop on Algorithms and Computation, pp. 120–131 (2008)

30. Yannakakis, M.: Embedding planar graphs in four pages. J. Comput. Syst. Sci. 38(1), 36–67 (1989)

