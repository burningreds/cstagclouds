6
1
0
2

 
r
a

 

M
1
1

 
 
]
L
G
.
s
c
[
 
 

2
v
4
3
9
3
0

.

2
0
6
1
:
v
i
X
r
a

Bouncing Towers move faster than Hanoï Towers,
but still require exponential time
Jérémy Barbay

Departamento de Ciencias de la Computación (DCC),
Universidad de Chile,
Santiago, Chile
jeremy@barbay.cl

Abstract

The problem of the Hanoï Tower is a classic exercise in recursive programming: the solution
has a simple recursive deﬁnition, and its complexity and the matching lower bound are the
solution of a simple recursive function (the solution is so easy that most students memorize it
and regurgitate it at exams without truly understanding it). We describe how some very minor
changes in the rules of the Hanoï Tower yield various increases of complexity in the solution, so
that they require a deeper analysis than the classical Hanoï Tower problem while still yielding
exponential solutions. In particular, we analyze the problem fo the Bouncing Tower, where just
changing the insertion and extraction position from the top to the middle of the tower results
in a surprising increase of complexity in the solution: such a tower of n disks can be optimally
moved in
less than a Hanoï Tower of same height), via 5 recursive
functions (or, equivalently, one recursion function with 5 states).

3n moves for n even (i.e.

√

Keywords and phrases Brähma Tower problem, Computer Science Education, Hanoï Tower
Problem, Recursivity.

Introduction

1
The Hanoï Tower Problem is a classical problem often used to teach recursivity, originally
proposed in 1883 by Édouard Lucas [5, 6], where one must move n disks, all of distinct size,
one by one, from a peg A to a peg C using only an intermediary peg B, while ensuring
that at no time does a disk stands on a smaller one. As early as 1892, Ball [3] described an
optimal recursive algorithm which moves the n disks of a Hanoï Tower in 2n−1 steps. Many
generalizations have been studied, allowing more than three pegs [4], coloring disks [7], and
cyclic Hanoï Towers [2]. Some problems are still open, as the optimality of the algorithm
for 4-peg Hanoï Tower Problem, and the analysis of the original problem is still a source
of inspiration hundreds of year after its deﬁnition:
for instance, Allouche and Dress [1]
proved in 1990 that the movements of the Hanoï Tower Problem can be generated by a
ﬁnite automaton, making this problem an element of SP ACE(1).

The solution to the Hanoï Tower Problem is simple enough that it can be memorized and
regurgitated at will by students from all over the world: asking about it in an assignment or
exam does not truly test a student’s mastery of the concept of recursivity, pushing instructors
to consider variants with slightly more sophisticated solutions. Some variants do not make
the problem more diﬃcult (e.g. changing the insertion and removal point to the bottom:
the solution is exactly the same), some make it only slightly more diﬃcult (e.g. considering
the case where the disks are not necessarily of distinct sizes, described and analized in
Appendix A), but some small changes can make it surprisingly more diﬃcult.

We consider the Bouncing Tower Problem, which only diﬀerence with the Hanoï Tower
Problem is the insertion and removal point in each tower, taken to be the middle instead
of the top (see Figure 1 for an illustration with Bouncing Towers of sizes n = 3 and n = 4,

© Jérémy Barbay;
licensed under Creative Commons License CC-BY

Leibniz International Proceedings in Informatics
Schloss Dagstuhl – Leibniz-Zentrum für Informatik, Dagstuhl Publishing, Germany

2

Bouncing Towers

and Section 2.1 for the formal deﬁnition). If the disks all weight the same, one can imagine
such a tower as standing on a spring, the elasticity k of the spring being tuned so that the
middle of the tower is always at the same height, where disks are inserted and removed.

Figure 1 An illustration of the rules for
the insertion and removal in a Bouncing
Tower, depending on the parity of its size
(sizes n = 3 and n = 4 here). In each case,
the shaded disk indicates the removal point
and the arrow indicates the insertion point.

As for the classical Hanoï Tower, such insertion and removal rules guarantee that
any move is reversible (i.e. any disk d removed from a peg X can always be immediately
reinserted in the same peg X), that the insertion and removal positions are uniquely
deﬁned, that each peg can always receive a disk, and that each tower with one disk or more
can always yield one disk. The problem is very similar to the Hanoï Tower Problem: one
would expect answering the following questions to be relatively easy, possibly by extending
the answers to the corresponding questions on Hanoï Towers1:

Consider the problem of moving a Bouncing Tower of n disks, all of distinct
size, one by one, from a peg A to a peg C using only an intermediary peg
B, while ensuring that at no time does a disk stands on a smaller one:
1. Which sequences of steps permit to move such a tower?
2. What is the minimal length of such a sequence?
3. How many shortest such sequences are there?

√

√

√

3n = 3 n

√

√

3 = 3 n−1

2 + 2(3 n−3

2 − 1) <

3n−1 − 2

3n (i.e. exactly

3n if n is odd). As

We show that there is a unique shortest sequence of steps which moves a Bouncing Tower
2 if n
of n disks of distinct sizes, and that it is of length at most
3 ≈ 1.733 < 2, this
is even, and 3
5
sequence is exponentially shorter than the corresponding one for the Hanoï Tower Problem
(of length 2n − 1). We deﬁne formally the problem and its basic properties in Section 2: its
formal deﬁnition in Section 2.1, some examples where such towers can be moved faster in
Section 2.2, and some useful concepts on the insertion and removal order of a tower in
Section 2.3. We describe a recursive solution in Section 3, via its algorithm in Section 3.1, the
proof of its correctness in Section 3.2 and the analysis of its complexity in Section 3.3. The
optimality of the solution is proved in Section 4, via an analysis of the graph of all possible
states and transition (deﬁned and illustrated in Section 4.1) and a proof of optimality for each
function composing the solution (Section 4.2). We conclude with a discussion (Section 5) of
various other variants of similar or increased complexity, and share in Appendix A the text
and the solution of a simpler variant successfully used in undergraduate assignments and
exams.

1 For a Hanoï Tower, the answer to those question is that there is a single such shortest sequence, of
length 2n − 1, obtained by the recursion h(n, A, B, C) = h(n−1, A, C, B).”A → B; ”.h(n−1, B, A, C) if
n > 0 and ∅ otherwise.

J. Barbay

3

2

Formal Deﬁnition and Basic Facts

In this section we deﬁne more formally the Bouncing Tower (Section 2.1), how small examples 
already show that moving such towers require less steps than moving a Hanoï Tower
(Section 2.2), and some properties of the order in which disks are inserted or removed on a
peg to build or destroy a tower (Section 2.3).

2.1 Formal Deﬁnition
The “middle” disk of a tower of even size is not well deﬁned, nor is the “middle” insertion
point in a tower of odd size: we deﬁne both more formally in such a way that if n is odd, the
removal position is the center one, and the insertion point is below it; while if n is even,
the insertion point is in the middle of the tower, while the removal position is below the
middle of the tower (see Figure 1 for an illustration with sizes n = 3 and n = 4). More
formally, on a peg containing n disks ranked by increasing sizes, the removal point is the
disk of rank b n

2c + 1; and the insertion point is position b n+1
2 c.

The insertion of disk d on peg X is legal if inserting d in the insertion point of X
yields a legal conﬁguration, where no disk is above a smaller one. A move from peg X to
peg Y is legal if there is a disk d to remove from X, and if the insertion of d on the Y is
legal.

2.2 Moving small towers - diﬀerences with Hanoï
For size one or two, there is no diﬀerence in the moving cost between a Hanoï Tower and
a Bouncing Tower. The ﬁrst diﬀerence appears for size three, when only ﬁve steps are
necessary to move a Bouncing Tower (see the sequence of ﬁve steps to move a Bouncing
Tower of size n = 3 in Figure 2) as opposed to the seven steps required for moving a
classical Hanoï Tower (see the sequence of seven steps to move a Hanoï Tower of size n = 3
in Figure 3).

A → B

A → B

A → C

B → C

B → C

1
2
3
A

B

C

1
3
A

2
B

C

2
3
B

1
A

C

A

2
3
B

1
C

2
B

A

1
3
C

1
2
3
C

A

B

Figure 2 A Bouncing Tower of three disks can be moved in just ﬁve steps.

A → C

A → B

C → B

A → C

B → A

B → C

A → C

1
2
3
A

B

C

2
3
A

1
C

B

3
A

2
B

1
C

1
2
B

3
A

C

A

1
2
B

3
C

1
A

2
B

3
C

1
A

B

2
3
C

1
2
3
C

A

B

Figure 3 A Hanoï Tower of three disks require seven steps to be moved between two pegs.

When an odd number of disks is present on the peg A, and an even number is present
on pegs B and C, a sub-tower of height 2 can be moved from A in 2 steps, when in a
Hanoï Tower we need 3 steps to move any subtower of same height. In the Bouncing Tower
Problem, having a third disk “ﬁxed” on A yields a reduced number of steps. We formalize
this notion of “ﬁxed” disk in the next section.

4

Bouncing Towers

2.3 Structural facts on a single Peg
Before considering the complete problem over three pegs, we describe some concept about
single pegs, and on the order in which the disks are inserted and removed on a speciﬁc peg.
(cid:73) Deﬁnition 1. We deﬁne the removal order as the order in which disks (identiﬁed by their
rank in the ﬁnal tower) can be removed from a Bouncing Tower. Symmetrically, we deﬁne
the insertion order as the order in which the disks are inserted in the tower.

The symmetry of the rules concerning the insertion and removal location of Bouncing 
Towers yields that the insertion order is the exact reverse of the removal order (the
insertion point of a tower is the removal point of a tower with one more disk), and each
disk removed from a peg can be immediately replaced exactly where it was.

In particular, a key argument to both the description of the solution in Section 3 and
to the proof of its optimality in Section 4 is the fact that, when some (more extreme) disks
are considered as “ﬁxed” (i.e. the call to the current function has to terminate before such
disks are moved), the order in which a subset of the disks is removed from a peg depends
on the number of those “ﬁxed” disks.
(cid:73) Deﬁnition 2. When moving recursively n disks from a peg X with x > n disks, the x− n
last disks in the removal order of X are said to be ﬁxed. The parity of peg X is the parity
of the number x of disks ﬁxed on this peg.

Bouncing Towers cannot be moved much faster than Hanoï Towers:

(cid:73) Lemma 3. It is impossible to move more than one disk between two pegs of same parity
without a third peg.
Proof. Between two pegs of same parity, the removal order is the same. So the ﬁrst disk
needed on the ﬁnal peg will be the last one removed from the starting peg. With more than
(cid:74)
one disk, we need the third peg to dispose temporally other disks.
(cid:73) Lemma 4. It is impossible to move more than two disk between two pegs of opposite
parities without a third peg.
Proof. Between two pegs of opposite parities, the removal orders are diﬀerent: But the
deﬁnition of the middle is constant when the number of disks changes of 2. So after moving
(cid:74)
two disks the third cannot be inserted in the right place.

The removal and insertion orders are changing with the parity of the Bouncing Tower:

Consider a peg with n disks on it:

if n = 2m + 1 is odd, then the disks are removed in the following order:

(m + 1, m + 2, m, m + 3, m − 1, m + 4, . . . , 3, 2m, 2, 2m + 1, 1)

if n = 2m is even, then the removal order is:

(m + 1, m, m + 2, m − 1, m + 3, m − 2, . . . , 2m − 1, 2, 2m, 1)

The relative order of m and m + 2, of m − 1 and m + 3, and more generally of any pair
of disks i and m − i for i ∈ [1..bn/2c], are distinct. More speciﬁcally, disks are alternately
extracted below and above the insertion point. This implies the two following connexity
lemma:

J. Barbay

5

(cid:73) Lemma 5. The k ﬁrst disks removed from the tower are contiguous in the original tower,
and they are either all smaller or all larger than the (k + 1)-th disk removed.
(cid:73) Lemma 6. If k disks are all smaller than the disk below the insertion point, and all
larger than the disk above the insertion point, then there exists an order in which to add
those k disks to the tower.

Proof. By induction: for one disk it is true; for k disks, if the insertion point after the
insertion of disc d is above d then add the larger and then the k − 1 disks left, else add
the smaller and then the k − 1 disks left.
(cid:74)

We present in the next section a solution to the Bouncing Tower Problem which takes
advantage of the cases where two disks can be moved between the same two pegs in two
consecutive steps.

3

Solution

One important diﬀerence between Hanoï Towers and Bouncing Towers is that we need not
always to remove n−1 disks of a tower of n disks to place the n-th disk on another peg (e.g.
in the sequence of steps shown in Figure 2, disk 3 was removed from A when there was still
a disk sitting on top of it). But we need always to remove at least n − 2 disks in order to
release the n-th disk, as it is the last or the last-but-one disk removed. This yields a slightly
more complex recursion than in the traditional case. We describe an algorithmic solution
in Section 3.1, prove its correctness in Section 3.2, and analyze the length of its output in
Section 3.3. We prove the optimality of the solution produced separately, in Section 4.

3.1 Algorithm
Note |A| the number of disks on peg A, |B| on B and |C| on C. For each triplet (x, y, z) ∈
{0, 1}3, we deﬁne the function movexyz(n, A, B, C) moving n disks from peg A to peg C
using peg B when |A| ≥ n, |A| − n ≡ x mod 2, |B| ≡ y mod 2, |C| ≡ z mod 2, and the n
ﬁrst disks extracted from A can be legally inserted on B and C. Less formally, there are x
ﬁxed disks on the peg A, y on B and z on C.

We need only to study three of those 23 = 8 functions. First, as the functions are
symmetric two by two:
for instance, move000(n, A, B, C) behaves as move111(n, A, B, C)
would if the insertion point in a tower of odd size was above the middle disk, and the
removal point in a tower of even size was above the middle of the tower:
in particular,
they have exactly the same complexity. Second, the reversibility and symmetry of the
functions yields a similar reduction: move001(n, A, B, C) has the same structure as the
function move100(n, A, B, C) and the two have the same complexity.

We describe the python code implementing those functions in Figures 4to 7, so that
the initial call is made through the call move000(n,"a","b","c"), while recursive calls
refer only to functions move000(n, A, B, C) (Figure 4), move100(n, A, B, C) (Figure 5),
move001(n, A, B, C) (similar to move100(n, A, B, C) and described in Figure 6) and move010(n, A, B, C)
(Figure 7).

The algorithm for move000(n, A, B, C) (in Figure 4) has the same structure as the corresponding 
one for moving Hanoï Towers, the only diﬀerence being in the parity of the pegs
in the recursive calls, which implies calling other functions than move000(n, A, B, C), in this
case move001(n, A, B, C) and move100(n, A, B, C). The algorithms for move100(n, A, B, C)

6

Bouncing Towers

Figure 4

move000(n, A, B, C)

Figure 5

move100(n, A, B, C)

Figure 7

move010(n, A, B, C)

def move100 (n,a,b,c):

def move010 (n,a,b,c):

def move (a,b):

print "("+ a+",",
print b+")" ,

def move000 (n,a,b,c):

if n >0 :

move100 (n-1,a,c,b)
move (a,c)
move001 (n-1,b,a,c)

if n == 1 :
move (a,c)

elif n == 2 :

move (a,b)
move (a,c)
move (b,c)
elif n >2 :

move010 (n-2,a,b,c)
move (a,b)
move (a,b)
move010 (n-2,c,b,a)
move (b,c)
move (b,c)
move010 (n-2,a,b,c)

if n == 1 :
move (a,c)
elif n >1 :

move100 (n-2,a,c,b)
move (a,c)
move (a,c)
move010 (n-2,b,a,c)

Figure 6

move001(n, A, B, C)

def move001 (n,a,b,c):

if n == 1 :
move (a,c)
elif n >1 :

move010 (n-2,a,c,b)
move (a,c)
move (a,c)
move001 (n-2,b,a,c)

(in Figure 5) and move001(n, A, B, C) (in Figure 6) and are taking advantage of the diﬀerence 
of parity between the two extreme pegs to move two consecutive disks in two moves, but
still has a similar structure to the algorithm for move000(n, A, B, C) and the corresponding
one for moving Hanoï Towers (just moving two disks instead of one).

The algorithm for move010(n, A, B, C) is less intuitive. Given that the removal and
insertion orders on the origin peg A and on the destination peg C are the same (because
the parity of those pegs is the same), n − 1 disks must be removed from A before the last
disk of the removal order, which yields a naive algorithm such as described in Figure 8.
Such a strategy would yield a correct solution but not an optimal one, as it reduces the size
only by one disk at the cost of two recursive calls and one step (i.e. reducing the size by two
disks at the cost of four recursive calls and three steps), when another strategy (described
in the algorithm in Figure 7) reduces the size by two at the cost of three recursive calls and
four steps: moving n − 2 disks to C, the two last disks of the removal order on B, then
n − 2 disks to A, the two last disks of the removal order on C, then ﬁnally the n − 2 disks
to C. The ﬁrst strategy (f(n) = 2f(n − 1) + 2 = 4f(n − 2) + 3) yields a complexity within
Θ(2n) while the second strategy (f(n) = 3f(n − 2) + 4) yields a complexity within Θ(3 n
2 ).
We show in Section 3.2 that moving two disks at a time is correct in this context and in
Section 4 that the latter yields the optimal solution.

3.2 Correctness of the algorithm
We prove the correctness of our solution by induction on the number n of disks.
(cid:73) Theorem 7. For any positive integer value n, and any triplet (x, y, z) ∈ {0, 1}3 of booleans,
the function movexyz(n, A, B, C) produces a sequence of legal steps which moves a Bouncing
Tower from A to C via B.

J. Barbay

Figure 8
Alternative
optimal)
take on move010(n, A, B, C)

(non

% |A|-n >0 is even ;
% |B| is odd;
% |C| is even .
IF n==1
move (A,C);
ELSE
move101 (n-1,A,C,B);
move (A,C);
move101 (n-1,B,A,C);
ENDIF

7

Figure 9
Alternative
optimal)
take on move101(n, A, B, C)

(non

% |A|-n >0 is even ;
% |B| is odd;
% |C| is even .
IF n==1
move (A,C);
ELSE
move010 (n-1,A,C,B);
move (A,C);
move010 (n-1,B,A,C);
ENDIF

The proof is based on the following invariant, satisﬁed by all recursive functions on

entering and exiting:
(cid:73) Deﬁnition 8. Requirement for insertion (i): The disks above the insertion point of B or
C are all smaller than the ﬁrst n disks removed from A; and the disks below the insertion
point of B or C are all larger than the ﬁrst n disks removed from A (see an illustration in
Figure 10).

1
2
n−1
n

4
...
n−2
3
A B C

Figure 10 Requirement for insertion (i): disks 4 to n − 2
can be inserted on B as the insertion point of B is between 2
and n − 1; and on C as the insertion point of C is under 3.

Proof. Consider the property IH(n) = “∀(x, y, z) ∈ {0, 1}3, ∀i ≤ n, movexyz(i, A, B, C) is
correct”. IH(0) is trivially true, and IH(1) can be checked for all functions at once. For all
values x, y, z, the function movexyz(1, A, B, C) is merely performing the step move(A → C).
The hypothesis IH(1) follows. Now, for a ﬁxed n > 1, assume that IH(n − 1) holds: we
prove the hypothesis IH(n) separately for each function.

Analysis of move000(n, A, B, C):
1. According to IH(n − 1) the call to move100(n − 1, A, B, C) is correct if (i) and (p)100
are respected. (i) is implied by (i) on move000(n − 1, A, B, C); (p)100 is implied by
(p)000 and the remaining disk on A (a − n mod 2 ≡ 0 ⇒ a − (n − 1) mod 2 ≡ 1
mod 2).
2. The step move(A → C) is possible and legal because of the precondition (i) for
move000(n, A, B, C): the disk moved was in the n ﬁrst removed from A, and so can
be introduced on C.

3. The call to move001(n, A, B, C) is symmetrical to 1, and so correct.
4. We can check the ﬁnal state by verifying that the number of disks removed from A

and added to C is (n − 1) + 1 = n.

So move000(n, A, B, C) is correct.

8

Bouncing Towers

Analysis of move100(n, A, B, C):
1. move100(n−2, A, B, C) is correct according to IH(n−1), as the requirements are also:
The requirement (i) is given by (i) for the initial call, and the parity (p)100 is respected
because we move two disks less than in the current call to move100(n, A, B, C).

2. The two disks left (let us call them α and β) are in position (given ﬁg. 11, (i)) such
that the removal order on A is (α, β) and the insertion order on C is (β, α) (see
ﬁg.11, (ii)). They can be inserted on C because of requirement (i). So the two disks
are correctly moved in two steps.

3. The requirements for move010(n − 2, A, B, C) are satisﬁed:

(i) stand as a consequence of the precondition (i) for the current call, as the n − 2
disks to be moved on C were on A before the original call, in the middle of α and
β.
(p)010: The number of disks on C is still even as we added two disks. The number
of disks on A is still odd as we removed two disks.

So, because of IH(n − 2), move010(n − 2, A, B, C) is correct.

So move100(n, A, B, C) is correct.

(i)

n odd: a is removed ﬁrst,
y is removed second.

(ii)

n even: y is removed ﬁrst,
x is removed second.

Figure 11 Removal order of the last two disks.

Analysis of move001(n, A, B, C): This function is the exact symmetric of move100(n, A, B, C),
for a task exactly symmetric, so has a symmetric proof of its correctness.
Analysis of move010(2, A, B, C): The two disks (let us call them α and β) are in position
(given ﬁg. 11, (ii)) such that the removal order on A is (β, α) and the insertion order
on C is (α, β, ), as A and C have the same parity. β can be inserted on B and they
can both be inserted on C because of requirement (i). So the two disks are correctly
moved in three steps, using peg B to dispose temporally disk β. So move010(2, A, B, C)
is correct.
Analysis of move010(n, A, B, C) if n > 2: All along of this proof of correctness we shall
use the fact that ﬁxing 2 disks on the same peg doesn’t change the parity of this peg.
1. move010(n − 2, A, B, C) is correct as: from (i) for the initial call results (i) for the
ﬁrst recursive call; (p)010 is a natural consequence of (p)010 for the initial call (because
parity conserved when icing two disks). So IH(n − 1) implies that move010(n −
2, A, B, C) is correct.

xyxyJ. Barbay

9

n
f010
f100
f000
3dn/2e

0
0
0
0
1

1
1
1
1
3

2
3
2
3
3

3
7
4
5
9

4
13
7
9
9

5
25
13
15
27

6
43
22
27
27

7
79
40
45
81

8
133
67
81
81

9
241
121
135
243

10
403
202
243
243

11
727
364
405
729

12
1213
607
729
729

13
2185
1093
1215
2187

14
3643
1822
2187
2187

15
6559
3280
3645
6561

Figure 12 The ﬁrst values of f010,f100 and f000, computed automatically from the recursion.

those corrobolate the intuition that f100(n) < f000(n) for values of n larger than 1.

2. A and B having diﬀerent parities, we can move two consecutive disks in two consec3.
 The second recursive call to move010(n − 2, A, B, C) veriﬁes conditions (i) and (p)010

utive calls as for move100(n, A, B, C).

as only two extremes disk have been removed from A.

4. The two next steps are feasible because of the diﬀerence of parity between B and C
5. The last recursive call is symmetric to the ﬁrst call, as we move back the n − 2 disks

(same argument as point 2).

between the two extreme disk, but this time on C.

So move010(n, A, B, C) is correct.

We analyze the complexity of this solution in the next section.

(cid:74)

3.3 Complexity of the algorithm
Let fxyz(n) be the complexity of the function movexyz(n, A, B, C), when |A| ≥ n, |A|−n ≡ x
mod 2, |B| ≡ y mod 2 and |C| ≡ z mod 2. The algorithms from Figures 4 to 7 yield a
recursive system of four equations.




∀x, y, z
∀x, y, z

∀n > 1,
∀n > 1,
∀n > 1,
∀n > 2,

fxyz(0) = 0
fxyz(1) = 1
f010(2) = 3
f000(n) = f100(n − 1) + 1 + f001(n − 1)
f100(n) = f100(n − 2) + 2 + f010(n − 2)
f001(n) = f010(n − 2) + 2 + f001(n − 2)
f010(n) = 3f010(n − 2) + 4

∀x, y, z
∀x, y, z

∀n > 1,
∀n > 1,
∀n > 2,

fxyz(0) = 0
fxyz(1) = 1
f010(2) = 3
f000(n) = 2f100(n − 1) + 1
f100(n) = f100(n − 2) + 2 + f010(n − 2)
f010(n) = 3f010(n − 2) + 4

As f001 is deﬁned exactly as f100 (because of the symmetry between move001(n, A, B, C)
and move100(n, A, B, C)), we can replace each occurence of f001 by f100, hence reducing the
four equations to a system of three equations:

Lemmas 9 to 11 resolve the system function by function. The function f010(n) can be

solved independently from the others:

10

Bouncing Towers

(cid:73) Lemma 9. f010(n) =



0
1
3
3 n+1
5 × 3 n

2 − 2

2 −1 − 2

if n = 0;
if n = 1;
if n = 2;
if n ≥ 3 is odd; and
if n ≥ 4 is even.

Proof. Consider the recurrence Xk+1 = 3Xk +4 at the core of the deﬁnition of f010: a mere
extension yields the simple expression Xk = 3k(X0 + 2) − 2.
2 ≥ 1, U0 = 1 and Uk+1 = 3Uk + 4 so that f(2k + 1) =
2 ≥ 1, V0 = 3 and Vk+1 = 3Vk + 4 so that f(2k) = Vk =
(cid:74)

When n ≥ 3 is odd, set k = n−1
Uk = 3k(1 + 2) − 2. Then f010(n) = 3 × 3k − 2 = 3k+1 − 2 for n ≥ 3 and odd.
When n ≥ 4 is even, set k = n
3k(3 + 2) − 2, so that f010(n) = 5 × 3k − 2 for n ≥ 4 and even.

Gathering all the results yields the ﬁnal expression.

The expression for the function f010 yields the expression for the function f100:

(cid:73) Lemma 10. f100(n) =



0
1
2
4
2 × 3 n
5
3 n+1
2 −1
2

2 −1 + 2

if n = 0;
if n = 1;
if n = 2;
if n = 3;
where n ≥ 4 is even; and
where n ≥ 5 is odd.

Proof. Consider the projection of the system to just f100:

f100(n) =

1
f100(n − 2) + 2 + f010(n − 2)

if n = 0
if n = 1
if n ≥ 2

 0

For any integer value of k ≥ 0, we combine some change of variables with the results

from Lemma 9 to yied two linear systems, which we solve separately:

Vk = f100(2k) and V0 = f100(0) = 0 so that f100(n) = Vk if n is even and k = n
2 ; and
Uk = f100(2k + 1) and U0 = f100(1) = 1 so that f100(n) = Uk if n is odd and k = n−1
2 .
On one hand, Uk = Uk−1 + 2 + f010(2k + 1 − 2) for k > 0 and U0 = 1. This yields a

linear recurrence which we develop as follow:

− 2 via Lemma 9 because 2k − 1 is odd;

Uk = Uk−1 + 2 + f010(2k − 1) by deﬁnition;

2

= Uk−1 + 2 + 3 × 3 (2k−1)−1
= Uk−1 + 3k by mere simpliﬁcation;
= U0 + 3
= 3k+1 − 1

because U0 = 1.

2

2(3k − 1) by resolution of a geometric serie;

Since f100(n) = U n−1

if n is odd.
On the other hand, Vk = Vk−1 + 2 + f010(2k − 2) for k > 0 and V0 = 0. The initial
conditions of f010 for n = 0, 1 and 2 yields the three ﬁrst values of Vk: V0 = 0; V1 =

when n is odd, the solution above yields f100(n) = 3 n+1
2 −1
2

2

J. Barbay

11

V0 + 2 + f010(0) = 0 + 2 + 0 = 2; and V2 = V1 + 2 + f010(2) = 2 + 2 + 3 = 7. Then we develop
the recursion for k ≥ 3 similarly to Uk:

Vk = Vk−1 + 2 + f010(2k − 2) by deﬁnition;

= Vk−1 + 2 + 5 × 3 (2k−2)
= Vk−1 + 5 × 3k−2 by mere simpliﬁcation (still only for k ≥ 3);

2 −1 − 2 for 2k − 2 ≥ 4 even, or any k ≥ 3 via Lemma 9;

= V2 + 5(cid:0)31 + ··· + 3k−2(cid:1) by propagation;
= V2 + 53k−1 − 2
= 7 + 5
= 5

2(3k−1 − 2) because V2 = 7;

23k−1 + 2 by simpliﬁcation.

2

by resolution of a geometric serie;

Since f100(n) = V n
even.

2 when n is even, the solution above yields f100(n) = 5

23 n

2 −1 + 2 if n is

Reporting those results in the deﬁnition of f100 yields the ﬁnal formula:

f100(n) =

0
1
2
4
2 × 3 n
5
3 n+1
2 −1
2

if n = 0;
if n = 1;
if n = 2;
if n = 3;

2 −1 + 2 where n ≥ 4 is even; and

where n ≥ 5 is odd.




Finally, the expression for the function f100 directy yields the expression for the function

f000:

(cid:73) Lemma 11. f000(n) =

1
3
5
3 n
2
5(3 n−3

2 + 1)

if n = 1
if n = 2
if n = 3
where n ≥ 4 is even; and
where n ≥ 5 is odd.

Proof.

f100(n) =

if n = 1;
if n = 2;
if n = 3;

1
2
4
2 −1 + 2 where n ≥ 4 is even; and
5
23 n
3 n+1
2 −1
2

where n ≥ 5 is odd.

f000(n) =

1
3
5
5 × 3 n−1
3 n
2

if n = 1
if n = 2
if n = 3

2 −1 + 5 where n ≥ 5 is odd; and

where n ≥ 6 is even.




From these results, deduce the value of f000(n) using that f000(n) = 2f100(n − 1) + 1.

(cid:74)

(cid:74)

12

Bouncing Towers

√

As

3 ≈ 1.73 < 2, this value is smaller than the number 2n −1 of steps required to move

a Hanoï Tower. We prove that this is optimal in the next section.

4 Optimality
Each legal state of the Bouncing Tower Problem with three pegs and n disks can be uniquely
described by a word of length n on the three letters alphabet {A, B, C}, where the i-th letter
indicates on which peg the i-th largest disk stands. Moreover, each word of {A, B, C}n
corresponds to a legal state of the tower, so there are 3n diﬀerent legal states (even though
not all of them are reachable from the initial state).

To prove the optimality of our algorithm, we prove that it moves the disks along the
shortest path in the conﬁguration graph (deﬁned in Section 4.1) by a simple induction proof
(in Section 4.2).

4.1 The conﬁguration graph
The conﬁguration graph of a Bouncing Tower has 3n vertices corresponding to the 3n legal
states, and two states s and t are connected by an edge if there is a legal move from state s to
state t. The reversibility of moves (seen in Section 2.3) implies that the graph is undirected.
Consider the initial state A . . . A (= An). The smallest disk 1 cannot be moved before
the other disks are all moved to peg B or all moved to peg C: we can’t remove disk 1 from
peg A if there is a disk under it, and we can’t put it on another peg if a larger disk is already
there. This partitions G into three parts, each part being characterized by the position of
disk 1; these parts are connected by edges representing a move of disk 1 (see the recursive
decomposition of G(n) in Figure 13).
Each part is an instance of the conﬁguration graph G0(n − 1) deﬁning all legal steps of
(n − 1) disks {2, . . . , n} given that disk 1 is ﬁxed on its peg.

Figure 13 First decomposition of the conﬁguration graph of the Bouncing Tower Problem.
Let us consider this subgraph G0(n − 1), when disk 1 (the smallest) is ﬁxed on one peg
(say on peg A). Note each state of this graph aX . . . Z, where a stands for the disk 1 ﬁxed on
peg A, and X . . . Z for positions of other disks on diverse pegs. The removal order changes
from those observed in G each time |A| is odd.

To remove the two extreme disks 2 and n (not moving disk 1, since it is ﬁxed), it is
necessary to move all other disks to a single other peg (same argument as for G(n)), so we
can divide our conﬁguration graph in subsets of states corresponding to diﬀerent positions
where disks 2 and n are ﬁxed.

J. Barbay

13

3
...
1
n−1
2
A B C

n

3
...
1
n−1 n
2
A B C

1
3
...
n−1
n
A B C

2

2
3
...
n−1 n
1
A B C

Figure 14 States where disk 2 is on A and
disk n is on another peg (i.e. B or C) cannot be
accessed from the initial state A . . . A for n > 4.
No move is possible from these states as A cannot
receive larger disk than 2 (and all are), B cannot
receive smaller disk than n (and all are), and C
cannot receive disk 2 nor n if n > 4.

Figure 15 States aBA . . . AC and aBB . . . BC
are not connected in the subgraph where disks 2
and n are ﬁxed on B and C, and disk 1 is ﬁxed on
A: As no disk can be inserted under n, if n > 4
it is impossible to move the n − 3 > 1 unﬁxed
disks from A to B (as to move more than one disk
between two pegs of same parity require a third
peg).

This deﬁnes 9 parts, as each of the two ﬁxed disks can be on one of the three peg. Of

those 9 parts, we need focusing only on 5:

two parts of the graph cannot be accessed from the initial state aA . . . A, (see an illustration 
in Figure 14); and
the part of the graph where disk 2 is ﬁxed on B and disk n is ﬁxed on C contains two
parts, which are not connected for n > 4 (see an illustration in Figure 15).

The ﬁve remaining parts are very similar. Three of them are of particular importance
as each contains one key state, which are aA . . . A, aB . . . B and aC . . . C. Consider ﬁrst
the graphs G0(n) for n ∈ {1, 2, 3} (n + 1 disks in total if we count the ﬁxed one): they are
represented in Figure 16. When one disk is ﬁxed on A, the task of moving disks from A to
B is symmetric with moving them from A to C, but quite distinct from the task of moving
disks from B to C.

Now, consider the part of the graph G0(n − 1) where the smallest and the largest disks
(2 and n) are ﬁxed on A. This part contains the initial state A . . . A. The only way to free
the smallest disk is to move the n − 3 other disks to another peg.

Once disks 2 and n are ﬁxed on the same peg (in addition to disk 1), the situation is
similar to the entire graph, with two fewer disks. It is the case each time two extreme disks
are ﬁxed on the same peg: when 2 and n are ﬁxed on peg C or B, or when 1 and n are ﬁxed
on peg A; the process can then ignore the two ﬁxed disks to move the n−3 remaining disks,
as the parity of the peg is unchanged. See the deﬁnitions of the graph G0(n) in Figure 16
for n ∈ {1, 2, 3} and in Figure 17 for n > 3.

4.2 Proof of optimality
To prove the optimality of the solution described in Section 3, we prove that the algorithm
is taking the shortest path in the conﬁguration graph deﬁned in the last section. A side
result is that this is the unique shortest solution.
(cid:73) Theorem 12. ∀(x, y, z) ∈ {0, 1}3, ∀n ≥ 0, movexyz(n, A, B, C) moves optimally n disks
from A to C.

14

Bouncing Towers

Figure 16 Subgraphs G0(n) with one disk ﬁxed on the peg A for n ∈ {1, 2, 3}.

Proof. Deﬁne the induction hypothesis IH(n) as “∀(x, y, z) ∈ {0, 1}3 movexyz(n, A, B, C)
moves optimally n disks from A to C”. Trivially IH(0) and IH(1) are true. Suppose that
there exists an integer N > 1 such that ∀n < N, the induction hypothesis IH(n) is true. We
prove that IH(N) is then also true.

move000(N, A, B, C) is optimal:
move000(N, A, B, C) for N > 0 consists of one call to move100(N, A, C, B), one unitary
step, and one call to move001(N, B, A, C).
So it moves optimally (by IH(N − 1)) from aA . . . A to aB . . . B, and then to cB . . . B,
and after that to cC . . . C. (In Figure 13 the right edge of the triangle.)
A path not going through states aB . . . B or cB . . . B would take more steps:

if we don’t go through the state aB . . . B, then the state aC . . . C is necessary, with a
cost of f100(N −1), and also the state bC . . . C (with a cost of 1), and at the end of the
path we have to go through the state cA . . . A, which optimal path to go to the ﬁnal
cC . . . C state is of length f100(N−1): this path is of length f100(N−1)+1+f100(N−1)
and is already as long as the one given by move000(N, A, B, C).
if we go through aB . . . B, but not through cB . . . B, then the path is not optimal as
it must go through aC . . . C and the optimal path from aA . . . A to aC . . . C doesn’t
go through aB . . . B.

So move000(N, A, B, C) is optimal.
move100(N, A, B, C) is optimal:
move100(N, A, B, C) for N > 1 consists of one call to move100(N − 2, A, C, B)), two
steps, and one call to move010(N − 2, B, A, C)).
As before, we shall consider these recursive calls of order smaller than N as optimal because 
of IH(N −2). So we know how to move optimally from aAA . . . AA to aAB . . . BA,

G’(2)(3 disks)aBBaCBaACaABaBAaCAaAAaBCaBaCaAG’(1)aCC(2 disks)aBBBaBABaBCBaBCAaACAaABAaBACaCBAaCCCaCABaCACaCBCaAAAaAACaAABG’(3)(4 disks)aCBBaBCCaBAAaBBAaCCAaCAAaCCBaBBCJ. Barbay

15

Figure 17 Recursive deﬁnition of G0(n), the graph of all legal steps when one disk is ﬁxed on
the ﬁrst peg, for n > 3. There is no way to connect the states aBB....BC, aBA...AC, aCC...CB
and aCA...AB without moving some of the disks from {1, 2, n}.

to aCB . . . BA, then to aCB . . . BC and to aCC . . . CC (in ﬁgure 17), this corresponds
to the left edge of the triangle).
We must now prove that other paths take more steps:

We cannot avoid the state aCB . . . BC, neither aCB . . . BA, as there is no other way
out of aCC . . . CC.
if we avoid the state aAB . . . BA then the optimal path to aCB . . . BA necessarily
passes by aBA . . . AA and aCA . . . AA, and is of length f100(N − 2) + 1 + f010(N −
2) + 1 + f010(N − 2), which is longer than the whole solution given by the algorithm,
of length f100(N) = f100(N − 2) + 2 + f010(N − 2).

So move100(N, A, B, C) is optimal.
move010(N, A, B, C) is optimal:
move010(1, A, B, C) and move010(2, A, B, C) are special cases, we can see in graphs G0(1)
and G0(2) on ﬁgure 16 page 14 that the optimal paths between aB . . . B and aC . . . C are
of length 1 and 3, as the solutions produced by the algorithm. So move010(1, A, B, C)
and move010(2, A, B, C) are proven optimal.
move010(N, A, B, C) for N > 2 corresponds to a path going through the states (the ﬁrst
disk being ﬁxed on b): (please report to ﬁg. 17 from aCC . . . CC to aBB . . . BB down
left to down right. )

f010(N−2)

−→ aCB . . . BC

2−→ aAB . . . BC

aCC . . . CC
f010(N−2)

−→ aAC . . . CC

2−→ aBC . . . CB

f010(N−2)

−→ aBB . . . BB

We shall demonstrate that all other paths take more steps:

The states bAC . . . CA and bCA . . . AC are mandatory, for connexity, and so are
bAC . . . CB and bCA . . . AB.
if we go through bBC . . . CB, then it’s bBA . . . AB which is mandatory.

aBC...CAaCB...BAaCC...CAaBB...BAaCB...BCaCA...ACaAB...BAaBC...CBaAC...CAaBB...BCaBA...ACaCC...CBaCA...ABaCA...AAaBA...AAaAA...AAaCC...CCaBA...ABaBB...BBG’(n−1)=G’(n−3)1 on A2 and n on CG’(n−3)G’(n−3)G’(n−3)G’(n−3)2 and n on C1 on A2 on C1 and n on A2 on B1 and n on A1,2 and n on A16

Bouncing Towers

if we contourn bBC . . . CB, then we shall go through bAB . . . BB, bCB . . . BB and
bCA . . . AB: the total path would be of length 3 + 4f010(N − 2), to be compared with
4 + 3f010(N − 2) (We trade one step with one recursive call). As f010(N − 2) ≥ 1 for
N − 2 ≥ q (i.e. N ≥ 3 > 2), move010(N, A, B, C) is optimal for N > 2.
(cid:74)

So move010(N, A, B, C) is optimal.

We discuss further extensions of those results in the next section.

5 Discussion

All the usual research questions and extensions about the Hanoï Tower Problem are still
valid about the Bouncing Tower Problem. We discuss only a selection of them, such as the
space complexity in Section 5.1, and the extension to other proportional insertion and
removal points in Section 5.2.

5.1 Space Complexity
Allouche and Dress [1] showed that the optimal sequence of steps required to move a Hanoï
Tower of n disks can be obtained by a simple function from the preﬁx of an inﬁnite unique
sequence, which itself can be produced by a ﬁnite automaton. This proves that the space
complexity of the Hanoï Tower Problem is constant.

The same technique does not seem to yield constant space for Bouncing Towers: whereas

the sequences of steps generated by each of the functions move100(n, A, B, C), move010(n, A, B, C)
and move001(n, A, B, C) are preﬁxes of inﬁnite sequences, extracting those suﬃxes and combining 
them in a sequence corresponding to move000(n, A, B, C) would require a counter us-
√
3n) ∈ Θ(n),
ing logarithmic space in the length of the sequences to be extracted, i.e. log2(
which would still be linear in the number of disks.

5.2 Levitating Towers
An extension of the Bouncing Tower Problem is to parametrize the insertion point, so
that the removal point is at position bαnc + 1 and the insertion point is under the disk
at position bα(n + 1)c in a tower of n disks, for α ∈ [0, 1
2] ﬁxed (the problem is symmetrical
for α ∈ [ 1
2 , 1]). By analogy with Bouncing Towers, we call this variant a αLevitating

Tower. This parametrization creates a continuous range of variants, of which the Hanoï
Tower Problem and the Bouncing Tower Problem are the two extremes:

for α = 0, the removal/insertion point is always at the top, which corresponds to a
Hanoï Tower, while
for α = 1

2 the problem corresponds to a Bouncing Tower.

The complexity of moving a αLevitating 
Tower cannot be smaller than the one of a
Bouncing Tower, as the key conﬁguration permitting to move 2 disks in 2 steps between the
same pegs is less often obtainable in a αLevitating 
Tower.

1

2

References
J.-P. Allouche and F. Dress. Tours de Hanoï et automates. RAIRO, Informatique Théorique
et applications, 24(1):1–15, 1990.
M.D. Atkinson. The cyclic towers of Hanoï. Information Processing Letters (IPL), 13(118-
119), 1981.

J. Barbay

17

3 W. R. Ball. Mathematical Recreations and Essays. McMillan, London, 1892.
4

J. S. Frame and B. M. Stewart. Solution of problem no 3918. American Mathematics
Monthly (AMM), 48:216–219, 1941.
Édouard Lucas. La tour d’Hanoï, véritable casse-tête annamite. In a puzzle game., Amiens,
1883. Jeu rapporté du Tonkin par le professeur N.Claus (De Siam).
Édouard Lucas. Récréations Mathématiques, volume II. Gauthers-Villars, Paris, quai des
Augustins, 55, 1883.
D. Wood. The towers of Brahma and Hanoï revisited. Journal of Recreational Mathematics
(JRM), 14(1):17–24, 1981.

5

6

7

Acknowledgements: We would like to thank Claire Mathieu, Jean-Paul Allouche and
Srinivasa Rao for corrections and encouragements, and Javiel Rojas-Ledesma and Carlos
Ochoa-Méndez for their comments on preliminary drafts. Funding: Jérémy Barbay is
partially funded by the Millennium Nucleus RC130003 “Information and Coordination in
Networks”.

Appendix
A Disk Pile Problem

The Hanoï Tower Problem is a classic example on recursivity, originally proposed by Édouard 
Lucas [5] in 1883. A recursive algorithm is known since 1892, moving the n disks
of a Hanoï Tower in 2n − 1 unit moves, this value being proven optimal by a simple lower
bound [3].

Consider the Disk Pile problem, a very simple variant where we allow some disks to
be of the same size. This obviously introduces some much easier instances, including an
extreme one where the disks are all the same size and the resulting tower can be moved in
linear time (see Figure 18 for the sequence of steps moving such a tower of size 3 with a
single size of disks).

c
b
a
A

B

C

b
a
A

c
C

B

a
A

B

b
c
C

a
b
c
C

A

B

Figure 18 Moving a Disk Pile of size 3.

1. Give a recursive algorithm to move a Disk Pile from one peg to the other, using only
one extra peg, knowing that ∀i ∈ {1, . . . , s}, ni is the number of disks of size i. Your
algorithm must be eﬃcient for the cases where all the disks are the same size, and where
all the disks are of distinct sizes.
Solution: We present an algorithm in Figure 19.
It is very similar to the algorithm
moving a Hanoï Tower, the only diﬀerence being that it moves the ni disks of size i at
(cid:74)
the same time, in ni consecutive moves.
2. Give and prove the worst case performance of your algorithm over all instances of ﬁxed

s and vector (n1, . . . , ns).
Solution: By solving the recursive formula directly given by the recursion of the algorithm,
 one gets that the ns largest disks are moved once, the ns−1 second largest disks

18

Bouncing Towers

Figure 19 Python code to move a Disk Pile

def diskPileMove (n,sizes ,a,b,c):

if n >0 :

move (nsizes 
[-1], sizes [0: -1] ,a,c,b)
for i in range (0, sizes [ -1]):

move (a,c)

move (nsizes 
[-1], sizes [0: -1] ,b,a,c)

are moved twice, the ns−2 third largest disks are moved four times, and so on to the
n1 smallest disks, which are each moved 2s−1 times. Summing all those moves give the

i=1 2i = 2n − 1, the solution to
(cid:74)

i∈{1,...,s}

ni2s−i

the traditional Hanoï Tower Problem.

number of moves performed by the algorithm:X
Note that for s = n and n1 = ··· = ns = 1, this yieldsPs−1
3. Prove that a performance ofP
Solution: We prove a lower bound of P
requiresP
(n1, . . . , nσ) requiresP

i∈{1,...,s} ni2s−i is optimal.

i∈{1,...,s} ni2s−i, for n disks of s distinct sizes,
with ni disks of size i by induction on the number of types of disks. We prove by
induction on the number of types of disk s that any pile of disks of sizes (n1, . . . , ns)

i∈{1,...,s} ni2s−i disk moves to be moved to another peg.

Initial Case: for s = 1 the bound is n1 and is obviously true, since each disk must be
individually moved from one peg to the other.
Inductive Hypothesis: suppose there is some σ ≥ 1 so that any pile of disks sizes

i∈{1,...,σ} ni2σ−i disk moves to be moved to another peg.

Inductive Step: consider a pile of disks of sizes (n1, . . . , nσ+1): clearly all the disks of
sizes smaller than σ + 1 need to be gathered on a unique peg before the largest disks
can be moved, to allow those last ones to be moved in nσ+1 disk moves, after which
all the disks of sizes smaller than σ + 1 need to be stacked above the largest ones. By
i∈{1,...,σ} ni2σ−i
disk moves, to be added to the nσ+1 disk moves. Hence, any pile of disk of sizes
i∈{1,...,σ+1} ni2σ+1−i disk moves to be moved to another

the inductive hypothesis, moving the smaller disks will require 2P
(n1, . . . , nσ+1) requires P
pile of disks of sizes (n1, . . . , ns) for s ≥ 1 requiresP

peg.
Conclusion: The inductive hypothesis is veriﬁed for the initial case where s = 1, and
propagates to any value of s ≥ 1 through the inductive step. We conclude that any
i∈{1,...,s} ni2s−i disk moves to be
(cid:74)
4. What is the worst case complexity of the Disk Pile problem over all instances of ﬁxed

moved to another peg.

Using the previous results it yields a complexity of 2s−1(n− s+1)+Ps−1

value s and ﬁxed total number of disks n?
Solution: The worst case (of both the algorithms and the most precise lower bound with
the number of disks of each size ﬁxed) occurs when n1 = n− s+1 and n2 = . . . = ns = 1.
i=1 2i = 2s−1(n−
s+2)−1 steps in the worst case over all instances of ﬁxed value s and ﬁxed total number
of disks n. This correctly yields 2n − 1 when s = n, in the worst case over all instances
(cid:74)
of ﬁxed total number of disks n.

