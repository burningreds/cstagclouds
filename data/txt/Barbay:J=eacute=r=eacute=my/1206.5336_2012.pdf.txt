3
1
0
2

 
l
u
J
 

3
1

 
 
]
S
D
.
s
c
[
 
 

3
v
6
3
3
5

.

6
0
2
1
:
v
i
X
r
a

Near-Optimal Online Multiselection

in Internal and External Memory

Departamento de Ciencias de la Computaci´on (DCC)

J´er´emy Barbay∗

Universidad de Chile

jbarbay@dcc.uchile.cl

Ankur Gupta†

Department of Computer Science and Software Engineering

Butler University

agupta@butler.edu

S. Srinivasa Rao‡

School of Computer Science and Engineering

Seoul National University

ssrao@cse.snu.ac.kr

Jon Sorenson†

Department of Computer Science and Software Engineering

Butler University

jsorenso@butler.edu

Abstract

We introduce an online version of the multiselection problem, in which q selection queries are
requested on an unsorted array of n elements. We provide the ﬁrst online algorithm that is 1competitive 
with Kaligosi et al.[ICALP 2005] in terms of comparison complexity. Our algorithm
also supports online search queries eﬃciently.

We then extend our algorithm to the dynamic setting, while retaining online functionality,
by supporting arbitrary insertions and deletions on the array. Assuming that the insertion of
an element is immediately preceded by a search for that element, we show that our dynamic
online algorithm performs an optimal number of comparisons, up to lower order terms and an
additive O(n) term.

For the external memory model, we describe the ﬁrst online multiselection algorithm that is
O(1)-competitive. This result improves upon the work of Sibeyn [Journal of Algorithms 2006]
when q > m, where m is the number of blocks that can be stored in main memory. We also
extend it to support searches, insertions, and deletions of elements eﬃciently.

∗Supported by Project Regular Fondecyt number 1120054.
†Supported in part by the Butler Holcomb Awards grant.
‡Supported by Basic Science Research Program through the National Research Foundation of Korea (NRF) funded

by the Ministry of Education, Science and Technology (Grant number 2012-0008241).

1

1

Introduction

The multiselection problem asks for the elements of rank Q = q1, q2, . . . , qq on an unsorted array A
drawn from an ordered universe of elements. We deﬁne B(Sq) as the information-theoretic lower
bound on the number of comparisons needed to answer q queries, where Sq = si denotes the queries
ordered by rank. We deﬁne ∆i = si+1 − si, where s0 = 0 and sq+1 = n. Then,

q

q

log (∆i!) =

Xi=0

∆i log

n
∆i − O(n).1

Xi=0

B(Sq) = log n! −

Several papers have analyzed this problem carefully. Dobkin and Munro [DM81] gave a deterministic 
bound using 3B(Sq) + O(n) comparisons. Prodinger [Pro95] proved the expected comparisons 
with random pivoting is 2B(Sq) ln 2 + O(n). Most recently, Kaligosi et al. [KMMS05]
showed a randomized algorithm taking B(Sq) + O(n) expected comparisons, along with a deterministic 
algorithm taking B(Sq) + o(B(Sq) + O(n) comparisons. Jim´enez and Mart´ınez [JM10] later
improved the number of comparisons in the expected case to B(Sq) + n + o(n). Most recently, Cardinal 
et al. [CFJ+09] generalized the problem to a partial order production, of which multiselection
is a special case. Cardinal et al. use the multiselection algorithm as a subroutine after an initial
preprocessing phase.

Kaligosi et al. [KMMS05] provide an elegant result in the deterministic case based on tying the
number of comparisons required for merging two sorted sequences to the information content of
those sequences. This simple observation drives an approach where manipulating these runs to both
ﬁnd pivots that are “good enough” and partition with near-optimal comparisons. The weakness of
the approaches in internal memory is that they must know all of the queries a priori.

In external memory, Sibeyn [Sib06] solves multiselection using n + nq/m1−ǫ I/Os, where ǫ is
any positive constant. The ﬁrst term comes form creating a static index structure using n I/Os,
and the reminder comes from the q searches in that index. In addition, his results also require the
condition that log N = O(B). When q = m, Sibeyn’s multiselection algorithm requires O(nmǫ)
I/Os, whereas the optimum is Θ(n) I/Os. In fact his bounds are ω(Bm(Sq)), for any q ≥ m, where
Bm(Sq)) is the lower bound on the number of I/Os required (see Section D.1 for the deﬁnition).

1.1 Our Results

For the multiselection problem in internal memory, we describe the ﬁrst online algorithm that
insert, and delete operations, of which q′ are search,
supports a set Q of q selection, search,
insert, and delete, using B(Sq) + o(B(Sq) + O(n + q′ log n) comparisons.2 Thus our algorithm
is 1-competitive with the oﬄine algorithm of Kaligosi et al. [KMMS05] in terms of comparison
complexity. We also show a randomized result achieving 1-competitive behavior with respect to
Kaligosi et al. [KMMS05], while only using O((log(n))O(1)) sampled elements instead of O(n3/4).
For the external memory model, we describe an online multiselection algorithm that supports a
set Q of q selection queries on an unsorted array stored on disk in n blocks, using O(Bm(Sq))+O(n)
I/Os, where Bm(Sq) is a lower bound on the number of I/Os required to support the given queries.
This result improves upon the work of Sibeyn [Journal of Algorithms 2006] when q > m, where m

1We use the notation logb

the base e logarithm of b.

a to refer to the base b logarithm of a. By default, we let b = 2. We also deﬁne ln b as

2For the dynamic result, we assume that the insertion of an element is immediately preceded by a search for that
element. In that case, we show that our dynamic online algorithm performs an optimal number of comparisons, up
to lower order terms and an additive O(n) term.

2

is the number of blocks that can be stored in main memory. We also extend it to support insertions
and deletions of elements using O(Bm(Sq)) + O(n + q logB N ) I/Os.

1.2 Preliminaries

Given an unsorted array A of length n, the median is the element x of A such that exactly ⌈n/2⌉
elements in A are greater than or equal to x. It is well-known that the median can be computed
in O(n) time, and many [Hoa61, BFP+73, SPP76] have analyzed the exact constants involved. The
best known result is due to Dor and Zwick [DZ99] to obtain 2.942 + o(n) time.

In the external memory model, the computer is abstracted to consist of two memory levels:
the internal memory of size M , and the (unbounded) disk memory, which operates by reading
and writing data in blocks of size B. We refer to the number of items of the input by N . For
convenience, we deﬁne n = N/B and m = M/B as the number of blocks of input and memory,
respectively. We make the reasonable assumption that 1 ≤ B ≤ M/2. In this model, we assume
that each I/O read or write is charged one unit of time, and that an internal memory operation
is charged no units of time. To achieve the optimal sorting bound of SortIO(N ) = Θ(n logm n)
in this setting, it is necessary to make the tall cache assumption [BF03]: M = Ω(B1+ǫ), for some
constant ǫ > 0, and we will make this assumption for the remainder of the paper.

2 A Simple Online Algorithm

Let A be an input array of n unsorted items. We describe a simple version of our algorithm for
handling selection and search queries on array A. We say that an element in array A at position i
is a pivot if A[1 . . . i − 1] < A[i] ≤ A[i + 1 . . . n].
where B[i] = 1 if and only if it is a pivot.

Bit Vector. Throughout all the algorithms in the paper, we maintain a bitvector B of length n

Preprocessing. Create a bitvector B and set each bit to 0. Find the minimum and maximum

elements in array A, swap them into A[1] and A[n] respectively, and set B[1] = B[n] := 1.

Selection. We deﬁne the operation A.select(s) to refer to the selection query s, which returns
A[s] if A were sorted. To compute this result, if B[s] = 1 then return A[s] and we are done.
If
B[s] = 0, ﬁnd a < s, b > s, such that B[a] = B[b] = 1 but B[a + 1 . . . b − 1] are all 0. Perform
quickselect [Hoa61] on A[a + 1 . . . b − 1], marking pivots found along the way in B. This gives us
A[s], with B[s] = 1, as desired.
Search. We deﬁne the operation A.search(p) returns the position j, which satisﬁes p = A[j] if A
were sorted; if p 6∈ A, then j is the number of items in A smaller than p.3 Perform a binary search
on A as if A were sorted. Let i be the location in A we ﬁnd from the search; if along the way we
discovered endpoints for the subarray we are searching that were out of order, stop the search and
let i be the midpoint. If A[i] = p and B[i] = 1 return i and we are done. Otherwise, we have just
identiﬁed the unsorted interval in A that contains p if it is present. Perform a selection query on
this interval; choose which side of a pivot on which to recurse based on the value of p (instead of
an array position as would be done in a normal selection query). As above, we mark pivots in B as
we go; at the end of the recursion we will discover the needed value j.

As queries arrive, our algorithm performs the same steps that quicksort would perform, although
not necessarily in the same order.
If we receive enough queries, we will, over time, perform a
quicksort on array A. This also means that our recursive subproblems mimic those from quicksort.

3The search operation is essentially the same as rank on the set of elements stored in the array A. We call it

search to avoid confusion with the rank operation deﬁned on bitvectors in Section 5.

3

We have assumed, up to this point, that the last item in an interval is used as the pivot, and
a simple linear-time partition algorithm is used. We explore using diﬀerent pivot and partitioning
strategies to obtain various complexity results for online selection and searching. As an easy
consequence of more a more precise analysis to follow, we show that the time to perform q select
and search queries on an array of n items is O(n log q + q log n). Now, we deﬁne terminology for
this alternate analysis.

2.1 Terminology

For now we assume all queries are selection queries, since search queries are selection queries with
a binary search preprocessing phase taking O(log n) comparisons. We explicitly bound the binary
search cost in our remaining results.

Query and Pivot Sets. Let Q denote a sequence of q selection queries, ordered by time of
arrival. Let St = {si} denote the ﬁrst t queries from Q, sorted by position. We also include s0 = 1
and st+1 = n in St for convenience of notation, since the minimum and maximum are found during
preprocessing. Let Pt = {pi} denote the set of k pivots found by the algorithm when processing
St, again sorted by position. Note that p1 = 1, pk = n, B[pi] = 1 for all i, and St ⊆ Pt.

Pivot Tree, Recursion Depth, and Intervals. The pivots chosen by the algorithm form a
binary tree structure, deﬁned as the pivot tree T of the algorithm over time.4 Pivot pi is the parent
of pivot pj if, after pi was used to partition an interval, pj was the pivot used to partition either
the right or left half of that interval. The root pivot is the pivot used to partition A[2..n− 1] due to
preprocessing. The recursion depth, d(pi), of a pivot pi is the length of the path in the pivot tree
from pi to the root pivot. All leaves in the pivot tree are also selection queries, but it may be the
case that a query is not a leaf. Each pivot was used to partition an interval in A. Let I(pi) denote
the interval partitioned by pi (which may be empty), and let |I(pi)| denote its length. Intervals
form a binary tree induced by their pivots.
If pi is an ancestor of pj then I(pj) ⊂ I(pi). The
recursion depth of an array element is the recursion depth of the smallest interval containing that
element, which in turn is the recursion depth of its pivot.

:= si+1 − si and similarly the pivot gap ∆Pt

Gaps and Entropy. Deﬁne the query gap ∆St
:=
i
pi+1 − pi. Observe that each pivot gap is contained in a smallest interval I(p). One endpoint of
this gap is the pivot p of interval I(p), and the other matches one of the endpoints of interval I(p).
By telescoping we have Pi ∆St

We will analyze the complexity of our algorithms based on the number of element comparisons.
The lower bound on the number of comparisons required to answer the selection queries in St is
obtained by taking the number of comparisons to sort the entire array, and then subtracting the
comparisons needed to sort the query gaps. We use B(St) to denote this lower bound.

i =Pj ∆Pt

j = n − 1.

i

B(St)

:=

t

Xi=0(cid:16)∆St

i (cid:17) log(cid:16)n/(cid:16)∆St

i (cid:17)(cid:17) − O(n).

Note that B(Sq) ≤ n log q: this upper bound is met when the queries are evenly spaced over the
input array A. We can show that the simple algorithm performs O(B(Sq) + q log n) for a sequence Q
4Intuitively, a pivot tree corresponds to a recursion tree, since each node represents one recursive call made during

the quickselect algorithm [Hoa61].

4

of q select and search queries on an array of n elements. We will also make use of the following fact
in the paper.

Fact 1. For all ǫ > 0, there exists a constant cǫ such that for all x ≥ 4, log log log x < ǫ log x + cǫ.
Proof. Since limx→∞(log log log x)/(log x) = 0, there exists a kǫ such that for all x ≥ kǫ, we
know that (log log log x)/(log x) < ǫ. Also, we know that in the interval [4, kǫ], the continuous
function log log log x − ǫ log x is bounded. Let cǫ = log log log kǫ − 2ǫ, which is a constant.

3 A Lemma on Sorting Entropy

Pivot Selection Methods. We say that a pivot selection method is good for the constant c with
1/2 ≤ c < 1 if, for all pairs of pivots pi and pj where pi is an ancestor of pj in the pivot tree, then

|I(pj)| ≤ |I(pi)| · cd(pj )−d(pi)+O(1).

Note that if the median is always chosen as the pivot, we have c = 1/2 and the O(1) term is in fact
zero. The pivot selection method of Kaligosi et al. [KMMS05, Lemma 8] is good with c = 15/16.

Lemma 1. If the pivot selection method is good as deﬁned above, then B(Pt) = B(St) + O(n).
Proof. We sketch the proof and defer the full details to Appendix B. Consider any two consecutive
selection queries s and s′, and let ∆ = s′ − s be the gap between them. Let P∆ = (pl, pl+1, . . . , pr)
be the pivots in this gap, where pl = s and pr = s′. The lemma follows from the claim that
B(P∆) = O(∆), since

B(Pt) − B(St) = 

k

∆Pt
j

Xj=0
i −

log ∆St

t

∆St
i

n log n −
Xi=0
Xi=0

B(P∆St

t

) =

i

=

=

log ∆Pt

j 
 − n log n −

log ∆Pt
j

k

t

∆Pt
j

Xj=0
O(cid:16)∆St
Xi=0

i (cid:17) = O(n).

∆St
i

log ∆St

i !

t

Xi=0

We now sketch the proof of our claim, which proves the lemma.

There must be a unique pivot pm in P∆ of minimal recursion depth. We split the gap ∆ at pm.

We deﬁne For brevity, we deﬁne Dl =Pm−1

i=0 ∆i and Dr =Pr−1

We consider the proof on the right-hand side Dr, and proof for Dl is similar. Since we use a good
pivot selection method, we can bound the total information content of the right-hand side by O(Dr).
This leads to the claim, and the proof follows. Details of this proof are in Appendix B.

i=m ∆i, giving ∆ = Dl + Dr.

Theorem 1 (Online Multiselection). Given an array of n elements, on which we have performed
a sequence Q of q online selection and search queries, of which q′ are search, we provide

• a randomized online algorithm that performs the queries using B(Sq)+ O(n + q′ log n) expected

number of comparisons, and

• a deterministic online algorithm that performs the queries using at most 4B(Sq) + O(n +

q′ log n) comparisons.

5

Proof. For the randomized algorithm, we use the randomized pivot selection algorithm of Kaligosi et
al. [KMMS05, Section 3, Lemma 2].) This algorithm gives a good pivot selection method with
c = 1/2 + o(1), and the time to choose the pivot is O(∆3/4) on an interval of length ∆, which is
subsumed in the O(n) term in the running time. Each element in an interval participates in one
comparison per partition operation. Thus, the total number of comparisons is expected to be the
sum of the recursion depths of all elements in the array. This total is easily shown to be B(Pq), and
by Lemma 1, the proof is complete. In Appendix A, we describe how to get a good pivot selection
method with just 6(log n)3(log ∆)2 samples, instead of O(∆3/4).

For the deterministic algorithm, we use the median of each interval as the pivot; the medianﬁnding 
algorithm of Dor and Zwick [DZ99] gives this to us in under 3∆ comparisons. We add
another comparison for the partitioning, to give a count of comparisons per array element of four
times the recursion depth. This is at most 4B(Pq), which is no more than 4B(Sq) + O(n) from
Lemma 1, and the result follows.

4 Optimal Online Multiselection

In this section we prove the following theorem.

Theorem 2 (Optimal Online Multiselection). Given an unsorted array A of n elements, we provide
a deterministic algorithm that supports a sequence Q of q online selection and search queries, of
which q′ are search, using B(Sq)(1 + o(1)) + O(n + q′ log n) comparisons in the worst case.

Note that our bounds match those of the oﬄine algorithm of Kaligosi et al. [KMMS05] when
q′ = 0 (i.e., there are no search queries).
In other words, we provide the ﬁrst 1-competitive
online multiselection algorithm. We explain our proof with three main steps. We ﬁrst explain our
algorithm and how it is diﬀerent from the algorithm in [KMMS05]. We then bound the number of
comparisons from merging by B(Sq)(1+o(1))+O(n), and then we bound the number of comparisons
from pivot ﬁnding and partitioning by o(B(Sq)) + O(n).

4.1 Algorithm Description and Modiﬁcations

We brieﬂy describe the deterministic algorithm from Kaligosi et al. [KMMS05]. They begin by
creating runs, which are sorted sequences from A of length roughly ℓ = log(B/n). Then, they
compute the median m of the median of these sequences and partition the runs based on m. After
partitioning, they recurse on the two sets of runs, sending select queries to the appropriate side
of the recursion. To maintain the invariant on run length on the recursions, they merge short
like-sized runs optimally until all but ℓ of the runs are again of length between ℓ and 2ℓ.

We make the following modiﬁcations to the deterministic algorithm of Kaligosi et al. [KMMS05]:

• The queries are processed online, that is, one at a time, from Q without knowing which

queries will follow. To do this, we maintain the bitvector B as described above.

• We admit search queries in addition to selection queries; in the analysis we treat them as

selection queries, paying O(q′ log n) comparisons to account for binary search.

• Since we don’t know all of Q at the start, we cannot know the value of B(Sq) in advance.
Therefore, we cannot preset a value for ℓ as in Kaligosi et al. [KMMS05]. Instead, we set ℓ
locally in an interval I(p) to 1 + ⌊lg(d(p) + 1)⌋. Thus, ℓ starts at 1 at the root of the pivot
tree T , and since we use only good pivots, d(p) = O(lg n). (Also, ℓ = log log n + O(1) in the
worst case.) We keep track of the recursion depth of pivots, from which it is easy to compute

6

the recursion depth of an interval. Also observe that ℓ can increase by at most one when
moving down one recursion level during a selection.

• We use a second bitvector R to identify the endpoints of runs within each interval that has

not yet been partitioned.

The algorithm to perform a selection query is as follows:

• As described earlier in this paper, we use bitvector B to identify the interval from which to

begin processing. The minimum and maximum are found in preprocessing.

• If the current interval has length less than 4ℓ2, we sort the interval to complete the query

(setting all elements as pivots). The cost for this case is bounded by Lemma 5.

• As is done in [KMMS05], we compute the value of ℓ for the current interval, merge runs so
that there is at most one of each length < ℓ, and then use medians of those runs to compute
a median-of-medians to use as a pivot. We then partition each run using binary search.

We can borrow much of the analysis done in [KMMS05]. We cannot use their work wholesale,
because we don’t know B in advance. For this reason, we cannot deﬁne ℓ as they have, and their
algorithm depends heavily on its use. To ﬁnish the proof of our theorem, we show how to modify
their techniques to handle this complication.

4.2 Merging

Kaligosi et al. [KMMS05, Lemmas 5—10] count the comparisons resulting from merging. Lemmas
5, 6, and 7 do not depend on the value of ℓ and so we can use them in our analysis. Lemma 8
shows that the median-of-medians built on runs is a good pivot selection method. Although the
proof clearly uses the value of ℓ, its validity does not depend on how large ℓ is; only that there are
at least 4ℓ2 items in the interval, which also holds for our algorithm. Lemmas 9 and 10 together
will bound the number of comparisons by B(Sq)(1 + o(1)) + O(n) if we can prove Lemma 2, which
bounds the information content of runs in intervals that are not yet partitioned.

Lemma 2. Let a run r be a sorted sequence of elements from A in a gap ∆Pt
length. Then,

i , where |r| is its

k

Xi=0 Xr∈∆Pt

i

|r| lg |r| = o(B(St)) + O(n).

Proof. In a gap of size ∆, ℓ = O(log d) where d the recursion depth of the elements in the gap.

we use a good pivot selection method, we know that the recursion depth of every element in

This givesPr∈∆ |r| log |r| ≤ ∆ log(2l) = O(∆ log log d), since each run has size at most 2ℓ. Because
the gap is O(log(n/∆)). Thus, Pk
|r| log |r| ≤ Pi ∆i log log log(n/∆i). Recall that
B(St) = B(Pt) + O(n) =Pi ∆i log(n/∆i) + O(n). Using Fact 1, the proof is complete.

i=0Pr∈∆Pt

i

4.3 Pivot Finding and Partitioning

Now we prove that the cost of computing medians and performing partition requires at most
o(B(Sq)) + O(n) comparisons. The algorithm computes the median m of medians of each run at
a node v in the pivot tree T . Then, it partitions each run based on m. We bound the number
of comparisons at each node v with more than 4ℓ2 elements in Lemmas 3 and 4. We bound the
comparison cost for all nodes with fewer elements in Lemma 5.

7

Terminology. Let d be the current depth of the pivot tree T (deﬁned in Section 2.1), and let
the root of T have depth d = 0.
In tree T , each node v is associated with some interval I(pv)
corresponding to some pivot pv. We deﬁne ∆v = |I(pv)| as the number of elements at node v in T .
Recall that ℓ = 1 + ⌊log(d + 1)⌋. Let a run be a sorted sequence of elements from A. We
deﬁne a short run as a run of length less than ℓ. Let βn be the number of comparisons required to
compute the exact median for n elements, where β is a constant less than three [DZ99]. Let rs
v be
the number of short runs at node v, and let rl

v be the number of long runs.

Lemma 3. The number of comparisons required to ﬁnd the median m of medians and partition all
runs at m for any node v in the pivot tree T is at most β(ℓ− 1) + ℓ log ℓ + β(∆v/ℓ) + (∆v/ℓ) log(2ℓ)
comparisons.

Proof. We compute the cost (in comparisons) for computing the median of medians. For the
rs
v ≤ ℓ − 1 short runs, we need at most β(ℓ − 1) comparisons per node. For the rl
v ≤ ∆v/ℓ long
runs, we need at most β(∆v/ℓ).
Now we compute the cost for partitioning each run based on m. We perform binary search on
i=1 log i ≤ ℓ log ℓ comparisons per node. For long

each run. For short runs, this requires at most Pℓ−1

runs, we need at most (∆v/ℓ) log(2ℓ) comparisons per node.

Since our value of ℓ changes at each level of the recursion tree, we will sum the above costs by

level. The overall cost in comparisons at level d is at most

2dβℓ + 2dℓ log ℓ + (n/ℓ)β + (n/ℓ) log(2ℓ).

We can now prove the following lemma.

Lemma 4. The number of comparisons required to ﬁnd the median of medians and partition over
all nodes v in the pivot tree T with at least 4ℓ2 elements is at most o(B(St)) + O(n).
Proof. For all levels of the pivot tree up to level ℓ′ ≤ log(B(Pt)/n), the cost is at most

log(B(Pt)/n)

Xd=1

2dℓ(β + log ℓ) + (n/ℓ)(β + log(2ℓ)).

Since ℓ = ⌊log(d+1)⌋+1, the ﬁrst term of the summation is bounded by (B(Pt)/n) log log(B(Pt)/n) =
o(B(Pt)). The second term is easily upper-bounded by

n log(B(Pt)/n)(log log log(B(Pt)/n)/ log log(B(Pt)/n)) = o(B(Pt)).

Using Lemma 1, the above two bounds are o(B(St)) + O(n).
For each level ℓ′ with log(B(Pt)/n) < ℓ′ ≤ log log n + O(1), we need to bound the remaining
cost. It is easy to bound each node v’s cost by o(∆v), but this is not suﬃcient—though we have
shown that the total number of comparisons for merging is B(St) + O(n), the number of elements
in nodes with ∆v ≥ 4ℓ2 could be ω(B(St)).
We bound the overall cost as follows, using the result of Lemma 3. Since node v has ∆v >
4ℓ2 elements, we can rewrite the bounds as O(∆v/ℓ log(2ℓ)). Recall that ℓ = log d + O(1) =
log(O(log(n/∆v))) = log log(n/∆v) + O(1), since we use a good pivot selection method. Summing

over all nodes, we get Pv (∆v/ℓ) log(2ℓ) ≤ Pv ∆v log(2ℓ) = o (B(Pt)) + O(n), using Fact 1 and
recalling that B(Pt) =Pv ∆v log(n/∆v). Finally, using Lemma 1, we arrive at the claimed bound

for queries.

8

Now we show that the comparison cost for all nodes v where ∆v ≤ 4ℓ2 is at most o(B(St))+O(n).
Lemma 5. For nodes v in the pivot tree T where ∆v ≤ 4ℓ2, the total cost in comparisons for all
operations is at most o(B(St)) + O(n).
Proof. We observe that nodes with no more than 4ℓ2 elements do not incur any cost in comparisons
for median ﬁnding and partitioning, unless there is (at least) one associated query within the node.
Hence, we focus on nodes with at least one query.

Let z = (log log n)2 log log log n + O(1). We sort the elements of any node v with ∆v ≤ 4ℓ2
elements using O(z) comparisons, since ℓ ≤ log log n + O(1). We set each element as a pivot. The
total comparison cost over all such nodes is no more than O(tz), where t is the number of queries
we have answered so far. If t < n/z, then the above cost is O(n).

Otherwise, t ≥ n/z. Then, we know that B(Pt) ≥ (n/z) log(n/z), by Jensen’s inequality. (In
words, this represents the sort cost of n/z adjacent queries.) Thus, tz ∈ o(B(Pt)). Using Lemma 1,
we know that B(Pt) = B(St) + O(n), thus proving the lemma.

5 Optimal Online Dynamic Multiselection

In this section, we extend our results for the case of the static array by allowing insertions and
deletions of elements in the array, while supporting the selection queries. Recall that we are
originally given the unsorted list A. For supporting insert and delete eﬃciently, we maintain the
newly inserted elements in a separate data structure, and mark the deleted elements in A. These
insert and delete operations are occasionally merged to make the array up-to-date. Let A′ denote
the current array with length n′. We want to support the following two additional operations:

• insert(a), which inserts a into A′, and;
• delete(i), which deletes the ith (sorted) entry from A′.

5.1 Preliminaries

Our solution uses the dynamic bitvector data structure of Hon et al. [HSS03]. This structure
supports the following set of operations on a dynamic bitvector V. The rank b(i) operation tells the
number of b bits up to the ith position in V. The select b(i) operation gives the position in V of the
ith b bit. The insert b(i) operation inserts the bit b in the ith position. The delete(i) operation
deletes the bit located in the ith position. The ﬂip(i) operation ﬂips the bit in the ith position.

Note that one can determine the ith bit of V by computing rank 1(i) − rank 1(i − 1).

(For
convenience, we assume that rank b(−1) = 0.) The result of Hon et al. [HSS03, Theorem 1] can
be re-stated as follows, for the case of maintaining a dynamic bit vector (the result of [HSS03] is
stated for a more general case).

Lemma 6 ([HSS03]). Given a bitvector V of length n, there exists a data structure that takes
n + o(n) bits and supports rank b and select b in O(logt n) time, and insert , delete and ﬂip in O(t)
time, for any parameter t such that (log n)O(1) ≤ t ≤ n. The data structure assumes access to a
precomputed table of size nǫ, for any ﬁxed ǫ > 0.

The elements in the array A swapped during the queries and insert and delete operations, to
create new pivots, and the positions of these pivots are maintained as before using the bitvector B.
In addition, we also maintain two bitvectors, each of length n′: (i) an insert bitvector I such that
I[i] = 1 if and only if A′[i] is newly inserted, and (ii) a delete bitvector D such that if D[i] = 1, the

9

ith element in A has been deleted. If a newly inserted item is deleted, it is removed from I directly.
Both I and D are implemented as instances of the data structure of Lemma 6.

We maintain the values of the newly inserted elements in a balanced binary search tree T . The
inorder traversal of the nodes of T corresponds to the increasing order of their positions in array
A′. We support the following operations on this tree are: (i) given an index i, return the element
corresponding to the ith node in the inorder traversal of T , and (ii) insert/delete an element at a
given inorder position. By maintaining the subtree sizes of the nodes in T , these operations can be
performed in O(log n) time without having to perform any comparisons between the elements.

Our preprocessing steps are the same as in the static case. In addition, the bitvectors I and D

are each initialized to the bitvector of n 0s. The tree T is initially empty.

In addition, after performing |A| insert and delete operations, we merge all the elements in T
with the array A, modify the bitvector B appropriately, and reset the bitvectors I and D (with all
zeroes). This increases the amortized cost of the insert and delete operations by O(1), without
requiring any additional comparisons.

5.2 Dynamic Online Multiselection

We now describe how to support A′.insert (a), A′.delete(i), A′.select (i), and A′.search(a) operations.

A′.insert(a). First, we search for the appropriate unsorted interval [ℓ, r] containing a using a binary
search on the original (unsorted) array A. Now perform A.search(a) on interval [ℓ, r] (choosing which
subinterval to expand based on the insertion key a) until a’s exact position j in A is determined.
The original array A must have chosen as pivots the elements immediately to its left and right
(positions j − 1 and j in array A); hence, one never needs to consider newly-inserted pivots when
choosing subintervals. Insert a in sorted order in T among at position I.select 1(j) among all the
newly-inserted elements. Calculate j′ = I.select 0(j), and set a’s position to j′′ = j′ − D.rank 1(j′).
Finally, we update our bitvectors by performing I.insert 1(j′′) and D.insert 0(j′′). Note that, apart
from the search operation, all other operations in the insertion procedure do not perform any
comparisons between the elements.

A′.delete(i). First compute i′ = D.select 0(i). If i′ is newly-inserted (i.e., I[i′] = 1), then remove the
node (element) with inorder number I.rank 1(i′) from T . Then perform I.delete(i′) and D.delete(i′).
If instead i′ is an older entry, simply perform D.ﬂip(i′). In other words, we mark the position i′ in
A as deleted even though the corresponding element may not be in its proper place.5

If I[i] = 1, return the element corresponding to the node with inorder number

A′.select(i).
I.rank 1(i) in T . Otherwise, compute i′ = I.rank 0(i) − D.rank 1(i), and return A.select(i′)).
A′.search(a). First, we search for the appropriate unsorted interval [ℓ, r] containing a using a
binary search on the original (unsorted) array A. Then, perform A.search(a) on interval [ℓ, r] until
a’s exact position j is found. If a appears in array A (which we discover through search), we need
to now check whether it has been deleted. We compute j′ = I.select 0(j) and j′′ = j′ − D.rank 1(j′).
If D[j′] = 0, return j′′. Otherwise, it is possible that the item has been newly-inserted. Compute
p = I.rank 1(j′), which is the number of newly-inserted elements that are less than or equal to a.
If T [p] = a, then return j′′; otherwise, return failure.

5If a user wants to delete an item with value a, one could simply search for it ﬁrst to discover its rank, and then

delete it using this function.

10

We show that the above algorithm achieves the following performance (in Appendix C).

Theorem 3 (Optimal Online Dynamic Multiselection). Given a dynamic array A′ of n original
elements, there exists a dynamic online data structure that can support q = O(n) select, search,
insert, and delete operations, of which q′ are search, insert, and delete, we provide a deterministic
online algorithm that uses at most B(Sq)(1 + o(1)) + O(n + q′ log n) comparisons.

6 External Online Multiselection

Suppose we are given an unsorted array A of length N stored in n = N/B blocks in the external
memory. Recall that sorting A in the external memory model requires SortIO(N ) = Θ(n logm n)
I/Os. The techniques we use in main memory are not immediately applicable to the external memory 
model. In the extreme case where we have q = N queries, the internal memory solution would
require O(n log2(n/m)) I/Os. This compares poorly to the optimal O(n logm n) I/Os performed by
the optimal mergesort algorithm for external memory.

As in the case of internal memory, the lower bound on the number of I/Os required to perform
a given set of selection queries can be obtained by subtracting the number of I/Os required to sort
the elements between the ‘query gaps’ from the sorting bound. More speciﬁcally, let St = {si} be
the ﬁrst t queries from a query set Q, sorted by position, and for 1 ≤ i ≤ t, let ∆St
:= si+1 − si be
the query gaps, as deﬁned in Section 2.1. Then the lower bound on the number of I/Os required
to support the queries in St is given by

i

Bm(St)

:= n logm n −

t

Xi=0(cid:16)∆St

i /B(cid:17) logm(cid:16)∆St

i /B(cid:17) − O(n),

where we assume that logm(cid:16)∆St

i /B(cid:17) = 0 when ∆St

i < mB = M in the above deﬁnition.

6.1 Algorithm Achieving O(Bm(Sq)) + O(n) I/Os
We now show that our lower bound is asymptotically tight, by describing an O(1)-competitive
algorithm. We assume that log N = log n + log B = O(B)—which allows us to store a pointer to a
block of the input using a constant number of blocks. This constraint is a reasonable assumption in
practice, and is similar to the word-size assumption transdichotomous word RAM model [FW93].
In addition, the algorithm of Sibeyn [Sib06] only works under this assumption, though this is not
explicitly mentioned. We obtain the following result for the external memory model.

Theorem 4. Given an unsorted array A occupying n blocks in external memory, we provide a
deterministic algorithm that supports a sequence Q of q online selection queries using O(Bm(Sq)) +
O(n) I/Os under the condition that log N = O(B).

Proof. Our algorithm uses the same approach as the internal memory algorithm, except that it
chooses d − 1 pivots at once using Lemma 9. Hence, each node v of the pivot tree T containing ∆v
It subdivides its ∆v elements into d partitions. Using
elements has a branching factor of d.
Lemma 10, we know this requires 2δv + d I/Os, where δv = ∆v/B.

We choose d = m/2, which satisﬁes the constraints for Lemmas 9—10. We also maintain the
bitvector V of length N , as described before. For each A.select(i) query, we access position V[i].
If V[i] = 1, return A[i], else scan left and right from the ith position to ﬁnd the endpoints of this
interval Ii using |Ii|/B I/Os. The analysis follows directly from the internal algorithm.

We extend this result to also support search, insert, and delete operations in Appendix D.

11

References

[BF03]

G. Brodal and R. Fagerberg. On the limits of cache-obliviousness. In Proceedings of
the ACM Symposium on Theory of Computing, pages –, 2003.

[BFP+73] Manuel Blum, Robert W. Floyd, Vaughan R. Pratt, Ronald L. Rivest, and Robert Endre 
Tarjan. Time bounds for selection. J. Comput. Syst. Sci., 7(4):448–461, 1973.

[CFJ+09]

[DM81]

[DZ99]

[FW93]

Jean Cardinal, Samuel Fiorini, Gwena¨el Joret, Rapha¨el M. Jungers, and J. Ian Munro.
An eﬃcient algorithm for partial order production. In Proceedings of the 41st annual
ACM symposium on Theory of computing, STOC ’09, pages 93–100, New York, NY,
USA, 2009. ACM.

David P. Dobkin and J. Ian Munro. Optimal time minimal space selection algorithms.
J. ACM, 28(3):454–461, 1981.

Dorit Dor and Uri Zwick. Selecting the median. SIAM J. Comput., 28(5):1722–1758,
1999.

Michael L. Fredman and Dan E. Willard. Surpassing the information theoretic bound
with fusion trees. J. Comput. Syst. Sci., 47(3):424–436, 1993.

[Hoa61]

C. A. R. Hoare. Algorithm 65: ﬁnd. Commun. ACM, 4(7):321–322, 1961.

[HSS03] Wing-Kai Hon, Kunihiko Sadakane, and Wing-Kin Sung. Succinct data structures for
searchable partial sums. In Proceedings of the International Symposium on Algorithms
and Computation, pages 505–516, 2003.

[JM10]

Rosa M. Jim´enez and Conrado Mart´ınez. Interval sorting. In Proceedings of the International 
Colloquium on Automata, Languages, and Programming, pages 238–249,
2010.

[KMMS05] Kanela Kaligosi, Kurt Mehlhorn, J. Ian Munro, and Peter Sanders. Towards optimal

multiple selection. In ICALP, pages 103–114, 2005.

[MP80]

[Pro95]

J. Ian Munro and Mike Paterson. Selection and sorting with limited storage. Theor.
Comput. Sci., 12:315–323, 1980.

Helmut Prodinger. Multiple quickselect - hoare’s ﬁnd algorithm for several elements.
Inf. Process. Lett., 56(3):123–129, 1995.

[Sib06]

Jop F. Sibeyn. External selection. J. Algorithms, 58(2):104–117, 2006.

[SPP76]

Arnold Sch¨onhage, Mike Paterson, and Nicholas Pippenger. Finding the median. J.
Comput. Syst. Sci., 13(2):184–199, 1976.

12

A Randomized Algorithm

Our pivot-choosing method is simple and randomized. We choose 2m elements at random from an
interval of size ∆, sort them (or use a median-ﬁnding algorithm) to ﬁnd the median, and use that
for our pivot. We wish to set values of m and t such that two events happen:

• At least 2t elements are chosen in an interval of size 2∆/ log ∆ about the median of the

interval.

• Between m − t and m + t elements are chosen less than the median.
• Between m − t and m + t elements are chosen larger than the median.

If we can show that all events happen with probability 1 − O(1/n2), then we end up with the
median of our 2m elements being a pivot at position 1/2(1 + O(1/ log ∆)), which is a good pivot.
Note that the last two events are mirror images of one another, and so have the same probability

of occurring.

First Event. This is the simpler of the two to estimate. A randomly chosen element fails
If we
to land in the middle interval with probability 1 − 2/ log ∆ = exp[−2/ log ∆(1 + o(1))].
choose at least (1.1) log ∆ log n elements, all fail to land in this middle interval with probability
(1 − 2/ log ∆)(1.1) log ∆ log n = exp[−(2.2) log n(1 + o(1))] = O(1/n2). Since we need 2t elements in
the interval, it suﬃces for 2m ≥ (2.2)t log ∆ log n, or m ≥ (1.1)t log ∆ log n.

Second (and third) Event. We need a bound on the sum of the ﬁrst k binomial coeﬃcients.
The following bound and proof are attributed to Lovasz:

Lemma 7. Let 0 ≤ k < m and deﬁne c :=(cid:0) 2m
Xi=0(cid:18)2m

k+1(cid:1)/(cid:0)2m
i (cid:19) <

m(cid:1). Then
c
2 · 22m.

k

Proof. Write k + 1 = m − t. Deﬁne

A :=

B :=

By the deﬁnition of c we have

m−t−1

Xi=0 (cid:18)2m
i (cid:19)
Xi=m−t(cid:18)2m
i (cid:19)

m

and, because the growth rate of one binomial coeﬃcient to the next slows as we approach (cid:0)2m

m(cid:1), we

have

(cid:18) 2m
m − t(cid:19) = c(cid:18)2m
m(cid:19)

(cid:18) 2m
m − t − 1(cid:19) < c(cid:18) 2m
m − 1(cid:19)
(cid:18) 2m
m − t − j(cid:19) < c(cid:18) 2m
m − j(cid:19)

and thus

for 0 ≤ j ≤ m − t.

13

Thus it follows that the sum of any t consecutive binomial coeﬃcients is less than c times the
sum of the next t coeﬃcients as long as we stay on the left-hand side of Pascal’s triangle. Thus
A < cB + c2B + c3B + ··· < c

1−c B. We also have A + B ≤ 22m−1. Combining these we have

A <

Solving for A completes the proof.

We then bound

c

1 − c

B ≤

c

c − 1(cid:0)22m−1 − A(cid:1) .

This can be derived from Stirling’s formula and Taylor series estimates for the exponential and
logarithm functions. We then obtain that
Lemma 8. Let 0 ≤ t < m. Then

(cid:0) 2m
m−t(cid:1)
m(cid:1) ≤ e−t2/(m+t).
(cid:0)2m

m−t−1

Xi=0 (cid:18)2m

i (cid:19) < 22m−1 · e−t2/(m+t).

Since choosing an element from an interval at random and observing if it falls before or after
the median is an event of probability 1/2, the event of choosing 2m elements and having less than
m − t fall below the median occurs with probability at most
Xi=0 (cid:18)2m
i (cid:19).

By our lemma above, this is bounded by (1/2) exp[−t2/(m + t)]. Thus, the probability there are
between m−t and m+t elements below the median is at least 1−exp[−t2/(m+t)] by the symmetry
of Pascal’s triangle. To obtain 1− O(1/n2) we need t2/(m + t) > 2 log n, or t ≥ √2m log n(1 + o(1).
Using our lower bound for m in terms of t above, we conclude that m = 6(log n)3(log ∆)2 and

2−2m

m−t−1

t = 4(log n)2 log ∆ meet our needs.
Theorem 5. Given a list of elements of length ∆ < n, with ∆ at least 6(log n)3(log ∆)2, with
probability at least 1 − O(1/n2), if we sample 6(log n)3(log ∆)2 of the ∆ elements uniformly at
random, then median of the sample falls in position ∆/2 ± ∆/ log ∆ in the original list.

B Proof of Lemma 1 (Entropy Lemma)

Proof. Consider any two consecutive selection queries s and s′, and let ∆ = s′ − s be the gap
between them. Let P∆ = (pl, pl+1, . . . , pr) be the pivots in this gap, where pl = s and pr = s′. The
lemma follows from the claim that B(P∆) = O(∆), since
j 
 − n log n −

B(Pt) − B(St) = 

i !

Xi=0

log ∆Pt

log ∆St

∆Pt
j

∆St
i

k

k

t

Xj=0
i −

log ∆St

t

∆St
i

n log n −
Xi=0
Xi=0

B(P∆St

t

i

t

∆Pt
j

Xj=0
O(cid:16)∆St
Xi=0

) =

=

=

log ∆Pt
j

i (cid:17) = O(n).

14

We now proceed to prove our claim.

There must be a unique pivot in P∆ of minimal recursion depth. Any pair of pivots with
the same recursion depth must have a common ancestor, and this ancestor must lie between the
pair. This ancestor is in P∆ and it has smaller recursion depth than the pair. Let pm denote the
pivot of minimum depth. (Note that pm = s or pm = s′ are possible.) As before, deﬁne the gaps
∆i = pi+1 − pi for l ≤ i < r. We split the gap ∆ at pm. We address the right side ﬁrst, and the
argument for the left side is similar.
The sequence d(pm), d(pm+1), . . . , d(pr−1) must be strictly increasing. Otherwise, one of these

pivots must be a leaf in the pivot tree, and hence a query, which is a contradiction.

Now consider I(pm+1). This interval must have pm as its left endpoint, due to its smaller
recursion depth.
Its right endpoint must have recursion depth shallower than pm+1, and hence
it contains all pivots up to and including pr. This means I(pi) ⊂ I(pm+1) for m + 1 < i < r,
∆i = pi+1 − pi < |I(pi)| for m + 1 < i < r, and it means that ∆ ≤ |I(pm−1)| + |I(pm+1)|.
For brevity, we deﬁne Dl = Pm−1
i=m ∆i, giving ∆ = Dl + Dr, and further
Dl ≤ |I(pm−1)|, Dr ≤ |I(pm+1)|. Let us also deﬁne αi := Dr/∆i for m ≤ i < r. We have

i=0 ∆i and Dr = Pr−1

Dr log Dr −

r−1

Xi=m

∆i log ∆i =

r−1

Xi=m

∆i log(Dr/∆i) = Dr

(log αi)/αi.

r−1

Xi=m

This quantity can be bounded from above with a lower bound on αi. Write Dr = b · |I(pm+1)| for
a constant b with 0 < b ≤ 1. So we have

αi = Dr/∆i > Dr/|I(pi)| = b|I(pm+1)|/|I(pi)|.

Since we are using a good pivot selection method, we get the bound

|I(pi)| ≤ |I(pm+1)| · cd(pi)−d(pm+1)+O(1).

Plugging in gives us αi > b · c−d(pi)+d(pm+1)+O(1) ≥ b · cm+1−i+O(1). The last inequality used the
fact that the recursion depths must be strictly increasing. Then

log αi
αi ≤

r−1

Xi=m

r−1−m

Xj=0

log(bcj+O(1))

bcj+O(1)

= O(1).

And thus

Dr log Dr −

A similar argument on the left side gives

Dl log Dl −

r−1

Xi=m

m−1

Xi=0

∆i log ∆i = O(Dr).

∆i log ∆i = O(Dl).

Finally, ∆ log ∆ − Dr log Dr − Dl log Dl = O(∆), and the proof is complete.

C Proof of Theorem 3

Let A′ denote the current array of length n′, after a sequence of queries and insertions. Let Q be the
sequence of q selection operations performed (either directly or indirectly through other operations)

15

on A′, ordered by time of arrival. Let Sq be the queries of Q, ordered by position. We now analyze
the number of comparisons performed by a sequence of queries and insert and delete operations.

We consider the case when the number of insert and delete operations is less than n. In other
If q′ is the number of
words, we are between two rebuildings of our dynamic data structure.
search, insert, and delete operations in the sequence, then we perform O(q′ log n′) comparisons
to perform the required searches. Note that our algorithm does not perform any comparisons for
delete(i) operations, until some other query is in the same interval as i. The deleted element will
participate in the other costs (merging, pivot-ﬁnding, and partitioning) for these other queries, but
its contribution can be bounded by O(log n), which we have as a credit.

Since a delete operation does not perform any additional comparisons beyond those needed to
perform a search, we assume that all the updates are insertions in the rest of this section. Since
each inserted element becomes a pivot immediately, it does not contribute to the comparison cost
of any other select operation. Also, note that in the algorithm of Theorem 2, no pivot is part of a
run and hence cannot eﬀect the choice of any future pivot.

Since Q is essentially a set of q selection queries, we can bound its total comparison cost for
selection queries by Theorem 2, which gives a bound of B(Sq)(1 + o(1)) + O(n). This proves the
theorem.

D External Online Multiselection

Suppose we are given an unsorted array A of length N stored in n = N/B blocks in the external
memory. Recall that sorting A in the external memory model requires SortIO(N ) = Θ(n logm n)
I/Os. The techniques we use in main memory are not immediately applicable to the external memory 
model. In the extreme case where we have q = N queries, the internal memory solution would
require O(n log2(n/m)) I/Os. This compares poorly to the optimal O(n logm n) I/Os performed by
the optimal mergesort algorithm for external memory.

D.1 A Lower Bound for Multiselect in External Memory

As in the case of internal memory, the lower bound on the number of I/Os required to perform a
given set of selection queries can be obtained by subtracting the number of I/Os required to sort
the elements between the ‘query gaps’ from the sorting bound. More speciﬁcally, let St = {si} be
the ﬁrst t queries from a query set Q, sorted by position, and for 1 ≤ i ≤ t, let ∆St
:= si+1 − si be
the query gaps, as deﬁned in Section 2.1. Then the lower bound on the number of I/Os required
to support the queries in St is given by

i

Bm(St)

:= n logm n −

t

Xi=0(cid:16)∆St

i /B(cid:17) logm(cid:16)∆St

i /B(cid:17) − O(n),

where we assume that logm(cid:16)∆St

i /B(cid:17) = 0 when ∆St

i < mB = M in the above deﬁnition.

D.2 Partitioning in External Memory

The main diﬀerence between our algorithms for internal and external memory is the partitioning
procedure. In the internal memory algorithm, we partition the values according to a single pivot,
recursing on the half that contains the answer. oIn the external memory algorithm, we modify
this binary partition to a d-way partition, for some d = Θ(m), by ﬁnding a sample of d “roughly

16

equidistant elements.” The next two lemmas describe how to ﬁnd such a sample, and then partition
the range of values into d + 1 subranges with respect to the sample.

Lemma 9. Given an unsorted array A containing N elements in external memory and an integer
parameter d < M/ log N , one can compute a sample of size d from A using n = N/B I/Os, such
that the rank of the jth value in this sample is within [j(N/d) − d, (j + log(N/d) − 1)N/d].
Proof. Given an unordered sequence of N elements (stored in a read-only memory) and an additional 
working space of size S = Ω((log N )2), Munro and Paterson [MP80] showed how to compute
a “reasonably well-spaced sample” of size s ≤ S/ log N , in a single sequential scan over the sequence.
 This well-spaced sample has the property that the rank of the jth element of the sample
among the initial sequence of elements is between (jN/s) − 1 and (j + log(N/s) − 1)N/s.
The algorithm only reads the input sequence from left to right, and it does not perform any
random accesses to the sequence. Note that we have access to an unbounded working space in the
external memory at the cost of additional I/Os. If M = o((log N )2), we can use the space on the
disk as temporary working space. Hence, it is easy to see that this algorithm can be translated to
the external memory model with S = max{M, (log N )2}, which gives the result stated.
Lemma 10. Given an unsorted array A occupying n pages of external memory and d < M/(2B)
sample elements stored in main memory, there is an algorithm to partition A by those values in
2n + d I/Os.

Proof. The algorithm scans the data, keeping one input block and d + 1 output blocks in main
memory. An output block is written to external memory when it is full, or when the scan is
complete. The algorithm performs n I/O to read the input, and at most n + d + 1 I/Os to write
the output into d + 1 partitions.

D.3 Algorithm Achieving O(Bm(Sq)) + O(n) I/Os
We now show that our lower bound is asymptotically tight, by describing an O(1)-competitive
algorithm. We assume that log N = log n + log B = O(B)—which allows us to store a pointer to a
block of the input using a constant number of blocks. This constraint is a reasonable assumption in
practice, and is similar to the word-size assumption transdichotomous word RAM model [FW93].
In addition, the algorithm of Sibeyn [Sib06] only works under this assumption, though this is not
explicitly mentioned.

Theorem 6. Given an unsorted array A occupying n blocks in external memory, we provide a
deterministic algorithm that supports a sequence Q of q online selection queries using O(Bm(Sq)) +
O(n) I/Os under the condition that log N = O(B).

Proof. Our algorithm uses the same approach as the internal memory algorithm, except that it
chooses d − 1 pivots at once using Lemma 9. Hence, each node v of the pivot tree T containing ∆v
elements has a branching factor of d.
It subdivides its ∆v elements into d partitions. Using
Lemma 10, we know this requires 2δv + d I/Os, where δv = ∆v/B.

We choose d = m/2, which satisﬁes the constraints for Lemmas 9—10. We also maintain the
bitvector V of length N , as described before. For each A.select(i) query, we access position V[i].
If V[i] = 1, return A[i], else scan left and right from the ith position to ﬁnd the endpoints of this
interval Ii using |Ii|/B I/Os. The analysis follows directly from the internal algorithm.

To add searches, we cannot aﬀord to spend log n time performing binary search on the blocks
of B. To handle this case, we build a B-tree T maintaining all pivots from A. (During preprocessing,

17

we insert A[1] and A[n] into T .) The B-tree T will be used to support search queries in O(logB N )
I/Os instead of O(log N ) I/Os. We modify the proof of Theorem 6 to obtain the following:

Corollary 1. Given an unsorted array A occupying n blocks in external memory, we provide a
deterministic algorithm that supports a sequence Q of q online selection and search queries using
O(Bm(Sq)) + O(min{qm, N} logB N ) + O(n) I/Os under the condition that log N = O(B).

Combining the ideas from Corollary 1 and Theorem 3, we can dynamize the above algorithm.

Corollary 2. Given an unsorted array A occupying n blocks in external memory, we provide a deterministic 
algorithm that supports a sequence Q of q online select, search, insert, and deleteoperations
using O(Bm(Sq)) + O(min{qm, N} logB N ) + O(n) I/Os under the condition that log N = O(B).

18

