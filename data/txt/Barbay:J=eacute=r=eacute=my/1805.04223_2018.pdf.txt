8
1
0
2

 

y
a
M
5
1

 

 
 
]

G
C
.
s
c
[
 
 

2
v
3
2
2
4
0

.

5
0
8
1
:
v
i
X
r
a

Computing Coverage Kernels

Under Restricted Settings

J´er´emy Barbay1 (cid:63), Pablo P´erez-Lantero2, and Javiel Rojas-Ledesma1

1 Departamento de Ciencias de la Computaci´on, Universidad de Chile, Chile

jeremy@barbay.cl, jrojas@dcc.uchile.cl.

2 Departamento de Matem´atica y Ciencia de la Computaci´on,

Universidad de Santiago, Chile. pablo.perez.l@usach.cl.

Abstract. We consider the Minimum Coverage Kernel problem:
given a set B of d-dimensional boxes, ﬁnd a subset of B of minimum
size covering the same region as B. This problem is NP-hard, but as
for many NP-hard problems on graphs, the problem becomes solvable in
polynomial time under restrictions on the graph induced by B. We consider 
various classes of graphs, show that Minimum Coverage Kernel
remains NP-hard even for severely restricted instances, and provide two
polynomial time approximation algorithms for this problem.

Introduction

1
Given a set P of n points, and a set B of m boxes (i.e. axis-aligned closed
hyper-rectangles) in d-dimensional space, the Box Cover problem consists in
ﬁnding a set C ⊆ B of minimum size such that C covers P . A special case is the
Orthogonal Polygon Covering problem: given an orthogonal polygon P
with n edges, ﬁnd a set of boxes C of minimum size whose union covers P. Both
problems are NP-hard [8, 11], but their known approximabilities in polynomial
time are diﬀerent: while Box Cover can be approximated up to a factor within
O(log OPT), where OPT is the size of an optimal solution [5, 7]; Orthogonal
√
Polygon Covering can be approximated up to a factor within O(
log n) [14].
In an attempt to better understand what makes these problems hard, and why
there is such a gap in their approximabilities, we introduce the notion of coverage
kernels and study its computational complexity.
Given a set B of n d-dimensional boxes, a coverage kernel of B is a subset
K ⊆ B covering the same region as B, and a minimum coverage kernel of B
is a coverage kernel of minimum size. The computation of a minimum coverage
kernel (namely, the Minimum Coverage Kernel problem) is intermediate between 
the Orthogonal Polygon Covering and the Box Cover problems.
This problem has found applications (under distinct names, and slight varia-
tions) in the compression of access control lists in networks [9], and in obtaining
concise descriptions of structured sets in databases [15, 19]. Since Orthogonal

(cid:63) This work was supported by projects CONICYT Fondecyt/Regular nos 1170366 and

1160543, and CONICYT-PCHA/Doctorado Nacional/2013-63130209 (Chile).

2

Polygon Covering is NP-hard, the same holds for the Minimum Coverage
Kernel problem. We are interested in the exact computation and approximability 
of Minimum Coverage Kernel in various restricted settings:

1. Under which restrictions is the exact computation of Minimum

Coverage Kernel still NP-hard?

2. How precisely can one approximate a Minimum Coverage Kernel

in polynomial time?
When the interactions between the boxes in a set B are simple (e.g., when all
the boxes are disjoint), a minimum coverage kernel of B can be computed eﬃciently.
 A natural way to capture the complexity of these interactions is through
the intersection graph. The intersection graph of B is the un-directed graph
with a vertex for each box, and in which two vertices are adjacent if and only
the respective boxes intersect. When the intersection graph is a tree, for instance,
each box of B is either completely covered by another, or present in any coverage
kernel of B, and thus a minimum coverage kernel can be computed eﬃciently.
For problem on graphs, a common approach to understand when does an NPhard 
problem become easy is to study distinct restricted classes of graphs, in
the hope to deﬁne some form of “boundary classes” of inputs separating “easy”
from “hard” instances [2]. Based on this, we study the hardness of the problem
under restricted classes of the intersection graph of the input.

Our results. We study the Minimum Coverage Kernel problem under three
restrictions of the intersection graph, commonly considered for other problems [2]:
planarity of the graph, bounded clique-number, and bounded vertex-degree. We
show that the problem remains NP-hard even when the intersection graph of
the boxes has clique-number at most 4, and the maximum degree is at most 8.
For the Box Cover problem we show that it remains NP-hard even under the
severely restricted setting where the intersection graph of the boxes is planar, its
clique-number is at most 2 (i.e., the graph is triangle-free), the maximum degree
is at most 3, and every point is contained in at most two boxes.

We complement these hardness results with two approximation algorithms
for the Minimum Coverage Kernel problem running in polynomial time. We
describe a O(log n)-approximation algorithm which runs in time within O(OPT ·
2 +1 log2 n); and a randomized algorithm computing a O(log OPT)-approximation
n d
in expected time within O(OPT · n
log2 n), with high probability (at least
1 − 1
nΩ(1) ). Our main contribution in this matter is not the existence of polynomial 
time approximation algorithms (which can be inferred from results on
Box Cover), but a new data structure which allows to signiﬁcantly improve
the running time of ﬁnding those approximations (when compared to the approximation 
algorithms for Box Cover). This is relevant in applications where
a minimum coverage kernel needs to be computed repeatedly [1, 9, 15, 19].

d+1

2

In the next section we review the reductions between the three problems
we consider, and introduce some basic concepts. We then present the hardness
results in Section 3, and describe in Section 4 the two approximation algorithms.
We conclude in Section 5 with a discussion on the results and future work.

3

Fig. 1. a) An orthogonal polygon P. b) A set of boxes B = {b1, b2, b3, b4} covering
exactly P, and such that in any cover of P with boxes, every box is either in B, or fully
covered by a box in B. c) A set of points D(B) = {p1, p2, p3, p4, p5} such that any subset
of B covering D(B), covers also P. d) The subset {b1, b2, b4} is an optimal solution for
the Orthogonal Polygon Cover problem on P, the Minimum Coverage Kernel
problem on B, and the Box Cover problem on D(B),B.

2 Preliminaries

To better understand the relation between the Orthogonal Polygon Covering,
 the Box Cover and the Minimum Coverage Kernel problems, we
brieﬂy review the reductions between them. We describe them in the Cartesian
plane, as the generalization to higher dimensions is straightforward.
Let P be an orthogonal polygon with n horizontal/vertical edges. Consider
the grid formed by drawing inﬁnitely long lines through each edge of P (see
Figure 1.a for an illustration), and let G be the set of O(n2) points of this grid
lying on the intersection of two lines. Create a set B of boxes as follows: for
each pair of points in G, if the box having those two points as opposed vertices
is completely inside P, then add it to B (see Figure 1.b.) Let C be any set of
boxes covering P. Note that for any box c ∈ C, either the vertices of c are in
G, or c can be extended horizontally and/or vertically (keeping c inside P) until
this property is met. Hence, there is at least one box in B that covers each
c ∈ C, respectively, and thus there is a subset B(cid:48) ⊆ B covering P with |B(cid:48)| ≤
|C|. Therefore, any minimum coverage kernel of B is also an optimal covering
of P (and thus, transferring the NP-hardness of the Orthogonal Polygon
Covering problem [8] to the Minimum Coverage Kernel problem).
Now, let B be a set of n boxes, and consider the grid formed by drawing
inﬁnite lines through the edges of each box in B. This grid has within O(n2) cells
(O(nd) when generalized to d dimensions). Create a point-set D(B) as follows:
for each cell c which is completely inside a box in B we add to D(B) the middle
point of c (see Figure 1.c for an illustration). We call such a point-set a coverage
discretization of B, and denote it as D(B). Note that a set C ⊆ B covers D(B) if
and only if C covers the same region as B (namely, C is a coverage kernel of B).
Therefore, the Minimum Coverage Kernel problem is a special case of the
Box Cover problem.

The relation between the Box Cover and the Minimum Coverage Kernel 
problems has two main implications. Firstly, hardness results for the Mini-

b1b3b2→→b4b1b3b2b4(a)(b)(c)(d)→b1b2b4Pp1p3p2p4p54

mum Coverage Kernel problem can be transferred to the Box Cover problem.
 In fact, we do this in Section 3, where we show that Minimum Coverage
Kernel remains NP-hard under severely restricted settings, and extend this result 
to the Box Cover problem under even more restricted settings. The other
main implication is that polynomial-time approximation algorithms for the Box
Cover problem can also be used for Minimum Coverage Kernel. However,
in scenarios where the boxes in B represent high dimensional data [9, 15, 19] and
Coverage Kernels need to be computed repeatedly [1], using approximation
algorithms for Box Cover can be unpractical. This is because constructing
D(B) requires time and space within Θ(nd). We deal with this in Section 4, where
we introduce a data structure to index D(B) without constructing it explicitly.
Then, we show how to improve two existing approximation algorithms [5, 16] for
the Box Cover problem by using this index, making possible to use them for
the Minimum Coverage Kernel problem in the scenarios commented on.

3 Hardness under Restricted Settings

We prove that Minimum Coverage Kernel remains NP-hard for restricted
classes of the intersection graph of the input set of boxes. We consider three
main restrictions: when the graph is planar, when the size of its largest clique
(namely the clique-width of the graph) is bounded by a constant, and when the
degree of a vertex with maximum degree (namely the vertex-degree of the graph)
is bounded by a constant.

3.1 Hardness of Minimum Coverage Kernel
Consider the k-Coverage Kernel problem: given a set B of n boxes, ﬁnd
whether there are k boxes in B covering the same region as the entire set. Proving
that k-Coverage Kernel is NP-complete under restricted settings yields the
NP-hardness of Minimum Coverage Kernel under the same conditions. To
prove that k-Coverage Kernel is NP-hard under restricted settings we reduce
instances of the Planar 3-SAT problem (a classical NP-complete problem [17])
to restricted instances of k-Coverage Kernel. In the Planar 3-SAT problem,
 given a boolean formula in 3-CNF whose incidence graph1 is planar, the
goal is to ﬁnd whether there is an assignment which satisﬁes the formula. The
(planar) incidence graph of any planar 3-SAT formula ϕ can be represented in
the plane as illustrated in Figure 2 for an example, where all variables lie on a
horizontal line, and all clauses are represented by non-intersecting three-legged
combs [13]. We refer to such a representation of ϕ as the planar embedding of ϕ.
Based on this planar embedding we proof the results in Theorem 1. Although
our arguments are described in two dimensions, they extend trivially to higher
dimensions.

1 The incidence graph of a 3-SAT formula is a bipartite graph with a vertex for each
variable and each clause, and an edge between a variable vertex and a clause vertex
for each occurrence of a variable in a clause.

5

Fig. 2. Planar embedding of the formula ϕ = (v1 ∨ v2 ∨ v3) ∧ (v3 ∨ v4 ∨ v5) ∧
(v1 ∨ v3 ∨ v5) ∧ (v1 ∨ v2 ∨ v4) ∧ (v2 ∨ v3 ∨ v4) ∧ (v4 ∨ v5 ∨ v6) ∧ (v1 ∨ v5 ∨ v6).
The crosses and dots at the end of the clause legs indicate that the connected
variable appears in the clause negated or not, respectively.

Theorem 1. Let B be a set of n boxes in the plane and let G be the intersection
graph of B. Solving k-Coverage Kernel over B is NP-complete even if G has
clique-number at most 4, and vertex-degree at most 8.
Proof. Given any set B of n boxes in Rd, and any subset K of B, certifying
that K covers the same region as B can be done in time within O(nd/2) using
Chan’s algorithm [6] for computing the volume of the union of the boxes in B.
Therefore, k-Coverage Kernel is in NP. To prove that it is NP-complete,
given a planar 3-SAT formula ϕ with n variables and m clauses, we construct
a set B of O(n + m) boxes with a coverage kernel of size 31m + 3n if and
only if there is an assignment of the variables satisfying ϕ. We use the planar
embedding of ϕ as a start point, and replace the components corresponding to
variables and clauses, respectively, by gadgets composed of several boxes. We
show that this construction can be obtained in polynomial time, and thus any
polynomial time solution to k-Coverage Kernel yields a polynomial time
solution for Planar 3-SAT. We replace the components in that embedding
corresponding to variables and clauses, respectively, by gadgets composed of
several boxes, adding a total number of boxes polynomial in the number of
variable and clauses.

Variable gadgets. Let v be a variable of a planar 3-SAT formula ϕ, and let cv be
the number of clauses of ϕ in which v appears. The gadget for v is composed of
4cv + 2 rectangles colored either red or blue (see Figure 4 for an illustration): 4cv
horizontal rectangles (of 3× 1 units of size), separated into two “rows” with 2cv
rectangles each, and two vertical rectangles (of 1 × 4 units of size) connecting
the rows. The rectangles in each row are enumerated from left to right, starting
by one. The i-th rectangle of the j-th row is deﬁned by the product of intervals
[4(i − 1), 4i − 1] × [4(j − 1), 4(j − 1) + 1], for all i = [1..2cv] and j = 1, 2.
The gadget occupies a rectangular region of (4cv + 1) × 4 units. Although the
gadget is deﬁned with respect to the origin of coordinates, it is later translated
to the region corresponding to v in the embedding of Knuth and Raghunathan
[13], which we assume without loss of generality to be large enough to ﬁt the
gadget. Every horizontal rectangle is colored red if its numbering is odd, and blue
otherwise. Besides, the vertical leftmost (resp. rightmost) rectangle is colored
blue (resp. red). As we will see later, these colors are useful when connecting a
clause gadget with its variables.

v1v2v3v4v5v66

Fig. 3. Variable and clause gadgets for ϕ = (v1∨v2∨v3)∧(v1∨v2∨v4)∧(v1∨v3∨
v4). The bold lines highlight one side of each rectangle in the instance, while
the dashed lines delimit the regions of the variable and clause components in
the planar embedding of ϕ. Finding a minimum subset of rectangles covering
the non-white regions yields an answer for the satisﬁability of ϕ.

Fig. 4. a) Gadget for a variable appearing in two clauses. A clause gadget
connects with the variable in the regions marked with a dot or a cross, depending 
on the sign of the variable in the clause. The optimal way to cover all the
redundant regions (the gray regions) is to choose either all the red rectangles
(as in b) or all the blue rectangles (as in c). d) The intersection graph of the
variable gadget.

Observe that: (i.) every red (resp. blue) rectangle intersects exactly two others,
 both blue (resp. red), sharing with each a squared region of 1 × 1 units
(which we call redundant regions); (ii.) the optimal way to cover the redundant
regions is by choosing either all the 2cv + 1 red rectangles or all the 2cv + 1 blue
rectangles (see Figure 4 for an example).

Clause gadgets. Let C be a clause with variables u, v, and w, appearing in this
order from left to right in the embedding of ϕ. Assume, without loss of generality,
that the component for C in the embedding is above the variables. We create
a gadget for C composed of 9 black rectangles, located and enumerated as in
Figure 5.a. The vertical rectangles numbered 1, 2 and 3 correspond to the legs of
C in the embedding, and connect with the gadgets of u, v, and w, respectively.
The remaining six horizontal rectangles connect the three legs between them.
The vertical rectangles have one unit of width and their height is given by the

v1v2v3v4048048048013422626260134201342(a)(b)(c)(d)7

Fig. 5. a) A clause gadget with nine black rectangles: three vertical legs (1,2,
and 3) and six horizontal rectangles (4-9). We call the regions where they meet
redundant regions. The striped regions at the bottom of each leg connect with
the variables. b) The intersection graph of the gadget. Any minimum cover of
the edges (redundant regions) requires 5 vertices (rectangles). c) Any cover of
the redundant regions which includes the three legs has 6 or more rectangles.

height of the respective legs in the embedding of C. Similarly, the horizontal
rectangles have one unit of height and their width is given by the separation
between the legs in the embedding of C (see Figure 3 for an example of how these
rectangles are extended or stretched as needed). Note that: (i.) every rectangle
in the gadget intersects exactly two others (again, we call redundant regions the
regions where they meet); (ii.) any minimum cover of the redundant regions
(edges in Figure 5.b) has ﬁve rectangles, one of which must be a leg; and (iii.)
any cover of the redundant regions which includes the three legs must have at
least six rectangles (e.g., see Figure 5.c).

Connecting the gadgets. Let v be a variable of a formula ϕ and cv be the number
of clauses in which v occurs. The legs of the cv clause gadgets are connected
with the gadget for v, from left to right, in the same order they appear in the
embedding of ϕ. Let C be the gadget for a clause containing v whose component
in the embedding of ϕ is above (resp. below) that for v. C connects with the
gadget for v in one of the rectangles in the upper (resp. lower) row, sharing a
region of 1 × 1 units with one of the red (resp. blue) rectangles if the variable
appears positive (resp. negative) in the clause (see Figure 6.a). We call this
region where the variable and clause gadgets meet as connection region, and its
color is given by the color of the respective rectangle in the variable gadget. Note
that a variable gadget has enough connection regions for all the cv clauses in
which it appears, because each row of the gadget has cv rectangles of each color.

Completing the instance. Each rectangle in a variable or clause gadget, as described,
 has a region that no other rectangle covers (i.e., of depth 1). Thus, the
coverage kernel of the instances described up to here is trivial: all the rectangles.
To avoid this, we cover all the regions of depth 1 with green rectangles (as illustrated 
in Figure 6.b) which are forced to be in any coverage kernel2. For every
clause gadget we add 11 such green rectangles, and for each variable gadget for
a variable v occurring in cv clauses we add 3cv + 2 green rectangles.

2 For simplicity, these green rectangles were omitted in Figure 3 and Figure 7.

7123456789(a)123476598(b)2345689(c)18

Fig. 6. An instance for (v1 ∨ v2 ∨ v3). a) The clause gadget connects with a
variable gadget in one of its red or blue connection regions depending on the
sign of the variable in the clause. b) To complete the instance, green boxes are
added to cover all the regions with depth 1. The green rectangles are forced to
be in any kernel by making them large enough so that each covers an exclusive
region.

Let ϕ be a formula with n variables and m clauses. The instance of kCoverage 
Kernel that we create for ϕ has a total of 41m + 4n rectangles: (i.)
each clause gadget has 9 rectangles for the comb, and 11 green rectangles, for a
total of 20m rectangles over all the clauses; (ii.) a gadget for a variable v has
4cv + 2 red and blue rectangles, and we add a green rectangle for each of those
that does not connect to a clause gadget (3cv + 2 per variable), thus adding a
total of 7cv + 4 rectangles by gadget; and (iii.) over all variables, we add a total

i=1 7cvi + 4 = 7(3m) + 4n = 21m + 4n rectangles3.

of(cid:80)n

Intuition: from minimum kernels to boolean values. Consider a gadget for a
variable v. Any minimum coverage kernel of the gadget is composed of all its
green rectangles together with either all its blue or all its red rectangles. Thus
the minimum number of rectangles needed to cover all the variable gadgets is
ﬁxed, and known. If all the red rectangles are present in the kernel, we consider
that v = 1, otherwise if all the blue rectangles are present, we consider that
v = 0 (see Figure 7 for an example). In the same way that choosing a value for
v may aﬀect the output of a clause C in which v occurs, choosing a color to
cover the gadget for v may aﬀect the number of rectangles required to cover the
gadget for C. For instance, consider that the gadget for v is covered with blue
rectangles (i.e., v = 0), and that v occurs unnegated in C (see the gadgets for v1
and the second clause in Figure 7). The respective leg of the gadget for C meets
v in one of its red rectangles. Since red rectangles were not selected to cover the
variable gadget, that leg is forced to cover the connection region shared with
the variable gadget, and thus is forced to be in any kernel of the gadget for C.
This corresponds to the fact that the literal of v in C evaluates to 0. If the same
happens for the three variables in C (i.e., C is not satisﬁed by the assignment),
then to cover its gadget at least six of the black rectangles will be required (see
the gadget for the second clause in Figure 7). However, if at least one of its legs
can be disposed of (i.e., at least one of the literals evaluates to 1), then the clause

3 Note that(cid:80)n

i=1 cvi = 3m since exactly 3 variables occurs in each clause.

(a)(b)v1v2v3v1v2v39

Fig. 7. a) An instance for ϕ = (v1 ∨ v2 ∨ v3) ∧ (v1 ∨ v2 ∨ v3) (the area covered
by green rectangles is highlighted with green falling lines). b) A cover of the
gadgets corresponding to the assignment v1 = 0, v2 = 1, v3 = 1 that does not
satisfy ϕ.

gadget can be covered with ﬁve of its black rectangles (see the gadget for the
ﬁrst clause in Figure 7). The minimum number of rectangles needed to cover all
the variable gadgets is ﬁxed and known: all the green rectangles, and one half of
the red/blue rectangles of each variable. Therefore, it suﬃces to show that there
is an assignment satisfying a 3-SAT formula if and only if every clause gadget
can be covered by ﬁve of its black rectangles (plus all its green rectangles).

Reduction. We prove the theorem in two steps. First, we show that such an instance 
has a coverage kernel of size 31m+3n if and only ϕ is satisﬁable. Therefore,
answering k-Coverage-Kernel over this instance with k = 31m + 3n yields
an answer for Planar 3-SAT on ϕ. Finally, we will show that the instance
described matches all the restrictions in Theorem 1, under minor variations.
(⇒) Let ϕ be 3-CNF formula with n variables v1, . . . , vn and m clauses C1, . . . , Cm,
let B be a set of boxes created as described above for ϕ, and let {v1 = α1, . . . , vn =
αn} be an assignment which satisﬁes ϕ. We create a coverage kernel K of B as
follows:
– For each variable gadget for vi ∈ {v1, . . . , vn} such that αi = 0 (resp. αi = 1),
add to K all but its red (resp. blue) rectangles, thus covering the entire gadget
minus its red (resp. blue) connection regions. This uncovered regions, which
must connect with clauses in which the literal of vi evaluates to 0, will be
covered later with the legs of the clause gadgets. Over all variables, we add to
i=1 ((7 − 2)cvi + (4 − 1)) = 5(3m)+3n = 15m+3n rectangles.
– For each clause Ci ∈ {C1, . . . , Cn}, add to K all its green rectangles and
the legs that connect with connection regions of the variable gadgets left
uncovered in the previous step. Note that at least one of the legs of Ci is
not added to K since at least one of the literals in the clause evaluates to
1, and the connection region corresponding to that literal is already covered
by the variable gadget. Thus, the redundant regions of the gadget for Ci
can be covered with ﬁve of its black rectangles (including the legs already

K a total of(cid:80)n

v1v2v3v1=0v2=1v3=1(a)(b)10

added). So, ﬁnally add to K black rectangles from the clause for Ci as needed
(up to a total of ﬁve), until all the redundant regions are covered (and with
the green rectangles, the entire gadget). Over all clauses, we add a total of
(11 + 5)m = 16m rectangles.

By construction, K is a coverage kernel of B: it covers completely every variable
and clause gadget. Moreover, the size of K is (15m + 3n) + 16m = 31m + 3n.

(cid:80)n

(⇐) Let ϕ be 3-CNF formula with n variables v1, . . . , vn and m clauses C1, . . . , Cm,
let B be a set of boxes created as described above for ϕ, and let K be a coverage
kernel of B whose size is (15m+3n)+16m = 31m+3n. Any coverage kernel of B
must include all its green rectangles. Furthermore, to cover any clause gadget at
least ﬁve of its black rectangles are required, and to cover any variable rectangle,
at least half of its red/blue rectangles are required. Thus, any coverage kernel
of B most have at least (11 + 5)m = 16m of the clause rectangles, and at least
i=1 ((3 + 4/2)cvi + (3)) = 5(3m) + 3n = 15m + 3n of the variable rectangles
are required. Hence, K must be a coverage kernel of minimum size.
Since the redundant regions of any two gadgets are independent, K must
cover each gadgets optimally (in a local sense). Given that the intersection graph
of the red/blue rectangles of a variable gadget is a ring (see Figure 4.d for an
illustration), the only way to cover a variable gadget optimally is by choosing
either all its blue or all its red rectangles (together with the green rectangles).
Hence, the way in which every variable gadget is covered is consistent with an
assignment for its variable as described before in the intuition. Moreover, the
assignment induced by K must satisfy ϕ: in each clause gadget, at least one of
the legs was discarded (to cover the gadget with 5 rectangles), and at least the
literal in the clause corresponding to that leg evaluates to 1.

Meeting the restrictions. Now we prove that the instance of Minimum Coverage 
Kernel generated for the reduction meets the restrictions of the theorem.
First, we show the bounded clique-number and vertex-degree properties for the
intersection graph of a clause gadget and its three respective variable gadgets. In
Figure 8 we illustrate the intersection graph for the clause ϕ = (v1∨v2∨v3). The
sign of the variables in the clause does not change the maximum vertex degree or
the clique-number of the graph, so the ﬁgure is general enough for our purpose.
Since we consider the rectangles composing the instance to be closed rectangles,
if two rectangles containing at least one point in common (in their interior or
boundary), their respective vertices in the intersection graph are adjacent. Note
that in Figure 8 the vertices with highest degree are the ones corresponding
to legs of the clause gadget (rectangles 1, 2, and 3). There are 4-cliques in the
graph, for instance the right lower corner of the green rectangle denoted h is
covered also by rectangles 1, 4 and d, and hence their respective vertices form
a clique. However, since there is no point that is covered by ﬁve rectangles at
the same time, there are no 5-cliques in the graph. Finally, note that, since the
clause gadgets are located according to the planar embedding of the formula,

11

Fig. 8. The intersection graph of the instance of the Minimum Coverage
Kernel problem corresponding to ϕ = (v1∨v2∨v3) (see the complete instance
in Figure 6.b). a) Numbering of the rectangles of the clause gadget. b) The
intersection graph of the instance: the vertices corresponding to the legs have
degree 8, which is the highest; and the red fat edges highlight two 4-cliques.

they are pairwise independent.4 Thus, the bounds on the clique-number and
vertex-degree of the intersection graph of any clause gadget extend also to the
(cid:117)(cid:116)
intersection graph of an entire general instance.

3.2 Extension to Box Cover

Since the Minimum Coverage Kernel problem is a special case of the Box
Cover problem, the result of Theorem 1 also applies to the Box Cover problem.
 However, in Theorem 2 we show that this problem remains hard under even
more restricted settings.
Theorem 2. Let P , B be a set of m points and n boxes in the plane, respectively,
and let G be the intersection graph of B. Solving Box Cover over B and P is
NP-complete even if every point in P is covered by at most two boxes of B, and
G is planar, has clique-number at most 2, and vertex-degree at most 4.

4 Two clause gadgets are pairwise independent if the rectangles composing them are
pairwise independent, as well as the rectangles where they connect with their respective 
variables gadgets.

123456789abcdefghijk(a)123456789fdehijkg(b)av1v2bv2c12

Proof. We use the same reduction from Planar 3-SAT, but with three main
variations in the gadgets: we drop the green rectangles of both the variable and
clause gadgets, add points within the redundant and connection region of both
variable and clause gadgets, and separate the rectangles numbered 5 and 6 of
each clause gadget so they do not intersect (see Figure 9 for an example). Since

Fig. 9. a) The instance of the Box Cover problem corresponding to ϕ = (v1∨
v2 ∨ v3). b) The intersection graph of the instance: the vertices corresponding
to the legs have degree 3, which is the highest; there are no 3-cliques in the
graph; and the graph is planar and can be drawn within the planar embedding
of ϕ (highlighted with dashed lines).

the interior of every connection or redundant region is covered by at most two of
the rectangles in the gadgets, every point of the instance we create is contained
in at most two boxes. In Figure 9.b we illustrate the intersection graph for the
clause ϕ = (v1 ∨ v2 ∨ v3). Since the sign of the variables in the clause does not
change the maximum vertex degree or the clique-number of the graph, or its
planarity, the properties we mention next are also true for any clause. Note that
three is the maximum vertex-degree of the intersection graph, and that there
are no 3-cliques. Also note that the intersection graph can be drawn within the
planar embedding of ϕ so that no two edges cross, and hence the graph is planar.
Again, due to the pairwise independence of the clause gadgets, these properties
(cid:117)(cid:116)
extend to the entire intersection graph of a general instance.

In the next section, we complement these hardness results with two approximation 
algorithms for the Minimum Coverage Kernel problem.

v2134567892v1v2v3(a)(b)123456789v1v313

4 Eﬃcient approximation of Minimum Coverage Kernels
Let B be a set of n boxes in Rd, and let D(B) be a coverage discretization of B
(as deﬁned in Section 2). A weight index for D(B) is a data structure which can
perform the following operations:
– Initialization: Assign an initial unitary weight to every point in D(B);
– Query: Given a box b ∈ B, ﬁnd the total weight of the points in b.
– Update: Given a box b ∈ B, multiply the weights of all the points within b

by a given value α ≥ 0;

We assume that the weights are small enough so that arithmetic operations over
the weights can be performed in constant time. There is a trivial implementation
of a weight index with initialization and update time within O(nd), and with
constant query time. In this section we describe an eﬃcient implementation of a
weight index, and combine this data structure with two existing approximation
algorithms for the Box Cover problem [16, 5] and obtain improved approximation 
algorithms (in the running time sense) for the Minimum Coverage
Kernel problem.

4.1 An Eﬃcient Weight Index for a Set of Boxes
We describe a weight index for D(B) which can be initialized in time within
O(n
log n). Let us consider
ﬁrst the case of a set I of n intervals.

2 ), and with query and update time within O(n

d+1

d−1

2

A weight index for a set of intervals. A trivial weight index which explicitly 
saves the weights of each point in D(I) can be initialized in time within
O(n log n), has linear update time, and constant query time. We show that by
sacriﬁcing query time (by a factor within O(log n)) one can improve update time
to within O(log n). The main idea is to maintain the weights of each point of
D(I) indirectly using a tree.
Consider a balanced binary tree whose leafs are in one-to-one correspondence
with the values in D(I) (from left to right in a non-decreasing order). Let pv
denote the point corresponding to a leaf node v of the tree. In order to represent
the weights of the points in D(I), we store a value µ(v) at each node v of the tree
subject to the following invariant: for each leaf v, the weight of the point pv equals
the product of the values µ(u) of all the ancestors u of v (including v itself). The
µ values allow to increase the weights of many points with only a few changes. For
instance, if we want to double the weights of all the points we simply multiply by
2 the value µ(r) of the root r of the tree. Besides the µ values, to allow eﬃcient
query time we also store at each node v three values min(v), max(v), ω(v): the
values min(v) and max(v) are the minimum and maximum pu, respectively, such
that u is a leaf of the tree rooted at v; the value ω(v) is the sum of the weights
of all pu such that u is a leaf of the tree rooted at v.

Initially, all the µ values are set to one. Besides, for every leaf l of the tree ω(l)
is set to one, while min(l) and max(l) are set to pl. The min, max and ω values

14

of every internal node v with children l, r, are initialized in a bottom-up fashion
as follows: min(v) = min{min(l), min(r)}; max(v) = max{max(l), max(r)};
ω(v) = µ(v)· (ω(l) + ω(r)). It is simple to verify that after this initialization, the
tree meets all the invariants mentioned above. We show in Theorem 3 that this
tree can be used as a weight index for D(I).
Theorem 3. Let I be a set of n intervals in R. There exists a weight index
for D(I) which can be initialized in time within O(n log n), and with query and
update time within O(log n).
Proof. Since intervals have linear union complexity, D(I) has within O(n) points,
and it can be computed in linear time after sorting, for a total time within
O(n log n). We store the points in the tree described above. Its initialization
can be done in linear time since the tree has within O(n) nodes, and when
implemented in a bottom-up fashion, the initialization of the µ, ω, min, and
max values, respectively, cost constant time per node.

To analyze the query time, let totalWeight(a, b, t) denote the procedure which
ﬁnds the total weight of the points corresponding to leafs of the tree rooted at
t that are in the interval [a, b]. This procedure can be implemented as follows:

1. if [a, b] is disjoint to [min(t), max(t)] return 0;
2. if [a, b] completely contains [min(t), max(t)] return ω(r);
3. if both conditions fail (leafs must meet either 1. or 2.), let l, r be the left and
4. if a > max(l) return µ(t) · totalWeight(a, b, r);
5. if b < min(r) return µ(t) · totalWeight(a, b, l);
6. otherwise return µ(t)(totalWeight(a,∞, l) + totalWeight(−∞, b, r)).

right child of t, respectively;

Due to the invariants to which the min and max values are subjected, every leaf
l of t corresponding to a point in [a, b] has an ancestor (including l itself) which
is visited during the call to totalWeight and which meets the condition in step 2.
For this, and because of the invariants to which the ω and µ values are subjected,
the procedure totalWeight is correct. Note that the number of nodes visited is
at most 4 times the height h of the tree: when both children need to be visited,
one of the endpoints of the interval to query is replaced by ±∞, which ensures
that in subsequent calls at least one of the children is completely covered by the
query interval. Since h ∈ O(log n), and the operations at each node consume
constant time, the running time of totalWeight is within O(log n).

Similarly, to analyze the update time, let updateWeights(a, b, t, α) denote the
procedure which multiplies by a value α the weights of the points in the interval
[a, b] stored in leafs descending from t. This can be implemented as follows:

1. if [a, b] is disjoint to [min(t), max(t)], ﬁnish;
2. if [a, b] completely contains [min(t), max(t)] set µ(r) = α · µ(r), set ω(r) =

α · ω(r), and ﬁnish;

3. if both conditions fail, let l, r be the left and right child of t, respectively;
4. if a > max(l), call updateWeights(a, b, r, α);

15

Fig. 10. (a) An illustration in the plane of three boxes equivalent to slabs
when restricted to the box Γ . The dots correspond to a set of points which
discretize the (grayed) region within Γ covered by the slabs.

5. else if b < min(r), call updateWeights(a, b, l, α);
6. otherwise, call updateWeights(a,∞, l, α), and updateWeights(−∞, b, r, α);
7. ﬁnally, after the recursive calls set ω(t) = µ(t) · (ω(l) + ω(r)), and ﬁnish.

Note that, for every point pv in [a, b] corresponding to a leaf v descending from
t, the µ value of exactly one of the ancestors of u changes (by a factor of α): at
least one changes because of the invariants to which the min and max values
are subjected (as analyzed for totalWeight); and no more than one can change
because once µ is assigned for the ﬁrst time to some ancestor u of v, the procedure
ﬁnishes leaving the descendants of v untouched. The analysis of the running time
is analogous to that of totalWeight, and thus within O(log n).
(cid:117)(cid:116)

The weight index for set of intervals described in Theorem 3 plays an important 
role in obtaining an index for a higher dimensional set of boxes. In a step
towards that, we ﬁrst describe how to use one dimensional indexes to obtain
indexes for another special case of sets of boxes, this time in high dimension.

A weight index for a set of slabs. A box b is said to be a slab within
another box Γ if b covers completely Γ in all but one dimension (see Figure 10.a
for an illustration). Let B be a set of n d-dimensional boxes that are slabs within
another box d-dimensional box Γ . Let B|Γ denote the set {b ∩ Γ | b ∈ B} of
the boxes ∈ B restricted to Γ . We describe a weight index for D(B|Γ ) with
initialization time within the size n, and with update and query time within
O(n log n).
For all i = [1..d], let Bi be the subset of slabs that are orthogonal to the i-th
dimension, and let Ii be the set of intervals resulting from projecting Γ and each
rectangle in B|Γ to the i-th dimension (see Figure 10.b for an illustration). The
key to obtain an eﬃcient weight index for a set of slabs is the fact that weight
indexes for D(I1), . . .D(Id) can be combined without much extra computational
eﬀort into a weight index for D(B|Γ ). Let p be a point D(B|Γ ) and let xi(p) denote
the value of the i-th coordinate of p. Observe that for all i ∈ [1..d], xi(p) ∈ D(Ii)
(see Figure 10.b for an illustration). This allows the representation of the weight

b2Γ(a)(b)b3Γb1x1x216

of each point p ∈ D(B) by means of the weights of xi(p) for all i ∈ [1..d]. We
do this by maintaining the following weight invariant: the weight of a point

p ∈ D(B|Γ ) is equal to(cid:81)d

i=1 (weight of xi(p) in D(Ii)).

Lemma 4. Let B be a set of n d-dimensional boxes that are equivalent to slabs
when restricted to another d-dimensional box Γ . There exists a weight index
for D(B) which can be initialized in time within O(n log n), and with query and
update time within O(log n).
Proof. Let Bi be the subset of B|Γ orthogonal to the i-th dimension, and let Ii
be the set of intervals resulting from projecting Γ and each rectangle in Bi to
the i-th dimension. Initialize a weight index for D(Ii) as in Theorem 3, for all
i ∈ [1..d]. Since the weights of all the points in the one dimensional indexes are
initialized to one, the weight of every point in D(B|Γ ) is also initialized to one,
according to the weight invariant. This initialization can be done in total time
within O(n log n).
Let b ∈ B|Γ be a box which covers Γ in every dimension except for the
i-th one, for some i ∈ [1..d] (i.e., b ∈ Bi), and let Pi bet the subset of D(Ii)
contained within the projection of b to the i-th dimension. The set of points of
D(B|Γ ) that are within b can be generated by the expression {(a1, . . . , ad) | a1 ∈
D(I1) ∧ . . . ∧ ai−1 ∈ D(Ii−1) ∧ ai ∈ Pi ∧ ai+1 ∈ D(Ii+1) ∧ . . . ∧ ad ∈ D(Id)}.
Therefore, the total weight of the points within b is given by the total weight
of the points xi(p) for all p ∈ Pi multiplied by the total weight of the points in
D(Ij), for all j = [1..d] distinct from i.
To query the total weight of the points of D(B|Γ ) within a box b ∈ Bi we
query the weight index of D(Ii) to ﬁnd the total weight of the points in the
projection of b to the i-th dimension (in time within O(log n)), then query the
remaining d − 1 indexes to ﬁnd the total weight store in the index (stored at
the ω value of the root of the trees), and return the product of those d values.
Clearly the running time is within O(log n).
The update is similar: to multiply by a value α the weight of all the points
of D(B|Γ ) within a box b ∈ Bi we simply update the weight index of D(Ii)
multiplying by α all the weights of the points within the projection of b to the
i-th dimension, and leave the other d− 1 weight indexes untouched. The running
time of this operation is also within O(n log n), and the invariant remains valid
(cid:117)(cid:116)
after the update.
Lemma 4 shows that there are weight indexes for a set of slabs B within
another box Γ that signiﬁcantly improve the approach of explicitly constructing
D(B|Γ ), an improvement that grows exponentially with the dimension d. We
take advantage of this to describe a similar improvement for the general case.

A Weight Index for The General Case. We now show how to maintain
a weight index of a general set B of d-dimensional boxes. The main idea is to
partition the space into cells such that, within each cell c, any box b ∈ B either
completely contains c or is equivalent to a slab. Then, we use weight indexes
for slabs (as described in Lemma 4) to index the weights within each of the

17

cells. This approach was ﬁrst introduced by Overmars and Yap [18] in order to
compute the volume of the region covered by a set boxes, and similar variants
were used since then to compute other measures [4, 6, 20]. The following lemma
summarizes the key properties of the partition we use:
Lemma 5 (Lemma 4.2 of Overmars and Yap [18]). Let B be a set of n
boxes in d-dimensional space. There exist a binary partition tree for storing any
subset of B such that
– It can be computed in time within O(nd/2), and it has O(n d
– Each box is stored in O(n
d−1
2 ) leafs;
√
– The boxes stored in a leaf are slabs within the cell corresponding to the node;
– Each leaf stores no more than O(

2 ) nodes;

n) boxes.

Consider the tree of Lemma 5. Analogously to the case of intervals, we augment 
this tree with information to support the operations of a weight index
eﬃciently. At every node v we store two values µ(v), ω(v): the ﬁrst allows to
multiply all the weights of the points of D(B) that are maintained in leafs descending 
from v (allowing to support updates eﬃciently); while ω(v) stores the
total weight of these points (allowing to support queries eﬃciently). To ensure
that all/only the nodes that intersect a box b are visited during a query or update 
operation, we store at each node the boundaries of the cell corresponding to
that node. Furthermore, at every leaf node l we implicitly represent the points
of D(B) that are inside the cell corresponding to l using a weight index for slabs.
To initialize this data structure, all the µ values are set to one. Then the
weight index within each leaf cell are initialized. Finally, the ω values of every
node v with children l, r, are initialized in a bottom-up fashion setting ω(v) =
µ(v) · (ω(l) + ω(r)). We show in Theorem 6 how to implement the weight index
operations over this tree and we analyze its running times.
Theorem 6. Let B be a set of n d-dimensional boxes. There is a weight index
for D(B) which can be initialized in time within O(n
d+1
2 ), and with query and
update time within O(n

log n).

d−1

2

Proof. The initialization of the index, when implemented as described before,
√
runs in constant time for each internal node of the tree, and in time within
O(
n log n) for each leaf (due to Lemma 4, and to the last item of Lemma 5).
Since the tree has O(n d
2 ) nodes, the total running time of the initialization is
within O(n

log n).

d+1

2

Since the implementations of the query and update operations are analogous
to those for the intervals weight index (see the proof of Theorem 3), we omit
the details of their correctness. While performing a query/update operation at
most O(n
d−1
2 ) leafs are visited (due to the third item of Lemma 5), and since the
height of the tree is within O(log n), at most O(n
log n) internal nodes are
visited in total. Hence, the cost of a query/update operation within each leaf is
within O(log n) (by Lemma 4), and is constant within each internal node. Thus,
(cid:117)(cid:116)
the total running of a query/update operation is within O(n

log n).

d−1

d−1

2

2

18

4.2 Practical approximation algorithms for Minimum Coverage

Kernel.

Approximating the Minimum Coverage Kernel of a set B of boxes via approximation 
algorithms for the Box Cover problem requires that D(B) is explicitly 
constructed. However, the weight index described in the proof of Theorem 
6 can be used to signiﬁcantly improve the running time of these algorithms.
We describe below two examples.
The ﬁrst algorithm we consider is the greedy O(log n)-approximation algorithm 
by Lov´asz [16]. The greedy strategy applies naturally to the Minimum
Coverage Kernel problem: iteratively pick the box which covers the most
yet uncovered points of D(B), until there are no points of D(B) left to cover. To
avoid the explicit construction of D(B) three operations most be simulated: (i.)
ﬁnd how many uncovered points are within a given a box b ∈ B; (ii.) delete the
points that are covered by a box b ∈ B; and (iii.) ﬁnd whether a subset B(cid:48) of B
covers all the points of D(B).
For the ﬁrst two we use the weight index described in the proof of Theorem 6:
to delete the points within a given box b ∈ B we simply multiply the weights of all
the points of D(B) within b by α = 0; and ﬁnding the number of uncovered points
within a box b is equivalent to ﬁnding the total weight of the points of D(B)
within b. For the last of the three operations we use the following observation:
Observation 1 Let B be a set of d-dimensional boxes, and let B(cid:48) be a subset of
B. The volume of the region covered by B(cid:48) equals that of B if and only if B(cid:48) and
B cover the exact same region.
Let OPT denote the size of a minimum coverage kernel of B, and let N denote the
size of D(B) (N ∈ O(nd)). The greedy algorithm of Lov´asz [16], when run over
the sets B and D(B) works in O(OPT log N ) steps; and at each stage a box is added
to the solution. The size of the output is within O(OPT log N ) ⊆ O(OPT log n).
This algorithm can be modiﬁed to achieve the following running time, while
achieving the same approximation ratio:
Theorem 7. Let B be a set of n boxes in Rd with a minimum coverage kernel
of size OPT. Then, a Coverage Kernel of B of size within O(OPT log n) can
be computed in time within O(OPT · n d

2 +1 log2 n).

d+1

Proof. We initialize a weight index as in Theorem 6, which can be done in time
O(n
2 ), and compute the volume of the region covered by B, which can be
done in time within O(nd/2) [6]. Let C be an empty set. At each stage of the
algorithm, for every box b ∈ B \ C we compute the total weight of the points
log n using the weight index).
inside b (which can be done in time within n
We add to C the box with the highest total weight, and update the weights of
all the points within this box to zero (by multiplying their weights by α = 0)
in time within n
log n. If the volume of the region covered by C (which can
be computed in O(nd/2)-time [6]) is the same as that of B, then we stop and
return C as the approximated solution. The total running time of each stage

d−1

2

d−1

2

19

is within O(n
O(OPT log n) yield the result of the theorem.

d+1

2

2k -heavy: ﬁnd a 1

log n). This, and the fact that the number of stages is within
(cid:117)(cid:116)
Now, we show how to improve Br¨onnimann and Goodrich’s O(log OPT) approximation 
algorithm [5] via a weight index. First, we describe their main idea.
Let w : D(B) → R be a weight function for the points of D(B), and for a subset
P ⊆ D(B) let w(P ) denote the total weight of the points in P. A point p is said
to be ε-heavy, for a value ε ∈ (0, 1], if w(p) ≥ εw(D(B)), and ε-light otherwise.
A subset B(cid:48) ⊆ B is said to be an ε-net with respect to w if for every ε-heavy
point p ∈ D(B) there is a box in B(cid:48) which contains p. Let OPT denote the size of a
minimum coverage kernel of B, and let k be an integer such that k/2 ≤ OPT < k.
The algorithm initializes the weight of each point in D(B) to 1, and repeats
the following weight-doubling step until every range is 1
2k -light
point p and double the weights of all the points within every box b ∈ B. When
this process stops, it returns a 1
2k -net C with respect to the ﬁnal weights as the
approximated solution.
Since each point in D(B) is 1
2k -heavy, C covers all the points of D(B). Hence,
2k -net of size O(kg(k)) can be computed eﬃciently, this algorithm computes
if a 1
a solution of size O(kg(k)). Besides, Br¨onnimann and Goodrich [5] showed that
for a given k, if more than µk = 4k log(n/k) weight-doubling steps are performed,
then OPT > 2k. This allows to guess the correct k via exponential search, and to
bound the maximum weight of any point by n4/k3 (which allows to represent
the weights with O(log n) bits). See Br¨onnimann and Goodrich’s article [5] for
the complete details of their approach.
We simulate the operations over the weights of D(B) again using a weight
index, this time with a minor variation to that of Theorem 6: in every node of the
space partition tree, besides the ω, µ values, we also store the minimum weight of
the points within the cell corresponding to the node. During the initialization and
update operations of the weight index this value can be maintained as follows:
for a node v with children l, r, the minimum weight minω(v) of a point in the cell
of v can be computed as minω(v) = ω(v) · min{minω(l), minω(r)}. This value
allows to eﬃciently detect whether there are 1
2k -light points, and to ﬁnd one in
the case of existence by tracing down, in the partition tree, the path from which
that value comes.
2k -net, we choose a sample of B by performing at least
(16k log 16k) random independent draws from B. We then check whether it is
eﬀectively a 1
2k -net, and if not, we repeat the process, up to a maximum of
O(log n) times. Haussler and Welzl [12] showed that such a sample is a 1
2k -net
with probability at least 1/2. Thus, the expected number of samples needed to
2k -net is constant, and since we repeat the process up to O(log n) times,
obtain a 1
the probability of eﬀectively ﬁnding one is at least 1 − 1
nΩ(1) . We analyze the
running time of this approach in the following theorem.
Theorem 8. Let B be a set of n boxes in Rd with a minimum coverage kernel of
size OPT. A coverage kernel of B of size within O(OPT log OPT) can be computed
in O(OPTn

log2 n)-expected time, with probability at least 1 − 1

To compute a 1

d+1

2

nΩ(1) .

20

Proof. The algorithm performs several stages guessing the value of k. Within
each stage we initialize a weight index in time within O(n
2 ). Finding whether
there is a 1
2k -light point can be done in constant time: the root of the partition
tree stores both w(D(B)) and the minimum weight of any point in the ω and
minω values, respectively. For every light point, the weight-doubling steps conlog 
n) (by Theorem 6). Since

sume time within O(cid:16)

(cid:17)(cid:17) ⊆ O(n

n ×(cid:16)

log n

d−1

d+1

n

2

d+1

2

at each stage at most 4k log(n/k) weight-doubling steps are performed, the total
running time of each stage is within O(kn
log2 n).
Given that k increases geometrically while guessing its right value, and since
the running time of each stage is a polynomial function, the sum of the running
times of all the stages is asymptotically dominated by that of the last stage, for
which we have that k ≤ OPT ≤ 2k. Thus the result of the theorem follows.
(cid:117)(cid:116)

k ) ⊆ O(kn

log n log n

d+1

d+1

2

2

Compared to the algorithm of Theorem 7, this last approach obtains a better
approximation factor on instances with small Coverage Kernels (O(log n)
vs. O(log OPT)), but the improvement comes with a sacriﬁce, not only in the
running time, but in the probability of ﬁnding such a good approximation. In
two and three dimensions, weight indexes might also help to obtain practical
O(log log OPT) approximation algorithms for the Minimum Coverage Problem.
 We discuss this, and other future directions of research in the next section.

5 Discussion

Whether it is possible to close the gap between the factors of approximation of
Box Cover and Orthogonal Polygon Covering has been a long standing
open question [14]. The Minimum Coverage Kernel problem, intermediate
between those two, has the potential of yielding answers in that direction, and has
natural applications of its own [9, 15, 19]. Trying to understand the diﬀerences
in hardness between these problems we studied distinct restricted settings. We
show that while Minimum Coverage Kernel remains NP-hard under severely
restricted settings, the same can be said for the Box Cover problem under even
more extreme settings; and show that while the Box Cover and Minimum
Coverage Kernel can be approximated by at least the same factors, the
running time of obtaining some of those approximations can be signiﬁcantly
improved for the Minimum Coverage Kernel problem.

Another approach to understand what makes a problem hard is Parameterized 
Complexity [10], where the hardness of a problem is analyzed with respect
to multiple parameters of the input, with the hope of ﬁnding measures gradually
separating “easy” instances form the “hard” ones. The hardness results described
in Section 3 show that for the Minimum Coverage Kernel and Box Cover
problems, the vertex-degree and clique-number of the underlaying graph are not
good candidates of such kind of measures, opposed to what happens for other
related problems [2].
In two and three dimensions, the Box Cover problem can be approximated
up to O(log log OPT) [3]. We do not know whether the running time of this algoREFERENCES


21

rithm can be also improved for the case of Minimum Coverage Kernel via
a weight index. We omit this analysis since the approach described in Section 4
is relevant when the dimension of the boxes is high (while still constant), as in
distinct applications [9, 15, 19] of the Minimum Coverage Kernel problem.

References

[1] P. K. Agarwal and J. Pan. “Near-Linear Algorithms for Geometric Hitting 
Sets and Set Covers”. In: Proceedings of the 30th Annual Symposium
on Computational Geometry (SoCG). New York, NY, USA: ACM, 2014,
271:271–271:279.

[2] V. E. Alekseev, R. Boliac, D. V. Korobitsyn, and V. V. Lozin. “NP-hard
graph problems and boundary classes of graphs”. In: Theoretical Computer
Science (TCS) 389.1-2 (2007), pp. 219–236.

[3] B. Aronov, E. Ezra, and M. Sharir. “Small-Size ε-Nets for Axis-Parallel
Rectangles and Boxes”. In: SIAM Journal on Computing (SICOMP) 39.7
(2010), pp. 3248–3282.

[4] J. Barbay, P. P´erez-Lantero, and J. Rojas-Ledesma. “Depth Distribution
in High Dimensions”. In: Proceedings of the 23rd International Conference
on Computing and Combinatorics (COCOON), 2017, Hong Kong, China.
Vol. 10392. Lecture Notes in Computer Science. Springer, 2017, pp. 38–49.
[5] H. Br¨onnimann and M. T. Goodrich. “Almost Optimal Set Covers in Finite 
VC-Dimension”. In: Discrete & Computational Geometry (DCG) 14.4
(1995), pp. 463–479.

[6] T. M. Chan. “Klee’s Measure Problem Made Easy”. In: 54th Annual IEEE
Symposium on Foundations of Computer Science (FOCS), Berkeley, CA,
USA, 26-29 October, 2013. IEEE Computer Society, 2013, pp. 410–419.

[7] K. L. Clarkson and K. R. Varadarajan. “Improved Approximation Algorithms 
for Geometric Set Cover”. In: Discrete & Computational Geometry
(DCG) 37.1 (2007), pp. 43–58.

[8] J. C. Culberson and R. A. Reckhow. “Covering Polygons Is Hard”. In:

Journal of Algorithms (JALG) 17.1 (1994), pp. 2–44.

[9] J. Daly, A. X. Liu, and E. Torng. “A Diﬀerence Resolution Approach
to Compressing Access Control Lists”. In: IEEE/ACM Transactions on
Networking (TON) 24.1 (2016), pp. 610–623.

[10] R. G. Downey and M. R. Fellows. Parameterized Complexity. Monographs

in Computer Science. Springer, 1999.

[11] R. J. Fowler, M. Paterson, and S. L. Tanimoto. “Optimal Packing and Covering 
in the Plane are NP-Complete”. In: Information Processing Letters
(IPL) 12.3 (1981), pp. 133–137.

[12] D. Haussler and E. Welzl. “ε-Nets and Simplex Range Queries”. In: Discrete 
& Computational Geometry 2 (1987), pp. 127–151.

[13] D. E. Knuth and A. Raghunathan. “The Problem of Compatible Repre-

sentatives”. In: SIAM Journal on Discrete Mathematics 5.3 (1992).

22

REFERENCES

[14] V. S. A. Kumar and H. Ramesh. “Covering Rectilinear Polygons with
Axis-Parallel Rectangles”. In: SIAM Journal on Computing (SICOMP)
32.6 (2003), pp. 1509–1541.

[15] L. V. S. Lakshmanan, R. T. Ng, C. X. Wang, X. Zhou, and T. Johnson.
“The Generalized MDL Approach for Summarization”. In: Proceedings of
28th International Conference on Very Large Data Bases (VLDB), August
20-23, 2002, Hong Kong, China. Morgan Kaufmann, 2002, pp. 766–777.

[16] L. Lov´asz. “On the ratio of optimal integral and fractional covers”. In:

Discrete Mathematics (DM) 13.4 (1975), pp. 383–390.

[17] W. Mulzer and G. Rote. “Minimum-weight triangulation is NP-hard”. In:

Journal of the ACM (JACM) 55.2 (2008).

[18] M. H. Overmars and C. Yap. “New Upper Bounds in Klee’s Measure Prob-

lem”. In: SIAM Journal on Computing (SICOMP) 20.6 (1991).

[19] K. Q. Pu and A. O. Mendelzon. “Concise descriptions of subsets of structured 
sets”. In: ACM Transactions on Database Systems (TODS) 30.1
(2005), pp. 211–248.

[20] H. Yildiz, J. Hershberger, and S. Suri. “A Discrete and Dynamic Version
of Klee’s Measure Problem”. In: Proceedings of the 23rd Annual Canadian 
Conference on Computational Geometry (CCCG), Toronto, Ontario,
Canada, August 10-12, 2011. 2011.

