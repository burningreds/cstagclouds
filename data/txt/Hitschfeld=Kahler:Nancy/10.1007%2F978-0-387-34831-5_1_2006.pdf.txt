A  Meshing  Tool  Product  Line  Architecture 

Maria  Cecilia  Bastarrica-'^,  Nancy  Hitschfeld-Kahler-'-,  Pedro  O.  Rossel^'^ 

^  Computer  Science  Department,  FCFM,  Universidad  de  Ciiile 

Blanco  Encalada  2120, Santiago,  Chile 

Departamento  de  Computacion  e Informatica,  Universidad  Catolica  del  Maule 

2 

Avenida  San  Miguel  3605, Talca,  Chile 

{cecilialnancy IprosselJQdcc  .ucliile.cl 

Abstract.  Meshing  tools  are  extremely  complex  pieces  of  software. 
Traditionally,  they  have  been  built  in  a  one  by  one  basis,  without  sys(cid:173)
tematically  reusing  already  developed  parts.  The  area  has  matured  so 
that  we  can  currently  think  of  building  meshing  tools  in  a  more  in(cid:173)
dustrial  manner.  Software  product  lines  is  a  trend  in  software  devel(cid:173)
opment  that  promotes  systematic  reuse. We propose  a  layered  product 
line architecture  for  meshing  tools  that  can  be  instantiated  with  differ(cid:173)
ent  algorithms,  ways of implementing  basic  concepts,  and  even  for  two 
or  three  dimensional  meshing  tools. We specify  it  formally  using  xADL 
and we show that  the architecture  is compatible with  a series of already 
built  tools.  This  work  is  the  beginning  of  a  domain  analysis  that  has 
the  potential  to  go  beyond  the  sometimes  rigid  descriptions  provided 
by  architectural  description  languages. 

1  Introduction 

Meshes  are  used  for  numerical  modeling,  visualizing  and/or  simulating  objects 
or  phenomena.  A  mesh  is  a  discretization  of  a  certain  domain  geometry.  This 
discretization  can  be  either  composed  by  a  unique  type  of  element,  such  as  tri(cid:173)
angles, tetrahedra  or  hexahedra,  or  a  combination  of different  types  of elements. 
Meshing  tools  generate  and  manage  these  discretizations. 

Meshing  tools  are  inherently  sophisticated  software  due  to  the  complexity 
of  the  concepts  involved,  the  large  number  of  interacting  elements  they  man(cid:173)
age,  and  the  application  domains  where  they  are  used.  Meshing  tools  need  to 
accompUsh  specific  functionality  while  still  having  an  acceptable  performance. 
Managing  thousands  and  even  millions  of  elements  with  a  reasonable  use  of 
computational  resources  -mainly  processor  time  and  storagebecomes 
 a  must 
if  the  tool  is  to  be  usable  at  all.  Lately,  however,  other  qualities  related  to 
modifiability  have  become  relevant  in  meshing  tool  development. 

There  are  many  application  domains  where  meshing  tools  are  used,  ranging 
from  mechanics  design  to  medicine  [12]. Each  domain  requires  slightly  different 
functionality.  For this reason,  a variety  of meshing tools have been built  differing 
on  the  functionality  included,  the  algorithms  used  for  implementing  their  func(cid:173)
tionality,  the  way  data  is represented,  or  the  format  of the  data  used  as input  or 

Please  use the following  format  when  citing  this  chapter: 

Bastarrica,  M.C.,  Hitschfeld-Kahler,  N.,  Rossel,  P.O.,  2006,  in  IFIP  International  Federation  for  Infor(cid:173)
mation  Processing,  Volume  219, Advanced  Software  Engineering:  Expanding  the  Frontiers  of  Software 
Technology,  eds. Ochoa,  S., Roman,  G.-C,  (Boston:  Springer), pp.  1-15. 

2 

Bastarrica  et  al. 

output.  Also  depending  on  the  application  domain,  it  may  be  required  to  have 
one,  two  or  three  dimensional  meshes,  each  one  maybe  using  different 
types 
of  basic  modeling  elements.  For  example,  analyzing  the  tree  rings  requires  2D 
meshes  generated  from  an  image,  simulating  tree  growth  uses  surface  meshes, 
and  modeling  brain  shift  during  surgery  requires  3D  meshes. 

Developing  any complex software  from  scratch  in a one by one basis is expen(cid:173)
sive,  slow  and  error  prone,  but  this  is the  way  meshing  tools  have  traditionally 
been  built.  If  this  development  task  is  not  performed  in  a  systematic  way  using 
good  software  engineering  practices,  it  may  easily  get  out  of  control  making  it 
almost  impossible  to  debug  and  even  more  difficult  to  modify.  There  have  been 
some  efforts  lately  applying  software  engineering  concepts  in  meshing  tool  de(cid:173)
velopment,  mainly  building  general  purpose  libraries  that  facilitate  reuse.  Also 
object-orientation  and  design  patterns  have  the  potential  of enhancing  software 
reuse  at  the  code  and  design  levels,  and  there  is some  experience  in  using  these 
techniques  for  developing  meshing  tools. 

The  software  architecture  is  one  of  the  main  artifacts  developed  during  the 
software  life  cycle  [15] because  it  determines  most  of the  non-functional  charac(cid:173)
teristics  the  resulting  software  will  have,  and  it  is  also  one  of  the  most  difficult 
documents  to change  once the software  is deployed  [2]. Architectural  patterns  [7] 
are  used  as  guidelines  for  architectural  design  by  reusing  design  knowledge  at 
a  high  level  of  abstraction.  Different  architectural  patterns  promote  different 
non-functional  characteristics.  In  this  way,  for  example,  by  using  component 
and  connector  patterns  such  as  client-server  or  repository,  runtime  properties 
can  be  modeled.  Or  using  module  patterns  such  as  decomposition  or  layers, 
properties  related  to  maintainability  can  be  modeled  [8]. 

Software  product  lines  is  a  trend  for  planned  massive  reuse  of  software  as(cid:173)
sets  [9]. The  most  typical  reusable  assets  are  software  components,  but  we  can 
also reuse  the  product  line  architecture  (PLA),  software  requirement  documen(cid:173)
tation,  and  test  cases,  among  others.  The  PLA  is  an  important  reusable  asset 
because  all  software  products  in  the  family  share  the  same  design  [6].  There(cid:173)
fore,  the  PLA  design  should  be carefully  approached  making sure it will  produce 
software  that  complies  with  the  desired  requirements. 

In  this  paper  we  present  the  product  line  architecture  for  a  family  of  mesh(cid:173)

ing  tools.  Its  design  is  based  on  the  general  architecture  of  pubHshed  meshing 
products,  as  well  as  our  own  experience  in  building  this  type  of  tools.  We  in(cid:173)
tended  to  provide  a  PLA  that  would  promote  flexibility  and  extensibility,  so 
that  existing  algorithms,  data  structures,  data  formats  and  visualizers  could  be 
combined  in  different  ways  to  produce  a  variety  of  meshing  tools  appropriate 
for  diverse  application  domains,  sharing  the  software  structure.  The  PLA  is 
modeled  following  the  layered  architectural  pattern  [7]. This  module  view  type 
is  used  for  promoting  modifiability,  reusability  and  portabihty.  Sometimes  it  is 
argued  that  layered  architectures  may  penalize  performance,  but  we have  found 
that  performance  does  not  necessarily  degrade  significantly  using  the  proposed 
PLA  [19]. In  [17]  it  is  reported  that  a  tool  implementing  this  layered  architecA 
 Meshing  Tool PLA 

3 

ture  performs  almost  as  fast  as  TetGen  [26], a  widely  used  open  source  meshing 
tool. 

We  formally  define  the  PLA  using  xADL  2.0,  an  XML-based  ADL  specially 
designed  to  support  the  description  of  architectures  as  explicit  collections  of 
components  and  connectors  [18].  There  are  graphical  tools  that  make  it  eas(cid:173)
ier  to  specify  software  architectures  using  xADL.  xADL  has  also  shown  to  be 
appropriate  to  specify  product  lines  architectures  [10]. 

We show  how the  proposed  PLA  can  be  instantiated  for  generating  different 
meshing tools. In particular  we show  how  already  implemented  tools can be  seen 
as  instantiations  of  our  product  family,  independently  of  the  methods  followed 
for  generating  the  meshes  and  the  dimensions  of  the  managed  mesh. 

The  paper  is  structured  as  follows.  In  Section  2  we  present  and  discuss 
concepts  such  as software  architecture  and  software  product  lines  and  how  they 
have  been  used  in  the  development  of  meshing  tools.  We  also  present  some 
efforts  in  developing  meshing  tools.  Section  3  presents  the  proposed  layered 
architecture  for  our  product  family  of  meshing  tools,  and  Section  4  shows  a 
series  of  different  instantiations  of this  PLA  to  produce  different  meshing  tools. 
Finally,  in  Section  5  we  present  some  conclusions  and  describe  our  work  in 
progress. 

2  Related  Work 

There  is  a  variety  of  meshing  tools  developed  for  different  purposes  [25].  How(cid:173)
ever, the  use of software  engineering  principles  in meshing tool design  has  spread 
only in the  last five years. Some examples  include the design of generic  extensible 
geometry  interfaces  between  CAD  modelers  and  mesh  generators  [21,23,27,30], 
the  design  of  object-oriented  data  structures  and  procedural  classes  for  mesh 
generation  [22], and  the  computational  geometry  algorithm  library  CGAL  [14]. 
Also recently  it  was  publish  a  discussion  on  the  usage of  formal  methods  for  im(cid:173)
proving reliability  of meshing  software  [13]. There  have also been  some  attempts 
in  using  software  product  family  concepts  for  building  meshing  tools  [3,28]. 

Software  product  lines  (SPL)  is  a  modern  approach  towards  software  de(cid:173)
velopment  based  on  planned  massive  reuse.  The  idea  is  to  provide  a  reuse  in(cid:173)
frastructure  that  supports  a  family  of  products,  and  to  spend  the  resources  in 
such  a  way  that  a  high  return  of  investment  and  reduce  time-to-market  can  be 
achieved  [29]. All elements subject  to  reuse  are  called  core  assets of the  SPL.  So, 
an  SPL  is a  set  of products  that  are  built  using  core  assets  in  a  planned  manner 
and  that  satisfy  the  needs  of  a  market  segment  [9]. One  of  the  most  important 
assets  in  a SPL  is the  product  line  architecture  (PLA).  Opportunistic  reuse  does 
not  usually  work  [6]; thus,  assets  in  a  SPL  should  be  developed  in  such  a  way 
that  reuse  is promoted.  This  development  process  is longer  and  more  expensive 
than  developing  one  product  at  a  time,  but  if assets  are  reused  enough  times,  it 
is still  cost-effective.  Experience  has shown  that  the  costs of developing  reusable 
assets  is paid  off  after  the  second  or  third  product  is built  [33]. The  strategy  for 

4 

Bastarrica  et  al. 

building  software  product  lines  is  to  identify  commonalities,  variabilities  and 
optional  modules. 

To  our  knowledge,  SPL  has  neither  been  widely  used  as  an  approach  for 
developing  meshing  tools,  nor  have  architectural  patterns  been  considered  as 
a  basis  for  designing  any  particular  meshing  tool  architecture.  Product  line 
architectures  must,  by  definition,  be  flexible  to  foster  all  products  in  the  SPL, 
and  promote  modifiability  so that  variabilities  could be incorporated.  Therefore, 
it  results  natural  to  use  module  view  type  patterns  [8],  and  more  particularly 
a  layered  architectural  pattern  [7]  as  a  guideline  for  designing  the  PLA. 

There  are  several  different  architecture  description  languages  (ADLs)  [20], 

but  not  all  of  them  are  good  for  specifying  PLAs. 

In  [5], an  integrated  notation  for  specifying  software  architectures  in  three 

levels  of  abstraction  is  proposed:  structure,  behavior  and  domain  specific  ab(cid:173)
stract  data  types.  In  [4] it  is shown  how to  use this  notation  for  defining  a  PLA. 
The  notation  helps  in  the  process  of  identifying  and  localizing  variations,  but 
this  it  is  not  only  non-standard  for  architecture  specification,  but  also  it  has 
Uttle  tool  support. 

Koala  is a software  component  model  designed  for  creating  software  product 

lines  for  a  large  variety  of  products  [31,32]. Koala  handles  variation  using  com(cid:173)
position,  where  selection  of  reusable  components  is  bound  in  different  ways  to 
obtain  different  products.  Koala  was  specifically  created  for  modeling  embed(cid:173)
ded  systems.  Mae  is  a  technique,  along  with  a  supporting  toolset,  to  formally 
specify,  analyze,  and  evolve  software  architectures.  It  uses  xADL  2.0  as  an  ex(cid:173)
tensible  notation  to  model  the  PLA  as  we  do.  We  may  use  Mae  in  the  future 
to  face  other  development  stages. 

UML  has  become  a  standard  notation  for  documenting  software  design. 

With  the  new  UML  2.0  standard,  some  modeling  elements  specifically  for  soft(cid:173)
ware  architectures  were  incorporated,  but  there  are  still  no  primitives  for  doc(cid:173)
umenting  connectors  or  architectural  styles.  However,  there  have  been  some 
efforts  to  extend  UML  in  order  to  be  able  to  use  it  as  an  ADL  [24].  To  our 
knowledge,  UML  has  not  been  widely  used  for  defining  PLA.  xADL  improves 
on  the  UML  approach  in  two  significant  ways:  features  and  extensibility.  With 
respect  to  features,  xADL  2.0's  type  system  and  product-line  support  are  abil(cid:173)
ities  not  present  in  UML  2.0  [10]. 

A Meshing  Tool  PLA 

5 

3  Product  Line  Architecture 

Independently  of the  application  domain,  any  meshing tool  may  provide  certain 
general  functionality: 

-  read  the  domain  geometry  and  physical  values 
-  generate  an  initial  mesh 
-  refine,  derefine,  improve  or  smooth  a  mesh  according  to  a  quality  criterion 

within  a  specified  region 

-  evaluate  the  quality  of  a  resulting  mesh 
-  store  the  mesh  into  a  file  possible  with  different  formats 
-  visualize  the  mesh 

The  specification  of  the  input  geometry  and  the  physical  values  can  be 
generated  by different  CAD  programs  or by other  mesh generation  tools. That  is 
why  there  should  be  a  component  in  charge  of managing  input/output  formats. 
It  may  be  required  to  follow  different  algorithms  for  generating  an  initial 
mesh.  These  algorithms  receive  the  domain  geometry,  and  generate  a  mesh  that 
represents  an  initial  discretization  of  the  domain. 

Modeling  different  problems  may  require  different  point  distributions  in  the 
mesh,  thus  a  variety  of  refinement  strategies  have  been  proposed.  A  refinement 
strategy  consists  of  dividing  coarse  elements  into  smaller  ones  until  a  set  of 
refinement  criteria  within  a specified  region  is fulfilled.  Improvement  is a  special 
kind  of  refinement  where  the  quality  of  the  mesh  elements  is  improved,  not 
necessarily  dividing  existing  elements. 

Smoothing  and  derefinement  processes  are  also  applied  according  to  some 
criteria  and  over  different  domain  regions.  Smoothing  moves  point  locations  in 
order  to  improve  the  local  quality  of  the  mesh  elements.  And  refinement  is  the 
inverse  process  of  refinement,  making  the  mesh  coarser  again. 

The  evaluation  process  lets  the  user  know  the  real  quality  of  the  mesh,  in 

terms  of  percentage  of  good  and  bad  elements. 

The  tools  that  form  part  of  the  family  may  include  some  or  all  of  these 
processes.  The  PLA  determines  the  product  line  scope  limiting  what  products 
can  be  built,  but  at  the  same time  it  should  be  flexible  enough  to  allow  designers 
to  build  all  desired  tools.  Flexibility  and  interchangeability  are  two  of  the  non(cid:173)
functional  requirements  that  guide  our  PLA  design;  this  is  why  we  chose  a 
module  view  type  architecture,  and  more  precisely  a  layered  architecture. 

Figure  1  shows  the  structure  of  the  meshing  tool  PLA.  This  architecture 
is  specified  using  ArchStudio  [1]. For  simplicity  we  only  include  the  connectors 
between  layers  and  not  those  among  modules  within  a  layer  even  though  they 
exist  and  they  may  be  quite  complex.  Table  1 includes  a  general  description  of 
each  type  of  component  included  in  the  PLA  shown  in  Fig.  1. 

The  architecture  is  composed  by  four  layers:  User  Interface, 

Algorithms, 

Model  and  Input  Output.  In  the  User  Interface 
layer  there  is  only  one  mod(cid:173)
ule:  Selector.  The  Algorithms  contains  the  modules  corresponding  to  all  typical 
mesh  processes.  The  Model  layer  includes  the  representation  of  all entities  used 

Bastarrica  et  al. 

iw.!C.-:p:i' 

lU.-..™., 

Fig.  1.  Meshing  Tool  PLA 

for  modeling  the  mesh  as  well  as  the  processes  for  input  and  output  the  corre(cid:173)
sponding  data.  Finally,  in  the  Input  Output  layer  there  are  modules  for  reading 
mesh  data  and/or  visualizing  it.  In  xADL,  each  layer  is  defined  as  a  structure. 
Figure  2  shows  the  xADL  specification  of  the  complete  Meshing  Tool  PLA. 
Figure  3  shows  the  xADL  specification  of  the  Refine  module.  This  module  is 
included  in  the  Algorithms  structure. 

Refine  and/or  improve  represent  the  core  functionality  of  a  meshing  tool. 
In  our  PLA,  both  are  presented  as  optional  even  though  it  may  seem  counter 

Layer 

C o m p o n e nt 

D e s c r i p t i on 

A Meshing  Tool  PLA 

User 

Interface 
Algorithmf 

T y pe 

Selector 

Format 

Initial 

Refine 

Improve 

Derefine 

Smooth 

Final 

Evaluate 

Criterion 

Region 

Model 

Output 

Mesh 

Vertex 
Edge 

Face 

Element 

Input 

Visualizer 

InputFile 

Input 
Output 

the 

Menu  for  choosing  the  process  to  execute  in  the  fol(cid:173)
lowing  step 
Translates  the  input  geometry  (domain)  specified  in 
any  of  the  accepted  formats  in  a  normalized  format 
Generates  an  initial  mesh  of  the  domain 
Divides  the  mesh  elements  that  do  not  satisfy 
refinement  criterion  in  the  specified  region 
Improves  the  mesh  quahty  by dividing  or  reorganizing 
its  elements  according  to  the  criterion  in  the  specified 
region 
Eliminates  mesh  elements  according  to  a  criterion  in 
the  specified  region 
Improves  the  quahty  ot  the  elements  by  moving  mesh 
points  according  to  some  criterion  in  the  specified  re(cid:173)
gion 
Applies  a  post-process  to  the  complete  mesh 
Generates  statistics  ot  the  current  mesh  according  to 
a  quality  criterion 
Represents  a  geometric  or  physical  quality  that  an 
element  must  fulfill.  For  example,  the  minimum  angle 
of  each  element  must  be  greater  than  25°  and/or  the 
maximum  edge  length  must  be  less  than  2 
Represents  the  pari  ot  the  domain  where  the  selected 
algorithm  is  applied  to  any  element  that  does  not 
fulfill  the  specified  criterion 
Gets 
tributes  and  stores  it  in  the  required  format 
Gontams  the  discretization  ot  the  domain.  It  is  com(cid:173)
posed  of  elements,  faces  (only  in  3D),  edges  and  ver(cid:173)
tices 
Represents  a  point  of  the  discretization 
Represents  a  connection  between  two  vertices 
Represents  the  connections  on  an  element  surface.  A 
triangular  face  is  the  one  defined  by  three  vertices 
or  edges,  and  a  rectangular  face  is  defined  by  four 
vertices  or  edges 
Represents  a  discretization  ceil. It  can  be  a  triangle  or 
rectangle  in  2D,  or  a  tetrahedron  or  an  hexahedron, 
among  others,  in  3D 
Reads  the  domain  description  in  a specific  format  and 
stores  it  as  part  of  the  mesh 
Tool  that  allows  the  visualization  of  the  domain  dis(cid:173)
cretization  and  physical  attributes 
Gontains  the  domain  description  m  a  format  gener(cid:173)
ated  by  a  CAD  tool 

the  domain  discretization  and  physical  at(cid:173)

Table  1.  Component  types 

intuitive.  Actually,  at  least  one  of  them  must  be  included  in  any  tool  instan8 


Bastarrica  et  al. 

tiation.  Though  they  represent  different  concepts,  there  are  certain  algorithms 
that  perform  both,  so  there  are  meshing  tools  that  provide  both  functionalities 
only  including  one  of them.  There  are  other  tools  that  prefer  to  use  different  al(cid:173)
gorithms  for  each one. This  is why  we give the  opportunity  of choosing  different 
configurations.  The  Face  module  in  the  Model  layer  is  also  defined  as  optional. 
For  all  3D  tools  there  must  exist  a  Face  module,  but  it  is  meaningless  for  2D 
tools. 

+  <types:archStructure  types:id= "Meshing  Tool" 

xsi:type= "types: ArchStructure" > 

+  <types:archStructure  types:id="User  Interface" 

xsi:type= "types: ArchStructure" > 

+  <types:archStructure  types:id= "Algorithms" 

xsi:type= "types: ArchStructure" > 
+  <types:archStructure  types:id= "Model" 
xsi:type= "types: ArchStructure" > 

+  <types:archStructure  types:id= "Input  Output" 

xsi:type= "types: ArchStructure" > 

Fig.  2.  Structures  used  in  Meshing  Tool  Architecture 

As  we  can  see  in  Figs.  1  and  3,  Refine  exposes  two  interfaces,  called  Re(cid:173)
respectively.  The  former  has  the  direction  in,  and 
fine.Top  and  Refine.Bottom, 
the  latter  has  the  direction  out;  this  means  that  this  component  can  be  used  by 
any  component  in the  upper  layer,  and  Refine  may  use other  modules  contained 
in  the  lower  layer,  following  the  rules  of  the  layered  architectural  pattern  [7]. 

According  to  the  graphical  specification  in Fig.  1 where  Refine  is defined  as 
tag  indicating  optionality. 

optional,  the  xADL  includes  the  options:optional 

4  Product  Instantiation 

In order  to show the  consistency of the  proposed  PLA, we present  some  products 
that  may  be  part  of  the  SPL. 

The  process  of  designing  meshing  products  using  the  proposed  PLA  has 
two  stages:  component  type  selection  and  implementation  selection.  First,  the 
component  types  that  are  to  be  included  must  be  chosen;  here  some  of  the  op(cid:173)
tional  component  types  may  not  be  included.  In  the  second  stage,  a  particular 
implementation  needs  to  be  chosen  for  every  selected  component  type.  In  this 
way,  different  meshing  tools  may  differ  in  their  functionality  (component  types 
included)  or  in  their  implementation  (concrete  component  implementation  as(cid:173)
signed  to  each  component  type). 

A Meshing  Tool  PLA 

-  <types:component  types:id= "Refine"  xsi:type="types:Component"> 

<types:description  xsi:type= "instance:Description"> 

Refine  module</types:description> 

-  <types:interface  types:id="Refine.Top"  xsi:type="types:Interface"> 

<types:description  xsi:type="instance:Description"  > 

Top  interface</types:description> 

<types:direction  xsi:type="instance:Direction" >  in</types:direction> 

</types:interface> 
-  <types:interface  types:id= "Refine.Bottom"  xsi:type="types:Interface"> 

<types:description  xsi:type= "instance:Description" > 

Bottom  interface<  /types:description> 

<types:direction  xsi:type="instance:Direction" >  out</types:direction> 

</types:interface> 
+  <options:optional  xsi:type="options:Optional"> 

< /typesxomponent > 

Pig.  3.  Refine  Module  Specification 

Our  SPL  is  oriented  towards  building  tools  for  the  generation  of  meshes 
required  for  numerically  solving  partial  differential  equations.  The  most  widely 
used  numerical  methods  for  solving  these  equations  are:  finite  differences,  con(cid:173)
trol  volumes,  and  finite  elements.  Typically  mesh  generators  have  been  imple(cid:173)
mented  using Delaunay  algorithms, octree or  advancing  front.  Meshes  satisfying 
the  Delaunay  condition  are  those  that  provide  the  most  equilateral  partition  of 
a  set  of  2D points.  Octrees  and  advancing  front  are  specific  techniques  for  mesh 
generation.  In  Section  4.1  we present  tools  for  generating  finite  element  meshes 
and  in  Section  4.2  we  present  control  volume  meshes;  in  each  case  we  present 
one  example  for  2D  meshes  and  another  one  for  3D  meshes. 

4.1  Finite  Element  Meshes 

For  a  large  range  of  problems  using  the  finite  element  method,  isotropic  meshes 
are  required.  The  isotropy  is  measured  based  on  the  geometrical  properties  of 
each  mesh  element,  e.g.  more  equilateral  elements  are  considered  better  than 
elements  with  too  small  or  too  large  angles. 

Simple  2D  Triangulation  Tool  2D  triangulations  require  some  of  the  com(cid:173)
ponent  types  identified  as  part  of  the  Algorithms  layer  of  the  PLA  in  Fig.  3. 
In  particular,  a  tool  that  generates  Delaunay  triangulations  where  all  triangles 
have  the  minimum  angle  greater  than  a  threshold  value  specified  by  the  user, 
requires  the  component  types  described  as  part  of  Table  2.  2D  triangulations 
do  not  require  the  Face  component  type,  but  all  other  component  types  in  the 
Model  layer  must  be  included. 

10 

Bastarrica  et  al. 

C o m p o n e nt 

D e s c r i p t i on 

T y pe 

Selector 

Initial 
Improve 
Criterion 

Region 

After  generating  the  initial  mesli,  only  the  improvement  algorithm 
can  be  selected  letting  the  user  to  provide  the  minimum  angle  for 
the  criterion  to  be  applied 
Delaunay.algorithm  is  used  for  generating  the  initial  mesh 
Delamiay_improvement_algorithm  is  used  for  improving 
Minimum-angle  is  used  as  a  general  criterion 
Whole_geometry  is  used  as  the  region  where  the  improvement  algo(cid:173)
rithm  is  applied 

Table  2.  2D  triangulation  meshing  tool  (taken  from 

E v en  t h o u gh  t he  F o r m at  c o m p o n e nt  t y pe  is  n ot  optional,  in  this  case  it  has 

a  d u m my  functionality  since  t he  mesh  is  already  r e ad  in  its  required  format. 

3D  T e t r a h e d r al  M e s h es  In  Table  3  t he  a l g o r i t h ms  included  in  a  p a r t i c u l ar 
3D  finite  element  mesh  g e n e r a t or  t a k en  from  [19]  are  described.  T h is  meshing 
tool  allows  t he  generation  of  3D  D e l a u n ay  a nd  n o n - D e l a u n ay  meshes  w i th  a 
user  specified  point  density  a nd  element  quality.  It  also  u n d e r s t a n ds  different 
i n p ut  a nd  o u t p ut  d a ta  formats.  All  c o m p o n e nt  t y p es  included  in  t he  Model 
layer  m u st  also  be  realized  as  p a rt  of  t he  tool,  including  F a ce  since  it  is  a  3D 
tool. 

C o m p o n e nt 

D e s c r i p t i on 

T y pe 

Selector 

Initial 

Format 

Refine 

Improve 

Criterion 

Region 

After  generating  the  initial  mesh,  the  Refine  and  Improve  compo(cid:173)
nents  ca.n  he  chosen  several  times 
GMVDelaunay  generates  a  Delaunay  mesh 
translates  the  Off  and  Mesh  formats  into  the  appropriate  format  understandable 
 by  the  meshing  tool  using  Of f Format  and  MeshFormat. 
respectively 
LeppBisection  refines  generally  according  to  the  longest  edge  cri(cid:173)
terion,  or  any  other  refinement  criterion 
LeppDelaunay  improves  the  mesh  with  the  CircumRadiusEdgeRatio 
criterion,  or  any  other  improvement  criterion 
A  set  of  different  eligible  criteria  tor  refinement  and  improvement 
e.g.  LongestEdge,  CircumRadiusEdgeRatio,  VolvimeEdgeRatio 
Region  where  the  algorithm  is  applied;  e.g.  WholeGeometry,  Cube, 
Sphere 

the 

Table  3.  3D  finite  element  mesh  generator  (taken  from  [19]) 

A  Meshing  Tool  PLA 

11 

4.2  Control  Volume  Meshes 

For  the  simulation  of  semiconductor  devices  using  the  control  volume  method, 
it  is  required  to  have  anisotropic  Delaunay  conforming  meshes  where  no  part 
of  a  Voronoi  region  of  an  internal  point  is  outside  the  domain  [11]. In  2D,  this 
requirement  is fulfilled  if there  is no obtuse  angle opposite to  boundary/interface 
edges.  In  3D,  for  each  boundary  face  the  center  of  the  smallest  circumsphere 
must  be  inside  the  domain.  In  addition,  too  large  angles  in  the  interior  of  the 
domain  and  too  high  vertex  edge  connectivity  must  be  avoided. 

2D  Triangulations  In  [3], a  tool  for  the  simulation  of  semiconductor  devices 
is  described.  Here  the  mesh  is  read  already  in  the  format  the  tool  is  able  to 
understand,  so  the  Format  component  is  assumed  to  have  a  dummy  function(cid:173)
ality.  This  tool  is  essentially  used  for  improving  and  post-processing  a  mesh 
already  generated  and  refined  by  another  meshing  generator.  The  specific  com(cid:173)
ponent  types  chosen  and  their  particular  implementations  are  those  described 
in  Table  4. 

Component 

Description 

Type 

Selector 

Criterion 

Region 

Allows to enter  a specitic improvement  region and criterion, and also 
to  choose  the  following  algorithm  to  be  applied  (either  Improve  or 
Final) 
Reads  the  already  generated  Delaunay  mesh 

Initial 
Improve  Applies  the  Delauiiay_improvement_algorithm  to  the  specified  re(cid:173)
gion  with  a  particular  criterion 
'ost-processes  the  mesh  eliminating  obtuse  angles  opposite  to  the 
boundary  (Non_obtuse_boimdary.algorithm 
Improvement  criteria  such  as  Maximum-edge-vertex_connectivity 
and  Maximum_angle 
the 
Region  where  tne  improvement  is  applied;  in  the  example  only 
Vfhole_geometry  is used,  but  it  may  also be  Circle  or  Rectangle 

Final 

Table  4.  2D control  volume  mesh  (taken  from 

3D  Mixed  Element  Meshes  A  tool  for  3D  semiconductor  simulation  is  de(cid:173)
scribed  in  [16]. In this  case, the  mesh  is composed  of different  types  of  elements, 
i.e.  cuboides,  prisms,  pyramids  and  tetrahedra.  The  implementation  is based  on 
a  modified  octree  approach.  Even  though  this  application  was  not  developed 
with  the  product  line  concepts  in  mind,  it  fits  within  the  PLA  structure  with 
little  effort.  The  components  included  as  part  of  the  tool  are  described  in  Ta(cid:173)
ble  5. 

12 

Bastarrica  et  al. 

Description 

Component 

Type 

Selector 

Initial 

Refine 

Final 

Region 

Criterion 

Format 

Allows  to  enter  a  list  of  criteria  and  their  associated  regions,  and 
then  the  whole  process  is invoked 
Reads  the  device  geometry  and  generates  a  Krst  coarse  mixed  ele(cid:173)
ment  mesh  (Fit-Device-Geometry) 
Divides  element  in  order  to  ht  physical  and  geometric  parameter 
values  (Ref ine-Grid) 
Improves  elements 
requirement  and  generates 
Make-IrregTilar_Leaves_Splittable 
Regions  where  the  refinement  is  applied,  e.g.  cuboid  or  rectangle, 
among  others 
Doping-Difference  and  Longest-Edge  as  the  main  refinement  cri(cid:173)
fp 
teria 
Outputs 
the 
Write-Doping-Information) 

fulfill 
region 
final  mixed  element  mesh 

understandable  Ey 
and 

(Write-Geometrical-Inf  ormation 

tHi  Voronoi 

the  mesh 

In 

a 

format 

in  order 

to 
the 

visualizer 

Table  5.  3D control  volume  mesh  (taken  from  [16]) 

5  Conclusion 

Meshing  tool  construction  has  not  generally  been  approached  using  modern 
software  engineering  techniques,  even  though  being  sophisticated  pieces  of  soft(cid:173)
ware  makes  them  an  appropriate  application  area. 

The  software  product  line  approach  intends  to  reuse  all  the  artifacts  that 
are  built  during  software  development  in  new  products  that  fall  within  the 
SPL  scope.  The  PLA  is  one  of  the  most  important  assets  in  a  SPL  because 
it  determines  the  non  functional  properties  the  resulting  software  will  have. 
Having  a  well  defined  architecture  allows  us  to  integrate  components,  either  in 
house  developed,  commercial  or  open  source,  such  as  the  visualizer  in  our  SPL 
case. 

We  proposed  a  layered  PLA  for  a  meshing  tool  SPL  and  we  showed  that  a 
variety  of  diverse  meshing  tools  are  consistent  with  the  proposed  structure.  By 
formally  specifying  the  PLA  using  xADL,  we  were  also  able  to  iterate  until  we 
designed  an  architecture  that  was  simple  enough  to  be  easily  understood,  while 
general  enough  to  be  able  to  capture  the  abstractions  behind  a  wide  variety  of 
meshing  tools.  Having  an  integrated  graphical  and  textual  modeling  tool  such 
ArchStudio,  greatly  helped  in  this  process. 

The  proposed  PLA  can  be  used  as  a  road  map  to  build  almost  any  meshing 
tool.  Different  dimensions,  algorithms, strategies  and  criteria  will determine  the 
concrete  implementation  of  the  component  types  identified  as  part  of  the  PLA 
that  will  be  part  of  each  different  meshing  tool.  We  plan  to  build  a  more  com(cid:173)
plete  set  of  different  implementations  of  the  component  types  in  the  PLA  and 
a  software  framework  based  on  the  PLA  structure  as  a  "meshing  tool  factory" 

A  Meshing  Tool  PLA 

13 

for  designing  different  tools  t h at  m ay  be  automatically  built  by  combining  t he 
chosen  i m p l e m e n t a t i on  for  each  c o m p o n e nt  t y p e. 

T h e re  are  currently  some  astronomical  applications  being  developed  based 

on  t he  proposed  P L A,  mainly  using  t he  proposed  layered  s t r u c t u re  as  a  guide(cid:173)
line. 

Acknowledgments 

T he  work  of  N a n cy  Hitschfeld-Kahler  was  partially  s u p p o r t ed  by  Fondecyt  P r o j(cid:173)
ect  N°1061227.  T he  work  of  P e d ro  O.  Rossel  was  partially  s u p p o r t ed  by  g r a nt 
No.  U CH  0109  from  M E C E S U P,  Chile. 

References 

1.  ArchStudio 

3.  Architecture-Based  Development  Environment. 

for 

tute 
Software  Research,  University 
http://www.isr.uci.edu/projects/archstudio/. 

of  California, 

Irvine, 

Insti(cid:173)
2005. 

2.  Len  Bass,  Paul  Clements,  and  Rick  Kazman.  Software  Architecture 

in  Practice. 

SET  Series  in  Software  Engineering.  Addison-Wesley,  2'"'  edition,  2003. 

of  meshing  tools.  Advances 

3.  Maria  Cecilia Bastarrica  and  Nancy  Hitschfeld-Kahler.  Designing  a product  family 
in  Engineering  Software,  37(1):1-10,  January  2006. 
4.  Maria  Cecilia  Bastarrica,  Marcelo  Lopez,  Sergio  F.  Ochoa,  and  Pedro  O.  Rossel. 
In 

Using  the  Integrated  Notation  for  Defining  a  Product  Line  Architecture. 
Proceedings  of  the  First  Conference  on  the  PRInciples 
PRISE'04,  Buenos  Aires,  Argentina,  November  2004. 

of  Software 

Engineering, 

5.  Maria  Cecilia  Bastarrica,  Sergio  F.  Ochoa,  and  Pedro  O.  Rossel.  Integrated  No(cid:173)

tation  for  Software  Architecture  Specifications.  In  Proceedings  of  the  XXIV 
ternational  Conference  of  the  Chilean  Computer  Science  Society,  SCCC'04,  pages 
26-35,  Arica,  Chile,  November  2004.  IEEE  Computer  Society. 

In(cid:173)

6.  Jan  Bosch.  Design  and  Use  of  Software  Architectures.  Adopting  and  Evolving  a 

Product  Line  Approach.  Addison  Wesley,  first  edition.  May  2000. 

7.  Frank  Buschmann,  Regine  Meunier,  Hans  Rohnert,  and  Peter  Sommerlad.  Pattern 
John  Wiley  &  Son  Ltd., 

Oriented  Software  Architecture:  A  System  of  Patterns. 
August  1996. 

8.  Paul  Clements,  Felix  Bachmann,  Len  Bass,  David  Garlan,  James  Ivers,  Reed 
Architectures. 

Little,  Robert  Nord,  and  Judith  Stafi'ord.  Documenting 
Views  and  Beyond.  SEI  Series  in  Software  Engineering.  Addison  Wesley,  2002. 

Software 

9.  Paul  Clements  and  Linda  M.  Northrop.  Software  Product  Lines:  Practices  and 

Patterns.  Addison  Wesley,  first  edition,  August  2001. 

10.  Eric  M.  Dashofy,  Andre  van  der  Hoek,  and  Richard  N.  Taylor.  A  Comprehen(cid:173)
sive  Approach  for  the  Development  of  Modular  Software  Architecture  Descrip(cid:173)
tion  Languages.  ACM  Transactions 
14(2):199-245,  2005. 

on  Software  Engineering  and  Methodology, 

11.  M.  de  Berg,  M.  van  Kreveld,  M.  Overmars,  and  O.  Schwarzkopf. 

Computational 

Geometry.  Algorithms  and  Applications.  Springer,  second  edition,  1998. 

14 

Bastarrica  et  al. 

12.  Rod  W.  Douglass,  Graham  F.  Carey,  David  R.  White,  Glen  A.  Hansen,  Yannis 
Kallinderis,  and  Nigel  R  Weatherill.  Current  views  on  grid  generation:  summaries 
of  a  panel  discussion.  Numerical  Heat  Transfer,  Part  B:  Fundamentals, 
41:211237,
  March  2002. 

13.  Ahmed  H.  ElSheikh,  W.  Spencer  Smith,  and  Samir  E.  Chidiac.  Semi-formal 
Software, 

design  of  reliable  mesh  generation  systems.  Advances 
35(12):827-841,  2004. 

in  Engineering 

14.  Andreas  Fabri,  Geert-Jan  Giezeman,  Lutz  Kettner,  Stefan  Schirra,  and  Sven 
Schonherr.  On  the  design  of  CGAL  a  computational  geometry  algorithms  library. 
Software 

-  Practice  and  Experience,  30(11):1167-1202,  2000. 

15.  Martin  Fowler.  Who  Needs  an  Architect?  IEEE  Software,  2 0 ( 5 ) : 1 H 3,  2003. 
16.  Nancy  Hitschfeld,  Paolo  Conti,  and  Wolfgang  Fichtner.  Mixed  Element  Trees: 
A  Generalization  of  Modified  Octrees  for  the  Generation  of  Meshes  for  the  Sim(cid:173)
ulation  of  Complex  3D  Semiconductor  Device  Structures. 
Transactions 
on  Computer-Aided  Design  of  Integrated  Circuits  and  Systems,  12(11):1714-1725, 
November  1993. 

IEEE 

17.  Nancy  Hitschfeld-Kalher,  Carlos  Lillo,  Ana  Caceres,  Maria  Cecilia  Bastarrica, 

and  Maria  Cecilia  Rivara.  Building  a  3D  Meshing  Framework  Using  Good  Soft(cid:173)
ware  Engineering  Practices.  In  Proceedings  of  the  J"*  International  Workshop  on 
Advanced  Software  Engineering,  Santiago,  Chile,  August  2006. 

18.  Rohit  Khare,  Michael  Guntersdorfer,  Peyman  Oreizy,  Nenad  Medvidovic,  and 
Richard  N.  Taylor.  xADL:  Enabling  Architecture-Centric  Tool  Integration  with 
XML. 
(HICSS-34),  Maui,  Hawaii,  January  2001.  IEEE  Computer  Society. 

In  34^  Annual  Hawaii 

Conference  on  System 

International 

Sciences 

19.  Carlos  Lillo.  Analysis,  Design  and  Implementation  of  an  Object-Oriented  System 
that  allows  to  Build,  Improve,  Refine  and  Visualize  3D  Objects.  Master's  thesis, 
Departamento  de  Ciencias  de  la  Computacion,  Universidad  de  Chile,  2006.  (in 
Spanish). 

20.  Nenad  Medvidovic  and  Richard  Taylor.  A  Classification  and  Comparison  Frame(cid:173)

work  for  Software  Architecture  Description  Languages. 
Software  Engineering,  26(1),  January  2000. 

IEEE  Transactions 

on 

21.  Silvio  Merazzi,  Edgar  Gerteisen,  and  Audrey  Mezentsev.  A  generic  CAD-mesh 

interface. 
pages  361-370,  October  2000. 

In  Proceedings  of  the  P"*  Annual 

International  Meshing 

Roundtable, 

22.  Anton  V.  Mobley,  Joseph  R.  Tristano,  and  Christopher  M.  Hawkings.  An  ObjectOriented 
 Design  for  Mesh  Generation  and  Operation  Algorithms.  In  Proceedings 
of  the  l(f^  Annual  International  Meshing  Roundtable,  Newport  Beach,  California, 
U.S.A.,  October  2001. 

23.  Malcolm  Panthaki,  Raikanta  Sahu,  and  Walter  Gerstle.  An  Object-Oriented  Vir(cid:173)

tual  Geometry  Interface.  In  Proceedings  of  the  6"'  Annual 
Roundtable,  pages  67-81,  Park  City,  Utah,  U.S.A.,  1997. 

International  Meshing 

24.  Sunghwan  Roh,  Kyungrae  Kim,  and  Taewoong  Jeon.  Architecture  Modeling  Lan(cid:173)
Software  En(cid:173)
2004),  pages  663-669,  Busan,  Korea,  November 

guage  based  on  UML  2.0.  In  Proceedings  of  the  11th  Asia-Pacific 
(APSEC 
gineering  Conference 
2004.  IEEE  Computer  Society. 

25.  Robert  Schneiders.  Meshing  software,  2006.  h t t p : / / w w w - u s e r s,  i n f o r m a t i k .-

r w t h - a a c h e n . d e/ 

r o b e r t s / s o f t w a r e . h t m l. 

26.  H.  Si  and  Klaus  Gartner.  Meshing  Piecewise  Linear  Complexes  by  Constrained 

Delaunay  Tetrahedralizations.  In  Proceedings  of  the  I4* 
Roundtable,  September  2005. 

International  Meshing 

A  Meshing  Tool  PL A 

15 

27.  R.  Bruce  Simpson. 

In  Proceedings 
International  Meshing  Roundtable,  pages  45-54,  South  Lake  Tahoe, 

Isolating  Geometry  in  Mesh  Programming. 

of  the  5'* 
California,  U.S.A.,  October  1999. 

28.  Spencer  Smith  and  Chien-Hsien  Chen.  Commonality  Analysis  for  Mesh  Gener(cid:173)

ating  Systems.  Technical  Report  CAS-04-10-SS,  Department  of  Computing  and 
Software,  McMaster  University,  October  2004. 

29.  Anne  Taulavuori,  Eila  Niemela,  and  Paivi  Kallio.  Component  documentation— 
Technology, 

and  Software 

Information 

a  key  issue  in  software  product  lines. 
46(8):535-546,  2004. 

30.  Timothy  J.  Tautges.  The  common  geometry  module  (CGM):  A  generic,  extensi(cid:173)

ble,  geometry  interface.  In  Proceedings  of  the  5*''  Annual 
Roundtable,  pages  337-347,  New  Orleans,  U.S.A.,  October  2000. 

International  Meshing 

31.  Rob  C. van  Ommering.  Building  product  populations  with  sofware  components.  In 

Proceedings  of  the  22rd  International  Conference  on  Software  Engineering, 
2002,  pages  255-265,  Orlando,  Florida,  USA,  May  2002.  ACM. 

ICSE 

32.  Rob  C.  van  Ommering,  Frank  van  der  Linden,  Jeff  Kramer,  and  Jeff  Magee.  The 
Computer, 

Koala  Component  Model  for  Consumer  Electronics  Software. 
33(3):78-85,  2000. 

IEEE 

33.  David  M.  Weiss  and  Chi  Tau  Robert  Lai.  Software  Product-Line  Engineering:  A 

Based  Software  Development  Process.  Addison-Wesley,  1999. 

