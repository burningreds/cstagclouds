A Gradual Interpretation of Union Types

Mat´ıas Toro(B) and ´Eric Tanter

PLEIAD Laboratory, Computer Science Department (DCC),

University of Chile, Santiago, Chile
{mtoro,etanter}@dcc.uchile.cl

Abstract. Union types allow to capture the possibility of a term to be of
several possibly unrelated types. Traditional static approaches to union
types are untagged and tagged unions, which present dual advantages
in their use. Inspired by recent work on using abstract interpretation to
understand gradual typing, we present a novel design for union types,
called gradual union types. Gradual union types combine the advantages 
of tagged and untagged union types, backed by dynamic checks.
Seen as a gradual typing discipline, gradual union types are restricted
imprecise types that denote a ﬁnite number of static types. We apply
the Abstracting Gradual Typing (AGT) methodology of Garcia et al. to
derive the static and dynamic semantics of a language that supports both
gradual unions and the traditional, totally-unknown type. We uncover
that gradual unions interact with the unknown type in a way that mandates 
a stratiﬁed approach to AGT, relying on a composition of two
distinct abstract interpretations in order to retain optimality. Thanks to
the abstract interpretation framework, the resulting language is type safe
and satisﬁes the reﬁned criteria for gradual languages. We also show how
to compile such a language to a threesome cast calculus, and prove that
the compilation preserves the semantics and properties of the language.

1 Introduction

Gradual typing originated as an approach to smoothly combine static and
dynamic type checking within the same programming language [29]. Over the
years, gradual typing has been applied to languages with more advanced features,
 such as objects [26], polymorphism [2], and type inference [13] among
others. Gradual typing has also been developed beyond the original static/dynamic 
typing dualistic view to accommodate the integration of static typing
disciplines of diﬀerent strengths, such as information-ﬂow typing [10], eﬀects [3],
and logical reﬁnements [21].

Recently, Garcia et al. [14] identiﬁed that the general framework of Abstract
Interpretation (AI) [9] can be applied, at the type level, to lay down solid foundations 
of gradual typing in its various forms, thereby justifying several design

M. Toro—Funded by CONICYT-PCHA/Doctorado Nacional/2015-21150510.
´E. Tanter—Partially funded by FONDECYT Project 1150017.

c(cid:2) Springer International Publishing AG 2017
F. Ranzato (Ed.): SAS 2017, LNCS 10422, pp. 382–404, 2017.
DOI: 10.1007/978-3-319-66706-5 19

A Gradual Interpretation of Union Types

383

decisions and criteria that were originally discovered and reﬁned by trial-anderror.
 In essence, the Abstracting Gradual Typing approach (AGT for short)
conceives of gradual types as abstracting (in the AI sense) a set of possible static 
types. Exploiting an underlying Galois connection, one can systematically
derive a gradually-typed language that is crisply connected to the original static
discipline, and satisﬁes a number of essential criteria for such languages [30].

Stepping back, AGT reinforces an even broader interpretation of gradual
typing: that of soundly dealing with imprecision at the type level. Indeed, one can
see dynamically-typed languages as languages with highly-imprecise static type
information, and the original gradually-typed languages as allowing to reason
about partial type information. For instance, consider a function f of gradual
type Int → ?; this type is imprecise in that it does not provide any information
about the values returned by f, but it does specify precisely that f is a function,
which furthermore expects an integer argument. Therefore, the gradual language
can statically reject f + 1 or f(true), accept f(1), and optimistically accept
f(1) + 2 subject to a dynamic check that the value of f(1) is indeed an integer.
Similarly, integrating a simply-typed language with gradual support for eﬀects [3]
can be viewed as dealing with imprecision of eﬀect information.

Inspired by this focus on imprecision, we observe that standard static type
systems have long been proposed to deal with a basic form of imprecision: the
possibility for a value to be of several, possibly-unrelated types. In the literature,
two approaches have been developed to safely, and fully statically, deal with the
possibility of an expression to have possibly diﬀerent types: disjoint (or tagged)
union types, such as sum types T1 + T2 and variant types, and untagged union
types, usually noted T1 ∨ T2 [23]. Both forms of union types have complementary
pros and cons when viewed from a pragmatic angle.

The understanding of both gradual types and union types as diﬀerent ways
to deal with imprecision at the type level suggests a novel, gradual interpretation
of union types. Following the abstract interpretation of gradual types put forth
in AGT, a gradual union T1 ⊕ T2 is a gradual type that abstracts both T1 and
T2. Seen in this light, a gradual union is a gradual type that is more precise than
the prototypical, fully-unknown, gradual type ?, which abstracts any possible
type. Starting from this insight, systematically applying the AGT methodology
yields a novel point in the design space of both union types and gradual types.
Adding gradual unions to a simply-typed language relaxes the typing discipline,
 but does not allow full dynamic type checking. To achieve this, one needs
to include both the unknown type ? and gradual unions. A second contribution
of this paper is to uncover that combining these two gradual type constructors 
in the same language demands a stratiﬁed approach to AGT, in which the
semantics of gradual types comes from the composition of two distinct abstract
interpretations.

Contributions. This article makes the following speciﬁc contributions:
– A novel design of union types that combines beneﬁts of both tagged and
untagged unions, with added static ﬂexibility backed by runtime checks. Compared 
to a standard gradually-typed language with only the totally-unknown

384

M. Toro and ´E. Tanter

type ?, the resulting design is stricter, allowing more blatantly wrong programs 
to be statically rejected.

– A ﬁrst example of a stratiﬁed approach to AGT. To derive the static
semantics of a gradual language, AGT requires a Galois connection between
gradual types and sets of static types, which then guides the lifting of functions 
and predicates on static types to their gradual counterparts [14]. We
observe that applying AGT directly to introduce both the unknown type and
gradual unions breaks optimality of the abstraction, thereby weakening the
meaning of type information, both statically and dynamically. To address
this, we develop a stratiﬁed approach that allows us to recover optimality.
More speciﬁcally, we ﬁrst apply AGT to support only the unknown type, and
lift this Galois connection and derived liftings to their powerset counterpart.
We then apply AGT once more with another Galois connection to introduce
support for gradual unions, which allows us to deﬁne liftings based on the
previously-deﬁned powerset liftings. We prove that the composed abstraction
is optimal. We conjecture that this technique might prove helpful in integrating 
other gradualization eﬀorts.

– The formalization and meta-theory of the proposed language, including 
type safety and the gradual guarantees of Siek et al. [30]; these results
follow directly, by construction, from relying on the AGT methodology.

– A compilation scheme to an internal language with threesomes, a
space-eﬃcient representation for casts [28]. We prove the correctness of the
compilation with respect to the reference semantics derived by AGT using
logical relations; this is the ﬁrst case of formally relating the reference dynamic
semantics obtained by AGT with a cast insertion translation.

Structure. Section 2 brieﬂy reviews tagged and untagged unions, highlighting
their pros and cons, and then informally introduces gradual unions, comparing
them with standard gradual types and with the other kinds of unions, including 
those supported by several recent languages such as Flow and TypeScript,
, a language
among others. Section 3 describes the static semantics of GTFL
with both gradual unions and the unknown type, using the Abstracting Gradual
Typing methodology. Section 4 describes the runtime semantics of the language
by translation to a threesome cast calculus, and gives the formal properties of
the language. Section 5 discusses related work and Sect. 6 concludes.

⊕

Complete deﬁnitions, as well as the proofs of all the results stated in the
paper, can be found in the companion technical report [33]. A prototype implementation 
is available online, showing interactive typing and reduction derivations 
for arbitrary source programs: http://pleiad.cl/gradual-unions/.

2 Background and Motivation

We ﬁrst brieﬂy review standard tagged and untagged union types [23], highlighting 
the tradeoﬀs associated with each approach, and then introduce gradual
union types as a novel point in the design space. We compare gradual unions

A Gradual Interpretation of Union Types

385

to other approaches to union types, including practical languages with unions
supported by runtime type tests. Finally, we compare gradual unions with the
standard gradual types introduced by Siek and Taha [29].

2.1 Tagged Unions

Tagged unions, also called disjoint union types, denote values of possibly diﬀerent
types. The “disjointness” of the union comes from the fact that elements must
be explicitly tagged so that it is clear to which type an element belongs. Tagging
allows type-safe disambiguation through a case analysis construct.

The simplest form of tagged unions are binary sum types, noted T1 + T2, with
injection forms inl and inr, and a disambiguation case expression. For instance,
inl 10 :: Int + Bool injects the integer 10 into the sum type Int + Bool. The tag
inl denotes the left part of the sum. Similarly, inr true :: Int + Bool injects true
to the right of the sum. Note that the ascription :: is necessary to maintain a
simple syntax-directed type system; diﬀerent techniques can be used to alleviate
notation for programmers [23].

Given a value of type Int + Bool, one cannot use it directly. For instance,
λx : Int + Bool.x + 1 is not well typed. To use a tagged value, one must ﬁrst
disambiguate through an explicit case analysis, considering each tag explicitly,
e.g. λx : Int + Bool.case x of inl x ⇒ x + 1 | inr x ⇒ if x then 1 else 0.

Note that Int + Bool is diﬀerent from Bool + Int because the injection tag is
relative to the position in the sum type. Sums can be generalized to variants,
which are n-ary sums with custom labels instead of the positional inl and inr tags.
In the case of variants, a type-case construct similar to case forces programmers
to consider all possible alternatives, thereby statically ensuring the absence of
runtime type errors.

To deal with with values of statically-unknown types, several proposals add
a type Dynamic whose values are pairs of a plain value and a type tag [1,16].
The type Dynamic is therefore akin to an inﬁnite tagged union, where tags are
types. Disambiguation through case analysis therefore requires a default branch
to handle unconsidered alternatives generally.

This general approach also explains how several languages support union
types without needing any explicit tagging operation. For instance, in safe
dynamic languages, all values are readily tagged with their class (either in the
sense of Harper [15], e.g. Int, Bool, Function, or, for class-based object-oriented
languages, their actual class). This allows disambiguation of unions through runtime 
type testing (either via a type-case analysis or casts that can fail). This
approach is exploited in several retroﬁtted type systems such as TypeScript [8],
Flow [11] and Typed Racket [31,32]. Explicit disambiguation of unions can also
be supported through pattern matching, as in CDuce [5] and Dotty [25].

2.2 Untagged Unions
An untagged union, noted T1∨T2, denotes the union of the values of type T1 and
of type T2, without any tagging mechanism to support disambiguation. In this

386

M. Toro and ´E. Tanter

set-theoretic interpretation [4,12,22], Int ∨ Int is the same type as Int; and a
value of type T1 is a value of type T1 ∨ T2, without any injection construct.

Untagged unions can be used to allow the branches of conditionals to have
unrelated types: for instance, the function λx : Bool.if x then 1 else false can be
considered well-typed at Bool → Int∨ Bool. This is the approach followed by the
CDuce programming language [5], for instance.

Automatically introducing imprecision through untagged unions can however
lead to unwanted programs being accepted. An alternative approach is for the
typing rule for conditional expressions to require both branches to be of the same
type, and to expect the programmer to use an explicit type ascription to specify
that imprecision is desired; e.g. λx : Bool.if x then (1 :: Int∨ Bool) else false. Note
that the ascription does not imply any runtime tagging; it is a purely static
artifact. Also, because of the set-theoretic interpretation of types, it is suﬃcient
to ascribe imprecision in one of the two branches.
Untagged unions have no projection construct either; the only safe operations
on a value of type T1 ∨ T2 are those that are supported by both T1 and T2. Note
that this makes untagged union restrictive to use; for instance, nothing useful
can be done with a value of type Int∨Bool. For instance, λx : Int∨Bool.x+1 is not
well-typed, because x could be a boolean value; and there is no disambiguation
expression like case to handle each alternative separately.

This does not mean that untagged unions are useless; for instance, if the language 
has records, then it is safe to access ﬁelds that are common to both types.
As noted by Pierce [23], untagged unions have traditionally been much more
frequent in program analysis than in programming languages, where they were
mostly used in type systems for semi-structured data [6,18], before being generalized 
in CDuce. Finally, note that the C language supports unsafe untagged
unions, allowing programmers to use operations that are supported by either T1
or T2, at their own risk!

2.3 Gradual Unions

Tagged and untagged unions are the only safe approaches to statically deal with
imprecision: either explicitly tag the imprecision so as to be able to safely discriminate 
later on, or assume the loss of precision and restrict what can be
done with imprecisely-typed values. Tagged unions have the beneﬁt of allowing
programmers to fully use values, but only after explicit case-based disambiguations.
 Untagged unions have the beneﬁt of requiring neither explicit injection
nor projection, but only allow restricted usage of values.

If we are willing to accept some form of dynamic checking errors, however,
we can combine the beneﬁts of both tagged and untagged unions by viewing a
union type as a kind of gradual type: T1 ⊕ T2 is a gradual type that represents
both T1 and T2. A gradual union supports the same kind of optimistic static
checking that standard gradual typing provides.
For instance, f (cid:2) λx : Int⊕ Bool.x + 1 is (optimistically) well typed, because
x might possibly be an Int, without any explicit projection or case analysis. The
expressions f 1 and f true are also well-typed because injection to a gradual

A Gradual Interpretation of Union Types

387

union is implicit. The expression f 1 evaluates to 2, as expected. But because x
might in fact be a Bool, a runtime check is implicitly introduced before applying
the + operator: hence the expression f true produces a runtime cast error.

As a gradual type, a gradual union allows clearly incorrect programs to be
rejected statically. For instance, changing the body of f to x 1 is statically
(cid:4)(cid:4)
is statically
rejected, because x cannot possibly be a function. Similarly, f “hola
rejected, because f only tolerates integer or boolean arguments.
Note that compared to untagged unions, the use of a value with a gradual
union type T1 ⊕ T2 is accepted if the operations make sense for either T1 or T2
(and not both). This is just like untagged unions in C, but backed by runtime
checks to ensure type safety. Injecting values into a gradual union type can be
done implicitly as when applying g in the example above, or using an ascription,
e.g. g (cid:2) λx : Bool.if x then (1::Int⊕ Bool) else (false::Int⊕ Bool) has type Bool →
Int ⊕ Bool.1

2.4 Comparing Unions

We summarize the characteristics of each form of union types as follows:

injection projection

use

Tagged unions

sums
type tests/casts

explicit
implicit

explicit
explicit

full
full

Untagged unions
Gradual unions

none

none

restricted

implicit

implicit

full

To illustrate the convenience of gradual unions compared to alternative

approaches, consider the following simple program:

let x : Bool ⊕ Int ⊕ String = 10
(λx : Int ⊕ Bool . x +1) x

The program introduces a variable x that can be one of three types, and initializes
it to the number 10. It then passes it as argument to a lambda that expects either
an Int or a Bool, and adds 1 to it. This program is well-typed, and returns 11. If
x is initialized with a string, the program fails at runtime before the application
of the function; if it is initialized with a boolean, the runtime error occurs before
the addition.

This example would not be well-typed with untagged unions. This is because
the intersection of Int and Bool and String is empty. If all three types have a
common method, say toString, then the body of the lambda can only safely
invoke x.toString().

Turning to tagged unions, using standard sum types, the equivalent program
would be fairly cumbersome to write because all injections and projections have
to be manually introduced by the programmer, and deal with exact positions:
1 Similarly to untagged unions, one could design a language whose conditional expression 
implicitly introduces imprecision, without the need for any ascription (Sect. 2.2);
we do not further consider this possible design and use ascriptions explicitly.

1
2
3
4
5
6
7
8
9

388

M. Toro and ´E. Tanter

let x : Bool + ( Int + String ) = inr inl 10
let x2 : Int + Bool = case x of

| inl y = > inr y
| inr y = > case y of

| inl z = > inl z
| inr z = > throw new Error ( " not (cid:2) an (cid:2) Int (cid:2) or (cid:2) Bool " )

(λx : Int + Bool . case x of

| inl y = > y + 1
| inr y = > throw new Error ( " not (cid:2) an (cid:2) Int " )) x2
Note the need for an explicit intermediate step (x2) to safely go from the ternary
union to the binary union.

The same program can also be written using implicitly-tagged unions with
type-test disambiguation. As expected, the code is more lightweight than with
sums thanks to implicit injection. For instance, in Flow:

if ( typeof x == " number " ) return x + 1
else throw new Error ( " not (cid:2) a (cid:2) number " )

const x : boolean | number | string = 10
const foo = ( x : number | boolean ): number = > {

1
2
3
4
5
6
7
Note that projections must be realized manually via typeof (lines 3, 4, 6 and 7).

}
if ( typeof x == " boolean " || typeof x == " number " ) foo ( x )
else throw new Error ( " not (cid:2) a (cid:2) boolean (cid:2) or (cid:2) number " )

Evolving precision. The advantage of gradual unions does not only lie in the
simplicity and compactness of the program deﬁnition. It also lies in its robustness
in the face of precision-related changes. For instance, suppose that as the software
matures, the programmer is now convinced that x will always be initialized with
a number and that the function can simply only accept numbers. With sums,
the program is so fragile that it would need to be modiﬁed at every injection
and projection point to account for this change in precision. The Flow version
would still run as is, but would feature a lot of dead code. Further decreasing
precision would require adding checks at various projection points. With gradual
unions, it is enough to adjust the type annotations—the rest of the program is
unchanged!

The fact that the static-to-dynamic spectrum is navigated solely through
the precision of type annotations, without requiring further modiﬁcation of the
program, is a key asset of gradual typing in general. The gradual guarantee of
Siek et al. [30] further characterizes the relation between the static and dynamic
semantics of programs that only diﬀer in the precision of their type annotations,
and will be discussed further when addressing the meta-theory of GTFL

⊕

.

Higher-order types. Finally, a major limitation of projections from unions using
explicit type tests is that they do not support higher-order types. For instance,
because one cannot decide whether an arbitrary function (e.g. of tag/class Func-
tion) always behave as a function of a particular type, programmers have to
manually wrap functions with pre-post type checks.

if ( typeof x === " number " ) {

1
2
3
4
5
6
7
and then pass the wrapped function as argument: g(wrapper).

const result = f ( x )
if ( typeof result === " boolean " ) return result
else throw new Error ( " not (cid:2) a (cid:2) boolean " )

} else throw new Error ( " not (cid:2) a (cid:2) number " )

}

A Gradual Interpretation of Union Types

389

Consider, in Flow or TypeScript, two functions of the following types:

f : ( number | boolean ) = > ( number | boolean )
g : (( number | string ) = > ( boolean | string )) = > string

To safely support the application g(f), one needs to explicitly wrap f as follows:

const wrapper = ( x : number | string ): string | boolean = >{

Conversely, with gradual unions, one can simply write:
let f : ( Int ⊕ Bool ) -> ( Int ⊕ Bool ) = ...
let g : (( Int ⊕ String ) -> ( Bool ⊕ String )) -> String = ...

g ( f )
for the exact same behavior; all the necessary checks and wrappers are handled 
under the hood.

2.5 Gradual Unions vs. Standard Gradual Types

Gradual typing has always been formulated in terms of an unknown type, frequently 
written ?, which denotes any possible type [29]. Furthermore, when
structural types are supported, gradual types can be more precise than the
fully-unknown type: for instance Int → ? denotes all function types from Int to
possibly any type.

To illustrate the key diﬀerence between gradual unions and standard gradual
types, consider a function h that always returns either an Int or a Bool. Starting
from a simple typing discipline, with standard gradual types, the most precise
type one can give to h is Bool → ?. However, this type allows for too much
ﬂexibility that was not intended: because h true has type ?, it can subsequently
be used in any context, even (h true) 1, which is clearly always going to fail since
h never returns a function. The problem comes form the fact that the gradual
type used for the codomain of h, ?, is too imprecise—yet it is the only available
type to denote both Int and Bool. Hence, the programmer cannot express a more
restricted form of ﬂexibility. Gradual unions address this need. For instance,
recalling function g from Sect. 2.3 above, (g true) 1 is statically rejected.

Gradual union types are a novel way to relax a static typing discipline in
a restricted manner. While the discussion above insists on the advantages of
this restricted ﬂexibility, it necessarily presents drawbacks as well. In particular,
a language with only gradual unions cannot fully embed the untyped lambda
calculus. In order to get the best of both worlds, one needs a language that
supports both the fully-unknown gradual type ? in addition to gradual unions.
This way, programmers can navigate the full static-to-dynamic spectrum, with

390

M. Toro and ´E. Tanter

more interesting intermediate points oﬀered by gradual unions. In the rest of
this paper, we design and formalize such a language.

3 GTFL

⊕

: Static Semantics

⊕

We now formalize GTFL
, a gradual language with both gradual unions and the
unknown type. As hinted previously, we follow the Abstracting Gradual Typing
(AGT) methodology [14] to derive the static semantics of GTFL

⊕

:

1. We start from a language with a fully static typing discipline, STFL.
2. We deﬁne the syntax of gradual types, and give them meaning via a concretization 
function and its corresponding most precise abstraction, forming
a Galois connection. Crucially, in this step we realize that the two forms
of gradual types must be handled in a stratiﬁed manner in order to ensure
optimality.

3. We derive the static semantics of the gradual language by lifting type predicates 
and type functions used in the static type system through the Galois
connection.

The most novel part of our development are steps 2 and 3, which showcase how
to compose Galois connections related to diﬀerent gradual type constructors. We
address the dynamic semantics of GTFL

to Sect. 4.

⊕

3.1 The Static Language: STFL

Our starting point is a simply-typed functional language with booleans and
integers, called STFL [14]. A term can be a lambda abstraction, a boolean, a
number, a variable, an application, an addition, a conditional, or an ascription.
The typing rules are standard—omitted for space reasons, available in [33]—
save for the fact that their presentation follows some simple conventions, helpful
for gradualization [14]: the type of each sub-expression is kept opaque, the type
relations (=) are made explicit as side conditions, and partial type functions
(dom, cod , equate) are used explicitly instead of relying on matching metavariables.
 The dynamic semantics and type safety of STFL are completely standard.

3.2 Deﬁning Gradual Types Separately

⊕

supports both the unknown type ? and gradual unions with ⊕. In this
GTFL
section, we look at both gradual type constructors separately in order to precisely
deﬁne their meaning. Recall that following AGT, the meaning of a gradual type
is the set of static types that it possibly represents, deﬁned by a concretization
function γ. Given such a meaning, the AGT methodology directs us to deﬁne
a sound and optimal abstraction function α, hence forming a Galois connection 
[14], which is then used to lift static type predicates and type functions to
operate on gradual types. We study both gradual type constructors in turn.

A Gradual Interpretation of Union Types

391

Let us ﬁrst recall from [14] the Galois connection for gradual types made up

with the (nullary constructor) ?, here denoted GType.

G ∈ GType
G :: = ? | Bool

|

Int | G → G

The meaning of these gradual types is standard, and deﬁned through concretization 
by Garcia et al. [14] as follows:
Deﬁnition 1 (GType Concretization). γ? : GType → P(Type)

γ?(Int) = { Int}

γ?(Bool) = { Bool}

γ?(?) = Type

γ?(G1 → G2) = { T1 → T2 | T1 ∈ γ?(G1) ∧ T2 ∈ γ?(G2)}

Note in particular that the meaning of the fully unknown type ? is the set of
all types. Similarly, the meaning of the imprecise type Int → ? is the set of all
function types Int → T , for any T ∈ Type.

Concretization naturally induces the notion of precision among gradual types,

which reﬂects the amount of static information of a gradual type [14].

Deﬁnition 2 (GType Precision). G1 is less imprecise than G2, notation
G1 (cid:8) G2, if and only if γ?(G1) ⊆ γ?(G2).

The following abstraction α? naturally forms a Galois connection with γ?:2

Deﬁnition 3 (GType Abstraction). α? : P(Type) (cid:5) GType

α?({ T }) = T

α?(T1 → T2) = α?(T1) → α?(T2)

α?(∅) = undeﬁned

α?(T ) = ? otherwise

The abstraction retains as much precision as possible (e.g. singletons, function
type constructor) and degrades to the unknown type otherwise. Note that α? is
undeﬁned for the empty set [14].

Importantly, γ? and α? form a Galois connection:

Proposition 1 (α? is Sound and Optimal). If T is not empty, then

(a) T ⊆ γ?(α?(T )).

(b) T ⊆ γ?(G) ⇒ α?(T ) (cid:8) G.

Soundness (a) means that α always produces a gradual type whose concretization 
overapproximates the information in the original set. Optimality (b)
means that α is the best sound approximation function: it produces the most
precise gradual type that abstracts a given set.

2 We use the hat notation X to refer to a set of elements X (e.g. T is a set of static

types, and T is a set of sets of static types).

392

M. Toro and ´E. Tanter

Let us now consider a Galois connection for the novel gradual type constructor 
introduced in this work, gradual unions. We use SType to denote gradual
types made up only of gradual unions, i.e. without ?.

S ∈ SType
S :: = S ⊕ S | Bool

|

Int | S → S

Note that this syntax admits n-ary unions recursively through S ⊕ S. We
consider gradual unions to be syntactically equivalent up to associativity of ⊕,
i.e. S1 ⊕ (S2 ⊕ S3) ≡ (S1 ⊕ S2) ⊕ S3. Gradual unions represent the ﬁnite set of
types represented (recursively) by each constituent:
Deﬁnition 4 (SType Concretization). γ⊕ : SType → Pﬁn(Type)
γ⊕(Int) = { Int}

γ⊕(S1 ⊕ S2) = γ⊕(S1) ∪ γ⊕(S2)

γ⊕(Bool) = { Bool}

γ⊕(S1 → S2) = { T1 → T2 | T1 ∈ γ⊕(S1) ∧ T2 ∈ γ⊕(S2)}

For instance γ⊕(Int⊕Bool⊕(Int → Bool)) = { Int, Bool, Int → Bool}. Because
gradual unions only produce ﬁnite sets of static types, the corresponding abstraction 
also only needs to be deﬁned on ﬁnite sets, and therefore can produce the
gradual union with all the elements, noted ⊕T :
Deﬁnition 5 (SType Abstraction). α⊕ : Pﬁn(Type) (cid:5) SType

α⊕(T ) = ⊕T

if T (cid:13)= ∅

Here again, (cid:14)γ⊕, α⊕(cid:15) forms a Galois connection.

3.3 Combining Gradual Types: Take 1

Now that we have deﬁned the meaning of gradual types formed with the unknown
type ?, as well as the meaning of gradual types formed with gradual unions ⊕,
, which combine
we turn to deﬁning the meaning of gradual types in GTFL
both constructors, denoted UType:

⊕

U ∈ UType
U :: = ? | U ⊕ U | Bool

|

Int | U → U (gradual types)

A ﬁrst seemingly natural approach is to deﬁne the concretization function
for UType by combining both concretization functions for GType and SType:
Deﬁnition 6 (UType Concretization, Take 1). γ : UType → P(Type)
γ(Bool) = { Bool}
γ(U1 ⊕ U2) = γ(U1) ∪ γ(U2)
γ(U1 → U2) = { T1 → T2 | T1 ∈ γ(U1) ∧ T2 ∈ γ(U2)}

γ(Int) = { Int}

γ(?) = Type

A Gradual Interpretation of Union Types

393

While this deﬁnition seems sensible,

it does not accommodate a corresponding 
optimal abstraction. Indeed, the abstraction functions for GType and
SType conﬂict with each other: how should we abstract a set of diﬀerent types?
For a set of base types, say { Int, Bool}, we can either abstract to ? or to
Int ⊕ Bool; the latter being optimal, while the former is not. In fact, to preserve
optimality, we ought to defer to the unknown type only for heterogeneous inﬁnite
sets. Even if we would adjust the deﬁnition of the combined abstraction to make
such a distinction, it would not be optimal. To see why, consider the type (? →
Int) ⊕ (Int → ?), whose concretization is:

γ((? → Int) ⊕ (Int → ?)) = γ(? → Int) ∪ γ(Int → ?)

= { T → Int | T ∈ Type} ∪ { Int → T | T ∈ Type}
= { Int → Int, Bool → Int, Int → Bool, . . .}
(cid:2) T

By taking the union of both sets, we “forget” a speciﬁcity of the original
gradual type—namely that it only represents functions that necessarily have Int
either as domain or as codomain. For instance, Bool → Bool is not present in
the resulting set T . However, the abstraction function that we obtain by directly
combining the two abstractions we have seen above is unable to recover an
optimal gradual type: because T is inﬁnite and only contains arrow types, the
best the abstraction can do is to keep the arrow constructor, and then separately
abstracts the domain and codomain types (just like α?). As a result:

α(T ) = ? → ?

While this abstraction is sound, it is not optimal: there exists a more precise
gradual type that represents T , the type (? → Int) ⊕ (Int → ?) we started with.
Losing optimality directly aﬀects the programmer’s experience. For instance,
in the type system, this means that the gain of precision that gradual unions are
supposed to provide (recall Sect. 2.5) is lost; similarly, type annotations would
not be strictly enforced at runtime.

3.4 Combining Gradual Types: Take Two

⊕

, we introduce a stratiﬁed, sketched in Fig. 1:

In order to deﬁne a proper Galois connection to give meaning to the gradual
types of GTFL
– Step 1. We start from the Galois connection between GType and P(Type),
named classic interpretation hereafter, which interprets the unknown type.
We already described this Galois connection in Sect. 3.2.

– Step 2. We lift this connection to operate on ﬁnite sets of gradual types, with
the standard collecting semantics, forming a new Galois connection between
Pﬁn(GType) and Pﬁn(P(Type)), named the classic set interpretation.

394

M. Toro and ´E. Tanter

Fig. 1. Stratiﬁed interpretation of UType.

⊕

– Step 3. We introduce a Galois connection between UType and Pﬁn(GType),
named union interpretation, which adds support for gradual unions among gradual 
types that include the unknown type.

– Step 4. We combine the classic set interpretation and the union interpretation.
 This combination gives a stratiﬁed interpretation of GTFL
gradual
types, UType, in terms of ﬁnite sets of (possibly-inﬁnite) sets of static types.
As we show, the stratiﬁed interpretation is itself a proper Galois connection, and
we can subsequently use it to lift the static (and dynamic) semantics of STFL
in order to deﬁne the semantics of GTFL
Step 2. Lifting the Classic Interpretation. Recall that (cid:14)γ?, α?(cid:15) from Definitions 
1 and 3 form a Galois connection between GType and P(Type) [14].
Our ﬁrst step is to lift this connection to operate on sets of gradual types with
the unknown type, i.e. to relate Pﬁn(GType) and Pﬁn(P(Type)). The powerset
lifting of γ?, denoted γ?, is simply the piecewise application of γ?:
Deﬁnition 7 (P ﬁn(GType) Concretization). γ? : Pﬁn(GType) → Pﬁn(P
(Type))

⊕

.

γ?(G) = { γ?(G) | G ∈ G}

Similarly, the powerset lifting of the abstraction function α?, denoted α?, is
the union of the piecewise application of α?:
Deﬁnition 8 (P ﬁn(GType) Abstraction). α? : Pﬁn(P(Type)) (cid:5) Pﬁn
(GType)

α?(∅) = undeﬁned

α?(T ) =

(cid:2)

α?(T )

As expected, (cid:14)γ?, α?(cid:15) is a proper Galois connection.

T∈T

Proposition 2 (α? is Sound and Optimal). If T is not empty, then

(a) T ⊆ γ?(α?(T )).

(b) T ⊆ γ?(G) ⇒ α?(T ) (cid:8) G.

A Gradual Interpretation of Union Types

395

Step 3. Introducing the union interpretation. We deﬁne a Galois connection 
between UType and Pﬁn(GType) by naturally extending the deﬁnition
of the connection between SType and Pﬁn(Type) from Deﬁnitions 4 and 5, so
that it now operates over types in UType instead of only types in SType.
Deﬁnition 9 (UType Concretization). γ⊕ : UType → Pﬁn(GType)
γ⊕(?) = { ?}

γ⊕(Bool) = { Bool}

γ⊕(Int) = { Int}

γ⊕(U1 → U2) = { T1 → T2 | T1 ∈ γ⊕(U1) ∧ T2 ∈ γ⊕(U2)}

γ⊕(U1 ⊕ U2) = γ⊕(U1) ∪ γ⊕(U2)

Compared to Deﬁnition 4, the only additional case to consider is that the
unknown type ? can now occur: it is handled like other nullary type constructors,
by concretizing to a singleton.

The abstraction is direct from Deﬁnition 5.

Deﬁnition 10 (UType Abstraction). α⊕ : Pﬁn(GType) (cid:5) UType

α⊕(G) = ⊕G

if G (cid:13)= ∅

where ⊕G denotes the gradual union of all the types in the set T .

Again, (cid:14)γ⊕, α⊕(cid:15) is a Galois connection.

Proposition 3 (α⊕ is Sound and Optimal). If G is not empty, then

(a) G ⊆ γ⊕(α⊕(G)).

(b) G ⊆ γ⊕(U) ⇒ α⊕(G) (cid:8) U.

Step 4. Composing the Connections. We can now compose the two Galois
connections in order to deﬁne a stratiﬁed interpretation for UType in terms of
sets of sets of static types.
Deﬁnition 11 (Concretization). γ : UType → Pﬁn(P(Type)), γ = γ? ◦ γ⊕
Deﬁnition 12 (Abstraction). α : Pﬁn(P(Type)) (cid:5) UType, α = α⊕ ◦ α?

Because the composition of two Galois connection is a Galois connection, the

stratiﬁed interpretation (cid:14)γ, α(cid:15) is a Galois connection.

Proposition 4 (α is Sound and Optimal). If T is not empty, then

(a) T ⊆ γ(α(T )).

(b) T ⊆ γ(U) ⇒ α(T ) (cid:8) U.

The notion of precision for gradual types used above is similarly induced by
concretization, i.e. U1 (cid:8) U2 ⇐⇒ γ(U1) ⊆ γ(U2). Note that these deﬁnitions use
containment over sets of sets, deﬁned as T1 ⊆ T2 ⇐⇒ ∀T1 ∈ T1,∃T2 ∈ T2, T1 ⊆
T2. Precision can equivalently be deﬁned in terms of the lifted classic abstraction,
i.e. U1 (cid:8) U2 ⇐⇒ γ⊕(U1) (cid:8)? γ⊕(U2), where G1 (cid:8)? G2 ⇐⇒ γ?(G1) ⊆ γ?(G2).

396

M. Toro and ´E. Tanter

Fig. 2. GTFL

⊕

: selected typing rules

Illustration. Let us come back to the example of Sect. 3.3 that motivated the
need for a stratiﬁed interpretation of UType.

γ((? → Int) ⊕ (Int → ?)) = {γ?(? → Int), γ?(Int → ?)}

= {{ T → Int | T ∈ Type} ,{ Int → T | T ∈ Type}}

we can now recover exactly the same gradual type

α({{ T → Int | T ∈ Type} ,{ Int → T | T ∈ Type}})

= α⊕(α?({ T → Int | T ∈ Type}) ∪ α?({ Int → T | T ∈ Type}))
= α⊕(? → Int, Int → ?) = (? → Int) ⊕ (Int → ?)

3.5 Static Semantics of GTFL

⊕

⊕

The syntax of GTFL
is the same as that of STFL, save for the introduction of
gradual types U. Consequently, terms t are lifted to gradual terms (cid:3)t ∈ UTerm,
i.e. terms with gradual type annotations.

⊕

The type system of GTFL

is presented in Fig. 2. The typing rules present
no surprise with respect to the gradual language with ? presented by Garcia
et al. [14]. This is because the novelty of gradual unions is encapsulated in
gradual type predicates and functions, such as ∼, (cid:21), (cid:4)dom, etc.

The essential idea of using abstract interpretation to deﬁne a gradual language 
is that the Galois connection that deﬁnes gradual types speciﬁes how to
lift both type predicates and functions to obtain their consistent counterpart.3
For instance, the consistent lifting of a predicate over static types is the existential 
lifting of the predicate through the Galois connection. In other words, for a
given binary predicate P ∈ Type2, its consistent lifting (cid:3)P ∈ GType2 is deﬁned
as: (cid:3)P (U1, U2) ⇐⇒ ∃T1 ∈ γ(U1),∃T2 ∈ γ(U2), P (T1, T2). Similarly for functions:
a lifted function is the abstraction of the application of the static function to
all the possible static types denoted by the involved gradual types. Formally,
(cid:3)f = α ◦ f ◦ γ, where f is the pointwise application of f to all elements.

3 The AI framework provides us with deﬁnitions for consistent predicates and functions;
 we will provide some equivalent algorithmic characterizations.

A Gradual Interpretation of Union Types

397

Lifting for Stratiﬁed Interpretation. We need to adapt these deﬁnitions
from AGT to our stratiﬁed setting; indeed, our Galois connection relates gradual
types with sets of sets of static types, rather than just sets of static types.

We can base our liftings of predicates and types on inclusion and pointwise

application that are extended to sets of sets.
Deﬁnition 13 (Predicate Lifting). (cid:3)P (U1, U2) ⇐⇒ ∃T1 ∈ γ(U1), T2 ∈
γ(U2), P (T1, T2) where ∈ is the existential lifting of ∈ to powersets: T ∈ T ⇐⇒
∃T ∈ T, T ∈ T
Equivalently: (cid:2)P (U1, U2) ⇐⇒ ∃T1 ∈ γ(U1),∃T2 ∈ γ(U2),∃T1 ∈ T1,∃T2 ∈ T2, P (T1, T2)
The lifting of a predicate can also be deﬁned in terms of each of the composed

interpretations:
Proposition 5. (cid:3)P (U1, U2) ⇐⇒ ∃G1 ∈ γ⊕(U1),∃G2 ∈ γ⊕(U2), (cid:3)P?(G1, G2)
where (cid:3)P? is the predicate P lifted with γ?.

The lifting of a type function f uses the pointwise application of f to all

elements of each subset of a powerset, which we note f.
Deﬁnition 14 (Function Lifting). (cid:3)f = α ◦ f ◦ γ
Again, we can deﬁne the lifting using the separate abstractions: (cid:2)f = α⊕ ◦ (cid:2)f ? ◦ γ⊕

Example Liftings. Let us look at the lifting of a type predicate and a type
function. We start with consistency, ∼, which corresponds to the lifting of type
equality: two gradual types are consistent if some static types in their concretization 
are equal.
Deﬁnition 15 (Consistency). U1 ∼ U2 if and only if ∃T1 ∈ γ(U1),∃T1 ∈
T1,∃T2 ∈ γ(U2),∃T2 ∈ T2, T1 = T2.

This deﬁnition is equivalent to the following inductive deﬁnition:

Proposition 6.

U ∼ U1

U ∼ U1 ⊕ U2

U ∼ U2

U ∼ U1 ⊕ U2

U1 ∼ U

U1 ⊕ U2 ∼ U

U2 ∼ U

U1 ⊕ U2 ∼ U
U21 ∼ U11
U12 ∼ U22
U11 → U12 ∼ U21 → U22

? ∼ U

U ∼ U
Let us now consider the (precision) meet of gradual types, which corresponds
to the lifting of the equate function used in the typing rule for conditionals. Its
algorithmic deﬁnition is:

U ∼ ?

398

M. Toro and ´E. Tanter

Deﬁnition 16 (Gradual Meet). Let (cid:21) : UType (cid:5) UType be deﬁned as:
1. U (cid:21) U = U
2. ? (cid:21) U = U (cid:21) ? = U
3. U (cid:10) (U1 ⊕ U2) = (U1 ⊕ U2)(cid:10) U =
4. (U11 → U12) (cid:21) (U21 → U22) = (U11 (cid:21) U21) → (U12 (cid:21) U22)
5. U1 (cid:21) U2 is undeﬁned otherwise.

U (cid:10) U1
U (cid:10) U2
(U (cid:10) U1) ⊕ (U (cid:10) U2)

if U (cid:10) U2 is undef ined
if U (cid:10) U1 is undef ined
otherwise

⎧

⎪

⎨

⎪

⎩

.

This algorithmic deﬁnition coincides with the lifting of equate:

Proposition 7. (cid:21) = α ◦ equate ◦ γ

4 GTFL

⊕

: Dynamic Semantics and Properties

⊕

(cid:14)(cid:14)U2

U3⇐= U1(cid:15)(cid:15)t = t if U1 = U2 = U3 ; and (cid:14)U2

U3⇐= U1(cid:15)t otherwise

⊕

⊕
⇒.

The syntax of GTFL

⊕
⇒ is a simple extension of that of GTFL

Following the tradition [29], we now give the dynamic semantics of GTFL
programs by a cast insertion translation to an internal language with explicit
⊕
⇒, which is adapted from
casts. We ﬁrst describe the internal language GTFL
the (blameless) threesome calculus of Siek et al. [28], and then present a cast
insertion translation from GTFL

to GTFL
⊕
⇒ is an adaptation of the original threesome
Intermediate Language. GTFL
calculus without blame [28]. A threesome (cid:14)T2
T3⇐= T1(cid:15) is a cast composed of
three types: the source type T1, the target type T2, and the middle type T3.
Initially, the middle type of a threesome is the greatest lower bound (in terms of
precision), or meet, of the source and target types. The key beneﬁt of threesomes
is that two threesomes can be merged into a single threesome by taking the meet
of their middle types, hence avoiding space issues [17].
, with cast expressions 
(cid:14)U2
U3⇐= U1(cid:15)u, where u denotes the simple
. For space reasons we only present a representative selection of
values of GTFL
typing rules in Fig. 3. In the typing rule for cast expressions (IT(cid:14)(cid:15)), the consistency
premises are required for a threesome to be well-formed (this is always the case by
, except that
construction). The other typing rules are basically those of GTFL
type consistency is replaced with type equality; this is because uses of consistency
will be guarded by the insertion of casts. For instance, Fig. 3 shows rule (ITapp):
typing rule (Uapp, Fig. 2) uses the premise U2 ∼ (cid:4)dom(U1), the
while the GTFL
new rule requires the type of t2 to exactly be (cid:4)dom(U1).
⊕
⇒, which are similar to [28].
Figure 4 presents the dynamic semantics of GTFL
Two threesomes that coincide on their source/target types are combined by
meeting their middle types. If the meet is undeﬁned then the term steps to
error. Otherwise both casts are merged to a new cast where the middle type is
now the meet between the middle types. Note that casts are introduced using
the following metafunction, which avoids producing useless threesomes:

U3⇐= U1(cid:15)t and casted values (cid:14)U2

⊕

⊕

⊕

⊕

A Gradual Interpretation of Union Types

399

Fig. 3. GTFL

⊕
⇒: selected typing rules

Fig. 4. GTFL

⊕
⇒: dynamic semantics of GTFL

⊕
⇒

⊕

Cast Insertion. A GTFL
program is elaborated through a type-driven cast
insertion translation. The key idea of the transformation is to insert casts in
places where consistency is used to justify the typing derivation. For instance, if
(cid:3)t : Int ⊕ Bool is used where Int is required, the translation inserts a cast (cid:14)Int ⇐
Int ⊕ Bool(cid:15)t, where t is the recursive translation of (cid:3)t. This cast plays the role of
the implicit projection from the gradual union type. Dually, when a term of type
Int is used where a gradual union is expected, the translation adds a cast that
performs the implicit injection to the gradual union, e.g. (cid:14)Int ⊕ Bool ⇐ Int(cid:15)10.
Note that a value with a cast that loses precision is like a tagged value in tagged
union type systems; the diﬀerence again is that the “tag” is inserted implicitly.
The translation judgment has the form Γ (cid:22) (cid:3)t ⇒ t : U: under type envi-
⊕
term (cid:3)t of type U, is translated to GTFL
⇒ term t. The
ronment Γ , GTFL
translation rules given in Fig. 5 are standard. Cast insertion rules use twosomes
U1(cid:7)U2⇐==== U1(cid:15)(cid:15)t: the
to ease readability; a twosome (cid:14)U2 ⇐ U1(cid:15)t is equal to (cid:14)(cid:14)U2
initial middle type is the meet of both ends [28].

⊕

400

M. Toro and ´E. Tanter

Fig. 5. Cast insertion: from GTFL

⊕

to GTFL

⊕
⇒ (selected rules)

⊕

⊕

⊕

. GTFL

satisﬁes a number of properties. First GTFL

Properties of GTFL
satisﬁes a standard type safety property:
Proposition 8 (Type safety). Suppose that · (cid:22) (cid:3)t ⇒ t : U, then either: t is a
value v; t (cid:23)−→ error; or t (cid:23)−→ t
Second, the gradual type system is a conservative extension of the static type
system; i.e. both systems coincide on fully-annotated terms.
Proposition 9 (Equivalence for fully-annotated terms). For any t ∈
Term, . (cid:22)S t : T if and only if . (cid:22) t : T

(cid:4) such that · (cid:22)i t

(cid:4) for some t

(cid:4) : U

Precision on terms, noted (cid:3)t1 (cid:8) (cid:3)t2, is the natural lifting of type precision to
terms. The gradual type system satisﬁes the static gradual guarantee of Siek
et al. [30], i.e. losing precision preserves typeability: if a program is well-typed,
then a less precise version of it also type checks, at a less precise type.
Proposition 10 (Static gradual guarantee). If . (cid:22) (cid:3)t1 : U1 and (cid:3)t1 (cid:8) (cid:3)t2, then
. (cid:22) (cid:3)t2 : U2, for some U2 such that U1 (cid:8) U2.
Similarly, losing precision preserves reduceability: a program that runs without
error continues to do so if it is annotated with less precise types.
Proposition 11 (Dynamic gradual guarantee). Suppose · (cid:22) (cid:3)t1 ⇒ t1 : U1,
· (cid:22) (cid:3)t2 ⇒ t2 : U2, and t1 (cid:8) t

1. If t1 (cid:23)−→ t2 then t
(cid:4)

2 where t2 (cid:8) t
(cid:4)

(cid:23)−→ t

(cid:4)
2.

(cid:4)
1

A technical novelty of our work is that we establish all the above properties
following a route that diﬀers from prior work. Usually, one establishes type safety
of the gradual language by ﬁrst proving type safety of the internal language and
then proving that the cast insertion translation preserves typing [29]. With this
approach, the gradual guarantees must then be established separately [30].

A Gradual Interpretation of Union Types

401

⊕

Our approach exploits the AGT methodology: we ﬁrst systematically derive
(i.e. which do not rely on a cast insertion
the direct runtime semantics of GTFL
translation). We then prove safety and the gradual guarantees, which in fact
directly follow from the abstract interpretation framework [14]. Then, we prove
that the compilation to threesome combined with the semantics of the internal
language together are equivalent to the dynamic semantics derived with AGT.
This correctness argument proceeds using logical relations.

5 Related Work

In Sect. 2, we have compared gradual unions to both tagged and untagged unions
from the standard type system literature [23], highlighting their key characteristics 
and diﬀerences. Gradual unions are unique in admitting runtime errors,
with the beneﬁts of more ﬂexible programming patterns. We have also compared
gradual unions to retroﬁtted type systems for dynamic languages with support
for unions. Note that in Flow, Typescript, CDuce and Typed Racket, a function
that expects an argument of type A + B can accept arguments of type A, B,
⊕
,
or A + B, but neither of type A + B + C nor A + D. In contrast, in GTFL
as long as two gradual union types have at least one compatible type in their
denotation, then they are compatible. So, a function that expects an argument
of type A ⊕ B accepts arguments of types such as A ⊕ B ⊕ C and A ⊕ D.

Flow-sensitive typing approaches such as occurrence typing [20] support more
precise type assignments based on the result of some (type) predicate check. Such
techniques can avoid the insertion of unnecessary casts [24]. However, in general,
the combination of gradual types with type tests raises questions regarding the
dynamic gradual guarantee [30], which have not yet been answered.
Interestingly, languages with set-theoretic (untagged) unions usually also consider 
intersection types, with distributivity relations such as (T1 ∨ T2) → T3 ≡
(T1 → T3) ∧ (T2 → T3). This law states that if a function accepts a value
that is either of type T1 or of type T2, then it behaves as both a function of
type T1 → T3 and a function of type T2 → T3. Gradual unions encompass
both interpretations, without having to resort to a notion of intersection types:
(T1 ⊕ T2) → T3 ≡ (T1 → T3) ⊕ (T2 → T3), because both types have the same
interpretation, i.e. they represent the same concrete set of static types. This
simplicity is a consequence of the optimistic interpretation with dynamic checks
that is characteristic of gradual typing. (Note that it resonates with the fact that
type precision is covariant in both positive and negative positions.)

Siek and Tobin-Hochstadt studied the interaction between gradual typing
and union types [27]. While seemingly related, the focus of their work is very
diﬀerent: the addition of the unknown type to a language with static union
types. Additionally, they only support the union of types with diﬀerent type
constructors, so for instance the union of two function types is not supported.

402

M. Toro and ´E. Tanter

Similarly, in parallel with this work, Castagna and Lanvin developed a theory
for gradual set-theoretic types, supporting union, intersection and the unknown
type [7]. Their system can express constructs similar to gradual unions by using
a combination of unions and intersection with the unknown type, e.g. Int⊕ Bool
is equivalent to (Int | Bool)&?. They also exploit AGT to derive the static semantics,
 although the more expressive setting with static unions and intersections
makes the design of the Galois connection much more challenging. Our design is
minimalist, providing a novel form of union types to languages that do not initially 
support such set-theoretic types. They mention compilation to threesomes
and proving the gradual guarantees as future work.

Jafery and Dunﬁeld [19] present a gradual language that features two types
of (datasort) reﬁnement sums, for either exhaustive or non-exhaustive matches.
Non-exhaustive matches are backed by dynamic checks in case of an unsuccessful 
match. Elements with a sum type must be explicitly injected; the sum
constructors are neither commutative nor associative. Also, they do not discuss
the interaction with the fully-unknown type.

6 Conclusion

Inspired by the interpretation of gradual types as a general approach to deal
with imprecision at the type level, and recognizing that unions types are a form
of imprecision, we proposed the novel notion of gradual union types. Gradual
unions are a new design for dealing with the possibility for expressions to have
diﬀerent, unrelated types. Accepting the possibility of runtime cast errors, gradual 
unions combine and extend the convenience of both tagged and untagged
union types. We have presented the meta-theory of gradual union types and
their interaction with the traditional unknown type, using the AGT methodology.
 We have described a compilation semantics to a threesome calculus, and
established its desired properties through logical relations. The combination of
both gradual type constructors forced us to explore a stratiﬁed approach to
AGT, whereby each gradual type constructor is interpreted separately and then
carefully composed in order to ensure optimality of the resulting abstraction.
This compositional approach to designing a gradual language is novel. We hope
that it helps understanding how to combine diﬀerent gradualization eﬀorts that
have been developed independently, and may not be fully orthogonal.

Acknowledgments. We thank Gabriel Scherer, Ronald Garcia and the anonymous
reviewers for their detailed comments and suggestions.

References

1. Abadi, M., Cardelli, L., Pierce, B., Plotkin, G.: Dynamic typing in a statically

typed language. ACM Trans. Program. Lang. Syst. 13(2), 237–268 (1991)

2. Ahmed, A., Findler, R.B., Siek, J., Wadler, P.: Blame for all. In: POPL 2011 (2011)
3. Ba˜nados Schwerter, F., Garcia, R., Tanter, ´E.: A theory of gradual eﬀect systems.

In: ICFP 2014 (2014)

A Gradual Interpretation of Union Types

403

4. Barbanera, F., Dezani-Ciancaglini, M., De’Liguoro, H.: Intersection and union

types: syntax and semantics. Inf. Comput. 119, 202–230 (1995)

5. Benzaken, V., Castagna, G., Frisch, A.: CDuce: an XML-centric general purpose

language. In: ICFP 2003 (2003)

6. Buneman, P., Pierce, B.: Union types for semistructured data. In: Connor, R.,
Mendelzon, A. (eds.) DBPL 1999. LNCS, vol. 1949, pp. 184–207. Springer, Heidelberg 
(2000). doi:10.1007/3-540-44543-9 12

7. Castagna, G., Lanvin, V.: Gradual typing with union and intersection types. In:

ICFP 2017 (2017)

8. Microsoft Corporation: Typescript

language

speciﬁcation.

https://www.

typescriptlang.org/. Accessed June 2017

9. Cousot, P., Cousot, R.: Abstract interpretation: a uniﬁed lattice model for static
analysis of programs by construction or approximation of ﬁxpoints. In: POPL 1977
(1977)

10. Disney, T., Flanagan, C.: Gradual information ﬂow typing. In: STOP 2011 (2011)
11. Facebook: Flow: a static type checker for JavaScript. https://ﬂow.org/. Accessed

June 2017

12. Frisch, A., Castagna, G., Benzaken, V.: Semantic subtyping. In: LICS 2002 (2002)
13. Garcia, R., Cimini, M.: Principal type schemes for gradual programs. In: POPL

2015 (2015)

14. Garcia, R., Clark, A.M., Tanter, ´E.: Abstracting gradual typing. In: POPL 2016

(2016)

15. Harper, P.R.: Practical Foundations for Programming Languages. Cambridge University 
Press, Cambridge (2012)

16. Henglein, F.: Dynamic typing: syntax and proof theory. Sci. Comput. Program.

22(3), 197–230 (1994)

17. Herman, D., Tomb, A., Flanagan, C.: Space-eﬃcient gradual typing. In: Trends in

Functional Programming (2007)

18. Hosoya, H., Vouillon, J., Pierce, B.C.: Regular expression types for XML. In: ICFP

2000 (2000)

19. Jafery, K.A., Dunﬁeld, J.: Sums of uncertainty: reﬁnements go gradual. In: POPL

2017 (2017)

20. Kent, A.M., Kempe, D., Tobin-Hochstadt, S.: Occurrence typing modulo theories.

In: PLDI 2016 (2016)

21. Lehmann, N., Tanter, ´E.: Gradual reﬁnement types. In: POPL 2017 (2017)
22. Pierce, B.C.: Programming with intersection types, union types, and polymorphism.
 Technical report CMU-CS-91-106 (1991)

23. Pierce, B.C.: Types and Programming Languages. MIT Press, Cambridge (2002)
24. Rastogi, A., Chaudhuri, A., Hosmer, B.: The ins and outs of gradual type inference.

In: POPL 2012 (2012)

25. Rompf, T., Amin, N.: Type soundness for dependent object types (DOT). In:

OOPSLA 2016 (2016)

26. Siek, J., Taha, W.: Gradual typing for objects. In: Ernst, E. (ed.) ECOOP
2007. LNCS, vol. 4609, pp. 2–27. Springer, Heidelberg (2007). doi:10.1007/
978-3-540-73589-2 2

27. Siek, J., Tobin-Hochstadt, S.: The recursive union of some gradual types. In:

Wadler Festschrift (2016)

28. Siek, J., Wadler, P.: Threesomes, with and without blame. In: POPL 2010 (2010)
29. Siek, J.G., Taha, W.: Gradual typing for functional languages. In: Scheme and

Functional Programming Workshop (2006)

404

M. Toro and ´E. Tanter

30. Siek, J.G., Vitousek, M.M., Cimini, M., Boyland, J.T.: Reﬁned criteria for gradual

typing. In: SNAPL 2015 (2015)

31. Tobin-Hochstadt, S., Felleisen, M.: The design and implementation of typed

scheme. In: POPL 2008 (2008)

32. Tobin-Hochstadt, S., Felleisen, M.: Logical types for untyped languages. In: ICFP

2010 (2010)

33. Toro, M., Tanter, ´E.: Gradual union types–complete deﬁnition and proofs. Technical 
report TR/DCC-2017-1, University of Chile, June 2017

