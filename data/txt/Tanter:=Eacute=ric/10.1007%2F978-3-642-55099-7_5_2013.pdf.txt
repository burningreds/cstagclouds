Effective Aspects: A Typed Monadic Embedding

of Pointcuts and Advice

Ismael Figueroa1,2,(cid:2), Nicolas Tabareau2, and Éric Tanter1,(cid:2)(cid:2)

1 PLEIAD Laboratory

University of Chile, Santiago, Chile

{ifiguero,etanter}@dcc.uchile.cl

http://pleiad.cl

2 ASCOLA Group

INRIA – Nantes, France

nicolas.tabareau@inria.fr

Abstract. Aspect-oriented programming (AOP) aims to enhance modularity and
reusability in software systems by offering an abstraction mechanism to deal with
crosscutting concerns. However, in most general-purpose aspect languages aspects 
have almost unrestricted power, eventually conﬂicting with these goals. In
this work we present Effective Aspects: a novel approach to embed the point-
cut/advice model of AOP in a statically typed functional programming language
like Haskell. Our work extends EffectiveAdvice, by Oliveira, Schrijvers, and
Cook; which lacks quantiﬁcation, and explores how to exploit the monadic setting
in the full pointcut/advice model. Type soundness is guaranteed by exploiting the
underlying type system, in particular phantom types and a new anti-uniﬁcation
type class. Aspects are ﬁrst-class, can be deployed dynamically, and the pointcut
language is extensible, therefore combining the ﬂexibility of dynamically typed
aspect languages with the guarantees of a static type system. Monads enables us
to directly reason about computational effects both in aspects and base programs
using traditional monadic techniques. Using this we extend Aldrich’s notion of
Open Modules with effects, and also with protected pointcut interfaces to external
advising. These restrictions are enforced statically using the type system. Also,
we adapt the techniques of EffectiveAdvice to reason about and enforce control
ﬂow properties. Moreover, we show how to control effect interference using the
parametricity-based approach of EffectiveAdvice. However, this approach falls
short when dealing with interference between multiple aspects. We propose a
different approach using monad views, a recently developed technique for handling 
the monad stack. Finally, we exploit the properties of our monadic weaver to
enable the modular construction of new semantics for aspect scoping and weaving.
 These semantics also beneﬁt fully from the monadic reasoning mechanisms
present in the language. This work brings type-based reasoning about effects for
the ﬁrst time in the pointcut/advice model, in a framework that is both expressive
and extensible; thus allowing development of robust aspect-oriented systems as
well as being a useful research tool for experimenting with new aspect semantics.

Keywords: aspect-oriented programming, monads, pointcut/advice model, typebased 
reasoning, modular reasoning.

(cid:2) Funded by a CONICYT-Chile Doctoral Scholarship.
(cid:2)(cid:2) Partially funded by FONDECYT project 1110051.

S. Chiba et al. (Eds.): Transactions on AOSD XI, LNCS 8400, pp. 145–192, 2014.
© Springer-Verlag Berlin Heidelberg 2014

146

I. Figueroa, N. Tabareau, and É. Tanter

1 Introduction

Aspect-oriented programming languages support the modular deﬁnition of crosscutting
concerns through a join point model [19]. In the pointcut/advice mechanism, crosscutting 
is supported by means of pointcuts, which quantify over join points, in order to
implicitly trigger advice [48]. Such a mechanism is typically integrated in an existing
programming language by modifying the language processor, may it be the compiler
(either directly or through macros), or the virtual machine. In a typed language, introducing 
pointcuts and advices also means extending the type system, if type soundness
is to be preserved. For instance, AspectML [7] is based on a speciﬁc type system in
order to safely apply advice. AspectJ [18] does not substantially extend the type system
of Java and suffers from soundness issues. StrongAspectJ [8] addresses these issues
with an extended type system. In both cases, proving type soundness is rather involved
because a whole new type system has to be dealt with.

In functional programming, the traditional way to tackle language extensions, mostly
for embedded languages, is to use monads [27]. Early work on AOP suggests a strong
connection to monads. De Meuter proposed to use them to lay down the foundations of
AOP [26], and Wand et al. used monads in their denotational semantics of pointcuts and
advice [48]. Recently, Tabareau proposed a weaving algorithm that supports monads
in the pointcut and advice model, which yields beneﬁts in terms of extensibility of
the aspect weaver [38], although in this work the weaver itself was not monadic but
integrated internally in the system. This connection was exploited in recent preliminary
work by the authors to construct an extensible monadic aspect weaver, in the context
of Typed Racket [14], but the proposed monadic weaver was not fully typed because of
limitations in the type system of Typed Racket.

This work proposes Effective Aspects: a lightweight, full-ﬂedged embedding of aspects 
in Haskell, that is typed and monadic.1 By lightweight, we mean that aspects
are provided as a small standard Haskell library. The embedding is full-ﬂedged because 
it supports dynamic deployment of ﬁrst-class aspects with an extensible pointcut 
language—as is usually found only in dynamically typed aspect languages like
AspectScheme [11] and AspectScript [45] (Sect. 3).

By typed, we mean that in the embedding, pointcuts, advices, and aspects are all statically 
typed (Sect. 4), and pointcut/advice bindings are proven to be safe (Sect. 5). Type
soundness is directly derived by relying on the existing type system of Haskell (type
classes [47], phantom types [21], and some recent extensions of the Glasgow Haskell
Compiler). Speciﬁcally, we deﬁne a novel type class for anti-uniﬁcation [32,33], which
is key to deﬁne safe aspects.

Finally, because the embedding is monadic, we derive two notable advantages over
ad hoc approaches to introducing aspects in an existing language. First, we can directly 
reason about aspects and effects using traditional monadic techniques. In short,

1 This work is an extension of our paper in the 12th International Conference on AspectOriented 
Software Development [39]. We mainly expand on using types to reason about aspect
interference (Section 7). In addition, we provide a technical background about monadic
programming in Haskell (Section 2). The implementation is available, with examples, at
http://pleiad.cl/EffectiveAspects

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

147

we can generalize the interference combinators of EffectiveAdvice [28] in the context
of pointcuts and advice (Sect. 6). And also we can use non-interference analysis techniques 
such as those from EffectiveAdvice, and from other advanced mechanisms, in
particular monad views [35] (Sect. 7). Second, because we embed a monadic weaver,
we can modularly extend the aspect language semantics. We illustrate this with several
extensions and show how type-based reasoning can be applied to language extensions
(Sect. 8). Sect. 9 discusses several issues related to our approach, Sect. 10 reviews related 
work, and Sect. 11 concludes.

2 Prelude: Overview of Monadic Programming

To make this work self-contained and to cater to readers not familiar with monads,
we present a brief overview of the key concepts of monadic programming in Haskell
used throughout this paper. More precisely, we introduce the state and error monad
transformers, and the mechanisms of explicit and implicit lifting in the monad stack.

The reader is only expected to know basic Haskell programming and to understand
the concept of type classes. As a good tutorial we suggest [20]. Readers already familiar
with monadic programming can safely skip this section.

2.1 Monads Basics

Monads [27,46] are a mechanism to embed and reason about computational effects
such as state, I/O, or exception-handling in purely functional languages like Haskell.
Monad transformers [22] allow the modular construction of monads that combine several 
effects. A monad transformer is a type constructor used to create a monad stack
where each layer represents an effect. Monadic programming in Haskell is provided
by the Monad Transformers Library (known as MTL), which deﬁnes a set of monad
transformers that can be ﬂexibly composed together.

A monad is deﬁned by a type constructor m and functions >>= (called bind) and
return. At the type level a monad is a regular type constructor, although conceptually
we distinguish a value of type a from a computation in monad m of type m a. Monads
provide a uniform interface for computational effects, as speciﬁed in the Monad type
class:

class Monad m where

return :: a → m a
(>>=) :: m a → (a → m b) → m b

Here return promotes a value of type a into a computation of type m a, and >>= is
a pipeline operator that takes a computation, extracts its value, and applies an action to
produce a new computation. The precise meanings for return and >>= are speciﬁc to
each monad. The computational effect of a monad is “hidden” in the deﬁnition of >>=,
which imposes a sequential evaluation where the effect is performed at each step. To
avoid cluttering caused by using >>= Haskell provides the do-notation, which directly

I. Figueroa, N. Tabareau, and É. Tanter

148
translates to chained applications of >>=. The x ← k expression binds identiﬁer x with
the value extracted from performing computation k for the rest of a do block.2

A monad transformer is deﬁned by a type constructor t and the lift operation, as

speciﬁed in the MonadTrans type class:

class MonadTrans t where

lift :: m a → t m a

The purpose of lift is to promote a computation from an inner layer of the monad stack,
of type m a, into a computation in the monad deﬁned by the complete stack, with type
t m a. Each transformer t must declare in an effect-speciﬁc way how to make t m an
instance of the Monad class.

2.2 Plain Monadic Programming

To illustrate monadic programming we ﬁrst describe the use of the state monad transformer 
StateT , denoted as ST, whose computational effect is to thread a value with
read-write access.

newtype ST s m a = ST (s → m (a, s))
eval ST :: ST s m a → s → m a
A ST s m a computation is a function that takes an initial state of type s and returns
a computation in the underlying monad m with a pair containing the resulting value
of type a, and a potentially modiﬁed state of type s. The eval ST function evaluates a
State s m a computation using an initial state s and yields only the returning computation 
m a. In addition, functions get ST and put ST allow to retrieve and update the
state inside a computation, respectively3.

get ST :: Monad m ⇒ ST s m s
get ST = ST $ λs → return (s, s)
put ST :: Monad m ⇒ s → ST s m ()
(cid:2) = ST $ λ → return ((), s
(cid:2))
put ST s

Note that both functions get the current state from some previous operation (>>= or
eval ST). The difference is that get ST returns this value and keeps the previous state
unchanged, whereas put ST replaces the previous state with its argument.

Example Application. Consider a mutable queue of integers with operations to enqueue
and dequeue its elements. To implement it we will deﬁne a monad stack M1, which
threads a list of integers using the ST transformer on top of the identity monad I (which
has no computational effect). We also deﬁne runM 1, which initializes the queue with
an empty list, and returns only the resulting value of a computation in M1.

2 x ← k performs the effect in k, while let x = k does not.
3 Note the use of $, here and throughout the rest of the paper, to avoid extra parentheses.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

149

type M1 = ST [Int ] I
runM 1 :: M1 a → a
runM 1 c = run I $ eval ST c [ ]

The implementation of the queue operations using M1 is simple, we just enqueue elements 
at the end of the list and dequeue elements from the beginning.

enqueue 1 :: Int → M1 ()
enqueue 1 n = do queue ← get ST

put ST $ queue ++ [n ]

dequeue 1 :: M1 Int
dequeue1 = do queue ← get ST

put ST $ tail queue
return $ head queue

Handling Error Scenarios. The above implementation of dequeue1 terminates with a
runtime error if it is performed on an empty queue, because tail fails when applied
on an empty list. To provide an error-handling mechanism we use the error monad
transformer ErrorT , denoted as ET.

newtype ET e m a = ET m (Either e a)
run ET :: Monad m ⇒ ET e m a → m (Either e a)

The type Either e a represents two possible values: a Left e value or a Right a value.
In this case the convention is that a Left e value is treated as an error, while a Right a
value is considered a successful operation. Then, the throw ET and catch ET operations
can be deﬁned to raise and handle exceptions.
throw ET :: Monad m ⇒ e → ET e m a
throw ET e = ET $ return (Left e)
catch ET :: Monad m ⇒ ET e m a → (e → ET e m a) → ET e m a
m ‘catch ET‘ h = ET $ do a ← run ET m

case a of

Left err → runET (h err )
Right val → return (Right val )

Observe that catch ET is intended to be used as an inﬁx operator, where the ﬁrst argument 
is the protected expression that would be inside a try block in Java, while the
second argument is the exception handler.

Combining State and Error-Handling Effects. To implement a queue with support for
exceptions we ﬁrst deﬁne a new monad stack M2 that combines both effects (using
Strings as error messages):

type M2 = ST [Int ] (ET String I)
runM 2 c = run I $ run ET $ eval ST c [ ]

150

I. Figueroa, N. Tabareau, and É. Tanter

Then we deﬁne the enqueue2 operation as before, but using M2:

enqueue 2 :: Int → M2 ()
enqueue 2 n = do queue ← get ST

put ST $ queue ++ [n ]

However, the straightforward deﬁnition of dequeue2 fails with a typing error:

dequeue2 :: M2 Int
dequeue2 = do queue ← get ST

if null queue

then throw ET "Queue is empty" -- typing error
else do put ST $ tail queue

return $ head queue

The problem is that throw ET returns a computation whose type is (ET String I) Int,
but the return type of dequeue2 is (ST [Int ] (ET String I)) Int.

Explicit Lifting in the Monad Stack. Using lift we can reuse a function intended for an
inner layer on the stack, like throw ET. The number of lift calls corresponds to the distance 
between the top of the stack and the inner layer of the stack. Hence for dequeue 2
we need only one call to lift :

dequeue2 :: M2 Int
dequeue2 = do queue ← get ST

if null queue

then (lift ◦ throw ET) "Queue is empty"
else do put ST $ tail queue

return $ head queue

Although we managed to implement a queue with support for both effects, this is not
satisfactory from a software engineering point of view. The reason is that plain monadic
programming and explicit liftings produce a strong coupling between functions and
particular monad stacks, hampering reusability and maintainability of the software.

2.3 Polymorphism on the Monad Stack

To address the coupling of functions with particular monad stacks and to expand the
notion of monads as a uniform interface for computational effects, the MTL deﬁnes
a set of type classes associated to particular effects. This way, monadic functions can
impose constraints in the monad stack using these type classes instead of relying on
a speciﬁc stack. These class constraints can be seen as families of monads, making a
function polymorphic with respect to the concrete monadic stack used to evaluate it.

State Operations. The MonadState type class, denoted as SM, deﬁnes the interface for
state-related operations, and ST is the canonical instance of this class.4
4 Expression m → s denotes a functional dependency [17], which means that the type of m
determines the type of s, allowing a more precise control of type inference.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

151

class Monad m ⇒ SM s m | m → s where
get :: m s
put :: s → m ()

Error-Handling Operations. The MonadError type class, denoted as EM, deﬁnes the
standard interface for error-handling operations, with ET as its canonical instance.

class Monad m ⇒ EM e m | m → e where
throwError :: e → m a
catchError :: m a → (e → m a) → m a

Implicit Lifting in the Monad Stack. Going back to our example of the integer queue,
the implementation using class contraints now is as follows:

enqueue :: (Monad m, SM [Int ] m) ⇒ Int → m ()
enqueue n = do queue ← get
dequeue :: (Monad m, SM [Int ] m, EM String m) ⇒ m Int
dequeue = do queue ← get
if null queue

put $ queue ++ [n ]

then throwError "Queue is empty"
else do put $ tail queue

return $ head queue

Observe that the functions are deﬁned in terms of an abstract monad m, which is
required to be an instance of SM, for insertions; and both SM and EM for retrieving
values. Also note that lift is not required to use throwError in dequeue. The reason
is that using type classes, like SM or EM, an operation is automatically routed to the
ﬁrst layer of the monad stack that is instance of the respective class. The MTL deﬁnes
implicit liftings between its transformers, by deﬁning several class instances for each of
them. Because of this, M2 is instance of both SM and EM.

The major limitation of implicit liftings is that it only chooses the ﬁrst layer of a
given effect. Consequently, when more than one instance of the same effect are used,
e.g. two state transformers to hold the state of a queue and a stack, the parts of the
program that access inner layers must use explicit lifting.

Explicit and implicit lifting are the standard mechanism in Haskell to handle the
monad stack. The mechanism used to handle the monad stack directly determines the
expressiveness of the type-based reasoning techniques, and other properties like modularity 
and reusability of components. This is discussed in detail in Sect. 6 and 7; in
particular we show that the standard mechanism falls short to deal with interference
of multiple aspects. Then we use monad views, a recent mechanism for managing the
monad stack developed by Schrijvers and Oliveira [35], to propose another approach to
address this situation.

152

I. Figueroa, N. Tabareau, and É. Tanter

3 Introducing Aspects

The fundamental premise for aspect-oriented programming in functional languages is
that function applications need to be subject to aspect weaving. We introduce the term
open application to refer to a function application that generates a join point, and consequently,
 can be woven.

Open Function Applications. Opening all function applications in a program or only a
few selected ones is both a language design question and an implementation question.
At the design level, this is the grand debate about obliviousness in aspect-oriented programming.
 Opening all applications is more ﬂexible, but can lead to fragile aspects and
unwanted encapsulation breaches. At the implementation level, opening all function
applications requires either a preprocessor or runtime support.

For now, we focus on quantiﬁcation—through pointcuts—and opt for a conservative
design in which open applications are realized explicitly using the # operator: f # 2
is the same as f 2, except that the application generates a join point that is subject to
aspect weaving. We will come back to obliviousness in Sect. 9.3, showing how different
answers can be provided within the context of our proposal.

Monadic Setting. Our approach to introduce aspects in a pure functional programming
language like Haskell can be realized without considering effects. Nevertheless, most
interesting applications of aspects rely on computational effects (e.g., tracing, memoization,
 exception handling, etc.). We therefore adopt a monadic setting from the start.
Also, as we show in Sect. 6 and 7, this allows us to exploit the approach of EffectiveAdvice 
[28] and other monadic reasoning mechanisms in order to perform type-based reasoning 
about effects in presence of aspects.

Illustration. As a basic example, recall the enqueue function (Sect. 2.3) and consider
the uniqueAdv advice, which enforces that the argument is only passed to proceed if
it is not already present in the underlying list l (e.g., to avoid repeated elements when
representing a set using a list);

uniqueAdv proceed arg = do l ← get

if elem arg l

then return ()
else proceed arg

Then, in program we deploy an aspect that reacts to applications of enqueue. This is
speciﬁed using the pointcut pcCall enqueue.

program n m = do deploy (aspect (pcCall enqueue) uniqueAdv )

enqueue # n
enqueue # m
showQueue

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

153

Evaluating program 1 2 returns a string representation "[1,2]" with both elements,
whereas program 1 1 returns "[1]" with only one element. Indeed, both results are as
expected. As shown in this example, aspects consist of a pointcut/advice pair and are
created with aspect, and deployed with deploy.

Our development of AOP simply relies on deﬁning aspects (pointcuts, advices), the
underlying aspect environment together with the operations to deploy and undeploy
aspects, and open function application. The remainder of this section brieﬂy presents
these elements, and the following section concentrates on the main challenge: properly
typing pointcuts and ensuring type soundness of pointcut/advice bindings.

3.1 Join Point Model

The support for crosscutting provided by an aspect-oriented programming language
lies in its join point model [24]. A join point model is composed by three elements: join
points that represents the (dynamic) steps in the execution of a program that aspects can
affect, a means of identifying join points—here, pointcuts—and a means of effecting at
join points—here, advices.

Join Points. Join points are function applications. A join point JP contains a function of
type a → m b, and an argument of type a. The monad m denotes the underlying computational 
effect stack. Note that this means that only functions that are properly lifted
to a monadic context can be advised. In addition, in order for pointcuts to be able to reason 
about the type of advised functions, we require the functions to be PolyTypeable 5.
data JP m a b = (Monad m, PolyTypeable (a → m b)) ⇒ JP (a → m b) a

From now on, we omit

the type constraints related to PolyTypeable (the
PolyTypeable constraint on a type is required each time the type has to be inspected
dynamically; exact occurrences of this constraint can be found in the implementation).

Pointcuts. A pointcut is a predicate on the current join point. It is used to identify join
points of interest. A pointcut simply returns a boolean to indicate whether it matches
the given join point.

data PC m a b = Monad m ⇒ PC (∀a

(cid:2)

(cid:2)

b

.m (JP m a

(cid:2)

(cid:2) → m Bool ))

b

(cid:2)

(cid:2)

b

A pointcut is represented as a value of type PC m a b. Types a and b are used
to ensure type safety, as discussed in Sect. 4.1. The predicate itself is a function with
(cid:2) → m Bool ), meaning it has access to the monad stack.
type ∀a
The ∀ declaration quantiﬁes on type variables a
(using rank-2 types) because a
pointcut should be able to match against any join point, regardless of the speciﬁc types
involved (we come back to this in Sect. 4.1).

.m (JP m a

and b

b

(cid:2)

(cid:2)

(cid:2)

5 Haskell provides the Typeable class to introspect monomorphic types. PolyTypeable is an

extension that supports both monomorphic and polymorphic types.

154

I. Figueroa, N. Tabareau, and É. Tanter

Pointcut Language. We provide two basic pointcut designators, pcCall and pcType, as
well as logical pointcut combinators, pcOr, pcAnd, and pcNot. A pointcut pcType f
matches all open applications to functions that have a type compatible with f (see Sect.
4.1 for a precise deﬁnition), and a pointcut pcCall f matches all open applications to f .

pcType f = PC (typePred (polyTypeOf f ))

pcCall f = PC (callPred f (polyTypeOf f ))

where typePred t = return $ λjp → return (compareType t jp)
where callPred f t = return $ λjp → return (compareFun f jp ∧
compareType t jp)

In both cases we use the polyTypeOf function (provided by PolyTypeable) to obtain
the type representation of function f , and compare it to the type of the function in the
join point using compareType. Additionally, to implement pcCall we require a notion
of function equality6. This is used in compareFun to compare the function in the join
point with the given function f . Note that in pcCall we also need to perform a type
comparison, using compareType. This is because a polymorphic function whose type
variables are instantiated in one way is equal to the same function but with type variables
instantiated in some other way (e.g. id :: Int → Int is equal to id :: Float → Float ).
Users can deﬁne their own pointcut designators. For instance, we can deﬁne controlﬂow 
pointcuts like AspectJ’s cﬂow (described in Sect. 8.1), data ﬂow pointcuts [23],
pointcuts that rely on the trace of execution [9] (Sect. 7.1), etc.

Advice. An advice is a function that executes in place of a join point matched by a
pointcut. This replacement is similar to open recursion in EffectiveAdvice [28]. An
advice receives a function (known as the proceed function) and returns a new function
of the same type (which may or may not apply the original proceed function internally).
We introduce a type alias for advice:

type Advice m a b = (a → m b) → a → m b
For instance, the type Monad m ⇒ Advice m Int Int is a synonym for the
type Monad m ⇒ (Int → m Int) → Int → m Int. For a given advice of type
Advice m a b, we call a → m b the advised type of the advice.

Aspects. An aspect is a ﬁrst-class value binding together a pointcut and an advice.
Supporting ﬁrst-class aspects is important: it makes it possible to support aspect factories,
 separate creation and deployment/undeployment of aspects, exporting opaque,
self-contained aspects as single units, etc. We introduce a data deﬁnition for aspects,
parameterized by a monad m (which has to be the same in the pointcut and advice):

data Aspect m a b c d = Aspect (PC m a b) (Advice m c d )

We defer the detailed deﬁnition of Aspect with its type class constraints to Sect. 4.2,

when we address the issue of safe pointcut/advice binding.

6 For this notion of function equality, we use the StableNames API, which relies on pointer

comparison. See Sect. 9.1 for discussion on the issues of this approach.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

155

3.2 Aspect Deployment

Aspect Environment. The list of aspects that are deployed at a given point of time
is known as the aspect environment. To be able to deﬁne the type AspectEnv as an
heterogenous list of aspects, we use an existentially quantiﬁed7, data EAspect that hides
the type parameters of Aspect:8

data EAspect m = ∀a b c d .EAspect (Aspect m a b c d )
type AspectEnv m = [EAspect m ]

This environment can be either ﬁxed initially and used globally [24], as in AspectJ,
or it can be handled dynamically, as in AspectScheme [11]. Different scoping strategies
are possible when dealing with dynamic deployment [40]. Because we are in a monadic
setting, we can pass the aspect environment implicitly using a monad. An open function
application can then trigger the set of currently deployed aspects by retrieving these
aspects from the underlying monad.

There are a number of design options for the aspect environment, depending on the
kind of aspect deployment that is desired. Following the Reader monad, we can provide 
a ﬁxed aspect environment, and add the ability to deploy an aspect for the dynamic
extent of an expression, similarly to the local method of the Reader monad. We can
also adopt a state-like monad, in order to support dynamic aspect deployment and undeployment 
with global scope. In this paper, without loss of generality, we go for the
latter.

The AT Monad Transformer. Because we are interested in using arbitrary computational
effects in programs, we deﬁne the aspect environment through a monad transformer
(Sect. 2.1), which allows the programmer to construct a monad stack of effects. The AT
monad transformer is deﬁned as follows:

newtype AT m a = AT (ST (AspectEnv (AT m)) m a) deriving (Monad )

To deﬁne the AT transformer we reuse the ST data constructor, because the AT transformer 
is essentially a state transformer (Sect. 2.2) that threads the aspect environment.
Using the GeneralizedNewtypeDeriving extension of GHC, we can automatically derive 
AT as an instance of Monad . We also deﬁne a proper instance of MonadTrans (not
shown here), and implicit liftings for the standard monad transformers of the MTL.9
Observe that the aspect environment is bound to the same monad AT m, in order to
provide aspects with access to open applications.

7 In Haskell an existentially quantiﬁed data type is declared using ∀ before the data constructor.
8 Because we cannot anticipate a ﬁxed set of class constraints for deployed aspects, we left the
type parameters unconstrained. Aspects with ad hoc polymorphism have to be instantiated
before deployment to statically solve each remaining type class constraint (see Sect. 9.2 for
more details).

9 In the rest of the paper we use the same technique to deﬁne our custom monad transformers,

hence we omit the deriving clauses and standard instance deﬁnitions, like MonadTrans.

156

I. Figueroa, N. Tabareau, and É. Tanter

Dynamic Aspect Deployment. We now deﬁne the functions for dynamic deployment,
which simply add and remove an aspect from the aspect environment:

deploy , undeploy :: EAspect (AT m) → AT m ()
deploy asp = AT $ λaenv → return ((), asp : aenv )
undeploy asp = AT $ λaenv → return ((), deleteAsp asp aenv )
Finally, in order to extract the computation of the underlying monad from an AT
computation we deﬁne the run AT function, with type Monad m ⇒ AT m a → m a
(similar to eval ST in the state monad transformer), that runs a computation in an empty
initial aspect environment. For instance, in the initial example of the enqueue function,
we can deﬁne a client as follows:

client n m = run I (run AT (program n m))

3.3 Aspect Weaving

Aspect weaving is triggered through open applications, i.e., applications performed with
the # operator, e.g., f # x .

Open Applications. We introduce a type class OpenApp that declares the # operator.
This makes it possible to overload # in certain contexts, and it can be used to declare
constraints on monads to ensure that the operation is available in a given context.

class Monad m ⇒ OpenApp m where

(#) :: (a → m b) → a → m b

The # operator takes a function of type a → m b and returns a (woven) function
with the same type. Any monad composed with the AT transformer has open application
deﬁned:

instance Monad m ⇒ OpenApp (AT m) where
f # a = AT $ λaenv → do

(woven_f , aenv
run (woven_f a) aenv

(cid:2)

(cid:2)) ← weave f aenv aenv (newjp f a)

An open application results in the creation of a join point, newjp f a, that represents
the application of f to a. The join point is then used to determine which aspects in the
environment match, produce a new function that combines all the applicable advices,
and apply that function to the original argument.

Weaving. The function to use at a given point is produced by the weave function:

weave :: Monad m ⇒ (a → AT m b) → AspectEnv (AT m) →

AspectEnv (AT m) → JP (AT m) a b → m (a → AT m b, AspectEnv (AT m))

weave f [ ] fenv
weave f (asp : asps) fenv jp =

case asp of EAspect (Aspect pc adv ) →

= return (f , fenv )

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

157

do (match, fenv

(cid:2)) ← apply_pc pc jp fenv

weave (if match

then apply_adv adv f
else f )
(cid:2)
asps fenv

jp

The weave function is deﬁned recursively on the aspect environment. For each aspect,
 it applies the pointcut to the join point. It then uses either the partial application
of the advice to f if the pointcut matches, or f otherwise10, to keep on weaving on the
rest of the aspect list. This deﬁnition is a direct adaptation of AspectScheme’s weaving 
function [11], and is also a monadic weaver [38] that supports modular language
extensions (in Sect. 8 we show how to exploit this feature).

Applying Advice. As we have seen, the aspect environment has type AspectEnv m,
meaning that the type of the advice function is hidden. Therefore, advice application
requires coercing the advice to the proper type in order to apply it to the function of the
join point:

apply_adv :: Advice m a b → t → t
apply_adv adv f = (unsafeCoerce adv ) f

The operation unsafeCoerce of Haskell is (unsurprisingly) unsafe and can yield segmentation 
faults or arbitrary results. To recover safety, we could insert a runtime type
check with compareType just before the coercion. We instead make aspects type safe
such that we can prove that the particular use of unsafeCoerce in apply_adv is always
safe. The following section describes how we achieve type soundness of aspects; Sect. 5
formally proves it.

4 Typing Aspects

Ensuring type soundness in the presence of aspects consists in ensuring that an advice
is always applied at a join point of the proper type. Note that by “the type of the join
point,” we refer to the type of the function being applied at the considered join point.

4.1 Typing Pointcuts

The intermediary between a join point and an advice is the pointcut, whose proper typing 
is therefore crucial. The type of a pointcut as a predicate over join points does not
convey any information about the types of join points it matches. To keep this information,
 we use phantom type variables a and b in the deﬁnition of PC :

data PC m a b = Monad m ⇒ PC (∀a

(cid:2)

(cid:2)

b

.m (JP m a

(cid:2)

(cid:2) → m Bool ))

b

10 apply_pc checks whether the pointcut matches the join point and returns a boolean and a
potentially modiﬁed aspect environment. Note that apply_pc is evaluated in the full aspect
environment fenv , instead of the decreasing (asp : asps) argument.

158

I. Figueroa, N. Tabareau, and É. Tanter

A phantom-type variable is a type variable that is not used on the right-hand side of
the data-type deﬁnition. The use of phantom type variables to type embedded languages
was ﬁrst introduced by Leijen and Meijer to type an embedding of SQL in Haskell [21];
it makes it possible to “tag” extra type information on data. In our context, we use it to
add the information about the type of the join points matched by a pointcut: PC m a b
means that a pointcut can match applications of functions of type a → m b. We call this
type the matched type of the pointcut. Pointcut designators are in charge of specifying
the matched type of the pointcuts they produce.

Least General Types. Because a pointcut potentially matches many join points of different 
types, the matched type must be a more general type. For instance, consider a pointcut 
that matches applications of functions of type Int → m Int and Float → m Int.
Its matched type is the parametric type a → m Int. Note that this is in fact the least
general type of both types.11 Another more general candidate is a → m b, but the least
general type conveys more precise information. As a concrete example, below is the
type signature of the pcCall pointcut designator:

pcCall :: Monad m ⇒ (a → m b) → PC m a b

Comparing Types. The type signature of the pcType pointcut designator is the same as
that of pcCall :

pcType :: Monad m ⇒ (a → m b) → PC m a b
However, suppose that f is a function of type Int → m a. We want the pointcut
pcType f to match applications of functions of more speciﬁc types, such as Int →
m Int and Int → m Char . This means that compareType actually checks that the
matched type of the pointcut is more general than the type of the join point.

Logical Combinators. We use type constraints in order to properly specify the matched
type of logical combinations of pointcuts. The intersection of two pointcuts matches
join points that are most precisely described by the principal uniﬁer of both matched
types. Since Haskell supports this uniﬁcation when the same type variable is used, we
can simply deﬁne pcAnd as follows:

pcAnd :: Monad m ⇒ PC m a b → PC m a b → PC m a b

For instance, a control ﬂow pointcut matches any type of join point, so its matched
type is a → m b. Consequently, if f is of type Int → m a, the matched type of
pcAnd (pcCall f ) (pcCﬂow g) is Int → m a.

Dually, the union of two pointcuts relies on anti-uniﬁcation [32,33], that is, the
computation of the least general type of two types. Haskell does not natively support
anti-uniﬁcation. We exploit the fact that multi-parameter type classes can be used to

11 The term most speciﬁc generalization is also valid, but we stick here to Plotkin’s original

terminology [32].

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

159

deﬁne relations over types, and develop a novel type class LeastGen (for least general)
that can be used as a constraint to compute the least general type t of two types t1 and
t2 (deﬁned in Sect. 5):

pcOr :: (Monad m, LeastGen (a → b) (c → d ) (e → f )) ⇒

PC m a b → PC m c d → PC m e f

For instance, if f is of type Int → m a and g is of type Int → m Float, the matched
type of pcOr (pcCall f ) (pcCall g) is Int → m a.

The negation of a pointcut can match join points of any type because no assumption

can be made on the matched join points:

pcNot :: Monad m ⇒ PC m a b → PC m a

(cid:2)

(cid:2)

b

Observe that the type of pcNot is quite restrictive. In fact, the advice of any aspect
with a single pcNot pointcut must be completely generic because the matched type
corresponds to fresh type variables. The matched type of pcNot can be made more
speciﬁc using pcAnd to combine it with other pointcuts with more speciﬁc types.

Open Pointcut Language. The set of pointcut designators in our language is open. Userdeﬁned 
pointcut designators are, however, responsible for properly specifying their
matched types. If the matched type is incorrect or too speciﬁc, soundness is lost.

Constraining Pointcuts to Speciﬁc Types. A pointcut cannot make any type assumption
about the type of the join point it receives as argument. The reason for this is again the
homogeneity of the aspect environment: when deploying an aspect, the type of its pointcut 
is hidden. At runtime, then, a pointcut is expected to be applicable to any join point.
The general approach to make a pointcut safe is therefore to perform a runtime-type
check, as was illustrated in the deﬁnition of pcCall and pcType in Sect. 3.1. However,
certain pointcuts are meant to be conjoined with others pointcuts that will ﬁrst apply a
sufﬁcient type condition.

In order to support the deﬁnition of pointcuts that require join points to be of a given

type, we provide the RequirePC type:

data RequirePC m a b = Monad m ⇒
b

RequirePC (∀a

(cid:2)

b

.m (JP m a

(cid:2)

(cid:2)

(cid:2) → m Bool ))

The deﬁnition of RequirePC is similar to that of PC , with two important differences.
First, the matched type of a RequirePC is interpreted as a type requirement. Second, a
RequirePC is not a valid stand-alone pointcut: it has to be combined with a standard
PC that enforces the proper type upfront. To safely achieve this, we overload pcAnd 12:

pcAnd :: (Monad m, LessGen (a → b) (c → d )) ⇒

PC m a b → RequirePC m c d → PC m a b

12 The constraint is different from the previous constraint on pcAnd . This is possible thanks to

the recent ConstraintKinds extension of GHC.

160

I. Figueroa, N. Tabareau, and É. Tanter

In this case pcAnd yields a standard PC pointcut and checks that the matched type of
the PC pointcut is less general than the type expected by the RequirePC pointcut. This
is expressed using the constraint LessGen, which, as we will see in Sect. 5, is based on
LeastGen.

To illustrate, let us deﬁne a pointcut designator pcArgGT for specifying pointcuts
that match when the argument at the join point is greater than a given n (of type a
instance of the Ord type class):

pcArgGT :: (Monad m, Ord a) ⇒ a → RequirePC m a b
pcArgGT n = RequirePC $ return (λjp →
return (unsafeCoerce (getJpArg jp) (cid:2) n))

The use of unsafeCoerce to coerce the join point argument to the type a forces us to
declare the Ord constraint on a when typing the returned pointcut as RequirePC m a b
(with a fresh type variable b). To get a proper pointcut, we use pcAnd, for instance to
match all calls to enqueue where the argument is greater than 10:

pcCall enqueue ‘pcAnd‘ pcArgGT 10

The pcAnd combinator guarantees that a pcArgGT pointcut is always applied to a
join point with an argument that is indeed of a proper type: no runtime type check is
necessary within pcArgGT , because the coercion is always safe.

4.2 Typing Aspects

The main typing issue we have to address consists in ensuring that a pointcut/advice
binding is type safe, so that the advice application does not fail. A ﬁrst idea to ensure
that the pointcut/advice binding is type safe is to require the matched type of the pointcut 
and the advised type of the advice to be the same (or rather, uniﬁable):

-- wrong!

data Aspect m a b = Aspect (PC m a b) (Advice m a b)

This approach can however yield unexpected behavior. Consider this example:

idM x = return x
adv :: Monad m ⇒ Advice (Char → m Char )
adv proceed c = proceed (toUpper c)
program = do deploy (aspect (pcCall idM ) adv )

x ← idM # ’a’
y ← idM # [True, False, True ]
return (x , y)

The matched type of the pointcut pcCall idM is Monad m ⇒ a → m a. With
the above deﬁnition of Aspect, program passes the typechecker because it is possible
to unify a and Char to Char . However, when evaluated, the behavior of program is
undeﬁned because the advice is unsafely applied with an argument of type [Bool ], for
which toUpper is undeﬁned.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

161

The problem is that during typechecking, the matched type of the pointcut and the
advised type of the advice can be uniﬁed. Because uniﬁcation is symmetric, this succeeds 
even if the advised type is more speciﬁc than the matched type. In order to address
this, we again use the type class LessGen to ensure that the matched type is less general
than the advice type:

data Aspect m a b c d = (Monad m, LessGen (a → m b) (c → m d )) ⇒

Aspect (PC m a b) (Advice m c d )

This constraint ensures that pointcut/advice bindings are type safe: the coercion performed 
in apply_adv always succeeds. We formally prove this in the following section.

5 Typing Aspects, Formally

We now formally prove the safety of our approach. We start brieﬂy summarizing the
notion of type substitutions and the is less general relation between types. Note that
we do not consider type class constraints in the deﬁnition. Then we describe a novel
anti-uniﬁcation algorithm implemented with type classes, on which the type classes
LessGen and LeastGen are based. We ﬁnally prove pointcut and aspect safety, and
state our main safety theorem.

5.1 Type Substitutions

In this section, we summarize the deﬁnition of type substitutions and introduce formally
the notion of least general type in a Haskell-like type system (without ad-hoc polymor-
phism). Thus, we have types t ::= Int, Char , . . . , t1 → t2, T t1 . . . tm, which denote 
primitive types, functions, and m-ary type constructors, in addition to user-deﬁned
types. We consider a typing environment Γ = (xi : ti)i∈N that binds variables to types.

Deﬁnition 1 (Type Substitution, from [31]). A type substitution σ is a ﬁnite mapping
from type variables to types. It is denoted [x1 (cid:8)→ t1, . . . , xn (cid:8)→ tn], where dom(σ) and
range(σ) are the sets of types appearing in the left-hand and right-hand sides of the
mapping, respectively. It is possible for type variables to appear in range(σ).
Substitutions are always applied simultaneously on a type. If σ and γ are substitutions,
 and t is a type, then σ ◦ γ is the composed substitution, where (σ ◦ γ)t = σ(γt).
Application of substitution on a type is deﬁned inductively on the structure of the type.
Substitution is extended pointwise for typing environments in the following way:
: σti)i∈N. Also, applying a substitution to a term t means to

σ(xi
apply the substitution to all type annotations appearing in t.

: ti)i∈N = (xi

Deﬁnition 2 (Less General Type). We say type t1 is less general than type t2, denoted
t1 (cid:9) t2, if there exists a substitution σ such that σt2 = t1. Observe that (cid:9) deﬁnes a
partial order on types (modulo α-renaming).

Deﬁnition 3 (Least General Type). Given types t1 and t2, we say type t is the least
general type iff t is the supremum of t1 and t2 with respect to (cid:9).

162

I. Figueroa, N. Tabareau, and É. Tanter

1 class LeastGen

(cid:2)

a b c σin σout | a b c σin → σout
-- Inductive case: The two type constructors match,
-- recursively compute the substitution for type arguments ai ,bi .

2
3
4 instance (LeastGen
LeastGen
5
T c1 . . . cn∼c)
6

(cid:2)
(cid:2)

7 ⇒ LeastGen

a1 b1 c1 σ0 σ1, . . . ,
an bn cn σn−1 σn,

(cid:2) (T a1 . . . an ) (T b1 . . . bn ) c σ0 σn

-- Default case: The two type constructors don’t match, c has to be a variable,
-- either unify c with c

(cid:2) (cid:7)→ (a, b), or extend the substitution with c (cid:7)→ (a, b)

(cid:2)

8
if c
9
10 instance (Analyze c (TVar c),
(cid:2) (a, b),
11
12

MapsTo σin c
VarCase c

13 ⇒ LeastGen

(cid:2)

(cid:2) (a, b) c σin σout)

a b c σin σout

Fig. 1. The LeastGen

(cid:2)

type class. An instance holds if c is the least general type of a and b.

5.2 Statically Computing Least General Types

In an aspect declaration, we statically check the type of the pointcut and the type of
the advice to ensure a safe binding. To do this we encode an anti-uniﬁcation algorithm
at the type level, exploiting the type class mechanism. A multi-parameter type class
R t1 . . . tn can be seen as a relation R on types t1 . . . tn, and instance declarations as
ways to inductively deﬁne this relation, in a manner very similar to logic programming.
The type classes LessGen and LeastGen used in Sect. 4 are deﬁned as particular
, shown in Fig. 1. This class is deﬁned in
cases of the more general type class LeastGen
line 1 and is parameterized by types a, b, c, σin, and σout. Note that σout is functionally
dependent on a, b, c, and σin; and that there is no where keyword because the class
declares no operations. Both σin and σout denote substitutions encoded at the type
level as a list of mappings from type variables to pairs of types. We use pairs of types
in substitutions because we have to simultaneously compute substitutions from c to a
and from c to b.

(cid:2)

To be concise, lines 4-7 present a single deﬁnition parametrized by the type constructor 
arity but in practice, there needs to be a different instance declaration for each
type constructor arity.

Proposition 1. If LeastGen
and σoutc = (a, b).

(cid:2)

a b c σin σout holds, then substitution σout extends σin

Proof. By induction on the type representation of a and b.

A type can either be a type variable, represented as T V ar a, or an n-ary type constructor 
T applied to n type arguments13. The rule to be applied depends on whether
the type constructors of a and b are the same or not.

(i) If the constructors are the same, then the rule deﬁned in lines 4-7 computes
(T c1 . . . cn) using the induction hypothesis that σici = (ai, bi), for i = 1 . . . n. The

13 We use the Analyze type class from P olyT ypeable to get a type representation at the type

level. For simplicity we omit the rules for analyzing type representations.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

163

component-wise application of constraints is done from left to right, starting from substitution 
σ0 and extending it to the resulting substitution σn. The type equality constraint
(T c1 . . . cn) ∼ c checks that c is uniﬁable with (T c1 . . . cn) and, if so, uniﬁes them.
Then, we can check that σnc = (a, b).

(ii) If the type constructors are not the same the only possible generalization is a type
variable. In the rule deﬁned in lines 10-13 the goal is to extend σin with the mapping
c (cid:8)→ (a, b) such that σoutc = (a, b), while preserving the injectivity of the substitution
(cid:11)(cid:12)
(see next proposition).

Proposition 2. If σin is an injective function, and LeastGen
then σout is an injective function.

(cid:2)

a b c σin σout holds,

(cid:2)

Proof. By construction LeastGen
introduces a binding from a fresh type variable to
(a, b), in the rule deﬁned in lines 10-13, only if there is no type variable already mapping
to (a, b)—in which case σin is not modiﬁed.

is N one.

To do this, we ﬁrst check that c is actually a type variable (T V ar c) by checking its
to the (possibly
representation using Analyze. Then in relation M apsT o we bind c
inexistent) type variable that maps to (a, b) in σin. In case there is no such mapping,
then c
Finally, relation V arCase binds σout to σin extended with {c (cid:8)→ (a, b)} in case
(cid:2)
is N one, otherwise σout = σin. It then uniﬁes c with c
. In all cases c is bound to
c
the variable that maps to (a, b) in σout, because it was either uniﬁed in rule M apsT o
or in rule V arCase. The hypothesis that σin is injective ensures that any preexisting
(cid:11)(cid:12)
mapping is unique.

(cid:2)

(cid:2)

(cid:2)

Proposition 3. If σin is an injective function, and LeastGen
then c is the least general type of a and b.

(cid:2)

a b c σin σout holds,

Proof. By induction on the type representation of a and b.

(i) If the type constructors are different the only generalization possible is a type

variable c.

(ii) If the type constructors are the same, then a = T a1 . . . an and b = T b1 . . . bn.
By Proposition 1, c = T c1 . . . cn generalizes a and b with the substitution σout. By
induction hypothesis ci is the least general type of (ai, bi).
Now consider a type d that also generalizes a and b, i.e. a (cid:9) d and b (cid:9) d, with associated 
substitution α. We prove c is less general than d by constructing a substitution
τ such that τ d = c.
Again, there are two cases, either d is a type variable, in which case we set τ =
{d (cid:8)→ c}, or it has the same outermost type constructor, i.e. d = T d1 . . . dn. Thus
ai (cid:9) di and bi (cid:9) di; and because ci is the least general type of ai and bi, there exists
a substitution τi such that τidi = ci, for i = 1 . . . n.
Now consider a type variable x ∈ dom(τi) ∩ dom(τj ). By deﬁnition of α, we
know that σout(τi(x)) = α(x) and σout(τj (x)) = α(x). Because σout is injective
(by Proposition 2), we deduce that τi(x) = τj(x) so there are no conﬂicting mappings
between τi and τj, for any i and j. Consequently, we can deﬁne τ =
τi and check
(cid:11)(cid:12)
that τ d = c.

(cid:2)

164

I. Figueroa, N. Tabareau, and É. Tanter

Deﬁnition 4 (LeastGen type class). To compute the least general type c for a and b,
we deﬁne:

LeastGen a b c (cid:3) LeastGen

(cid:2)

a b c σempty σout, where σempty is the empty

substitution and σout is the resulting substitution.

Deﬁnition 5 (LessGen type class). To establish that type a is less general than type b,
we deﬁne:

LessGen a b (cid:3) LeastGen a b b

5.3 Pointcut Safety

We now establish the safety of pointcuts with relation to join points.

Deﬁnition 6 (Pointcut match). We deﬁne the relation matches(pc, jp), which holds
iff applying pointcut pc to join point jp in the context of a monad m yields a computation
m T rue.

Deﬁnition 7 (Safe user-deﬁned pointcut). Given a join point term jp and type environment 
Γ , a user-deﬁned pointcut is safe if:
Γ (cid:15) pc : P C m a b
Γ (cid:15) jp : JP m a
(cid:2)
(cid:2)
b
Γ (cid:15) matches(pc, jp)
(cid:2) → m b
implies that a

(cid:2) (cid:9) a → m b.

Now we prove that the matched type of a given pointcut is more general than the join
points matched by that pointcut.

Proposition 4. Given a join point term jp and a pointcut term pc, and type environment
Γ ; and that if pc is user-deﬁned, then it is safe (according to Deﬁnition 7). Then, if
Γ (cid:15) pc : P C m a b
Γ (cid:15) jp : JP m a
(cid:2)
(cid:2)
b
Γ (cid:15) matches(pc, jp)
then a

(cid:2) (cid:9) a → m b.

(cid:2) → m b

Proof. By induction on the matched type of the pointcut.

– Case pcCall : By construction the matched type of a pcCall f pointcut is the type of
f . Such a pointcut matches a join point with function g if and only if: f is equal to
g, and the type of f is less general than the type of g. (On both pcCall and pcType
this type comparison is performed by compareType on the type representations of
its arguments.)

– Case pcType: By construction the matched type of a pcType f pointcut is the type
of f . Such a pointcut only matches a join point with function g whose type is less
general than the matched type.

– Case pcAnd on PC PC : Consider pc1 ‘pcAnd ‘ pc2. The matched type of the combined 
pointcut is the principal uniﬁer of the matched types of the arguments—which
represents the intersection of the two sets of join points. The property holds by the
induction hypothesis applied to pc1 and pc2.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

165

– Case pcAnd on PC RequirePC : Consider pc1 ‘pcAnd ‘ pc2. The matched type of
the combined pointcut is the type of pc1 and it is checked that the type required by
pc2 is more general so the application of pc2 will not yield an error. The property
holds by induction hypothesis on pc1.

– Case pcOr: Consider pc1 ‘pcOr ‘ pc2. The matched type of the combined pointcut
is the least general type of the matched types of the argument, computed by the
LeastGen constraint—which represents the union of the two sets of join points.
The property holds by induction hypothesis on pc1 and pc2.

– Case pcNot: The matched type of a pointcut constructed with pcNot is a fresh type
(cid:11)(cid:12)

variable, which by deﬁnition is more general than the type of any join point.

5.4 Advice Type Safety

If an aspect is well-typed, then the advised type of the advice is more general than the
matched type of the pointcut:

Proposition 5. Given a pointcut term pc, an advice term adv , and a type environment
Γ , if
Γ (cid:15) pc : P C m a b
Γ (cid:15) adv : Advice m c d
Γ (cid:15) (aspect pc adv) : Aspect m a b c d
then a → m b (cid:9) c → m d.
Proof. Using the deﬁnition of Aspect (Sect. 4.2) and because Γ (cid:15) (aspect pc adv) :
Aspect m a b c d, we know that the constraint LessGen is satisﬁed, so by Deﬁnitions 4
and 5, and Proposition 1, a → m b (cid:9) c → m d.
(cid:11)(cid:12)

5.5 Safe Aspects

We now show that if an aspect is well-typed, then the advised type of the advice is more
general than the type of join points matched by the corresponding pointcut:

Theorem 1 (Safe Aspects). Given the terms jp, pc, and adv representing a join point,
a pointcut and an advice respectively, given a type environment Γ ; and assuming that
if pc is a user-deﬁned pointcut, then it is safe (according to Deﬁnition 7). Then, if
Γ (cid:15) pc : P C m a b
Γ (cid:15) adv : Advice m c d
Γ (cid:15) (aspect pc adv) : Aspect m a b c d
and
Γ (cid:15) jp : JP m a
(cid:2)
b
Γ (cid:15) matches(pc, jp)
then a
Proof. By Proposition 4 and 5 and the transitivity of (cid:9).

(cid:2) (cid:9) c → m d.

(cid:11)(cid:12)

(cid:2)

(cid:2) → m b

166

I. Figueroa, N. Tabareau, and É. Tanter

module Fib (ﬁb, pcFib) where
import AOP
pcFib = pcCall ﬁbBase ‘pcAnd ‘ pcArgGT 2
ﬁbBase n = return 1
ﬁbAdv proceed n = do f1 ← ﬁbBase # (n − 1)
f2 ← ﬁbBase # (n − 2)
return (f1 + f2 )

ﬁb :: Monad m ⇒ m (Int → m Int)
ﬁb = do deploy (aspect pcFib ﬁbAdv )

return $ ﬁbBase #

Fig. 2. Fibonacci module

Corollary 1 (Safe Weaving). The coercion of the advice in apply_adv is safe.

Proof. Recall apply_adv (Sect. 3.3):

apply_adv :: Advice m a b → t → t
apply_adv adv f = (unsafeCoerce adv ) f

By construction, apply_adv is used only with a function f that comes from a join
point that is matched by a pointcut associated to adv . Using Theorem 1, we know that
(cid:2) (cid:9) a → m b. We note σ the
the join point has type JP m a
associated substitution. Then, by compatibility of substitutions with the typing judgement 
[31], we deduce σΓ (cid:15) σadv : Advice m a
(cid:2)
. Therefore, (unsafeCoerce adv )
(cid:11)(cid:12)
corresponds exactly to σadv, and is safe.

(cid:2) → m b

and that a

(cid:2)

b

(cid:2)

(cid:2)

b

6 Open and Protected Modules, with Effects

This section illustrates how we can exploit the monadic embedding of aspects to encode 
Open Modules [2] extended with effects. Additionally, we present the notion of
protected pointcuts, which are pointcuts whose type places restrictions on admissible
advice. We illustrate the use of protected pointcuts to enforce control ﬂow properties of
external advice, reusing the approach of EffectiveAdvice [28].

6.1 A Simple Example

We ﬁrst describe a simple example that serves as the starting point. Figure 2 describes a
Fibonacci module, following the canonical example of Open Modules. The module uses
an internal aspect to implement the recursive deﬁnition of Fibonacci: the base function,
ﬁbBase, simply implements the base case; and the ﬁbAdv advice implements recursion 
when the pointcut pcFib matches. Note that pcFib uses the user-deﬁned pointcut
pcArgGT (deﬁned in Sect. 4.1) to check that the call to ﬁbBase is done with an argument 
greater than 2. The ﬁb function is deﬁned by ﬁrst deploying the internal aspect,
and then partially applying # to ﬁbBase. This transparently ensures that an application

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

167

module MemoizedFib (ﬁb) where
import qualiﬁed Fib
import AOP
memo proceed n =
do table ← get

if member n table

then return (table ! n)
else do y ← proceed n

(cid:2) ← get

table
put (insert n y table
return y

(cid:2))

ﬁb = do deploy (aspect Fib.pcFib memo)

Fib.ﬁb

Fig. 3. Memoized Fibonacci module

of ﬁb is open. The ﬁb function is exported, together with the pcFib pointcut, which can
be used by an external module to advise applications of the internal ﬁbBase function.
Figure 3 presents a Haskell module that provides a more efﬁcient implementation of
ﬁb by using a memoization advice. To beneﬁt from memoization, a client only has to
import ﬁb from the MemoizedFib module instead of directly from the Fib module.

Note that if we consider that the aspect language only supports the pcCall pointcut
designator, this implementation actually represents an open module proper. Preserving 
the properties of open modules, in particular protecting from external advising of
internal functions, in presence of arbitrary quantiﬁcation (e.g., pcType, or an alwaysmatching 
pointcut) is left for future work. Importantly, just like Open Modules, the approach 
described here does not ensure anything about the advice beyond type safety. In
particular, it is possible to create an aspect that incorrectly calls proceed several times,
or an aspect that has undesired computational effects. Fortunately, the type system can
assist us in expressing and enforcing speciﬁc interference properties.

6.2 Protected Pointcuts

In order to extend Open Modules with effect-related enforcement, we introduce the notion 
of protected pointcuts, which are pointcuts enriched with restrictions on the effects
that associated advice can exhibit. Simply put, a protected pointcut embeds a combinator 
that is applied to the advice in order to build an aspect. If the advice does not
respect the (type) restrictions expressed by the combinator, the aspect creation expression 
simply does not typecheck and hence the aspect cannot be built. A combinator is
any function that can produce an advice:

type Combinator t m a b = Monad m ⇒ t → Advice m a b

The protectPC function packs together a pointcut and a combinator:

168

I. Figueroa, N. Tabareau, and É. Tanter

protectPC :: (Monad m, LessGen (a → m b) (c → m d )) ⇒

PC m a b → Combinator t m c d → ProtectedPC m a b t c d

A protected pointcut, of type ProtectedPC , cannot be used with the standard aspect
creation function aspect. The following pAspect function is the only way to get an
aspect from a protected pointcut (the constructor PPC is not exposed):

pAspect :: Monad m ⇒ ProtectedPC m a b t c d → t → Aspect m a b c d
pAspect (PPC pc comb) adv = aspect pc (comb adv )

The key point here is that when building an aspect using a protected pointcut, the combinator 
comb is applied to the advice adv . We now show how to exploit this extension
of Open Modules to restrict control ﬂow properties, using the proper type combinators.
The next section describes how to control computational effects.

6.3 Enforcing Control Flow Properties

Rinard et al. present a classiﬁcation of advice in four categories depending on how they
affect the control ﬂow of programs [34]:

– Combination: The advice can call proceed any number of times.
– Replacement: There are no calls to proceed in the advice.
– Augmentation: The advice calls proceed exactly once, and it does not modify the

arguments to or the return value of proceed.

– Narrowing: The advice calls proceed at most once, and does not modify the arguments 
to or the return value of proceed.

In EffectiveAdvice [28], Oliveira and colleagues show a type-based enforcement of
these categories, through advice combinators (Fig. 4). These combinators ﬁt the general 
Combinator type we described in Sect. 6.2, and can therefore be embedded in
protected pointcuts. Observe that no combinator is needed for combination advice, because 
no interference properties are enforced. Replacement advice is advice that has no
access to proceed . Augmentation advice is represented by a pair of before/after advice
functions, such that after has access to the argument, the return value, and an extra
value optionally exposed by the before function. A narrowing advice is in fact the combination 
of both a replacement advice and an augmentation advice, where the choice
between both is driven by a runtime predicate.

As an illustration, observe that memoization is a typical example of a narrowing
advice: the combination of a replacement advice (“return memoized value without pro-
ceeding”) and an augmentation advice (“proceed and memoize return value”), where
the choice between both is driven by a runtime predicate (“is there a memoized value
for this argument?”). Therefore, it is now straightforward for the Fib module to expose
a protected pointcut that restricts valid advice to narrowing advice only:

module Fib (ﬁb, ppcFib) where
ppcFib = protectPC pcFib narrow
. . .

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

169

type Replace m a b = (a → m b)
replace :: Replace m a b → Advice m a b
replace radv proceed = radv
type Augment a b c m = (a → m c, a → b → c → m ())
augment :: Monad m ⇒ Augment a b c m → Advice m a b
augment (before, after ) proceed arg =

do c ← before arg
b ← proceed arg
after arg b c
return b

type Narrow m a b c = (a → m Bool, Augment m a b c, Replace m a b)
narrow :: Monad m ⇒ Narrow m a b c → Advice m a b
narrow (p, aug, rep) proceed x =

do b ← p x

if b then replace rep proceed x

else augment aug proceed x

Fig. 4. Replacement, augmentation and narrowing advice combinators (adapted from [28])

memo :: (SM (Map a b) m, Ord a) ⇒ Narrow a b () m
memo = (pred , (before, after ), rep) where

pred n
before
after n r = do {table ← get ; put (insert n r table)}
rep x

= do {table ← get ; return (member n table)}
= return ()
= do {table ← get ; return (table ! n)}

Fig. 5. Memoization as a narrowing advice (adapted from [28])

The protected pointcut ppcFib embeds the narrow type combinator. Hence, only
advice that can be statically typed as narrowing advice can be bound to that pointcut. A
valid deﬁnition of the memo advice is given in Fig. 5. Note that the protected pointcut is
only restrictive with respect to the control ﬂow effect of the advice, but not with respect
to its computational effect: any monad m is accepted.

Finally, note that this approach is not limited to the four categories of Rinard et
al.; custom kinds of advice can be deﬁned in a similar way. For instance, we consider
adaptation advice as a weaker version of narrowing where the advice is allowed to
modify the arguments to proceed. The implementation is straightforward:

type Adaptation a b c m = (a → a, a → m c, a → b → c → m ())
adapt :: Adaptation a b c m → Advice m a b
adapt (adapter , before, after ) proceed arg =

augment (before, after ) proceed (adapter arg)

A relevant design choice is whether the adapter function is pure or is allowed to perform 
effects. This choice affects which properties can be statically checked based on

170

I. Figueroa, N. Tabareau, and É. Tanter

the type of the advice. Allowing effects is more expressive, but it is source of potential
interferences, in addition to advices and pointcuts. The next section describes how to
control effect interference between these components.

7 Controlling Effect Interference

The monadic embedding of aspects also enables reasoning about computational effects.
We are particularly interested in reasoning about effect interference between components 
of a system: aspects, base programs, and combinations thereof. To do this, in
Section 7.1 we ﬁrst show how to adapt the non-interference types deﬁned in EffectiveAdvice 
[28], which distinguish between aspect and base computation. The essence
of this technique is to use parametricity to forbid components from making assumptions
about some part of the monad stack. Then, because components must work uniformly
over the restricted section of the stack, they can only utilize effects available in the
non-restricted section.

However, this approach falls short when considering several aspects in a system,
because aspects (and base programs) can still interfere between them. In Section 7.2
we show how a reﬁnement of the technique can be used to address this situation, but
that unfortunately is impractical because it requires explicit liftings and strongly couples 
components to particular shapes of the monad stack—hampering modularity and
reusability.

Finally, we show in Section 7.4 a different approach to enforce non-interference
based on monad views [35], a recently developed mechanism for handling the monad
stack, which is summarized in Section 7.3.

7.1 Distinguishing Aspect and Base Computation

To illustrate the usefulness of distinguishing between aspect and base computation,
consider a Fibonacci module where the internal calls throw an exception when given a
negative integer as argument. In that situation, it is interesting to ensure that the external
advice bound to the exposed pointcut cannot throw or catch those exceptions.

Following EffectiveAdvice [28], we can enforce an advice to be parametric with
respect to a monad used by base computation, effectively splitting the monad stack into
two. To this end we deﬁne the NIAT (NI stands for non-interference) type:

newtype NIAT t m a = NIAT (ST (AspectEnv (NIAT t m)) (t m) a)

Observe that NIAT splits the monad stack into an upper part t, with the effects available 
to aspects; and a lower part m, with the effects available to base computation. We
extend other deﬁnitions (weave, deploy, etc.) accordingly.

Note that NIAT is a proper monad, but not a monad transformer. This is because the
MonadTrans class is designed for a type constructor t that is applied to some monad
m, but NIAT takes two types as arguments. We could deﬁne the partial application
NIAT t as a monad transformer, but this is inconvenient because explicit lift operations
would skip the upper layer of the stack14. However, for allowing explicit lifting into

14 Because we would lift from m to (NIAT t) m.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

171

NIAT we need an operation to transform a computation from t m into an NIAT t m
computation. To this end we provide the niLift operation as follows:

niLift :: Monad (t m) ⇒ t m a → NIAT t m a
niLift ma = NIAT $ ST $ λaenv → do

a ← ma
return (a, aenv )

Effect Interference and Pointcuts. The novelty compared to EffectiveAdvice is that we
also have to deal with interferences for pointcuts. But to allow effect-based reasoning
on pointcuts, we need to distinguish between the monad used by the base computation
and the monad used by pointcuts. Indeed, in the interpretation of the type PC m a b,
m stands for both monads, which forbids to reason separately about them. To address
this issue, we need to interpret PC m a b differently, by saying that the matched
type is a → b instead of a → m b. In this way, the monad for the base computation
(which is implicitly bound by b) does not have to be m at the time the pointcut is
deﬁned. To accommodate this new interpretation with the rest of the code, very little
changes have to be made15. Mainly, the types of pcCall , pcType and the deﬁnition of
Aspect:

pcCall , pcType :: Monad m ⇒ (a → b) → PC m a b
data Aspect m a b c d = (Monad m, LessGen (a → b) (c → m d )) ⇒

Aspect (PC m a b) (Advice m c d )

Note how the deﬁnition of Aspect forces the monad of the pointcut computation to
be uniﬁed with that of the advice, and with that of the base code. The results of Sect. 5
can straightforwardly be rephrased with these new deﬁnitions.

Typing Non-interfering Pointcuts and Advices. Using rank-2 types [30] we can restrict
the type of pointcuts and advices. The following types synonyms guarantee that noninterfering 
pointcuts (NIPC ) and advices (NIAdvice) only use effects available in t.

= ∀m.(Monad m, MonadTrans t ) ⇒
type NIPC t a b
type NIAdvice t a b = ∀m.(Monad m, MonadTrans t ) ⇒

PC (NIAT t m) a b

Advice (NIAT t m) a b

By universally quantifying over the type m of the effects used in the base computation,
 these types enforce, through the properties of parametricity, that pointcuts
or advices cannot refer to speciﬁc effects in the base program. We can deﬁne aspect
construction functions that enforce different (non-)interference patterns, such as noninterfering 
pointcut NIPC with unrestricted advice Advice, unrestricted pointcut PC
with non-interfering advice NIAdvice, etc.

15 The implementation available online uses this interpretation of PC m a b.

172

I. Figueroa, N. Tabareau, and É. Tanter

module FibErr (ﬁb, ppcFib) where
import AOP
pcFib = pcCall ﬁbBase ‘pcAnd ‘ pcArgGT 2
ppcFib = protectPC pcFib niAdvice
ﬁbBase n = return 1
ﬁbAdv proceed n = do f1 ← errorFib # (n − 1)
f2 ← errorFib # (n − 2)
return (f1 + f2 )

ﬁb = do deploy (aspect pcFib ﬁbAdv )
errorFib :: (MonadTrans t, EM String m) ⇒ Int → NIAT t m Int
errorFib n = if n < 0

return errorFib

then (niLift ◦ lift ◦ throwError )“Error : negative argument
else

ﬁbBase # n

(cid:2)(cid:2)

Fig. 6. Fibonacci with error

Enforcing Non-interference. Coming back to Open Modules and protected pointcuts,
to enforce non-interfering advice we need to deﬁne a typed combinator that requires an
advice of type NIAdvice:

niAdvice :: (Monad (t m), Monad m) ⇒

NIAdvice t a b → Advice (NIAT t m) a b

niAdvice adv = adv

Observe that the niAdvice combinator is computationally the identity function, but it
does impose a type requirement on its argument. Using this combinator, a module can
expose a protected pointcut that enforces non-interference with base effects.

Fibonacci Module with Error Handling. We now deﬁne a Fibonacci module (Fig. 6)
where base functions ﬁbBase and ﬁbAdv raise an exception when given a negative
argument.16 The exception is raised on monad m that corresponds to base computation,
and which is required to be an instance of EM. The deﬁnition of ppcFib enforces that
external advice cannot manipulate exceptions in m, because it uses the niAdvice advice
combinator. The drawback is that because we are using an effect in an inner layer of the
stack, we need to use explicit lifting to satisfy the expected type.

Non-interfering Base Computation. Symmetrically, we can check that a part of the
base code cannot interfere with effects available to aspects by using the type synonym
NIBase, which universally quantiﬁes over the type t of effects available to the advice:

type NIBase m a b = ∀t .(Monad m, MonadTrans t , Monad (t m)) ⇒

a → NIAT t m b

16 We do not use an error-checking argument on purpose, for the sake of illustration. We use such

an aspect in Sect. 7.2 where we consider the issues of multiple effectful aspects.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

173

Reasoning about Pointcut Interference. Another use of effect reasoning can be done
at the level of pointcuts. Indeed, in the monadic embedding of aspects, we allow for
effectful pointcuts. For example, we can deﬁne a sequential pointcut combinator [10]
pcSeq pc 1 pc2, that matches ﬁrst pc1 and then pc2:

pcSeq :: (SM Bool m) ⇒ PC m a b → PC m c d → PC m c d
pcSeq (PC mpc1) (PC mpc2) =
PC $ do pc1 ← mpc1
pc2 ← mpc2
return $ λjp → do b ← get

if b then pc2 jp

else do b

(cid:2) ← pc1 jp
put b
return False

(cid:2)

As expressed in the SM Bool m constraint, the pointcut requires a boolean state in
which to store the current point of its matching behavior: False (resp. True) means
pc1 (resp. pc2) is to be matched. Consequently, any base program that modiﬁes this
state will alter the behavior of the pointcut. This situation can be avoided by using the
non-interfering base computation type NIBase, just described above.

7.2 Interference between Multiple Aspects

NIAT only distinguishes between base and aspect computation. Although useful, this
implies that interference between aspects is still possible because all of them will share
the same upper part of the monad stack. A similar situation happens with base programs
and the lower part of the monad stack.

To illustrate this issue, consider a Fibonacci module program that uses the memo
advice to improve the performance, and also uses a checkArg advice that throws an
exception when given a negative argument (instead of a base code check as in Fig. 6). In
this setting, checkArg could update the cache with incorrect values, either accidentally
or intentionally; or conversely, memo could throw arbitrary exceptions, even with a
non-negative argument.

Finer-Grained Splitting of the Monad Stack. Following the idea used in NIAT, to enforce 
non-interference between memo and checkArg we need to split the monad stack
into the monad for base computation m, and two upper layers t1 and t2. The idea is
to assign to each aspect a unique layer in the stack, and to use parametricity to ensure
non-interference. To this end we deﬁne the NIAT2 monad, which splits the monad stack
as described. We also consider niLift 2, which serves the same role as niLift.

newtype NIAT2 t1 t2 m a =

NIAT2 (ST (AspectEnv (NIAT2 t1 t2 m)) (t1 (t2 m)) a)

Again, we extend other deﬁnitions properly (weave, etc.). Using rank-2 types, the following 
type synonyms guarantee that non-interfering pointcuts and advices access can

174

I. Figueroa, N. Tabareau, and É. Tanter

only access the effect available in the ﬁrst layer L1, which corresponds to t1; or in the
second layer L2, which corresponds to t2.

type NIPC L1

t1 a b = ∀t2 m.(Monad m, MonadTrans t1,
t2 a b = ∀t1 m.(Monad m, MonadTrans t1,
type NIPC L2
type NIAdvice L1 t1 a b = ∀t2 m.(Monad m, MonadTrans t1,
type NIAdvice L2 t2 a b = ∀t1 m.(Monad m, MonadTrans t1,

MonadTrans t2) ⇒ PC (NIAT2 t1 t2 m) a b
MonadTrans t2) ⇒ PC (NIAT2 t1 t2 m) a b
MonadTrans t2) ⇒ Advice (NIAT2 t1 t2 m) a b
MonadTrans t2) ⇒ Advice (NIAT2 t1 t2 m) a b

Non-interference Combinators. To enforce non-interference properties we need to deﬁne 
advice combinators, as we did with niAdvice. Again, we can enforce different
non-interference patterns, by deﬁning as many construction functions as required. We
describe the advice combinators niAdvice L1 and niAdvice L2 that enforce that aspects
work exclusively with the effect provided by the ﬁrst and second layer, respectively.

niAdvice L1 :: (Monad m, MonadTrans t1, MonadTrans t2) ⇒
NIAdvice L1 t1 a b → Advice (NIAT2 t1 t2 m) a b
niAdvice L1 adv = adv
niAdvice L2 :: (Monad m, MonadTrans t1, MonadTrans t2) ⇒
NIAdvice L2 t2 a b → Advice (NIAT2 t1 t2 m) a b

niAdvice L2 adv = adv

Now we deﬁne the monad stack S that provides the state and error-handling effects.

type S = NIAT2 (ET String) (ST (Map Int Int)) I

Then, we deﬁne the new ﬁbonacci function using the checkArg L1 and memoL2 advices,
which operate on the ﬁrst and second layer of the monad stack, respectively.

ﬁbMemoErr :: Int → S Int
ﬁbMemoErr n = do deploy (aspect pcFib (niAdvice L2 memoL2 ))
f ← ﬁb
deploy (aspect (pcCall f ) (niAdvice L1 checkArg L1
f # n

))

The implementation of checkArg L1 is as follows:

checkArg L1 proceed arg =

if arg < 0

then (niLift 2 ◦ throwError ) "Error: negative argument"
else proceed arg

And similarly, we deﬁne memoL2:

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

175

memoL2 proceed n =

do table ← niLift 2 $ lift $ get

if member n table

then return (table ! n)
else do y ← proceed n

(cid:2) ← niLift 2 $ lift $ get

table
(niLift 2 ◦ lift ◦ put ) (insert n y table
return y

(cid:2))

Note that checkArg L1 is applied on calls to the external ﬁbonacci function f , while
memoL2 is applied to the internal calls of the Fibonacci module, exposed by pcFib.

While an improvement over the binary base/aspect approach of EffectiveAdvice,
illustrated in Section 7.1, this approach has two major drawbacks. First, it is not scalable 
because we need a different NIATn monad to support a setting with n mutually
exclusive effects for aspects. Second, it is necessary to use explicit lifting in the implementation 
of advice. The reason is that we are explicitly using an effect from a layer
at an arbitrary position in monad stack. Because we need to preserve parametricity to
enforce non-interference, an advice cannot make any assumptions on the monad transformers 
that compose the stack. In particular, it cannot assume that the transformers
support implicit liftings from the inner layers of the stack. In fact, in the presence of
implicit lifting the layer from which an effect comes depends on the concrete monad
stack used. These issues hamper modularity and reusability of aspects. In general, there
is a tension between implicit lifting—designed to make a layer provide several effects
at once—and splitting the monad stack with one aspect/effect per layer. In Section 7.4
we address these issues by using monad views [35].

7.3 Interlude: Monad Views

Monad views, recently developed by Schrijvers and Oliveira [35], are a technique for
handling the monad stack, which extends and complements the standard mechanisms
of explicit and implicit liftings (Section 2). Monad views provide robust support for
accessing the effects of the monad stack without being coupled to a particular stack
layout. Views are denoted using (cid:4), and are an instance of the View type class that
deﬁnes the from operation. Additionally, we use bidirectional views, denoted with the
(cid:8)(cid:9) type operator. In addition to from, a bidirectional view supports the to operation.

from :: (Monad m, Monad n, View ((cid:4))) ⇒ n (cid:4) m → n a → m a
⇒ n (cid:8)(cid:9) m → m a → n a
to

:: (Monad m, Monad n)

In short, given two monads n and m, a view n (cid:4) m transforms computations from n
to m, and a bidirectional view n (cid:8)(cid:9) m can also transform computations from m to n.

View-Speciﬁc Operations. Views are ﬁrst-class values, hence they can be used as arguments.
 For instance, consider the functions getv and putv deﬁned in [35]:

getv :: (Monad m, SM s n, View ((cid:4))) ⇒ (n (cid:4) m) → m s
getv v = from v $ get

176

I. Figueroa, N. Tabareau, and É. Tanter

putv :: (Monad m, SM s n, View ((cid:4))) ⇒ (n (cid:4) m) → s → m ()
putv v = from v ◦ put

Given an initial monad m and a view n (cid:4) m, getv returns a computation m s from an
arbitrary state layer n. Conversely, putv puts a new value into state layer n.

Creating Views. Schrijvers and Oliveira propose the construction of views using structural 
and nominal masks, which are applied onto the layers of a monad stack [35].

– A structural mask is a bit-like mask applied to the monadic stack in order to hide
the layers that conﬂict with implicit lifting. Such a mask is created by concatenating
unary masks for each layer using the ::: type operator:17 (cid:5) indicates a visible layer
and (cid:6) a hidden layer.

– A nominal mask refers to layers of the stack using names instead of relative positions.
 This is done with the tag monad transformer T. Given an arbitrary type Tag,
the layer TTag labels a particular position of the monad stack using type Tag. An
example of a tagged monad stack (for some types Tag 1 and Tag 2) is:

type M = TTag 1 (ST Int (TTag 2 ET String I))

where the ST layer is labeled with Tag 1 and the ET layer is labeled with Tag 2.
For inspecting tagged monad stacks, the type class n (cid:16)Tag m exposes a monad
n representing the layer of the stack m tagged with type Tag. It also provides the
structure operation to obtain the view between n and m associated to t:

class (Monad m, Monad n) ⇒ n (cid:16)Tag m where
structure :: View ((cid:4)) ⇒ Tag → (n (cid:4) m)

7.4 Beyond the Aspect/Base Distinction

Monad views enable a different approach to enforce non-interference. The idea is that
aspects will be generic with respect to the effects they require using type class constraints,
 assuming exclusive access to a monad stack with those effects. To avoid noninterference,
 client code uses a concrete monad stack and transforms each advice into a
view-speciﬁc advice where the aspect only sees the sections of the monad stack that it
is allowed to access.

For instance, the memo advice described in Fig. 3 requires access to a dictionary to

store the precomputed results. This is explicit in the (inferred) type of the advice:

memo :: (Monad m, Ord a, SM (Map a b) m) ⇒ Advice m a b

In a similar way we deﬁne checkArg, which requires access to an error effect:

checkArg :: (Monad m, Num a, EM String m) ⇒ Advice m a b
checkArg proceed arg =

if arg < 0

then throwError “Error : negative argument
else proceed arg

(cid:2)(cid:2)

17 We follow the graphical notation used in [35].

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

177

S1

AOT

ErrorT
String

StateT

Map Int Int

Identity

v1 = S1 +

:::

:::

AOT

ErrorT
String

StateT

Map Int Int

Identity

v2 = S1 +

:::

:::

AOT

ErrorT
String

StateT

Map Int Int

Identity

Fig. 7. Applying structural masks to the monad stack S1

Arbitrarily Splitting the Monad Stack with Views. Observe now that the advice does
not depend on the speciﬁc position of an effect in the monad stack. The novelty with
respect to using implicit liftings is that we can assign to each aspect a virtual view of
the monad stack that only contains the effect available to them. To assign a part of the
monad stack to an advice we deﬁne the withView function:
withView :: (Monad n, Monad m) ⇒ n (cid:8)(cid:9) m → Advice n a b → Advice m a b
withView v adv proceed arg = from v $ adv (λa → to v (proceed a)) arg

This function transforms an advice from a restricted monad n to an advice in the “com-
plete” stack m, using a bidirectional view provided as argument. We require a bidirectional 
view because we need to lift the proceed function, with type a → n b into an
equivalent function with type a → m b—which by construction performs effects only
on n. Then, because evaluation of the restricted advice yields a computation n b, we
use the from operation to lift it into a computation m b.
Observe that partially applying withView with a given view yields a function of
type Advice n a b → Advice m a b, which ﬁts with the notion of advice combinators
(Sect. 6.2). Therefore, it is possible to export protected pointcuts that expose a particular
section of the monad stack to external advice. Additionally, we can deﬁne functions to
transform join points and pointcuts, in a similar way to withView .

Using Structural Masks. Consider a concrete monad stack S1 which holds the required
state and error effects.

type S1 = AT (ET String (ST (Map Int Int) I))

Then, we deﬁne the ﬁbonacci function as follows:

ﬁbMemoErr

(cid:2)

n = do deploy (aspect pcFib (withView v1 memo))

f ← ﬁb
deploy (aspect (pcCall f ) (withView v2 checkArg))
f # n
where v1 = (cid:5) ::: (cid:6) ::: (cid:5)
v2 = (cid:5) ::: (cid:5) ::: (cid:6)

178

I. Figueroa, N. Tabareau, and É. Tanter

We deﬁne views v1 and v2 using structural masks. Both allow access to AT, allowing
AOP-speciﬁc operations into advice (e.g., deploying aspects). Besides that, v1 exposes
only the ST transformer, whereas v2 only allows accessing to the ET transformer. Figure 
7 depicts how views v1 and v2 deﬁne new virtual monad stacks, by applying structural 
masks to S1. Note that structural masks can be applied only to monad transformers,
but not the monad at the bottom of the stack.

It is clear that now aspects do not need to perform explicit liftings and are not coupled
to a particular monad stack. However, these issues are present when constructing views
using nominal masks. Changes to the monad stack that is used to run client code need
to be reﬂected in (potentially many) client functions that use structural masks.

Using Nominal Masks. A more ﬂexible approach that is not coupled to any particular
monad stack is to use nominal masks to tag each effect required by aspects. Then client
code can use the tags to directly access the effects and properly transform the advices.
Consider a monad stack S2, where the state and error layers are tagged:

data StateTag
data ErrorTag
type S2 = AT (TErrorTag (ET String (TStateTag (ST (Map Int Int) I))

The stack is tagged at the type level, therefore we deﬁne two singleton types (with
no data constructors), namely StateTag and ErrorTag, to use as arguments for the T
monad transformer.

The ﬁbonacci function implemented using nominal masks is:

ﬁbMemoErr

(cid:2)(cid:2) :: ∀m n1 n2.(Monad m,
n1 (cid:16)StateTag (AT m), SM (Map Int Int) n1,
n2 (cid:16)ErrorTag (AT m), EM String n2)
⇒ Int → AT m Int

ﬁbMemoErr

(cid:2)(cid:2)

n = do deploy (aspect pcFib (withView v1 memo))

f ← ﬁb
deploy (aspect (pcCall f ) (withView v2 checkArg))
f # n

where v1 = structure StateTag :: n1 (cid:8)(cid:9) m
v2 = structure ErrorTag :: n2 (cid:8)(cid:9) m

In contrast to the previous deﬁnition, we need to use explicit type annotations because 
using nominal masks can lead to ambiguity in type inference18. Observe that we
assume a monad m that is tagged with two singleton types StateTag and ErrorTag.
We use (cid:16) to expose these layers as monads n1 and n2 respectively, and we constrain
these monads to expose the corresponding effects. Therefore, by using nominal masks
we can independently evolve the deﬁnition of S2, as long as we keep the tagged layers
expected by ﬁbMemoErr

(satisfying both the tag name and the required effect).

(cid:2)(cid:2)

18 The ∀m n1 n2 annotation is required to use the type variables in the scope of a do expression.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

179

Perspectives on Using Views. The content of the do expression is the same using structural 
or nominal masks. In fact it is possible to deﬁne a more generic function that takes
views v1 and v2 as argument. Because views are ﬁrst-class values, there is a wide design
space on how to use them to control aspect interference. For example, aspects can be
deﬁned directly using (cid:16) constraints as required.

On the other hand, programmers must carefully deﬁne the views that are provided
to each advice, because the typechecker cannot distinguish between intentional and
accidental sharing of effects.

Controlling effect

interference between aspects is a well-known and widely
researched area in the AOP community. The two approaches presented in this section 
show that the concrete mechanism used to manage the monad stack determines
the expressiveness of type-based reasoning techniques. We believe that the problem
of assigning exclusive access to effects in the monadic stack originates from the fact
that the monad stack is public and transparent to all components in a system. We conjecture 
that a mechanism that statically controls access to effects, while being ﬂexible
for developers ought to be devised, and indeed is a line of future work that transcends
aspect-oriented programming. An additional line of future work is the connection between 
monad views and MRI [29] (a framework for monadic reasoning that extends
EffectiveAdvice [35]), which is based on parametricity and considers only implicit and
explicit lifting.

As a ﬁnal remark, in a setting with an unrestricted deploy operation the restrictions
on advice must be applied at each particular aspect deployment. This makes it difﬁcult 
to establish global properties about advice in a system (which may require external
static analysis). This can be solved with a custom AT-like monad transformer that provides 
a more restricted deployment mechanism.

8 Language Extensions

The typed monadic embedding of aspects supports modular extensions of the aspect
language. The simplest extension is to introduce new user-deﬁned pointcuts. More interestingly,
 because the language features a monadic weaver [38], we can modularly
implement new semantics for aspect scoping and weaving. In addition, all language extensions 
beneﬁt from the type-based reasoning techniques described in this paper—to
the best of our knowledge, this is a novel contribution of this work. In this section we
describe the following developments:

– A user-deﬁned pcCﬂow pointcut designator.
– Secure weaving, in which a set of join points can be hidden from advising.
– Privileged aspects that can see hidden join points from a secure computation.
– Aspect weaving with execution levels [41].
– An example of type-based reasoning in the semantics of execution levels.

8.1 Cﬂow Pointcut

An interesting illustration of extending the language with user-deﬁned pointcuts is the
case of control ﬂow checks. Essentially, implementing the pcCﬂow pointcut requires a

180

I. Figueroa, N. Tabareau, and É. Tanter

way to track join points emitted during program execution. This tracking mechanism
can be implemented modularly using a state monad transformer that holds a stack of
join points, and an aspect that matches every join point, stores it in the stack, and then
proceeds to obtain the result, which is returned after popping the stack. This corresponds
to the stack-based implementation of cﬂow described in [24].

Join Point Stack. To do this, we ﬁrst deﬁne a join point stack as a list of existentiallyquantiﬁed 
join points, EJP, just like we did to deﬁne the aspect environment as a list
of homogeneous EAspect values (Sect. 3.1).

data EJP = ∀a b m.Monad m ⇒ EJP (JP m a b)
type JPStack = [EJP ]

Then, to collect the join points into a JPStack we deﬁne the JPT monad transformer,

reusing the implementation of the standard ST transformer:

newtype JPT m a = JPT (ST JPStack m a)

In addition, to support a polymorphic monad stack we deﬁne the JPM type class as

follows, and declare JPT as an instance.
class Monad m ⇒ JPM m where
:: m JPStack
getJPStack
pushJPStack :: EJP → m ()
popJPStack :: m ()
instance Monad m ⇒ JPM (JPT m) where . . .

Deﬁning pcCﬂow . Given the deﬁnitions above, the implementation of pcCﬂow is very
similar to that of pcCall (Sect. 3.1).19

pcCﬂow :: JPM m ⇒ (a → m b) → PC m c (m
pcCﬂow f = return (λ → do
jpStack ← getJPStack
return $ any (λejp → compareFunEJP f ejp ∧ compareTypeEJP f ejp)

d )

(cid:2)

jpStack

Here compareFunEJP checks the equality of the function bound to the join point and
function f ; and compareTypeEJP checks that the type of f is more general than the
type of the join point. Function any returns whether any element of jps satisﬁes a given
predicate. We can deﬁne the pcCﬂowbelow pointcut in a similar way.

Maintaining the Join Point Stack. Now it remains to deﬁne the aspect that maintains
the join point stack. We ﬁrst deﬁne the pcAny pointcut, which matches all functions
applications and pushes the corresponding join point into the stack.

19 Note that, as discussed in Sect. 4.1, we speciﬁcally declare that the matched type of the pointcut

is in a different monad m

(cid:2)

.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

181

pcAny :: JPM m ⇒ PC m a b
pcAny = PC $ return $ λjp → do pushJPStack (EJP jp)

return True

Note that the deﬁnition of pcAny preserves type soundness (Sect. 4.1) because its
matched type is given by two fresh type variables a and b, and hence is the most general
type possible. Next, we deﬁne collectAdv as an advice that performs proceed, pops the
stack and returns the result.

collectAdv proceed arg = do result ← proceed arg

popJPStack
return result

Finally, we deﬁne the maintainJpStack aspect as follows.
maintainJpStack :: JPM m ⇒ Aspect m a (m b) a b
maintainJpStack = aspect pcAny collectAdv

This approach is inefﬁcient because we are matching and storing all join points,
instead of only those that can be queried in existing uses of pcCﬂow . Alternative optimizations 
can be deﬁned, for example putting in the stack only relevant join points, or
a per-ﬂow deployment that allows using a boolean instead of a stack [24].

A consequence of not deﬁning pcCﬂow as a primitive pointcut is that we need to
ensure that evaluation of maintainJpStack occurs before than any other advice. Otherwise,
 control ﬂow pointcuts from other aspects will have incorrect information to
determine whether to execute the advice. This can be implemented directly in a custom
AT transformer that takes a list of priority aspects and ensures they are always evaluated
ﬁrst during weaving.

8.2 Secure Weaving

For security reasons it can be interesting to protect certain join points from being advised.
 To support such a secure weaving, we deﬁne a new monad transformer AS
T, which
embeds an (existentially quantiﬁed) pointcut that speciﬁes the hidden join points, and
we modify the weaving process accordingly (not shown here).

data EPC m = ∀a b.EPC (PC m a b)
T m)
data AS

(AspectEnv (AS

T m a = AS
T

→ EPC (AS
→ m (a, (AspectEnv (AS

T m)

T m), EPC (AS

T m))))

This can be particularly useful when used with the pcCﬂow pointcut to protect the
computation that occurs in the control ﬂow of critical function applications. For instance,
 we can ensure that the whole control ﬂow of function f is protected from advising 
during the execution of program p , assuming a function runAS
T, similar to runAT
(Sect. 3.2):

run AS
T

(EPC (pcCﬂow f )) p

182

I. Figueroa, N. Tabareau, and É. Tanter

8.3 Privileged Aspects

Hiding some join points to all aspects may be too restrictive. For instance, certain “sys-
tem” aspects like access control should be treated as privileged and view all join points.
Another example is the aspect in charge of maintaining the join point stack for the
sake of control ﬂow reasoning (used by pcCﬂow ). In such cases, it is important to be
able to deﬁne a set of privileged aspects, which can advise all join points, even those
that are normally hidden in a secure computation. The implementation of a privileged
aspects list is a straightforward extension to the secure weaving mechanism described
above.

8.4 Execution Levels

Execution levels avoid unwanted computational interference between aspects, i.e. when
an aspect execution produces join points that are visible to others, including itself [41].
Execution levels give structure to execution by establishing a tower in which the ﬂow of
control navigates. Aspects are deployed at a given level and can only affect the execution 
of the underlying level. The execution of an aspect (both pointcuts and advices) is
therefore not visible to itself and to other aspects deployed at the same level, only to aspects 
standing one level above. The original computation triggered by the last proceed
in the advice chain is always executed at the level at which the join point was emitted.
If needed, the programmer can use level-shifting operators to move execution up and
down in the tower.

The monadic semantics of execution levels are implemented in the ELT monad
transformer (Fig. 8). The Level type synonym represents the level of execution as an
integer. ELT wraps a run function that takes an initial level and returns a computation
in the underlying monad m, with a value of type a and a potentially modiﬁed level.
As in the AT transformer, the monadic bind and return functions are the same as in
the state monad transformer. The private operations inc, dec, and at are used to deﬁne 
the user-visible operations current, up, down, and lambda_at. In addition to level
shifting with up and down, current reiﬁes the current level, and lambda_at creates a
level-capturing function bound at level l. When such a function is applied, execution
jumps to level l and then goes back to the level prior to the application [41].

The semantics of execution levels can be embedded in the deﬁnition of aspects themselves,
 by transforming the pointcut and advice of an aspect at deployment time, as
shown in Fig. 9.20 This is done by functions pcEL and advEL. pcEL ﬁrst ensures that
the current execution level lapp matches ldep, the level at which the aspect is deployed.
If so it then runs the pointcut one level above. Similarly, advEL ensures that the advice
is run one level above, with a proceed function that captures the deployment level.

Example. Figure 10 deﬁnes a generic logging advice, logAdv, which appends the argument 
and result of advised functions to the log21. In program, we deploy an aspect that

20 For simplicity, in Sect. 3.2 we only described the default semantics of aspect deployment;

aspect (un)deployment is actually deﬁned using overloaded (un)deployInEnv functions.

21 Using the tell function of the MonadWriter class (denoted WM), which is not described in

Sect. 2, but which essentially is a state monad with append-only access.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

183

-- primitive operations

-- user-visible operations

1 type Level = Int
2 newtype ELT m a = ELT (ST Level m a)
3
4 inc = ELT $ λl → return ((), l + 1)
5 dec = ELT $ λl → return ((), l − 1)
6 at l = ELT $ λ → return ((), l )
8 current = ELT $ λl → return (l , l )
9 up c = do {inc; result ← c; dec; return result }
10 down c = do {dec; result ← c; inc; return result }
11 lambda_at f l = λarg → do n ← current
at l
result ← f arg
at n
return result

7

12
13
14
15

Fig. 8. Execution levels monad transformer and level-shifting operations

deployInEnv (Aspect (pc :: PC (AT (ELT m)) tpc) adv ) aenv =

let

pcEL ldep = (PC $ return $ λjp → do
lapp ← current
if lapp ≡ ldep then up $ runPC pc jp

else return False) :: PC (AT (ELT m)) tpc

advEL ldep proceed arg = up $ adv (lambda_at proceed ldep) arg

in do l ← current

return EAspect (Aspect (pcEL l ) (advEL l )) : aenv

Fig. 9. Redeﬁning aspect deployment for execution levels semantics. An aspect is made levelaware 
by transforming its pointcut and advice.

intercepts all calls to showM (the monadic version of show) where the argument is of
type Int (we require a type annotation for the pointcut because showM is a bounded
polymorphic function—see Sect. 9.2 for details).

The evaluation of the program depends on the instantiation of the monad stack M .
In a setting without execution levels, advising showM with logAdv triggers an inﬁnite 
loop because logAdv internally performs open applications of showM , which are
matched by the same aspect. Using the execution level semantics, evaluation terminates
because the join point emitted by the advice is not visible to the aspect itself.

Interestingly, explicit open applications limit the possibilities of unwanted advising.
More obliviousness, e.g., through partial application of #, makes it harder to track down
these issues (we come back to obliviousness in Sect. 9.3). Nevertheless, identifying the
source of the regression is not sufﬁcient per se: in our example, if it is necessary for
logAdv to use open applications (so that other aspects can intervene), there is not much
that can be done to avoid regression.

184

I. Figueroa, N. Tabareau, and É. Tanter

showM a = return (show a)
logAdv proceed a = do argStr ← showM # a

tell ("Arg: " ++ argStr )
result ← proceed a
return result

program n = runM $ do

deploy (aspect (pcCall (showM :: → Int → M String)) logAdv )
showM # n

Fig. 10. A program that loops unless execution levels are used

Beyond Execution Levels. Execution levels adds a topological dimension to the composition 
of aspects into a system. However, their tower-like structure may be too restricted 
for certain scenarios, for instance for dynamic analyses aspects [43]. Recently,
Tanter et al. proposed programmable membranes [44] as a generalization of execution
levels. We have developed a prototype implementation of membrane semantics in Effective 
Aspects [12], using the same approach of converting pointcuts and advices at
deployment time. However, instead of passing the current level of execution (an inte-
ger), we maintain the bindings between membranes (a graph) using a state monad.

8.5 Reasoning about Language Extensions

The above extensions can be implemented in an dynamically typed language such as
LAScheme [41]. However, it is challenging to provide any kind of reasoning about
effects due to the dynamic nature of the language.

Enforcing Non-interference in Language Extensions. We can combine the monadic interpretation 
of execution levels with the management of effect interference (Sect. 7) in
order to reason about level-shifting operations performed by base and aspect computations.
 For instance, it becomes possible to prevent aspect and/or base computation to
use effects provided by the ELT monad transformer, thus ensuring that the default semantics 
of execution levels is preserved (and therefore that the program is free of aspect
loops [42]). For this we must consider a concrete monad stack that has the AT and ELT
transformers on top:

type AELT m = AT ELT m

Observe that this monad stack is general with respect other effects it may contain. Then,
we simply deﬁne an advice combinator that forbids access to the ELT layer, which
provides the level-shifting operations.

levelAgnosticAdv = withView ((cid:5) ::: (cid:6) ::: (cid:5))

This mask hides the layer with the execution-level-related effects, but allows access to
AT at the top, and to the rest of the stack. Then to ensure level agnostic advice we just
redeﬁne program to use this combinator, in a suitable monad stack M :22

22 We use the WriterT transformer (WT), which is the canonical instance of WM.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

185

type M = AELT (WT String I)
runM c = run I $ runWT $ run ELT (run AT c) 0
program n = runM $ do

deploy (aspect (pcCall (showM :: → Int → M String))

(levelAgnosticAdv logAdv ))

showM # n

If more advanced use of execution levels is required, this contraint can be explicitly
relaxed in the AT or ELT monad transformer, thus stressing in the type that it is the
responsibility of the programmer to avoid inﬁnite regression.

Using Types to Enforce Weaving Semantics. The type system makes it possible to specify 
functions that can be woven, but only within a speciﬁc aspect monad. For instance,
suppose that we want to deﬁne a critical computation, which must only be run with
secure weaving for access control. The computation must therefore be run within the
AS

T monad transformer with a given pointcut pc_ac (ac stands for access control).
To enforce the use of AS

T with a speciﬁc pointcut value would require the use of a
dependent type, which is not possible in Haskell. This said, we can use the newtype
data constructor together with its ability to derive automatically type class instances, to
deﬁne a new type AAC
T monad transformer and forces it to be
run with the pc_ac pointcut:

T that encapsulates the AS

newtype AAC
runSafe (AAC

T m a = AAC
T
T c) = run AS
T

T m a) deriving (Monad , OpenApp, . . .)

(AS
(EPC pc_ac) c

Therefore, we can export the critical computation by typing it appropriately:

critical :: Monad m ⇒ AAC
Because the AAC
T

T m a

computation typed as AAC
T
advisable with secure weaving for access control.

constructor is hidden in a module, the only way to run such a
is to use runSafe. The critical computation is then only

9 Discussion

We now discuss a number of issues related to our approach: how to deﬁne a proper notion 
of function equality, how to deal with overloaded functions, and ﬁnally, we analyze
the issue of obliviousness.

9.1 Supporting Equality on Functions

Pointcuts quantify about join points, and a major element of the join point is the function
being applied. The pcType designator relies on type comparison, implemented using
the PolyTypeable type class in order to obtain representations for polymorphic types.
The pcCall is more problematic, as it relies on function equality, but Haskell does not
provide an operator like eq? in Scheme.

186

I. Figueroa, N. Tabareau, and É. Tanter

A ﬁrst workaround is to use the StableNames API that allows comparing functions
using pointer equality. Unfortunately, this notion of equality is fragile. StableNames
equality is safe in the sense that it does not equate two functions that are not the same,
but two functions that are equal can be seen as different.

The problem becomes even more systematic when it comes to bounded polymorphism.
 Indeed, each time a function with constraints is used, a new closure is created
by passing the current method dictionary of type class instances. Even with optimized
compilation (e.g., ghc -O), this (duplicated) closure creation is unavoidable and so
StableNames will consider different any two constrained functions, even if the passed
dictionary is the same.

To overcome this issue, we have overloaded our equality on functions with a special
case for functions that have been explicitly tagged with a unique identiﬁer at creation
(using Data.Unique). This allows us to have a robust notion of function equality but it
has to be used explicitly at each function deﬁnition site.

9.2 Advising Overloaded Functions

From a programmer’s point of view, it can be interesting to advise an overloaded function 
(that is, the application of all the possible implementations) with a single aspect.
However, deploying aspects in the general case of bounded polymorphism is problematic 
because of the resolution of class constraints. Recall that in order to be able to
type the aspect environment, we existentially hide the matched and advised types of
an aspect. This means that all type class constraints must be solved statically at the
point an aspect is deployed. If the matched and advised types are both bounded polymorphic 
types, type inference cannot gather enough information to statically solve the
constraints. So advising all possible implementations requires repeating deployment of
the same aspect with different type annotations, one for each instance of the involved
type classes.

To alleviate this problem, we developed a macro using TemplateHaskell [36]. The
macro extracts all the constrained variables in the matched type of the pointcut, and
generates an annotated deployment for every possible combination of instances that
satisfy all constraints. In order to retain safety, the advised type of an aspect must be
less constrained than its matched type. This is statically enforced by the Haskell type
system after macro expansion.

9.3 Obliviousness

The embedding of aspects we have presented thus far supports quantiﬁcation through
pointcuts, but is not oblivious: open applications are explicit in the code. A ﬁrst way
to introduce more obliviousness without requiring non-local macros or, equivalently, a
preprocessor or ad hoc runtime semantics, is to use partial applications of #. For instance,
 the enqueue function can be turned into an implicitly woven function by deﬁn-
(cid:2) = enqueue #. This approach was used in Fig. 2 for the deﬁnition of
ing enqueue
ﬁb. It can be sufﬁcient in similar scenarios where quantiﬁcation is under control. Otherwise,
 it can yield issues in the deﬁnition of pointcuts that rely on function identity, beand 
enqueue are different functions. Also, this approach is not entirely
cause enqueue

(cid:2)

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

187

satisfactory with respect to obliviousness because it has to be applied speciﬁcally for
each function.

De Meuter proposes [26] to use the binder of a monad to redeﬁne function application.
 His approach focuses on deﬁning one monad per aspect, but can be generalized to
a list of dynamically deployed aspects as presented in Sect. 3.2. For this, we can redeﬁne
the monad transformer AT to make all monadic applications open transparently:

instance Monad m ⇒ Monad (AT m) where
return a = AT $ λaenv → return (a, aenv )
k >>= f = do x ← k
f # x

This presentation improves obliviousness because any monadic application is now an
open application, but it suffers from a major drawback: it breaks the monadic laws.
Indeed, left identity and associativity

-- Left identity:
return x >>= f = f x
-- Associativity:
(m >>= f ) >>= g = m >>= (λx → f x >>= g)

can be invalidated, depending on the current list of deployed aspects. This is not
surprising as AOP allows one to redeﬁne the behavior of a function and even to redeﬁne
the behavior of a function depending on its context of execution. Breaking monadic
laws is not prohibited by Haskell, but it is very dangerous and fragile; for instance,
some compilers exploit the laws to perform optimizations, so breaking them can yield
incorrect optimizations.

9.4 Technical Requirements of Our Model

The current implementation of Effective Aspect uses several extensions of the GHC
Haskell compiler (see the details at http://plead.cl/effectiveaspects).
Nevertheless, we believe that the anti-uniﬁcation algorithm at the type level (Section 4.1)
is the essential feature that would be required to make our approach work on other languages.
 A potential line of work is to port Effective Aspects to Scala, which has some
likeness to Haskell and also has monads, and investigate what kind of issues arise in the
process.

10 Related Work

The earliest connection between aspects and monads was established by De Meuter in
1997 [26]. In that work, he proposes to describe the weaving of a given aspect directly
in the binder of a monad. As we have just described above (Sect. 9.3), doing so breaks
the monad laws, and is therefore undesirable.

188

I. Figueroa, N. Tabareau, and É. Tanter

Wand et al. [48] formalize pointcuts and advice and use monads to structure the
denotational semantics; a monad is used to pass the join point stack and the store around
evaluation steps. The speciﬁc ﬂavor of AOP that is described is similar to AspectJ, but
with only pure pointcuts. The calculus is untyped. The reader may have noticed that we
do not model the join point stack in this paper. This is because it is not required for
a given model of AOP to work. In fact, the join point stack is useful only to express
control ﬂow pointcuts. In our approach, this is achieved by specifying a user-deﬁned
pointcut designator for control ﬂow, which uses a monad to thread the join point stack
(or, depending on the desired level of dynamicity, a simple control ﬂow state [24]).
Support for the join point stack does not have to be included as a primitive in the core
language. This is in fact how AspectJ is implemented [24,15].

Hofer and Osterman [16] shed some light on the modularity beneﬁts of monads and
aspects, clarifying that they are different mechanisms with quite different features: monads 
do not support declarative quantiﬁcation, and aspects do not provide any support
for encapsulating computational effects. In this regard, our work does not attempt at
unifying monads and aspects, contrary to what De Meuter suggested. Instead, we exploit 
monads in Haskell to build a ﬂexible embedding of aspects that can be modularly
extended. In addition, the fully typed setting provides the basis for reasoning about
monadic effects.

The notion of monadic weaving was described by Tabareau [38], where he shows that
writing the aspect weaver in a monadic style paves the way for modular language extensions.
 He illustrated the extensibility approach with execution levels [41] and levelaware 
exception handling [13]. The authors then worked on a practical monadic aspect
weaver in Typed Racket [14]. However, the type system of Typed Racket turned out
to be insufﬁciently expressive, and the top type Any had to be used to describe pointcuts 
and advices. This was the original motivation to study monadic weaving in Haskell.
Also in contrast to this work, prior work on monadic aspect weaving does not consider a
base language with monads. In this paper, both the base language and the aspect weaver
are monadic, combining the beneﬁts of type-based reasoning about effects (Sect. 6) and
modular language extensions (Sect. 8)—including type-based reasoning about language
extensions.

Haskell has already been the subject of AOP investigations using the type class system 
as a way to perform static weaving [37]. AOP idioms are translated to type class
instances, and type class resolution is used to perform static weaving. This work only
supports simple pointcuts, pure aspects, and static weaving, and is furthermore very
opaque to modular changes as the translation of AOP idioms is done internally at compile 
time.

The speciﬁc ﬂavor of pointcut/advice AOP that we developed is directly inspired
by AspectScheme [11] and AspectScript [45]: dynamic aspect deployment, ﬁrst-class
aspects, and extensible set of pointcut designators. While we have not yet developed the
more advanced scoping mechanisms found in these languages [40], we believe there
are no speciﬁc challenges in this regard. The key difference here is that these languages
are both dynamically typed, while we have managed to reconcile this high level of
ﬂexibility with static typing.

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

189

In terms of statically typed functional aspect languages, the closest proposal to ours
is AspectML [7]. In AspectML, pointcuts are ﬁrst-class, but advice is not. The set
of pointcut designators is ﬁxed, as in AspectJ. AspectML does not support: advising
anonymous functions, aspects of aspects, separate aspect deployment, and undeployment.
 AspectML was the ﬁrst language in which ﬁrst-class pointcuts were statically
typed. The typing rules rely on anti-uniﬁcation, just like we do in this paper. The major
difference, though, is that AspectML is deﬁned as a completely new language, with a
speciﬁc type system and a speciﬁc core calculus. Proving type soundness is therefore
very involved [7]. In contrast, we do not need to deﬁne a new type system and a new
core calculus. Type soundness in our approach is derived straightforwardly from the
type class that establishes the anti-uniﬁcation relation. Half of section 5 is dedicated to
proving that this type class is correct. Once this is done (and it is a result that is independent 
from AOP), proving aspect safety is direct. Another way to see this work is as
a new illustration of the expressive power of the type system of Haskell, in particular
how phantom types and type classes can be used in concert to statically type embedded
languages.

Aspectual Caml [25] is another polymorphic aspect language. Interestingly, Aspectual 
Caml uses type information to inﬂuence matching, rather than for reporting type
errors. More precisely, the type of pointcuts is inferred from the associated advices, and
pointcuts only match join points that are valid according to these inferred types. We
believe this approach can be difﬁcult for programmers to understand, because it combines 
the complexities of quantiﬁcation with those of type inference. Aspectual Caml
is implemented by modifying the Objective Caml compiler, including modiﬁcations to
the type inference mechanism. There is no proof of type soundness.

The advantages of our typed embedding do not only lie within the simplicity of
the soundness proof. They can also be observed at the level of the implementation.
The AspectML implementation is over 15,000 lines of ML code [7], and the Aspectual
Caml implementation is around 24,000 lines of Objective Caml code [25]. In contrast,
our implementation, including the execution levels extension (Sect. 8), is only 1,600
lines of Haskell code. Also, embedding an AOP extension entirely inside a mainstream
language has a number of practical advantages, especially when it comes to efﬁciency
and maintainability of the extension.

Finally, reasoning about advice effects has been studied from different angles. For
instance, harmless advice can change termination behavior and use I/O, but no more [6].
A type and effect system is used to ensure conformance. Translucid contracts use grey
box speciﬁcations and structural reﬁnement in veriﬁcation to reason about control effects 
[5]. In this work, we rather follow the type-based approach of EffectiveAdvice
(EA) [28], which also accounts for various control effects and arbitrary computational
effects. A limitation of EA is its lack of support quantiﬁcation. A contribution of this
work is to show how to extend this approach to the pointcut/advice mechanism. The
subtlety lies in properly typing pointcuts. An interesting difference between both approaches 
is that in EA, it is not possible to talk about “the effects of all applied advices”.
Once an advice is composed with a base function, the result is seen as a base function
for the following advice. In contrast, our approach, thanks to the aspect environment and

190

I. Figueroa, N. Tabareau, and É. Tanter

dynamic weaving, makes it possible to keep aspects separate and ensure base/aspect
separation at the effect level even in presence of multiple aspects. We believe that this
splitting of the monad stack is more consistent with programmers expectations.

11 Conclusion

We develop a novel approach to embed aspects in an existing language. We exploit
monads and the Haskell-type system to deﬁne a typed monadic embedding that supports 
both modular language extensions and reasoning about effects with pointcut/advice 
aspects. We show how to ensure type soundness by design, even in presence
of user-extensible pointcut designators, relying on a novel-type class for establishing
anti-uniﬁcation. Compared to other approaches to statically typed polymorphic aspect
languages, the proposed embedding is more lightweight, expressive, extensible, and
amenable to interference analysis. The approach can combine Open Modules and EffectiveAdvice,
 and supports type-based reasoning about modular language extensions.

Acknowledgments. This work was supported by the INRIA Associated team REAL.
We thank the anonymous reviewers from the AOSD’13 conference and from this journal,
 and we also thank Tom Schrijvers for all his useful feedback.

References

1. In: Proceedings of the 11th Workshop on Foundations of Aspect-Oriented Languages (FOAL

2012), Potsdam, Germany. ACM Press (March 2012)

2. Aldrich, J.: Open modules: Modular reasoning about advice. In: Gao, X.-X. (ed.) ECOOP

2005. LNCS, vol. 3586, pp. 144–168. Springer, Heidelberg (2005)

3. In: Proceedings of the 7th ACM International Conference on Aspect-Oriented Software

Development (AOSD 2008), Brussels, Belgium. ACM Press (April 2008)

4. In: Proceedings of the 9th ACM International Conference on Aspect-Oriented Software

Development (AOSD 2010), Rennes and Saint Malo, France. ACM Press (March 2010)

5. Bagherzadeh, M., Rajan, H., Leavens, G.T., Mooney, S.: Translucid contracts: Expressive
speciﬁcation and modular veriﬁcation for aspect-oriented interfaces. In: Proceedings of the
10th ACM International Conference on Aspect-Oriented Software Development (AOSD
2011), Porto de Galinhas, Brazil. ACM Press (March 2011)

6. Dantas, D.S., Walker, D.: Harmless advice. In: Proceedings of the 33rd ACM SIGPLANSIGACT 
Symposium on Principles of Programming Languages (POPL 2006), Charleston,
South Carolina, pp. 383–396. ACM Press (January 2006)

7. Dantas, D.S., Walker, D., Washburn, G., Weirich, S.: AspectML: A polymorphic aspectoriented 
functional programming language. ACM Transactions on Programming Languages
and Systems 30(3), Article No. 14 (May 2008)

8. De Fraine, B., Südholt, M., Jonckers, V.: StrongAspectJ: ﬂexible and safe pointcut/advice

bindings. In: AOSD 2008 [3], pp. 60–71

9. Douence, R., Fradet, P., Südholt, M.: Trace-based aspects. In: Filman, R.E., Elrad, T., Clarke,
S., Ak¸sit, M. (eds.) Aspect-Oriented Software Development, pp. 201–217. Addison-Wesley,
Boston (2005)

10. Douence, R., Motelet, O., Südholt, M.: A formal deﬁnition of crosscuts. In: Matsuoka, S.

(ed.) Reﬂection 2001. LNCS, vol. 2192, pp. 170–186. Springer, Heidelberg (2001)

Effective Aspects: A Typed Monadic Embedding of Pointcuts and Advice

191

11. Dutchyn, C., Tucker, D.B., Krishnamurthi, S.: Semantics and scoping of aspects in higherorder 
languages. Science of Computer Programming 63(3), 207–239 (2006)

12. Figueroa, I., Tabareau, N., Tanter, É.: Taming aspects with monads and membranes. In:
Proceedings of the 12th Workshop on Foundations of Aspect-Oriented Languages (FOAL
2013), Fukuoka, Japan, pp. 1–6. ACM Press (March 2013)

13. Figueroa, I., Tanter, É.: A semantics for execution levels with exceptions. In: Proceedings of
the 10th Workshop on Foundations of Aspect-Oriented Languages (FOAL 2011), Porto de
Galinhas, Brazil, pp. 7–11. ACM Press (March 2011)

14. Figueroa, I., Tanter, É., Tabareau, N.: A practical monadic aspect weaver. In: Proceedings of
the 11th Workshop on Foundations of Aspect-Oriented Languages (FOAL 2012), pp. 21–26
(2012)

15. Hilsdale, E., Hugunin, J.: Advice weaving in AspectJ. In: Lieberherr, K. (ed.) Proceedings of
the 3rd ACM International Conference on Aspect-Oriented Software Development (AOSD
2004), Lancaster, UK, pp. 26–35. ACM Press (March 2004)

16. Hofer, C., Ostermann, K.: On the relation of aspects and monads. In: Proceedings of AOSD

Workshop on Foundations of Aspect-Oriented Languages (FOAL 2007), pp. 27–33 (2007)

17. Jones, M.P.: Type classes with functional dependencies. In: Smolka, G. (ed.) ESOP 2000.

LNCS, vol. 1782, pp. 230–244. Springer, Heidelberg (2000)

18. Kiczales, G., Hilsdale, E., Hugunin, J., Kersten, M., Palm, J., Griswold, W.G.: An overview
of aspectJ. In: Lindskov Knudsen, J. (ed.) ECOOP 2001. LNCS, vol. 2072, pp. 327–353.
Springer, Heidelberg (2001)

19. Kiczales, G., Lamping, J., Mendhekar, A., Maeda, C., Lopes, C.V., Loingtier, J.-M.,
Irwin, J.: Aspect-oriented programming. In: Ak¸sit, M., Matsuoka, S. (eds.) ECOOP 1997.
LNCS, vol. 1241, pp. 220–242. Springer, Heidelberg (1997)

20. Learn you a haskell website (2013), http://learnyouahaskell.com/
21. Leijen, D., Meijer, E.: Domain speciﬁc embedded compilers. In: Ball, T. (ed.) Proceedings

of the 2nd USENIX Conference on Domain-Speciﬁc Languages, pp. 109–122 (1999)

22. Liang, S., Hudak, P., Jones, M.: Monad transformers and modular interpreters. In: Proceedings 
of the 22nd ACM Symposium on Principles of Programming Languages (POPL 95),
San Francisco, California, USA, pp. 333–343. ACM Press (1995)

23. Hansen, K.A., Kawauchi, K.: Dataﬂow pointcut in aspect-oriented programming. In: Ohori,

A. (ed.) APLAS 2003. LNCS, vol. 2895, pp. 105–121. Springer, Heidelberg (2003)

24. Hansen, K.A., Kiczales, G., Dutchyn, C.: A compilation and optimization model for aspectoriented 
programs. In: Hedin, G. (ed.) CC 2003. LNCS, vol. 2622, pp. 46–60. Springer,
Heidelberg (2003)

25. Masuhara, H., Tatsuzawa, H., Yonezawa, A.: Aspectual Caml: an aspect-oriented functional
language. In: Proceedings of the 10th ACM SIGPLAN Conference on Functional Programming 
(ICFP 2005), Tallin, Estonia, pp. 320–330. ACM Press (September 2005)

26. Meuter, W.D.: Monads as a theoretical foundation for aop. In: International Workshop on

Aspect-Oriented Programming at ECOOP, p. 25. Springer (1997)

27. Moggi, E.: Notions of computation and monads. Information and Computation 93(1), 55–92

(1991)

28. Oliveira, B.C.D.S., Schrijvers, T., Cook, W.R.: EffectiveAdvice: discplined advice with explicit 
effects. In: AOSD 2010 [4], pp. 109–120

29. Oliveira, B.C.D.S., Schrijvers, T., Cook, W.R.: MRI: Modular reasoning about interference

in incremental programming. Journal of Functional Programming 22, 797–852 (2012)

30. Peyton Jones, S., Vytiniotis, D., Weirich, S., Shields, M.: Practical type inference for

arbitrary-rank types. Journal of Functional Programming 17(1), 1–82 (2007)

31. Pierce, B.C.: Types and programming languages. MIT Press, Cambridge (2002)
32. Plotkin, G.D.: A note on inductive generalization. Machine Intelligence 5, 153–163 (1970)

192

I. Figueroa, N. Tabareau, and É. Tanter

33. Reynolds, J.C.: Transformational systems and the algebraic structure of atomic formulas.

Machine Intelligence 5, 135–151 (1970)

34. Rinard, M., Salcianu, A., Bugrara, S.: A classiﬁcation system and analysis for aspect-oriented
programs. In: Proceedings of the 12th ACM Symposium on Foundations of Software Engineering 
(FSE 12), pp. 147–158. ACM Press (2004)

35. Schrijvers, T., Oliveira, B.C.: Monads, zippers and views: virtualizing the monad stack. In:
Proceedings of the 16th ACM SIGPLAN Conference on Functional Programming (ICFP
2011), Tokyo, Japan, pp. 32–44. ACM Press (September 2011)

36. Sheard, T., Jones, S.P.: Template meta-programming for haskell. SIGPLAN Not. 37(12), 60–

75 (2002)

37. Sulzmann, M., Wang, M.: Aspect-oriented programming with type classes. In: Proceedings
of the Sixth Workshop on Foundations of Aspect-Oriented Languages (FOAL 2007), Vancouver,
 British Columbia, Canada, pp. 65–74. ACM Press (2007)

38. Tabareau, N.: A monadic interpretation of execution levels and exceptions for AOP. In: Tanter,
 É., Sullivan, K.J. (eds.) Proceedings of the 11th International Conference on AspectOriented 
Software Development (AOSD 2012), Potsdam, Germany. ACM Press (March
2012)

39. Tabareau, N., Figueroa, I., Tanter, É.: A typed monadic embedding of aspects. In: Kinzle, J.
(ed.) Proceedings of the 12th International Conference on Aspect-Oriented Software Development 
(AOSD 2013), Fukuoka, Japan, pp. 171–184. ACM Press (March 2013)

40. Tanter, É.: Expressive scoping of dynamically-deployed aspects. In: AOSD 2008 [3],

pp. 168–179

41. Tanter, É.: Execution levels for aspect-oriented programming. In: AOSD 2010 [4], pp. 37–48
42. Tanter, É., Figueroa, I., Tabareau, N.: Execution levels for aspect-oriented programming:
Design, semantics, implementations and applications. Science of Computer Programming
(2013) (available online)

43. Tanter, É., Moret, P., Binder, W., Ansaloni, D.: Composition of dynamic analysis aspects. In:
Proceedings of the 9th ACM SIGPLAN International Conference on Generative Programming 
and Component Engineering (GPCE 2010), Eindhoven, The Netherlands, pp. 113–122.
ACM Press (October 2010)

44. Tanter, É., Tabareau, N., Douence, R.: Taming aspects with membranes. In: Proceedings of
the 11th Workshop on Foundations of Aspect-Oriented Languages (FOAL 2012) [1], pp. 3–8
45. Toledo, R., Leger, P., Tanter, É.: AspectScript: Expressive aspects for the Web. In: AOSD

2010 [4], pp. 13–24

46. Wadler, P.: The essence of functional programming. In: Proceedings of the 19th ACM Symposium 
on Principles of Programming Languages (POPL 1992), Albuquerque, New, Mexico,
USA, pp. 1–14. ACM Press (January 1992)

47. Wadler, P., Blott, S.: How to make ad-hoc polymorphism less ad hoc. In: Proceedings of the
16th ACM Symposium on Principles of Programming Languages (POPL 1989), Austin, TX,
USA, pp. 60–76. ACM Press (January 1989)

48. Wand, M., Kiczales, G., Dutchyn, C.: A semantics for advice and dynamic join points
in aspect-oriented programming. ACM Transactions on Programming Languages and
Systems 26(5), 890–910 (2004)

