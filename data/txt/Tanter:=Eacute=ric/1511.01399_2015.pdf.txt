Deriving a Simple Gradual Security Language

Ronald Garcia

Software Practices Lab

Department of Computer Science
University of British Columbia

rxg@cs.ubc.ca

´Eric Tanter

PLEIAD Laboratory

Computer Science Department (DCC)

University of Chile

etanter@dcc.uchile.cl

5
1
0
2

 

v
o
N
0
2

 

 
 
]
L
P
.
s
c
[
 
 

3
v
9
9
3
1
0

.

1
1
5
1
:
v
i
X
r
a

Abstract
Abstracting Gradual Typing (AGT) is an approach to systematically 
deriving gradual counterparts to static type disciplines (Garcia 
et al. 2016). The approach consists of deﬁning the semantics of
gradual types by interpreting them as sets of static types, and then
deﬁning an optimal abstraction back to gradual types. These operations 
are used to lift the static discipline to the gradual setting. The
runtime semantics of the gradual language then arises as reductions
on gradual typing derivations.

To demonstrate the ﬂexibility of AGT, we gradualize
λSEC (Zdancewic 2002), the prototypical security-typed language,
with respect to only security labels rather than entire types, yielding
a type system that ranges gradually from simply-typed to securelytyped.
 We establish noninterference for the gradual
language,
, using Zdancewic’s logical relation proof method.
Whereas prior work presents gradual security cast
languages,
which require explicit security casts, this work yields the ﬁrst gradual 
security source language, which requires no explicit casts.

called λfSEC

Introduction

1.
Gradual typing has often been viewed as a means to combine
the agility beneﬁts of dynamic languages, like Python and Ruby
with the reliability beneﬁts of static languages like OCaml and
Scala. This paper, in a line of work on the foundations of gradual
typing, explores the idea that static and dynamic are merely relative
notions.

This relativistic view of gradual typing is not new. Work on
gradual information ﬂow security by Disney and Flanagan (2011)
and Fennell and Thiemann (2013) develop languages where only
information-ﬂow security properties are subject to a mix of dynamic 
and static checking. Ba˜nados Schwerter et al. (2014) develop
a language where only computational effect capabilities are gradualized.
 In each of these cases, the “fully-dynamic” corner of the
gradual language is not dynamic at all by typical standards, but
rather simply typed. However, those languages support seamless
migration toward a more precise typing discipline that subsumes
simple typing.

To explore this notion, we revisit the idea of gradual informationﬂow 
security. Our tool of inquiry is a new approach to the foundations 
of gradual typing called Abstracting Gradual Typing (AGT)
(Garcia et al. 2016). AGT is a technique for systematically deriving
gradual type systems by interpreting gradual types as sets of static
types. That work developed a traditional gradual type system with
subtyping, introducing an unknown type ?. But AGT was directly
inspired by Ba˜nados Schwerter et al. (2014), who used an early version 
of these techniques to gradualize only effects. However, they
develop the dynamic semantics of gradual effects in the traditional
ad hoc fashion. Here, we bring the approach full circle, deriving a

complete static and dynamic semantics for a gradual counterpart to
the λSEC language of Zdancewic (2002).

In their simplest form, security-typed languages require values
and types to be annotated with security labels, indicating their conﬁdentiality 
level. The security type system guarantees noninterference,
 i.e., that more-conﬁdential information does not alter the lessconﬁdential 
results of any expression.

We prove that the resulting gradual language, called λfSEC

, is
not only safe in that it never unexpectedly crashes, but that it
is sound in that it honours the information-ﬂow invariants of the
precisely typed terms. The former property is unsurprising, since
even the most imprecisely typed program still maintains the simple
typing discipline, which is enough to establish the safety of the
operational semantics. The soundness of the language with respect
to the security type discipline, i.e., that basic information ﬂow
properties are respected, is the key property.

The prior work in gradual security typing developed gradual
cast languages, which require explicit type casts to connect imprecisely 
typed terms with precisely typed terms. This is akin to the intermediate 
languages of traditional gradually-typed languages. This
work presents the ﬁrst gradual source language, where no explicit
casts are needed: they are introduced by the language semantics.
Furthermore, following the AGT approach, the runtime semantics
are induced by the proof of type safety for λSEC, yielding a crisp
connection to that precise static type discipline.

As with the original work on AGT, we can straightforwardly
establish proper adaptations of the reﬁned criteria for gradually
typed languages. We will do so in this ongoing work.

Ultimately this work views gradual typing as a theory of imprecise 
typing rather than dynamic checking. Indeed dynamic checking 
is an inevitable consequence of this approach, but the focus here
is on the types and their meaning. We believe that this broader view
of gradual typing can widen the reach of gradual typing beyond
its current niche of interest among dynamic language enthusiasts.
Furthermore, we believe that AGT generalizes the foundations of
gradual typing enough to support a wide variety of gradual type
disciplines.

2. The Static Language: λSEC
We ﬁrst present the λSEC language, with some differences from the
original presentation (Zdancewic 2002). The most notable changes
are that the type system is syntax directed, and the runtime semantics 
are small-step structural operational semantics rather than bigstep 
natural semantics.

Figure 1 presents the syntax and type system for λSEC. The language 
extends a simple typing discipline with a lattice of security
labels ℓ. All program values are ascribed security labels, which are
partial ordered 4 from low security to high-security and include
top and bottom security labels ⊤ and ⊥. The λSEC types S extend

ℓ ∈ LABEL, S ∈ TYPE,

x ∈ VAR,

b ∈ BOOL, ⊕ ∈ BOOLOP

t ∈ TERM,

r ∈ RAWVALUE v ∈ VALUE Γ ∈ VAR

ﬁn
⇀ TYPE

::= Boolℓ | S →ℓ S
::= true | false
::= b | λx : S.t
::= rℓ
::= v | t t | t ⊕ t | if t then t else t | t :: S

S
b
r
v
t
⊕ ::= ∧ | ∨ | =⇒

(types)
(Booleans)
(raw values)
(values)
(terms)
(operations)

Γ ⊢ t : S

(Sx) x : S ∈ Γ
Γ ⊢ x : S

(Sb)

Γ ⊢ bℓ : Boolℓ

(Sλ)

Γ, x : S1 ⊢ t : S2

Γ ⊢ (λx : S1.t)ℓ : S1 →ℓ S2

(S⊕)

Γ ⊢ t1 : Boolℓ1

Γ ⊢ t2 : Boolℓ2

Γ ⊢ t1 ⊕ t2 : Bool

(ℓ1≺ℓ2)

t
f

::= . . . | t≺ℓ
::= (cid:3) ⊕ t | v ⊕ (cid:3) | (cid:3) t | v (cid:3) (frames)

(term stamping)

if (cid:3) then t else t | (cid:3)≺ℓ

(S≺)

Γ ⊢ t : S

Γ ⊢ t≺ℓ : S ≺ℓ

t −→ t Notions of Reduction

b1ℓ1 ⊕ b2ℓ2 −→ (b1 J⊕K b2)(ℓ1≺ℓ2)

(λx : S.t)ℓ v −→ ([v/x]t)≺ℓ

if trueℓ then t1 else t2 −→ t1 ≺ℓ

if falseℓ then t1 else t2 −→ t2 ≺ℓ

rℓ1 ≺ℓ2 −→ r(ℓ1≺ℓ2)

t 7−→ t Reduction

t1 −→ t2
t1 7−→ t2

t1 7−→ t2

f [t1] 7−→ f [t2]

(Sapp)

Γ ⊢ t1 : S11 →ℓ S12

Γ ⊢ t2 : S2

S2 <: S11

Figure 2. λSEC: Small-Step Dynamic Semantics

Γ ⊢ t1 t2 : S12 ≺ℓ

(Sif)

Γ ⊢ t : Boolℓ

Γ ⊢ t1 : S1

Γ ⊢ t2 : S2

Γ ⊢ if t then t1 else t2 : (S1 <

:

S2)≺ℓ

(S::)

Γ ⊢ t : S1

S1 <: S2

Γ ⊢ t :: S2 : S2

S <: S

ℓ 4 ℓ′

Boolℓ <: Bool

ℓ′

:

S <

S, S <

:S

S′
1 <: S1

S2 <: S′
2

ℓ 4 ℓ′

S1 →ℓ S2 <: S′

1 →ℓ′ S′
2

:

: TYPE × TYPE ⇀ TYPE

ℓ′ = Bool

(ℓ≺ℓ′)

:

Bool

<
Boolℓ <
(S11 →ℓ S12)<
S <

:

:

S undeﬁned otherwise

(S21 →ℓ′ S22) = (S11 <

:S21) →(ℓ≺ℓ′) (S12 <

:

versa. Rule (Sif) speciﬁes that the type of a conditional is the sub-
:of the types of the branches, further stamped to incortyping 
join<
porate the conﬁdentiality of the predicate expression’s label l. The
latter is necessary to forbid indirect ﬂow of information through
the conditional. As usual, the join of two function types is deﬁned
:of the argument types, which in turn relies
in terms of the meet <
on the label meet operator ≺. The (S::) rule introduces ascription,
which can move the type of an expression to any supertype.

These syntax-directed typing rules deﬁne a type system that is
sound and complete with respect to Zdancewic’s. The following
propositions use ⊢Z for the type system of Zdancewic (2002), and
consider only terms without ascription (i.e., the common subset of
the two systems).

S22)

Proposition 1. If Γ ⊢ t : S then Γ ⊢Z t : S.

Proof. By induction on Γ ⊢ t : S.

<

Bool

: : TYPE × TYPE ⇀ TYPE
<
Boolℓ
(S11 →ℓ S12)<
S <

:S undeﬁned otherwise

:

ℓ′ = Bool
:(S21 →ℓ′ S22) = (S11 <

(ℓ≺ℓ′)

:

S21) →(ℓ≺ℓ′) (S12 <

:S22)

Proposition 2. If Γ ⊢Z t : S Then Γ ⊢ t : S′ for some S′ <: S.

Figure 1. λSEC: Syntax and Static Semantics

Proof. By induction on Γ ⊢Z t : S.

a simple type discipline by associating a security label to each type
constructor.

Rules for variables, constants and functions are straightforward.
The (S⊕) rule for binary boolean operations ensures that the conﬁdentiality 
of combining two values is the least upper bound, or
join≺, of the conﬁdentiality of the two sub-expressions. Similarly,
when applying a function (Sapp), the result type joins the label of
the function’s result type S12 with the label ℓ of the function type.
For this, the rule uses a notion of label stamping on types:1

Boolℓ≺ℓ′ = Bool(ℓ≺ℓ′)

(S1 →ℓ S2)≺ℓ′ = S1 →(ℓ≺ℓ′) S2

Rule (Sapp) also appeals to a notion of subtyping S <: S. Subtyping 
is induced by the ordering on security labels. It allows lowersecurity 
values to ﬂow to higher-security contexts, but not vice1 
We overload the join notation ≺ throughout, and rely on the context to
disambiguate.

Dynamic semantics. The dynamic semantics of λSEC were originally 
presented as big step semantics (Zdancewic 2002). Figure 2
presents the equivalent small-step semantics. Of particular interest 
is the new label stamping form on terms, which we call term
stamping t≺ℓ. Term stamping allows small-step reduction to retain
security information that is merged with the resulting value of the
nested term.

This small-step semantics coincides with the big-step semantics
of λSEC (Zdancewic 2002). Note that we establish the equivalence
to the source λSEC language (Figure 1), i.e., without term stamping,
since it is only needed internally to support small-step reduction.
As usual, 7−→∗ denotes the reﬂexive, transitive closure of 7−→.
Proposition 3. t ⇓ v if and only if t 7−→∗ v.

Proof.
Case (only if). By induction on t ⇓ v, using the admissibility of
the ⇓ rules in 7−→∗.

Case (if). By induction on the length of the reduction t 7−→∗ v.
Straightforward case analysis on t using the admissibility of the
inversion lemmas for ⇓ in 7−→∗.

3. Gradualizing λSEC
In gradualizing λSEC, we could decide to support unknown information 
in both types and security labels. Here, to show the ﬂexibility
of the AGT approach, we gradualize λSEC only in terms of security 
labels, thereby supporting a gradual evolution between simplytyped 
programs and securely-typed programs.

3.1 Meaning of Unknown Security Type Information
To gradualize our security types, we introduce a notion of gradual
labels and deﬁne their meanings in terms of concrete labels of a
given security lattice.
Deﬁnition 1 (Gradual labels). A gradual label ˜ℓ is either a label ℓ
or the unknown label ?.

˜ℓ ∈ GLABEL
˜ℓ

::= ℓ | ?

(gradual labels)

As with static security typing, we develop gradual security types

by assigning a gradual label to every type constructor.
Deﬁnition 2 (Gradual security type). A gradual security type is a
gradual type labeled with a gradual label:

eS ∈ GTYPE
eS ::= Bool ˜ℓ | eS →˜ℓ eS (gradual types)

To give meaning to gradual security types, we use the AGT
approach of deﬁning a concretization function that maps gradual
security types to sets of static security types. This concretization is
the natural lifting of a concretization for gradual labels.
Deﬁnition 3 (Label Concretization). Let γℓ : GLABEL → P(LABEL)
be deﬁned as follows:

γℓ(ℓ) = { ℓ }
γℓ(?) = LABEL

We give meaning to the unknown label by saying that it represents
any label. On the other hand, any static label represents only itself.
Since we are operating on complete lattices, the sound and
optimal abstraction function from sets of labels to gradual labels
is fully determined by the concretization. We characterize it below.
Deﬁnition 4 (Label Abstraction). Let αℓ : P(LABEL) → GLABEL
be deﬁned as follows:

αℓ({ ℓ }) = ℓ

αℓ(∅) is undeﬁned

αℓ(Ûℓ) = ? otherwise

Proposition 4 (αℓ is Sound). IfÛℓ is not empty, thenÛℓ ⊆ γℓ(αℓ(Ûℓ)).
Proof. By case analysis on the structure of Ûℓ. If Ûℓ = { ℓ } then
γℓ(αℓ({ ℓ })) = γℓ(ℓ) = { ℓ } =Ûℓ, otherwise
γℓ(αℓ(Ûℓ)) = γℓ(?) = LABEL ⊇Ûℓ.
Proposition 5 (αℓ is Optimal). IfÛℓ ⊆ γℓ(˜ℓ) then αℓ(Ûℓ) ⊑ ˜ℓ.

˜ℓ1 ⊑ ˜ℓ2

Bool˜ℓ1 ⊑ Bool ˜ℓ2

˜ℓ1 ⊑ ˜ℓ2

eS12 ⊑ eS22
eS11 ⊑ eS21
eS11 →˜ℓ1 eS12 ⊑ eS21 →˜ℓ2 eS22

Proof. By case analysis on the structure of ˜ℓ. If ˜ℓ = ℓ, γℓ(˜ℓ) =

{ ℓ };Ûℓ ⊆ { ℓ } ,Ûℓ 6= ∅ implies αℓ(Ûℓ) = αℓ({ ℓ }) = ℓ ⊑ ˜ℓ (if
Ûℓ = ∅, αℓ(Ûℓ) is undeﬁned). If ˜ℓ = ?, ˜ℓ′ ⊑ ˜ℓ for all ˜ℓ′.

Having deﬁned the meaning of gradual labels, we deﬁne the

meaning of gradual security types via concretization.
Deﬁnition 5 (Type Concretization). Let γS : GTYPE → P(TYPE)
be deﬁned as follows:

where

γS(Bool ˜ℓ) = { Boolℓ | ℓ ∈ γℓ(˜ℓ) }
γS(eS1) →γℓ(˜ℓ) γS(eS2)

γS(eS →˜ℓ eS) = ˇ 
¸ ÛS1 →Ûℓ ÛS2 = { S1 →ℓ S2 | Si ∈ γS(ÛSi), ℓ ∈Ûℓ } .

With concretization of security type, we can now deﬁne security

type precision.
Deﬁnition 6 (Label and Type Precision).
1. ˜ℓ1 is less imprecise than ˜ℓ2, notation ˜ℓ1 ⊑ ˜ℓ2, if and only if

γℓ(˜ℓ1) ⊆ γℓ(˜ℓ2); inductively:

˜ℓ ⊑ ?

˜ℓ ⊑ ˜ℓ

2. eS1 is less imprecise than eS2, notation eS1 ⊑ eS2, if and only if
γS(eS1) ⊆ γS(eS2); inductively:

We now deﬁne the abstraction function.

Deﬁnition 7 (Type Abstraction). Let the abstraction function αS :
P(TYPE) → GTYPE be deﬁned as:

αS({ Boolℓi }) = Boolαℓ({ ℓi })

αS({ Si1 →ℓi Si2 }) = αS({ Si1 }) →αℓ({ ℓi }) αS({ Si2 })

αS(ÛT ) is undeﬁned otherwise

We can only abstract valid sets of security types, i.e. in which

elements only defer by security labels.
Deﬁnition 8 (Valid Type Sets).

valid ({ Boolℓi })

valid({ (Si1 → Si2)ℓi })

valid ({ Si1 })

valid({ Si2 })

Proposition 6 (αS is Sound).

If valid (ÛS) thenÛS ⊆ γS(αS(ÛS)).
Proof. By well-founded induction on ÛS according to the ordering
relationÛS < ÛS deﬁned as follows:
Where¯dom,ˆcod : P(GTYPE) → P(GT ype) are the collecting

liftings of the domain and codomain functions dom, cod respectively,
 e.g.,

¯dom(ÛS) < ÛS
ˆcod (ÛS) < ÛS

¯dom(ÛS) = { dom(S) | S ∈ ÛS } .

We then consider cases onÛS according to the deﬁnition of αS.

Case ({ Boolℓi }).

γS(αS({ Boolℓi })) = γS(Boolαℓ({ ℓi }))

= { Boolℓ | ℓ ∈ γℓ(αℓ({ ℓi })) }
⊇ { Boolℓi } by soundness of αℓ.

Case ({ Si1 →ℓi Si2 }).

γS(αS({ Si1 →ℓi Si2 }))

= γS(αS({ Si1 }) →αℓ({ ℓi }) αS({ Si2 }))
= γS(αS({ Si1 }) →γℓ(αℓ({ ℓi })) γS(αS({ Si2 }))
⊇ { Si1 →ℓi Si2 }

by induction hypotheses on { Si1 } and { Si2 }, and soundness of
αℓ.

Proposition 7 (αS is Optimal). If valid (ÛS) and ÛS ⊆ γS(eS) then
αS(ÛS) ⊑ eS.
Proof. By induction on the structure of eS.
Case (Bool ˜ℓ). γS(Bool˜ℓ) = { Boolℓ | ℓ ∈ γℓ(˜ℓ) }
SoÛS = { Boolℓ | ℓ ∈Ûℓ } for someÛℓ ⊆ γℓ(˜ℓ). By optimality of αℓ,
αℓ(Ûℓ) ⊑ ˜ℓ, so αS({ Boolℓ | ℓ ∈Ûℓ }) = Bool
αℓ(Ûℓ)
Case (eS1 →˜ℓ eS2). γS(eS1 →˜ℓ eS2) = ˇ 
γS(eS1) →γℓ(˜ℓ) γS(eS2).
SoÛS = { S1i →li S2i }, with { S1i } ⊆ γS(eS1),
{ S1i } ⊆ γS(eS2), and { li } ⊆ γℓ(˜ℓ). By induction hypotheses,
αS({ S1i }) ⊑ eS1 and αS({ S2i }) ⊑ eS2, and by optimality of αℓ,
αℓ({ li }) ⊑ ˜ℓ. Hence αS({ S1i →li S2i }) =
αS({ S1i }) →αℓ({ li }) αS({ S2i }) ⊑ eS1 →˜ℓ eS2.

⊑ Bool˜ℓ.

3.2 Consistent Predicates and Operators
Following the AGT approach, we lift predicates on labels and types
to consistent predicates on the corresponding gradual labels and
gradual types. Consistent predicates hold if some member of the
collecting semantics satisﬁes the corresponding static predicate. We
lift partial functions to gradual partial functions, as per the standard
approach in abstract interpretation.

Deﬁnition 9 (Consistent label ordering). ˜ℓ1 e4 ˜ℓ2 if and only if

ℓ1 4 ℓ2 for some (ℓ1, ℓ2) ∈ γℓ(˜ℓ1) × γℓ(˜ℓ2).
Algorithmically:

ℓ1 4 ℓ2

? e4 ˜ℓ

Deﬁnition 10 (Gradual label join).

ℓ1 e4 ℓ2
˜ℓ1e≺˜ℓ2 = αℓ({ ℓ1≺ℓ2 | (ℓ1, ℓ2) ∈ γℓ(˜ℓ1) × γℓ(˜ℓ2) }).

Algorithmically:

˜ℓ e4 ?

⊤e≺? = ?e≺⊤ = ⊤
˜ℓe≺? = ?e≺˜ℓ = ? if ˜ℓ 6= ⊤
ℓ1e≺ℓ2 = ℓ1≺ℓ2

Both gradual label stamping and gradual join of security types

are obtained by lifting their corresponding static operations:

Deﬁnition 11 (Gradual label meet).

˜ℓ1e≺˜ℓ2 = αℓ({ ℓ1≺ℓ2 | (ℓ1, ℓ2) ∈ γℓ(˜ℓ1) × γℓ(˜ℓ2) }).

Algorithmically:

⊥e≺? = ?e≺⊥ = ⊥
˜ℓe≺? = ?e≺˜ℓ = ? if ˜ℓ 6= ⊥
ℓ1e≺ℓ2 = ℓ1≺ℓ2

We now lift subtyping to gradual security types.

Deﬁnition 12 (Consistent subtyping). eS1 . eS2 if and only if
S1 <: S2 for some (S1, S2) ∈ γS(eS1) × γS(eS2)

3.3 Gradual Security Type System
The gradual security type system is adapted from Figure 1 by lifting
static types and labels to gradual types and labels, lifting partial
functions on static types to partial functions on gradual types, and
lifting predicates on types and labels to consistent predicates on
gradual types and labels.

The AGT approach yields a gradual counterpart to an underlying 
static type system that satisﬁes a number of desirable properties.
 To state these properties, the following propositions use ⊢S to
denote the λSEC typing relation of Figure 1.
Proposition 8 (Conservative Extension). For t ∈ TERM,
⊢S t : S if and only if ⊢ t : S

Proof. By induction over the typing derivations. The proof is trivial
because static types are given singleton meanings via concretization.


natural lifting of type precision to terms.

In the following proposition, precision on termset1 ⊑ et2 is the
Proposition 9 (Static gradual guarantee). If ⊢et1 : eS1 andet1 ⊑et2,
then ⊢et2 : eS2 and eS1 ⊑ eS2.
By induction on typing derivation of Γ ⊢ et1 : eS1 using the
deﬁnition ofet1 ⊑et2.

Proof. Corollary of the corresponding proposition for open terms.

3.4 Dynamic Semantics of Gradual Security Typing
Interiors of consistent subtyping and label ordering. The interior 
of a consistent judgment expresses the most precise deducible
information about a consistent judgment. We deﬁne the interior of
a judgment in terms of our abstraction.
Deﬁnition 13 (Interior). Let P be a binary predicate on static
types. Then the interior of

the judgment eP (eT1, eT2), notation
IP (eT1, eT2), is the smallest tuple heT ′
2i ⊑2 heT1, eT2i such that
for hT1, T2i ∈ TYPE2, if hT1, T2i ∈ γ2(eT1, eT2) and P (T1, T2),
then hT1, T2i ∈ γ2(eT ′

It is formalized as follows:

1, eT ′

1, eT ′

2).

IP (eT1, eT2) = α2({ hT1, T2i ∈ γ2(eT1, eT2) | P (T1, T2) }).

We use case-based analysis to calculate the algorithmic rules for

the interior of consistent subtyping on gradual security types:

I4(˜ℓ1, ˜ℓ2) = h˜ℓ′

1, ˜ℓ′
2i
I<:(Bool ˜ℓ1 , Bool ˜ℓ2 ) = hBool ˜ℓ′

1

, Bool˜ℓ′

2

i

I<:(eS21, eS11) = heS′

21, eS′

11i

I4(˜ℓ1, ˜ℓ2) = h˜ℓ′

I<:(eS11 →˜ℓ1 eS12, eS21 →˜ℓ2 eS22) = heS′

I<:(eS12, eS22) = heS′
12, eS′

1, ˜ℓ′
2i
11 →˜ℓ′

1 eS′

22i

12, eS′

21 →˜ℓ′

22i

2 eS′

r ∈ RAWVALUE v ∈ VALUE Γ ∈ VAR

ﬁn
⇀ GTYPE

b ∈ BOOL, ⊕ ∈ BOOLOP

x ∈ VAR,

˜ℓ ∈ GLABEL, eS ∈ GTYPE,
et ∈ GTERM,
::= Bool˜ℓ | eS →˜ℓ eS
eS
::= b | λx : eS.et
::= v |etet |et ⊕et | ifet thenet elseet

⊕ ::= ∧ | ∨ | =⇒

::= true | false

::= rℓ

et

b
r
v

Γ ⊢ t : S

(gradual types)
(Booleans)
(base values)
(values)
(terms)
(operations)

Γ ⊢ b˜ℓ : Bool˜ℓ

The rules appeal to the algorithmic rules for the interior of

consistent label ordering, calculated similarly:

ℓ 6= ⊤

I4(ℓ, ?) = hℓ, ?i

I4(⊤, ?) = h⊤, ⊤i

ℓ 6= ⊥

I4(?, ℓ) = h?, ℓi

I4(?, ⊥) = h⊥, ⊥i

I4(˜ℓ, ˜ℓ) = h˜ℓ, ˜ℓi

(eSb)
Γ, x : eS1 ⊢et : eS2

(eSx) x : eS ∈ Γ
Γ ⊢ x : eS
(eSλ)
Γ ⊢et1 : Bool˜ℓ1

Γ ⊢ (λx : eS1.et)˜ℓ : eS1 →˜ℓ eS2
Γ ⊢et2 : Bool˜ℓ2
(eS⊕)
Γ ⊢et1 ⊕et2 : Bool
˜ℓ1e≺˜ℓ2
Γ ⊢et1 : eS11 →˜ℓ eS12
Γ ⊢et2 : eS2
Γ ⊢et1et2 : eS12e≺ ˜ℓ
Γ ⊢et1 : eS1
Γ ⊢et : Bool˜ℓ
Γ ⊢ ifet thenet1 elseet2 : (eS1e<
eS1 . eS2
Γ ⊢ t : eS1
(eS::)
Γ ⊢ t :: eS2 : eS2
eS2 . eS′
1 . eS1
eS′
eS1 →˜ℓ eS2 . eS′

˜ℓ e4 ˜ℓ′

(eSapp)
(eSif)

eS2 . eS11

Γ ⊢et2 : eS2
:eS2)e≺ ˜ℓ

eS . eS

: GTYPE × GTYPE ⇀ GTYPE

Bool˜ℓ . Bool˜ℓ′

:

:

:

:S

Bool˜ℓ′ = Bool

Se<
S, Se<
e<
Bool˜ℓe<
(˜ℓe≺˜ℓ′)
(eS11 →˜ℓ eS12)e<
eSe<
:eS undeﬁned otherwise
e<
Bool˜ℓe<
(eS11 →˜ℓ eS12)e<
:eS undeﬁned otherwise
eSe<
Figure 3. λfSEC

Bool˜ℓ′ = Bool

(˜ℓ≺˜ℓ′)

:

: : GTYPE × GTYPE ⇀ GTYPE

:

(eS21 →˜ℓ′ eS22) = (eS11e<

:eS21) →

:(eS21 →˜ℓ′ eS22) = (eS11e<

:eS21) →

: Syntax and Static Semantics

2

˜ℓ e4 ˜ℓ′
1 →˜ℓ′ eS′

2

(eS12e<

:eS22)

(˜ℓe≺˜ℓ′)

(eS12e<

:eS22)

(˜ℓe≺˜ℓ′)

b˜ℓ ∈ TERMBool ˜ℓ

xeS ∈ TERMeS

teS2 ∈ TERMeS2

˜ℓ1e≺˜ℓ2 ε2teS2 ∈ TERMBool

(λxeS1 .teS2 )˜ℓ ∈ TERMeS1→ ˜ℓeS2
teS1 ∈ TERMeS1
ε1 ⊢ eS1 . Bool˜ℓ1
teS2 ∈ TERMeS2
ε2 ⊢ eS2 . Bool˜ℓ2
ε1teS1 ⊕
˜ℓ1e≺˜ℓ2
teS1 ∈ TERMeS1
ε1 ⊢ eS1 . eS11 →˜ℓ eS12
teS2 ∈ TERMeS2
ε2 ⊢ eS2 . eS11
ε1teS1 @eS11→ ˜ℓeS12 ε2teS2 ∈ TERMeS12e≺˜ℓ
teS1 ∈ TERMeS1
ε1 ⊢ eS1 . Bool˜ℓ1
teS2 ∈ TERMeS2
ε2 ⊢ eS2 . (eS2e≺eS3)e≺ ˜ℓ1
teS3 ∈ TERMeS3
ε3 ⊢ eS3 . (eS2e≺eS3)e≺ ˜ℓ1
if ε1teS1 then ε2teS2 else ε3teS3 ∈ TERM
(eS2e<
:eS3)e≺˜ℓ1
ε1 ⊢ eS1 . eS2

teS1 ∈ TERMeS1
ε1teS1 :: eS2 ∈ TERMeS2
Figure 4. λfSEC

: Gradual Intrinsic Terms

Intrinsic terms. Fig. 4 presents the intrinsic terms for λfSEC

. Note
that we do not need to introduce term stamping in this language.
Since terms are intrinsically typed and we have ascriptions, labels
can be stamped at the type level.

Reduction. Evaluation uses the consistent transitivity operator
◦<: to combine evidences:

heS1, eS21i ◦<: heS22, eS3i = △<:(eS1, eS21 ⊓ eS22, eS3)

First we calculate a recursive meet operator for gradual types:

Bool ˜ℓ ⊓ Bool˜ℓ′ = Bool ˜ℓ⊓˜ℓ′

(eS11 →˜ℓ eS12) ⊓ (eS21 →˜ℓ′ eS22) = (eS11 ⊓ eS21) →˜ℓ⊓˜ℓ′ (eS12 ⊓ eS22)

eS ⊓ eS′ undeﬁned otherwise

where ˜ℓ ⊓ ˜ℓ′ = αℓ(γℓ(˜ℓ) ∩ γℓ(˜ℓ′)), or algorithmically:

˜ℓ ⊓ ? = ? ⊓ ˜ℓ = ˜ℓ
ℓ ⊓ ℓ = ℓ
ℓ ⊓ ℓ′ undeﬁned otherwise

We calculate a recursive deﬁnition for △<: by case analysis on

the structure of the second argument,

△4(˜ℓ1, ˜ℓ2, ˜ℓ3) = h˜ℓ1, ˜ℓ3i

△<:(Bool˜ℓ1 , Bool˜ℓ2 , Bool ˜ℓ3 ) = hBool ˜ℓ1 , Bool ˜ℓ3 i

△<:(eS31, eS21, eS11) = heS31, eS11i
△<:(eS12, eS22, eS32) = heS12, eS32i

△4(˜ℓ1, ˜ℓ2, ˜ℓ3) = h˜ℓ1, ˜ℓ3i

△<:(eS11 →˜ℓ1 eS12, eS21 →˜ℓ2 eS22, eS31 →˜ℓ3 eS32)
= heS11 →˜ℓ1 eS12, eS31 →˜ℓ3 eS32i

with the following deﬁnition of △4, again calculated by case
analysis on the middle gradual label:

△4(˜ℓ1, ⊤, ˜ℓ3) = h˜ℓ1, ⊤i

⊤ e4 ˜ℓ3
˜ℓ1 e4 ˜ℓ2

˜ℓ2 e4 ˜ℓ3

△4(˜ℓ1, ˜ℓ2, ˜ℓ3) = h˜ℓ1, ˜ℓ3i

˜ℓ1 e4 ⊥

△4(˜ℓ1, ⊥, ˜ℓ3) = h⊥, ˜ℓ3i

˜ℓ2 6∈ { ⊥, ⊤ }

The reduction rules are given in Fig. 5. The evidence inversion
functions reﬂect the contravariance on arguments and the need to
stamp security labels on return types:

idom(heS′
icod (heS′

2, eS′
1 →˜ℓ′ eS′
1 →˜ℓ′′ eS′′
1 →˜ℓ′′ eS′′
2, eS′′
1 →˜ℓ′ eS′

2 i) = heS′′
2 i) = heS′

1 , eS′
2e≺˜ℓ′, eS′′

1i

2 e≺˜ℓ′′i

3.5 Example
Consider a simple lattice with two conﬁdentiality levels, L = ⊥
and H = ⊤, and the following extrinsic program deﬁnitions:

f , (λx : BoolL.x)L
g , (λx : Bool?.x)L

v , falseH

a public channel
an unknown channel
that can be publicly used
a private value

f v does not type check, but f (g v) does typecheck, even though
it fails at runtime. Type checking yields the corresponding intrinsic
deﬁnitions:

(heSf , eSf i f ) @eSf (cid:16)hL, Li (heSg, eSgi g) @eSg (hH, Hi v))(cid:17)

where the intrinsic subterms are essentially identical to their extrinsic 
counterparts:

f , (λxBoolL .x)L
g , (λxBool? .x)L

v , falseH

a public channel
an unknown channel
that can be publicly used
a private value

refer to the types of f and g, and elide the application operators

For conciseness, we abbreviate Bool ˜ℓ with ˜ℓ, use eSf and eSg to
@eS. At each step, we use grey boxes to highlight the focus of

reduction/rewriting, and underline the result.

ε ∈ EVIDENCE,
t ∈ TERM∗,

et ∈ EVTERM,

ev ∈ EVVALUE, u ∈ SIMPLEVALUE,

v ∈ VALUE,

g ∈ EVFRAME,

f ∈ TMFRAME

::= heS,eSi

::= εt
::= εu
::= x | b˜ℓ | (λx.t)˜ℓ

ε
et

ev
u

v

g

f

::= u | εu :: eS

::= (cid:3) ⊕
|
::= g[ε(cid:3)]

˜ℓ et | ev ⊕

if (cid:3) then et else et

˜ℓ (cid:3) | (cid:3) @eS et | ev @eS (cid:3) | (cid:3) :: eS

Notions of Reduction

, Bool

error

1

2

2

(˜ℓ′

2)

(˜ℓ′′

2 )

if ε1b˜ℓ

−→: TERMeS

hBool˜ℓ′

1

i (b2)˜ℓ2

−→

i (b1)˜ℓ1

:: Bool˜ℓ

, Bool˜ℓ′′

∪ { error })

i (b1 J⊕K b2)

(˜ℓ1e≺˜ℓ2)

, Bool˜ℓ′′
hBool

if (ε2 ◦<: idom (ε1)) not deﬁned

× (TERMeS
⊕˜ℓ hBool˜ℓ′
1e≺˜ℓ′′
1e≺˜ℓ′
@eS1→ ˜ℓeS2 ε2u −→
ε1(λxeS11 .t∗)˜ℓ1
ßicod (ε1)([((ε2 ◦<: idom (ε1))u :: eS11)/xeS1 ]t∗) :: eS2e≺ ˜ℓ
then ε2teS2 else ε3teS3 −→®ε2teS2 :: (eS2e<
:eS3)e≺ ˜ℓ
ε3teS3 :: (eS2e<
:eS3)e≺ ˜ℓ
ε1(ε2v :: eS) −→cß(ε2 ◦<: ε1)v
× (TERMeS
teS −→ r

if not deﬁned

∪ { error })

∪ { error })

−→c: EVTERM × (EVTERM ∪ { error })

7−→: TERMeS

(R−→)

b = true

b = false

error

Reduction

r ∈ (TERMeS
teS 7−→ r

(Rgerr)

(Rferr)

et −→c error
g[et] 7−→ error

1 7−→ error
1 ] 7−→ error

teS
f [teS

: Intrinsic Reduction

(Rg)

et −→c et ′
g[et] 7−→ g[r]

2

2 ]

teS
1 7−→ teS
1 ] 7−→ f [teS
f [teS
Figure 5. λfSEC

L ) (hH, Hi v) )(cid:1)

(heSf ,eSf i f )(cid:0) hL, Li ((heSg ,eSgi g ) (hH, Hi v))(cid:1)
(heSf ,eSf i f )(cid:0) hL, Li ( (heSg ,eSgi (λx?.x)eSg
(heSf ,eSf i f )(cid:0) hL, Li (?, ?([ (hH, Hi ◦<: h?, ?i) v :: ?/x]x) :: ?)(cid:1)
(heSf ,eSf i f )(cid:0) hL, Li (?, ?( [hH, Hiv :: ?/x]x ) :: ?)(cid:1)
(heSf ,eSf i f )(cid:0) hL, Li ( ?, ?(hH, Hi v :: ?) :: ?)(cid:1)
(heSf ,eSf i f )(cid:0) hL, Li ( (hH, Hi ◦<: h?, ?i) v :: ?)(cid:1)
(heSf ,eSf i f )(cid:0) hL, Li (hH, Hiv :: ?) (cid:1)
(heSf ,eSf i f )(cid:0)error(cid:1)

because hH, Hi ◦<: hL, Li = △<:(H, H ⊓ L, L)
which is undeﬁned because H ⊓ L is undeﬁned.

(Rf)

=

−→

=◦<:

=[t/t]t

−→c

=◦<:

−→c

4. Noninterference for λgSEC

We establish noninterference for the gradual security language
using logical relations, adapting the technique from Zdancewic
(2002).

First, in the intrinsic setting, the type environment related to an
open term t is simply the set of (intrinsically-typed) free variables
of the term, F V (t). We use the metavariable Γ ∈ P(VAR∗) to
denote such “type-environments-as-sets”.

Informally, the noninterference theorem states that a program
with low (visible) output and a high (private) input can be run with
different high-security values and, if terminating, will always yield
the same observable value.2
Theorem 10 (Noninterference).

with F V (t) =

if t ∈ TERMBool ˜ℓ

{ x } , x ∈ TERMeS

t[v1/x] 7−→∗ v′

, and v1, v2 ∈ TERMeS

1 ∧ t[v2/x] 7−→∗ v′

with label (eS) 6e4 ˜ℓ, then

1) = bval(v′
2)

2 ⇒ bval(v′

Proof. The result follows by using the method of logical relations
(following Zdancewic (2002)), as a special case of Lemma 15
below.

Note that we compare equality of bare values at base types,
stripping the checking-related information (labels, evidences and

ascriptions): i.e. bval(b˜ℓ) = b and bval(εb˜ℓ :: eS) = b. Also,

gradual programs can fail. We establish termination-insensitive
noninterference, meaning in particular that any program may run
into an error without violating noninterference.
Deﬁnition 14 (Gradual security logical relations). For an arbitrary
element ζ of the security lattice, the ζ-level gradual security relations 
are type-indexed binary relations on closed terms deﬁned

inductively as presented in Figure 6. The notation v1 ≈ζ v2 : eS
indicates that v1 is related to v2 at type eS when observed at the
security level ζ. Similarly, the notation t1 ≈ζ t2 : C(eS) indicates
at type eS when observed at the security level ζ.

that t1 and t2 are related computations that produce related values

The logical relations are very similar to those of Zdancewic
(2002), except for the points discussed above and the fact that we
account for subtyping in the relation between values at a function
type (recall that our type system is syntax-directed).
Deﬁnition 15 (Secure program). A well-typed program t that proDeﬁnition 
16 (Related substitutions). Two substitutions σ1 and σ2
are related, notation Γ ⊢ σ1 ≈ζ σ2, if σi |= Γ and

duces a ζ-observable output of type eS (i.e. label(eS) e4 ζ) is secure
iff t ≈ζ t : C(eS).
∀xeS ∈ Γ.σ1(xeS) ≈ζ σ2(xeS) : eS.
Lemma 11 (Substitution preserves typing). If teS ∈ TERMeS
σ |= F V (teS ) then σ(teS) ∈ TERMeS
Proof. By induction on the derivation of teS ∈ TERMeS
TERMeS
label(Bool˜ℓ) = ˜ℓ and label(eS1 →˜ℓ eS2) = ˜ℓ.

i, we have t1 ≈ζ t2 : C(eS) if and only if

Lemma 12 (Reduction preserves relations). Consider t1, t2 ∈

2 The label function returns the top-level security label of the given type:

2 : C(eS)

. Posing ti 7−→∗ t′

t′
1 ≈ζ t′

and

.

.

7−→∗.

Proof. Direct by deﬁnition of t1 ≈ζ t2 : C(eS) and transitivity of
Lemma 13 (Canonical forms). Consider a value v ∈ TERMeS
Then either v = u, or v = εu :: eS with u ∈ TERMeS ′ and
ε ⊢ eS′ . eS. Furthermore:
1. If eS = Bool˜ℓ then either v = b˜ℓ or v = εb˜ℓ′ :: Bool ˜ℓ with
b˜ℓ′ ∈ TERMBool ˜ℓ′ and ε ⊢ Bool˜ℓ′ . Bool ˜ℓ.
2. If eS = eS1 →˜ℓ eS2 then either v = (λxeS1.teS2 )˜ℓ with teS2 ∈
:: eS1 →˜ℓ eS2 with teS ′
TERMeS2
TERMeS ′

1.teS ′
or v = ε(λxeS ′
and ε ⊢ eS′
1 →˜ℓ′ eS′
2 . eS1 →˜ℓ eS2.

Proof. By direct inspection of the formation rules of gradual intrinsic 
terms (Figure 4).

2 )˜ℓ′

2 ∈

2

Lemma 14 (Ascription preserves relation). Suppose ε ⊢ eS′ . eS.
1. If v1 ≈ζ v2 : eS′ then (εv1 :: eS) ≈ζ (εv2 :: eS) : C(eS).
2. If t1 ≈ζ t2 : C(eS′) then (εt1 :: eS) ≈ζ (εt2 :: eS) : C(eS).
tion on the judgment ε ⊢ eS′ . eS. The difference here is that consistent 
subtyping is justiﬁed by evidence, and that the terms have
to be ascribed to exploit subtyping. In particular, case 1 above establishes 
a computation-level relation because each ascribed term

Proof. Following Zdancewic (2002), the proof proceeds by induc-

(εvi :: eS) may not be a value: each value vi is either a bare value
ui or a casted value εiui :: eSi, with εi ⊢ Si . eS. In the latter
case, (ε(εiui :: eSi) :: eS) either steps to error (in which case the
relation is vacuously established), or steps to ε′ui :: eS, which is a

value.

Noninterference follows directly from the following lemma,
which establishes that substitution preserves the logical relations:

,

ing the last step used in the derivation:

Lemma 15 (Substitution preserves relation).

If teS ∈ TERMeS
Γ = F V (teS), and Γ ⊢ σ1 ≈ζ σ2, then σ1(teS ) ≈ζ σ2(teS ) : C(eS).
Proof. By induction on the derivation that t ∈ TERMeS
Case (x). teS = xeS so Γ = {xeS}. Γ ⊢ σ1 ≈ζ σ2 implies by
deﬁnition that σ1(xeS) ≈ζ σ2(xeS) : eS.
Case (b). teS = b˜ℓ. By deﬁnition of substitution, σ1(b˜ℓ) =

σ2(b˜ℓ) = b˜ℓ. By deﬁnition, b˜ℓ ≈ζ b˜ℓ : Bool ˜ℓ as required.

. Consider-

——–

——–

Lemma 11:

6∈ dom(σi), and

Case (λ). teS = (λxeS1.teS2 )˜ℓ. Then eS = eS1 →˜ℓ eS2.
By deﬁnition of substitution, assuming xeS1
σi(teS ) = (λxeS1 .σi(teS2 ))˜ℓ ∈ TERMeS
1, with ε2 ⊢ eS′

If ˜ℓ 6 e4 ζ the result holds trivially because all function values are
related in such a cases. Assume ˜ℓ e4 ζ, and assume two values
v1 and v2 such that v1 ≈ζ v2 : eS′
1 . eS1. (We
omit the @eS operator in applications below since we simply pick

v1 ≈ζ v2 : Bool ˜ℓ ⇐⇒ vi ∈ TERMBool ˜ℓ

v1 ≈ζ v2 : eS1 →˜ℓ eS2 ⇐⇒ vi ∈ TERMeS1→ ˜ℓeS2
ε1 ⊢ eS1 →˜ℓ eS2 . eS′
2 : eS′′
t1 ≈ζ t2 : C(eS) ⇐⇒ ti ∈ TERMeS

1 ≈ζ v′

∀v′

∧ ˜ℓ e4 ζ =⇒ bval(v1) = bval(v2)
∧ ˜ℓ e4 ζ =⇒ ∀ε1, ε2, eS′
2, and eS′′
1 →˜ℓ′ eS′
1 →˜ℓ′ eS′
2 and ε2 ⊢ eS′′
1 . eS′
1 . (ε1v1 @eS ′
1→ ˜ℓ′eS ′
1) ≈ζ (ε1v2 @eS ′
1→ ˜ℓ′eS ′
∧ (t1 7−→∗ v1 ∧ t2 7−→∗ v2 =⇒ v1 ≈ζ v2 : eS)

1, we have:

2 ε2v′

Figure 6. Gradual security logical relations

1 such that

2 ε2v′

2) : C(eS2e≺˜ℓ)

eS = eS1 →˜ℓ eS2.)

We need to show that:

≈ζ

ε1(λxeS1.σ1(teS2 ))˜ℓ ε2v1
ε1(λxeS1.σ2(teS2 ))˜ℓ ε2v2

: C(eS2e≺˜ℓ)

Each vi is either a bare value ui or a casted value ε2iui :: eS′

1.
In the latter case, the application expression combines evidence,
which may fail with error. If it succeeds, we call the combined
evidence ε′
2i. The application rule then applies: it may fail with
error if the evidence ε′
2i cannot be combined with the evidence
for the function parameter. In all of the failure cases, the relation
vacuously holds. We therefore consider the only interesting case,
where the applications succeed. We have:

ε1(λxeS1 .σi(teS2 ))˜ℓ ε′

2iui

7−→ εr([εaui :: eS1/xeS1 ]σi(teS2 )) :: eS2e≺˜ℓ

where εr and εai are the new evidences for the return value and
argument, respectively. We then extend the substitutions to map

xeS1 to the casted arguments:
By Lemma 14.1, (εa1u1 :: eS1) ≈ζ (εa2u2 :: eS1) : eS1
So Γ, xeS1 ⊢ σ′

i = σi{xeS1 7→ εaui :: eS1}

2. By induction hypothesis:

1 ≈ζ σ′

σ′

By the deﬁnition of substitution, this is exactly:

σ′

1(teS2) ≈ζ σ′

2(teS2) : C(eS2)

[εau1 :: eS1/xeS1 ]σ1(teS2) ≈ζ [εau2 :: eS1/xeS1 ]σ2(teS2 ) : C(eS2)
Finally, since εr ⊢ eS2 . eS2e≺˜ℓ, by Lemma 14.2:
εr[εau1 :: eS1/xeS1 ]σ1(teS2 ) :: eS2e≺ ˜ℓ
εr[εau2 :: eS1/xeS1 ]σ2(teS2 ) :: eS2e≺ ˜ℓ

By backward preservation of the relations (Lemma 12), this implies
that:

: C(eS2e≺˜ℓ)

≈ζ

≈ζ

ε1(λxeS1.σ1(teS2 ))˜ℓ ε2v1
ε1(λxeS1.σ2(teS2 ))˜ℓ ε2v2

——–

: C(eS2e≺˜ℓ)

Case (⊕). teS = ε1teS1 ⊕˜ℓ ε2teS2

By deﬁnition of substitution and Lemma 11:

σi(teS ) = ε1σi(teS1 ) ⊕

By induction hypotheses:

˜ℓ ε2σi(teS2 ) ∈ TERMeS

σ1(teS1 ) ≈ζ σ2(teS1 ) : C(eS1) and σ1(teS2 ) ≈ζ σ2(teS2 ) : C(eS2)

By deﬁnition of related computations:

σ1(teS1 ) 7−→∗ v11 ∧ σ2(teS1 ) 7−→∗ v21 ⇒ v11 ≈ζ v21 : eS1
σ1(teS2 ) 7−→∗ v12 ∧ σ2(teS2 ) 7−→∗ v22 ⇒ v12 ≈ζ v22 : eS2
:: eSj. In case a value vij is a casted value,
then the whole term σi(teS ) can take a step by (Rg), combining εi

By Lemma 13, each vij is either a boolean (bij)˜ℓij
boolean εij(bij )˜ℓ′

with εij. Such a step either fails, or succeeds with a new combined
evidence. Therefore, either:

or a casted

ij

σi(teS) 7−→∗ error

in which case we do not care since we only consider terminationinsensitive 
noninterference, or:

σi(teS )

7−→∗
ε′
1(bi1)˜ℓ′
7−→ ε′(bi)˜ℓ′

⊕˜ℓ ε′
:: Bool ˜ℓ

i1

i

2(bi2)˜ℓ′

i2

with bi = bi1J⊕Kbi2 and ˜ℓ′

i = ˜ℓ′
≈ζ (b2)˜ℓ′

i1e≺˜ℓ′

i2. It remains to show that:
: Bool ˜ℓ

2

(b1)˜ℓ′

1

If ˜ℓ 6e4 ζ, then the result holds trivially because all boolean values
are related. If ˜ℓ e4 ζ, then also ˜ℓ′
i e4 ζ, which means by deﬁnition of

≈ζ on boolean values, that b11 = b21 and b12 = b22, so b1 = b2.

——–

Case (app). teS = ε1teS1 @eS11→ ˜ℓeS12 ε2teS2
with ε1 ⊢ eS1 . S11 →˜ℓ S12, ε2 ⊢ eS2 . eS11, and eS = eS12e≺˜ℓ.
We omit the @eS11→ ˜ℓeS12 operator in applications below.

By deﬁnition of substitution and Lemma 11:

σi(teS ) = ε1σi(teS1) ε2σi(teS2 ) ∈ TERMeS

By induction hypothesis:

By deﬁnition of related computations:

σ1(teS1 ) ≈ζ σ2(teS1 ) : C(eS1) and σ1(teS2 ) ≈ζ σ2(teS2 ) : C(eS2)
σ1(teS1 ) 7−→∗ v11 ∧ σ2(teS1 ) 7−→∗ v21 ⇒ v11 ≈ζ v21 : eS1
σ1(teS2 ) 7−→∗ v12 ∧ σ2(teS2 ) 7−→∗ v22 ⇒ v12 ≈ζ v22 : eS2

By deﬁnition of ≈ζ at values of function type, using ε1 and ε2 to
justify the subtyping relations, we have:

(ε1v11 ε2v12) ≈ζ (ε1v21 ε2v22) : C(eS12e≺˜ℓ)

——–

Case (if).

TERMeSi

By deﬁnition of substitution:

teS = if ε1teS1 then ε2teS2 else ε3teS3, with teSi ∈
, ε1 ⊢ eS1 . Bool ˜ℓ1
σi(teS ) = if ε1σi(teS1 ) then ε2σi(teS2 ) else ε3σi(teS3 )

and eS = (eS2e<

:eS3)e≺˜ℓ1

If ˜ℓ 6e4 ζ, then σ1(teS ) ≈ζ σ2(teS ) : C(eS) holds trivially because the
≈ζ relations relate all such well-typed terms. Let us assume ˜ℓ e4 ζ.

By the induction hypothesis we have that:

σ1(teS1) ≈ζ σ2(teS1) : C(eS1)

v11 ≈ζ v21 : eS1

Assuming σi(teS1 ) 7−→∗ vi1, by the deﬁnition of ≈ζ we have:
By Lemma 13, each vi1 is either a boolean (bi1)˜ℓi1
boolean εi1(bi1)˜ℓ′

or a casted
implies
, so by deﬁnition of ≈ζ on boolean values, b11 = b21.

:: eS1. In either case, eS1 . Bool ˜ℓ1

eS1 = Bool ˜ℓ′
In case a value vi1 is a casted value, then the whole term σi(teS )

can take a step by (Rg), combining εi with εi1. Such a step either
fails, or succeeds with a new combined evidence. Therefore, either:

i1

1

σi(teS ) 7−→∗ error

in which case we do not care since we only consider terminationinsensitive 
noninterference, or:

if ε′

7−→∗

1(bi1)˜ℓ′

σi(teS)
then ε2σi(teS2) else ε3σi(teS3 )
Because b11 = b21, both σ1(teS ) and σ2(teS) step into the same

branch of the conditional. Let us assume the condition is true (the
other case is similar). Then:

1

By induction hypothesis:

σi(teS) 7−→ ε2σi(teS2 ) :: eS
σ1(teS2) ≈ζ σ2(teS2) : C(eS2)

Assume σi(teS2 ) 7−→∗ vi2, then v12 ≈ζ v22 : eS2. Since ε2 ⊢ eS2 .
eS, by Lemma 14 we have:

(ε2σ1(teS2 ) :: eS) ≈ζ (ε2σ2(teS2 ) :: eS) :: C(eS)

——–

Jif (Zheng and Myers 2007). Furthermore, both designs treat an
unlabeled type as having the top label, then allowing explicit casts
downward in the security lattice. This design is analogous to the
internal language of the quasi-static typing approach. In that approach,
 explicit casts work well, but the external language there
accepts too many programs. That difﬁculty was the original motivation 
for consistency in gradual typing (Siek and Taha 2006).

Thiemann and Fennell (2014) develop a generic approach to
gradualize annotated type systems. This is similar to security typing
(labels are one kind of annotation), except that they only consider
annotation on base types, and the language only includes explicit
casts, like the gradual security work discussed above. They track
blame and provide a translation that removes unnecessary casts.

Acknowledgments We thank Mat´ıas Toro for feedback and contributing 
the proofs of Propositions 1 and 2 in Appendix A.

References
F. Ba˜nados Schwerter, R. Garcia, and ´E. Tanter. A theory of gradual
effect systems.
In 19th ACM SIGPLAN Conference on Functional
Programming (ICFP 2014), pages 283–295, Gothenburg, Sweden, Sept.
2014. ACM Press.

T. Disney and C. Flanagan. Gradual information ﬂow typing. In International 
Workshop on Scripts to Programs, 2011.

R. Garcia, A. M. Clark, and ´E. Tanter. Abstracting gradual typing.

L. Fennell and P. Thiemann. Gradual security typing with references. In
Computer Security Foundations Symposium, pages 224–239, June 2013.
In
43rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming 
Languages (POPL 2016), St Petersburg, FL, USA, Jan. 2016. ACM
Press.

J. G. Siek and W. Taha. Gradual typing for functional languages. In Scheme

and Functional Programming Workshop, pages 81–92, Sept. 2006.

P. Thiemann and L. Fennell. Gradual typing for annotated type systems. In
Z. Shao, editor, 23rd European Symposium on Programming Languages
and Systems (ESOP 2014), volume 8410 of LNCS, pages 47–66, Grenoble,
 France, 2014. Springer-Verlag.

S. Zdancewic. Programming Languages for Information Security. PhD

thesis, Cornell University, Aug. 2002.

L. Zheng and A. C. Myers. Dynamic security labels and noninterference.

International Journal of Information Security, 6(2):67–84, Mar. 2007.

A. Auxiliary Proofs
Proposition 1. If Γ ⊢ t : S then Γ ⊢Z t : S.

By deﬁnition of substitution:

Case (::). teS = εteS1 :: eS, with teS1 ∈ TERMeS1
σi(teS) = ε1σi(teS1 ) :: eS
σ1(teS1) ≈ζ σ2(teS1) : C(eS1)

The result follows directly by Lemma 14.

By induction hypothesis:

and ε1 ⊢ eS1 . eS.

Proof. By induction on Γ ⊢ t : S.

As most of the type rules are identical, most of the cases are
straightforward. The exceptions to this are the (Sif) and (Sapp)
rules.
Case (Sif). Then

D0

D1

D2

Γ ⊢ t0 : Boolℓ
Γ ⊢ if t0 then t1 else t2 : (S1<

Γ ⊢ t1 : S1

Γ ⊢ t2 : S2
:S2)≺ℓ

D =

5. Related Work and Conclusion
The design of a gradual security-typed language is a novel contribution.
 Despite the fact that both Disney and Flanagan (2011)
and Fennell and Thiemann (2013) have proposed languages for security 
typing dubbed gradual, they do not propose gradual source
languages. Rather, the language designs require explicit security
casts—which can also be encoded with a label test expression in

By Lemma 16, S1 <: (S1 <
Lemma 17 (S1<
:S2) <: (S1<
:S2)≺ℓ.
and S2 <: (S1<
Combining these with the induction hypotheses, we get

: S2) and S2 <: (S1 <
:S2)≺ℓ, therefore S1 <: (S1<

: S2), and by
:S2)≺ℓ

Ei

E0

Γ ⊢Z ti : Si Si <: (S1<

:S2)≺ℓ

Γ ⊢Z t0 : Boolℓ

Γ ⊢Z ti : (Si<

:S2)≺ℓ

E =

Γ ⊢Z if t0 then t1 else t2 : (S1<

:S2)≺ℓ

Case (λSEC-APP). Then t = t1 t2 and Γ ⊢Z t1 t2 : S12 ≺ ℓ
for some S12 and ℓ such that Γ ⊢Z t1 : S11 →ℓ S12 and
Γ ⊢Z t2 : S11.
Using induciton hypothesis on the premises we also know that
12 and ℓ′ such that
Γ ⊢ t1 : S′
S11 <: S′
11, S′
12 such that
S′′
11 <: S11. By transitivity on subtyping then S′′
11. Then
12 ≺ℓ′ and by Lemma 18 if we choose
by (Sapp) Γ ⊢ t1 t2 : S′
S′ = S′
12≺ℓ′ <: S12≺ℓ, i.e. S′ <: S.

11 →ℓ′ S′
12 <: S12 and ℓ′ 4 ℓ, and that Γ ⊢ t2 : S′′

12≺ℓ′, we conclude that S′

12 for some S′

11 <: S′

11, S′

Lemma 19. Let S1, S2 and S3 ∈ TYPE.
1. If (S1 <

:S2) is deﬁned, S1 <: S3 and S1 <: S3 then (S1 <

:

S2) <: S3.

2. If (S1 <

:S2) is deﬁned, S3 <: S1 and S3 <: S2 then S3 <:

(S1<

:S2).

:S2) <: S3.

:S2).
Proof. We start by proving (1) by case analysis on type (S1<
:S2) is deﬁned then S1 = Boolℓ1 and S2 =
Case (Boolℓ). As (S1<
Boolℓ2 for some ℓ1 and ℓ2. Also as S1 <: S3, then S3 = Boolℓ3
for some ℓ3. By (<:Bool), ℓ1 4 ℓ3 and ℓ2 4 ℓ3 then by deﬁnition of
:S2) = Bool(ℓ1≺ℓ2) <: Boolℓ3, i.e.
≺, (ℓ1≺ℓ2) 4 ℓ3. Then (S1 <
(S1<
:S2) is deﬁned then S1 = S11 →ℓ1 S12
Case (S →ℓ S). As (S1<
and S2 = S21 →ℓ1 S22 for some S11, S12, S21, S22, ℓ1 and ℓ2.
Also as S1 <: S3, then S3 = S31 →ℓ3 S32 for some S31, S32
and ℓ3. By (<:→), S31 <: S11, S12 <: S32, S31 <: S21, S22 <:
S32, ℓ1 4 ℓ3 and ℓ2 4 ℓ3.
: S22). By
Then (S1 <
using induction hypothesis (2) then S31 <: (S11 <
: S21) and by
:S22) <: S32. Also by
using induction hypothesis (1) then (S12 <
deﬁnition of ≺, (ℓ1 ≺ ℓ2) 4 ℓ3. Finally by (<:→) we conclude
: S22) <: S31 →ℓ3 S32, i.e.
that (S11 <
(S1<

:S2) <: S3.
The proof of (2) is similar to (1) but using the argument that if

: S21) →(ℓ1≺ℓ2) (S12 <

: S21) →(ℓ1≺ℓ2) (S12 <

: S2) = (S11 <

ℓ3 4 ℓ1 and ℓ3 4 ℓ2 then ℓ3 4 (ℓ1≺ℓ2).

Case (Sapp). Then t = t1 t2 and Γ ⊢ t1 t2 : S12≺ℓ for some S12
and ℓ such that Γ ⊢ t1 : S11 →ℓ S12, Γ ⊢ t2 : S2 and S2 <: S11.
Using induction hypothesis on t2 we know that Γ ⊢Z t2 : S2. As
S2 <: S11. Then by (λSEC-SUB) Γ ⊢Z t2 : S11. Using induction
hypothesis on t1, Γ ⊢Z t1 : S11 →ℓ S12, then by (λSEC-APP) we
conclude that Γ ⊢Z t1 t2 : S12≺ℓ

Lemma 16. Let S1, S2 ∈ TYPE. Then
1. If (S1<
2. If (S1<

:S2) is deﬁned then S1 <: (S1<
:S2) is deﬁned then (S1<

:S2).
:S2) <: S1.

:S2).

Proof. We start by proving (1) assuming that (S1≺S2) is deﬁned.
We proceed by case analysis on S1.
:S2) is deﬁned then
Case (Boolℓ). If S1 = Boolℓ1 then as (S1 <
S2 must have the form Boolℓ2 for some ℓ2. Therefore (S1<
:S2) =
Bool(ℓ1≺ℓ2). But by deﬁnition of 4, ℓ1 4 (ℓ1≺ℓ2) and therefore
we use (<:Bool) to conclude that Boolℓ1 <: Bool(ℓ1≺ℓ2), i.e.
S1 <: (S1<
:S2) is deﬁned
Case (S →ℓ S). If S1 = S11 →ℓ1 S12 then as (S1<
then S2 must have the form S21 →ℓ2 S22 for some S21, S22 and
ℓ2.
We also know that (S1<
By deﬁnition of 4, ℓ1 4 (ℓ1≺ℓ2). Also, as (S1<
(S11<
(S11<
S12 we also know that S12 <: (S12<
conclude that S11 →ℓ1 S12 <: (S11<
i.e. S1 <: (S1<

:S22).
:S2) is deﬁned then
:S21) is deﬁned. Using the induction hypothesis of (2) on S11,
:S21) <: S11. Also, using the induction hypothesis of (1) on
:S22). Then by (<:→) we can
:S22),
:S21) →(ℓ1≺ℓ2) (S12<

:S21) →(ℓ1≺ℓ2) (S12<

:S2) = (S11<

:S2).

The proof of (2) is similar to (1) but using the argument that

(ℓ1≺ℓ2) 4 ℓ1.

Lemma 17. Let S ∈ TYPE and ℓ ∈ LABEL. Then S <: S≺ℓ.

Proof. Straigthforward case analysis on type S using the fact that
ℓ 4 (ℓ′≺ℓ) for any ℓ′.

Lemma 18. Let S1, S2 ∈ TYPE such that S1 <: S2, and let
ℓ1, ℓ2 ∈ LABEL such that ℓ1 4 ℓ2. Then S1≺ℓ1 <: S2≺ℓ2.

Proof. Straightforward case analysis on type S using the deﬁnition
of label stamping on types.

Proposition 2. If Γ ⊢Z t : S Then Γ ⊢ t : S′ for some S′ <: S.

Proof. By induction on derivations of Γ ⊢Z t : S.

We proceed by case analysis on t (modulo (λSEC-SUB)). As
most of the type rules are identical, most of the cases are straightforward.
 The exception to this is case (λSEC-COND) and (λSEC-
APP):
Case (λSEC-COND). Then t = if t′ then t1 else t2 and
Γ ⊢Z if t′ then t1 else t2 : Sz≺ℓ for some Sz, and l such that
Γ ⊢Z t′ : Boolℓ, Γ ⊢Z t1 : S≺ℓ and Γ ⊢Z t2 : S≺ℓ.
Using induction hypothesis on the premises we also know that
Γ ⊢ t′ : Boolℓ′ for some ℓ′ 4 ℓ, Γ ⊢ t1 : S′
1 <: S≺ℓ,
and Γ ⊢ t2 : S′
By (Sif), Γ ⊢ if t′ then t1 else t2 : (S′
Lemma 16 we know that (S′
choose S′ = (S′
i.e. S′ <: S.

2) ≺ ℓ′. Then by
2) <: Sz, and by Lemma 18 if we
2)≺ℓ′ <: Sz≺ℓ,

2)≺ℓ′, we conclude that (S′

2 for some S′

1 for some S′

2 <: S≺ℓ.

1 ≺ S′

1≺S′

1≺S′

1≺S′

