Experimenting with Language Support for

Proximity in Ambient-Oriented Programming

Victor Ramiro1, Jessie Dedecker2,(cid:2), ´Eric Tanter1,(cid:2)(cid:2), and Peter Barron3

1 PLEIAD Lab, Computer Science Department (DCC)

University of Chile, Santiago, Chile

2 Programming Technology Lab, Vrije Universiteit Brussel, Belgium

3 Distributed Systems Group, Trinity College, Dublin, Ireland
{vramiro,etanter}@dcc.uchile.cl, jededeck@vub.ac.be,

Peter.Barron@cs.tcd.ie

Abstract. Proximity is a key to scalable and meaningful interactions in
distributed systems, both natural and artiﬁcial, and in particular in pervasive 
computing environments. However, proximity as such is a vague
notion that can be considered both in a very factual manner (spatial
distance) and in a very abstract and subjective manner (user aﬃnity).
We claim that an adequate system or programming language for ambient
intelligence applications ought to support an open notion of proximity,
making it possible to rely on diﬀerent, possibly subjective, understandings 
of proximity, as well as their combinations. We explore how to extend 
the Ambient-Oriented Programming language AmbientTalk with
language constructs that give programmers ﬂexible control over subjective 
proximity deﬁnitions in both service advertising and discovery.

1 Introduction

Proximity can be deﬁned as a state of nearest, the perception of being close
to something or someone. As a concept it naturally plays a signiﬁcant role in
how, as humans, we interact with our environment. This can be observed in
the relationships we maintain with others, or in the manner in which we interact
with everyday objects around us. For instance, how we hold one friendship above
another, or in the way we relate the topics of diﬀerent books to each other.

The concept of proximity is also of interest to the ﬁeld of pervasive computing
and ambient intelligence, where the focus is on unobtrusively managing and
assisting the tasks of users. In these systems the introduction of proximity allows
interactions to be bounded locally. The approach aids scalability [35] as entity
interaction is scoped. In addition, the application of proximity allows entities to
demarcate content of interest [19] making it easier to discover services or data
that are of relevance.
(cid:2) J. Dedecker is funded by Interuniversity Attraction Poles Programme Belgian State,

Belgian Science Policy.

(cid:2)(cid:2) ´E. Tanter is partially ﬁnanced by the Millennium Nucleus Center for Web Research,

Grant P04-067-F, Mideplan, Chile, and FONDECYT Project 11060493.

D. Weyns, S.A. Brueckner, and Y. Demazeau (Eds.): EEMMAS 2007, LNAI 5049, pp. 259–283, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008

260

V. Ramiro et al.

For example, consider a proximity deﬁned by a geometric distance of 10 meters
and a degree of separation between friends of 1. The former scopes interactions
to a 10 meter radius and recognises that content exceeding the boundary is of
less relevance. The later demarcates content which, in this case, are from close
friends. For pervasive computing the determination of such proximities should
be done at the service discovery level as this is the initial point of interaction. In
this paper, we present such an approach using a broad notion of proximity that
can be use in mobile ad-hoc environments.

Traditional applications of proximity have focused on the physical distance
between entities. However, by providing a broader notion of proximity that incorporates 
a more open application of the concept it is possible to gain greater
control over the interaction between entities. Unfortunately, such an open application 
of proximity is currently not supported by the state of the art. From
this point of motivation, that open notions of proximity should be supported by
pervasive computing systems, this paper makes the following contributions:

– a taxonomy of possible useful notions of proximity is presented in Section 2.
– from this taxonomy we present, in Section 2.4, a set of requirements capable

of supporting these notions of proximity within a system.

– we propose a model that supports these requirements in Section 3.
– we present and discuss a technical implementation of this model in AmbientTalk 
in Sections 4 and 5.

2 What Do You Mean, “Proximity”?

“Proximity is deﬁned as the state, quality, sense, or fact of being near
or next” – The American Heritage

The above deﬁnition of proximity leads us to considering two orthogonal dimensions 
when it comes to analysing proximity1. First, being near or next depends
on the notion of distance used; that is, one entity is close to another with respect 
to a given metric. Such a metric can be based on physical properties of
the entities (e.g. physical location), or on a more abstract criteria, not related to
the material world (e.g. nearness of relatives). We discuss physical vs. abstract
proximity in Section 2.1, and then consider the interests of being able to compose
several proximity metrics in Section 2.2.

Second, the deﬁnition mentions the word “sense” in addition to “state” or
“fact”, which tends to suggest a subjective notion of proximity, that depends
on the actual perception of the subject entity. This is in contrast to objective
criteria or metrics, for which all entities share the same understanding of what
it means to be close. We elaborate on this dimension in Section 2.3

2.1 Physical vs. Abstract Proximity
Physical Proximity. In current pervasive computing and ambient intelligence
systems,
is primarily determine by physical
1 The most part of this section ﬁrst appeared in [3].

the proximity of entities

Experimenting with Language Support

261

(a) Deﬁning proximity 
in the form a
polygon.

(b) Deﬁning proximity 
using a physical 
boundary of a
room.

(c) Deﬁning proximity 
using the signal 
propagation of
a wireless network.

Fig. 1. Diﬀerent notions of physical proximity (B is “near” A, but C is not)

(a) Deﬁning proximity using the relationships 
of users. Distance is determine 
by the degree of separation
between two users.

(b) Deﬁning proximity base on
the interests or hobbies of users.
Weightings on links indicate similarity 
of hobbies.

Fig. 2. Diﬀerent notions of abstract proximity

considerations. For example in YABS [2], a domain speciﬁc language developed 
for pervasive computing, interactions are limited to the local environment,
where “local” is deﬁned by a geometric parameter (Fig. 1(a)). In Gaia [34] a
middleware framework developed for pervasive computing, proximity is administratively 
bound to a physical location which, in this case, is a meeting room
(Fig. 1(b)). Taking a diﬀerent approach, systems such as AmbientTalk [11] implicitly 
deﬁne proximity based on the signal strength of wireless communications
(Fig. 1(c)): interactions can only take place when entities are in range of communication.


Abstract Proximity. Physical notions of proximity are very useful in developing 
pervasive computing systems [19,35], but it is also possible to extend the
beneﬁts of proximity considerations by examining abstract notions of proximity:
an abstract proximity does not directly map to physical characteristics of the
considered entities, but rather relies on logical, domain speciﬁc criteria.

First of all, one may consider a virtual rather than physical concept of place:
e.g. although video conference participants may be in geographically diﬀerent
places, they all share the same virtual meeting room. On another line, one can
deﬁne proximity based on the relationships of users - friends, acquaintances, or

262

V. Ramiro et al.

friends of friends. The distance between two users (or entities owned by users) is
the degree of separation between them, i.e. the length of the path relating them
on a relationship graph (Fig. 2(a)). This metric can be used for instance to allow
access to your personal devices to yourself, your friends, and friends of friends
(that is, a friendship distance of at most 2). One can consider that present instant
messenger applications consider the buddy relationship, restricting interactions
to a distance of 1. In a diﬀerent vain, it is possible to deﬁne proximity based
on the interests or hobbies of users. The distance in this case can be described
in terms of the similarity of one hobby or interest to another. For instance,
jogging is arguably much more similar to trekking than to knitting (Fig. 2(b)).
It is likewise possible to devise a wide number of abstract proximities, related
to particular domains or applications.

2.2 Composite Proximity

Most pervasive computing systems consider proximity as a singular concept: the
idea of composing diﬀerent proximities to reﬁne the overall scope of interactions
is generally not considered. This is a strong limitation, because considering the
potentially wide variety of proximity notions we have discussed above, it is clear
that there is a lot to gain in being able to combine diﬀerent types of proximity
to express a more subtle requirement.

For example, composing a proximity based on geometric distance (Fig. 1(a))
and user hobbies (Fig. 2(b)) would ﬁrst, aid scalability through the scoping of
interactions within the local environment, and secondly, highlight content in
the local environment that may be of interest. One could also consider spatiotemporal 
proximity, relating entities that are or have been, within a given time
frame, in the same local environment. Another example is to combine spatial
locality with network link quality, e.g. to aid in the development of an application
disseminating multimedia content to local participants.

Alternatively, combining geometric distance (Fig. 1(a)) with the wireless signal 
strength (Fig. 1(c)) between nodes would deﬁne a proximity that not only
scopes interactions of nodes to their physical locality but by their closeness in
terms of signal strength. Such a proximity might be useful in disseminating multimedia 
content to local participants where link quality is important.

2.3 Objective vs. Subjective Proximity

We now turn to a crucial issue when it comes to considering diﬀerent notions of
proximity in the context of open networks.

Objective Proximity. Existing pervasive computing systems support a notion
of proximity that can be deﬁned as objective in the sense that the semantics of
the proximity function are hardwired in the middleware layer. That is, all entities
in the system share the same notion(s). In a system like AmbientTalk, where
network connectivity is the only proximity factor, this shared understanding is
obvious. In Gaia as well, proximity is deﬁned by physical presence in an active

Experimenting with Language Support

263

proximity(5); // circle of radius 5
proximity(-5,-5,-10,5,-10,20,10,20,10,5,5,-5); // polygon as in Fig.1(a)
proximity(F34); // symbolic location as in Fig.1(b)

Fig. 3. Proximity deﬁnitions in YABS

space, i.e. a meeting room. In a system like YABS, each entity can deﬁne its
own proximity requirement using the proximity function (Fig. 3). Although
the actual parameters of the proximity functions are speciﬁc to each entity, the
interpretation of the proximity function is deﬁned in the infrastructure, and
cannot be changed.

Subjective Proximity. The way systems reliant on objective proximity work
implies that the diﬀerent shared interpretations of proximity are installed or
conﬁgured upfront in the infrastructure. Although this approach is feasible if we
consider a limited and ﬁxed number of interpretations (like in YABS), it does
not ﬁt our claim that many proximity notions are of interest, both physical and
abstract, and that these notions are potentially speciﬁc to certain applications
or domains. It is necessary that clients be able to deﬁne, compose and use new
notions of proximity.

In other words, if a new entity joins a certain environment and looks for
services of a certain type that are “close” to it, this entity ought to be able to
use its own notion of what it means to be nearby. This means that the proximity
function should possible be deﬁned by the client itself, not predeﬁned by the
underlying infrastructure. In this case there is no globally shared understanding
of the proximity, rather a subjective view of the client, that reﬂects the particular
requirements of the application.

2.4 Requirements for Proximity Relationships

In order for a software system to support a notion of proximity it must be capable
of deﬁning proximity relationships. A proximity relationship (PR) deﬁnes when
a party is considered to be in proximity of another party. The type of proximity
relationship that can be expressed in a system determines its support for the
notions of proximity we identiﬁed above. For example, a system will support
physical proximity when it supports the proximity relationship to be expressed
in terms of a physical distance.

To express the diﬀerent notions of proximity we described above the underlying 
system needs to support evaluating proximity relationships. We distilled
ﬁve requirements for these PRs, that need to be supported by the underlying
system, such that they can express the identiﬁed types of proximity:

1. Open PRs: proximity relations should be general such that they can support 
both physical and abstract proximity. PRs can be deﬁned in terms
of physical location parameters (such as GPS coordinates) or applicationspeciﬁc 
parameters (such as database information).

264

V. Ramiro et al.

2. Composite PRs: proximity relations can be constructed as a composition

of a set of simpler or more comprehensible proximity relations.

3. Idiosyncratic PRs: proximity relations should be custom deﬁnable by both
clients and servers in the network. Since a network is built from heterogeneous 
components, each having their own requirements, it is impossible to
deﬁne a set of shared deﬁnitions of proximity. Being able to deﬁne idiosyncratic 
proximity relationships enables one to express subjective proximity.

4. Distributed PR evaluation: proximity relations are deﬁned over a set of
networked parties with the aim to reduce the number of interactions in the
system. Hence, it is important that the proximity evaluation process scales
and is therefore distributed over the network.

5. Dynamic PRs: proximity relationships should be deﬁnable with values that

change in time.

A model where it is possible to deﬁne PRs with these properties provides a
good basis to express the diﬀerent notions of proximity we deﬁned above. These
notions ought to be supported by system software for pervasive computing. In
the remainder of this paper we study how proximity can be used to scope the
context in which service discovery and advertising is performed.

3 Open Proximity Model for Scoping Service Discovery

The scope of service discovery is typically deﬁned by the broadcasting range
of packets in the network. In practice this broadcasting range is limited to the
subnet of the network to reduce unnecessary network traﬃc in other subnets. The
scope of this mechanism is implicit and determined by the network conﬁguration
rather than the application requirements.

In this work, we propose to scope the service discovery based on a proximity
model. In this section, we ﬁrst give a brief overview of the model followed, and
then discuss some of its details. We ﬁnally evaluate it in the light of the PR
requirements established previously.

3.1 Overview of the Model

Service discovery is the combination of two processes: a service query, issued
by a client, and a service advertisement, issued by a server. Typically, a service
advertisement includes a number of attributes characterizing the service, and a
service query deﬁnes constraints on these attributes, specifying what the client
is looking for.

We propose to deﬁne explicit scopes based on proximity for both the query
and advertising processes. This allows a server to restrict its advertisements so
that they are visible only to clients within a given scope. Reciprocally, a client
is able to specify the scope within which it is interested in querying services.
Only if the scope of both parties intersect can the client actually see the service,
check its speciﬁc characteristics according to the query, and start using it if
appropriate.

Experimenting with Language Support

265

Fig. 4. Printer Scenario: Clients searching for printers around in a 10m proximity range
and Printers advertise if and only if the client is in the Social scope deﬁned by a friend
network graph

The scope of a particular process is deﬁned by a proximity function. Such
a function is a predicate over the properties that characterize the other party.
Properties are key-value pairs, that can include information such as the physical
location and application-speciﬁc data such as a social network database from an
application. The type and naming of the property information that is included
should be based on an ontology shared by the involved parties.

As an example, consider the scenario depicted in Figure 4. A client application

(running on a PDA) is searching for a printer server:

– The client application deﬁnes an objective and physical proximity function:
it considers any printer that is in a radius of 10 meters. This proximity
function deﬁnes the scope of client query.

– The printer services deﬁne an abstract and subjective proximity function
based on a social network: when the owner of the PDA and the owner of
the printer know each other directly (1st degree) or indirectly (until the
2nd degree) then the service considers the client to be in proximity. This
proximity function deﬁnes the scope of service advertisement.

When the owner of the PDA is within the social range of the owner’s printer,
and the printer is located within 10 meters around the PDA, the PDA sees the
printer and can run its service query to determine if the printer has the right
properties (eg. resolution), and if so, use it.

3.2 Distributed Evaluation Semantics

Figure 5 illustrates the distributed evaluation process for doing service discovery.
In the ﬁrst phase, the client starts broadcasting in the network the requested
service and its properties. In this phase the scope of service query and service

266

V. Ramiro et al.

C : Client

S : Server

B : Broadcast

[1st phase: proximity scope]

[ﬁnd(S, propsc)]

[S, propsc]

pc(propss) ? continue : abort

[propss]

ps(propsc) ? continue : abort

pattern(propss) ? ask : abort

[request]

[return]

[2nd phase: service discovery]

Fig. 5. Evaluation of proximity between server and client

1st phase: Proximity Scope
[proxserver(propsclient)]server the scope of the service advertisement
[proxclient(propsserver)]client
2nd phase: Service Discovery
[queryclient(propsserver)]client if a service matches client requirements

the scope of the client query

Fig. 6. Distributed evaluation of service discovery with proximity

advertisement is determined, by evaluating both the client and server proximity
functions. Each function is evaluated at the site where it has been deﬁned using
the properties that characterize the other party. The second phase, the execution
of the service query, is only performed when both client and server consider each
other in proximity. In this stage the client considers whether the service properties 
match its application requirements. In the printer example, this could be
the properties of the printer such as for example its printing resolution, printing
speed or the number of jobs that are in its queue.

The sequence diagram intuitively describes the evaluation semantics. Figure 6
summarizes the semantics. The notation [exp]site denotes that the expression exp
is executed on the node site in the network.

3.3 Eﬃciency of the Model

Our objective in presenting the proximity model was simplicity in its design
and usability. However, among the motivation for scoping service discovery with
proximity functions is the fact of increasing scalability of the system. For this
reason it is important that the model can be implemented eﬃciently.

Experimenting with Language Support

267

Costs of Proximity. We claim that proximity relationships can reduce interactions 
among peers in the environment because a client and a service will not
initiate an interaction when they are not considered to be in one another’s proximity.
 In particular, the actual service query is not executed unless both client
and server have agreed that they are in scope.

In the overall cost model, we have to consider (a) the amount of data that is
transferred over the network, (b) the number of connections that are established,
and (c) the computational resources used to compute the proximity.

Of course, we have to keep in mind what the cost would be if no support for
proximity were provided. For obtaining the same semantics without the support
of proximity relations, for instance in Jini [26], the client ﬁrst retrieves all the
available services that match the query, and then have to ﬁlters them according
to his criteria of proximity.

So, our model implies the transmission of the properties required to compute
proximity on both sides. In Jini, server properties used to compute client-deﬁned
scope would have to be passed also, after the query has succeeded. Client properties 
are not passed over the network, but this is due to the fact that it is
impossible to express server-side proximity with Jini: a published service is visible 
to any client in reach.

So overall, the gain of our approach in terms of eﬃciency is that queries do
not have to be evaluated against service providers that are out of scope. For this
to represent a gain, the cost of evaluating a query should be higher than the
cost of evaluating proximity. We believe this makes sense in most cases, where
proximity is a ﬁrst approximation of the range in which services should be found,
while the actual service query potentially discriminates on each and every detail
of the provided services. This of course depends on a design decision that the
programmer has to commit to.

Staging Proximity Evaluation. If needed, it is possible to further enhance
the eﬃciency of proximity evaluation by adopting a staged evaluation approach.
The basic idea is as follows: since a proximity function is a predicate on the
properties of a peer, it can be decomposed in smaller functions that only require
a subset of these properties.

The smaller functions represent logical evaluation steps. Their composition
with boolean operators allows optimization of the traﬃc (at the expense of con-
nections). Indeed, if two functions f1 and f2 are composed with an and operator,
if f1 rejects the peer, then it is not needed to evaluate f2 (and therefore, we avoid
sending over the network the properties required by f2).

In the worst case, all smaller functions have to be evaluated, and so all properties 
have to be transmitted. The diﬀerence with the non-staged approach then
is that more connections have been necessary (one per evaluation stage). But on
average, this approach performs better.

Decomposing proximity functions in smaller functions to allow staged evaluation 
has some consequences with respect to the simplicity of the approach. First,
the developer has to take special care into decomposing the proximity functions
manually, to keep the desired semantics. Second, each functions must indicate

268

V. Ramiro et al.

the precise properties it requires for evaluation. This is crucial to allow the runtime 
to transmit only the required properties at each step of the evaluation. For
example, as we will see in Section 5.2, our solution in AmbientTalk simply relies
on a naming convention: a formal parameter of a proximity function must be the
name of the property it is denoting. Finally, attention must be paid to the order
of the functions because if the programmer has knowledge about the relative size
of properties, he can take advantage of this fact to evaluate ﬁrst the functions
that require the smallest properties. We show an example of this in Section 5.2.

3.4 Discussion
Now that we have deﬁned a model of proximity functions we can review its
capabilities to express the required types of proximity relationships we distilled
in Section 2.4:

1. Open PRs: proximity functions can express open PRs because they can be
used to express both proximity based on a physical location or on applicationspeciﬁc 
information.

2. Composite PRs: Representing the proximity relationships as functions
has the advantage that the relationships can be composed using function
composition operators.

3. Idiosyncratic PRs: proximity functions are not predeﬁned and both the
client applications and services can deﬁne idiosyncratic PRs tailored to their
requirements. As a consequence, both objective (when the functions refer to
a shared library of proximity concepts) and subjective (when the functions
deﬁne custom semantics for proximity) PRs be expressed in the model.

4. Distributed PR evaluation: In our model a PR is deﬁned by two proximity 
functions, one for the client and one for the server, such that each
proximity function is computed locally given the properties of each party.

5. Dynamic PRs: The model can support partially dynamic proximity relationships 
because the properties can be re-evaluated each time they are sent
over the network.

The proposed model of proximity functions is capable of expressing the required 
proximity relationships. In order to experiment with this model, we extend
the service discovery abstractions of a contemporary distributed programming
language for mobile networks, called AmbientTalk [11,9]. The next section brieﬂy
explains the important programming concepts found in AmbientTalk. Section 5
then extends AmbientTalk’s service discovery abstractions to support our model.
If the reader is already familiar with AmbientTalk, it is safe to skip the next section 
and proceed to Section 5.

4 AmbientTalk in a Nutshell

The Ambient-Oriented Programming (AmOP) paradigm [10] addresses the distributed 
computing problems associated with the interactions of mobile devices.
Interconnected mobile devices are diﬀerent from traditional distributed systems:

Experimenting with Language Support

269

– Volatile Connections: Mobile devices are communicating using wireless
technology, which is subject to frequent interference such that failure is the
norm rather than the exception.

– Zero Infrastructure: Mobile devices are expected to operate autonomously
in diﬀerent environments. These environments can oﬀer infrastructure to
support interactions. However, such infrastructure is not always available
and a programming model should support software that does not rely on
infrastructure.

The AmOP paradigm [10] has deﬁned a number of principal criteria for distributed 
programming models in order to address these characteristics:

– Time decoupling implies that it is not necessary to have both parties
of the communication connected at the same time. This criterium supports
communication between mobile devices that are temporarily unavailable due
to volatile connections.

– Synchronization decoupling means that the control ﬂow of the communicating 
parties is not blocked upon sending or receiving messages. This criterium 
ensures that the availability of shared resources, which can be locked
in a thread of control, does not depend on the availability of other resources
in the network.

– Space decoupling implies that the communicating parties do not need to
know each others addresses beforehand. This criterium is required to support
communication that does not rely on infrastructure.

In order to support these AmOP criteria a distributed programming language
called AmbientTalk [9] has been conceived. AmbientTalk is a distributed objectoriented 
programming language speciﬁcally designed for composing service objects 
in mobile (ad-hoc) networks. AmbientTalk inherits most of its standard
language features from Scheme, Self and Smalltalk. From Scheme, it inherits
the notion of lexically scoped closures. From Self and Smalltalk, it inherits an
expressive block closure syntax, the representation of closures as objects and the
use of block closures for the deﬁnition of control structures. The object model of
AmbientTalk is derived from Self: classless, slot-based objects using delegation
as a reuse mechanism. The language also supports reﬂection [28]. The remainder 
of this section will be used to summarize AmbientTalk’s (distributed) object
model and its syntax.

4.1 AmbientTalk Objects

AmbientTalk is a domain speciﬁc language designed to support distributed programming 
abstractions. Despite that, AmbientTalk remains a complete objectbased 
language with dynamic typing support. AmbientTalk bases its object
model in the prototype model from Self [39]. To explain how objects work in
AmbientTalk, consider the deﬁnition of a printer object:

270

V. Ramiro et al.

i n i t ( d p i ){

def d p i ;
def queue ;
def

1 def P r i n t e r := object : {
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16 } ;

doc . p r i n t ( ) ;
queue . remove ( doc ) ;

} ;

s e l f . d p i
s e l f . queue := Queue . new ( 1 0 ) ;

:= d p i ;

} ;
def addJob ( aJob ) { queue . add ( aJob ) ; } ;
def ge t Qu e u e S i z e ( ) { queue . l e n g t h ( ) ; } ;
def p r i n t ( ) {

queue . f o r e a c h : { | doc |

} ;

In the code excerpt above we deﬁne a Printer object ex-nihilo [20] with the
object: construct. This printer object has two ﬁelds: the printer resolution dpi
and an internal queue to store the incoming jobs. The init method is used to
initialize new objects when the new method is invoked. Rather than creating
a new instance like in class based object oriented languages, the new message
returns a clone of the receiver object. The init method initializes the object with
a coherent value to all ﬁelds. There are three methods deﬁned in the Printer
object to manipulate the object’s internal state, addJob, getQueueSize and
print. The print illustrates the use of keyword syntax and closures. The queue
object has a method foreach: that takes a closure2 as its argument. The method
is, unlike the other methods in the example, not of a canonical form. Instead it
is based on the keyword syntax, which was ﬁrst introduced in Smalltalk.

Keyword syntax can be recognized by the trailing colons after each word
and can take multiple arguments. For example, an iteration is expressed as
1.to: 10 do: { |i| system.println(i); }, where the keyword to:do: represents 
a function that take two arguments, an integer and a closure. A closure is
syntactically created with { |arg1 ... argN| exp1; ... expN }. In the code
excerpt above a closure is used in the print method to iterate (using foreach:)
over the printer’s queue. The closure has one argument doc, it prints the document 
and removes the documents from the queue. In other words, the print
method iterates over the documents in the queue and removes each document
after it has been printed.

4.2 Concurrent Programming

The concurrency model of AmbientTalk is based on the communicating event
loops model from the E distributed programming language [27], which is an extension 
of the Actors Model [1]. The E model combines actors and objects into
a uniﬁed concurrency model. Unlike other actor languages such as Act1 [21],
ABCL [42] and Actalk [4] an actor is a container of regular objects that can
be individually sent asynchronous messages. Hence, whereas in traditional actor
languages only actors can be sent asynchronous messages, regular objects can

2 A closure is a nameless function that encapsulates its lexical scope.

Experimenting with Language Support

271

now also be sent asynchronous messages. The container is responsible for executing 
these messages one at a time. To have a better understanding on how
AmbientTalk actors behave, we ﬁrst need to describe the fundamental concurrency 
properties of the event loop concurrency.

Event Loop Concurrency. The communicating event loop of the E language is an
event driven concurrency model. In this model, the event loop is a thread that
perpetually processes events from its event queue by invoking a corresponding
event handler. In addition, an event loop can enforce three concurrency control
properties:

– Serial execution: An event loop processes incoming events from its event

queue one by one, i.e. in a strictly serial order.

– Non-blocking communication: An event loop never suspends its execution
to wait for another event loop to ﬁnish a computation. Rather, all communications 
between event loops occurs by means of asynchronous event
notiﬁcations.

– Exclusive state access: Event handlers and their associated state belong to
a single event loop. In other words, an event loop has exclusive access to its
mutable state.

Actors. In AmbientTalk concurrent event loops are created with actors. Actors
represent the event queue with a message queue. This means that events are represented 
as messages, event notiﬁcations as asynchronous messages and events
handlers are represented as methods or closures. The thread event loop of the
actor is perpetually dispatching the messages of the message queue to the corresponding 
method in the receiver object of the message. Messages in the event
queue are processed serially to avoid race conditions on shared state of objects.
By default, all objects created belong to the virtual machine actor. Other actors
can be created as well:

1 def anActor := actor : { | arg1 , arg2 ,
2
3 } ;

. . .

. . .

, argN |

In the code above a new actor anActor is deﬁned with the actor: constructor.
An actor is isolated from its lexical scope to avoid sharing state with the actor
that spawned it, a set of arguments can be given to be copied in the lexical scope
of the created actor.

Communication. Each object belongs to one and only one actor. If the objects
belong to diﬀerent actors, the communication must be asynchronous by means
of a far reference. A far reference is a proxy to the object belonging to another
actor. Figure 7 illustrates AmbientTalk actors as communicating event loops.
The dotted line represent the event loop threads of the actors which are taking
messages from the actor’s message queue and synchronously execute the corresponding 
method on the actor’s owned objects. If two objects belong to the same
actor, they can communicate either asynchronously or using sequential message
passing.

272

V. Ramiro et al.

Actor

Message

queue

Actor

Message from A to B

Event
Loop

A

Object

B

Far reference

Fig. 7. AmbientTalk actors as communicating event loops

An asynchronous message is enqueued in the message queue of the actor that
hosts the target object. AmbientTalk distinguishes between sequential message
passing using the dot operator (obj.m()); and asynchronous message passing
using the arrow operator (obj<-m()). Asynchronous messages can return futures 
[27], which is a placeholder for the real return value of the asynchronous
call.

1 def p r i n t e r Q u e u e S i z e F u t := p r i n t e r <−ge t Qu e u e S i z e ( ) ;

The printerQueueSizeFut is assigned to a future, in this case a placeholder
for the queue size of the printer. After the printer has eventually processed the
getQueueSize message the future will be resolved with the value returned by
the getQueueSize method invocation:

1 when : p r i n t e r Q u e u e S i z e F u t becomes : { | q u e u e S i z e |
2
3 }

system . p r i n t ( ”The Queue S i z e i s : ” + q u e u e S i z e ) ;

The when:becomes: keyword takes a future and a closure as its arguments,
and registers the closure as an observer of the future. If the future is resolved to
a proper value, the closure is executed with the resolved value of the future as
parameter.

4.3 Distributed Programming

In the previous section we discussed the AmbientTalk’s concurrency model. Each
actor encapsulates one thread and a collection of objects that are serially accessible 
by means of asynchronous message passing. From a distributed perspective
traditional actor languages also employ actors as the unit of distribution and
this is also the case in AmbientTalk. However, as opposed to traditional actor
languages AmbientTalk’s model of distribution makes it possible to remotely
reference regular objects using far references as a communication channel. This
means that, since far references only support asynchronous method invocations,
all remote communication is asynchronous too. Hence, the concept of far references 
is used both for local and remote concurrent distributed computations.
AmbientTalk also provides programming abstractions to deal with partial failures 
[9] but these are beyond the scope of this paper.

Experimenting with Language Support

273

4.4 Summary

AmbientTalk is a language for distributed computing in mobile networks. Its concurrency 
and distribution model is based on actors and communicating event
loops. This model is based on asynchronous messages exchanged between objects 
encapsulated in actor. The programming language features a number of
language constructs, such as futures and ﬁrst-class event-handlers, to marry an
object-oriented distributed programming style with distributed asynchronous
concurrent computations.

5 Service Discovery and Proximity in AmbientTalk

In this section we explain AmbientTalk’s current service discovery abstractions
and discuss its limitations. In the light of these limitations we then present an
extension of AmbientTalk’s service discovery language constructs based on the
proximity model we proposed in Section 3.

5.1 Service Discovery in AmbientTalk

Service discovery is an important feature in ambient-oriented programming [11].
This paradigm assumes no network infrastructure such that service discovery
is important to bootstrap the system and ﬁnd services as users move from one
location to another. Therefore an expressive and scalable manner to publish and
subscribe services in the network is required.

Pattern-Based Discovery. In AmbientTalk service discovery is facilitated with a
pattern matching system. A pattern has a similar structure as regular objects
but diﬀers in the interpretation of its ﬁelds. In objects, ﬁelds always refer to
values (methods are also values in the form of closures) whereas a pattern’s
ﬁelds represent matching expressions. These matching expressions are evaluated
with the service’s ﬁelds. The matching expressions can be:

– Equality: a ﬁeld must have a speciﬁc value, for instance x := 10 means

that the ﬁeld obj.x must be 10 in the exported service obj.

– Wildcards: a ﬁeld may have any value, for instance x := * means that the

ﬁeld obj.x may have any value in the exported service obj.
– Constraints: a ﬁeld may have any value in the range deﬁned by the con-
< 10} means that obj.x can
straints, for instance x := constraint: {
be any value less than 10. Notice that “ ” is bound to the runtime value of
the ﬁeld.

As an example, a pattern to match the printer object we deﬁned in Section 4.1:

1 def p r i n t e r S p e c s := pattern : {
2
3
4
5 } ;

def type := P r i n t e r S e r v e r ;
def d p i
def queue := c o n s t r a i n t : {

:= 7 0 0 ;

. s i z e ( ) < 5 } ;

274

V. Ramiro et al.

In the code above, note that the pattern has a subset of the ﬁelds deﬁned
by the properties of the printer. The printerSpecs deﬁnes that the expected
service must have exactly seven hundred dpi and less than ﬁve jobs in its queue.
Furthermore, the pattern deﬁnes the ﬁeld type, which speciﬁes the desired type
of the exported service.

Exporting and Querying Objects. An object is advertised together with a type
tag using the export:as: construct. Since AmbientTalk is a dynamically typed
language a type tag is used to universally identify the type of objects. In the code
below, the printer service creates a Printer object and then exports it tagged
as a PrinterServer.

1
2

def hp := P r i n t e r . new( Port . new( ” usb ” ) , ” hp9200xl ” ) ;
export : hp as : P r i n t e r S e r v e r ;

On the client side we register a handler that, upon discovery of an object
matches the printerSpecs, and sends an addJob message to the discovered
printer object. Registering the handler, which is a closure parameterized with
printer, is done using the when:discovered: function:

when : p r i n t e r S p e c s discovered : { | p r i n t e r |
}

p r i n t e r <−addJob ( j ob ) ;

1
2
3

This function initiates a service query based on the pattern we deﬁned above.
Note that this function does not block until a service has been found. Instead
it immediately terminates and the registered handler is asynchronously invoked
when a printer has been discovered.

Evaluation. AmbientTalk has an expressive pattern matching system to specify
service queries. However, the programming constructs do not provide support for
an evaluation of proximity prior to evaluating the queries. As a consequence, a
client has to encode his proximity requirement in the query itself. But the server,
like in Jini, has no means to scope his advertisement. Services are advertised
in the network based on a datagram broadcasting protocol. As a consequence,
service advertisements are propagated to all clients in the network broadcasting
range.

5.2 Open Proximity Model in AmbientTalk

In our extension, In line with the model we presented in Section 3, we introduce
two constructs to support proximity in AmbientTalk: properties and proximity
functions. Their usage is explained below from the server (service advertisement)
and client (service query) perspectives using the printer example introduced in
Section 3.

Properties. Properties deﬁne the context information that is exposed to servers
and clients. They are used in proximity functions for determining the scope of
the service queries and advertisements.

Experimenting with Language Support

275

:= properties : { | hp , gps , myAddressBook |

1 def hp := P r i n t e r . new( Port . new( ” usb ” ) , ” hp9200xl ” ) ;
2
3 def p r i n t e r P r o p s
4
5
6
7
8
9
10
11 } ;

def type := P r i n t e r S e r v e r ;
def owner := ” J e s s i e Dedecker”
def d p i
def queue ( ) { hp . ge tQu e u e S i z e ( ) } ;
def x ( ) { gps . getX ( ) } ;
def y ( ) { gps . getY ( ) } ;
def addressBook := myAddressBook ;

:= hp . getMaxDPI ( ) ;

The code above deﬁnes the printer properties. These properties are parameterized 
with three objects hp, gps, and myAddressBook that are deﬁned in the
surrounding lexical scope. These objects are encapsulated in the properties and
their values are exposed through the properties via regular ﬁelds and a method
invocation protocol. Fields are used to deﬁne a constant property value (such
as the maximum resolution of the printer, dpi) whereas the method invocations
are used to compute the latest value of a dynamic property (such as current
printer queue size, queue()). Whenever the properties are requested by a server
or a client all dynamic properties are computed and the results are communicated 
to the requesting party. Hence, only the ﬁelds are communicated and not
the encapsulated objects such that this information remains hidden to the other
party.

Similarly, the client also deﬁnes the properties that are needed to compute

the proximity function.

:= properties :{ | gps , pda |

1 def c l i e n t P r o p s
2
3
4
5
6 } ;

def owner := ” V i c t o r Ramiro”
def addressBook := pda . getAddressBook ( ) ;
def x ( ) { gps . getX ( ) } ;
def y ( ) { gps . getY ( ) } ;

Computing the Scope of Service Advertisements. In the example in Section 
3 we speciﬁed that the printer service should only advertise itself to clients
whose owners are either direct or indirect (two degrees of separation) acquaintances.
 This type of constraints are expressed as functions that deﬁne the proximity 
scope in which the service is advertised to potential clients. The scope is
deﬁned by the socialScope function:

s o c i a l S c o p e ( ){ | c l i e n t |

s e r v e r . addressBook . c o n t a i n s ( c l i e n t . owner ) then : {

i f :
} e l s e : {

true ;

1 def
2
3
4
5
6
7
8 }

} ;

i n t e r

def
i n t e r . l e n g t h ( ) > 0 ;

:= s e r v e r . addressBook . i n t e r s e c t ( c l i e n t . addressBook ) ;

The function takes one argument, client, which upon invocation is bound to
the client properties. The server properties are represented by the server object,
assumed to be in the lexical scope of the function deﬁnition. The socialScope
function checks if the owner of the client device (client.owner) is either a

276

V. Ramiro et al.

direct acquaintance or if the client’s owner indirectly knows acquaintances of the
server’s owner. This is a case where the information transmitted over the network
is heavy weight. In this speciﬁc case we need to know the friends connections
graph to resolve the social scope. If we do not have information of it beforehand
we need to calculate it completely. If we have information, for example using a
service available in the network, the function could delegate this task to a server
which knows and maintains the social graph (such as a Facebook web service).

Using Staged Evaluation. Another option to reduce network traﬃc is to
decompose our function in stages as described in Section 3.3. For that, we need
to realize that the socialScope function depends on the evaluation of an if
clause, which can be divided into two smaller functions. If the ﬁrst clause yields
true, we do not need to evaluate the other function. We therefore reduce the if
to the composition of two smaller functions using the or operator, as follows:

s o c i a l S c o p e R e f i n e d ( ) {

f 1 := { | owner |

my. addressBook . c o n t a i n s ( owner )

f 2 := { | addressBook |

i n t e r

def
i n t e r . l e n g t h ( ) > 0 ;

} ;
compose ( or ( f1 , f 2 ) ) ;

def
} ;
def

1 def
2
3
4
5
6
7
8
9
10 }

:= my. addressBook . i n t e r s e c t ( addressBook ) ;

Although the two proposed proximity functions, the socialScope function and
its reﬁnement socialScopeRefined, have a diﬀerent structure, they return the
same results. Note that in order to specify which properties are needed for each
function f1 and f2, these functions declare their formal parameter with the
actual property name (owner and addressBook). The runtime uses this information 
to handle the optimized staged evaluation of the proximity. In this case,
if f1 evaluates to true, we do not need to evaluate f2, and therefore we avoid
transmitting the address book over the network.

Advertising the Service within its Scope. We have extended AmbientTalk’s
export:as: function such that the service’s properties and scope function can
be taken into account:

1 export : hp with : p r i n t e r P r o p s

in :

s o c i a l S c o p e R e f i n e d ( ) ;

In the code above, export:with:in: exports the object hp with its properties
and the scope of the service advertisement is deﬁned using a proximity function
socialScope.

Computing the Scope of Service Discovery. In the example we speciﬁed
that the client would restrict its service discovery scope based on a physical
proximity of ten meters radius. We deﬁne a euclidean proximity function:

i sW i t h i n Rad i u s ( maxDistance ){ | s e r v e r |
def d := ( ( c l i e n t . x−s e r v e r . x ) . expt ( 2 ) +

( c l i e n t . y−s e r v e r . y ) . expt ( 2 ) ) . s q r t ( ) ;

d < maxDistance ;

1 def
2
3
4
5 }

Experimenting with Language Support

277

This function is parameterized with the server argument that will be bound
to the properties of the server. The client argument is bound in the lexical
scope of the function. The function computes the euclidean distance based on
the coordinates it ﬁnds in the client and server’s properties and checks if the
PDA is within the maximum radius of the server.

Initiating the Service Discovery. After we have deﬁned the scope of service
query we can register the handlers to discover a service matching our description:

1 when : p r i n t e r S p e c s discovered : { | p r i n t e r |
2
3
4
5
6 } with :

p r i n t e r <−addJob ( j ob ) ;
when : p r i n t e r <−l o c a t i o n ( ) becomes : { | l o c a t i o n |
}

i sW i t h i n Rad i u s ( 1 0 ) ;

gui <−showDialog ( ”Job added to p r i n t e r @ ” + l o c a t i o n ) ;

c l i e n t P r o p s

in :

The client registers itself with when:discovered:with:in: the printerSpecs
to match services in the network and a handler to execute when a matching
service is found. This handler adds the printing job in the queue of the printer
server and announces where the document is being printed. It also attaches the
properties of the client (clientProps) and scopes the service query to a circular
area of ten meters of radius.

5.3 Discussion

We have extended AmbientTalk’s service discovery abstractions such that both
service queries and advertisements can be scoped with proximity functions.
These proximity functions are used to express PRs in AmbientTalk. We evaluate 
our service discovery extensions to express the diﬀerent PRs we deﬁned in
section 2.4:

1. Open PRs: functions can be deﬁned in terms of physical location parameters 
or application-speciﬁc parameters. The only prerequisite is that this
information is exposed in the properties such that functions can access this
information.

2. Composite PRs: functions in AmbientTalk are ﬁrst-class. Thus proximity 
function are ﬁrst-class and can be composed. An example is shown the
composition made on the socialScope reﬁnement.

3. Idiosyncratic PRs: functions can be idiosyncratically deﬁned. Both clients
and servers can attach such a function to the service query and advertisement
such that each party can deﬁne its scope based on (subjective) proximity.

4. Distributed PR evaluation: client and service deﬁne their own proximity
function, just requiring the properties deﬁned by the other as a parameter
to locally evaluate the function. Properties are distributed in the network
where each node evaluate them to determine the proximity scope. Staged
evaluation further optimizes the process by avoiding evaluating superﬂuous
conditions; this is at the cost of a manual decomposition of a proximity
function into sub-functions composed by logical operators.

278

V. Ramiro et al.

5. Dynamic PRs: the properties support dynamic ﬁelds which are reevaluated 
with each transmission such that only the most recent values of
the properties are used to compute the scope. The issue of how to deal with
interactions that have begun based on an assumption of proximity that turns
out to be invalid at some point in time is left unaddressed and represents a
non-trivial challenge for future work.

6 Related Work

We focus our discussion of related work on the use of proximity in managing
system interaction. In particular, we investigate the use of proximity in multiagent 
systems. Also, we look at how the concept of proximity has been applied
to service discovery in pervasive and ubiquitous computing.

6.1 Multi-agent Systems
The concept of proximity, or that of locality, is a technique that multi-agent
systems have used to manage and coordinate agent interaction. This can be
particularly seen in systems inspired by stigmergy [13], where the locality of
interaction with the environment is an essential construct in determining agent
behavior. For instance, Brueckner and Parunak [5] use stigmergy in a multi-agent
system to ﬁnd global patterns across spatially distributed real-time data. Each
agent’s interaction is limited spatially to the local pheromone concentrations on
the individual nodes. Other applications of stigmergy can also be observed in
[14,24,33,40]. In these instances, while the environment used to perform stigmergy 
may diﬀer, the notion of proximity is still evident.

The application of proximity is also apparent in other multi-agent systems using 
diﬀerent forms of swarming such as ﬂocking and shoaling [31,37,38]. In these
cases, agents coordinate their behavior based on that of neighboring agents. In
[30,29], for example, De Nardi et al. control a ﬂeet of miniature helicopters using
the concept of ﬂocking. Neighboring helicopters are determined through their
physical presence or proximity to each other. In another instance, Cui and Potok 
[8] have developed a technique for clustering documents using a multi-agent
system based on ﬂocking. Neighbours are determined via similarities between
the documents.

The use of proximity is not just limited to multi-agent systems inspired by biology.
 Castelli et al. [6] presents a system that allows agents to retrieve context
information via a spatial proximity centered around a speciﬁc physical location.
 In a diﬀerent approach, to aid collaboration among agents in a ubiquitous
computing environment, Locatelli et al. have devised a method [23] that allows
agents to perceive the physical or logical presence of other nearby agents. In [16],
Hanssens et al. structures agents within societies that represent, and which also
act on behalf of a user or space. Interaction is bound to agents within a society,
and hence to a speciﬁc physical proximity.

Julien and Roman have developed a middleware abstraction [18] that provides
agents with a view of the data in the system. The view, in terms of proximity, is

Experimenting with Language Support

279

deﬁned using either a metric based on the geometric distance or the hop count
between an agent and the data within an ad-hoc network. It is also possible for
agents to deﬁne multiple views in which further access to the data can be gained
using a tuple based mechanism. In a similar approach, Schelfthout et al. have
developed a framework called ObjectPlaces [36]. The distance metric, in this
case, is deﬁned on a per application basis. However, in practice it would appear
the metric needs also to include a hop count between nodes to ensure correct
operation.

In reviewing the usage of proximity it is evident that the concept, whether
it is used implicitly or explicitly, is one that is prevalent among research in
multi-agent systems. This is most likely due to multi-agent systems using the
environment as a primary abstraction [41] in their design. However, the extensive
support that we propose for proximity, and which we have outlined in this paper,
has not been fully realised in the multi-agent systems we have reviewed. As
such, there is limited support for open, idiosyncratic and composite proximity
relationships, as well as for their distributed evaluation.

6.2 Service Discovery

Within pervasive computing and ambient intelligence, service discovery is one of
the more useful techniques for supporting spontaneous interoperability between
components [19,12]. The approach facilitates the dynamic location of components 
that allows interaction between components to occur with little or no prior
knowledge. It is a technique that has been applied successfully to a number of
pervasive computing systems [32,17]. However, traditional service discovery systems 
such as SLP [15], Jini [26] and Salutation [7], do not fully meet the demands
of pervasive systems. They tend to be designed for ﬁxed infrastructures rather
than mobile ad hoc environments which are more prevalent in pervasive computing.
 Also, the use of proximity to improve the discovery mechanism, as outline
in Section 2.4, is not explicitly supported.

For instance, Jini [26] does service discovery based on an attribute matching
system. The default matching system checks for object equality and treats null
values as wildcards. The default matching process can be customized such that
boolean expressions can be used to match the attribute objects. While the combination 
of attribute objects with a customized matching process enables one to
support open proximity relationships, it does not permit dynamic relationships,
because attributes cannot be changed at run time. As a result, it is not possible
to manage devices with changing GPS positions or to look up a printer with
a small number of documents in the queue of a printer. However, it is feasible
to deﬁne composite relationships using object composition techniques such as
aggregation and inheritance. It is not possible to support idiosyncratic proximity 
relationships because the attribute classes need to be known beforehand in
order for the clients to be able to refer to the attributes of the system. Finally,
while Jini does support some of the underlying system requirements of evaluating 
proximity relationships, it is not explicitly provided for, nor is there the
ability to operate such functionality in, mobile ad hoc environment.

280

V. Ramiro et al.

There is, however, a number of service discovery systems that have been designed 
for mobile ad hoc environments. Some of these systems have also used
proximity to improve their service discovery mechanism. For instance, Meier et
al. [25] have develop a system where service providers can deﬁne a proximity in
which their services are available from. The deﬁnition of the proximity is limited
to a geometric distance - physical proximity. The notion of abstract proximity
is not supported, nor is the concept of idiosyncratic or composite PRs. Once
a client registers an interest in a service they are continuously notiﬁed of any
matching services as they move through the environment.

In a diﬀerent approach, Yoon et al [43] have developed an overlay routing
algorithm based on proximity. The approach is aimed at improving the discovery
of services in mobile ad hoc networks. While the algorithm does not allow the
explicit deﬁnition of a proximity, it does return the nearest service in terms of the
current state of the network. This is determined periodically through measuring
diﬀerent aspects of the network. Liu and Issarny also use a similar approach [22]
to determining proximity. In this case they use the signal strength between nodes
to measure the nearness of services to a client. Open proximity relationships are
not supported by these approaches, nor is the ability to compose or distribute
the evaluation of these relationships.

While the use of proximity is evident among service discovery systems its
application tends to be limited. In our approach we have looked to provide a
verbose implementation of the concept that is both open and ﬂexible.

7 Future Work and Conclusion

7.1 Future Work
The model we presented above has been partially implemented but there are two
important open issues that require further work. First, our implementation does
not explicitly consider the topology of the underlying network. This means that
our protocols only consider devices within the multicasting capabilities of the
network. In order to expand the range we are considering a publish-subscribe
architecture where nodes are selected to act as routers. These routers link devices 
together that have an intersecting proximity scope. The second issue we are
investigating is how to manage dynamic proximity relations once the discovery
process has occurred. This implies determining an eﬃcient way to recompute
proximity conditions when required, and give programmers a way to handle the
case where a proximity condition becomes false. Finally, we have to pursue empirical 
evidence of the beneﬁts of the staged evaluation and property-sending
mechanism described in this paper, through more complex examples and benchmarks.


7.2 Conclusion
In pervasive computing, being able to scope interactions based on a notion of
proximity is important both for scalability and demarcation of content of interest.
 Still, proximity is a vague concept whose semantics often rely on the implicit

Experimenting with Language Support

281

context of its subjects. From this observation we have argued for the support of
open notions of proximity in pervasive computing. We presented a taxonomy on
the concept proximity from an application perspective. From this taxonomy we
derived a set of requirements for deﬁning proximity relationships between entities.
 This set of requirements was then used to design an open proximity model
for service discovery. Our model scopes the interactions between devices by deﬁning 
a scope for service query and advertisements. Hence, evaluation of service
queries is scaled down to devices within this scope thus enhancing the scalability
of the overall system by reducing the number of interactions. A notable diﬀerence 
with other discovery mechanisms is the fact that service providers can scope
the advertising of services. Furthermore, since proximity is an open concept, in
this model we can deﬁne the scope of interactions based on any application requirements,
 not only physical location. Finally, we have discussed and illustrated
a ﬁrst integration of this model with the service discovery abstractions of the
AmbientTalk language.

References

1. Agha, G.: ACTORS: a model of concurrent computation in distributed systems.

The MIT Press, Cambridge (1986)

2. Barron, P., Cahill, V.: YABS: a domain-speciﬁc language for pervasive computing 
based on stigmergy. In: Jarzabek, S., Schmidt, D.C., Veldhuizen, T.L. (eds.)
Proceedings of the 5th ACM SIGPLAN/SIGSOFT Conference on Generative Programming 
and Component Engineering (GPCE 2006), Portland, Oregon, October
2006, pp. 285–294. ACM Press, New York (2006)

3. Barron, P., Dedecker, J., Tanter, ´E.: Proximity is in the eye of the beholder. In:
M¨ugge, H., Tanter, ´E., Cherrier, P., Dedecker, J., Lopes, C., Cebulla, M. (eds.)
Proceedings of the 3rd ECOOP workshop on Object Technology for Ambient Intelligence 
and Pervasive Computing (OT4AmI 2007), Berlin, Germany, July 2007,
pp. 1–6 (2007); Technical Report 2007-12, Technische Universit¨at Berlin

4. Briot, J.-P.: From objects to actors: study of a limited symbiosis in smalltalk-80.
In: Proceedings of the 1988 ACM SIGPLAN workshop on Object-based concurrent
programming, pp. 69–72. ACM Press, New York (1988)

5. Brueckner, S.A., Van Dyke Parunak, H.: Swarming agents for distributed pattern
detection and classiﬁcation. In: Workshop on Ubiquitous Computing, AAMAS 2002
(2002)

6. Castelli, G., Mamei, M., Zambonelli, F.: Engineering contextual

information
for pervasive multiagent systems. In: Conference on Engineering EnvironmentMediated 
Multiagent Systems, EEMMAS 2007 (October 2007)

7. Salutation Consortium. Salutation architecture speciﬁcation v2.0c (1999),

http://www.salutation.org

8. Cui, X., Potok, T.E.: Distributed ﬂocking approach for information stream clustering
analysis. In: 7th ACIS International Conference on Software Engineering, Artiﬁcial
Intelligence, Networking, and Parallel/Distributed Computing, SNPD 2006 (2007)

9. Van Cutsem, T., Mostinckx, S., Boix, E.G., Dedecker, J., De Meuter, W.: Ambi-
entTalk: Object-oriented event-driven programming in mobile ad hoc networks. In:
Astudillo, H., Tanter, ´E. (eds.) Proceedings of the XXVI International Conference
of the Chilean Computer Science Society, Iquique, Chile, November 2007, pp. 3–12.
IEEE Computer Society, Los Alamitos (2007)

282

V. Ramiro et al.

10. Dedecker, J., Mostinckx, S., Van Cutsem, T., De Meuter, W., D’Hondt, T.:
Ambient-oriented programming. In: OOPSLA 2005 Onward! Track (October 2005)
11. Dedecker, J., Van Cutsem, T., Mostinckx, S., D’Hondt, T., De Meuter, W.:
Ambient-oriented programming in AmbientTalk. In: Thomas, D. (ed.) ECOOP
2006. LNCS, vol. 4067, pp. 230–254. Springer, Heidelberg (2006)

12. Edwards, W.K., Grinter, R.E.: At home with ubiquitous computing: Seven challenges.
 In: Abowd, G.D., Brumitt, B., Shafer, S. (eds.) UbiComp 2001. LNCS,
vol. 2201, pp. 256–272. Springer, Heidelberg (2001)

13. Grasse, P.-P.: Le reconstruction du nid et les coordinations inter-individuelles
chez bellicositermes natalensis et cubitermes sp. la theorie de la stigmergie: essai
d’interpretation du comportement des termites constructeurs. Insectes Sociaux 6,
41–81 (1959)

14. Gulyas, L.: Application of stigmergy - a coordination mechanism for mobile agents.
In: 1st Hungarian National Conference on Agent-Based Computing (HUNABC
1998), Budapest, pp. 143–154. Springer, Heidelberg (1998)

15. Guttman, E., Perkins, C., Veizades, J., Day, M.: Service location protocol, version

2 (1999), http://www.ietf.org/rfc/rfc2608.txt

16. Hanssens, N., Kulkarni, A., Tuchinda, R., Horton, T.: Building agent-based intelligent 
workspaces. In: The International Workshop on Agents for Business Automation 
(2002)

17. Hermann, R., Husemann, D., Moser, M., Nidd, M., Rohner, C., Schade, A.:
DEAPspace: Transient ad-hoc networking of pervasive devices. In: 1st ACM international 
symposium on Mobile ad hoc networking and computing (2000)

18. Julien, C., Roman, G.-C.: EgoSpaces: Facilitating rapid development of contextaware 
mobile applications. IEEE Transactions on Software Engineering 32(5), 281–
298 (2006)

19. Kindberg, T., Fox, A.: System software for ubiquitous computing. IEEE Pervasive

Computing 1(1) (2002)

20. Lieberman, H.: Using prototypical objects to implement shared behavior in objectoriented 
systems. In: Meyrowitz, N. (ed.) Proceedings of the 1st International Conference 
on Object-Oriented Programming Systems, Languages and Applications
(OOPSLA 1986), Portland, Oregon, USA, October 1986, vol. 21(11), pp. 214–223.
ACM Press, ACM SIGPLAN Notices, New York (1986)

21. Lieberman, H.: Concurrent object-oriented programming in ACT 1. In: Yonezawa,
A., Tokoro, M. (eds.) Object-Oriented Concurrent Programming, pp. 9–36. MIT
Press, Cambridge (1987)

22. Liu, J., Issarny, V.: Signal strength based service discovery (s3d) in mobile ad hoc
networks. In: 16th Annual IEEE International Symposium on Personal Indoor and
Mobile Radio Communications (2005)

23. Locatelli, M.P., Vizzari, G.: Environment support to the management of context
awareness information. In: Conference on Engineering Environment-Mediated Multiagent 
Systems, EEMMAS 2007 (October 2007)

24. Mamei, M., Zambonelli, F.: Spreading pheromones in everyday environments via

rﬁd technologies. In: 2nd IEEE Symposium on Swarm Intelligence (June 2005)

25. Meier, R., Cahill, V., Nedos, A., Clarke, S.: Proximity-based service discovery in
mobile ad hoc networks. In: Kutvonen, L., Alonistioti, N. (eds.) DAIS 2005. LNCS,
vol. 3543, pp. 115–129. Springer, Heidelberg (2005)

26. Sun Microsystems. Jini speciﬁcations,

http://www.sun.com/software/jini/specs/

Experimenting with Language Support

283

27. Miller, M., Tribble, E.D., Shapiro, J.: Concurrency among strangers: Programming
in E as plan coordination. In: De Nicola, R., Sangiorgi, D. (eds.) TGC 2005. LNCS,
vol. 3705, pp. 195–229. Springer, Heidelberg (2005)

28. Mostinckx, S., Van Cutsem, T., Timbermont, S., Tanter, ´E.: Mirages: Behavioral
intercession in a mirror-based architecture. In: Proceedings of the ACM Dynamic
Languages Symposium (DLS 2007), Montreal, Canada, October 2007, pp. 89–100.
ACM Press, New York (2007)

29. De Nardi, R., Holland, O.: Ultraswarm: A further step towards a ﬂock of miniature

helicopters. In: SAB Workshop on Swarm Robotics (2006)

30. De Nardi, R., Holland, O., Woods, J., Clark, A.: Swarmav: A swarm of miniature

aerial vehicles. In: 21st International UAV Systems Conference (April 2006)

31. Olfati-Saber, R.: Flocking for multi-agent dynamic systems: algorithms and theory.

IEEE Transactions on Automatic Control 51(3), 401–420 (2006)

32. Ponnekanti, S., Lee, B., Fox, A., Hanrahan, P., Winograd, T.: Icrafter: A service
framework for ubiquitous computing environments. In: Abowd, G.D., Brumitt, B.,
Shafer, S. (eds.) UbiComp 2001. LNCS, vol. 2201, pp. 56–75. Springer, Heidelberg
(2001)

33. Ricci, A., Omicini, A., Viroli, M., Gardelli, L., Oliva, E.: Cognitive stigmergy:
Towards a framework based on agents and artifacts. In: Weyns, D., Van Dyke
Parunak, H., Michel, F. (eds.) E4MAS 2006. LNCS (LNAI), vol. 4389, pp. 124–
140. Springer, Heidelberg (2007)

34. Roman, M., Hess, C., Cerqueira, R., Ranganathan, A., Campbell, R.H., Nahrstedt,
K.: Gaia: a middleware platform for active spaces. SIGMOBILE Mob. Comput.
Commun. Rev. 6(4), 65–67 (2002)

35. Satyanarayanan, M.: Pervasive computing: vision and challenges. IEEE Personal

Communications 8(4), 10–17 (2001)

36. Schelfthout, K., Holvoet, T., Berbers, Y.: Views: Middleware abstractions for
context-aware applications in manets. In: 5th International Workshop on Software
Engineering for Large-scale Multi-Agent Systems (2005)

37. Tanner, H.G., Jadbabaie, A., Pappas, G.J.: Stable ﬂocking of mobile agents, part I:
ﬁxed topology. In: 42nd IEEE Conference on Decision and Control (December 2003)
38. Tanner, H.G., Jadbabaie, A., Pappas, G.J.: Stable ﬂocking of mobile agents, part II:
dynamic topology. In: 42nd IEEE Conference on Decision and Control (December
2003)

39. Ungar, D., Smith, R.B.: Self: The power of simplicity. In: Meyrowitz, N. (ed.)
Proceedings of the 2nd International Conference on Object-Oriented Programming
Systems, Languages and Applications (OOPSLA 1987), Orlando, Florida, USA,
October 1987, vol. 22(12), pp. 227–241. ACM Press. ACM SIGPLAN Notices,
New York (1987)

40. Valckenaers, P., Kollingbaum, M., Van Brussel, H., Bochmann, O., Zamﬁrescu, C.:
The design of muilt-agent coordination and control systems using stigmergy. In:
International Workshop on Emergent Synthesis, IWES 2001 (March 2001)

41. Weyns, D., Omicini, A., Odelli, J.: Environment as a ﬁrst class abstraction in
multiagent systems. Autonomous Agents and Multi-Agent Systems 14(1), 5–30
(2007)

42. Yonezawa, A., Briot, J.-P., Shibayama, E.: Object-oriented concurrent programming 
in ABCL/1. In: Conference proceedings on Object-oriented programming
systems, languages and applications, pp. 258–268. ACM Press, New York (1986)
43. Yoon, H.-J., Lee, E.-J., Jeong, H., Kim, J.-S.: Proximity-based overlay routing for
service discovery in mobile ad hoc networks. In: Aykanat, C., Dayar, T., K¨orpeo˘glu,
˙I. (eds.) ISCIS 2004. LNCS, vol. 3280, pp. 176–186. Springer, Heidelberg (2004)

