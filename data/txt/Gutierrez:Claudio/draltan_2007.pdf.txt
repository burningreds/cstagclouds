A note on the history of the document:
RDF Formalization, by Draltan Marin

Claudio Gutierrez

Computer Science Department,

Universidad de Chile

Santiago de Chile, May 2006

Draltan Marin, in 2004 a student of the Programmes Masters of the Ecole
Polytechnique, France, spent the (austral) winter 2004 at the Computer Science 
Department of Universidad de Chile doing a Research Internship (Training 
Agreement 16/03/2004).

The topic of this research was: Applications de la Logique `a la s´emantique
du web, and was carried out by Draltan during the months of May to July
2004, under the supervision of Claudio Guti´errez (Universidad de Chile) and
Gilles Dowek (Ecole Polytechnique).

The output of this research was the Report on the Formalization of RDF
that follows, which was presented at the Ecole Polytechnique by Draltan
Marin in September 2004. It contains a formalization in mathematical (logic)
language of the W3C Recommendation of 10 February 2004, RDF Semantics,
edited by P. Hayes, including suggestions and corrections.

The report circulated among some researchers, but was never published.
Visiting Bolzano in May 2006, and discussing missing rules of the RDF Semantics 
document of the W3C based on this report, Enrico Franconi suggested 
me to make it public. Thus, following his suggestion, I am making it
public as a Technical Report of the Year 2006.

1

RDF formalization

Draltan Marin

draltan.marin@polytechnique.org

August 25, 2004

Contents

1 Introduction

2 Formal syntax

2.1 Graph deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Working with graphs . . . . . . . . . . . . . . . . . . . . . . . . .

3 Interpretations

3.3

3.1 Simple interpretation . . . . . . . . . . . . . . . . . . . . . . . . .
Interpreting RDF Vocabulary . . . . . . . . . . . . . . . . . . . .
3.2
3.2.1 RDF Axiomatic triples . . . . . . . . . . . . . . . . . . . .
3.2.2 RDF Interpretation . . . . . . . . . . . . . . . . . . . . .
3.2.3 Reiﬁcation, Containers and Collections . . . . . . . . . . .
Interpreting RDFS Vocabulary . . . . . . . . . . . . . . . . . . .
3.3.1 RDFS Axiomatic triples . . . . . . . . . . . . . . . . . . .
3.3.2 RDFS Interpretation . . . . . . . . . . . . . . . . . . . . .
Interpreting Datatypes . . . . . . . . . . . . . . . . . . . . . . . .
3.4.1 D-Interpretation . . . . . . . . . . . . . . . . . . . . . . .
3.4.2 XSD Interpretation . . . . . . . . . . . . . . . . . . . . . .
3.5 Alternative deﬁnition for a simple interpretation . . . . . . . . .

3.4

4 Entailment rules

4.1 General: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Instance: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3 Rdf/Rdfs:
. . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.4 Validity of the entailment rules . . . . . . . . . . . . . . . . . . .

4.3.1 Type:
4.3.2 Properties:
4.3.3 Classes:

5 Soundness and Completeness

6 RDF and First order logic

1

1

2
2
3

4
5
6
6
7
7
9
9
11
12
12
13
14

16
16
16
17
17
17
18
18

20

27

7 Conclusion and proposed corrections

29

1

Introduction

RDF stands for Resource Description Framework, and it is an assertional language 
intended to provide the necessary means to express propositions about
almost any matter.

This framework was ﬁrst created in 1998 and it was originally designed to
achieve goals such as describing properties and relationship between resources in
a machine-understandable way, thus permitting to make automated inferences
about these resources.

A resource can be practically anything, it can be an url as well as an object

such as a table, or as abstract as an idea or thought.

A proposition in RDF has a graph like structure. The meaning of one such
a proposition will be given by a formal semantic which will tell us what can be
inferred from it. RDF has a simple semantic which can be extended in order to
adapt this framework to a wide variety of uses.

This document pretends to present as formal as possible the syntactic and
semantic aspects of RDF, leaving apart the serialization or possible implementations 
of it. We have based this work on the documents presenting the formal
syntax [RDF-Concepts] and abstract semantics [RDF-Semantics] which are two
of the six documents which specify RDF. The last version at the time of writing
this document of these speciﬁcations are recommendations of the W3C of 10th
February 2004.

We will focus on section 2 on the basic deﬁnitions and structure of a proposition 
in RDF. On sections 3, 4 and 5 we will deﬁne its semantics from two
diﬀerent points of view, the ﬁrst based on a model theory for RDF and some
of its possible extensions, the notion of entailment among rdf graphs will then
be introduced. The second based on a deductive system of rules which we will
prove to be equivalent to the previous deﬁnitions, in the sense of entailment.

On section 6 we will show why we think that RDF is a fragment of ﬁrst

order logic.

During the creation of this document we have detected some problems in the
deﬁnitions and we think that there are some concepts which might be reviewed
in a next version of RDF speciﬁcations, these comments will be presented in the
last section.

2 Formal syntax

In this section we will present the formal syntax of an rdf graph.

Informally the nodes of an rdf graph can be either an URI (Uniform Resource
Identiﬁer), a literal or a blank node. The arcs can only be URIs. Note that
since an URI can be both a node and an arc the structure of an rdf graph is
not exactly this of a normal graph. Intuitively an uri will represent a resource,

2

a blank node will represent an unidentiﬁed resource, and a literal will be a
character string or some other type of data.

The basic unit of a graph is a triple, which consists of a subject, a predicate
and an object. For example, a triple (s, p, o) can be seen as an oriented node arc
node structure in which s and o are the nodes and p is an arc going from s to o.
The intended meaning of one such a triple is that the binary property p holds
for the couple (s, o). A graph will be a set of triples, where the sets of nodes
and arcs will be the union of the nodes and arcs of each triple respectively.

However, this intended meaning is not important for the moment, and will
be formalized when deﬁning the semantic of one such a graph. All the following
deﬁnitions are to be seen as formal objects only.

2.1 Graph deﬁnitions
Deﬁnition 1 (RDF URI reference) An RDF URI reference consist of a character 
string which produces a valid URI character sequence (according to [URI]).
Two RDF URI references are equal if and only if they compare as equal, character 
by character. We will note U the set of all RDF URI references.
Deﬁnition 2 (Datatype) A datatype d is deﬁned by a set Ld of character
strings, called lexical space, an arbitrary set Vd called the value space and a
map φd : Ld → Vd called the lexical-to-value mapping.
Deﬁnition 3 (Literal) A lexical form is an Unicode character string. A literal
consist of either a lexical form ω combined with an optional language tag1 τ in
which case it is called a plain literal and we will note < ω, τ > (or simply ω
when there is no language tag); or a lexical form ω combined with an RDF URI
reference u in which case it is called a typed literal and we will note ω + u. The
set of all literals will be called L.

Literals are distinct and distinguishable from RDF URI references (U ∩ L = ∅).
Let B be an arbitrary inﬁnite set disjoint from U ∪ L.

Deﬁnition 4 (Blank node) An element of B is called a blank node.
Deﬁnition 5 (RDF triple) An RDF triple is an element of U ∪ B × U × U ∪
B ∪ L. Its ﬁrst component is called the subject of the triple, the second the
predicate and the third the object.

Deﬁnition 6 (RDF graph) An RDF graph or simply graph is a set of RDF
triples. A subgraph (resp. proper subgraph) of a graph is a subset (resp. proper
subset) of triples in the graph.

Informally a datatype is identiﬁed by at least one RDF URI reference. This
identiﬁcation will be better explained when deﬁning the datatype interpretations
of an RDF graph.

RDF includes a built-in datatype XMLLiteral whose RDF URI reference is:

1A language tag may be used for identifying the language of a plain text when it’s a natural

language. Language tags are deﬁned in [RFC-3066]

3

http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral

and is fully2 described in [RDF-Concepts].
The RDF URI reference in a typed literal is informally meant to be a
datatype RDF URI identiﬁcation. Then a typed literal can be seen as a couple
(string, datatype), and will be well-typed if the string belongs to the lexical
space of the corresponding datatype, otherwise it will be called ill-typed.

2.2 Working with graphs
The following deﬁnitions are useful for stating syntactic relationship between
graphs, such as isomorphic graphs and instances of a graph. We will not treat
in detail every one of these notions and the importance they might have.
Deﬁnition 7 (Map) A map is a function µ : U ∪B ∪L → U ∪B ∪L such that
µ|U = IdU and µ|L = IdL. For any triple (s, p, o) deﬁne µ(s, p, o) as the triple
(µ(s), µ(p), µ(o)) and for a graph G, µ(G) the image by µ of the set of triples
G. A map µ is consistent with G if µ(G) is an RDF graph, that is, if for any
subject s in a triple of G we have µ(s) ∈ U ∪ B.
∼= G2)
Deﬁnition 8 (Isomorphism ) Two graphs G1, G2 are isomorphic (G1
if and only if there exists a map µ such that µ(G1) = G2 and such that µ|BG1
is bijective where BG1 is the set of blank nodes that occur in G1.
Deﬁnition 9 (Ground graph) A triple with no blank nodes is a ground triple.
A graph whose triples are all ground is called a ground graph.
Deﬁnition 10 (Occurence) We say that x ∈ U ∪B ∪ L occur in a graph G if
x is the subject, the object or the predicate of any triple in G.

Deﬁnition 11 (Name, Vocabulary) A name is a literal or a RDF URI reference.
 A typed literal comprises two names: itself and the RDF URI reference
which is part of it.
A vocabulary is a set of names. The vocabulary of a graph is the set of all
names which occur in the graph.

Note that the RDF URI reference which is part of a typed literal does not

necessarily belong to the vocabulary of a graph G.

Deﬁnition 12 (Instance) G1 is an instance of G2 if there exist a map µ
consistent with G2 such that G1 = µ(G2). We say that G1 is an instance with
respect to a vocabulary V if µ(B) ⊆ V ∪ B, and G1 is a proper instance if
µ−1(BG1) (cid:40) BG2, where BG1 and BG2 are the sets of blank nodes which occur
in G1 and G2 respectively.

Note that any graph is an instance of itself, an instance of an instance of G
is an instance of G, and if H is an instance of G then every triple in H is an
instance of some triple in G.

2See comments on last section

4

Deﬁnition 13 (Lean graph) A graph is lean if it has no instance which is a
proper subgraph of it.

3

Interpretations

In this section we will add meaning to rdf graphs. In order to do so we will
follow the same construction of interpretations used in [RDF-Semantic] except
for the notation.

Depending on the meaning we want to give to a certain graph we will consider
diﬀerent kinds of interpretations (e.g. simple, rdf, rdfs, xsd, etc.). For each one
of them there will be some special semantic conditions.

Intuitively, an interpretation will represent a possible conﬁguration of the
world, such that we can verify wether or not what is said on a graph G is true
on this world. This leads us to think of a graph as something which restricts
the possible worlds we are looking at (those in which G is true), thus providing
some information.

Now, given two graphs, G and H, if all the worlds in which G is true are
such that H is also true we will say that H is entailed by G.
In terms of
information we can think of this notion as: All the information provided by
H is already provided by G. Another way of thinking of this is that H is a
semantic consequence of G, in that case we can say that from G we can ”infer”
H.

The same reasoning applies to any kind of interpretation, and this will be

the departure point to describe semantic relationship among rdf graphs.

As described in [RDF-Semantic] any interpretation is relative to a certain
vocabulary, so we will in general speak of an interpretation of the vocabulary
V . However, at the end of this section, we will show that in terms of entailment
this is not relevant, only the semantic conditions which describe the kind of
interpretation are.

As we announced earlier, a triple (s, p, o) can be thought of as stating that
a certain binary predicate associated to p holds for the couple (s, o). An interpretation 
will give us this association, and given a graph, it will be true if none
of its triples state something false.

Blank nodes will play a special role when evaluating the value of truth of
a given graph, because every one of them represents a priori some unknown
element of the world. To interpret a blank node we will have the freedom of
choosing an arbitrary element in the domain of the interpretation as long as it
is the same element for all the occurrences of the same blank node.

3.1 Simple interpretation
Deﬁnition 14 A simple interpretation I of a vocabulary V is deﬁned by:
IR 6= ∅: the set of resources, called the domain or universe of I.
IP : the set of properties of I.
LV ⊆ IR: the set of literal values which contains all plain literals in V .

5

Γ : IP 7→ P(IR × IR)
|[·]|I : (U∪L) ∩ V → IR ∪ IP such that if x is a plain literal then |[x]|I = x, and
if it is a typed literal |[x]|I ∈ IR.

Given an interpretation I = {IR,IP ,LV , Γ,|[·]|I} consider the function |[·]|I

deﬁned by:

(cid:189)
(cid:189)

(cid:189)

true if s, p, o ∈ V,|[p]|I ∈ IP and (|[s]|I ,|[o]|I) ∈ Γ(|[p]|I)
f alse otherwise
f alse if ∃t ∈ E such that |[t]|I = f alse
true otherwise

If t is a ground triple (s, p, o):
|[t]|I =
If E is a ground graph:
|[E]|I =
Let A : B0 → IR be a mapping from a set of blank nodes (B0 ⊆ B) to the
domain of I. Consider the extension |[·]|I+A of |[·]|I deﬁned by |[b]|I+A = A(b)
when b is a blank node in B0. Then we can naturally deﬁne |[·]|I+A for triples
and graphs as we did before. Now we can extend the deﬁnition of |[·]|I for
non-ground graphs as:

true if there exists A : BE → IR such that |[E]|I+A = true
f alse otherwise

If E is an RDF graph let BE be the set of blank nodes in E:
|[E]|I =
Note that blank nodes work as if they were existential variables, and properties 
can be assigned both a binary predicate and an element of the domain of
the interpretation.
Deﬁnition 15 (Entailment) I satisﬁes G if |[G]|I = true, in that case we
will note I |= G otherwise I (cid:50) G. Let S be a set of graphs, and G a graph,
then S simply entails G if and only if for every interpretation3 I we have:
(∀H ∈ S, I |= H) ⇒ I |= G.
In that case we note S |= G.

Note that if I |= E then I |= E0 for every E0 ∼= E. This is, if we rename
the blank nodes of E to obtain E0, since there exists A : BE 7→ IR such that
|[E]|I+A = true we can ﬁnd A0 : BE0 → IR satisfying |[E0]|I+A0 = true, in fact
we can choose A0 = A◦ µ−1, where µ is a bijective map which makes E0 = µ(E).
We can see also that the restriction of the blank nodes mapping A to a certain
subset B0 of B is not necessary, because since IR 6= ∅ we can always extend A
to the whole set of blank nodes B.

Deﬁnition 16 (Validity) Any process which constructs a graph G from some
other graph(s) S is said to be (simply) valid if S entails G in every case, otherwise 
invalid.

3In fact, for this deﬁnition to be correct we should say: for every vocabulary V , for every

interpretation of V ...

6

Interpreting RDF Vocabulary

3.2
In the rest of this document the preﬁx rdf: is an abbreviation for:
http://www.w3.org/1999/02/22-rdf-syntax-ns#

The RDF vocabulary rdfV is the following set of URI references:
• rdf:type rdf:Property rdf:XMLLiteral rdf:value
• (Reiﬁcation vocabulary:) rdf:Statement rdf:subject rdf:predicate

rdf:object

• (Container vocabulary:) rdf:Seq rdf:Bag rdf:Alt rdf: 1 rdf: 2 ...
• (Collection vocabulary:) rdf:nil rdf:List rdf:first rdf:rest

3.2.1 RDF Axiomatic triples

The following set of triples is called RDF axiomatic triples:

• (rdf:type,rdf:type,rdf:Property)
• (rdf:subject,rdf:type,rdf:Property)
• (rdf:predicate,rdf:type,rdf:Property)
• (rdf:object,rdf:type,rdf:Property)
• (rdf:first,rdf:type,rdf:Property)
• (rdf:rest,rdf:type,rdf:Property)
• (rdf:value,rdf:type,rdf:Property)
• (rdf: 1,rdf:type,rdf:Property)
• (rdf: 2,rdf:type,rdf:Property)
• . . .
• (rdf:nil,rdf:type,rdf:List)

3.2.2 RDF Interpretation
Let LXM Llit,VXM Llit and φXM Llit be the lexical space, value space and lexical
to value mapping of the XMLLiteral datatype.

Deﬁnition 17 (RDF interpretation) An rdf-interpretation of V is a simple
interpretation I of (V ∪ rdf V ) which satisﬁes the extra conditions:

• x ∈ IP ⇔ (x,|[rdf:Property]|I) ∈ Γ(|[rdf:type]|I)

7

• If l is the typed literal: ω+rdf:XMLLiteral ∈ V then:

if ω ∈ LXM Llit then: |[l]|I = φXM Llit(ω), |[l]|I ∈ LV and (|[l]|I ,|[rdf:XMLLiteral]|I) ∈
Γ(|[rdf:type]|I)
otherwise |[l]|I /∈ LV and (|[l]|I ,|[rdf:XMLLiteral]|I) /∈ Γ(|[rdf:type]|I)

• I satisﬁes the RDF axiomatic triples.

Deﬁnition 18 (RDF-entailment) Let S be a set of graphs, and G a graph,
then S rdf-entails G if and only if for every rdf-interpretation I we have: (∀H ∈
S, I |= H) ⇒ I |= G.
In that case we note S |=rdf G.

3.2.3 Reiﬁcation, Containers and Collections

Note that there are no special semantic conditions to restrict the meaning of
this vocabulary. However there is an intended meaning for those names. We
will not treat in detail this subject because it is not relevant for the purposes of
this document. In fact ﬁnding an appropriate way to give semantic conditions
for this vocabulary is not easy and may be a subject of further research. Instead
we would like to point out the following aspects:

Reiﬁcation vocabulary is intended to be used when talking about rdf triple
like statements. For example, the statement which has a subject u a predicate x
and an object v can be represented by the following graph ( b is a blank node):

G = {( b,rdf:type,rdf:Statement),
( b,rdf:subject, u),
( b,rdf:predicate, x),
( b,rdf:object, v)}
It is important to note that in general neither does this graph entail the
H = {(u, x, v)}
nor does H entails G.
In fact G only states that there is an element b which is of type statement
and has u, x and o as subject, predicate and object respectively, but H states
that a certain property associated to x holds for the couple (u, v).

graph:

About container vocabulary we can say that its intended use is to represent
sets of elements. There are diﬀerent types of containers: rdf:Seq is considered
to be an ordered set, rdf:Alt is considered to represent a set of alternatives, and
rdf:Bag is considered to represent an unordered set which may have repeated
elements.

Here there is an example to illustrate the intended use of this vocabulary:
G = {( b,rdf:type,rdf:Alt),
( b,rdf: 1, u),
( b,rdf: 2, v),
( b,rdf: 3, w)}
In this example b represents a container of type rdf:Alt whose ﬁrst element
is u, its second v and its third w. However nothing prevents us to have the
following graph:

8

G0 = {( b,rdf:type,rdf:Alt),
( b,rdf: 1, u),
( b,rdf: 1, v),
( b,rdf: 4, w)}
Note that the ﬁrst element of b is both u and v. Note also that this second
graph does not entails that there exist a second or third element of this container.
In fact there is no way of stating how many elements a container may have.
Similar problems arise when using rdf:Bag or rdf:Seq.

is:

Collection vocabulary is used to describe list structures. An example of this
G0 = {(x,rdf:type,rdf:List),
(x,rdf:first, u),
(x,rdf:rest, v),
(v,rdf:first, w),
(v,rdf:rest,rdf:nil)}
Even thought rdf:nil is meant to represent the empty list and is used to
mark the end of the list, nothing prevents us to have a list without an end, or
a list with multiple endings, etc. For example:

G0 = {(x,rdf:type,rdf:List),
(x,rdf:first, u),
(x,rdf:rest, v),
(v,rdf:first, w),
(v,rdf:rest,rdf:nil)
(v,rdf:rest, z),
(z,rdf:first, u)
(z,rdf:rest,rdf:nil)}
All these pathological cases we have just seen are perfectly possible and the
lack of semantic conditions for these vocabularies requires us to be careful when
using it.

Interpreting RDFS Vocabulary

3.3
In the rest of this document the preﬁx rdfs: is an abbreviation for:
http://www.w3.org/2000/01/rdf-schema#

The RDFS vocabulary rdfsV is the following set of URI references:
• rdfs:domain rdfs:range
• rdfs:Resource rdfs:Literal rdfs:Datatype
• rdfs:Class rdfs:subClassOf rdfs:subPropertyOf
• rdfs:member rdfs:Container rdfs:ContainerMembershipProperty
• rdfs:comment rdfs:seeAlso rdfs:isDefinedBy rdfs:label

9

3.3.1 RDFS Axiomatic triples

The following set of triples is called RDFS axiomatic triples:

• (rdf:type, rdfs:domain, rdfs:Resource)
• (rdfs:domain, rdfs:domain, rdf:Property)
• (rdfs:range, rdfs:domain, rdf:Property)
• (rdfs:subPropertyOf, rdfs:domain, rdf:Property)
• (rdfs:subClassOf, rdfs:domain, rdfs:Class)
• (rdf:subject, rdfs:domain, rdf:Statement)
• (rdf:predicate, rdfs:domain, rdf:Statement)
• (rdf:object, rdfs:domain, rdf:Statement)
• (rdfs:member, rdfs:domain, rdfs:Resource)
• (rdf:first, rdfs:domain, rdf:List)
• (rdf:rest, rdfs:domain, rdf:List)
• (rdfs:seeAlso, rdfs:domain, rdfs:Resource)
• (rdfs:isDefinedBy, rdfs:domain, rdfs:Resource)
• (rdfs:comment, rdfs:domain, rdfs:Resource)
• (rdfs:label, rdfs:domain, rdfs:Resource)
• (rdf:value, rdfs:domain, rdfs:Resource)
• (rdf:type, rdfs:range, rdfs:Class)
• (rdfs:domain, rdfs:range, rdfs:Class)
• (rdfs:range, rdfs:range, rdfs:Class)
• (rdfs:subPropertyOf, rdfs:range, rdf:Property)
• (rdfs:subClassOf, rdfs:range, rdfs:Class)
• (rdf:subject, rdfs:range, rdfs:Resource)
• (rdf:predicate, rdfs:range, rdfs:Resource)
• (rdf:object, rdfs:range, rdfs:Resource)
• (rdfs:member, rdfs:range, rdfs:Resource)
• (rdf:first, rdfs:range, rdfs:Resource)

10

• (rdf:rest, rdfs:range, rdf:List)
• (rdfs:seeAlso, rdfs:range, rdfs:Resource)
• (rdfs:isDefinedBy, rdfs:range, rdfs:Resource)
• (rdfs:comment, rdfs:range, rdfs:Literal)
• (rdfs:label, rdfs:range, rdfs:Literal)
• (rdf:value, rdfs:range, rdfs:Resource)
• (rdf:Alt, rdfs:subClassOf, rdfs:Container)
• (rdf:Bag, rdfs:subClassOf, rdfs:Container)
• (rdf:Seq, rdfs:subClassOf, rdfs:Container)
• (rdfs:ContainerMembershipProperty, rdfs:subClassOf, rdf:Property)
• (rdfs:isDefinedBy, rdfs:subPropertyOf, rdfs:seeAlso)
• (rdf:XMLLiteral, rdf:type, rdfs:Datatype)
• (rdf:XMLLiteral, rdfs:subClassOf, rdfs:Literal)
• (rdfs:Datatype, rdfs:subClassOf, rdfs:Class)
• (rdf: 1, rdf:type, rdfs:ContainerMembershipProperty)
• (rdf: 1, rdfs:domain, rdfs:Resource)
• (rdf: 1, rdfs:range, rdfs:Resource)
• (rdf: 2, rdf:type, rdfs:ContainerMembershipProperty)
• (rdf: 2, rdfs:domain, rdfs:Resource)
• (rdf: 2, rdfs:range, rdfs:Resource)
• ...

3.3.2 RDFS Interpretation

Deﬁnition 19 (RDFS interpretation) An rdfs-interpretation of V is an rdfinterpretation 
I of (V ∪rdf V ∪rdf sV ) plus a set IC ⊂ IR and a map ΓC : IC →
P(IR) which satisfy the extra conditions:

• x ∈ ΓC(y) ⇔ (x, y) ∈ Γ(|[rdf:type]|I)
• IC = ΓC(|[rdfs:Class]|I)
• IR = ΓC(|[rdfs:Resource]|I)

11

• LV = ΓC(|[rdfs:Literal]|I)
• (x, y) ∈ Γ(|[rdfs:domain]|I) and (u, v) ∈ Γ(x) ⇒ u ∈ ΓC(y)
• (x, y) ∈ Γ(|[rdfs:range]|I) and (u, v) ∈ Γ(x) ⇒ v ∈ ΓC(y)
• Γ(|[rdfs:subPropertyOf]|I) is reﬂexive and transitive on IP
• (x, y) ∈ Γ(|[rdfs:subPropertyOf]|I) ⇒ x, y ∈ IP and Γ(x) ⊂ Γ(y)
• x ∈ IC ⇒ (x,|[rdfs:Resource]|I) ∈ Γ(|[rdfs:subClassOf]|I)
• (x, y) ∈ Γ(|[rdfs:subClassOf]|I) ⇒ x, y ∈ IC and ΓC(x) ⊂ ΓC(y)
• Γ(|[rdfs:subClassOf]|I) is reﬂexive and transitive on IC
• x ∈ ΓC(|[rdfs:ContainerMembershipProperty]|I) ⇒ (x,|[rdfs:member]|I) ∈

Γ(|[rdfs:subPropertyOf]|I)

• x ∈ ΓC(|[rdfs:Datatype]|I) ⇒ (x,|[rdfs:Literal]|I) ∈ Γ(|[rdfs:subClassOf]|I)
• I satisﬁes the RDFS axiomatic triples.

Note that since an rdfs interpretation is an rdf interpretation then for an ill
typed XML literal l, this is a typed literal whose uri is rdf:XMLLiteral and
such that its lexical form does not belong to the lexical space of the XMLLiteral
datatype, we must have that |[l]|I /∈ LV .

have that a graph such as:

Now by the ﬁrst, fourth and sixth conditions of an rdfs interpretation we
G = {(a,rdfs:range,rdfs:Literal), (x, a, l)}
has no interpretation if l is an ill typed XML literal.
In that case, this is when there is no rdfs interpretation which satisﬁes a
graph, we will say that it is an XML clash. Note that since this is the only
negative condition all the XML clashes are product of stating in a graph that
an ill typed literal is of type literal.

For rdf interpretations this problem does not arise because there is no possibility 
of stating one such a thing.

Deﬁnition 20 (RDFS-entailment) Let S be a set of graphs, and G a graph,
then S rdfs-entails G if and only if for every rdfs-interpretation I we have:
(∀H ∈ S, I |= H) ⇒ I |= G.
In that case we note S |=rdf s G.

Interpreting Datatypes

3.4
As we said earlier, every datatype is ”identiﬁed” by at least one URI, and
a typed literal is intended to represent an element of the value space of the
datatype identiﬁed by the URI given in it. In order to give a formal deﬁnition
for this ”identiﬁcation” we need to have a function which associates URIs to
datatypes. One such a function will be called a datatype map. Then, by means

12

of this map we will be able to interpret typed literals. There will be then the
notion of well and ill typed literals. A well typed literal will correspond to a
typed literal l whose character string belongs to the lexical space of the datatype
corresponding to the URI included in l, otherwise it will be an ill typed literal.
However this notion will change if we change the map we are considering.

So, when interpreting datatypes, we will need to specify which is the map
we are considering. There will be only one restriction to one such a datatype
map: the datatype XML Literal, which is intended to be the built in datatype
of rdf will have to be always identiﬁed by rdf:XMLLiteral. So for the special
case of a typed literal whose URI is rdf:XMLLiteral there will be no confusion
possible to determine wether it is or not a well typed literal. In general we will
speak of a well/ill typed XML Literal when this is the case.

Formally:

Deﬁnition 21 (Datatype map) Let D be a set of datatypes containing the
XML Literal datatype (which we will note dxmlLit) and U a set of RDF URI
references containing rdf:XMLLiteral, then a datatype map D is a map D :
U →.D such that D(rdf:XMLLiteral) = dxmlLit.
For each datatype d we will note respectively Ld, Vd and φd the lexical space,
the value space and the lexical to value mapping of d.

3.4.1 D-Interpretation

Deﬁnition 22 (D-interpretation) Let D be a datatype map, then a D-interpretation
of a vocabulary V is an rdfs-interpretation I of (V ∪ U) which satisﬁes the following 
extra conditions:

• |[u]|I = D(u)
• If D(u) = d then IC(d) = Vd and IC(d) ⊆ LV
• If D(u) = d then for any typed literal ω + v, if |[v]|I = d: if ω ∈ Ld then

|[ω + v]|I = φd(ω) otherwise |[ω + v]|I /∈ LV

• If D(u) = d then |[u]|I ∈ ΓC(|[rdfs:Datatype]|I)

Deﬁnition 23 (Well / ill -typed literal) A typed literal ω + u is called a
well-typed literal in a D interpretation I if u ∈ U and ω ∈ LD(u). If u ∈ U and
ω /∈ LD(u) it is called an ill-typed literal.

The ﬁrst condition ensures that I interprets the URI reference according
to the datatype map provided. Note that this does not prevent other URI
references from also denoting the datatype.

The second condition ensures that the datatype URI reference, when used
as a class name, refers to the value space of the datatype, and that all elements
of a value space must be literal values.

The third condition ensures that typed literals in the vocabulary respect the
datatype lexical-to-value mapping. The condition also requires that an ill-typed

13

literal, where the literal string is not in the lexical space of the datatype, not
denote any literal value. Intuitively, such a name does not denote any value, but
in order to avoid the semantic complexities which arise from empty names, the
semantics requires such a typed literal to denote an ’arbitrary’ non-literal value.
An ill-typed literal does not in itself constitute an inconsistency, but a graph
which entails that an ill-typed literal has rdf:type rdfs:Literal, or that an
ill-typed XML literal has rdf:type rdf:XMLLiteral, would be inconsistent.

Note that this third condition applies only to datatypes in the range of D.
Typed literals whose type is not in the datatype map of the interpretation are
treated as before, i.e. as denoting some unknown thing. The condition does not
require that the URI reference in the typed literal be the same as the associated
URI reference of the datatype; this allows semantic extensions which can express
identity conditions on URI references to draw appropriate conclusions.

The fourth condition ensures that the class rdfs:Datatype contains the
datatypes used in any satisfying D-interpretation. Notice that this is a necessary,
 but not a suﬃcient, condition; it allows the class |[rdfs:Datatype]|I to
contain other datatypes.

Deﬁnition 24 (D-entailment) Let S be a set of graphs, and G a graph, then
S D-entails G if and only if for every D-interpretation I we have: (∀H ∈ S, I |=
H) ⇒ I |= G.
In that case we note S |=D G.

3.4.2 XSD Interpretation

In the rest of this document the preﬁx xsd: is an abbreviation for:
http://www.w3.org/2001/XMLSchema#

The following are the XSD datatypes deﬁned in XML Schema Part 2: Datatypes

[XML-Schema2] and are referred to as XSD Datatypes:

xsd:string, xsd:boolean, xsd:decimal, xsd:float, xsd:double, xsd:dateTime,

xsd:time, xsd:date, xsd:gYearMonth, xsd:gYear, xsd:gMonthDay, xsd:gDay,
xsd:gMonth, xsd:hexBinary, xsd:base64Binary, xsd:anyURI, xsd:normalizedString,
xsd:token, xsd:language, xsd:NMTOKEN, xsd:Name, xsd:NCName, xsd:integer,
xsd:nonPositiveInteger, xsd:negativeInteger, xsd:long, xsd:int, xsd:short,
xsd:byte, xsd:nonNegativeInteger, xsd:unsignedLong, xsd:unsignedInt,
xsd:unsignedShort, xsd:unsignedByte, xsd:positiveInteger

Note that here we have denoted each datatype with its respective RDF URI

reference.

Deﬁnition 25 A datatype map which maps each one of the above RDF URI
references as the respective XSD datatype is called an XSD datatype map. A D
interpretation where D is an XSD datatype map is called an XSD interpretation.

14

3.5 Alternative deﬁnition for a simple interpretation
In terms of entailment we can see that the restriction of an interpretation to
a certain vocabulary is not necessary. In fact, we could consider a deﬁnition
of interpretation independent of the vocabulary and even when the notion of
satisfaction would change, the notion of entailment remains the same.

For sake of clarity we will note, during this paragraph, a simple interpretation 
of a vocabulary a v-interpretation. We will also note the satisfaction and
entailment of a graph with the |=v symbol.
Deﬁnition 26 A β-interpretation I is deﬁned by:
IR 6= ∅: the set of resources, called the domain or universe of I.
IP : the set of properties of I.
LV ⊆ IR: the set of literal values which contains all plain literals in L.
Γ : IP 7→ P(IR × IR)
|[·]|I : U∪L → IR ∪ IP such that if x is a plain literal then |[x]|I = x, and if it
is a typed literal |[x]|I ∈ IR.

Here we have changed the previous restriction of |[·]|I to the whole space of
URI references and Literals (U∪L). Note that a β-interpretation is always a
v-interpretation where the vocabulary is U∪L.
The deﬁnition of |[·]|I for ground triples and graphs is the same, except that
now the condition ”s, p, o ∈ V ” for a ground triple is not necessary and can be
omitted.
In order to interpret blank nodes we will consider maps of the form A : B →
IR and the same construction used earlier to deﬁne |[·]|I+A and |[·]|I+A, which
leads to the following deﬁnition of |[·]|I for a graph E:

(cid:189) |[x]|I if x ∈ U∪L
(cid:189)
(cid:189)

Given a map A : B → IR :
|[x]|I+A =
A(x) if x ∈ B
If t is a triple (s, p, o):
true if |[p]|I+A ∈ IP and (|[s]|I+A,|[o]|I+A) ∈ Γ(|[p]|I+A)
|[t]|I+A =
f alse otherwise
If E is a graph:
f alse if ∃t ∈ E such that |[t]|I+A = f alse
|[E]|I+A =
true otherwise
|[E]|I

true if there exists A : B → IR such that |[E]|I+A = true
f alse otherwise

(cid:189)

β =

Deﬁnition 27 Given a β-interpretation I, we say that I β-satisﬁes G if |[G]|I
true, in that case we will note I |=β G, otherwise I (cid:50)β G.
Deﬁnition 28 Let S be a set of graphs, and G a graph, then S β-entails G if
and only if for every β-interpretation I we have: (∀H ∈ S, I |=β H) ⇒ I |=β G.
In that case we note S |=β G.
Proposition 1 Let S be a set of graphs, and G a single graph, then (S |=β
G) ⇔ (S |=v G).

β =

15

Proof. It is easy to see that (S |=v G) ⇒ (S |=β G), because we know that a
β-interpretation can be seen as a v-interpretation of the vocabulary U∪L.
We will now prove ¬(S |=v G) ⇒ ¬(S |=β G). This means that if there
exist a v-interpretation I = {IR,IP ,LV , Γ,|[·]|I} such that ∀H ∈ S, I |=v H
and I (cid:50)v G then there exists a β-interpretation I0 such that ∀H ∈ S, I0 |=β H
and I0 (cid:50)β G. If the vocabulary V of I is U ∪ L, then I is also a β-interpretation
and we can consider I0 = I.
Assume now that V (cid:40) U ∪ L, and consider the case when the vocabulary of
G is a subset of V (VG ⊆ V ). Then the β-interpretation I0 deﬁned by:
I0
R = IR ∪ Lplain where Lplain is the set of all plain literals in L.
I0
P = IP
L0
V = Lplain ∪ LV
Γ0 = Γ
|[·]|I0(x) =

x if x is a plain literal
x0 otherwise.
trivially satisﬁes ∀H ∈ S, I0 |=β H. If we had I0 |=β G then there would be a
R such that: |[G]|I0+A0 = true, this means that for every triple
map A0 : B → I0
t ∈ G : |[t]|I0+A0 = true, but then we would have that since the interpretations
I and I0 give the same value of truth for every triple in G then I would also
satisfy G as a v-interpretation which is a contradiction.
In the case when VG (cid:42) V we have that VG 6= ∅ and therefore G 6= ∅.
Moreover, since there exist x0 in VG not in V there is a triple t0 in which x0 occur.
One such a triple can’t be in any H ∈ S. We will construct a β-interpretation in
which the triple t0 will always be f alse. Let I0 be a β-interpretation satisfying
∀H ∈ S, I0 |=β H. Then redeﬁne I0 as follows:

 |[x]|I if x ∈ V

where x0 is a ﬁxed element in IR.

If t0 = (a, x0, b) then |[x0]|I0 ∈ I0
If t0 = (x0, a, b) then |[a]|I0 ∈ I0
If t0 = (b, a, x0) then |[a]|I0 ∈ I0
None of these conditions can aﬀect the value of truth given to any H ∈ S
β and they guarantee that the interpretation obtained doesn’t β-satisfy

P and Γ0(|[x0]|I0) = ∅.
P and ∀c ∈ IR, (|[x0]|I0, c) /∈ Γ0(|[a]|I0)
P and ∀c ∈ IR, (c,|[x0]|I0) /∈ Γ0(|[a]|I0)

by |[·]|I
G.

4 Entailment rules

In this section we will introduce a set of rules with which we will be able to
prove entailment between graphs. Each one of these rules consists of two parts:
B . The upper part is a set (possibly inﬁnite) of clauses of the form Σ : K ‘ G
A
in which K and G are rdf graphs, and Σ is a mapping from a subset of B to
BK ∪ VK ∪ rdf sV ∪ rdf V . The lower part is a clause of the same form.

Informally a proof will be a tree whose nodes are labeled by a set of clauses
and for each one of these clauses we will apply a rule. The out-arcs from a node
will then be the rules applied to these clauses. We will show that if a proof tree
whose root is the clause ∅ : K ‘ G where K and G are graphs with no blank
nodes in common and whose leafs are all an empty inference, then K |= G.

16

Inversely, if K |= G we will show that it is possible to construct one such a
proof tree.

Note that in order to ”apply” a rule certain conditions must be satisﬁed,

which will be exposed with each rule.

Deﬁnition 29 (Proof tree) Is a rooted labeled tree. Each node of the tree is
a set of clauses A, and for each clause C of this set there is exactly one out-arc
labeled by one of the rules of the form X
C . For each node A diﬀerent from the
root there is exactly one in-arc labeled by a rule of the form A
X .

Note that a triple (s, p, o) represents the graph containing only this triple

and Axioms means the set of rdf and rdfs axiomatic triples.

The rules are the following:

4.1 General:

1.

2.

4.2

1.

2.

3.

4.

Σ : K ‘ (s, p, o) init only if (s, p, o) ∈ K
{Σ : K ‘ t; t ∈ E}

break only if BE ⊂ dom(Σ)

Σ : K ‘ E

alloc only if BE ⊂ dom(Σ)

Instance:
Σ : K ‘ E
∅ : K ‘ E
Σ : K ‘ (s, p, x)
Σ : K ‘ (s, p, b) ins1 only if Σ( b) = x
Σ : K ‘ (x, p, o)
Σ : K ‘ ( b, p, o) ins2 only if Σ( b) = x
Σ : K ‘ (s, p, b)
Σ : K ‘ (s, p, x) gl only if Σ( b) = x ∈ L

4.3 Rdf/Rdfs:

4.3.1 Type:

Σ : K ‘ (s, p, o)

1.

2.

3.

Σ : K ‘ (p, rdf:type, rdf:Prop) rdf1
Σ : K ‘ (x, rdf:type, rdf:Res) rdf s4
only if x ∈ BK ∪ VK ∪ rdf sV ∪ rdf V
Σ : K ‘ ( b, rdf:type, rdf:Res) rdf s4l
only if Σ( b) = x ∈ L∩VK

17

4.

5.

6.

7.

8.

Σ : K ‘ ( b, rdf:type, rdf:XMLLit) rdf2
only if Σ( b) = l is a well-typed XMLLiteral and l ∈ VK.
Σ : K ‘ ( b, rdf:type, rdfs:Literal) rdf s1
only if Σ( b) = l is a plain literal and l ∈ VK.
Σ : K ‘ (a, rdf:domain, b), Σ : K ‘ (x, c, y), Σ : K ‘ (c, rdfs:sp, a)

Σ : K ‘ (x, rdf:type, b)

rdf s2

Σ : K ‘ (a, rdf:range, b), Σ : K ‘ (x, c, y), Σ : K ‘ (c, rdfs:sp, a)

Σ : K ‘ (y, rdf:type, b)

rdf s3

Σ : K ‘ (a, rdfs:sc, b), Σ : K ‘ (x, rdf:type, a)

Σ : K ‘ (x, rdf:type, b)

rdf s9

4.3.2 Properties:

Σ : K ‘ (a, rdfs:sp, b), Σ : K ‘ (x, a, y)

rdf s7
Σ : K ‘ (a, rdfs:sp, b), Σ : K ‘ (b, rdfs:sp, c)

Σ : K ‘ (x, b, y)

Σ : K ‘ (a, rdfs:sp, c)
Σ : K ‘ (a, rdf:type, rdf:Prop)

Σ : K ‘ (a, rdfs:sp, a)

rdf s6

Σ : K ‘ (a, rdf:type, rdfs:ContMemProp)

Σ : K ‘ (a, rdfs:sp, rdf:Member)

rdf s12

rdf s5

4.3.3 Classes:

1.

2.

3.

4.

1.

2.

3.

4.

Σ : K ‘ (a, rdf:type, rdfs:Class)

Σ : K ‘ (a, rdfs:sc, rdf:Res)

rdf s8

Σ : K ‘ (a, rdfs:sc, b), Σ : K ‘ (b, rdfs:sc, c)

Σ : K ‘ (a, rdfs:sc, c)
Σ : K ‘ (a, rdf:type, rdfs:Class)

Σ : K ‘ (a, rdfs:sc, a)

rdf s10

Σ : K ‘ (a, rdf:type, rdfs:Datatype)
Σ : K ‘ (a, rdfs:sc, rdfs:Literal) rdf s13

rdf s11

4.4 Validity of the entailment rules
We will now show that if there exists a ﬁnite height proof tree whose root is
Σ : K ‘ E then K |=rdf s E. Moreover, we will show that for every interpretation
I such that I |= K, for every A such that |[K]|I+A = true there exist a mapping

18

σ : B → I R satisfying σ(x) = |[Σ(x)]|I+A for every blank node x in dom(Σ) such
that |[G]|I+σ = true.

In more simple words this means that every blank node in G can be identiﬁed
to a node in K, which can be an uri or literal as well as a blank node and the
function Σ is the mean to manage this identiﬁcation during the proof.
For sake of clarity we will note Σ : K |= E the following proposition: ∀I,∀A :
|[K]|I+A = true ⇒ ∃σ : B → I R such that σ(x) = |[Σ(x)]|I+A for every x in
dom(Σ) and |[E]|I+σ = true.
We can restrict this notation for rdf or rdfs interpretations only to have
Σ : K |=rdf E and Σ : K |=rdf s E respectively. Note that Σ : K |= E ⇒ K |= E.
Proposition 2 Given two rdf graphs K and E such that and there exist a
proof tree of ﬁnite height and whose root is Σ : K ‘ E, where Σ is such that
dom(Σ) ∩ img(Σ) = ∅ and dom(Σ) ∩ BK = ∅ then Σ : K |=rdf s E.
Proof. We will prove this by induction over the height of the tree. There
are however many cases for which the proof is practically the same, so we will
only present the most signiﬁcant cases. Note that we will only consider rdfs
interpretations.
For every case when the root of the tree is Σ : K ‘ E we will consider, given
I and A such that |[K]|I+A = true, the following deﬁnition of σ:
σ(x) =

(cid:189) |[Σ(x)]|I+A if x ∈ dom(Σ)

A(x) otherwise

If the height of the tree is 1 we have the following cases:
•

Σ : K ‘ (s, p, o) init:
Since to apply this rule we must have that (s, p, o) ∈ K, we know that
neither s nor o belong to dom(Σ). Then |[(s, p, o)]|I+σ = |[(s, p, o)]|I+A =
true.
Σ : K ‘ (x, rdf:type, rdf:Res) rdf s4:
In order to apply this rule x must belong to BK ∪ VK ∪ rdf sV ∪ rdf V
so for every rdfs interpretation I for every A we know that |[x]|I+σ =
|[x]|I+A ∈ IR and by the semantic conditions of an rdfs interpretation
IR = ΓC(|[rdf:Res]|I) which means that (|[x]|I+A,|[rdf:Res]|I) ∈ Γ(|[rdf:type]|I).
Σ, : K ‘ ( b, rdf:type, rdf:Res) rdf s4l:
Since x ∈ L∩VK and we have that |[ b]|I+σ = |[x]|I the proof is the same
as in the previous case.
Σ : K ‘ ( b, rdf:type, rdf:XMLLit) rdf2
We know that l is a well typed XML literal and l ∈ VK so for any I an rdf
interpretation we have that |[l]|I ∈ ΓC(|[rdf:XMLLit]|I), so (|[l]|I ,|[rdf:XMLLit]|I) ∈
Γ(|[rdf:type]|I). Besides we know that |[l]|I = |[ b]|I+σ which concludes
the proof.

•

•

•

19

•

Σ : K ‘ ( b, rdf:type, rdfs:Literal) rdf s1:
The proof is the same as in the previous case except that we use the semantic 
conditions for rdfs interpretations.

For the rest of the cases we will only prove the following (because the proof

is practically the same for the others):

alloc:

break:

• Σ : K ‘ E
∅ : K ‘ E
We know that there exists a proof tree whose root is Σ : K ‘ E by hypothesis 
of induction we know that ∀I,∀A such that |[K]|I+A = true there
exists σ such that |[E]|I+σ = true
• Σ : K ‘ (s, p, x)
Σ : K ‘ (s, p, b) ins1:
We know that Σ( b) = x so ∀I,∀A we have that |[ b]|I+σ = |[x]|I+A and
then, since Σ : K |= (s, p, x) we conclude Σ : K |= (s, p, b). (The proof is
almost the same for the cases ins2 and gl)
• {Σ : K ‘ t; t ∈ E}
This means that for every t ∈ E we have Σ : K |= t. In other words
∀t ∈ E,∀I,∀A,∃σt such that ∀x ∈ dom(Σ) : σt(x) = |[Σ(x)]|I+A and
|[K]|I+A ⇒ |[t]|I+σt.
Since dom(Σ) contains every blank node in E then for every triple t the
restriction of σt to the set of blank nodes BE is the same function, name
it σE. Then we can choose for every triple t the same σE which leads to
the following:
∀I,∀A,∃σE such that ∀x ∈ dom(Σ) : σE(x) = |[Σ(x)]|I+A and |[K]|I+A ⇒
∀t ∈ E : |[t]|I+σE
Which is exactly Σ : K |= E.

Σ : K ‘ E

For all the rest of the cases the proof is straightforward from the semantic

conditions of an rdf or rdfs interpretation.

5 Soundness and Completeness

The main result of this section is that the deductive system of the previous
entailment rules is complete for rdfs entailment. It is easy to prove the soundness
of these rules, in fact, in order to do so we must only prove for each one of these
rules that they are valid. This follows directly from the deﬁnitions.

If we are in the case of simple and rdf entailment not all the rules are valid.

Theorem 3 (Simple entailment) Given K and E two ﬁnite rdf graphs where
BK ∩ BE = ∅ then K |= E if and only if there exist a proof tree whose root is
∅ : K ‘ E and the arcs can only be labeled by one of the following rules: init,
break, alloc, ins1, ins2.

20

Proof. Since E has an instance which is a subgraph of K there exist a mapping
µ satisfying µ(E) ⊆ K. We apply then the alloc rule to get µ : K ‘ E followed
by the break rule and then for each one of the branches the ins1 and ins2 rules
when necessary. Then the init rule to ﬁnish the proof tree.
The proof of the ”if” we have to prove that all these rules are valid, which is
the same proof we did earlier.

Theorem 4 (RDF Entailment) Given K and E two ﬁnite rdf graphs where
BK ∩BE = ∅ then K |=rdf E if and only if there exist a proof tree whose root is
∅ : K ‘ E and the arcs can only be labeled by one of the following rules: init,
break, alloc, ins1, ins2, rdf1, rdf2.

We will not prove this theorem since the proof follows the same principle of

the proof for rdfs entailment.

The following theorem says that this deductive system is sound and complete

for rdfs entailment.
Theorem 5 (RDFS Entailment) Given K and E two rdf graphs where BK∩
BE = ∅ and such that neither K nor E are XML clash, then K |=rdf s E if and
only if there exist a proof tree whose root is ∅ : K ‘ E and the arcs can only be
labeled by any of the following rules: general rules, instance rules, or rdf/rdfs
rules.

To prove this theorem we will need to deﬁne an rdfs Herbrand interpretation,

in order to do so, let’s consider the following construction:

Let K be an rdf graph such that there exist at least one rdfs interpretation

satisfying K. This means that it is not an XML clash. Then we deﬁne I0 as:

• IR ={x; x ∈ U ∪ BK and x occur in K}∪

{x; x is a plain literal or ill typed XML literal}∪
{φXM L(x); x is a well typed XML literal}∪
rdf V ∪ rdf sV

(cid:189)

φXM L(x) if x is a well typed XML literal
x otherwise

• |[x]| =
• IP = {|[p]|; (s, p, o) ∈ K ∪ Axioms} ∪ {p|(p,rdf:type,rdf:Prop) ∈ K ∪
Axioms}
• Lv ={|[x]|; x is a plain literal}∪

{|[x]|; x is a well typed XML literal}∪
{|[x]|; (x, rdf:type, rdf:Literal) ∈ K}∪
{|[x]|; (x, rdf:type, rdf:XMLLit) ∈ K}

21

• Γ0(|[rdf:type]|) =

{(|[x]|,|[rdf:Literal]|); x is a plain literal}∪
{(|[x]|,|[rdf:XMLLit]|); x is a well typed XML literal}∪
{(|[x]|,|[rdf:Prop]|); (u, x, v) ∈ K}∪
{(|[x]|,|[rdf:Res]|;|[x]| ∈ IR}∪
{(|[x]|,|[y]|); (x, rdf:type, y) ∈ K}

• if p is diﬀerent from rdf:type:

Γ0(|[p]|) = {(|[x]|,|[y]|); (x, p, y) ∈ K}

Now for each i ∈ N+ consider Ii deﬁned inductively as:
• IR,i = IR
• |[x]|i = |[x]|
• IP,i = IP,i−1 ∪ {x; (x,|[rdf:Prop]|) ∈ Γi−1(|[rdf:type]|)}
• Lv,i = Lv,i−1 ∪ {x; (x,|[rdf:Literal]|) ∈ Γi−1(|[rdf:type]|)}
• Γi(|[rdf:type]|) =

Γi−1(|[rdf:type]|)∪
{(u, v); (u, v) ∈ Γi−1(x) ∧ (x,|[rdf:type]|) ∈ Γi−1(|[rdfs:sp]|)}
{(u, y); (u, v) ∈ Γi−1(x) ∧ (x, y) ∈ Γi−1(|[rdfs:domain]|)}
{(v, y); (u, v) ∈ Γi−1(x) ∧ (x, y) ∈ Γi−1(|[rdfs:range]|)}
{(u, y); (u, x) ∈ Γi−1(|[rdf:type]|) ∧ (x, y) ∈ Γi−1(|[rdfs:sc]|)}

• Γi(|[rdfs:sc]|) =

Γi−1(|[rdfs:sc]|)∪
{(u, v); (u, v) ∈ Γi−1(x) ∧ (x,|[rdf:sc]|) ∈ Γi−1(|[rdfs:sp]|)}∪
{(x,|[rdfs:Res]|); (x,|[rdfs:Class]|) ∈ Γi−1(|[rdf:type]|)}∪
{(x, x); (x,|[rdfs:Class]|) ∈ Γi−1(|[rdf:type]|)}∪
{(x, y); (x, z) ∈ Γi−1(|[rdfs:sc]|) ∧ (z, y) ∈ Γi−1(|[rdfs:sc]|)}∪
{(x,|[rdf:Literal]|); (x,|[rdfs:Datatype]|) ∈ Γi−1(|[rdf:type]|)}

• Γi(|[rdfs:sp]|) =

Γi−1(|[rdfs:sp]|)∪
{(u, v); (u, v) ∈ Γi−1(x) ∧ (x,|[rdf:sp]|) ∈ Γi−1(|[rdfs:sp]|)}∪
{(x, x); (x,|[rdf:Prop]|) ∈ Γi−1(|[rdf:type]|)}∪
{(x, y); (x, z) ∈ Γi−1(|[rdfs:sp]|) ∧ (z, y) ∈ Γi−1(|[rdfs:sp]|)}∪
{(x,|[rdf:Member]|); (x,|[rdfs:ContMemProp]|) ∈ Γi−1(|[rdf:type]|)}

• Γi(p) =

Γi−1(p)∪
{(u, v); (u, v) ∈ Γi−1(x) ∧ (x, p) ∈ Γi−1(|[rdfs:sp]|)}∪

Clearly I0 simply entails K, and so for all the other simple interpretations
Now, given a set of interpretations M such that ∀I, I0 ∈ M we have: IR,I =

Ii.
IR,I0 = IR and |[·]|I = |[·]|I0 = |[·]| we can deﬁne:

22

I as:

I∗ =
I∈M
IR,∗ = IR
|[x]|∗ = |[x]|
IP,∗ =
I∈M
Lv,∗ =
Γ(p) =

(cid:83)
(cid:83)
(cid:83)

I∈M

I∈M

IP,I
Lv,I
ΓI(p)

(cid:83)

All this leads us to the following deﬁnition:

Deﬁnition 30 (RDFS Herbrand Interpretation) The rdfs Herbrand interpretation 
IH of K is deﬁned by:

(cid:83)
i∈N
and ΓC(y) = {x; (x, y) ∈ Γ(|[rdf:type]|IH )}

Ii

It is easy to verify that IH is an rdfs interpretation of K. In fact IH is such
that |[K]|IH +id = true where id is the identity function over blank nodes. And
it satisﬁes all the rdfs semantic conditions.
Moreover, given a triple t and a function over blank nodes A if |[t]|IH +A =
true there exists i ∈ N such that |[t]|Ii+A = true. And K |=rdf s E ⇔ IH |= E.
Lemma 6 Let E, K be rdf graphs such that BE ∩BK = ∅ and such that neither
K nor E are XML clash, then there exist Σ such that dom(Σ) = BE and Σ :
K ‘rdf s E if and only if K |=rdf s E.
Proof (of the lemma). As we said earlier if there exist one such Σ, satisfying
Σ : K ‘ E then clearly we have K |= E. The opposite way requires a more
delicate treatment:

The idea is to identify by means of the Herbrand model of K all the blanks
in E to nodes of K. Then, with this identiﬁcation Σ we will see that for every
triple in E the condition Σ : K ‘ (s, p, o) holds. Since for every triple in E which
doesn’t contain any blank this Σ function won’t change anything the proof is
over, for the rest of the triples we show that the value of truth of the triple will
be given by the Herbrand model because it satisﬁes only those triples which are
true in every interpretation of K.
Assume K |= E then we know that for every interpretation I which makes
|[K]|I true also makes |[E]| true. Let’s take the rdfs Herbrand interpretation of
K.
We know that IH |=rdf s E which means that there exist A : BE → IR such
that |[E]|IH +A = true. But since there exist a bijection between IR and the set
of nodes of K (the identity except for well typed XML literals) we can construct
a function Σ : BE → BK ∪ VK ∪ rdf sV ∪ rdf V as follows:

(cid:189)

XM L(A(x)) if A(x) ∈ VXM Llit
φ−1
A(x) otherwise

Σ(x) =
We must now prove that this Σ satisﬁes Σ : K ‘ E.

23

Let I be an rdfs interpretation of K and A0 be such that |[K]|I+A0 = true.
Consider σ deﬁned as σ(x) = |[Σ(x)]|I+A0 then, for every triple (s, p, o) ∈ E we
have that exactly one of the following cases occur:

1. neither s nor o are blank nodes

2. only s is a blank node:

3. only o is a blank node:

4. both s and o are blank nodes:
Clearly for the ﬁrst case we have |[(s, p, o)]|I+σ = |[(s, p, o)]|I = true, which

is exactly what we have to prove.

For the rest of the cases the proof is quite similar so we will only prove this
for case 2:
|[(s, p, o)]|I+σ = true ⇔ (σ(s),|[o]|I) ∈ Γ(|[p]|I) ⇔ (|[Σ(x)]|I+A0,|[o]|I) ∈
Γ(|[p]|I)
if b = Σ(x) ∈ BK we have to prove: (A0(b),|[o]|I) ∈ Γ(|[p]|I) which is true
because (b,|[o]|IH ) ∈ ΓIH (p) in the Herbrand model.
In fact this assertion
means that the pair formed by the interpretation of the blank node b and the
interpretation of o belongs to the set which ΓIH associates to the interpretation
of p and the only way for this to be true is that this is true in every model of K
because IH only satisﬁes the conditions that every interpretation must satisfy
(and identifying every interpretation uniquely to the node it represents).
On the other hand if y = Σ(x) /∈ BK we have by doing a similar reasoning
that (|[y]|I ,|[o]|I) ∈ Γ(|[p]|I).
Finally we have that for every triple (s, p, o) ∈ E the evaluation |[(s, p, o)]|I+σ =
true then |[E]|I+σ = true which concludes the demonstration.
Proof (of the theorem). Assume that K |= E, where BK ∩ BE = ∅ and
such that neither K nor E are XML clash, then by the previous lemma we know
that there exists Σ such that Σ : K ‘ E. For this proof we will extend this Σ
function in order to have at least one blank node associated to each literal.

We will now show how to construct a proof tree. To do so we will ﬁrst apply
the alloc rule with Σ and then the break rule in order to construct a proof
tree from clauses of the form Σ : K ‘ (s, p, o) where (s, p, o) ∈ E. Then, by
induction we will show how to construct the proof tree corresponding to each
of these clauses.
We know that |[K]|IH +id = true so for each triple t in E we have |[t]|IH +Σ =
true. By construction of the Herbrand model we also know that for each one of
these triples there exists i ∈ N such that |[t]|Ii+Σ = true. Now, we will prove
that if there exists i ∈ N such that |[(s, p, o)]|Ii+Σ = true holds then we can
construct a ﬁnite proof tree for the following clause: Σ : K ‘ (s, p, o).
From now on s0 = Σ(s) if s is a blank node or s0 = s otherwise and o0 = Σ(o)
if o is a blank node or o0 = o otherwise
If |[(s, p, o)]|I0+Σ = true then (|[s0]|I0+id,|[o0]|I0+id) ∈ Γ0(|[p]|I0) This can

only be possible in one of the following cases:

24

• either (s0, p, o0) ∈ K:

Then we apply the ins1 and ins2 rules if necessary and ﬁnally the init
rule to ﬁnish the proof tree.

• or p =rdf:type and:

– s0 is a plain literal and o0 =rdf:Literal:

Then we apply the ins1 rule if necessary and then we ﬁnish the proof
tree by the rdf s1 rule.

– or s0 is a well typed XML literal and o0 =rdf:XMLLit:

Then again we apply the ins1 rule if necessary and then we ﬁnish
the proof tree by the rdf2 rule.

– or o0 =rdf:Prop and there exist u, v such that (u, s0, v) ∈ K:

Then we apply the ins1 and ins2 rule if necessary, then the rdf1
rule to get Σ : K ‘ (u, s0, v) (note that s0 must be an uri because
(u, s0, v) ∈ K) and the proof tree ﬁnishes by the init rule.

– or o0 =rdfs:Res and s0 ∈ BK ∪ VK ∪ rdf sV ∪ rdf V :

Then we apply the ins1 rule if necessary, if s0 isn’t a literal we apply 
the ins2 rule and then the rdf s4 rule to ﬁnish the proof three.
Otherwise we apply the rdf s4l rule.

We have just seen the base case, now by induction we will see that given
i ∈ N if ∀j < i,|[(s, p, o)]|Ij +Σ = true ⇒ there is a ﬁnite proof tree whose root
is Σ : K ‘ (s, p, o) then so this holds for i.
In other words (|[s0]|,|[o0]|) ∈
Γi(|[p]|) (note that since there is no possible confusion we have omitted the
index). Again there are several diﬀerent cases for this to occur:

Let’s assume that |[(s, p, o)]|Ii+Σ = true.

• either p =rdfs:sp and:

– either s0 = o0 and (|[s0]|,|[rdf:Prop]|) ∈ Γi−1(|[rdf:type]|):

The idea is to get Σ : K ‘ (s0,rdfs:sp, s0), but this is not always
possible since s0 might be a literal. So we will see in detail each one
of the possible cases:
In the case s0 is not a literal or s and o are not blank nodes we
will have (after eventually applying the ins1 or ins2 rules) Σ : K ‘
(s0,rdfs:sp, s0). Now, by applying the rdf s6 rule we get Σ : K ‘
(s0,rdf:type,rdf:Prop).
On the other hand, if s0 is the literal l:
if o is a blank node we
apply the ins1 rule to get Σ : K ‘ (s,rdfs:sp, l) otherwise we do
have already this. Note that s must be a blank node because there
are no literals in the subject. We can now apply the gl rule to get
Σ : K ‘ (s,rdfs:sp, s). And here again, by applying the rdf s6 rule
we get Σ : K ‘ (s,rdf:type,rdf:Prop).
In both cases we can ﬁnish the demonstration with the proof tree for
Σ : K ‘ (x,rdf:type,rdf:Prop), where x is either s or s0 depending

25

on the case. This tree is ﬁnite because |[(x,rdf:type,rdf:Prop)]|Ii−1+Σ =
true.

– or there exists z such that (|[s0]|,|[z]|) ∈ Γi−1(|[rdfs:sp]|) and (|[z]|,|[o0]|) ∈

Γi−1(|[rdfs:sp]|):
We apply the rdf s5 rule to get Σ : K ‘ (s,rdfs:sp, z), Σ : K ‘
(z,rdfs:sp, o) then we ﬁnish with the proof tree of each one of the
branches. Note that we can always choose z as to be either a blank
node or an uri because if it was a literal l, we know that there is at
least one blank node which satisﬁes Σ( b) = l.

– or o0 =rdf:Member and (|[s0]|,|[rdfs:ContMemProp]|) ∈ Γi−1(|[rdf:type]|):

First we apply the ins1 rule to get Σ : K ‘ (s,rdfs:sp,rdfs:member)
(if o is a blank node) and then the rdf s12 rule to get Σ : K ‘
(s,rdf:type,rdfs:ContMemProp) and we ﬁnish with the proof tree
for this clause.
• or p =rdfs:sc and:

– either o0 =rdfs:Res and (|[s0]|,|[rdfs:Class]|) ∈ Γi−1(|[rdf:type]|):
Again we ﬁrst apply the ins1 rule to get Σ : K ‘ (s,rdfs:sc,rdfs:Res)
(if o is a blank node) and then the rdf s8 rule to get Σ : K ‘
(s,rdf:type,rdfs:Class). And the proof ﬁnish with the proof tree
for this clause.

– or s0 = o0 and (|[s0]|,|[rdfs:Class]|) ∈ Γi−1(|[rdf:type]|):

The idea is to get Σ : K ‘ (s0,rdfs:sc, s0), but again this is not
always possible since s0 might be a literal. So as we did before:
In the case s0 is not a literal or s and o are not blank nodes we
will have (after eventually applying the ins1 or ins2 rules) Σ : K ‘
(s0,rdfs:sc, s0). Now, by applying the rdf s10 rule we get Σ : K ‘
(s0,rdf:type,rdfs:Class).
On the other hand, if s0 is the literal l:
if o is a blank node we
apply the ins1 rule to get Σ : K ‘ (s,rdfs:sc, l) otherwise we do
have already this. Note that s must be a blank node because there
are no literals in the subject. We can now apply the gl rule to get
Σ : K ‘ (s,rdfs:sc, s). And here again, by applying the rdf s10 rule
we get Σ : K ‘ (s,rdf:type,rdfs:Class).
In both cases we can ﬁnish the demonstration with the proof tree
for Σ : K ‘ (x,rdf:type,rdfs:Class), where x is either s or s0
depending on the case.

– or there exists z such that (|[s0]|,|[z]|) ∈ Γi−1(|[rdfs:sc]|)∧(|[z]|,|[o0]|) ∈

Γi−1(|[rdfs:sc]|):
We apply the rdf s11 rule to get Σ : K ‘ (s,rdfs:sc, z), Σ : K ‘
(z,rdfs:sc, o) then we ﬁnish with the proof tree of each one of the
branches. Note that we can always choose z as to be either a blank
node or an uri because if it was a literal l, we know that there is at
least one blank node which satisﬁes Σ( b) = l.

26

– or o0 =rdf:Literal and (|[s0]|,|[rdfs:Datatype]|) ∈ Γi−1(|[rdf:type]|):

First we apply the ins1 rule to get Σ : K ‘ (s,rdfs:sc,rdfs:Literal)
(if o is a blank node) and then the rdf s13 rule to get Σ : K ‘
(s,rdf:type,rdfs:Datatype) and we ﬁnish with the proof tree for
this clause.

• or p =rdf:type and:

– either there exist x, y such that (|[s0]|,|[y]|) ∈ Γi−1(|[x]|) and (|[x]|,|[o0]|) ∈

Γi−1(|[rdfs:domain]|):
We will consider two cases: either x is an uri or it’s a blank node.
In the ﬁrst case we have that |[(s, x, y)]|Ii−1+Σ = true, and then
|[(x,rdfs:sp, x)]|Ii+Σ = true which is already proved to have a proof
tree. Then we can apply the rdf s2 rule to get Σ : K ‘ (x,rdfs:domain, o), Σ :
K ‘ (s, x, y), Σ : K ‘ (x,rdfs:sp, x) and we ﬁnish by the proof tree
for each one of these branches.
On the second case we know that x is a blank node, so we must prove
that there exist at least one uri c which satisﬁes both (|[s0]|,|[y]|) ∈
Γi−1(|[c]|) and (|[x]|,|[c]|) ∈ Γi−1(|[rdfs:sp]|). We will do so by in-
duction:
if i = 2 then the only way to have (|[s0]|,|[y]|) ∈ Γ1(|[x]|) is that there
exists one such c.
Now if i > 2 we have two cases: either (|[s0]|,|[y]|) ∈ Γi−2(|[x]|) or
there exists c0 such that (|[s0]|,|[y]|) ∈ Γi−2(|[c0]|) and (|[c0]|,|[x]|) ∈
Γi−2(|[rdfs:sp]|). On the ﬁrst case we know by induction that there
exists one such c. For the second suppose that c0 isn’t an uri then we
can assume that it is a blank node. By hypothesis of induction we
know that there exists an uri c such that (|[s0]|,|[y]|) ∈ Γi−3(|[c]|) and
(|[c]|,|[c0]|) ∈ Γi−2(|[rdfs:sp]|). But then we have that (|[c]|,|[x]|) ∈
Γi−1(|[rdfs:sp]|) and so we have an uri which satisﬁes what we need.
Then we can apply the rdf s2 rule to get Σ : K ‘ (x,rdfs:domain, o), Σ :
K ‘ (s, c, y), Σ : K ‘ (c,rdfs:sp, x) and we ﬁnish by the proof tree
for each one of these branches.

– or there exist x, y such that (|[y]|,|[s0]|) ∈ Γi−1(|[x]|) and (|[x]|,|[o0]|) ∈

Γi−1(|[rdfs:range]|):
The proof is the same as in the previous case.

– or there exist x, y such that (|[s0]|,|[x]|) ∈ Γi−1(|[rdf:type]|) and
(|[x]|,|[o0]|) ∈ Γi−1(|[rdfs:sc]|):
We can apply the rdf s9 rule to get Σ : K ‘ (x,rdfs:sc, o), Σ : K ‘
(s,rdf:type, x) and ﬁnally the proof tree for each clause.

• or p is any uri and:

– either (|[s0]|,|[o0]|) ∈ Γi−1(p):

Then, by hypothesis of induction, we already have a proof tree.

27

– or there exists p0 such that (|[s0]|,|[o0]|) ∈ Γi−1(|[p0]|) and (|[p0]|,|[p]|) ∈

Γi−1(|[rdfs:sp]|):
We apply the rdf s7 rule to get Σ : K ‘ (s, p0, o), Σ : K ‘ (p0,rdfs:sp, p).
Now by induction we know that for each one of these branches there
is a proof tree which ﬁnish the demonstration in both cases. Note
that p0 can be chosen as to be an uri, (Why?).

We have shown how to construct a proof tree if we have |[E]|IH +Σ = true.
Otherwise, this is when |[E]|IH +Σ = f alse we know that K |= E is false because
the Herbrand model doesn’t satisfy E (see the construction of Σ in the previous
lemma), and since the rules are all valid we can’t construct a proof tree. This
ﬁnish the demonstration of the theorem.

6 RDF and First order logic

In this section we will try to show a parallel between RDF and First order logic.
We will do so by showing how to translate the an rdf graph into a ﬁrst order
logic formula, and we will try to expose some results on interpretations and
entailment. We will focus this discussion on rdfs graphs and on how to prove
rdfs entailment.

Since formulas in FOL are ﬁnite we will restrict this analysis to ﬁnite rdf

graphs.

The language over which we will write our formulas will be formed by an
inﬁnite set of constants, containing one symbol for each uri, literal and blank
node, a 3-ary predicate symbol st and two unary predicates Lit and XM LLit.

Deﬁnition 31 The translation ˜t of a triple t = (s, p, o) will be deﬁned as:
if o is a plain literal then: ˜t = st(s, p, o) ∧ Lit(o)
if o is a well typed literal then: ˜t = st(s, p, o) ∧ XM LLit(o)
otherwise: ˜t = st(s, p, o)
And given an rdf graph K, we will deﬁne the translation of K as:
˜K =

(cid:86)

˜t

t∈K∪Axioms

In order to provide this formulas with a semantic meaning we will consider

the following set of formulas which we will call rdf sA:

• ∀s,∀p,∀o, st(s, p, o) ⇒ st(p, type, prop)∧ st(s, type, res)∧ st(p, type, res)∧

st(o, type, res)

• ∀l, Lit(l) ⇔ st(l, type, literal)
• ∀l, XM LLit(l) ⇔ st(l, type, xmlliteral)
• ∀s,∀p,∀o,∀p0, st(s, p, o) ∧ st(p, sp, p0) ⇒ st(s, p0, o)
• ∀s, st(s, type, prop) ⇒ st(s, sp, s)

28

• ∀s,∀x,∀o, st(s, sp, x) ∧ st(x, sp, o) ⇒ st(s, sp, o)
• ∀s, st(s, type, ContM emP ) ⇒ st(s, sp, member)
• ∀s, st(s, type, Class) ⇒ st(s, sc, s) ∧ st(s, sc, res)
• ∀s,∀x,∀o, st(s, sc, x) ∧ st(x, sc, o) ⇒ st(s, sc, o)
• ∀s, st(a, type, Datatype) ⇒ st(a, sc, literal)
• ∀u,∀v,∀x,∀y, st(x, domain, y) ∧ st(u, x, v) ⇒ st(u, type, y)
• ∀u,∀v,∀x,∀y, st(x, range, y) ∧ st(u, x, v) ⇒ st(v, type, y)

Instead of considering only the translation of an rdf graph K we will consider
the theory of the set formed by this formula ˜K and rdf sA. Note that there are
no restrictions in the theory as to prevent a blank node to be in the position
of a predicate, nor to a literal to be in the position of a subject, so there are
in this theory many formulas which can’t be translated back into rdfs graphs,
however we will see that if a translation of another graph G is a formula of this
theory, then K |=rdf s G.

We will announce without giving a proof the following proposition:

Proposition 7 (translation) Given two rdfs graphs K and E such that neither 
of them is an XML clash, K |=rdf s E ⇔ ∃σ such that ˜K |=1st ˜E[σ(x)/x],
where σ is a map from the set of blank nodes of E to blank nodes, uris and
literals, and ˜E[σ(x)/x] is the translation of E in which we have replaced all the
occurrences of x for σ(x), for all x ∈ dom(σ).

7 Conclusion and proposed corrections

We have presented the formal aspects of syntax and semantics of RDF following
as much as possible the speciﬁcations of this language. However, there are
some points that might be reviewed. Some concerning the deﬁnitions, other
concerning the rules of entailment.

1. First of all we would like to point out that the deﬁnition of instance of
an rdf graph given in the speciﬁcations is quite ambiguous. The proposed
deﬁnition for an instance is:
“Suppose that M is a mapping from a set of blank nodes to some set of
literals, blank nodes and URI references; then any graph obtained from a
graph G by replacing some or all of the blank nodes N in G by M(N) is
an instance of G”.
Note that G2 is an instance of G2 depending on the map which is being
considered. For example:
If M is the map deﬁned by M( b1) = x and M(b2) = y ,G1 and G2 deﬁned
as:
G1 = {(x, u, b1), ( b2, v, x)}

29

G2 = {(x, u, x), (y, v, x)}
then G2 is an instance of G1. Now, if M is deﬁned as M( b2) = x and
M(b1) = y then, is G2 an instance of G1?
Moreover, in the ﬁrst example, there is no guarantee that G2 was ”ob-
tained” by replacing the blank nodes of G1.
Clearly this is not a serious problem, but we think that this concept should
be well deﬁned.

2. The concept of equivalence deﬁned in the speciﬁcations is the following:
“Two RDF graphs G and G0 are equivalent if there is a bijection M
between the sets of nodes of the two graphs, such that:

• M maps blank nodes to blank nodes.
• M(lit) = lit for all RDF literals lit which are nodes of G.
• M(uri) = uri for all RDF URI references uri which are nodes of G.
• The triple (s, p, o) is in G if and only if the triple (M(s), p, M(o)) is

in G0.”

We think that a more suitable world for that is ”isomorphism”, and ”equiv-
alence” should be reserved for semantic equivalence only, this is when given
two graphs, each one entails the other.
Some other notions which may be useful and frequently used would be
formalized, such as maps of rdf graphs, map consistent with a graph,
morphisms, or nodes of a graph (in order to extend the vocabulary to the
whole set of nodes occurring on a graph).

3. The deﬁnition of well/ill typed literals is not correct unless a datatype
map is deﬁned (see comment on section 3.4). The only deﬁnition which
could be proposed without a previous deﬁnition of a datatype map is
the well/ill typed XML literal. However the XML literal datatype is not
completely deﬁned in the speciﬁcations, its lexical-to-value mapping is not
precised. The only thing it is said about it is that it is a bijective map. We
think that the scope of the possible consequences this may have should be
treated more carefully, in fact, depending on the lexical-to-value map we
are considering, a graph can be either true or false in a given interpretation.

4. When deﬁning entailment among graphs, the vocabulary should be quantiﬁed.
 In fact, since one should speak of an interpretation of a vocabulary
V , talking about every interpretation is meaningless unless we specify of
which vocabulary. Entailment can then be deﬁned either as:

• G |= E ⇔ ∀V vocabulary,∀I interpretation of V, (I |= G ⇒ I |= E)

or:

• G |= E ⇔ ∀I interpretation of VG, (I |= G ⇒ I |= E), where VG is

the vocabulary of G.
Note that both deﬁnitions are equivalent.

30

5. Finally, and most important of all, we have noticed that the rdfs entailment 
lemma is not true. In fact if we consider the following graph:
G = {(a,rdfs:sp, b), ( b,rdfs:range, c), (x, a, y)}
where b is a blank node and the rest are all URIs, we can see that G entails 
the triple (y,rdf:type, c). However there are no rules which permit
to deduce this triple.
When looking at the demonstration we can see that the deﬁnition of the
rdfs Herbrand interpretation is far from being complete. Note the follow-
ing:
If x is in IPRH then IEXTRH(x) = {¡s,o¿: D contains the triple sur(s) x
sur(o) . }
The semantic conditions would force that:
IEXTRH(x) = {¡s,o¿: D contains the triple sur(s) x sur(o) or there exists
y such that IEXTRH(y) contains ¡s,o¿ }
This semantic condition is supposed to be guaranteed by applying rule
rdf s7, but it can only be applied if the resulting triple is well formed, this
is, its predicate cannot be a blank node.
We have proposed a set of rules which corrects this problem by changing
rules rdf s2 and rdf s3. These rules also formalize the notion of blank node
”allocated” to x.

References

[URI]

http://www.isi.edu/in-notes/rfc2396.txt

[RDF-Concepts] http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/

[RDF-Semantics] http://www.w3.org/TR/2004/REC-rdf-mt-20040210/

[XML-Schema2] http://www.w3.org/TR/xmlschema-2/

[RFC-3066]

http://www.isi.edu/in-notes/rfc3066.txt

31

