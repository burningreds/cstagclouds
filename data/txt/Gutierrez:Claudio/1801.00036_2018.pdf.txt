7
1
0
2
 
c
e
D
9
2

 

 
 
]

B
D
.
s
c
[
 
 

1
v
6
3
0
0
0

.

1
0
8
1
:
v
i
X
r
a

An introduction to Graph Data Management∗

Renzo Angles1,3 and Claudio Gutierrez2,3

1Dept. of Computer Science, Universidad de Talca, Chile

(rangles@utalca.cl)

2Dept. of Computer Science, Universidad de Chile, Chile

(cgutierr@dcc.uchile.cl)

3Center for Semantic Web Research (http://ciws.cl/)

Abstract

A graph database is a database where the data structures for the
schema and/or instances are modeled as a (labeled)(directed) graph
or generalizations of it, and where querying is expressed by graphoriented 
operations and type constructors. In this article we present
the basic notions of graph databases, give an historical overview of its
main development, and study the main current systems that implement
them.

1

Introduction

It has been long recognized that graphs are a natural way to represent information 
and knowledge. In fact, the notion of “graph database” has a long
development, at least since the 1980’s. But it is only recently that several
technological developments have made it possible to make this abstract idea
a reality. Powerful hardware to store and process graphs, powerful sensors
to record directly the information, powerful machines that allow to analyze
and visualize graphs, among other factors, have given rise to the current
ﬂourishing in the area of graph data management.

There are two broad and interrelated topics in this area that from our
perspective deserve to be treated separately today. One is the area of graph
database models, which comprises general principles that ideally should
∗Work funded by the Millennium Nucleus Center for Semantic Web Research under

Grant NC120004.

1

guide the design of systems. The second is graph database systems themselves,
 which are system that deal with graph data processing, sometimes
addressing directly demands of users, thus emphasizing factors such as eﬃciency,
 usability and direct solutions to urgent data management problems.

Graph database models. The fundamental abstraction behind a database
system is its database model. In the most general sense, a database model
(or just data model) is a conceptual tool used to model representations of
real world entities and the relationships among them. As is well known, a
data model can be characterized by three basic components, namely data
structures, query and transformation language, and integrity constraints.
Following this deﬁnition, a graph database model is a model where data
structures for the schema and/or instances are modeled as graphs (or generalizations 
of them), where the data manipulation is expressed by graphoriented 
operations (i.e. a graph query language), and appropriate integrity
constraints can be deﬁned over the graph structure

The main characteristic of a graph database is that the data are conceptually 
modeled and presented to the user as a graph, that is, the data structures 
(data and/or schema) are represented by graphs, or by data structures
generalizing the notion of graph (e.g. hypergraphs or hypernodes). One of
the main features of a graph structure is the simplicity to model unstructured 
data. Therefore, in graph models the separation between schema and
data (instances) is less marked than in the classical relational model.

Regarding data manipulation and querying, it is is expressed by graph
transformations, or by operations whose main primitives are based on graph
features like paths, neighborhoods, subgraphs, graph patterns, connectivity,
and graph statistics (diameter, centrality, etc.). Some graph models deﬁne
a ﬂexible collection of type constructors and operations, which are used to
create and access the graph data structures. Another approach is to express
all queries using a few powerful graph manipulation primitives. Usually the
query language is what gives a database model its particular ﬂavor. In fact,
the diﬀerences among graph data structures are usually minors as compared
to diﬀerences among graph query languages.

Finally, integrity constraints enforce data consistency. These constraints
can be grouped in schema-instance consistency, identity and referential integrity,
 and functional and inclusion dependencies. Examples of these are
labels with unique names, typing constraints on nodes functional dependencies,
 domain and range of properties, etc.

In this article we will concentrate in the data structure and language

2

facets of graph database models.

Graph Data Management Systems There are two categories of graph
data management systems: graph databases and graph processing frameworks.
 These systems provide two perspectives for storing and querying
graph data, each one with their own goals. The former are systems specifically 
designed for managing graph-like data following the basic principles
of database systems, i.e. persistent data storage, physical/logical data independence,
 data integrity and consistency. The latter are frameworks for
batch processing and analysis of big graphs putting emphasis in the use of
multiple machines to improve the performance

Contents and Organization of this article. This article presents an
overview of the basic notions, the historical evolution and the main current
developments of this area. There are three main topics, distributed by sections.
 First, an overview of the ﬁeld and its development, which we hope
can be of help to look for ideas and past experiences. Second, a review of
the main graph database models in order to give a perspective on actual
developments. Third, a similar review of graph database query languages.
Finally, we present current graph data management systems in a comparative 
manner.

2 Motivation and Overview of the Field

In this section we present motivations for graph data management and
brieﬂy review the developments of it. There is an emphasis on models in
order to give a certain abstraction level and unity of concepts that sometimes 
get lost in the wide diversity syntaxes and implementation solutions
that exist today. This section follows closely our review [42].

2.1 Why graph database models?

The ﬁrst question one should answer is why to choose a graph data model
instead of a relational, object-oriented, semi-structured, or other type of data
model. The one-sentence answer is: Graph models are designed to manage
data in areas where the main concern has to do with the interconnectivity
or topology of that data. In these applications, the atomic data and the
relations amongst the units of data have the same level of importance.

Among the main advantages that graph data models oﬀer over other

types of models, we can mention:

3

• Graphs has been long ago recognized as one of the most simple, natural 
and intuitive knowledge representation systems. This simplicity
overcomes the limitations of the lineal format of classical writing systems.


• Graph data structures allow for a natural modeling when data has
graph structure. Graphs have the advantage of being able to keep
all the information about an entity in a single node and show related
information by arcs connected to it. Graph objects (like paths, neigh-
borhoods) may have ﬁrst order citizenship.

• Queries can address direct and explicitly this graph structure. Associated 
with graphs are speciﬁc graph operations in the query language
algebra, such as ﬁnding shortest paths, determining certain subgraphs,
and so forth. Explicit graphs and graph operations allow users to express 
a query at a high level of abstraction. In summary, Graph models 
realize for graph data the separation of concerns between modeling
(the logic level) and implementation (physical level).

• Implementation-wise, graph databases may provide special graph storage 
structures, and take advantage of eﬃcient graph algorithms available 
for implementing speciﬁc graph operations over the data.

2.2 Comparison with classical models

As is well known, there are manifold approaches to model information and
knowledge, depending on application areas and user needs. We will brieﬂy
review the most inﬂuential of those models (relational, semantic, objectoriented,
 semistructured) and compare them to graph data models.

The Relational data model [57] was introduced by Codd and is based on
the simple notion of relation, which together with its associated algebra and
logic, made the relational model a primary model for database research. In
particular, its standard query and transformation language, SQL, became a
paradigmatic language for querying. It popularized the concept of abstraction 
levels by introducing a separation between the physical and logical levels.
 Gradually the focus shifted to modeling data as seen by applications and
users (that is, tables). The diﬀerences between graph data models and the
relational data model are manifold. The relational model is geared towards
simple record-type data, where the data structure is known in advance (airline 
reservations, accounting, inventories, etc.). The schema is ﬁxed, which

4

makes it diﬃcult to extend these databases. It is not easy to integrate different 
schemas, nor is it automatized. The table-oriented abstraction is not
suitable to naturally explore the underlying graph of relationships among
the data, such as paths, neighborhoods, patterns.

Semantic data models [122] focus on the incorporation of richer and more
expressive semantics into the database, from a user’s viewpoint. Database
designers can represent objects and their relations in a natural and clear
manner (similar to the way users view an application) by using high-level
abstraction concepts such as aggregation, classiﬁcation and instantiation,
suband 
super-classing, attribute inheritance and hierarchies. A well-known
and successful case is the entity-relationship model [54], which has become
a basis for the early stages of database design. Semantic data models are
relevant to graph data model research because the semantic data models
reason about the graph-like structure generated by the relationships between
the modeled entities.

Object-oriented (O-O) data models [95] are designed to address the weaknesses 
of the relational model in data intensive domains involving complex
data objects and complex object interactions, such as CAD/CAM software,
computer graphics and information retrieval. According to the O-O programming 
paradigm on which these models are based, they represent data
as a collection of objects that are organized into classes, and have complex
values and methods. O-O data models are related to graph data models
in their explicit or implicit use of graph structures in deﬁnitions. Nevertheless,
 there are important diﬀerences with respect to the approach for
modeling how to model the world. O-O data models view the world as a
set of complex objects having certain state (data), where interaction is via
method passing. On the other hand, graph data models view the world as a
network of relations, emphasizing data interconnection, and the properties
of these relations. O-O data models focus on object dynamics, their values 
and methods. Graph data models focus instead on the interconnection,
while maintaining the structural and semantic complexity of the data.

Semistructured data models [50, 33] were motivated by the increased
existence of semistructured data (also called unstructured data), data exchange,
 and data browsing mainly on the Web. In semistructured data, the
structure is irregular, implicit and partial; the schema does not restrict the
data, it only describes it, a feature that allows extensible data exchanges;
the schema is large and constantly evolving; the data is self-describing, as
it contains schema information. Representative semistructured models are
OEM [120] and Lorel [34]. Many of these ideas can be seen in current semistructured 
languages like XML or JSON. Generally, semistructured data is

5

represented using a tree-like structure. However, cycles between data nodes
are possible, which leads to graph-like structures like in graph data models.
Some authors characterize semistructured data as rooted directed connected
graphs.

2.3 Historical overview

The ideas of graph databases can be dated at least to the nineties, where
much of the theory developed. Probably due to the lack of hardware support
to manage big graphs, this line of research declined for a while until a few
years ago, when processing graphs became common and a second wave of
research was initiated.

The ﬁrst wave.
In an early approach, facing the failure of contemporary
systems to take into account the semantics of a database, a semantic network 
to store data about the database was proposed by Roussopoulos and
Mylopoulos [130] . An implicit structure of graphs for the data itself was
presented in the Functional Data Model [136], whose goal was to provide a
“conceptually natural” database interface. A diﬀerent approach proposed
the Logical Data Model (LDM) [99], where an explicit graph data model intended 
to generalize the relational, hierarchical and network models. Later,
Kunii [98] proposed a graph data model for representing complex structures
of knowledge called G-Base.

In the late eighties an object-oriented data model based on a graph structure,
 called O2, was introduced by L´ecluse et al [101]. Along the same lines,
GOOD [80] is an inﬂuential graph-oriented object model, intended to be a
theoretical basis for a system in which manipulation as well as representation
are transparently graph-based. Among the subsequent developments based
on GOOD are: GMOD [38] that proposes a number of concepts for graphoriented 
database user interfaces; Gram [37] which is an explicit graph data
model for hypertext data; PaMaL [75] which extends GOOD with explicit
representation of tuples and sets; GOAL [87] that introduces the notion
of association nodes; G-Log [121] which proposed a declarative query language 
for graphs; and GDM [86] that incorporates representation of n-ary
symmetric relationships.

There were proposals that used generalization of graphs with data modeling 
purposes. The Hypermodel [101] (which we will develop in more de-
tail) was a model based on nested graphs on which subsequent work was
developed [123, 102]. The same idea was used for modeling multi-scaled
networks [110] and genome data [77].

6

Another generalization of graphs, hypergraphs, gave rise to another family 
of models. GROOVY [105] is an object-oriented data model based on
hypergraphs. This generalization was used in other contexts: query and
visualization in the Hy+ system [59]; modeling of data instances and access
to them [141]; representation of user state and browsing [139];

There are several other proposals that deal with graph data models.
G¨uting proposed GraphDB [125] intended for modeling and querying graphs
in object-oriented databases and motivated by managing information in
transport networks. Database Graph Views [79] proposed an abstraction
mechanism to deﬁne and manipulate graphs stored in either relational objectoriented 
or ﬁle systems. The project GRAS [94] uses attributed graphs for
modeling complex information from software engineering projects. The well
known OEM [120] model aims at providing integrated access to heterogeneous 
information sources, focusing on information exchange.

Another important line of development has to do with data representation 
models and the World Wide Web. Among them are data exchange
models like XML [47], metadata representation models like RDF [96] and
ontology representation models like OWL [114].

The second wave. We are witnessing the second impulse of development
of graph data management which is focused on one hand, in practical systems,
 and on the other, in theoretical analyses particularly of graph query
languages. We will review the former in Section 5 concentrating in database
systems and will leave the latter out of this article. The reader interested
in graph query languages can review article “Foundations of Modern Query
Languages for Graph Databases”[40].

3 Graph Database Models

All graph data models have as their formal foundation variations on the basic 
mathematical deﬁnition of a graph, e.g., directed or undirected graphs,
labeled or unlabeled edges and nodes, properties on nodes and edges, hypergraphs,
 hypernodes.

The most simple model is a plain labeled graph, ie. a graph with nodes
and edges as everyone knows it. Although highly easy to learn, it has the
drawback that it is diﬃcult to modularize the information it represents. The
notions of hypernodes and hypergraphs address this problem. Hypergraphs,
by enhancing the notion of simple edge, allow the representation of multiple
complex relations. On the other hand, hypernodes modularize the notion

7

Figure 1: Example of a genealogy expressed in the relational model (i.e. as
tables on the left) and a diagram of its scheme on the right.

of node, by allowing nesting graphs inside nodes. As drawbacks, both models 
use complex data structures which make it less intuitive their use and
implementation.

Regarding simplicity, one of the most popularized models is the semistructured 
model, which use the most simple version of a graph, namely a tree,
the most common and intuitive way or organizing our data (e.g. directories)
Finally, the most common models are slightly enhanced version of the plain
graphs. One of them, the RDF model, gives a light typing to nodes, and
considers edges as nodes, giving uniformity to the information objects in the
model. The other, the property graph model, allows to adds properties to
edges and nodes.

Next, we will present these models and show a paradigmatic example of
each. We will use the genealogy toy example modeled as tables and a simple
schema in Figure 1.

3.1 The basics: Labeled graphs

The most basic data structure for graph database models is a directed graph
with nodes and edges labeled by some vocabulary. A good example is Gram
[37], a graph data model motivated by hypertext querying.

A schema in Gram is a directed labeled multigraph, where each node
is labeled with a symbol called a type, which has associated a domain of
values.
In the same way, each edge has assigned a label representing a
relation between types (see example in Figure 2). A feature of Gram is the
use of regular expressions for explicit deﬁnition of paths called walks. An
alternating sequence of nodes and edges represent a walk, which combined
with other walks conforms other special objects called hyperwalks.

For querying the model (particularly path-like queries), an algebraic language 
based on regular expressions is proposed. For this purpose a hyper8


NAMELASTNAMEAnaJuliaJamesDavidMaryGeorgeDevilleDevilleDevilleJonesStoneJonesPERSONPARENTGeorgeAnaJuliaJamesJamesMaryMaryJuliaJuliaDavidDavidJuliaJulia JonesAna StoneGeorge JonesparentparentparentparentparentparentMary DevilleDavid DevilleJames DevilleFigure 2: Gram. At the schema level we use generalized names for deﬁnition
of entities and relations. At the instance level, we create instance labels (e.g.
PERSON 1) to represent entities, and use the edges (deﬁned in the schema)
to express relations between data and entities.

walk algebra is deﬁned, which presents unary operations (projection, selection,
 renaming) and binary operations (join, concatenation, set operations),
all closed under the set of hyperwalks.

3.2 Complex relations: The Hypergraph model

The notion of hypergraph is a generalization of graphs where the notion of
edge is extended to hyperedge, which relates an arbitrary set of nodes [45].
Hypergraphs allow the deﬁnition of complex objects (using undirected hy-
peredges), functional dependencies (using directed hyperedges), object-ID
and (multiple) structural inheritance.

A good representative case is GROOVY (Graphically Represented ObjectOriented 
data model with Values [105]), an object-oriented data model which
is formalized using hypergraphs. An example of hypergraph schema and instance 
is presented in Figure 3.

The model deﬁnes a set of structures for an object data model: value
schemas, objects over value schemas, value functional dependencies, object
schemas, objects over object schemas and class schemas. The model shows
that these structures can be deﬁned in terms of hypergraphs.

Groovy also includes a hypergraph manipulation language (HML) for
querying and updating hypergraphs. It has two operators for querying hypergraphs 
by identiﬁer or by value, and eight operators for manipulation
(insertion and deletion) of hypergraphs and hyperedges.

9

SchemaInstancePERSON_4PERSON_5PERSON_6JonesGeorgePERSON_3JuliaPERSON_1PERSON_2AnaStonenamelastnamelastnamelastnamelastnameparentparentparentJamesDevilleDavidMarynamenamelastnamelastnamePERSONparentNAMELASTNAMEnamelastnamenamenameparentparentnameparentFigure 3: GROOVY. At the schema level (left), we model an object
PERSON as an hypergraph that relates the attributes NAME, LASTNAME 
and PARENTS. Note the value functional dependency (VDF)
NAME,LASTNAME → PARENTS logically represented by the directed
hyperedge ({NAME,LASTNAME} {PARENTS}). This VFD asserts that
NAME and LASTNAME uniquely determine the set of PARENTS.

3.3 Nested graphs: The Hypernode model

A hypernode is a directed graph whose nodes can themselves be graphs
(or hypernodes), allowing nesting of graphs. Hypernodes can be used to
represent simple (ﬂat) and complex objects (hierarchical, composite, and
cyclic) as well as mappings and records. A key feature is its inherent ability
to encapsulate information.

The hypernode model which we will use as example was introduced by
Levene and Poulovassilis [104]. They deﬁned the model and a declarative
logic-based language structured as a sequence of instructions (hypernode
programs), used for querying and updating hypernodes. A more elaborated
version [123] includes the notion of schema and type checking, introduced
via the idea of types (primitive and complex), that are also represented
by nested graphs (See an example in Figure 4).
It also includes a rulebased 
query language called Hyperlog, which can support both querying and
browsing with derivations as well as database updates, and is intractable
in the general case. A third version of the model [102] discusses a set of
constraints (entity, referential and semantic) over hypernode databases. In
addition it presents another query and update language called HNQL, which
use compounded statements to produce HNQL programs.

10

AnaPERSONNAMELASTNAMEPARENTSCHILD−PARENTPERSON2PARENTSLASTNAMENAMEJamesDevillePERSON4PARENTSLASTNAMENAMEDevilleMaryPERSON6PARENTSVAL(3)StoneSchemaCHILD−PARENTInstanceNAMELASTNAMEGeorgePARENTS1PERSONJonesNAMELASTNAMEVAL(2)VAL(1)PARENTS3PERSONJonesJuliaNAMELASTNAMEVAL(4)VAL(3)PARENTS5PERSONDavidDevilleNAMELASTNAMEVAL(4)Figure 4: Hypernode Model. The schema (left) deﬁnes a person as a complex
object with the properties name and lastname of type string, and parent of
type person (recursively deﬁned). The instance (on the right) shows the
relations in the genealogy among diﬀerent instances of person.

Summarizing, the main features of the Hypernode model are: a nested
graph structure which is simple and formal; the ability to model arbitrary
complex objects in a straightforward manner; underlying data structure of
an object-oriented data model; enhancement of the usability of a complex
objects database system via a graph-based user interface.

3.4 Trees: The Semistructured model (JSON, OEM, XML)

The semistructured model was designed to describe data together with its
schema in one place, also called “self-describing” data. Technically they are
trees, the most simple version of a graph, but could describe, via references,
general graphs.

The semistructured model was designed to overcome the limitation of
both, structured data (ﬁxed schema and format, precise rules) and unstructured 
data (loose schema, no format, little predictability). The early motivations 
were the modeling of documents (whose structure can be viewed as
trees), data on the Web and data integration at Web scale [50, 33].

Among its advantages are the simple way to integrate new data, to model
incomplete data, and the ﬂexibility to query it without prior knowledge
of schema. The drawbacks are mainly in the area of optimization, which
becomes much harder as the structure of the data is not necessarily known
in advance.

An early proposal in this direction was the data model OEM [74, 120]
which proposed an extremely simple and elegant model of objects with identiﬁers 
and “links” to other objects , with a simple syntax (see Figure 5) which

11

PERSONNameLastnameParentJuliaJonesPERSON_3ParentNameLastnameParentJamesDevillePERSON_4StringNameLastnameParentMaryDevillePERSON_6LastnameNameLastnameParentDavidDevillePERSON_5NameNameLastnameParentGeorgeJonesPERSON_1InstanceNameLastnameParentAnaStonePERSON_2SchemaPERSONFigure 5: Object Exchange Model (OEM). Schema and instance are mixed.
The data is modeled beginning in a root node &pp, with children person
nodes, each of them identiﬁed by an Object-ID (e.g. &p2). These nodes have
children that contain data (name and lastname) or references to other nodes
(parent). Referencing permits to establish relations between distinct hierarchical 
levels. Note the tree structure obtained if one forgets the pointers to
OIDs, a characteristic of semistructured data.

today we can recognize in JSON.

The most popular and elaborated version of the semi-structured model
is the XML model.
It comprises a rich and ﬂexible data structure [?], a
suite of highly reﬁned and standardized query and transformation languages
(XPath, XQuery, XSLT)1 and several other features, that have much to
teach graph query language designers.

3.5 Uniform graphs: The RDF model

The Resource Description Framework (RDF) [96] is a recommendation of the
W3C designed originally to represent metadata. One of the main advantages
(features) of the RDF model is its ability to interconnect resources in an
extensible way using graph-like structure for data.

One of the main advantages of RDF is its dual nature. In fact, there
are two possible reading of the model. From a knowledge representation

1 XPath Language www.w3.org/TR/xpath/

XQuery Language www.w3.org/TR/xquery/
XSLT Transformations www.w3.org/TR/xslt20/

12

&pp&p4&p5&p6&p3OEM GraphpersonpersonpersonpersonpersonpersonparentparentparentOEM Syntax&p1&p2namenamenamenamenamelastnameparentparentparentperson : &p2 { name : "Ana" ,lastname : "Jones" }lastname : "Stone" }lastname : "Jones" ,person : &p3 { name : "Julia" ,parent : &p1 ,parent : &p2 }person : &p4 { name : "James" ,lastname : "Deville" }person : &p5 { name = "David",lastname : "Deville" ,parent : &p3 ,parent : &p4 }person : &p6 { name = "Mary" ,lastname : "Deville" ,parent : &p4 }  }parent : &p3 ,"George""Julia"{ person : &p1 { name : "George" ,"Deville""Mary""Ana""Stone"lastnamelastnamelastname"Jones""James""Deville"lastname"David""Deville"lastnamename"Jones"Figure 6: RDF data model. Note that schema and instance are mixed
together. The edges labeled type disconnect the instance from the schema.
The instance is built by the subgraphs obtained by instantiating the nodes of
the schema, and establishing the corresponding parent edges between these
subgraphs.

perspective, an atomic RDF expression is triple consisting of a subject (the
resource being described), a predicate (the property) and an object (the
property value). Each triple represents a logical statement of a relationship
between the subject and the object, and one could enhance this basic logic by
adding rules and ontologies over it (e.g. RDFS and OWL) A general RDF
expression is a set of such triples called an RDF Graph (see example in
Figure 6), which can be intuitively considered as a semantic network. From
the second perspective, the RDF model is the most general representation
of a graph, where edges are also considered nodes. In this sense, formally
is not a traditional graph [84]. This allows to self-references, reiﬁcation
(i.e. making statements over statements), and essentially be self-contained.
The drawback of all this niceties are the complexity that come with this
generalization, particularly for eﬃcient implementation.

SPARQL [124] is the standard query language for RDF. It is able to
express complex graph patterns by means of a collection of triple patterns
whose solutions can be combined and restricted by using several operators

13

Figure 7: Property graph data model. The main characteristic of this model
is the occurrence of properties in nodes and edges. Each property is represented 
as a pair property-name = “property-value”.

(i.e. AND, UNION, OPTIONAL, and FILTER). The latest version of the
language, SPARQL 1.1 [71], includes explicit operators to express negation of
graph patterns, arbitrary length path matching (i.e. reachability), aggregate
operators (e.g. COUNT), subqueries, and query federation.

3.6 Nodes, edges and properties: The Property graph model

A property graph is a directed, labelled, attributed multigraph. That is,
a graph where the edges are directed, both nodes and edges are labeled
and can have any number of properties (or attributes), and there can be
multiple edges between any two vertices [128]. Properties are key/value
pairs that represent metadata for nodes and edges. In practice, each vertex
of a property graph has an identiﬁer (unique within the graph) and zero
or more labels. Node labels could be associated to node typing in order to
provide schema-based restrictions. Additionally, each (directed) edge has a
unique identiﬁer and one or more labels. An example of property graph is
shown in Figure 7.

Property graphs are used extensively in computing as they are more
expressive2 than the simpliﬁed mathematical objects studied in theory. In
fact, the property graph model can express other types of graph models by
simply abandoning or adding particular bits and pieces [128].

There is no standard query language for property graphs although some
proposals are available. Blueprints [11] was one of the ﬁrst libraries created

2Note that the expressiveness of a model is deﬁned by ease of use, not by the limits of

what can be modeled.

14

for the property graph data model. Blueprints is analogous to the JDBC,
but for graph databases. Gremlin [7] is a functional graph query language
which allows to express complex graph traversals and mutation operations
over property graphs. Neo4j [21] provides Cypher [14], a declarative query
language for property graphs. The syntax of Cypher, very similar to SQL
via expressions match-where-return, allows to easily express graph patterns
and path queries.

4 Querying Graph Databases

Data manipulation and querying in graph data management is expressed by
graph operations or graph transformations whose main primitives are based
on graph features like neighborhoods, graph patterns and paths. Another
approach is to express all queries using a few powerful graph manipulation
primitives enclosed by a graph query language.

In this section we give a brief overview of the research on querying graph
databases. First, we present a broad classiﬁcation of queries studied in the
context of graph databases, including a description of their characteristics
(e.g. complexity and expressiveness). After that, we present a review of
graph query languages, including short descriptions of some proposals we
consider representative of the area.

4.1 Classiﬁcation of graph queries

In this section we present a broad classiﬁcation of queries that have been
largely studied in graph theory and can be considered essential for graph
databases. We grouped them in adjacency, pattern matching, reachability
and analytical queries.

To ﬁx notations, let us represent a graph database as a single labeled
directed multigraph. Speciﬁcally, a tuple G = (N, E, L, δ, λN , λE) where N
is a ﬁnite set of nodes, E is a ﬁnite set of edges, L is a ﬁnite set of labels,
δ : E → N 2 is the edge function that associates edges with pairs of nodes,
λN : N → L is the node labeling function, and λE : E → L is the edge
labeling function. An edge e = (n, n(cid:48)) ∈ E will be represented as a triple
(v, w, v(cid:48)) where v = λN (n), w = λE(e) and v(cid:48) = λN (n(cid:48)). Nodes and edges
will usually be referenced by using their labels. Additionally, a path ρ in G
is a sequence of edges (v0, w0, v1), (v1, w1, v2), . . . , (vm−1, wm−1, vm) where
v0 and vm are the source and target nodes of the path respectively. The
label of ρ is the sequence of labels w0, w1, . . . , wm−1.

15

4.1.1 Adjacency queries

The primary notion in this type of queries is node/edge adjacency. Two
nodes are adjacent (or neighbors) when there is an edge between them.
Similarly, two edges are adjacent when they share a common node. Examples 
of adjacency queries are: “return the neighbors of a node v” or “check
whether nodes v and v(cid:48) are adjacent”, In spite of their simplicity, to compute
eﬃciently adjacency queries could be a challenge for big sparse graphs [97].
The basic notion of adjacency can be extended to deﬁne more complex
“neighborhood queries”. For instance, the k-neighborhood [119] of a root
node v is the set of all nodes that are reachable from v via a path of k edges
(i.e. the length of the path is no more than k). Similarly, the k-hops [66] of
v returns all the nodes that are at a distance of k edges from v. Note that a
k-neighborhood query can be expressed as a composition of k-hops queries
1-hops ∪···∪ k-hops, but removing duplicates.

Several applications can beneﬁt from reachability queries, in particular
those where the notion of inﬂuence is an important concern. For instance,
in information retrieval adjacency queries are used for web ranking using
hubs and authorities [53]. In recommendation systems are used to obtain
users with similar interests [66]. In social networks can be used to validate
the well-known six-degrees-of-separation theory.

4.1.2 Pattern matching queries

The basic notion of graph pattern matching consists in to ﬁnd the set of
subgraphs of a database graph that “match” a given graph pattern. A basic
graph pattern is usually deﬁned as a small graph where some nodes and edges
can be labeled with variables. The purpose of the variables is to indicate
unknown data and more importantly, to deﬁne the output of the query (i.e.
variables will be “ﬁlled” with solution values). For instance, the expression
(John, f riend, ?y), (John, f riend, ?z), (?y, f riend, ?z) represents a graph
pattern where ?x and ?y are variables. The result or interpretation of this
graph pattern could be “the pairs of friends of John which are also friends”.
Graph pattern matching is typically deﬁned in terms of sub-graph isomorphism,
 i.e. to ﬁnd all subgraphs of a database G that are isomorphic
to a graph pattern P . Hence, pattern matching deals with two problems:
the graph isomorphism problem that has a unknown computational complexity,
 and the sub-graph isomorphism problem which is an NP-complete
problem [73].

Graph matching is easily identiﬁable in many application domains. For

16

instance, graph patterns are fundamental within the pattern recognition ﬁeld
[62]. In social network analysis is used to identify communities and social
positions [70]. In protein interaction networks, researchers are interested in
patterns that determine proteins with similar functions [138].

There are a number of variations on the basic notion of pattern matching:
• Graph patterns with structural extension or restrictions. A basic graph
pattern has been deﬁned as a simple structure containing nodes, edges
and variables, however this notion can be extended or restricted depending 
on the graph data model. For instance, if the database is a
property graph then a graph pattern should support conditions over
such properties.

• Complex graph patterns.

In some cases, a collection of basic graph
patterns can be combined via speciﬁc operators (e.g. union, optional
and diﬀerence) to conform complex graph patterns. The semantics of
these graph patterns can be deﬁned in terms of an algebra of graph
patterns.

• Semantic matching. It consists in to match graphs based on speciﬁc
interpretations (i.e. semantics) given to nodes and edges. Such interpretations 
can be deﬁned via semantic rules (e.g. an ontology).

• Inexact matching. In this case the graph pattern matching algorithm
returns a ranked list of the most similar matches (instead of the original
exact matching). These algorithms employ a cost function to measure
the similarity of the graphs and error correction techniques to deal
with noise data.

• Approximate matching. This variation concerns the use of algorithms
that ﬁnd approximate solutions to the pattern matching problem, i.e.
they oﬀer polynomial time complexity but are not guaranteed to ﬁnd
a solution. In case of exact matching the algorithm will return some
solutions, but not all matches. For inexact matching, a close solution
will be returned, but not the closest.

Very related to graph pattern matching is the area of graph mining [36].
This area includes the problems of frequent pattern mining, clustering and
classiﬁcation. For instance, the goal of frequent pattern mining is the discovery 
of common patterns, i.e. to ﬁnd subgraphs that occurs frequently in the
entire database graph. The problem of computing frequent subgraphs is particularly 
challenging and computationally intensive, as it needs to compute

17

graph and subgraph isomorphisms. The discovery of patterns can be useful
for many application domains, including ﬁnding strongly connected groups
in social networks and ﬁnding frequent molecular structures in biological
databases.

4.1.3 Reachability queries (connectivity)

One of the most characteristic problems in graph databases is to compute
reachability of information.
In general terms, the problem of reachability 
tests whether two given nodes are connected by a path. Reachability
queries have been intensively studied in traditional database models, in particular 
for querying relational and semi-structure databases. Yannakakis
[146] surveyed a set of path problems relevant to the database area including 
computing transitive closures, recursive queries and the complexity of
path searching.

In the context of graph databases, reachability queries are usually modeled 
as path or traversal problems characterized by allowing restrictions over
nodes and edges. Mendelzon and Wood [63] introduced the notion of Regular 
Path Query (RPQ) as a way of expressing reachability queries. The
basic structure of a regular path query is an expression (?x, τ, ?y) where ?x
and ?y are variables, and τ is a regular expression. The goal of this RPQ
is to ﬁnd all pairs of nodes (?x, ?y) connected by a path such that the concatenation 
of the labels along the path satisﬁes τ . Note that variables ?x
and ?y can be replaced by node labels (i.e. data values) in order to deﬁne
speciﬁc source and target nodes respectively. For instance, the path query
(John, f riend+, ?z) returns the people ?z that can be reached from “John”
by following “friend” edges.

The complex nature of path problems is such that their computations
often requires a search over a sizable data space. The complexity of regular 
path queries was initially studied in [115] in terms of computing simple
paths (i.e. paths with no repeated nodes). Speciﬁcally, the problem of ﬁnding 
all pairs of nodes connected by a simple path satisfying a given regular
expression was shown to be NP-complete in the size of the graph. Due to
the high computational complexity of RPQs under simple path semantics,
researchers proposed a semantics based on arbitrary paths. This semantics
leads to tractable combined complexity for RPQs and tractable data complexity 
for a family of expressive languages. See [44] for a complete review
about these issues.

Reachability queries are present in multiple application domains. For
instance, path queries are very useful: in semi-structured data, for querying

18

XML documents using XPath [35]; in social networks, to discover people
with common interests [70]; and in biological networks, to ﬁnd speciﬁc biochemical 
pathways between distance nodes [138].

Reachability queries are the basis for other real life graph queries. Maybe
the most important is the shortest-path distance (also called the geodesic
distance). For instance, in a road network it is fundamental to calculate the
minimum distance between two locations [150].

4.1.4 Analytical queries

The queries of this type do not consult the graph structure; instead they are
oriented to measure quantitatively and usually in aggregate form topological
features of the database graph. Analytical queries can be supported via
special operators that allow to summarize the query results, or by ad-hoc
functions hiding complex algorithms.

Summarization queries can be expressed in a query language by using the
so-called aggregate operators (e.g., average, count, maximum, etc.). These
operators can be used to calculate the order of the graph (i.e., the number of
vertices), the degree of a node (i.e., the number of neighbors of the node), the
minimum / maximum / average degree in the graph, the length of a path
(i.e., the number of edges in the path), the distance between nodes (i.e.,
the length of a shortest path between the nodes), among others “simple”
analytical queries.

Complex analytical queries are related to compute important algorithms
for graph analysis and mining (see [36] for a extensive review). Examples of
such graph algorithms are:

• Characteristic path length. It is the average shortest path length in
a network. It measures the average degree of separation between the
nodes.

• Connected components.

It is an algorithm for extracting groups of

vertices that can reach each other via graph edges.

• Community detection. This algorithm deals with the discovery of
groups whose constituent nodes form more relationships within the
group than with nodes outside the group.

• Clustering coeﬃcient. The clustering coeﬃcient of a node is the probability 
that the neighbors of the node are also connected to each other.
The average clustering coeﬃcient of the whole graph is the average of
the clustering coeﬃcients of all individual nodes.

19

• PageRank This algorithm, created in the context of web searching,
models the behavior of an idealized random Web surfer. The PageRank 
score of a webpage represents the probability that the random
Web surfer chooses to view the webpage. This algorithm can be an
eﬀective method to measure the relative importance of nodes in a data
graph.

Complex analytical queries are the speciality of graph processing frameworks 
due to their facilities for implementing and running complex algorithms 
over large graphs. More details about these queries can be found in
articles comparing graph processing frameworks (e.g. [78] and [149]).

4.2 A short review of graph query languages

In the literature of graph data management there is substantial work on
graph query languages (GQLs). A review of GQLs proposed during the ﬁrst
wave of graph databases was presented in [42]. Based on this, Wood [143]
studied several GQLs focusing on their expressive power and computational
complexity. A review and comparison of practical query languages provided
by graph databases (available at the time) was presented in [39]. Recently,
Barcelo [44] studied the problem of querying graph databases, in particular
the expressiveness and complexity of several navigational query languages.
To the best of our knowledge, the ﬁrst graph query language was proposed 
in 1987 by Cruz, Mendelzon and Wood (i.e. the language G). After
that, several theoretical GQLs have been proposed, in some cases accompanying 
the deﬁnition of a graph data model. It has been just in the last
ten years that practical GQLs are available thanks to the release of graph
database systems. Example of this is Cypher, the query language provided
by the Neo4j graph database.

Although a GQL is normally related to a graph database model, this
relation is no exclusive. For instance, several object-oriented data models
deﬁned graph-based languages to manipulate the objects in the database
(e.g. GraphDB [126] and G-Log[121]), or to represent database transformations 
(e.g. GOOD [80] and GUL [86]). A similar situation occurred
for semistructured data models when graph-oriented operations are used to
navigate the tree-based data (e.g. Lorel [34] and UnQL [51]). Additionally,
several graph-based query languages have been designed for speciﬁc applications 
domains, in particular those related to complex networks, for instance
social networks (e.g. SoQL [129]), biological networks (e.g. DNAQL [48]),
bibliographical networks (e.g. BiQL [68]), the Web (e.g. WebSQL [68]) and
the Semantic Web (e.g. SPARQL [83]).

20

Figure 8: Evolution of graph query languages: G [63], G+ [64], Graphlog
[61], HPQL [104], THQL [141], GRE [142], Gram [37], Hyperlog [123],
HNQL [103], PORL [72], SLQL [52], HQL [137], PRPQ [107], GraphQL
[85], SPARQL [124], RLV [132], Cypher [14], ECRPQ [43], PDQL [41], GXPath 
[106], SPARQL 1.1 [71] and RQ [127].

For the sake of space we will not present a complete review of graph query
languages. Instead we describe some of the languages we consider relevant
and useful to show the developments in the area. Moreover, we restrict
our review to “pure” GQLs, that is those languages speciﬁcally designed to
work with graph data models. Figure 8 presents this subset of languages in
chronological order.

As we mentioned before, Cruz et al. [63] proposed the query language
G. This language introduced the notion of graphical query as a set of query
graphs. A query graph (pattern) is a labeled directed multigraph in which
the node labels may be either variables or constants, and the edge labels
can be regular expressions combining variables and constants. The result
of a graphical query Q with respect to a graph database G is the union of
all query graphs of Q which match subgraphs of G. For instance, Figure
9 presents a example of graphical query containing two query graphs, Q1
and Q2. This query ﬁnds the ﬁrst and last cities visited in all round trips
from Toronto (“Tor”), in which the ﬁrst and last ﬂights are with Air Canada
(“AC”) and all other ﬂights (if any) are with the same airline. Note that the
last condition is expressed by the edge labeled with regular expression w+.
Thanks to the inclusion of regular expressions, G is able to express recursive
queries more general than transitive closure. However, the evaluation of
queries in G is of high computational complexity due to its semantics based
on simple paths.

G evolved into a more powerful language called G+ [64]. The notion
of graphical query proposed by G is extended in G+ to deﬁne a summary

21

Figure 9: Example of a graphical graph query expressed in language G [63].

graph that represent how to restructure the answer obtained by the query
graphs. Additionally, G+ allows to express aggregate functions over paths
and sets of paths (i.e. it allows to compute the size of the shortest path).

GraphLog [60] is a query language that extends G+ by adding negation
and unifying the concept of a query graph. A query is now a single graph
pattern containing one distinguished edge which corresponds to the restructured 
edge of the summary graph in G+. The eﬀect of a GraphLog query is
to ﬁnd all instances of the pattern that occur in the database graph and for
each one of them deﬁne a virtual link represented by the distinguished edge.
It was shown [61] that the expressive power of GraphLog is equivalent to
three well-known query classes: stratiﬁed linear Datalog programs, queries
computable in non-deterministic logarithmic space, and queries expressible
with a transitive closure operator plus ﬁrst-order logic. Based on this, the
GraphLog’s authors argued that the language is able to express “real life”
recursive queries.

Gram [37] is a query language based on walks3 and hyperwalks. Assuming 
that T is the union of node and edge types in the database graph, a walk
expression is a regular expression over T without alternation (union), whose
language contains only alternating sequences of node and edge types. A
hyperwalk is a set of walk expressions connected by at least one node type.
Assuming a database graph containing travel agency data, the expression
JOURNEY first (STOP next)* + STOP in CITY is a hyperwalk containing
two walk expressions connected by the node type STOP. Hence, the above
hyperwalk describes the walks going from a node (of type) JOURNEY to
one of its nodes (of type) STOP in a CITY.

The set of walks in the database satisfying a hyperwalk expression r is

3In graph theory, a walk is an alternating sequence of nodes and connecting edges,
which begins and ends with a vertex, and where any node and any edge can be visited
any number of times.

22

called the instance of r and is denoted by I(r). Based on these notions,
Gram deﬁnes a hyperwalk algebra with operations closed under the set of
hyperwalks (e.g. projection, selection, join and set operations). For example,
 the following algebra expression computes all journeys which traverse
Munich.

πJOU RN EY (σM unich(CIT Y )I(JOURNEY ﬁrst(STOP next)*

STOP in CITY)))

Although less popular, there are also languages for manipulating and
querying hypergraphs and hypernodes (nested graphs). GROOVY [105]
introduced a Hypergraph Manipulation Language (HML) for querying and
updating labeled hypergraphs which deﬁnes basic operators for manipulation
(addition and deletion) and querying of hypergraphs and hyperedges. On
the other side, Levene and Poulovassilis [104] deﬁned a logic-based query and
update language for hypernode where a query is expressed as a hypernode
program consisting of a set of hypernode rules.

GraphQL [85] is a graph query language for property graphs which is
based on the use of formal grammars for composing and manipulating graph
structures. A graph grammar is a ﬁnite set of graph motifs where a graph
motif can be either a simple graph or composed of other graph motifs by
means of concatenation, disjunction and repetition. For instance, consider
the following graph grammar containing three graph motifs:

graph G1 { node v1, v2; edge e1(v1,v2); }
graph G2 { node v2, v3; edge e2(v2,v3); }
graph G3 { graph G1 as X; graph G2 as Y; edge e3(X.v2,
Y.v2) }.

The graph motifs G1 and G2 are simple, whereas G3 is a complex graph
motif which concatenates the graph motifs G1 and G2 via the edge e3 and
the common node v2. The language of a graph grammar is the set of all the
graphs derivable from graph motifs of that grammar. The query language
is based on graph patterns consisting of a graph motif plus a predicate on
attributes of the motif. A predicate is a combination of boolean or arithmetic
comparison expressions. For instance, the expression

graph P { node v1, v2; edge e1(v1,v2) }
where v1.name=“A” and v2.year > 2000;

describes a graph pattern where two nodes v1, v2 must be connected by an
edge e1, and the nodes must satisfy the conditions following the where
clause.

23

Note that most of the languages described above are more theoretical
than practical. Cypher [14] is a declarative language for querying property
graphs implemented by the Neo4j graph database. The most basic query
in Cypher consists of a expression containing clauses START, MATCH and
RETURN. For example, assuming a friendship graph, the following query
returns the name of the friends of the persons named “John”:

START x=node:person(name="John")
MATCH (x)-[:friend]->(y)
RETURN y.name

The START clause speciﬁes one or more starting points (nodes or edges) in
the database graph. The MATCH clause contains the graph pattern of the
query. The RETURN clause speciﬁes which nodes, edges and properties in
the matched data will be returned by the query. Cypher is able to express
some types of reachability queries via path expressions. For instance, the
expression p = (a)-[:knows*]->(b) computes the paths from node (a) to
node (b), following only knows outgoing edges, and maintains the solution in
the path variable p. Additionally, there exist build-in functions to calculate
speciﬁc operations on nodes, edges, attributes and paths. For instance,
complementing the above path expression, the function shortestPath(p)
returns the shortest path between nodes (a) and (b).

SPARQL [124] is the standard query language for the RDF data model.
A typical query in SPARQL follows the traditional SELECT-FROM-WHERE
structure where the FROM clause indicates the data sources, the WHERE
clause contains a graph pattern, and the SELECT clause deﬁnes the output
of the query (e.g. resulting variables). The simplest graph pattern, called
a triple pattern, is an expression of the form subject − predicate − object
where identiﬁers (i.e. URIs), values (RDF Literals) or variables (e.g. ?X)
can be used to represent a node-edge-node pattern. A complex graph pattern 
is a collection of triple patterns whose solutions can be combined and
restricted by using operators like AND, UNION, OPTIONAL and FILTER.
For instance, the following query returns the names of persons described in
the given data source (i.e. an RDF graph):

SELECT ?N
FROM <http://example.org/data.rdf>
WHERE { ?X rdf:type voc:Person . ?X voc:name ?N }

The latest version of the language, SPARQL 1.1 [71], includes novel features 
like negation of graph patterns, arbitrary length path matching (i.e.

24

reachability), aggregate operators (e.g. COUNT), subqueries, and query
federation.

5 Graph Data Management Systems

The systems for graph data management can be classiﬁed in two main categories,
 graph databases and graph processing frameworks. Although the
problems addressed for both groups are similar, they provide two diﬀerent
approaches for storing and querying graph data, with their own advantages
and disadvantages.

Graph databases aim at persistent management of graph data, allowing
to transactionally store and access graph data on a persistent medium. In
this sense, these provide eﬃcient single-node solutions with limited scalability.
 On the other hand, graph processing frameworks aim to provide batch
processing and analysis of large graphs often in a distributed environment
with multiple machines. These solutions usually process the graph in memory,
 but diﬀerent parts of the graph are managed by distinct, distributed
nodes.

Closely related to graph databases are the systems for managing RDF
data. These systems, called RDF Triple Stores or RDF databases, are specifically 
designed to store collections of RDF triples, to support the standard
SPARQL query language, and possibly to allow some kind of inference via
semantic rules. Although Triple Stores are based on the RDF graph data
model, they are specialized databases with their own characteristics. Therefore,
 we will study them separately.

Next we present a review of current systems in the above categories,

including a short description of each of them.

5.1 Graph database systems

A graph database system (GDBS) – or just graph database – is a system 
speciﬁcally designed for managing graph-like data following the basic
principles of database systems, i.e. persistent data storage, physical/logical
data independence, data integrity and consistency. The research on graph
databases have a long history, at least since the 1980s. Although the ﬁrst of
these were primarily theoretical proposals (with emphasis on graph database
models), it is only recently that several technological developments (e.g.
powerful hardware to store and process graphs) have made it possible to
have practical systems.

25

The current “market” of graph databases includes more than 15 systems
with diﬀerent levels of development. All these systems provide most of the
major components in database management systems, including: storage engine 
(with innate support for graph structures), database languages (for data
deﬁnition, manipulation and querying), indexes and query optimizer, transactions 
and concurrency controllers, and external interfaces (user interface
or API) for system management.

Considering their internal implementation, we classify graph databases in
two types: native and non-native graph databases. Native graph databases
implement ad-hoc data structures and indexes for storing and querying
graphs. Non-native graph databases make use of other database systems to
store graph data and implement query interfaces to execute graph queries
over the back-end system.

In the group of native graph databases we found: AllegroGraph [3], Bitsy
[9], Cayley [13], GraphBase [17], Graphd [116], HyperGraphDB [88], IBM
System G [144], imGraph [89], InﬁniteGraph [19], InfoGrid [20], Neo4j [21],
Sparksee/DEX [26], Trinity [135]) and TurboGraph [82]. Among the systems 
considered non-native graph databases we can mention: Titan [29],
which supports Apache Cassandra, Apache HBase and Oracle BerkeleyDB
as storage backends; FlockDB [15] is a distributed graph-oriented database
which uses MySQL as the storage engine; OrientDB [24] and ArangoDB
[8], which are document-store databases adapted to managing graphs; OQGRAPH 
[23] which is a graph computation engine for MySQL, MariaDB y
Drizzle; VelocityGraph [30] an object database supporting graphs; and Horton 
[133], which is based on the cloud programming infrastructure Orleans.
There are several papers comparing the features [67, 39, 49, 113] and
performance [140, 56, 90] of graph databases. Next, we brieﬂy describe the
systems we consider more relevant.

AllegroGraph[3] is one of the precursors in the current generation of
graph databases. Although it was born as a graph database, its current
development is oriented to meet the Semantic Web standards (i.e., RDF/S,
SPARQL and OWL). Additionally, AllegroGraph provides special features
for GeoTemporal Reasoning and Social Network Analysis.

Sparksee (formely DEX)[112] is a native graph database for persistent
storage of property graphs.
Its implementation is based on bitmaps and
other secondary structures, and provides libraries (APIs) in several languages 
for implementing graph queries. Sparksee is been used in social,
bibliographical and biological networks analysis, media analysis, fraud detection 
and business intelligence applications of indoor positioning systems
HyperGraphDB [88] is a systems that implements the hypergraph data

26

model (i.e. edges are extended to connect more than two nodes). This model
allows a natural representation of higher-order relations, and is particularly
useful for modeling data of areas like knowledge representation, artiﬁcial
intelligence and bio-informatics. Hypergraph stores the graph information
in the form of key-value pairs which are stored on BerkeleyDB.

InﬁniteGraph [19] is a database oriented to support large-scale graphs in
a distributed environment. It aims the eﬃcient traversal of relations across
massive and distributed data stores.
Its focus of attention is to extend
business, social and government intelligence with graph analysis.

Neo4j [21] is based on a network oriented model where relations are ﬁrst
class objects. It is fully written in java and implements an object-oriented
API, a native disk-based storage manager for graphs, and a framework for
graph traversals.

Trinity [135]) implements a general purpose graph engine over a distributed 
memory cloud. Trinity implements a globally addressable distributed 
memory storage, and provides a random access abstraction for large
graph computation. Hence, it supports both online graph query processing
and oﬄine graph analytics. Its query languages, called TSL, allows users to
declare data schema and communication protocols.

5.2 Graph processing frameworks

In addition to graph databases, a number of graph processing frameworks
have been proposed to address the needs of processing complex and largescale 
graph datasets. These frameworks are characterized by in-memory
batch processing and the use of distributed and parallel processing strategies.
Note that, distributed systems with more computing and memory resources
are able to process large-scale graphs, but they can be less eﬃcient than
single-node platforms when speciﬁc graph queries are executed.

On the one hand, generic data processing systems such as Hadoop [5],
YARN [6], Stratosphere [28] and Pegasus [91] have been adapted for graph
processing due to their facilities for batch data processing. Most of these
systems are based on the MapReduce programming model and implemented
on top of the Hadoop platform, the open source version of MapReduce. By
exploiting data-parallelism, these systems are highly scalable and support
a range of fault-tolerance strategies. Though these systems improve the
performance of iterative queries, users still need to “think” their analytical
graph queries as MapReduce jobs. In fact, naively expressing graph computation 
and graph algorithms in these data-parallel abstractions can be
challenging [145]. Additionally, these systems cannot take advantage of the

27

characteristics of graph-structure data and often result in complex job chains
and excessive data movement when implementing iterative graph algorithms
[149].

On the other hand, graph-speciﬁc platforms such as Pregel [111], Apache
Giraph [4], GraphLab [109, 108], Apache Hama, Catch de Wind [134],
GPS [131], Mizan [93], PowerGraph [76], GraphX [18], TurboGraph [82]
and GraphChi [100] provide diﬀerent programming interfaces for expressing
graph analytic algorithms. These platforms, also called oﬄine graph analytic 
systems, perform an iterative, batch processing over the entire graph
dataset until the computation satisﬁes a ﬁxed-point or stopping criterion.
Therefore, these systems are particularly designed for computing graph algorithms 
which require iterative, batch processing, e.g., PageRank, recursive
relational queries, clustering, social network analysis, machine learning and
data mining algorithms [92]. Next we brieﬂy describe some of these systems.
Pregel [111] is a system that provides a native API speciﬁcally designed
by Google for writing algorithms that process graph data. Pregel is a vertexcentric 
programming abstraction that adapts the Bulk Synchronous Parallel
(BSP) model, which was developed to address the problem of parallelizing 
jobs across multiple workers for scalability The fundamental computing 
paradigm Pregel employs can be characterized as “think like a vertex”.
Graph computations are speciﬁed in terms of what each vertex has to compute;
 edges are communication channels for transmitting computation results 
from one vertex to another, and do not participate in the computation.
To avoid communication overheads, Pregel preserves data locality by ensuring 
computation is performed on locally stored data. The input graph is
loaded once at the start of a program and all computations are executed
in-memory. As a result, Pregel supports only graphs that ﬁt in memory
[81].

Giraph [16] is an open source implementation of Pregel. Giraph runs
workers as map-only jobs on Hadoop and uses HDFS for data input and output.
 Giraph also uses Apache ZooKeeper for coordination, checkpointing,
and failure recovery schemes. Giraph has incorporated several optimizations,
 has a rapidly growing user base, and has been scaled by Facebook
to graphs with a trillion edges. Giraph is executed in-memory, which can
speed-up job execution, but, for large amounts of messages or big datasets,
can also lead to crashes due to lack of memory.

GraphLab [108] is an open-source, graph-speciﬁc distributed computation 
platform implemented in C++. GraphLab uses the GAS decomposition
(Gather, Apply, Scatter), which is similar to, but fundamentally diﬀerent
from, the BSP model. In the GAS model, a vertex accumulates information

28

about its neighborhood in the Gather phase, applies the accumulated value
in the Apply phase, and updates its adjacent vertices and edges and activates 
its neighbouring vertices in the Scatter phase. Another key diﬀerence
is that GraphLab partitions graphs using vertex cuts rather than edge cuts.
Consequently, each edge is assigned to a unique machine, while vertices are
replicated in the caches of remote machines. Besides graph processing, it
also supports various machine learning algorithms.

There are several works comparing graph processing frameworks. For
instance, the ﬁrst evaluation study of modern big data frameworks, including 
Map-Reduce, Stratosphere, Hama, Giraph and Graphlab, is presented
in [69]. In [78], a benchmarking suite for graph-processing platforms is presented.
 The suite was used to evaluate the performance of Hadoop, YARN,
Stratosphere, Giraph, GraphLab, and Neo4j. In [149], the authors present
a comparison study on parallel processing systems, including Giraph, GPS
and GraphLab. Finally, an Experimental Comparison of Pregel-like Graph
Processing Systems is presented in [81].

5.3 RDF database systems

An RDF database (also called Triple Store) is a specialized graph database
for managing RDF data. RDF deﬁnes a data model based on expressions
of the form subject-predicate-object (SPO) called RDF triples. Therefore,
an RDF dataset is composed by a large collection of RDF triples which
implicitly form a graph.

SPARQL is the standard query language for RDF databases.

It is a
declarative language which allows to express several types of graph patterns.

Its most recent version (SPARQL 1.1) supports advanced features
like property paths, aggregate functions and subqueries.

There are several works comparing RDF databases (see for example [65]).
Similar to graph databases, RDF databases can also be classiﬁed into native
and non-native RDF databases. Examples of native RDF databases are
Jena [58], RDF-3X [118], 4store [2] and TripleBit [147]. Among the nonnative 
RDF databases we can mention to OpenLink Virtuoso [31], Sesame
[25] and DB2RDF [46], which are implemented on top of relational database
systems.

Being more speciﬁc about native storage approaches, the RDF databases
can be classiﬁed into four categories [147]: triples table, property table,
column store with vertical partitioning and RDF graph based store.

A triple table refers to the approach of storing RDF data in a 3-column
table with each row representing a SPO statement. Hence, the evaluation

29

of SPARQL queries involve self-joins over this long table. A popular approach 
to improving performance of queries in this storage model is to use
an exhaustive indexing method that creates a full set of SPO permutations
of indexes. Among the systems implementing triple tables we can mention
RDF-3X [118], Sesame [25], 3store [1], BrightstarDB [12].

A second approach is to store RDF data in a property table [32] with
subject as the ﬁrst column and the list of distinct predicates as the remaining
columns. A single property table can be extremely sparse and contains
many NULL values. Thus multiple-property tables with diﬀerent clusters
of properties are proposed as an optimization technique. Jena [58], Oracle
[55], and BitMat are examples of systems implementing property tables.

RDF data can also be stored by using multiple two-column tables, one
for each unique predicate. The ﬁrst column is for subject whereas the other
column is for object. This method, called column store with vertical partitioning 
[32], can be implemented over row-oriented or column-oriented
database systems. This column-store approach is implemented by C-Store
Finally, a graph based approach focuses on storing RDF data as a graph.
In this case, the RDF triples must be modeled as classical graph nodes and
edges, and the SPARQL queries must be transformed into graph queries.
Among the RDF graph based stores we can mention Ontotext GraphDB [22],
gStore [151], Stardog [27], Blazegraph [10], TrinityRDF [148] and GEMS
[117].

References

[1] 3store. http://sourceforge.net/projects/threestore/.

[2] 4store. http://www.4store.org.

[3] AllegroGraph. http://www.franz.com/agraph/allegrograph/.

[4] Apache Giraph. http://giraph.apache.org.

[5] Apache Hadoop. https://hadoop.apache.org.

[6] Apache

Hadoop

MapReduce
http://hadoop.apache.org/docs/current/hadoop-yarn/.

NextGen

(YARN).

[7] Apache TinkerPop - An open source graph computing framework.

http://tinkerpop.incubator.apache.org.

[8] ArangoDB. http://www.arangodb.org.

30

[9] Bitsy. https://bitbucket.org/lambdazen/bitsy/wiki/Home.

[10] Blazegraph. http://www.blazegraph.com/bigdata.

[11] Blueprints. https://github.com/tinkerpop/blueprints/wiki.

[12] BrightstarDB - A native RDF database for the .NET platform.

http://brightstardb.com.

[13] Cayley graph database. https://github.com/google/cayley.

[14] Cypher

-

Graph

Query

Language.

http://neo4j.com/developer/cypher-query-language/.

[15] FlockDB. https://github.com/twitter/ﬂockdb/.

[16] Giraph. https://github.com/aching/Giraph.

[17] Graphbase. http://graphbase.net/.

[18] GraphX - Apache API for graphs and graph-parallel computation.

https://spark.apache.org/graphx/.

[19] InﬁniteGraph. http://inﬁnitegraph.com/.

[20] InfoGrid - The Internet Graph Database. http://infogrid.org/.

[21] Neo4j. http://neo4j.org/.

[22] Ontotext GraphDB.

http://www.ontotext.com/products/ontotext-

graphdb/.

[23] OQGraph.

https://mariadb.com/kb/en/mariadb/oqgraph-storage-

engine/.

[24] OrientDB - Multi-Model NoSQL Database. http://orientdb.com.

[25] Sesame. http://www.openrdf.org/.

[26] Sparksee

-

Scalable

high-performance

graph

database.

http://www.sparsity-technologies.com/.

[27] Stardog. http://stardog.com.

[28] Stratosphere

- next generation big data analytics platform.

http://stratosphere.eu.

31

[29] Titan

-

Distributed

Graph

Database.

http://thinkaurelius.github.io/titan/.

[30] VelocityGraph. http://www.velocitygraph.com.

[31] Virtuoso Universal Server. http://virtuoso.openlinksw.com/.

[32] D. J. Abadi, A. Marcus, S. R. Madden, and K. Hollenbach. Scalable 
semantic web data management using vertical partitioning. In
Proceedings of the 33rd international conference on Very Large Data
Bases (VLDB), pages 411–422, 2007.

[33] S. Abiteboul. Querying Semi-Structured Data. In Proceedings of the
6th International Conference on Database Theory (ICDT), volume
1186 of LNCS, pages 1–18. Springer, Jan. 1997.

[34] S. Abiteboul, D. Quass, J. McHugh, J. Widom, and J. L. Wiener. The
Lorel query language for semistructured data. International Journal
on Digital Libraries (JODL), 1(1):68–88, 1997.

[35] S. Abiteboul and V. Vianu. Regular path queries with constraints.

Journal of Computer and System Sciences, 58:428–452, 1999.

[36] C. C. Aggarwal and H. Wang, editors. Managing and Mining Graph
Data (Advances in Database Systems). Springer Science – Business
Media, 2010.

[37] B. Amann and M. Scholl. Gram: A Graph Data Model and Query
Language. In European Conference on Hypertext Technology (ECHT),
pages 201–211. ACM, 1992.

[38] M. Andries, M. Gemis, J. Paredaens, I. Thyssens, and J. V. den Bussche.
 Concepts for Graph-Oriented Object Manipulation. In Proceedings 
of the 3rd International Conference on Extending Database Technology 
(EDBT), volume 580 of LNCS, pages 21–38. Springer, March
1992.

[39] R. Angles. A comparison of current graph database models. In 4rd
International Workshop on Graph Data Management: Techniques and
Applications (GDM) (ICDE Workshop), 2012.

[40] R. Angles, M. Arenas, P. Barcel´o, A. Hogan, J. Reutter, and D. Vrgoˇc.
Foundations of modern query languages for graph databases. ACM
Comput. Surv., 50(5):68:1–68:40, Sept. 2017.

32

[41] R. Angles, P. Barcel´o, and G. R´ıos. A practical query language for
graph dbs. In 7th Alberto Mendelzon International Workshop on Foundations 
of Data Management (AMW), 2013.

[42] R. Angles and C. Gutierrez. Survey of graph database models. ACM

Computing Surveys (CSUR), 40(1):1–39, 2008.

[43] P. Barcel´o, L. Libkin, A. W. Lin, and P. T. Wood. Expressive languages 
for path queries over graph-structured data. ACM Trans.
Database Syst., 37(4):1–46, Dec. 2012.

[44] P. Barcel´o Baeza. Querying graph databases. In Proceedings of the
32nd symposium on Principles of database systems (PODS), pages
175–188. ACM, 2013.

[45] C. Berge. Graphs and Hypergraphs. North-Holland, Amsterdam, 1973.

[46] M. A. Bornea, J. Dolby, A. Kementsietsidis, K. Srinivas, P. Dantressangle,
 O. Udrea, and B. Bhattacharjee. Building an eﬃcient RDF
store over a relational database. In Proceedings of the ACM International 
Conference on Management of Data (SIGMOD), pages 121–132.
ACM, 2013.

[47] T. Bray,

J. Paoli,

Extensible 
Markup Language (XML) 1.0, W3C Recommendation.
http://www.w3.org/TR/1998/REC-177-19980210, 10 February 1998.

and C. M. Sperberg-McQueen.

[48] R. Brijder, J. J. M. Gillis, and J. Van den Bussche. The DNA Query
Language DNAQL. In Proceedings of the 16th International Conference 
on Database Theory (ICDT), pages 1–9. ACM, 2013.

[49] M. Buerli. The current state of graph databases. Technical report,

December 2012.

[50] P. Buneman. Semistructured Data. In Proceedings of the 16th Symposium 
on Principles of Database Systems (PODS), pages 117–121.
ACM Press, May 1997.

[51] P. Buneman, M. Fernandez, and D. Suciu. Unql: a query language
and algebra for semistructured data based on structural recursion. The
VLDB Journal, 9(1):76–110, Mar. 2000.

[52] L. Cardelli, P. Gardner, and G. Ghelli. A Spatial Logic for Querying 
Graphs. In Proceedings of the 29th International Colloquium on

33

Automata, Languages, and Programming (ICALP), LNCS, pages 597–
610. Springer, July 2002.

[53] C.-S. Chang and A. L. P. Chen. Supporting conceptual and neighborhood 
queries on the World Wide Web. IEEE Transactions on Systems,
Man, and Cybernetics (TSMC), 28(2):300–308, 1998.

[54] P. P.-S. Chen. The Entity-Relationship Model - Toward a Uniﬁed View
of Data. ACM Transactions on Database Systems (TODS), 1(1):9–36,
1976.

[55] E. I. Chong, S. Das, G. Eadon, and J. Srinivasan. An Eﬃcient SQLbased 
RDF Querying Scheme. In Proc. VLDB Endow., pages 1216–
1227, 2005.

[56] M. Ciglan, A. Averbuch, and L. Hluchy. Benchmarking Traversal
Operations over Graph Databases. In Proceedings of the 28th International 
Conference on Data Engineering Workshops, pages 186–189.
IEEE Computer Society, 2012.

[57] E. F. Codd. A Relational Model of Data for Large Shared Data Banks.

Communications of the ACM, 13(6):377–387, 1970.

[58] H.-P. D. Company. Jena - A Semantic Web Framework for Java.

http://jena.sourceforge.net/, 2000.

[59] M. Consens and A. Mendelzon. Hy+: a Hygraph-based Query and

Visualization System. SIGMOD Record, 22(2):511–516, 1993.

[60] M. P. Consens and A. O. Mendelzon. Expressing Structural HyperIn 
Proceedings of the 2th Conference on

text Queries in Graphlog.
Hypertext, pages 269–292. ACM Press, 1989.

[61] M. P. Consens and A. O. Mendelzon. GraphLog: a Visual Formalism
for Real Life Recursion. In Proceedings of the 9th ACM Symposium on
Principles of Database Systems, PODS, pages 404–416. ACM Press,
April 2-4 1990.

[62] D. Conte, P. Foggia, C. Sansone, and M. Vento. Thirty years of graph
International Journal of Pattern

matching in pattern recognition.
Recognition and Artiﬁcial Intelligence, 18(3), 2004.

[63] I. F. Cruz, A. O. Mendelzon, and P. T. Wood. A Graphical Query
In Proceedings of the Association

Language Supporting Recursion.

34

for Computing Machinery Special Interest Group on Management of
Data, pages 323–330. ACM Press, May 1987.

[64] I. F. Cruz, A. O. Mendelzon, and P. T. Wood. G+: Recursive Queries
without Recursion. In Proceedings of the 2th International Conference
on Expert Database Systems (EDS), pages 645–666. Addison-Wesley,
April 1989.

[65] P. Cudr´e-Mauroux, I. Enchev, S. Fundatureanu, P. Groth, A. Haque,
A. Harth, F. Keppmann, D. Miranker, J. Sequeda, and M. Wylot.
NoSQL Databases for RDF: An Empirical Evaluation.
In Proc. of
the International Semantic Web Conference (ISWC), volume 8219 of
LNCS, pages 310–325. Springer Berlin Heidelberg, 2013.

[66] D. Dominguez-Sal, N. Martinez-Bazan, V. Muntes-Mulero, P. Baleta,
and J. L. Larriba-Pey. A discussion on the design of graph database
benchmarks. In TPC Technology Conference on Performance Evaluation 
and Benchmarking, 2010.

[67] D. Dominguez-Sal, P. Urb´on-Bayes, A. Gim´enez-Va˜n´o, S. G´omezVillamor,
 N. Mart´ınez-Baz´an, and J. L. Larriba-Pey. Survey of graph
database performance on the HPC scalable graph analysis benchmark.
In Proc. of the 2010 international conference on Web-age information
management (WAIM), pages 37–48. Springer-Verlag, 2010.

[68] A. Dries, S. Nijssen, and L. De Raedt. A query language for analyzing
networks. In Proc. of the 18th ACM conference on Information and
knowledge management (CIKM), pages 485–494. ACM, 2009.

[69] B. Elser and A. Montresor. An evaluation study of BigData frameworks 
for graph processing. In Proceedings of the IEEE International
Conference on Big Data, pages 60–67. IEEE, 2013.

[70] W. Fan. Graph Pattern Matching Revised for Social Network Analysis.
 In Proceedings of the 15th International Conference on Database
Theory (ICDT), pages 8–21, New York, NY, USA, 2012. ACM.

[71] L. Feigenbaum, G. T. Williams, K. G. Clark, and E. TorProtocol.
 W3C Recommendation.

res.
http://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/,
March 21 2013.

SPARQL

1.1

35

[72] S. Flesca and S. Greco. Partially Ordered Regular Languages for
Graph Queries. In Proceedings of the 26th International Colloquium
on Automata, Languages and Programming (ICALP), volume 1644 of
LNCS, pages 321–330. Springer, July 1999.

[73] B. Gallagher. Matching structure and semantics: A survey on graphbased 
pattern matching. In AAAI, 2006.

[74] H. Garcia-Molina, Y. Papakonstantinou, D. Quass, A. Rajaraman,
Y. Sagiv, J. Ullman, V. Vassalos, and J. Widom. The tsimmis approach 
to mediation: Data models and languages. Jounal on Intelligent 
Information Systems, 8(2):117–132, 1997.

[75] M. Gemis and J. Paredaens. An Object-Oriented Pattern Matching
Language.
In Proceedings of the First JSSST International Symposium 
on Object Technologies for Advanced Software, pages 339–355.
Springer-Verlag, 1993.

[76] J. E. Gonzalez, Y. Low, H. Gu, D. Bickson, and C. Guestrin. Power-
Graph: Distributed Graph-parallel Computation on Natural Graphs.
In Proceedings of the 10th USENIX Conference on Operating Systems
Design and Implementation (OSDI), pages 17–30, Berkeley, CA, USA,
2012. USENIX Association.

[77] M. Graves, E. R. Bergeman, and C. B. Lawrence. A Graph-Theoretic
Data Model for Genome Mapping Databases. In Proceedings of the
28th Hawaii International Conference on System Sciences (HICSS),
page 32. IEEE Computer Society, 1995.

[78] Y. Guo, M. Biczak, A. L. Varbanescu, A. Iosup, C. Martella, and
T. L. Willke. How Well Do Graph-Processing Platforms Perform?
An Empirical Performance Evaluation and Analysis. In Proceedings
of the IEEE 28th International Parallel and Distributed Processing
Symposium, pages 395–404. IEEE Computer Society, 2014.

[79] A. Guti´errez, P. Pucheral, H. Steﬀen, and J.-M. Th´evenin. Database
Graph Views: A Practical Model to Manage Persistent Graphs. In
Proceedings of the 20th International Conference on Very Large Data
Bases (VLDB), pages 391–402. Morgan Kaufmann, September 1994.

[80] M. Gyssens, J. Paredaens, J. V. den Bussche, and D. V. Gucht. A
In Proceedings of the 9th

Graph-Oriented Object Database Model.

36

Symposium on Principles of Database Systems (PODS), pages 417–
424. ACM Press, 1990.

[81] M. Han, K. Daudjee, K. Ammar, M. T. ¨Ozsu, X. Wang, and T. Jin. An
Experimental Comparison of Pregel-like Graph Processing Systems.
Proc. VLDB Endow., 7(12):1047–1058, Aug. 2014.

[82] W.-S. Han, S. Lee, K. Park, J.-H. Lee, M.-S. Kim, J. Kim, and H. Yu.
TurboGraph: A Fast Parallel Graph Engine Handling Billion-scale
Graphs in a Single PC. In Proceedings of the 19th ACM International
Conference on Knowledge Discovery and Data Mining, pages 77–85.
ACM, 2013.

[83] S. Harris and A. Seaborne. SPARQL 1.1 Query Language - W3C Rec-
http://www.w3.org/TR/2013/REC-sparql11-queryommendation.

20130321/, March 21 2013.

[84] J. Hayes and C. Gutierrez. Bipartite Graphs as Intermediate Model
for RDF. In Proceedings of the 3th International Semantic Web Conference 
(ISWC), number 3298 in LNCS, pages 47–61. Springer-Verlag,
Nov 2004.

[85] H. He and A. K. Singh. Graphs-at-a-time: query language and access
In Proc. of the 2008 Int. Conf. on

methods for graph databases.
Management of Data (SIGMOD), pages 405–418. ACM, 2008.

[86] J. Hidders. Typing Graph-Manipulation Operations. In Proceedings of
the 9th International Conference on Database Theory (ICDT), pages
394–409. Springer-Verlag, 2002.

[87] J. Hidders and J. Paredaens. GOAL, A Graph-Based Object and Association 
Language. Advances in Database Systems: Implementations
and Applications, CISM, pages 247–265, Sept. 1993.

[88] B. Iordanov. HyperGraphDB: a generalized graph database.

In
Proceedings of the International Conference on Web-age Information
Management (WAIM), pages 25–36. Springer-Verlag, 2010.

[89] S. Jouili and A. Reynaga. imGraph: A Distributed In-Memory Graph
Database. In Proc. of the International Conference on Social Computing 
(SocialCom), pages 732–737, 2013.

37

[90] S. Jouili and V. Vansteenberghe. An empirical comparison of graph
databases. In Proc. of the International Conference on Social Computing 
(SocialCom), pages 708–715, Sept 2013.

[91] U. Kang, C. E. Tsourakakis, and C. Faloutsos. PEGASUS: A PetaScale 
Graph Mining System Implementation and Observations.
In
Proceedings of the 9th International Conference on Data Mining, pages
229–238. IEEE Computer Society, 2009.

[92] A. Khan and S. Elnikety. Systems for Big-Graphs. In Proc. of the 40th

International Conference on Very Large Data Bases (VLDB), 2014.

[93] Z. Khayyat, K. Awara, A. Alonazi, H. Jamjoom, D. Williams, and
P. Kalnis. Mizan: A System for Dynamic Load Balancing in Largescale 
Graph Processing.
In Proceedings of the 8th ACM European
Conference on Computer Systems, pages 169–182. ACM, 2013.

[94] N. Kiesel, A. Schurr, and B. Westfechtel. GRAS: A Graph-Oriented
Software Engineering Database System. In IPSEN Book, pages 397–
425, 1996.

[95] W. Kim. Object-Oriented Databases: Deﬁnition and Research DiIEEE 
Transactions on Knowledge and Data Engineering

rections.
(TKDE), 2(3):327–341, 1990.

[96] G. Klyne and J. Carroll. Resource Description Framework (RDF)
Concepts and Abstract Syntax. http://www.w3.org/TR/2004/REC-
115-concepts-20040210/, February 2004.

[97] L. Kowalik. Adjacency queries in dynamic sparse graphs. Information

Processing Letters, 102:191–195, May 2007.

[98] H. S. Kunii. DBMS with Graph Data Model for Knowledge Handling.
In Proceedings of the 1987 Fall Joint Computer Conference on Exploring 
technology: today and tomorrow, pages 138–142. IEEE Computer
Society Press, 1987.

[99] G. M. Kuper and M. Y. Vardi. A New Approach to Database Logic. In
Proceedings of the 3th Symposium on Principles of Database Systems
(PODS), pages 86–96. ACM Press, April 1984.

[100] A. Kyrola, G. Blelloch, and C. Guestrin. GraphChi: Large-scale Graph
Computation on Just a PC. In Proceedings of the 10th USENIX Con38


ference on Operating Systems Design and Implementation, pages 31–
46, Berkeley, CA, USA, 2012. USENIX Association.

[101] C. L´ecluse, P. Richard, and F. V´elez. O2, an Object-Oriented Data
Model. In Proceedings of the ACM International Conference on Management 
of Data (SIGMOD), pages 424–433. ACM Press, June 1988.

[102] M. Levene and G. Loizou. A Graph-Based Data Model and its RamIEEE 
Transactions on Knowledge and Data Engineering

iﬁcations.
(TKDE), 7(5):809–823, 1995.

[103] M. Levene and G. Loizou. A Graph-Based Data Model and its Ramiﬁcations.
 Technical report, 1995.

[104] M. Levene and A. Poulovassilis. The Hypernode Model and its Associated 
Query Language. In Proceedings of the 5th Jerusalem Conference
on Information technology, pages 520–530. IEEE Computer Society
Press, 1990.

[105] M. Levene and A. Poulovassilis. An Object-Oriented Data Model
Formalised Through Hypergraphs. Data & Knowledge Engineering
(DKE), 6(3):205–224, 1991.

[106] L. Libkin, W. Martens, and D. Vrgoˇc. Querying Graph Databases
with XPath. In Proceedings of the 16th International Conference on
Database Theory (ICDT), pages 129–140. ACM, 2013.

[107] Y. A. Liu and S. D. Stoller. Querying complex graphs. In Proc. of
the 8th Int. Symposium on Practical Aspects of Declarative Languages,
pages 16–30. Springer-Verlag, 2006.

[108] Y. Low, D. Bickson, J. Gonzalez, C. Guestrin, A. Kyrola, and J. M.
Hellerstein. Distributed GraphLab: A Framework for Machine Learning 
and Data Mining in the Cloud. Proc. VLDB Endow., 5(8):716–727,
2012.

[109] Y. Low, J. Gonzalez, A. Kyrola, D. Bickson, C. Guestrin, and J. M.
Hellerstein. GraphLab: A New Parallel Framework for Machine Learning.

In Conference on Uncertainty in Artiﬁcial Intelligence (UAI),
July 2010.

[110] M. Mainguenaud. Simatic XT: A Data Model to Deal with Multiscaled 
Networks. Computer, Environment and Urban Systems, 16:281–
288, 1992.

39

[111] G. Malewicz, M. H. Austern, A. J. Bik, J. C. Dehnert, I. Horn,
N. Leiser, and G. Czajkowski. Pregel: a system for large-scale graph
processing. In Proceedings of the International Conference on Management 
of data (SIGMOD), pages 135–146, New York, NY, USA,
2010. ACM.

[112] N. Mart´ınez-Bazan, V. Munt´es-Mulero, S. G´omez-Villamor, J. Nin,
DEX: HighM.
-A. S´anchez-Mart´ınez, and J.-L. Larriba-Pey.
Performance Exploration on Large Graphs for Information Retrieval.
In Proceedings of the 16th Conference on Information and Knowledge
Management (CIKM), pages 573–582. ACM, 2007.

[113] R. McColl, D. Ediger, J. Poovey, D. Campbell, and D. A. Bader.
A Brief Study of Open Source Graph Databases. The Computing
Research Repository (CoRR), 2013.

[114] D. L. McGuinness

and F.

van Harmelen.

Ontology
http://www.w3.org/TR/2004/REC-133-features-20040210/,
February 2004.

Overview,

Language

W3C

OWL Web
Recommendation.
10

[115] A. O. Mendelzon and P. T. Wood. Finding regular simple paths in

graph databases. SIAM J. Comput., 24(6):1235–1258, Dec. 1995.

[116] S. M. Meyer, J. Degener, J. Giannandrea, and B. Michener. Optimizing 
Schema-last Tuple-store Queries in Graphd. In Proceedings of the
ACM International Conference on Management of Data (SIGMOD),
pages 1047–1056. ACM, 2010.

[117] A. Morari, V. Castellana, O. Villa, A. Tumeo, J. Weaver, D. Haglin,
S. Choudhury, and J. Feo. Scaling semantic graph databases in size
and performance. IEEE Micro, 34(4):16–26, July 2014.

[118] T. Neumann and G. Weikum. The RDF-3X engine for scalable management 
of RDF data. The VLDB Journal, 19(1):91–113, 2010.

[119] A. N. Papadopoulos and Y. Manolopoulos. Nearest Neighbor Search -
A Database Perspective. Series in Computer Science. Springer, 2005.

[120] Y. Papakonstantinou, H. Garcia-Molina, and J. Widom. Object Exchange 
across Heterogeneous Information Sources. In Proceedings of
the 11th International Conference on Data Engineering (ICDE), pages
251–260. IEEE Computer Society, 1995.

40

[121] J. Paredaens, P. Peelman, and L. Tanca. G-Log: A Graph-Based
Query Language. IEEE Transactions on Knowledge and Data Engineering 
(TKDE), 7(3):436–453, 1995.

[122] J. Peckham and F. J. Maryanski. Semantic Data Models. ACM Computing 
Surveys, 20(3):153–189, 1988.

[123] A. Poulovassilis and M. Levene. A Nested-Graph Model for the Representation 
and Manipulation of Complex Objects. ACM Transactions
on Information Systems (TOIS), 12(1):35–68, 1994.

[124] E. Prud’hommeaux and A. Seaborne. SPARQL Query Language for
RDF. W3C Recommendation. http://www.w3.org/TR/2008/REC-
115-sparql-query-20080115/, January 15 2008.

[125] Ralf Hartmut G¨uting. GraphDB: Modeling and Querying Graphs in
Databases. In Proceedings of 20th International Conference on Very
Large Data Bases (VLDB), pages 297–308. Morgan Kaufmann, 1994.

[126] Ralf Hartmut G¨uting. GraphDB: Modeling and Querying Graphs in

Databases. Technical Report 155, Fernuniversit¨at Hagen, 1994.

[127] J. L. Reutter, M. Romero, and M. Y. Vardi. Regular queries on graph
In Proceedings of the 18th International Conference on

databases.
Database Theory (ICDT), pages 177–194, March 2015.

[128] M. A. Rodriguez and P. Neubauer. Constructions from dots and lines.

Bul. Am. Soc. Info. Sci. Tech., 36(6):35–41, 2010.

[129] R. Ronen and O. Shmueli. SoQL: A Language for Querying and Creating 
Data in Social Networks. In Proceedings of the 2009 IEEE International 
Conference on Data Engineering (ICDE), pages 1595–1602.
IEEE Computer Society, 2009.

[130] N. Roussopoulos and J. Mylopoulos. Using Semantic Networks for
Database Management. In Proceedings of the International Conference
on Very Large Data Bases (VLDB), pages 144–172. ACM, Sept 1975.

[131] S. Salihoglu and J. Widom. GPS: A Graph Processing System. In Proceedings 
of the 25th International Conference on Scientiﬁc and Statistical 
Database Management, pages 1–12. ACM, 2013.

[132] S. Santini. Regular Languages with Variables on Graphs. Information

and Computation, 211:1–28, Feb. 2012.

41

[133] M. Sarwat, S. Elnikety, Y. He, and M. F. Mokbel. Horton+: A
Distributed System for Processing Declarative Reachability Queries
over Partitioned Graphs. Proc. VLDB Endow., 6(14):1918–1929, Sept.
2013.

[134] Z. Shang and J. X. Yu. Catch the Wind: Graph workload balancing on
cloud. In 30th International Conference on Data Engineering (ICDE),
pages 553–564. IEEE Computer Society, 2013.

[135] B. Shao, H. Wang, and Y. Li. Trinity: a distributed graph engine on
a memory cloud. In Proceedings of the ACM International Conference
on Management of Data (SIGMOD), pages 505–516. ACM, 2013.

[136] D. W. Shipman. The Functional Data Model and the Data Language 
DAPLEX. ACM Transactions on Database Systems (TODS),
6(1):140–173, 1981.

[137] D. Theodoratos. Semantic Integration and Querying of Heterogeneous
Data Sources Using a Hypergraph Data Model. In Proceedings of the
19th British National Conference on Databases (BNCOD), Advances
in Databases, LNCS, pages 166–182. Springer, 2002.

[138] Y. Tian, R. C. McEachin, C. Santos, D. J. States, and J. M. Patel.
Saga: a subgraph matching tool for biological graphs. Bioinformatics,
23(2):232–239, 2007.

[139] F. W. Tompa. A Data Model for Flexible Hypertext Database Systems.
 ACM Transactions on Information Systems (TOIS), 7(1):85–
100, 1989.

[140] C. Vicknair, M. Macias, Z. Zhao, X. Nan, Y. Chen, and D. Wilkins.
A comparison of a graph database and a relational database. In ACM
Southeast Regional Conference, 2010.

[141] C. Watters and M. A. Shepherd. A Transient Hypergraph-Based
Model for Data Access. ACM Transactions on Information Systems
(TOIS), 8(2):77–102, 1990.

[142] P. T. Wood. Factoring Augmented Regular Chain Programs. In Proceedings 
of the 16th International Conference on Very Large Data
Bases (VLDB), pages 255–263. Morgan Kaufmann Publishers Inc.,
1990.

42

[143] P. T. Wood. Query languages for graph databases. SIGMOD Record,

41(1):50–60, Apr. 2012.

[144] Y. Xia, I. Tanase, L. Nai, W. Tan, Y. Liu, J. Crawford, and C. Lin.
Explore eﬃcient data organization for large scale graph analytics and
storage. In IEEE International Conference on Big Data, 2014.

[145] R. S. Xin, J. E. Gonzalez, M. J. Franklin, and I. Stoica. GraphX:
A Resilient Distributed Graph System on Spark.
In First International 
Workshop on Graph Data Management Experiences and Systems 
(GRADES), pages 1–6. ACM, 2013.

[146] M. Yannakakis. Graph-Theoretic Methods in Database Theory.

In
Proceedings of the 9th Symposium on Principles of Database Systems
(PODS), pages 230–242. ACM Press, 1990.

[147] P. Yuan, P. Liu, B. Wu, H. Jin, W. Zhang, and L. Liu. TripleBit: A
Fast and Compact System for Large Scale RDF Data. Proc. VLDB
Endow., 6(7):517–528, May 2013.

[148] K. Zeng, J. Yang, H. Wang, B. Shao, and Z. Wang. A distributed graph
engine for web scale rdf data. Proceedings of the VLDB Endowment,
6(4):265–276, 2013.

[149] Y. Zhao, K. Yoshigoe, M. Xie, S. Zhou, R. Seker, and J. Bian. Evaluation 
and analysis of distributed graph-parallel processing frameworks.
Journal of Cyber Security and Mobility, 3(3):289–316, July 2014.

[150] A. D. Zhu, H. Ma, X. Xiao, S. Luo, Y. Tang, and S. Zhou. Shortest
path and distance queries on road networks: towards bridging theory 
and practice. In Proceedings of the International Conference on
Management of Data (SIGMOD), pages 857–868. ACM, 2013.

[151] L. Zou, M. ¨Ozsu, L. Chen, X. Shen, R. Huang, and D. Zhao. gStore: a
graph-based SPARQL query engine. The VLDB Journal, 23(4):565–
590, 2014.

43

