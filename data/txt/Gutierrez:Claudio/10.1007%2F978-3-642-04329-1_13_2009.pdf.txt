Chapter 13
On the Semantics of SPARQL

Marcelo Arenas, Claudio Gutierrez,
and Jorge Pérez

Abstract The Resource Description Framework (RDF) is the standard data model
for representing information about World Wide Web resources. In January 2008, it
was released the recommendation of the W3C for querying RDF data, a query language 
called SPARQL. In this chapter, we give a detailed description of the semantics 
of this language. We start by focusing on the deﬁnition of a formal semantics for
the core part of SPARQL, and then move to the deﬁnition for the entire language,
including all the features in the speciﬁcation of SPARQL by the W3C such as blank
nodes in graph patterns and bag semantics for solutions.

13.1 Introduction

The Resource Description Framework (RDF) is a data model for representing information 
about World Wide Web resources. Jointly with its release in 1998 as recommendation 
of the W3C, the natural problem of querying RDF data was raised.
Since then, several designs and implementations of RDF query languages have been
proposed. In 2004, the RDF Data Access Working Group, part of the W3C Semantic 
Web Activity, released a ﬁrst public working draft of a query language for RDF,
called SPARQL [15].1 Since then, SPARQL has been rapidly adopted as the standard 
for querying Semantic Web data. In January 2008, SPARQL became a W3C
recommendation.

RDF is a directed labeled graph data format and, thus, SPARQL is essentially
a graph-matching query language. SPARQL queries are composed by three parts.

1The name SPARQL is a recursive acronym that stands for SPARQL Protocol and RDF Query
Language.
M. Arenas ((cid:2)) · J. Pérez
Department of Computer Science, Pontiﬁcia Universidad Católica de Chile,
Vicuña Mackenna 4860, 7820436 Macul, Santiago, Chile
e-mail: marenas@ing.puc.cl

J. Pérez
e-mail: jperez@ing.puc.cl

C. Gutierrez
Department of Computer Science, Universidad de Chile, Blanco Encalada 2120,
8370459 Santiago, Santiago, Chile
e-mail: cgutierr@dcc.uchile.cl

R. De Virgilio et al. (eds.), Semantic Web Information Management,
DOI 10.1007/978-3-642-04329-1_13, © Springer-Verlag Berlin Heidelberg 2010

281

282

M. Arenas et al.

The pattern matching part, which includes several interesting features of pattern
matching of graphs, like optional parts, union of patterns, nesting, ﬁltering values
of possible matchings, and the possibility of choosing the data source to be matched
by a pattern. The solution modiﬁers, which once the output of the pattern has been
computed (in the form of a table of values of variables), allow to modify these
values applying classical operators like projection, distinct, order and limit. Finally,
the output of a SPARQL query can be of different types: yes/no queries, selections
of values of the variables which match the patterns, construction of new RDF data
from these values and descriptions of resources.

The deﬁnition of a formal semantics for SPARQL has played a key role in the
standardization process of this query language. Although taken one by one the features 
of SPARQL are intuitive and simple to describe and understand, it turns out
that the combination of them makes SPARQL into a complex language. Reaching 
a consensus in the W3C standardization process about a formal semantics for
SPARQL was not an easy task. The initial efforts to deﬁne SPARQL were driven by
use cases, mostly by specifying the expected output for particular example queries.
In fact, the interpretations of examples and the exact outcomes of cases not covered
in the initial drafts of the SPARQL speciﬁcation, were a matter of long discussions in
the W3C mailing lists. In [11], the authors presented one of the ﬁrst formalizations
of a semantics for a fragment of the language. Currently, the ofﬁcial speciﬁcation of
SPARQL [15], endorsed by the W3C, formalizes a semantics based on [11].

A formalization of a semantics for SPARQL is beneﬁcial for several reasons, including 
to serve as a tool to identify and derive relations among the constructors that
stay hidden in the use cases, to identify redundant and contradicting notions, to drive
and help the implementation of query engines and to study the complexity, expressiveness 
and further natural database questions like rewriting and optimization. In
this chapter, we present a streamlined version of the core fragment of SPARQL with
precise algebraic syntax and a formal compositional semantics based on [11–13].

One of the delicate issues in the deﬁnition of a semantics for SPARQL is the
treatment of optional matching and incomplete answers. The idea behind optional
matching is to allow information to be added if the information is available in the
data source, instead of just failing to give an answer whenever some part of the pattern 
does not match. This feature of optional matching is crucial in Semantic Web
applications, and more speciﬁcally in RDF data management, where it is assumed
that every application have only partial knowledge about the resources being managed.
 The semantics of SPARQL is formalized by using partial mappings between
variables in the patterns and actual values in the RDF graph being queried. This
formalization allows one to deal with partial answers in a clean way, and is based
on the extension of some classical relational algebra operators to work over sets of
partial mappings.

The rest of the chapter is organized as follows. In Sect. 13.2, we describe the
ofﬁcial syntax of SPARQL proposed by the W3C. In Sect. 13.3, we introduce an algebraic 
syntax for the language and compare it with the ofﬁcial syntax. In Sect. 13.4,
we formalize the semantics of SPARQL. We begin formalizing a set semantics for
the language without considering blank nodes in patterns. We then extend the semantics 
to consider blank nodes and we provide a bag semantics for SPARQL. In

13 On the Semantics of SPARQL

283

Sect. 13.5, we review some of the results in the literature about the complexity of
evaluating SPARQL graph patterns. Section 13.6 describes some related work about
the formalization of a semantics for SPARQL. Concluding remarks are in Sect. 13.7.

13.2 The W3C Syntax of SPARQL

The RDF query language SPARQL was adopted as a W3C recommendation on
January 15, 2008. Its syntax and semantics are speciﬁed in [15]. SPARQL is a language 
designed to query data in the form of sets of triples, namely RDF graphs (see
Sect. 13.3 for a formal deﬁnition of the notion of RDF graph). The basic engine of
the language is a pattern matching facility, which uses some graph pattern matching
functionalities (sets of triples can be viewed also as graphs). The overall structure of
the language—from a syntactic point of view—resembles SQL with its three main
blocks (as shown in Fig. 13.1):
• A WHERE clause, which is composed of a graph pattern. Informally speaking,
this clause is given by a pattern that corresponds to an RDF graph where some
resources have been replaced by variables. But not only that, more complex expressions 
(patterns) are also allowed, which are formed by using some algebraic
operators. This pattern is used as a ﬁlter of the values of the dataset to be returned.
• A FROM clause, which speciﬁes the sources or datasets to be queried.
• A SELECT clause, which speciﬁes the ﬁnal form in which the results are returned
to the user. SPARQL, in contrast to SQL, allows several forms of returning the
data: a table using SELECT, a graph using DESCRIBE or CONSTRUCT, or a
TRUE/FALSE answer using ASK.

In what follows, we explain in more detail each component of the language. Of
course, for ultimate details the reader should consult [15].

Fig. 13.1 The general form of a SPARQL query

284

13.2.1 Basic Deﬁnitions

M. Arenas et al.

There are several basic concepts used in the deﬁnition of the syntax of SPARQL,
many of which are taken from the RDF speciﬁcation with some minor modiﬁcations.
For the sake of completeness, we review them here.

An IRI (Internationalized Resource Identiﬁer [5]) is an identiﬁer of resources,
which essentially extends the syntax of URIs to a much wider repertoire of characters 
for internationalization purposes. For denoting resources, SPARQL uses IRIs
instead of the URIs of RDF. A literal is used to identify values such as numbers and
dates by means of a lexical representation. Anything represented by a literal could
also be represented by a IRI, but it is often more convenient or intuitive to use literals.
 All literals have a lexical form that is a Unicode string. There are two types
of literals: plain and typed. A plain literal is a string combined with an optional
language tag. This may be used for plain text in a natural language. A typed literal
is a string combined with a datatype IRI.

13.2.2 Basic Structures

In order to present the language, we follow the grammar given in Fig. 13.2 that
speciﬁes the basic structure of the SPARQL Query Grammar [15].2

As shown in Fig. 13.2, a SPARQL Query is given by a Prologue followed by
any of the four types of SPARQL queries: SelectQuery, ConstructQuery,
DescribeQuery or AskQuery. The Prologue contains the declaration of
variables, namespaces and abbreviations to be used in the query. The SELECT
clause in a SelectQuery selects a group of variables, or all of them using—
as in SQL—the wildcard *. In these types of queries, one can eliminate duplicate
solutions using DISTINCT. In a ConstructQuery, the CONSTRUCT form, and
more speciﬁcally the ConstructTemplate form, is used to construct an RDF
graph using the obtained solutions. In a DescribeQuery, the DESCRIBE form
is not normative (only informative). It is intended to describe the speciﬁed variables
or IRIs, i.e., it returns all the triples in the dataset involving these resources. In an
AskQuery, the ASK form has no parameters but the dataset to be queried and a
WHERE clause. It returns TRUE if the solution set is not empty, and FALSE otherwise.


In a SPARQL query, the DatasetClause allows to specify one graph (the
DefaultGraphClause) or a set of named graphs, i.e., a set of pairs of identiﬁers 
and graphs, which are the data sources to be used when computing the answer
to the query. Moreover, the WHERE clause is used to indicate how the information
from the data sources is to be ﬁltered, and it can be considered the central component 
of the query language. It speciﬁes the pattern to be matched against the data

2http://www.w3.org/TR/rdf-sparql-query/#grammar.

13 On the Semantics of SPARQL

285

Query

::=

Prologue ( SelectQuery | ConstructQuery |

DescribeQuery | AskQuery )

SelectQuery ::=

"SELECT" ( "DISTINCT" | "REDUCED" )?

( Var+ | "*" )

DatasetClause* WhereClause SolutionModifier

ConstructQuery ::=

"CONSTRUCT" ConstructTemplate
DatasetClause* WhereClause
SolutionModifier

DescribeQuery

::=

"DESCRIBE" ( VarOrIRIref+ | "*" )
DatasetClause* WhereClause?
SolutionModifier

AskQuery

::=

"ASK" DatasetClause* WhereClause

DatasetClause

::=

"FROM" ( DefaultGraphClause |

NamedGraphClause )

WhereClause

::=

"WHERE"? GroupGP

GroupGP
GPNotTr
OptionalGP
GraphGP
GroupOrUnionGP ::= GroupGP ( "UNION" GroupGP )*
Filter

::= "{" TB? ((GPNotTr | Filter) "."? TB?)* "}"
::= OptionalGP | GroupOrUnionGP | GraphGP
::= "OPTIONAL" GroupGP
::= "GRAPH" VarOrIRIref GroupGP

::= "FILTER" Constraint

SolutionModifier

::=

OrderClause? LimitOffsetClauses?

Fig. 13.2 A fragment of the SPARQL Query Grammar [15]

sources. In particular, it includes sets of triples with some of the IRIs or blank elements 
replaced by variables, called “triple blocks” (TB in the grammar), an operator
for collecting triples and blocks (denoted by {A . B}, and with no ﬁxed arity),
an operator UNION for specifying alternatives, an operator OPTIONAL to provide
optional matchings, and an operator FILTER that allows ﬁltering results of patterns
under certain basic constraints.

Example 13.1 Consider the following query: “Give the name and the mailbox of
each person who has a mailbox with domain .cl”. This query can be expressed in
SPARQL as follows:

PREFIX foaf:
PREFIX ex:

<http://xmlns.com/foaf/0.1/>
<http://example.com/ns#>

SELECT ?name ?mbox
FROM
WHERE

{

<myDataSource.rdf>

?x

foaf:name

?name .

286

M. Arenas et al.

foaf:mbox

?mbox .

?x
?mbox

ex:domain

".cl"

}

The ﬁrst two lines in this example form the Prologue of the query, which speciﬁes 
the namespaces to be used. In this case, one is the well-known FOAF ontology,
and the other one is an example namespace. The keywords foaf and ex are abbreviations 
for the namespaces, which are used in the body of the query.

The SELECT keyword indicates that the query returns a table with two columns,
corresponding to the values obtained from the matching of the variables ?name and
?mbox against the graph pointed to in the FROM clause (myDataSource.rdf),
and according to the pattern described in the WHERE clause. It should be noticed
that a string starting with the symbol ? denotes a variables in SPARQL.

In the above query, the WHERE clause is composed by a pattern with three triples:
?x foaf:name ?name, ?x foaf:mbox ?mbox and ?mbox ex:domain
".cl", where .cl is a literal. This pattern indicates that one is looking for the
elements ?x, ?name and ?mbox in the RDF graph myDataSource.rdf such
that the foaf:name of ?x is ?name, the foaf:mbox of ?x is ?mbox and the
ex:domain of ?mbox is .cl. Thus, an expression of the form {A . B} in
SPARQL denotes the conjunction of A and B, as this expression holds if both A
and B holds.

13.2.3 More Complex Queries

SPARQL allows to write more complex queries than the ones presented in the previous 
section. The syntax of these queries becomes slightly involved and, in particular,
two important issues are the use of the OPTIONAL and of the FILTER operator. We
discuss these issues in this section.

Example 13.2 (Querying optional values) Consider the following query: “Give the
name and the mailbox, if it is provided, of each person in the FOAF ﬁle of Bob”.
This query can be expressed in SPARQL as follows:

PREFIX foaf: <http://xmlns.com/foaf/0.1/>

SELECT ?name ?mbox
FROM
WHERE

{

<http://example.org/foaf/bobFoaf>

foaf:name ?name .

?x
OPTIONAL { ?x

foaf:mbox

?mbox }

}

In this case, the WHERE clause is composed by the conjunction of two patterns, the
triple pattern ?x foaf:name ?name and the optional pattern:

OPTIONAL { ?x

foaf:mbox

?mbox },

13 On the Semantics of SPARQL

287

which in turn includes the triple pattern ?x foaf:mbox ?mbox. The WHERE
clause indicates that one is looking for the elements ?name and ?mbox in the RDF
graph http://example.org/foaf/bobFoaf such that the foaf:name of
?x is ?name and the foaf:mbox of ?x is ?mbox, provided that ?x has a
foaf:mbox. In the case where ?x does not have a mailbox, the variable ?mbox
is not instantiated and, thus, the corresponding tuple in the answer table only has a
value in the attribute ?name.

As shown in the previous example, the keyword OPTIONAL in the W3C
SPARQL syntax works as a unary operator. In the following example, we show
a query where this operator has to be used in conjunction with the notion of named
graph.

Example 13.3 (Querying different data sources) Consider the following query: “For
every person known by Alice and Bob, give the nicknames by which are known by
Alice and Bob.” We note that in this case the query must be posed against two
different data sets, the FOAF data of Bob and of Alice. Moreover, it could be the
case that Bob and Alice know different nicknames for a person, or that Bob knows a
nickname for a person which is not known by Alice, or vice versa. Hence, to express
the query in SPARQL, we need to use named graphs and the OPTIONAL operator:

PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX data: <http://example.org/foaf/>

SELECT ?nickA ?nickB
FROM NAMED <http://example.org/foaf/aliceFoaf>
FROM NAMED <http://example.org/foaf/bobFoaf>
WHERE

{

}

GRAPH data:bobFoaf { ?x foaf:knows ?comm .

OPTIONAL { ?comm foaf:nick ?nickB } } .

GRAPH data:aliceFoaf { ?y foaf:knows ?comm .

OPTIONAL { ?comm foaf:nick ?nickA } }

Notice that in the WHERE clause, the operator GRAPH is used to specify over which
dataset the pattern enclosed in braces should be matched. Also, notice the use of the
OPTIONAL operator to avoid losing information for people that only has a registered 
nickname in the FOAF data of either Alice or Bob.

It is important to notice that nesting of optional patterns is allowed in the ofﬁcial
speciﬁcation of SPARQL [15]. Unfortunately, the rules that deﬁne this nesting are
rather involved (see rules 20–23 in [15]).

As mentioned above, the operator FILTER is another interesting and complex
feature of SPARQL. More speciﬁcally, SPARQL ﬁlters restrict the solutions of a
graph pattern match according to a given expression, which includes several functions 
and operators that are deﬁned over the elements of the RDF graphs and the
variables of SPARQL queries. A subset of these functions and operators are taken

288

M. Arenas et al.

from XQuery and XPath (see [15] for further details). Among them, one of the
most useful is the unary operator bound(?x), which checks if the variable ?x is
bounded in the answer (this turns out to be really useful in combination with the
OPTIONAL operator [1]). The functions isIRI, isBlank and isLiteral play
similar roles. As expected, the Boolean connectives OR, AND and NOT (denoted
by logical-or, logical-and and !, respectively) have also been included, as
well as some functionalities for checking equality and order. The following example
shows one of these features.

Example 13.4 (Filtering values) Consider the following query: “Give the list of people 
for whom Alice knows at least two nicknames.” This query can be expressed by
the following SPARQL query:

PREFIX foaf: <http://xmlns.com/foaf/0.1/>

SELECT ?y
FROM <http://example.org/foaf/aliceFoaf>
WHERE

{

}

?x foaf:knows ?y .
?y foaf:nick ?nick1 .
?y foaf:nick ?nick2 .
FILTER (?nick1 != ?nick2) }

The ﬁlter expression FILTER (?nick1 != ?nick2) is used to check that the
nicknames ?nick1 and ?nick2 of ?y are distinct. Thus, this expression is used
to ensure that Alice knows at least two distinct nicknames for ?y.

We conclude our discussion by pointing out that one important aspect of
SPARQL is the scope of the FILTER operator, which is a source of difﬁculties
in the current speciﬁcation of SPARQL (see [1] for more details).

13.2.4 Final Remarks

We conclude this section by providing a list of some important syntactic features
of SPARQL, which are widely used in practice (for a complete list see the ofﬁcial
speciﬁcation of SPARQL [15]).
• A literal in SPARQL is a string (enclosed in either double quotes or single quotes),
with either an optional language tag (introduced by @) or an optional datatype IRI
or preﬁxed name (introduced by ^^).
• Variables are preﬁxed by either “?” or “$”, and these two symbols are not considered 
to be part of the variable name. Furthermore, variables in SPARQL queries
have global scope; the use of a given variable name anywhere in a query identiﬁes
the same variable.

13 On the Semantics of SPARQL

289

• There is syntactic sugar for expressing namespaces. As we pointed out, in general
it is more convenient to declare them in the Prologue of the query, but this is
not mandatory. For example, these three expressions represent the same query:

PREFIX
SELECT
WHERE

dc: <http://purl.org/dc/elements/1.1/>
?title
{ <http://example.org/book/book1> dc:title ?title }

PREFIX
PREFIX
SELECT
WHERE

BASE
PREFIX
SELECT
WHERE

dc: <http://purl.org/dc/elements/1.1/>
: <http://example.org/book/>
$title
{ :book1

$title }

dc:title

<http://example.org/book/>
dc: <http://purl.org/dc/elements/1.1/>
$title
{ <book1>

?title }

dc:title

The clause BASE is used to indicate the base IRI for a query. In the last example,
 this base IRI is http://example.org/book/ and, thus, the element
book1 in the query refers to this namespace.
• SPARQL allows a simpliﬁed notation for sets of triple patterns with a common
subject; the symbol ‘;’ can be used to express that a set of pairs is associated
with a particular subject, thus writing the subject only once. For example, the
following sequence of triples:

?x
?x

foaf:name
foaf:mbox

?name .
?mbox .

is the same in SPARQL as:

?x

foaf:name
foaf:mbox

?name ;
?mbox .

13.3 An Algebraic Syntax for SPARQL

In this section, we present the algebraic formalization of the core fragment of
SPARQL proposed in [11–13], and show that it is equivalent in expressive power
to the core fragment of SPARQL deﬁned in [15]. Thus, this formalization is used
in this chapter to give a formal semantics to SPARQL, as well as to study some
fundamental properties of this language.

We start by introducing the necessary notions about RDF (for details on the formalization 
of RDF see [7]). Assume that there are pairwise disjoint inﬁnite sets
I , B and L (IRIs [5], Blank nodes, and Literals, respectively). A triple (s, p, o) ∈
(I ∪ B) × I × (I ∪ B ∪ L) is called an RDF triple. In this tuple, s is the subject, p
the predicate and o the object. We denote the union I ∪ B ∪ L by T (RDF Terms).
Assume additionally the existence of an inﬁnite set V of variables disjoint from the
above sets.

290

M. Arenas et al.

Deﬁnition 13.1 (RDF Graph) An RDF graph [10] is a set of RDF triples. If G is an
RDF graph, then term(G) is the set of elements of T appearing in the triples of G,
and blank(G) is the set of blank nodes appearing in G (blank(G) = term(G) ∩ B).

SPARQL queries are evaluated against an RDF dataset [15], that is, a set of RDF
graphs in which every graph is identiﬁed by an IRI, except for a distinguished graph
in the set called the default graph. Formally, an RDF dataset is a set:

D = (cid:2)

G0,(cid:5)u1, G1(cid:6), . . . ,(cid:5)un, Gn(cid:6)(cid:3)

where G0, . . . , Gn are RDF graphs, u1, . . . , un are distinct IRIs, and n ≥ 0. In the
dataset, G0 is the default graph, and the pairs (cid:5)ui , Gi(cid:6) are named graphs, with ui
being the name of Gi. We assume that every dataset D is equipped with a function
dD such that dD(u) = G if (cid:5)u, G(cid:6) ∈ D and dD(u) = ∅, otherwise. Additionally,
name(D) stands for the set of IRIs that are names of graphs in D, and term(D)
and blank(D) stand for the set of terms and blank nodes appearing in the graphs
of D, respectively. For the sake of simplicity, and without loss of generality, we
assume that the graphs in a dataset have disjoint sets of blank nodes, i.e., for i (cid:9)= j ,
blank(Gi ) ∩ blank(Gj ) = ∅.

As we have seen in the previous section, the ofﬁcial syntax of SPARQL [15]
considers operators GRAPH, OPTIONAL, UNION, FILTER and conjunction via a
point symbol (.). The syntax also considers { } to group patterns, and some implicit 
rules of precedence and association. For example, the point symbol (.) has
precedence over OPTIONAL, and OPTIONAL is left associative. In order to avoid
ambiguities in the parsing, in this section, we present the syntax of SPARQL graph
patterns in a more traditional algebraic formalism, using binary operators AND (.),
UNION (UNION), OPT (OPTIONAL), FILTER (FILTER) and GRAPH (GRAPH).
We fully parenthesize expressions making explicit the precedence and association
of operators.
To deﬁne the algebraic syntax of SPARQL, we need to introduce the notions of
triple pattern and basic graph pattern. A triple pattern is a tuple t ∈ (I ∪ L ∪ V ) ×
(I ∪ V ) × (I ∪ L ∪ V ), and a basic graph pattern is a ﬁnite set of triple patterns.
Notice that a triple pattern is essentially an RDF triple with some positions replaced
by variables. Also notice that in our deﬁnitions of triple and basic graph pattern,
we are not considering blank nodes. We make this simpliﬁcation here to focus on
the pattern matching part of the language. In Sect. 13.4.1, we discuss how these
deﬁnitions should be extended to deal with blank nodes in basic graph patterns.

We use basic graph patterns as the base case for the syntax of SPARQL graph
pattern expressions. A SPARQL graph pattern expression is deﬁned recursively as
follows:

1. A basic graph pattern is a graph pattern.
2. If P1 and P2 are graph patterns, then expressions (P1 AND P2), (P1 OPT P2) and
(P1 UNION P2) are graph patterns (conjunction graph pattern, optional graph
pattern, and union graph pattern, respectively).
3. If P is a graph pattern and X ∈ I ∪ V , then (X GRAPH P ) is a graph pattern.

13 On the Semantics of SPARQL

291

(P FILTER R) is a graph pattern (a ﬁlter graph pattern).

4. If P is a graph pattern and R is a SPARQL built-in condition, then the expression
A SPARQL built-in condition is constructed using elements of the set I ∪ L ∪ V
and constants, logical connectives (¬, ∧, ∨), ordering symbols (<, ≤, ≥, >), the
equality symbol (=), unary predicates like bound, isBlank, and isIRI, plus other
features (see [15] for a complete list). In this chapter, we restrict to the fragment of
SPARQL where a built-in condition is a Boolean combination of terms constructed
by using = and bound, that is:
1. If ?X, ?Y ∈ V and c ∈ I ∪ L, then bound(?X), ?X = c and ?X =?Y are (atomic)
2. If R1 and R2 are built-in conditions, then (¬R1), (R1 ∨ R2) and (R1 ∧ R2) are

built-in conditions.

built-in conditions.

Let P be a SPARQL graph pattern. In the rest of this chapter, we use var(P ) to
denote the set of variables occurring in P . In particular, if P is a basic graph pattern,
then var(P ) denotes the set of variables occurring in the triple patterns that form P .
Similarly, for a built-in condition R, we use var(R) to denote the set of variables
occurring in R.

We conclude the deﬁnition of the algebraic framework by describing the formal
syntax of the SELECT query result form. A SELECT SPARQL query is simply a
tuple (W, P ), where P is a SPARQL graph pattern expression and W is a set of
variables such that W ⊆ var(P ).

13.3.1 Translating SPARQL into the Algebraic Formalism

In this section, we show that every SPARQL query can be translated into the algebraic 
terminology introduced above. But before providing the procedure that performs 
this translation, we show how the examples of Sect. 13.2 can be written in the
algebraic formalism.

Example 13.5 First, consider the query “Give the name and the mailbox of each
person who has a mailbox with domain .cl” from Example 13.1. The following
algebraic expression represents this query (when evaluated over the RDF graph
myDataSource.rdf):

({?name, ?mbox},

((?x, http://xmlns.com/foaf/0.1/name, ?name) AND
(?x, http://xmlns.com/foaf/0.1/mbox, ?mbox) AND
(?mbox, http://example.com/ns#domain, ".cl")))

Second, consider the query “Give the name and the mailbox, if it is provided, of
each person in the FOAF ﬁle of Bob”, which was considered in Example 13.2. The
following algebraic expression represents this query (when evaluated over the graph
http://example.org/foaf/bobFoaf):

292

M. Arenas et al.

({?name, ?mbox},

((?x, http://xmlns.com/foaf/0.1/name, ?name) OPT

(?x, http://xmlns.com/foaf/0.1/mbox, ?mbox)))

Third, consider the query: “For every person known by Alice and Bob, give the
nicknames by which are known by Alice and Bob” from Example 13.3. This query
can be expressed as follows in the algebraic formalism:

({?nickA, ?nickB},

((http://example.org/foaf/bobFoaf GRAPH

((?x, http://xmlns.com/foaf/0.1/knows, ?comm) OPT

(?comm, http://xmlns.com/foaf/0.1/nick, ?nickB))) AND

(http://example.org/foaf/aliceFoaf GRAPH

((?y, http://xmlns.com/foaf/0.1/knows, ?comm) OPT

(?comm, http://xmlns.com/foaf/0.1/nick, ?nickA)))))

Finally, consider the query: “Give the list of people for whom Alice knows at least
two nicknames” from Example 13.4. The following expression represents this query
(when evaluated over the graph http://example.org/foaf/aliceFoaf):

({?y},

(((?x, http://xmlns.com/foaf/0.1/knows, ?y) AND

(?y, http://xmlns.com/foaf/0.1/nick, ?nick1) AND
(?y, http://xmlns.com/foaf/0.1/nick, ?nick2))

FILTER (?nick1 != ?nick2)))

In Algorithm 13.1, we show a transformation function T of patterns in the
SPARQL syntax into the algebraic formalism presented in this section. For the
sake of readability, we assume that the translation of Triple Blocks (TB) is given
(this translation is straightforward, but tedious due to the multiple representations
of triples allowed in the SPARQL syntax).

Algorithm 13.1 Transformation T of SPARQL pattern syntax into algebraic syntax
1: // Input: a SPARQL graph pattern GroupGP
2: // Output: an algebraic expression E = T (GroupGP)
3: E ← ∅; FS ← ∅
4: for each syntactic form f in GroupGP do
if f is TB then E ← (E AND T (TB))
5:
if f is OPTIONAL GroupGP1 then E ← (E OPT T (GroupGP1))
6:
if f is GroupGP1 UNION ··· UNION GroupGPn then
7:
if n > 1 then E
8:
else E
9:
E ← (E AND E
10:
if f is GRAPH VarOrIRIref GroupGP1 then
11:
E ← (E AND (VarOrIRIref GRAPH T (GroupGP1)))
12:
if f is FILTER constraint then FS ← (FS ∧ constraint)
13:
14: end for
15: if FS (cid:9)= ∅ then E ← (E FILTER FS)

(cid:15) ← (T (GroupGP1) UNION ··· UNION T (GroupGPn))
(cid:15)

(cid:15) ← T (GroupGP1)

)

13 On the Semantics of SPARQL

293

For example, consider the following pattern written according to the ofﬁcial syntax 
of SPARQL:

{

}

?x :age ?y
FILTER (?y > 30)
?x :knows ?z .
?z :home_country ?c
FILTER (?c = "Chile")
OPTIONAL { ?z :phone ?p }

Following the grammar of SPARQL given in Fig. 13.2, the above pattern is parsed as
a single GroupGP that contains the syntactic forms TB, Filter, TB, Filter and
OptionalGP (in that order), with the OptionalGP syntactic form containing a
GroupGP composed by a single TB syntactic form.
The translation function in Algorithm 13.1 starts with E = {} and FS = {}. Then

it considers all the syntactic forms in the pattern obtaining that:

(cid:5)
E = (cid:4)(cid:4)(cid:4){} AND T (TB1)
FS = (cid:4)

(cid:5)
AND T (TB2)
(cid:5)
?Y > 30 ∧ ?C = Chile

(cid:5)
OPT T (GroupGP1)

where TB1 is ?x :age ?y, TB2 is ?x :knows ?z . ?z :home_country ?c,
and GroupGP1 is { ?z :phone ?p }. The translations T (TB1) and T (TB2) are
simply {(?X, :age, ?Y )} and {(?X, :knows, ?Z), (?Z, :home_country, ?C)}, respectively.
 To compute T (GroupGP1), the algorithm proceeds recursively and gives as
output the pattern:

(cid:15) = (cid:4){} AND

(cid:2)
(?Z, :phone, ?P )

(cid:3)(cid:5)

E

Thus, the ﬁnal output of the algorithm is:
(cid:3)(cid:5)

(cid:6)(cid:4)(cid:4)(cid:4){} AND
AND

(cid:2)
(?X, :age, ?Y )
(cid:2)
(?X, :knows, ?Z), (?Z, :home_country, ?C)

(cid:3)(cid:5)

(cid:4){} AND

(cid:2)

OPT

(?Z, :phone, ?P )

(cid:3)(cid:5)(cid:5)

FILTER

(cid:5)(cid:7)
(cid:4)
?Y > 30 ∧ ?C = Chile

13.4 Semantics of SPARQL

To deﬁne the semantics of SPARQL graph pattern expressions, we use the algebraic
representation of SPARQL introduced in the previous section.
We start by introducing some terminology. A mapping μ from V to T is a partial
function μ : V → T . The domain of μ, denoted by dom(μ), is the subset of V
where μ is deﬁned. The empty mapping μ∅ is a mapping such that dom(μ∅) = ∅
(i.e. μ∅ = ∅). Given a triple pattern t and a mapping μ such that var(t ) ⊆ dom(μ),

294

M. Arenas et al.

μ(t ) is the triple obtained by replacing the variables in t according to μ. Similarly,
given a basic graph pattern P and a mapping μ such that var(P ) ⊆ dom(μ), we
have that μ(P ) = (cid:8)
{μ(t )}, i.e., μ(P ) is the set of triples obtained by replacing
the variables in the triples of P according to μ.
We can now deﬁne the semantics for basic graph patterns as a function J·KG that

t∈P

given a basic graph pattern P returns a set of mappings.

Deﬁnition 13.2 Let G be an RDF graph, and P a basic graph pattern. The evaluation 
of P over G, denoted by JP KG, is deﬁned as the set of mappings
(cid:3)
μ : V → T | dom(μ) = var(P ) and μ(P ) ⊆ G

JP KG = (cid:2)

Notice that for every RDF graph G, it holds that J{} KG = {μ∅}, i.e. the evaluation 
of an empty basic graph pattern against any graph results in the set containing 
only the empty mapping. For every basic graph pattern P (cid:9)= {}, we have that
JP K∅ = ∅.
To deﬁne the semantics of more complex patterns, we need to introduce some
more notions. Two mappings μ1 and μ2 are compatible when for all x ∈ dom(μ1)∩
dom(μ2), it is the case that μ1(x) = μ2(x), i.e., when μ1 ∪ μ2 is also a mapping.
Intuitively, μ1 and μ2 are compatible if μ1 can be extended with μ2 to obtain a new
mapping, and vice versa. Note that two mappings with disjoint domains are always
compatible and that the empty mapping μ∅ is compatible with every other mapping.
Let Ω1 and Ω2 be sets of mappings. We deﬁne the join of, the union of and the

difference between Ω1 and Ω2 as:
Ω1 (cid:2)(cid:3) Ω2 = {μ1 ∪ μ2 | μ1 ∈ Ω1, μ2 ∈ Ω2 and μ1, μ2 are compatible mappings}
Ω1 ∪ Ω2 = {μ | μ ∈ Ω1 or μ ∈ Ω2}
Ω1 (cid:4) Ω2 = {μ ∈ Ω1 | for all μ

are not compatible}

(cid:15) ∈ Ω2, μ and μ

(cid:15)

Based on the previous operators, we deﬁne the left outer-join as:

Ω1 Ω2 = (Ω1 (cid:2)(cid:3) Ω2) ∪ (Ω1 (cid:4) Ω2)

Intuitively, Ω1 (cid:2)(cid:3) Ω2 is the set of mappings that result from extending mappings in
Ω1 with their compatible mappings in Ω2, and Ω1 (cid:4) Ω2 is the set of mappings in
Ω1 that cannot be extended with any mapping in Ω2. The operation Ω1 ∪ Ω2 is the
usual set theoretical union. A mapping μ is in Ω1 Ω2 if it is the extension of a
mapping of Ω1 with a compatible mapping of Ω2, or if it belongs to Ω1 and cannot 
be extended with any mapping of Ω2. These operations resemble the relational
algebra operations but over sets of mappings (partial functions).
We are ready to deﬁne the semantics of SPARQL graph pattern expressions as a
function J· KD
G which given a dataset D and a (target) graph G in D, takes a pattern
expression and returns a set of mappings. For the sake of readability, the semantics
of ﬁlter expressions is presented in a separate deﬁnition.

13 On the Semantics of SPARQL

295

Deﬁnition 13.3 Let D be an RDF dataset and G an RDF graph in D. The evaluation
of a graph pattern P over G in the dataset D, denoted by J· KD
G , is deﬁned recursively
as follows:
1. if P is a basic graph pattern, then JP KD
= JP1KD
2. if P is (P1 AND P2), then JP KD
= JP1KD
3. if P is (P1 OPT P2), then JP KD
= JP1KD
4. if P is (P1 UNION P2), then JP KD
5. if P is (X GRAPH P1), then:
= JP1KD

= JP KG.
(cid:2)(cid:3) JP2KD
G .
JP2KD
G .
∪ JP2KD
G .

G

G

G

G

G

G

G

• if X ∈ I , then JP KD
• if X ∈ V , then

G

dD (X),
= (cid:9)
v∈name(D)

JP KD

G

(cid:4)
JP1KD

dD (v)

(cid:2)(cid:3) {μX→v}(cid:5)

where μX→v is a mapping such that dom(μ) = {X} and μ(X) = v.

Given a dataset D with default graph G0, and a SPARQL pattern P , we say that the
evaluation of P over dataset D, denoted by JP KD

, is simply JP KD

.

G0

The idea behind the OPT operator is to allow for optional matching of patterns.
Consider pattern expression (P1 OPT P2) and let μ1 be a mapping in JP1KD
G . If there
exists a mapping μ2 ∈ JP2KD
G such that μ1 and μ2 are compatible, then μ1 ∪ μ2 belongs 
to J(P1 OPT P2)KD
G . But if no such a mapping μ2 exists, then μ1 belongs to
J(P1 OPT P2)KD
G . Thus, operator OPT allows information to be added to a mapping
μ if the information is available, instead of just rejecting μ whenever some part of
the pattern does not match. This feature of optional matching is crucial in Semantic
Web applications, and more speciﬁcally in RDF data management, where it is assumed 
that every application has only partial knowledge about the resources being
managed.

The operator GRAPH is used to change the target RDF graph over which a pattern 
is being evaluated. An expression of the form (X GRAPH P ), with X an IRI
and P a graph pattern, is used to change the target RDF graph to the one whose
name is X, and then to continue evaluating P over that RDF graph. The expression
(X GRAPH P ), with X a variable, is used to evaluate the pattern P over all the
named RDF graphs in a dataset D, and its result is the union of all these evaluations.
Notice that before taking the union, for every v ∈ name(D), the set of mappings
obtained by evaluating pattern P over dD(v) is joined with a mapping that assigns
to variable X the value v. It should also be noticed that GRAPH is the only operator
that can change the target RDF graph. Thus, if a pattern P does not contain any
GRAPH expression, then the entire pattern is evaluated over a single RDF graph
(the default graph of the RDF dataset). Therefore, if P is a SPARQL graph pattern
expression that does not contain any GRAPH sub-expression, we simply write JP KG
to denote the set JP KD
G . We use this notation in the following section when studying
the complexity of evaluating graph pattern expressions.

296

M. Arenas et al.

The semantics of ﬁlter expressions goes as follows. Given a mapping μ and a
built-in condition R, we deﬁne a notion of satisfaction of R by μ, denoted by μ |= R,
in a three valued logic (with values true, false and error). For an atomic builtin 
condition of the form ?X = c, if ?X /∈ dom(μ) the evaluation results in error;
else, the evaluation results in true if μ(?X) = c and results in false otherwise.
Similarly, for an atomic built-in condition of the form ?X =?Y , if ?X /∈ dom(μ) or
?Y /∈ dom(μ) the evaluation results in error; else, the evaluation results in true
if μ(?X) = μ(?Y ) and results in false otherwise. For the case of bound(?X), the
evaluation results in true if ?X ∈ dom(μ), and in false otherwise. For non-atomic
constraints, the evaluation is deﬁned as usual in a three valued logic:

R1

true
true
true
error
error
error
false
false
false

R2

true
error
false
true
error
false
true
error
false

R1 ∧ R2 R1 ∨ R2

true
error
false
error
error
false
false
false
false

true
true
true
true
error
error
true
error
false

R1

true
error
false

¬R1

false
error
true

Then μ |= R if and only if the evaluation of R against μ results in true.
Deﬁnition 13.4 Given an RDF dataset D, an RDF graph G in D, and a ﬁlter ex-
| μ |= R}.
pression (P FILTER R), we have that J(P FILTER R)KD

= {μ ∈ JP KD

G

G

Several algebraic properties of graph patterns are proved in [11]. A simple property 
is that AND and UNION are associative and commutative. This permits us
to avoid parentheses when writing sequences of AND operators or UNION operators.
 This is consistent with the deﬁnitions of Group Graph Pattern and Union
Graph Pattern in [15]. To simplify the notation, when considering basic graph patterns 
composed by a single triple pattern {t}, we do not write the braces enclosing 
t. For example, for the pattern (({t1} UNION {t2}) OPT {t3}), we simply write
((t1 UNION t2) OPT t3). The following lemma shows that the base case for the syntax 
and semantics of SPARQL can also be deﬁned in terms of triple patterns (instead
of sets of triple patterns), as the semantics of basic graph patterns can be obtained
by using the AND operator between triple patterns.
Lemma 13.1 Let {t1, t2, . . . , tn} be a basic graph pattern, where n ≥ 1. Then for
every dataset D, it holds that:

(cid:6)(cid:6){t1, t2, . . . , tn}(cid:7)(cid:7)D = (cid:6)(cid:6)

(t1 AND t2 AND ··· AND tn)

(cid:7)(cid:7)D

To formally deﬁne the semantics of SELECT SPARQL queries, we need the
following notion. Given a mapping μ : V → T and a set of variables W ⊆ V ,

13 On the Semantics of SPARQL

297

the restriction of μ to W , denoted by μ|W , is a mapping such that dom(μ|W ) =
dom(μ) ∩ W and μ|W (?X) = μ(?X) for every ?X ∈ dom(μ) ∩ W .
Deﬁnition 13.5 Given a SELECT query (W, P ), the evaluation of (W, P ) in a
dataset D is the set of mappings J(W, P )KD = {μ|W

| μ ∈ JP KD}.

In the rest of this chapter, we usually represent sets of mappings as tables where
each row represents a mapping in the set. We label every row with the name of a
mapping, and every column with the name of a variable. If a mapping is not deﬁned 
for some variable, then we simply leave empty the corresponding position.
For instance, the table:

?X ?Y
b
a
c

μ1 :
μ2 :
μ3 :

?Z ?V

?W

d

e

represents the set of mappings Ω = {μ1, μ2, μ3}, where:

dom(μ1) = {?X, ?Y},
dom(μ2) = {?Y, ?W},
dom(μ3) = {?Z},

μ1(?X) = a,
μ2(?Y ) = c,
and μ3(?Z) = e

and μ1(?Y ) = b
and μ2(?W ) = d

We sometimes write {{?X → a, ?Y → b},{?Y → c, ?W → d},{?Z → e}} for a set
of mappings as the one above.

Example 13.6 Consider an RDF graph G storing information about professors in a
university:
G = (cid:2)

(B1, name,
(B1, phone,
(B2, email,
(B2, name,
(B3, webPage, www.george.edu),
(B3, name,
(B4, email,
(B4, name,
(B4, webPage, www.starr.edu), (B4, phone,

ringo@acd.edu),
(cid:3)
888-4537)

paul),
john),
george),
ringo),

777-3426),
john@acd.edu),

Let D be an RDF dataset with G as its default graph and with no named graphs.
The following are graph pattern expressions and their evaluations over D. Since
the graph patterns do not use the GRAPH operator, we denote their evaluation
by J·KG.
– P1 = ((?A, email, ?E) OPT (?A, webPage, ?W )). Then

?A ?E

?W

JP1KG =

μ1 : B2
μ2 : B4

john@acd.edu
ringo@acd.edu www.starr.edu

298

M. Arenas et al.

– P2 = (((?A, name, ?N ) OPT (?A, email, ?E)) OPT (?A, webPage, ?W )). Then

JP2KG =

?A
μ1 : B1
μ2 : B2
μ3 : B3
μ4 : B4

?N
paul
john
george
ringo

?E

?W

john@acd.edu

ringo@acd.edu

www.george.edu
www.starr.edu

– P3 = ((?A, name, ?N ) OPT ((?A, email, ?E) OPT (?A, webPage, ?W ))). Then

JP3KG =

?A
μ1 : B1
μ2 : B2
μ3 : B3
μ4 : B4

?N
paul
john
george
ringo

?E

?W

john@acd.edu

ringo@acd.edu www.starr.edu

Notice the difference between JP2KG and JP3KG. These two examples show that
J((A OPT B) OPT C)KG (cid:9)= J(A OPT (B OPT C))KG in general.
– P4 = ((?A, name, ?N ) AND ((?A, email, ?E) UNION (?A, webPage, ?W ))).
Then

JP4KG =

?A
μ1 : B2
μ2 : B3
μ3 : B4
μ4 : B4

?N
john
george
ringo
ringo

?E

?W

john@acd.edu

ringo@acd.edu

www.george.edu

www.starr.edu

– P5 = (((?A, name, ?N ) OPT (?A, phone, ?P )) FILTER (?N = paul)). Then

JP5KG =
– P6 = (((?A, name, ?N ) OPT (?A, phone, ?P )) FILTER (¬ bound(?P ))). Then

?A ?N
paul

μ1 : B1

?P

777-3426

JP6KG =

?A
μ1 : B2
μ2 : B3

?N
john
george

?P

The following example shows the evaluation of patterns that use operator

GRAPH.

H = (cid:2)

Example 13.7 Let G be the graph in Example 13.6 and consider the following RDF
graph H :

(R1, name, mick), (R1, email, mj@acd.edu),
(cid:3)
(R2, name, keith), (R2, email, keith@acd.edu)

Let D = {∅,(cid:5)tb, G(cid:6),(cid:5)trs, H(cid:6)} be an RDF dataset with empty default graph. The
following are graph pattern expressions and their evaluations over D.

13 On the Semantics of SPARQL

299

– P7 = (trs GRAPH (?A, name, ?N )). Then
?A
?N
R1 mick
keith
R2

JP7KD =

μ1 :
μ2 :

– P8 = (?G GRAPH {(?A, name, ?N ), (?A, email, ?E)}). Then
?E

JP8KD =

μ1 :
μ2 :
μ3 :
μ4 :

?G
tb
tb
trs
trs

?A
B2
B4
R1
R2

?N
john
ringo
mick
keith

john@acd.edu
ringo@acd.edu
mj@acd.edu
keith@acd.edu

Finally, the following example shows the evaluation of a SELECT pattern.

Example 13.8 Let D be the dataset in Example 13.7 and consider the pattern P8 in
that example. Then the evaluation of the SELECT query ({?G, ?N, ?E}, P8) over D
is the following set of mappings:

(cid:6)(cid:6)(cid:4){?G, ?N, ?E}, P8

(cid:5)(cid:7)(cid:7)
=

μ1 :
μ2 :
μ3 :
μ4 :

?G
tb
tb
trs
trs

?N
john
ringo
mick
keith

?E

john@acd.edu
ringo@acd.edu
mj@acd.edu
keith@acd.edu

13.4.1 Blank Nodes in Graph Patterns

The ofﬁcial speciﬁcation of SPARQL [15] allows basic graph patterns to have blank
nodes in their triple patterns. Blank nodes in graph patterns are essentially deﬁned
as variables whose values cannot be retrieved by a query. In what follows, we extend
the deﬁnitions of the previous sections to consider graph patterns with blank nodes.
We extend the deﬁnition of triple patterns to be tuples in the set (T ∪ V ) ×
(I ∪ V ) × (T ∪ V ), that is, triple patterns are now allowed to have blank nodes as
components. Similarly, we extend the deﬁnition of basic graph patterns. Also for a
triple pattern t and a basic graph pattern P , we deﬁne blank(t ) and blank(P ) as the
sets of blank nodes appearing in t and P , respectively.

Deﬁnition 13.6 Let G be an RDF graph and P a basic graph pattern with blank
nodes. Then the evaluation of P over G, denoted by JP KG, is deﬁned as the set of
all mappings μ such that:
• dom(μ) = var(P ),
• and there exists a substitution θ : blank(P ) → term(G) such that μ(θ (P )) ⊆ G,
where θ (P ) is the basic graph pattern that results from replacing the blank nodes of
P according to θ.

300

M. Arenas et al.

This deﬁnition extends the deﬁnition of the semantics of a basic graph pattern
P not mentioning blanks nodes, as by using the substitution θ : ∅ → term(G),
we obtain the same set of mappings as in Deﬁnition 13.2 for pattern P (since
θ (P ) = P ).
Now, given a dataset D and a general graph pattern P constructed from basic
graph patterns possibly with blank nodes, the evaluation of P over D is deﬁned as
in the previous section but with Deﬁnition 13.6 as the base case.

Example 13.9 Let G be the RDF graph in Example 13.6, and consider the basic
graph pattern P = {(X, name, ?N ), (X, email, ?E)}, where X is a blank node.
Notice that, if we use a substitution θ : blank(P ) → term(G) such that θ (X) =
B2, and a mapping μ = {?N → john, ?E → john@acd.edu}, then we have that
μ(θ (P )) ⊆ G. Thus, μ is in the evaluation of P over G. In fact, the evaluation of P
over G is the set of mappings:
JP KG =

?E

μ1 :
μ2 :

?N
john
ringo

john@acd.edu
ringo@acd.edu

13.4.2 Bag Semantics of SPARQL

A bag Ω of mappings is a set of mappings in which every mapping is annotated with
a positive integer that represents its cardinality in Ω. We denote the cardinality of
the mapping μ in the bag Ω by cardΩ (μ) (or simply card(μ) when Ω is understood
from the context). If μ /∈ Ω, then cardΩ (μ) = 0.

In Sect. 13.4, we consider operations between sets of mappings. Those operations
can be extended to bags by, roughly speaking, making the operations not to discard
duplicates. Formally, if Ω1, Ω2 are bags of mappings, then:

for μ ∈ Ω1 (cid:2)(cid:3) Ω2,
for μ ∈ Ω1 ∪ Ω2,
for μ ∈ Ω1 (cid:4) Ω2,

cardΩ1 (μ1) · cardΩ2 (μ2)

cardΩ1(cid:2)(cid:3)Ω2 (μ) = (cid:10)
μ=μ1∪μ2
cardΩ1∪Ω2 (μ) = cardΩ1 (μ) + cardΩ2 (μ)
cardΩ1(cid:2)Ω2 (μ) = cardΩ1 (μ)

The bag semantics of basic graph patterns that contain blank nodes is formalized
in the following deﬁnition. This formalization is used as the base case for the bag
semantics of SPARQL graph patterns.

Deﬁnition 13.7 Consider a basic graph pattern P (possibly with blank nodes) and
an RDF graph G. The cardinality of the mapping μ ∈ JP KG is deﬁned as the number
of distinct substitutions θ : blank(P ) → term(G) such that μ(θ (P )) ⊆ G, i.e.,

cardJP KG (μ) = (cid:11)(cid:11)(cid:2)

θ : blank(P ) → term(G) | μ

(cid:4)
θ (P )

(cid:3)(cid:11)(cid:11)
(cid:5) ⊆ G

13 On the Semantics of SPARQL

301

For a basic graph pattern P , without blank nodes, every solution μ ∈ JP KG has
cardinality 1, as in this case the only possible substitution is θ : ∅ → term(G).
Given a dataset D and a general graph pattern P constructed from basic graph
patterns possibly with blank nodes, we deﬁne the bag semantics of P over D simply
as in Deﬁnition 13.3, but applying bag operators and considering the semantics of
basic graph patterns as in Deﬁnition 13.7.
We deﬁne now the bag semantics of SPARQL SELECT queries. Informally,
when considering bag semantics, to evaluate a SELECT query q = (W, P ), we
simply take the projection of the evaluation of P over W but without discarding
duplicates. Formally, given a SPARQL SELECT query (W, P ) and a mapping μ in
the evaluation of (W, P ) over a dataset D, we deﬁne the cardinality of μ in JP KD
as:

cardJ(W,P )KD (μ) = (cid:10)
ν∈JP KD : ν|

cardJP KD (ν).

=μ

W

Example 13.10 Consider the RDF graph:

G = (cid:2)

(cid:3)
(Alice, knows, Bob), (Alice, knows, Peter), (Bob, knows, Peter)

and the basic graph pattern P = {(?X, knows, B)} with B a blank node. Now
consider the mapping μ1 = {?X → Alice}, and the substitutions θ1 and θ2 from
blank(P ) to term(G) such that θ1(B) = Bob and θ2(B) = Peter. Then it holds that
μ1(θ1(P )) ⊆ G and that μ1(θ2(P )) ⊆ G. Thus, we have that μ1 is in JP KG and that
the cardinality of μ1 is 2. If we consider the mapping μ2 = {?X → Bob}, then we
have that μ2 is also in JP KG and that the cardinality of μ2 is 1.

Example 13.11 As an example of the evaluation of a SELECT query under bag
semantics, consider the dataset D and the pattern P8 of Example 13.7, and the SELECT 
query ({?G}, P8). Then the evaluation of ({?G}, P8) over D is composed by
the mappings μ1 = {?G → tb} and μ2 = {?G → trs}, both with cardinality 2.

13.5 On the Complexity of the Evaluation Problem

A fundamental issue in every query language is the complexity of query evaluation
and, in particular, what is the inﬂuence of each component of the language in this
complexity.

In this section, we study the complexity of the evaluation of SPARQL graph patterns,
 reviewing some of the results in the literature regarding this problem. The
ﬁrst study about the complexity of SPARQL was published in [11], and some reﬁnements 
of the complexity results of [11] were presented in [13, 17]. We present
here a study of the complexity that follows [11], considering fragments of SPARQL
graph patterns built incrementally, and presenting complexity results for each such
fragment.

302

M. Arenas et al.

In this section, we focus on the core fragment of SPARQL and, thus, we impose
the following restrictions to graph patterns and to the evaluation process. First, we
will be mainly focused on the evaluation of SPARQL patterns, that is, we do not consider 
SELECT queries, and we restrict to the evaluation over a single RDF graph,
that is, we do not consider the GRAPH operator. Second, we assume that graph patterns 
do not contain blank nodes. And third, we focus on the set semantics of graph
patterns, that is, we do not consider the cardinality of mappings when evaluating
SPARQL patterns. It would be interesting to investigate whether the complexity results 
that we present in this section can be extended to the bag-semantics case. We
left this study for future work.

As is customary when studying the complexity of the evaluation problem for a
query language [18], we consider its associated decision problem. We denote this
problem by EVALUATION and we deﬁne it as follows:

INPUT
QUESTION : Is μ ∈ JP KG?

: An RDF graph G, a graph pattern P , and a mapping μ.

It is important to recall that we are assuming that P in the above deﬁnition does
not contain blank nodes, and that JP KG is the set-based evaluation of P over the
RDF graph G. Also notice that the evaluation problem that we study considers the
mapping as part of the input. That is, we study the complexity by measuring how
difﬁcult it is to verify whether a given mapping is a solution for a pattern evaluated 
over an RDF graph. This is the standard decision problem considered when
studying the complexity of a query language [18], as opposed to the computation
problem of actually listing the set of solutions (ﬁnding all the mappings). To focus
on the associated decision problem allows us to obtain a ﬁne grained analysis of
the complexity of the evaluation problem, classifying the complexity for different
fragments of SPARQL in terms of standard complexity classes. Also notice that the
pattern P and the graph G are both inputs in the deﬁnition of EVALUATION. Thus,
we study the combined complexity of the query language [18].

We start this study by considering the fragment consisting of graph pattern
expressions constructed by using only AND and FILTER operators. This simple
fragment is interesting as it does not use the two most complicated operators in
SPARQL, namely UNION and OPT. Given an RDF graph G, a graph pattern P in
this fragment and a mapping μ, it is possible to efﬁciently check whether μ ∈ JP KG
by using the following simple algorithm [11]. First, for each triple t in P , verify
whether μ(t ) ∈ G. If this is not the case, then return false. Otherwise, by using a
bottom-up approach, verify whether the expression generated by instantiating the
variables in P according to μ satisﬁes the FILTER conditions in P . If this is the
case, then return true, else return false.
Theorem 13.1 [11] EVALUATION can be solved in time O(|P| · |G|) for graph
pattern expressions constructed by using only AND and FILTER operators.

13 On the Semantics of SPARQL

303

We continue this study by adding the UNION operator to the AND-FILTER
fragment. It is important to notice that the inclusion of UNION in SPARQL is one
of the most controversial issues in the deﬁnition of this language. The following
theorem proved in [11], shows that the inclusion of the UNION operator makes the
evaluation problem for SPARQL considerably harder.

Theorem 13.2 [11] EVALUATION is NP-complete for graph pattern expressions
constructed by using only AND, FILTER and UNION operators.

It is straightforward to prove that EVALUATION is in NP for the case of graph
pattern expressions constructed by using only AND, UNION and FILTER operators.
 The NP-hardness proof presented in [11] relies on a reduction from the satisﬁability 
problem for propositional formulas in CNF (SAT-CNF). An instance of
SAT-CNF is a propositional formula ϕ of the form C1 ∧ ··· ∧ Cn, where each Ci
(i ∈ [1, n]) is a clause, that is, a disjunction of propositional variables and negations 
of propositional variables. Then the problem is to verify whether there exists
a truth assignment satisfying ϕ. It is well known that SAT-CNF is NP-complete [6].
In the encoding presented in [11], the authors use a ﬁxed RDF graph D and a ﬁxed
mapping μ. Then they show how to encode a SAT-CNF formula by using SPARQL
variables to encode literals (propositional variables and negations of propositional
variables), AND and UNION to encode ∧ and ∨, respectively, and FILTER restrictions 
to ensure that if a truth assignment assigns value true to a literal (cid:6), then it must
assign value false to the negation of (cid:6) (and vice versa).

We now consider the OPT operator, which is the most involved operator in graph
pattern expressions and, deﬁnitively, the most difﬁcult to deﬁne. The following theorem 
proved in [11] shows that when considering all the operators in SPARQL graph
patterns, the evaluation problem becomes considerably harder.

Theorem 13.3 [11] EVALUATION is PSPACE-complete.

The membership in PSPACE is given by Algorithm 13.2. Given a mapping
μ, a pattern P , and an RDF graph G, the algorithm veriﬁes whether μ ∈ JP KG.
In the procedure, we use pos(P , G) to denote the set of mappings ν such that
dom(ν) ⊆ var(P ) and for every variable ?X ∈ dom(ν), it holds that ν(?X) is a value
in term(G).

It is easy to see that the procedure is correct (it is essentially applying the definition 
of the set-semantics of the SPARQL operators). Given that the size needed
to store the name of a variable in var(P ) is O(log|P|) and the size needed to store
an element of G is O(log|G|), we obtain that the size of a mapping in pos(P , G)
is O(|P| · (log|P| + log|G|)). Thus, given that the depth of the tree of recursive
calls to Eval is O(|P|), we have that procedure Eval can be implemented by using
a polynomial amount of space.

To prove the PSPACE-hardness of EVALUATION, the authors show in [11] how
to reduce in polynomial time the quantiﬁed boolean formula problem (QBF) to

304

M. Arenas et al.

Algorithm 13.2 Eval(μ: mapping, P : graph pattern, G: RDF graph)
1: case:
2: P is a triple pattern t:
3:
4:
5: P is a pattern of the form (P1 FILTER R):
6:
7:
8: P is a pattern of the form (P1 UNION P2):
9:
10:
11: P is a pattern of the form (P1 AND P2):
12:
13:

if dom(μ) = var(t ) and μ(t ) ∈ G then return true
return false
if Eval(μ, P1, G) = true and μ |= R then return true
return false
if Eval(μ, P1, G) = true or Eval(μ, P2, G) = true then return true
return false
for each pair of mappings μ1 ∈ pos(P1, G) and μ2 ∈ pos(P2, G)
if Eval(μ1, P1, G) = true and Eval(μ2, P2, G) = true and μ = μ1∪ μ2 then return

true
return false
if Eval(μ, (P1 AND P2), G) = true then return true
if Eval(μ, P1, G) = true then
for each mapping μ
(cid:15)
if Eval(μ
return true
return false

14:
15: P is a pattern of the form (P1 OPT P2):
16:
17:
18:
19:
20:
21:

(cid:15) ∈ pos(P2, G)

, P2, G) = true and μ is compatible with μ

(cid:15)

then return false

EVALUATION. An instance of QBF is a quantiﬁed propositional formula ϕ of the
form:

∀x1∃y1∀x2∃y2 ···∀xm∃ym ψ,

where ψ is a quantiﬁer-free formula of the form C1 ∧ ··· ∧ Cn, with each Ci
(i ∈ {1, . . . , n}) being a clause, that is, a disjunction of propositional variables and
negations of propositional variables. Then the problem is to verify whether ϕ is
valid. It is known that QBF is PSPACE-complete [6]. In the encoding presented
in [11], the authors use a ﬁxed RDF graph G and a ﬁxed mapping μ. Then they
encode formula ϕ with a pattern Pϕ that uses nested OPT operators to encode the
quantiﬁer alternation of ϕ, and a graph pattern not mentioning the optional operator
to encode the satisﬁability of formula ψ.
When verifying whether μ ∈ JP KG, it is natural to assume that the size of P is
considerably smaller than the size of G. This assumption is very common when
studying the complexity of a query language. In fact, it is named data complexity
in the database literature [18], and it is deﬁned as the complexity of the evaluation
problem for a ﬁxed query. More precisely, for the case of SPARQL, given a graph
pattern expression P , the evaluation problem for P , denoted by EVALUATION(P ),
has as input an RDF graph G and a mapping μ, and the problem is to verify whether
μ ∈ JP KG. The following result shows that the data-complexity of the evaluation
problem for SPARQL patterns is in LOGSPACE.

13 On the Semantics of SPARQL

305

Theorem 13.4 EVALUATION(P ) is in LOGSPACE for every graph pattern expression 
P .

To see why the above theorem holds, consider Algorithm 13.2. The space needed
to store a mapping in pos(P , G) is O(|P| · (log|P| + log|G|)), and this bound becomes 
O(log|G|) when P is considered to be ﬁxed. Thus, given that the depth of
the tree of recursive calls to Eval is a ﬁxed constant if P is considered to be ﬁxed,
we obtain that Eval can be implemented by using logarithmic space in this case.

13.6 Related Work

Most of the material presented in this chapter comes from [11]. At the time when
[11] was published, there were two main proposals for the semantics of SPARQL
graph pattern expressions. The ﬁrst was an operational semantics, consisting essentially 
in the execution of a depth-ﬁrst traversal of parse trees of graph pattern 
expressions, and the use of intermediate results to avoid some computations.
At that time, this approach was followed by ARQ [2] (a language developed by
HPLabs), and by the W3C when evaluating graph pattern expressions containing
nested optionals [16]. For instance, the computation of the mappings satisfying
(A OPT (B OPT C)) was done by ﬁrst computing the mappings that match A,
then checking which of these mappings match B and for those that match B checking 
whether they also match C [16]. The second approach, compositional in spirit
and the one advocated in [11], extended classical conjunctive query evaluation [7]
and was based on a bottom up evaluation of parse trees of graph pattern expressions,
borrowing notions of relational algebra evaluation [4, 8] plus some additional features.
 Currently, the ofﬁcial speciﬁcation of SPARQL [15], endorsed by the W3C,
formalizes a semantics based on [11], that we also follow in this chapter.

Since the beginning of the SPARQL standardization process by the W3C there
have been efforts to formalize the semantics of the language. In [4], Cyganiak
presents a relational model of SPARQL. The author uses modiﬁed versions of the
standard relational algebra operators (join, left outer join, projection, selection, etc.)
to model SPARQL SELECT clauses. The central idea in [4] is to make a correspondence 
between SPARQL queries and relational algebra queries over a single
relation Triple(subject, predicate, object), that stores RDF graphs in the form of
triples. In [4], the author discusses some drawbacks of using classical relational algebra 
operators to deﬁne the semantics of SPARQL, and identiﬁes cases in which
his formalization does not match the SPARQL ofﬁcial speciﬁcation. Additionally,
a translation system between SPARQL and SQL is outlined in [4]. The system extensively 
uses COALESCE and IS NULL/IS NOT NULL operators to accurately
resemble some SPARQL features. With different motivations, but similar philosophy,
 Harris et al. present in [8] an implementation of a simple fragment of SPARQL
in a relational database engine (they use relational algebra operators similar to the
ones used in [4]).

306

M. Arenas et al.

As noted in [4], the treatment of null values is the major problem encountered
when trying to specify the semantics of SPARQL by means of standard relational
algebra. Since mappings must be modeled as relational tuples, null values need to
be used to model unbounded variables. Zaniolo introduces in [19] an algebra to
deal with null values in relational databases. The author interprets null values as
standing for “no information”, as opposed with the more complex “unknown” and
“nonexistent” interpretations [9]. In [19], a relation with null values is deﬁned as a
set of tuples of not necessarily the same arity, which possibly contain null values
in some of their components. The author then deﬁnes operators over those relations
with nulls that generalize the standard relational algebra operators. The treatment
of null values in [19] matches the treatment of unbounded variables in SPARQL.
Thus, the operators over sets of mappings introduced in Sect. 13.3 can be easily
modeled within the framework of [19]. Although the formalization in [19] can be
used to deﬁne the semantics of SPARQL, we follow a simpliﬁed approach formalizing 
only what is strictly necessary in the SPARQL context, and thus simplifying
the subsequent study of the language.

DeBruin et al. [3] study the semantics of the conjunctive fragment of SPARQL
(graph patterns using only the AND operator, plus the SELECT clause) from a logical 
point of view. This semantics slightly differs from the deﬁnition in [15] on the
issue of blank nodes. In their approach, blanks play the role of “non-distinguished”
variables, that is, variables that are not presented in the answer.

In [14], Polleres studies the problem of translating SPARQL queries into Datalog
queries. Based on [11], the author proposes three different semantics: (1) bravelyjoining,
 (2) cautiously-joining and (3) strictly-joining semantics. These semantics 
are obtained by strengthening the notion of compatible mappings, and thus,
strengthening the conditions under which unbound variables are joined. Strictlyjoining 
semantics essentially resembles the inner-join condition of SQL, allowing
a simple translation into Datalog. Bravely-joining semantics coincides with the semantics 
presented in Sect. 13.4. To translate the bravely-joining semantics into Datalog,
 a special predicate BOUND(·) is needed to test whether a variable is bounded
to a non-null value. As a result, the translation generates a program with disjunctions 
in the bodies of the rules that extensively uses ¬BOUND(·). The program is
then transformed into Datalog by using standard techniques [14].

13.7 Conclusion

The query language SPARQL has been in the process of standardization since 2004.
In this process, the semantics of the language has played a key role. A formalization
of a semantics is beneﬁcial on several grounds: help in identifying relationships
among the constructors that stay hidden in the use cases, identify redundant and
contradicting notions, study the expressiveness and complexity of the language, help
in optimizing the evaluation of queries, etc. In this chapter, we have provided such a
formal semantics for SPARQL, and we have reviewed some results concerning the
complexity of evaluating SPARQL graph patterns.

13 On the Semantics of SPARQL

307

Acknowledgements We would like to thank Alejandro Mallea for many useful comments.
The authors were supported by: Arenas—Fondecyt grant 1090565; Gutierrez—Fondecyt grant
1070348; Pérez—Conicyt Ph.D. Scholarship. We would like to thank Alejandro Mallea for many
useful comments.

References

1. Angles, R., Gutierrez, C.: The expressive power of SPARQL. In: Proceedings of the Seventh

International Semantic Web Conference, pp. 114–129 (2008)

2. ARQ. A SPARQL processor for Jena, version 1.3 March 2006, Hewlett-Packard Development

Company. http://jena.sourceforge.net/ARQ

3. de Bruijn, J., Franconi, E., Tessaris, S.: Logical reconstruction of normative rdf. In: OWLED
4. Cyganiak, R.: A relational algebra for SPARQL. Tech. Rep. HPL-2005-170, HP-Labs.

http://www.hpl.hp.com/techreports/2005/HPL-2005-170.html

5. Durst, M., Suignard, M.: RFC 3987, Internationalized Resource Identiﬁers (IRIs). http://

www.ietf.org/rfc/rfc3987.txt

6. Garey, M.R., Johnson, D.S.: Computers and Intractability: A Guide to the Theory of NPCompleteness.
 Freeman, New York (1979)

7. Gutierrez, C., Hurtado, C., Mendelzon, A.: Foundations of Semantic Web databases. In: Proceedings 
of the Twenty-Third ACM Symposium on Principles of Database Systems (PODS),
pp. 95–106 (2004)

8. Harris, S., Shadbolt, N.: SPARQL query processing with conventional relational database systems.
 In: WISE Workshops, pp. 235–244

9. Imielinski, T., Lipski, W.: Incomplete information in relational databases. J. ACM 31(4), 761–

791 (1984)

10. Klyne, G., Carroll, J.J., McBride, B.: Resource Description Framework (RDF): Concepts 
and Abstract Syntax. W3C Recommendation 10 February 2004. http://www.w3.org/
TR/rdf-concepts/

11. Pérez, J., Arenas, M., Gutierrez, C.: Semantics and complexity of SPARQL. In: Proceedings

of the Fifth International Semantic Web Conference (ISWC), pp. 30–43 (2006)

12. Pérez, J., Arenas, M., Gutierrez, C.: Semantics of SPARQL. Technical Report, Universidad de

Chile TR/DCC-2006-17, October 2006

13. Pérez, J., Arenas, M., Gutierrez, C.: Semantics and complexity of SPARQL. ACM Trans.

Database Syst. 34(3) (2009)

14. Polleres, A.: From SPARQL to rules (and back). In: WWW, pp. 787–796
15. Prud’hommeaux, E., Seaborne, A.: SPARQL Query Language for RDF. W3C Recommendation 
15 January 2008. http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/

16. Seaborne, A.: Personal communication (2006)
17. Schmidt, M., Meier, M., Lausen, G.: Foundations of SPARQL Query Optimization. arXiv.org

paper arXiv:0812.3788v1, December 19, 2008

18. Vardi, M.Y.: The complexity of relational query languages (extended abstract). In: STOC

1982, pp. 137–146

19. Zaniolo, C.: Database relations with null values. J. Comput. Syst. Sci. 28(1), 142–166 (1984)

