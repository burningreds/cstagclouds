The Multiset Semantics of SPARQL Patterns

Renzo Angles1,3(B) and Claudio Gutierrez2,3

1 Department of Computer Science, Universidad de Talca, Talca, Chile

2 Department of Computer Science, Universidad de Chile, Santiago, Chile

3 Center for Semantic Web Research, Santiago, Chile

rangles@utalca.cl

Abstract. The paper determines the algebraic and logic structure of the
multiset semantics of the core patterns of SPARQL. We prove that the
fragment formed by AND, UNION, OPTIONAL, FILTER, MINUS and
SELECT corresponds precisely to both, the intuitive multiset relational
algebra (projection, selection, natural join, arithmetic union and except),
and the multiset non-recursive Datalog with safe negation.

1 Introduction

The incorporation of multisets (also called “duplicates” or “bags”)1 into the
semantics of query languages like SQL or SPARQL is essentially due to practical
concerns: duplicate elimination is expensive and duplicates might be required for
some applications, e.g. for aggregation. Although this design decision in SQL may
be debatable (e.g. see [6]), today multisets are an established fact in database
systems [8,14].

The theory behind these query languages is relational algebra or equivalently,
relational calculus, formalisms that for sets have a clean and intuitive semantics
for users, developers and theoreticians [1]. The same cannot be said of their extensions 
to multisets, whose theory is complex (particular containment of queries)
and their practical use not always clear for users and developers [8]. Worst, there
exist several possible ways of extending set relational operators to multisets and
one can ﬁnd them in practice. As illustration, let us remind the behaviour of SQL
relational operators. Consider as example the multisets A = {a, a, a, b, b, d} and
B = {a, b, b, c}. Then A UNION ALL B = {a, a, a, a, b, b, b, b, c, d}, that is, the “sum”
of all the elements in both multisets (UNION DISTINCT is classical set union). A
INTERSECT ALL B is {a, b, b}, i.e., the common elements in A and B, each with the
minimum of the multiplicities in A and B. Regarding negation or diﬀerence, there
are at least two: A EXCEPT ALL B is {a, a, d}, i.e. the arithmetical diﬀerence of the
copies, and A EXCEPT B is {d}, the elements in A (with their multiplicity) after
ﬁltering out all elements occurring in B. The reader can imagine that the “rules”
for combining these operators are not simple nor intuitive as they do not follow
the rules of classical set operations.

1 There is no agreement on terminology ([18], p. 27). In this paper we will use the

word “multiset”.

c(cid:2) Springer International Publishing AG 2016
P. Groth et al. (Eds.): ISWC 2016, Part I, LNCS 9981, pp. 20–36, 2016.
DOI: 10.1007/978-3-319-46523-4 2

The Multiset Semantics of SPARQL Patterns

21

Is there a rationale behind the possible extensions? Not easy to tell. Early
on Dayal et al. [7] observed that there are two conceptual approaches to extend
the set operators of union, intersection and negation, corresponding to the two
possible interpretations of multiple copies of a tuple. The ﬁrst approach treats
all copies of a given tuple as being identical or indistinguishable. The second one
treats all copies of a tuple as being distinct, e.g., as having an underlying identity.
Each of these interpretations gives rise to a diﬀerent semantics for multisets. The
ﬁrst one permits to extend the lattice algebra structure of sets induced by the
⊆-order by deﬁning a multiset order ⊆m deﬁned as A ⊆m B if each element in A
is contained in B and its multiplicity in B is bigger than in A. This order gives
a lattice meet (multiset intersection) deﬁned as the elements c present in both
multisets, and with multiplicity min(cA, cB), where cA, cB are the number of
copies of c in A and B respectively. This is the INTERSECT ALL operator of SQL.
The lattice join of two multisets gives a union deﬁned as the elements c present
in both multisets with multiplicity max(cA, cB). This operator is not present in
SQL. As was shown by Albert [2], there is no natural negation to add to this
lattice to get a Boolean algebra structure like in sets. The second interpretation
(all copies of an element are distinct) gives a poor algebraic structure. The union
gives in this case an arithmetic version, where the elements in the union of the
multisets A and B are the elements c present in both multisets with cA + cB
copies. This is the UNION ALL operator in SQL. Under this interpretation, the
intersection loses its meaning (always gives the empty set) and the diﬀerence
becomes trivial (A − B = A).

In order to illustrate the diﬃculties of having a “coherent” group of operators
for multisets, let us summarize the case of SQL, that does not have a clear
rationale on this point.2 We classiﬁed the operators under those that: keep the
set semantics; preserve the lattice structure of multiset order; do arithmetic with
multiplicities. Let A, B be multisets, and for each element c, let cA and cB be
their respective multiplicities in A and B.

union :

intersection :

diﬀerence :

⎧
⎪⎨

⎪⎩
⎧
⎪⎨

⎪⎩

set
lattice
arithmetic UNION ALL (multiplicity:cA + cB)

UNION DISTINCT (multiplicity: 1)
not present in SQL(*) (multiplicity: max(cA, cB))

INTERSECT DISTINCT (multiplicity: 1)
INTERSECT ALL (multiplicity: min(cA, cB))

set
lattice
arithmetic does not make sense
⎧
⎪⎪⎪⎨
set
lattice
arithmetic EXCEPT ALL (multiplicity: max(0, cA − cB)
⎪⎪⎪⎩
f ilter

not present in SQL(∗∗)(multiplicity: 1)
does not exists

EXCEPT(mult:if (cB = 0) then cA else 0

(*) Simulated as (A UNION ALL B) EXCEPT ALL (A INTERSECT ALL B).
(**) Simulated as SELECT DISTINCT * FROM (A EXCEPT B).

2 We follow the semantics of ANSI and ISO SQL:1999 Database Language Standard.

22

R. Angles and C. Gutierrez

At this point, a question arises: Are there “reasonable”, “well behaved”,
“harmonic”, groups of these operations for multisets? The answer is positive.
Albert [2] proved that lattice union and lattice intersection plus a ﬁlter diﬀerence 
work well in certain domains. On the other hand, Dayal et al. [7] introduced
the multiset versions for projection (πX), selection (σC), join ((cid:4)(cid:5)) and distinct
(δ) and studied their interaction with Boolean operators. They showed that the
lattice versions above combine well with selection (σP∨Q(r) = σP (r) ∪ σQ(r)
and similarly for intersection); that the arithmetic versions combine well with
projection (πX(r ∪ s) = πX(r) ∪ πX(s)). An important facet is the complexity 
introduced by the diﬀerent operators. Libkin and Wong [16,17] and Grumbach 
et al. [9] studied the expressive power and complexity of the operations of
the fragment including lattice union and intersection; arithmetic diﬀerence; and
distinct.

For our purposes here, namely the study of the semantics of multisets in
SPARQL, none of the above fragments help. It turns out that is a formalism
coming from a logical ﬁeld, the well behaved fragment of non-recursive Datalog
with safe negation (nr-Datalog¬), the one that matches the semantics of multisets
in SPARQL. More precisely, the natural extension of the usual (set) semantics
of Datalog to multisets developed by Mumick et al. [19]. In this paper we work
out the relational counterpart of this fragment, using the framework deﬁned
by Dayal et al. [7], and come up with a Multiset Relational Algebra (MRA)
that captures precisely the multiset semantics of the core relational patterns of
SPARQL. MRA is based on the operators projection (π), selection (σ), natural
join ((cid:4)(cid:5)), union (∪) and ﬁlter diﬀerence (\). The identiﬁcation of this algebra and
the proof of the correspondence with the relational core of SPARQL are the main
contributions of this paper. Not less important, as a side eﬀect, this approach
gives a new relational view of SPARQL (closer to classical relational algebra
and hence more intuitive for people trained in SQL); allows to make a clean
translation to a logical framework (Datalog); and matches precisely the fragment
of SQL corresponding to it. Table 1 shows a glimpse of these correspondences,
whose details are worked in this paper.

Contributions. Summarizing, this paper advances the current understanding of
the SPARQL language by determining the precise algebraic (Multiset Relational
Algebra) and logical (nr-Datalog¬) structure of the multiset semantics of the
core pattern operators in the language. This contribution is relevant for users,
developers and theoreticians. For users, it gives an intuitive and classic view of
the relational core patterns of SPARQL, allowing a good understanding of how to
use and combine the basic operators of the SPARQL language when dealing with
multisets. For developers, helps to perform optimization, design extensions of the
language, and understanding the semantics of multisets allowing for example
translations from SPARQL operators to the right multiset operators of SQL and
vice versa. For theoreticians, introduces a clean framework (Multiset Datalog as
deﬁned by Mumick et al. [19]) to study from a formal point of view the multiset
semantics of SPARQL patterns.

The Multiset Semantics of SPARQL Patterns

23

Table 1. Schema of correspondences of multiset SPARQL patterns: with
SPARQL algebra operators; Relational Multiset algebra operators; Datalog rules; and
SQL expressions. The operator EXCEPT in SPARQL is new (although expressible). The
operator diﬀ is a typed version of the diﬀ SPARQL algebra operator, and \ in MRA is
the multiset ﬁlter diﬀerence.

SPARQL

Multiset Relational

Algebra

SELECT X ...

P FILTER C

P1 . P2

P1 UNION P2

P1 EXCEPT P2

πW (...)
σC (r)
r1 (cid:4)(cid:5) r2
r1 ∪ r2

r1 \ r2

SQL

¬
nr-Datalog
q(X) ← L1, . . . , Ln SELECT X ...
L ← LP , C
L ← L1, L2
L ← L1
L ← L2
L ← L1,¬L2

r1 EXCEPT r2

FROM r WHERE C

r1 NATURAL JOIN r2

r1 UNION ALL r2

The paper is organized as follows. Section 2 presents the basic notions and
notations used in the paper. Section 3 identiﬁes a classical relational algebra view
of SPARQL patterns, introducing the fragment SPARQLR. Section 4 presents
the equivalence between SPARQLR and multiset non-recursive Datalog with
safe negation, and provides explicit transformations in both directions. Section 5
introduces the Multiset Relational Algebra, a simple and intuitive fragment of
relational algebra with multiset semantics, and proves that it is exactly equivalent 
to multiset non-recursive Datalog with safe negation. Section 6 analyzes
related work and presents brief conclusions.

2 SPARQL Graph Patterns

The deﬁnition of SPARQL graph patterns will be presented by using the formalism 
presented in [22], but in agreement with the W3C speciﬁcations of SPARQL
1.0 [25] and SPARQL 1.1 [10].

RDF Graphs. Assume two disjoint inﬁnite sets I and L, called IRIs and literals
respectively.3 An RDF term is an element in the set T = I ∪ L. An RDF triple
is a tuple (v1, v2, v3) ∈ I × I × T where v1 is the subject, v2 the predicate and
v3 the object. An RDF Graph (just graph from now on) is a set of RDF triples.
The union of graphs, G1 ∪ G2, is the set theoretical union of their sets of triples.
Additionally, assume the existence of an inﬁnite set V of variables disjoint from
T . We will use var(α) to denote the set of variables occurring in the structure α.
A solution mapping (or just mapping from now on) is a partial function
μ : V → T where the domain of μ, dom(μ), is the subset of V where μ is deﬁned.
3 In addition to I and L, RDF and SPARQL consider a domain of anonymous resources
called blank nodes. Their occurrence introduces issues that are not discussed in this
paper. Based on the results in [11], we avoided blank nodes assuming that their
absence does not aﬀect the results presented in this paper.

24

R. Angles and C. Gutierrez

(cid:5)) = dom(μ) ∩ W and μ

The empty mapping, denoted μ0, is the mapping satisfying that dom(μ0) = ∅.
Given ?X ∈ V and c ∈ T , we use μ(?X) = c to denote the solution mapping
variable ?X to term c. Similarly, μ?X→c denotes a mapping μ satisfying that
dom(μ) = {?X} and μ(?X) = c. Given a ﬁnite set of variables W ⊂ V , the
(cid:5) satisfying that
restriction of a mapping μ to W , denoted μ|W , is a mapping μ
(cid:5)(?X) = μ(?X) for every ?X ∈ dom(μ) ∩ W . Two
dom(μ
mappings μ1, μ2 are compatible, denoted μ1 ∼ μ2, when for all ?X ∈ dom(μ1) ∩
dom(μ2) it satisﬁes that μ1(?X) = μ2(?X), i.e., when μ1 ∪ μ2 is also a mapping.
Note that two mappings with disjoint domains are always compatible, and that
the empty mapping μ0 is compatible with any other mapping.
A selection formula is deﬁned recursively as follows: (i) If ?X, ?Y ∈ V and
c ∈ I ∪ L then (?X = c), (?X =?Y ) and bound(?X) are atomic selection
(cid:5)) and
formulas; (ii) If F and F
¬(F ) are boolean selection formulas. The evaluation of a selection formula F
under a mapping μ, denoted μ(F ), is deﬁned in a three-valued logic with values
true, false and error. We say that μ satisﬁes F when μ(F ) = true. The semantics
of μ(F ) is deﬁned as follows:
– If F is ?X = c and ?X ∈ dom(μ), then μ(F ) = true when μ(?X) = c and
μ(F ) = false otherwise. If ?X /∈ dom(μ) then μ(F ) = error.
– If F is ?X =?Y and ?X, ?Y ∈ dom(μ), then μ(F ) = true when μ(?X) = μ(?Y )
and μ(F ) = false otherwise. If either ?X /∈ dom(μ) or ?Y /∈ dom(μ) then
μ(F ) = error.

(cid:5) are selection formulas then (F ∧ F

– If F is bound(?X) and ?X ∈ dom(μ) then μ(F ) = true else μ(F ) = false.
– If F is a Boolean combination of the previous atomic cases, then it is evaluated

(cid:5)), (F ∨ F

following a three value logic table (see [25], 17.2).

Multisets. A multiset is an unordered collection in which each element may occur
more than once. A multiset M will be represented as a set of pairs (t, j), each
pair denoting an element t and the number j of times it occurs in the multiset
(called multiplicity or cardinality). When (t, j) ∈ M we will say that t j-belongs
to M (intuitively “t has j copies in M”). To uniformize the notation and capture
the corner cases, we will write (t,∗) ∈ M or simply say t ∈ M when there are
≥ 1 copies of t in M. Similarly, when there is no occurrence of t in M, we will
simply say “t does not belong to M”, and abusing notation write (t, 0) ∈ M, or
(t,∗) /∈ M. All of them indicate that t does not occur in M.

For multisets of solution mappings, following the notation of SPARQL, we
will also use the symbol Ω to denote a multiset and card(μ, Ω) to denote the
cardinality of the mapping μ in the multiset Ω. In this sense, we use (μ, n) ∈ Ω
to denote that card(μ, Ω) = n, or simply μ ∈ Ω when card(μ, Ω) > 0. Similarly,
card(μ, Ω) = 0 when μ /∈ Ω. The domain of a multiset Ω is deﬁned as dom(Ω) =
μ∈Ω dom(μ).

(cid:6)

SPARQL Algebra. Let Ω1, Ω2 be multisets of mappings, W be a set of variables
and F be a selection formula. The SPARQL algebra for multisets of mappings is
composed of the operations of projection, selection, join, union, minus, diﬀerence
and left-join, deﬁned respectively as follows:

The Multiset Semantics of SPARQL Patterns

25

(cid:7)

(cid:7)

μ(cid:2)=μ|W card(μ, Ω1)

– πW (Ω1) = {μ
(cid:5) | μ ∈ Ω1, μ
(cid:5) = μ|W}
(cid:5)
, πW (Ω1)) =
where card(μ
– σF (Ω1) = {μ ∈ Ω1 | μ(F ) = true}
where card(μ, σF (Ω1)) = card(μ, Ω1)
– Ω1 (cid:2)(cid:3) Ω2 = {μ = (μ1 ∪ μ2) | μ1 ∈ Ω1, μ2 ∈ Ω2, μ1 ∼ μ2}
where card(μ, Ω1 (cid:2)(cid:3) Ω2) =
– Ω1 ∪ Ω2 = {μ | μ ∈ Ω1 ∨ μ ∈ Ω2}
where card(μ, Ω1 ∪ Ω2) = card(μ, Ω1) + card(μ, Ω2)
– Ω1 − Ω2 = {μ1 ∈ Ω1 | ∀μ2 ∈ Ω2, μ1 (cid:4) μ2 ∨ dom(μ1) ∩ dom(μ2) = ∅}
where card(μ1, Ω1 − Ω2) = card(μ1, Ω1)
– Ω1\F Ω2 = {μ1 ∈ Ω1 | ∀μ2 ∈ Ω2, (μ1 (cid:4) μ2)∨(μ1 ∼ μ2∧(μ1∪μ2)(F ) (cid:15)= true)}
where card(μ1, Ω1 \F Ω2) = card(μ1, Ω1)
– Ω1(cid:2)(cid:3)(cid:2)(cid:3) F Ω2 = σF (Ω1 (cid:2)(cid:3) Ω2) ∪ (Ω1 \F Ω2)
where card(μ, Ω1(cid:2)(cid:3)(cid:2)(cid:3) F Ω2) = card(μ, σF (Ω1 (cid:2)(cid:3) Ω2)) + card(μ, Ω1 \F Ω2)

μ=(μ1∪μ2) card(μ1, Ω1) × card(μ2, Ω2)

Syntax of Graph Patterns. A SPARQL graph pattern is deﬁned recursively as
follows: A tuple from (I ∪ L ∪ V ) × (I ∪ V ) × (I ∪ L ∪ V ) is a graph pattern
called a triple pattern.4 If P1 and P2 are graph patterns then (P1 AND P2),
(P1 UNION P2), (P1 OPT P2) and (P1 MINUS P2) are graph patterns. Also if C
is a ﬁlter constraint (as deﬁned below) then (P1 FILTER C) is a graph pattern.
And if W is a set of variables, (SELECT W P1) is a graph pattern.
A ﬁlter constraint is deﬁned recursively as follows: (i) If ?X, ?Y ∈ V and
c ∈ I∪L then (?X = c), (?X =?Y ) and bound(?X) are atomic ﬁlter constraints;
(ii) If C1 and C2 are ﬁlter constraints then (!C1), (C1 || C2) and (C1 && C2)
are complex ﬁlter constraints. Given a ﬁlter constraint C, we denote by f(C) the
selection formula obtained from C. Note that there exists a simple and direct
translation from ﬁlter constraints to selection formulas and vice versa.
Semantics of SPARQL Graph Patterns. The evaluation of a SPARQL graph
pattern P over an RDF graph G is deﬁned as a function [[P]]G (or [[P]] where G
is clear from the context) which returns a multiset of solution mappings. Let
P1, P2, P3 be graph patterns and C be a ﬁlter constraint. The evaluation of a
graph pattern P over a graph G is deﬁned recursively as follows:
1. If P is a triple pattern t, then [[P]]G = {μ | dom(μ) = var(t)∧ μ(t) ∈ G} where
μ(t) is the triple obtained by replacing the variables in t according to μ, and
each mapping μ has cardinality 1.

2. [[(P1 AND P2)]]G =[[P1]]G (cid:2)(cid:3)[[P2]]G
3. If P is (P1 OPT P2) then

(a) if P2 is (P3 FILTER C) then [[P]]G =[[P1]]G(cid:2)(cid:3)(cid:2)(cid:3) C[[P3]]G
(b) else [[P]]G =[[P1]]G(cid:2)(cid:3)(cid:2)(cid:3) (true)[[P2]]G
4. [[(P1 MINUS P2)]]G =[[P1]]G −[[P2]]G
5. [[(P1 UNION P2)]]G =[[P1]]G ∪[[P2]]G
6. [[(P1 FILTER C)]]G = σf (C)([[P1]]G)
7. [[(SELECT W P1)]]G = πW ([[P1]]G).
4 We assume that any triple pattern contains at least one variable.

26

R. Angles and C. Gutierrez

For the rest of the paper, we will call SPARQLW3C the fragment of graph
patterns including the operators AND, UNION, OPT, FILTER, MINUS and
SELECT, as deﬁned above.

3 The Relational Fragment of SPARQL

In this section we will introduce a fragment of SPARQL which follows standard
intuitions of the operators from relational algebra and SQL. We will prove that
this fragment is equivalent to SPARQLW3C. First, let us introduce the DIFF
operator as an explicit way of expressing negation-by-failure5 in SPARQL.

Deﬁnition 1 (The DIFF operator). The weak diﬀerence of two graph patterns,
 P1 and P2, is deﬁned as

[[(P1 DIFF P2)]] = {μ1 ∈[[P1]] | ∀μ2 ∈[[P2]], μ1 (cid:4) μ2}

where card(μ1,[[(P1 DIFF P2)]]) = card(μ1,[[P1]]).

It is important to note that the DIFF operator is not deﬁned in SPARQL
1.0 nor in SPARQL 1.1 at the syntax level. However, it can be implemented in
current SPARQL engines by using the diﬀerence operator of the SPARQLW3C
algebra. It was showed [4,13] that the operators OPT and MINUS can be simulated 
with the operator DIFF in combination with AND, UNION and FILTER.
In order to facilitate, and make more natural the translation from SPARQL
to Relational Algebra (and Datalog), we will introduce a more intuitive notion
of diﬀerence between two graph patterns. We deﬁne the domain of a pattern
P , denoted dom(P ), as the set of variables that occur (deﬁning the output
“schema”) in the multiset of solution mappings for any evaluation of P .

Deﬁnition 2 (The EXCEPT operator). Let P1, P2 be graph patterns satisfying 
dom(P1) = dom(P2). The except diﬀerence of P1 and P2 is deﬁned as

[[(P1 EXCEPT P2)]] = {μ ∈[[P1]] | μ /∈[[P2]]}

where card(μ,[[(P1 EXCEPT P2)]]) = card(μ,[[P1]]).

∗

We will denote by EXCEPT

(or outer EXCEPT) the version of this operation 
when the restriction on domains is not considered.6

Note that the restriction on the domains of P1 and P2 follows the philosophy
of classical relational algebra. But it can be proved that EXCEPT and its outer
version are simulable each other:

Lemma 1. For each pair of graph patterns P1, P2 in SPARQLW3C, and any
and vice
RDF graph G, the operator EXCEPT can be simulated by EXCEPT
versa.
5 Recall that negation-by-failure can be expressed in SPARQL 1.0 as the combination
of an optional graph pattern and a ﬁlter constraint containing the bound operator.

∗

6 This operation is called SetMinus in [12].

The Multiset Semantics of SPARQL Patterns

27

∗
Proof. Clearly EXCEPT can be simulated by EXCEPT
tion, let us assume that dom(P1) (cid:15)= dom(P2). Then (P1 EXCEPT
expressed by the pattern (P

(cid:5)
1 EXCEPT P

(cid:5)
2) where:

. On the other direc-
P2) can be

∗

1 = (P1 FILTER(¬bound(?x1) && . . . && ¬bound(?xn))) when dom(P1) \
(cid:5)
– P
dom(P2) = {x1, . . . , xn} and P
2 = (P2 FILTER(¬bound(?y1) && . . . && ¬bound(?ym))) when dom(P2)\
(cid:5)
– P
dom(P1) = {y1, . . . , ym} and P
Note that cardinalities of selected mappings are not touched.

1 = P1 when dom(P1) \ dom(P2) = ∅; and
(cid:5)
2 = P2 when dom(P2) \ dom(P1) = ∅.
(cid:5)

The next lemma establishes the relationship between EXCEPT and DIFF,

showing that EXCEPT can be simulated in SPARQLW3C.

Lemma 2. For every pair of graph patterns P1, P2 in SPARQLW3C, and any
RDF graph G, the operator EXCEPT can be simulated by DIFF and vice versa.

∗

∗

∗
. And EXCEPT

Proof. The high level proof goes as follows. EXCEPT, as we saw, is equivalent to
EXCEPT
diﬀers from DIFF only in checking compatibility of
mappings (i.e. ∼).[[P1 EXCEPT
P2]] eliminates from[[P1]] those mappings in[[P2]]
that are equal to one in [[P1]]; while DIFF eliminates those that are compatible
with one in [[P1]]. That is, the diﬀerence is between the multisets {(μ1, n1) ∈ Ω1 |
¬∃μ2 ∈ Ω2 ∧ μ1 = μ2} versus {(μ1, n1) ∈ Ω1 | ¬∃μ2 ∈ Ω2 ∧ μ1 ∼ μ2}. Now, for
two mappings μ1, μ2, equality and compatibility (μ1 = μ2 versus μ1 ∼ μ2) diﬀer
only in those variables that are bound in μ1 and unbound in μ2 or vice versa.
Thus, to simulate = with ∼ and vice versa, it is enough to have an operator that
replaces all unbound entries in mappings of Ω1 and Ω2 by a fresh new constant,
2, and we will have that {(μ1, n1) ∈ Ω1 | ¬∃μ2 ∈
(cid:5)
e.g. c, call the new sets Ω
∧ μ1 = μ2}. Note
Ω2 ∧ μ1 ∼ μ2} is equivalent to {(μ1, n1) ∈ Ω
that cardinalities are preserved because the change between “unbound” and “c”
does not change them. The rest is to express the two operations on multisets of
solution mappings: the one that ﬁlls in unbound entries with a fresh constant c;
and the one that changes back the values c to unbound.

| ¬∃μ2 ∈ Ω

(cid:5)
1 and Ω

(cid:5)
1

(cid:5)
2

Now we are ready to state the main theorem. Deﬁne SPARQLR as the fragment 
of SPARQLW3C graph pattern expressions deﬁned recursively by triple
patterns plus the operators AND, UNION, FILTER and EXCEPT. Considering
that DIFF is able to express OPT and MINUS (cf. [4,13]), and that the DIFF
operator is expressible in SPARQLR (Lemma 2), we have the following result:
Theorem 1. SPARQLR is equivalent to SPARQLW3C.

For the rest of the paper, we will concentrate our interest on SPARQLR.

Note 1. An alternative proof of Theorem 1 is given as follows. (Compare [13],
Lemma 12). Let θ be a function that renames variables by fresh ones.

SPARQLW3C contains SPARQLR: The graph pattern (P1 EXCEPT P2) can
(cid:5))

be rewritten into an equivalent pattern (((P1 OPT(θP2)) FILTER C) FILTER C

28

R. Angles and C. Gutierrez

where dom(P1) = {?x1, . . . , ?xn}, C is (?x1 = θ?x1 && . . . && ?xn = θ?xn) and
(cid:5) is (! bound(θ?x1)).
SPARQLR contains SPARQLW3C: The graph pattern (P1 DIFF P2) can be

C

(cid:5)
1 = θ(P1), P

(cid:5)
2 = θ(P2) and C is

rewritten into an equivalent graph pattern
(cid:5)
(P1 EXCEPT(SELECT W ((P1 AND P
1) FILTER C) AND P
where W = dom(P1) = {?x1, . . . , ?xn}, P
(?x1 = θ?x1 && . . . ?xn = θ?xn).
4 SPARQLR ≡ Multiset Datalog
In this section we prove that SPARQLR have the same expressive power of
Multiset Datalog. Although the ideas of the proof are similar to those in [3] (now
for SPARQLR), we will sketch the main transformations to make the paper as
self contained as possible. For notions of Datalog see Levene and Loizou [15], for
the semantics of Multiset Datalog, Mumick et al. [19].

(cid:5)
2))

4.1 Multiset Datalog

A term is either a variable or a constant. A positive literal L is either a predicate
formula p(t1, dots, tn) where p is a predicate name and t1, dots, tn are terms,
or an equality formula t1 = t2 where t1 and t2 are terms. A negative literal
¬L is the negation of a literal L. A rule is an expression of the form L ←
L1 ∧ ··· ∧ Lk ∧ ¬Lk+1 ∧ ··· ∧ ¬Ln where L is a positive literal called the head
of the rule and the rest of literals (positive and negative) are called the body. A
fact is a rule with empty body and no variables. A Datalog program Π is a ﬁnite
set of rules and its set of facts is denoted facts(Π).

A variable x is safe in a rule r if it occurs in a positive predicate or in x = c
(c constant) or in x = y where y is safe. A rule is safe it all its variables are
safe. A program is safe if all its rules are safe. A program is non-recursive if its
dependency graph is acyclic. In what follows, we only consider non-recursive and
safe Datalog programs, denoted by nr-Datalog¬.

To incorporate multisets to the classical Datalog framework we will follow
the approach introduced by Mumick and Shmueli [20]. The idea is rather intu-
itive: Each derivation tree gives rise to a substitution θ. In the standard (set)
semantics, what matters is the set of the diﬀerent substitutions that instantiates
the distinguished literal. On the contrary, in multiset semantics the number of
such instantiations also becomes relevant. As Mumick and Shmueli state [19,20],
“duplicate semantics of a program is obtained by counting the number of derivation 
trees”. Thus now we have pairs (θ, n) of substitutions θ plus the number n
of derivation trees that produce θ.

A Datalog query is a pair (Π, L) where Π is a program and L is a distinguished 
predicate (the goal) occurring as the head of a rule. The answer to (Π, L)
is the multiset of substitutions θ such that makes θ(L) true.

The Multiset Semantics of SPARQL Patterns

29

Normalized Datalog. Let L, L1, L2 be literals. We assume, without loss of generality,
 that any safe non-recursive Datalog program can be normalized such that
it just contains rules of the following types:
– (Projection rule) L ← L1 where var(L) ⊂ var(L1);
– (Selection rule) L ← L1, EQ where EQ is a set of equalities of the form
xi = xj such that xi, xj are variables or constants.
– (Join rule) L ← L1, L2 where var(L) ⊆ var(L1) ∪ var(L2); and
– (Negation rule) L ← L1,¬L2 where var(L2) ⊆ var(L1) and var(L) = var(L1).

4.2 From SPARQL to Datalog

The algorithm that transforms SPARQL into Datalog includes transformations
of RDF graphs to Datalog facts, SPARQL queries into a Datalog queries, and
SPARQL mappings into Datalog substitutions.

RDF Graphs to Datalog Facts: Let G be an RDF graph: each term t in G is
encoded by a fact iri(t) or literal(t) when t is an IRI or a literal respectively;
the set of terms in G is deﬁned by the rules term(X) ← iri(X) and term(X) ←
literal(X); the fact N ull(null) encodes the null value (unbounded value); each
RDF triple (v1, v2, v3) in G is encoded by a fact triple(v1, v2, v3). Recall that we
are assuming that an RDF graph is a “set” of triples.

SPARQL Patterns into Datalog Rules: The transformation follows essentially
the idea presented by Polleres [23]. Let P be a graph pattern and G an RDF
graph. Denote by δ(P )G the function which transforms P into a set of Datalog
rules. Table 2 shows the transformation rules deﬁned by the function δ(P )G,
where the notion of compatible mappings is implemented by the rules:

comp(X, X, X) ← term(X), comp(X, Y, X) ← term(X) ∧ N ull(Y ),
comp(Y, X, X) ← N ull(Y ) ∧ term(X), comp(X, X, X) ← N ull(X).

Also, an atomic ﬁlter condition C is encoded by a literal L as follows (where
?X, ?Y ∈ V and u ∈ I ∪ L): if C is either (?X = u) or (?X =?Y ) then L is C; if
C is bound(?X) then L is ¬N ull(?X).

SPARQL Mappings to Datalog Substitutions: Let P be a graph pattern, G an
RDF graph and μ a solution mapping of P in G. Then μ gets transformed into a
substitution θ satisfying that for each x ∈ var(P ) there exists x/t ∈ θ such that
t = μ(x) when μ(x) is bounded and t = null otherwise.

Now, the correspondence between the multiplicities of mappings and substitutions 
works as follows: Each SPARQL mapping comes from an evaluation tree.
A set of evaluation trees becomes a multiset of mappings. Similarly, a set of Datalog 
derivation trees becomes a multiset of substitutions. Thus, each occurrence
of a mapping μ comes from a SPARQL evaluation tree. This tree is translated
by Table 2 to a Datalog derivation tree, giving rise to an occurrence of a substitution 
in Datalog. Each recursive step in Table 2 carries out bottom up the
correspondence between cardinalities of mappings and substitutions.

30

R. Angles and C. Gutierrez

Table 2. Transforming SPARQLR graph patterns into Datalog Rules. The function
δ(P )G takes a graph pattern P and an RDF graph G, and returns a set of Datalog rules
with main predicate p(var(P )), where var(P ) denotes the tuple of variables obtained
from a lexicographical ordering of the variables in P . If L is a Datalog literal, then
νj(L) denotes a copy of L with its variables renamed according to a variable renaming
function νj : V → V . comp is a literal encoding the notion of compatible mappings.
cond is a literal encoding a ﬁlter condition C. W is a subset of var(P1).

Pattern P
(x1, x2, x3)
(P1 AND P2)

(P1 UNION P2)

(P1 EXCEPT P2)

(SELECT W P1)

(P1 FILTER C)

and C is atomic

δ(P )G
p(var(P )) ← triple(x1, x2, x3)
p(var(P )) ← ν1(p1(var(P1))) ∧ ν2(p2(var(P2)))

(cid:2)

(cid:2)

(cid:2)

x∈var(P2)\var(P1) N ull(x),
x∈var(P1)\var(P2) N ull(x),

x∈var(P1)∩var(P2) comp(ν1(x), ν2(x), x),
δ(P1)G, δ(P2)G
dom(ν1) = dom(ν2) = var(P1) ∩ var(P2), range(ν1) ∩ range(ν2) = ∅.
p(var(P )) ← p1(var(P1))
p(var(P )) ← p2(var(P2))
δ(P1)G, δ(P2)G
p(var(P1)) ← p1(var(P1)) ∧ ¬p2(var(P2)),
δ(P1)G, δ(P2)G
p(W ) ← p1(var(P1)),
δ(P1)G
p(var(P )) ← p1(var(P1)) ∧ cond

δ(P1)G

Thus we have that a SPARQL query Q = (P, G) where P is a graph pattern
and G is an RDF graph gets transformed into the Datalog query (Π, p(var(P )))
where Π is the Datalog program δ(P )G plus the facts got from the transformation 
of the graph G, and p is the goal literal related to P .

4.3 From Datalog to SPARQL
Now we need to transform Datalog facts into RDF data, Datalog substitutions
into SPARQL mappings, and Datalog queries into SPARQL queries.

Datalog Facts as an RDF Graph: Given a Datalog fact f = p(c1, ..., cn), consider
the function desc(f) which returns the set of triples

{(u, predicate, p), (u, rdf: 1, c1), . . . , (u, rdf: n, cn)},

where u is a fresh IRI. Given a set of Datalog facts F , the RDF description of
F will be the graph G =

f∈F desc(f).

(cid:6)

Datalog Rules as SPARQL Graph Patterns: Let Π be a (normalized) Datalog
program and L be a literal p(x1, . . . , xn) where p is a predicate in Π and each
xi is a variable. We deﬁne the function gp(L)Π which returns a graph pattern
encoding of the program (Π, L). The translation works intuitively as follows:

The Multiset Semantics of SPARQL Patterns

31

(a) If predicate p is extensional, then gp(L)Π returns the graph pattern
((?Y, predicate, p) AND(?Y, rdf: 1, x1) AND··· AND(?Y, rdf n, xn)),
where ?Y is a fresh variable.

(b) If predicate p is intensional and {r1, . . . , rn} is the set of all the rules in
Π where p occurs in the head, then gp(L)Π returns the graph pattern
(. . . (T (r1) UNION T (r2)) . . . UNION T (rn)) where T (ri) is deﬁned as follows
(when n = 1 the resulting graph pattern is reduced to T (r1)):
• If ri is L ← L1 then T (ri) returns SELECT x1, . . . , xn WHERE gp(L1)Π.
• If ri
is L ← L1 ∧ EQ, where EQ is a set of equalities of the form
xi = xj such that xi, xj are variables or constants, then T (ri) returns
(gp(L1)Π FILTER C) where C is a ﬁlter condition equivalent to EQ.
• If ri is L ← L1 ∧ L2 then T (ri) returns (gp(L1)Π AND gp(L2)Π).
• If ri is L ← L1 ∧ ¬L2 then T (ri) returns (gp(L1)Π EXCEPT

∗

gp(L2)Π).

Datalog Substitutions as SPARQL Mappings: For each substitution θ satisfying 
(Π, L) build a mapping μ satisfying that, if x/t ∈ θ then x ∈ dom(μ) and
μ(x) = t. The correspondence of multiplicities work in a similar way (via derivation 
tree to evaluation tree) as in the case of mappings to substitutions.

Putting together the transformation in Table 2 and the pattern obtained by
using gp(L)Π, we get the following theorem, whose proof is a long but straightforward 
induction on the structure of the patterns in one direction, and on the
level of Datalog in the other.
Theorem 2. Multiset nr-Datalog¬ has the same expressive power as SPARQLR.

5 The Relational Version of Multiset Datalog: MRA

In this section we introduce a multiset relational algebra (called MRA), counterpart 
of Multiset Datalog, and prove its equivalence with the fragment of
non-recursive Datalog with safe negation.

5.1 Multiset Relational Algebra (MRA)

Multiset relational algebra is an extension of classical relation algebra having
multisets of relations instead of sets of relations. As indicated in the introduction,
there are manifold approaches and operators to extend set relational algebra with
multisets. We use the semantics of multiset operators deﬁned by Dayal et al. [7]
for the operations of selection, projection, natural join and arithmetic union; and
add ﬁlter diﬀerence (not present there) represented by the operator “except”.

Let us formalize these notions. In classical (Set) relational algebra, a database
schema is a set of relational schemas. A relational schema is deﬁned as a set of
attributes. Each attribute A has a domain, denoted dom(A). A relation R over
the relational schema S = {A1, . . . , An} is a ﬁnite set of tuples. An instance r of
a schema S is a relation over S. Given an instance r of a relation R with schema
S, Aj ∈ S and t = (a1, . . . , an) ∈ r, we denote by t[Aj] the tuple (aj). Similarly
with t[X] when X ⊆ S and we will deﬁne t[∅] = ∅.

32

R. Angles and C. Gutierrez

In the Multiset relational algebra setting, an instance of a schema is a multiset
relation, that is, a set of pairs (t, i), where t is a tuple over the schema S, and
i ≥ 1 is a positive integer. (For notions and notations on multisets recall Sect. 2,
Multisets).

(cid:5) be mul-
(cid:5) respectively. Let A ∈ S be an attribute,

Deﬁnition 3 (Multiset Relational Algebra (MRA)). Let r and r
tiset relations over the schemas S and S
a ∈ dom(A) and I = S ∩ S
(cid:5). MRA consists of the following operations:
1. Selection. σA=a(r) = {(t, i) : (t, i) ∈ r ∧ t[A] = a}.
(cid:5) is a multiset relation over S ∪ S
2. Natural Join. r (cid:4)(cid:5) r
(cid:5) − S. Let t
(cid:5) denotes concatenation of tuples. Then
(cid:2)
t
= {(t
(cid:5)
(cid:2)(t
[S

]), i × j) : (t, i) ∈ r ∧ (t

(cid:5) ∧ t[I] = t

, j) ∈ r

(cid:5)(cid:5) = S

r (cid:4)(cid:5) r

S

(cid:5)(cid:5)

(cid:5)

(cid:5)

(cid:5) deﬁned as follows. Let

(cid:5)

[I]}.

3. Projection. Let X ⊆ S. Then:
πX(r) = {(t[X],

(cid:8)

4. Union. Assume S = S

(cid:5).

(tj ,nj )∈r s.t. tj [X]=t

nj) : (t,∗) ∈ r}.

r ∪ r

(cid:5)

={(t, i) : t i − belongs to r and t /∈ r

(cid:5)}

(cid:5)

(cid:5)

∪ {(t
∪ {(t, i + j) : t i − belongs to r and t j − belongs to r

j − belongs to r

/∈ r and t

, j) : t

(cid:5)}

(cid:5)

(cid:5)}.

5. Except. Assume S = S

(cid:5).
r \ r

(cid:5)

= {(t, i) ∈ r : (t,∗) /∈ r

(cid:5)}.

As usual, we will deﬁne a query in this multiset relational algebra as an expression 
over an extended domain which includes, besides the original domains of
the schemas, a set of variables V .
5.2 MRA ≡ Multiset nr-Datalog ¬
This subsection is devoted to prove the following result.
Theorem 3. Multiset relational algebra (MRA) has the same expressive power
as Multiset Non-recursive Datalog with safe negation.

From this theorem and Theorem 2 it follows:
Corollary 1. SPARQLR is equivalent to MRA.

Proof. The proof is based on the ideas of the proof of Theorem 3.18 in [15],
extended to multisets. Let E be a relational algebra query expression over the
schema R and D a database. Then it will be translated by a function (·)Π to the
Datalog program facts(Π) ∪ EΠ, where facts(Π) is the multiset of facts (over
fresh predicates rΠ for each relation r, and having the same arity as the original
schema of r):

1 (V1).

1 (x1, . . . , xk) ∧ C

3. E = E1 (cid:4)(cid:5) E2. Let V = V2 \ V1. The translation is: outE(V1, V ) ← EΠ

2. E = σC(E1), where C is a set of equalities of the form xi = xj where
xi, xj are variables or constants. The translation EΠ is the program:
outE(x1, . . . , xk) ← EΠ
1 (V1) ∧
4. E = πA(E1), where A is a sublist of the attributes in E1. The translation is:
5. E = E1 ∪ E2, where E1 and E2 have the same schema. The translation is:
6. E = E1 \ E2, where E1 and E2 have the same schema. The translation is:

EΠ
2 (V2)
outE(A) ← EΠ
outE(x1, . . . , xk) ← EΠ
outE(x1, . . . , xk) ← EΠ
It is important to check that the resulting program is non-recursive (this is
because the structure of the algebraic relational expression from where it comes
is a tree). Also it is safe because in rule (6) both expressions have the same
schema). Now, it needs to be shown that for each relational expression (query)
E in R, [E]D and [EΠ] return the same “tuples” with the same multiplicity.
This is done by induction on the structure of E.

1 (x1, . . . , xk) outE(x1, . . . , xk) ← EΠ
1 (x1, . . . , xk) ∧ ¬EΠ

2 (x1, . . . , xk)

2 (x1, . . . , xk)

The Multiset Semantics of SPARQL Patterns

33

facts(Π) = {(rΠ(t), n) : t is a tuple with multiplicity n in schema r in D},
and EΠ is the translation of the expression E given by the recursive speciﬁcation
below. For the expression Ej, the set Vj will denote its list of attributes.

1. Base case. No operator involved. Thus the query is a member of the schema
R, namely r(x1, . . . , xn). The corresponding Multiset Datalog query is:
outr(x1, . . . , xn) ← rΠ(x1, . . . , xn)

Now, let us present the transformation from Multiset Datalog to Multiset
Relational Algebra. Note that we may assume a normal form for the Datalog
programs as presented in Sect. 4.1. Then the recursive translation (·)R from
Datalog programs to MRA expressions goes as follows.
1. First translate those head predicates q occurring in ≥ 2 rules as follows. Let q
be the head of rules r1, . . . , rk, k ≥ 2. Rename each such head q with the same
set of variables V . Then the translation is (q)R = (qr1)R ∪ ··· ∪ (qrk)R. From
now on, we can assume that, not considering these q’s, all other predicates
occur as head in at most one rule. Hence we will not need the subindex
indicating the rule to which they belong to.

πA((p)R).

qR is a fresh new schema with the corresponding arity.

2. (Base case.) Let r be a fact q(V ). Then translates it as (qr)R = qR(V ), where
3. Let r be q(A) ← p(V ), where A is a sublist of V . The translation is (qr)R =
4. Let r be q(V ) ← p(V ) ∧ C, where C is a set of equalities xi = xj such that
5. Let r be q(X, Y, Z) ← p1(X, Y ) ∧ p2(Y, Z), where X, Y, Z are disjoint lists of
6. Let r be q(X, Y ) ← p1(X, Y )∧¬p2(Y ), that is the rule is safe. The translation

variables. The translation is (qr)R = (p1)R (cid:4)(cid:5) (p2)R.
is (qr)R = (p1)R \ ((p1)R (cid:4)(cid:5) (p2)R).

xi, xj are variables or constants. The translation is (qr)R = σC((p)R).

34

R. Angles and C. Gutierrez

The arguments about multiplicity are straightforward veriﬁcations. And
because the program Π is non-recursive (i.e. its dependency graph is acyclic), the
recursive translation to the relational expression gives a well formed algebraic
expression.

6 Related Work and Conclusions

To the best of our knowledge, the multiset semantics of SPARQL has not been
systematically addressed. There are works that, when studying the expressive
power of SPARQL, touched some aspects of this topic. Cyganiak [5] was among
the ﬁrst who gave a translation of a core fragment of SPARQL into relational
algebra. Polleres [23] proved the inclusion of the fragment of SPARQL patterns
with safe ﬁlters into Datalog by giving a precise and correct set of rules. Schenk
[26] proposed a formal semantics for SPARQL based on Datalog, but concentrated 
on complexity more than expressiveness issues. Both, Polleres and Schenk
do not consider multiset semantics of SPARQL in their translations. Perez et al.
[21] gave the ﬁrst formal treatment of multiset semantics for SPARQL. Angles
and Gutierrez [3], Polleres [24] and Schmidt et al. [27] extended the set semantics
to multiset semantics using this idea. Kaminski et al. [12] considered multisets
in subqueries and aggregates in SPARQL. In none of these works was addressed
the goal of characterizing the multiset algebraic and/or logical structure of the
operators in SPARQL.

We studied the multiset semantics of the core SPARQL patterns, in order
to shed light on the algebraic and logic structure of them. In this regard, the
discovery that the core fragment of SPARQL patterns matches precisely the
multiset semantics of Datalog as deﬁned by Mumick et al. [19] and that this
logical structure corresponds to a simple multiset algebra, namely the Multiset
Relational Algebra (MRA), builds a nice parallel to that of classical set relational
algebra and relational calculus. Contrary to the rather chaotic variety of multiset
operators in SQL, it is interesting to observe that in SPARQL there is a coherent
body of multiset operators. We think that this should be considered by designers
in order to try to keep this clean design in future extensions of SPARQL.

Last, but not least, this study shows the complexities and challenges that
the introduction of multisets brings to query languages, exempliﬁed here in the
case of SPARQL.

Acknowledgments. The authors have funding from Millennium Nucleus Center for
Semantic Web Research under Grant NC120004. The authors thank useful feedback
from O. Hartig and anonymous reviewers.

References

1. Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley,

Boston (1995)

2. Albert, J.: Algebraic properties of bag data types. In: Proceedings of the International 
Conference on Very Large Data Bases (VLDB), pp. 211–219 (1991)

The Multiset Semantics of SPARQL Patterns

35

3. Angles, R., Gutierrez, C.: The expressive power of SPARQL. In: Sheth, A.P., Staab,
S., Dean, M., Paolucci, M., Maynard, D., Finin, T., Thirunarayan, K. (eds.) ISWC
2008. LNCS, vol. 5318, pp. 114–129. Springer, Heidelberg (2008)

4. Angles, R., Gutierrez, C.: Negation in SPARQL. In: Alberto Mendelzon International 
Workshop on Foundations of Data Management (AMW) (2016)

5. Cyganiak, R.: A relational algebra for SPARQL. Technical report HPL-2005-170,

HP Labs (2005)

6. Date, C.J.: Date on Database: Writings 2000–2006. APress, New York (2006)
7. Dayal, U., Goodman, N., Katz, R.H.: An extended relational algebra with control
over duplicate elimination. In: Proceedings of the Symposium on Principles of
Database Systems (PODS), pp. 117–123. ACM (1982)

8. Green, T.J.: Bag semantics. In: Encyclopedia of Database Systems, pp. 201–206

(2009)

9. Grumbach, S., Libkin, L., Milo, T., Wong, L.: Query languages for bags: expressive

power and complexity. SIGACT News 27(2), 30–44 (1996)

10. Harris, S., Seaborne, A.: SPARQL 1.1 Query Language - W3C Recommendation,

21 March 2013. http://www.w3.org/TR/2013/REC-sparql11-query-20130321/

11. Hogan, A., Arenas, M., Mallea, A., Polleres, A.: Everything you always wanted to

know about blank nodes. J. Web Semant. 27(1), 42–69 (2014)

12. Kaminski, M., Kostylev, E.V., Grau, B.C.: Semantics and expressive power of
subqueries and aggregates in SPARQL 1.1. In: Proceedings of the International
Conference on World Wide Web (WWW), pp. 227–238. ACM (2016)

13. Kontchakov, R., Kostylev, E.V.: On expressibility of non-monotone operators in
SPARQL. In: International Conference on the Principles of Knowledge Representation 
and Reasoning (2016)

14. Lamperti, G., Melchiori, M., Zanella, M.: On multisets in database systems. In:
Calude, C.S., Pun, G., Rozenberg, G., Salomaa, A. (eds.) Multiset Processing.
LNCS, vol. 2235, pp. 147–216. Springer, Heidelberg (2001)

15. Levene, M., Loizou, G.: A Guided Tour of Relational Databases and Beyond.

Springer, Heidelberg (1999)

16. Libkin, L., Wong, L.: Some properties of query languages for bags. In: Proceedings
of the International Workshop on Database Programming Languages (DBPL) -
Object Models and Languages, pp. 97–114 (1994)

17. Libkin, L., Wong, L.: Query languages for bags and aggregate functions. J. Comput.

Syst. Sci. 55(2), 241–272 (1997)

18. Melton, J., Simon, A.R.: SQL:1999. Understanding Relational Language Components.
 Morgan Kaufmann Publishers, Burlington (2002)

19. Mumick, I.S., Pirahesh, H., Ramakrishnan, R.: The magic of duplicates and aggregates.
 In: Proceedings of the International Conference on Very Large Data Bases
(VLDB), pp. 264–277 (1990)

20. Mumick, I.S., Shmueli, O.: Finiteness properties of database queries. In: Australian

Database Conference, pp. 274–288 (1993)

21. P´erez, J., Arenas, M., Gutierrez, C.: Semantics of SPARQL. Technical Report

TR/DCC-2006-17, Department of Computer Science, University of Chile (2006)

22. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and complexity of SPARQL. ACM

Trans. Database Syst. (TODS) 34(3), 1–45 (2009)

23. Polleres, A.: From SPARQL to rules (and back). In: Proceedings of the 16th International 
World Wide Web Conference (WWW), pp. 787–796. ACM (2007)

24. Polleres, A.: How (well) do datalog, SPARQL and RIF interplay? In: Barcel´o,
P., Pichler, R. (eds.) Datalog 2.0 2012. LNCS, vol. 7494, pp. 27–30. Springer,
Heidelberg (2012)

36

R. Angles and C. Gutierrez

25. Prud’hommeaux, E., Seaborne, A.: SPARQL query language

for RDF.
2008. http://www.w3.org/TR/2008/

W3C Recommendation,
REC-115-sparql-query-20080115/

15

January

26. Schenk, S.: A SPARQL semantics based on datalog. In: Hertzberg, J., Beetz,
M., Englert, R. (eds.) KI 2007. LNCS (LNAI), vol. 4667, pp. 160–174. Springer,
Heidelberg (2007)

27. Schmidt, M., Meier, M., Lausen, G.: Foundations of SPARQL query optimization.
In: Proceedings of the International Conference on Database Theory, pp. 4–33.
ACM (2010)

