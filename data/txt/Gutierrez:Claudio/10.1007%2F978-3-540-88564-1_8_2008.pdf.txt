The Expressive Power of SPARQL

Renzo Angles and Claudio Gutierrez

Department of Computer Science, Universidad de Chile

{rangles,cgutierr}@dcc.uchile.cl

Abstract. This paper studies the expressive power of SPARQL. The
main result is that SPARQL and non-recursive safe Datalog with negation 
have equivalent expressive power, and hence, by classical results,
SPARQL is equivalent from an expressiveness point of view to Relational 
Algebra. We present explicit generic rules of the transformations
in both directions. Among other ﬁndings of the paper are the proof that
negation can be simulated in SPARQL, that non-safe ﬁlters are superﬂuous,
 and that current SPARQL W3C semantics can be simpliﬁed to a
standard compositional one.

1 Introduction

Determining the expressive power of a query language is crucial for understanding 
its capabilities and complexity, that is, what queries a user is able to pose,
and how complex the evaluation of queries is, issues that are central considerations 
to take into account when designing a query language.

SPARQL, the query language for RDF, has recently become a W3C recommendation 
[9]. In the RDF Data Access Working Group (WG) were it was
designed, expressiveness concerns generated ample debate. Many of them remained 
open due to lack of understanding of the theoretical expressive power of
the language.

This paper studies in depth the expressive power of SPARQL. A ﬁrst issue
addressed is the incorporation of negation. The W3C speciﬁcation of SPARQL
provides explicit operators for join and union of graph patterns, even for specifying 
optional graph patterns, but it does not deﬁne explicitly the diﬀerence of
graph patterns. Although intuitively it can be emulated via a combination of
optional patterns and ﬁlter conditions (like negation as failure in logic program-
ming), we show that there are several non-trivial issues to be addressed if one
likes to deﬁne the diﬀerence of patterns inside the language.

A second expressiveness issue refers to graph patterns with non-safe ﬁlter, i.e.,
graph patterns (P FILTER C) for which there are variables in C not present in
P . It turns out that these type of patterns, which have non-desirable properties,
can be simulated by safe ones (i.e., patterns where every variable occurring in
C also occurs in P ). This simple result has important consequences for deﬁning
a clean semantics, in particular a compositional and context-free one.

A. Sheth et al. (Eds.): ISWC 2008, LNCS 5318, pp. 114–129, 2008.
c(cid:2) Springer-Verlag Berlin Heidelberg 2008

The Expressive Power of SPARQL

115

A third topic of concern was the presence of non desirable features in the W3C
semantics like its operational character. We show that the W3C speciﬁcation of
the semantics of SPARQL is equivalent to a well behaved and studied compositional 
semantics for SPARQL, which we will denote in this paper SPARQLC [6].
Using the above results, we are able to determine the expressive power of
SPARQL. We prove that SPARQLC and non-recursive safe Datalog with nega-
¬
) are equivalent in their expressive power. For this, ﬁrst we
tion (nr-Datalog
¬
show that SPARQLC is contained in nr-Datalog
by deﬁning transformations
¬
(for databases, queries, and solutions) from SPARQLC to nr-Datalog
, and we
prove that the result of evaluating a SPARQLC query is equivalent, via the trans-
¬
formations, to the result of evaluating (in nr-Datalog
) the transformed query.
¬
is contained in SPARQLC using a similar
Second, we show that nr-Datalog
approach. It is important to remark that the transformations used are explicit
and simple, and in all steps bag semantics is considered.

Finally, and by far, the most important result of the paper is the proof that
SPARQL has the same expressive power of Relational Algebra under bag semantics 
(which is the one of SPARQL). This follows from the well known fact that
¬
Relational Algebra has the same expressive power as nr-Datalog

[1].

The paper is organized as follows. In Section 2 we present preliminary material.
 Section 3 presents the study of negation. Section 4 studies non-safe ﬁlter
patterns. Section 5 proves that the W3C speciﬁcation of SPARQL and SPARQLC
are equivalent. Section 6 proves that SPARQLC and nr-Datalog¬ have the same
expressive power. Section 7 presents the conclusions.

Related Work. The W3C recommendation SPARQL is from January 2008. Hence,
it is no surprise that little work has been done in the formal study of its expressive
power. Several conjectures were raised during the WG sessions 1. Furche et al. [3]
surveyed expressive features of query languages for RDF (including old versions
of SPARQL) in order to compare them systematically. But there is no particular
analysis of the expressive power of SPARQL.

Cyganiak [2] presented a translation of SPARQL into Relational Algebra considering 
only a core fragment of SPARQL. His work is extremely useful to implement 
and optimize SPARQL in SQL engines. At the level of analysis of expressive
issues it presented a list of problems that should be solved (many of which still
persist), like the ﬁlter scope problem and the nested optional problem.

Polleres [8] proved the inclusion of the fragment of SPARQL patterns with
safe ﬁlters into Datalog by giving a precise and correct set of rules. Schenk [10]
proposed a formal semantics for SPARQL based on Datalog, but concentrated
on complexity more than expressiveness issues. Both works do not consider bag
semantics of SPARQL in their translations.

The work of Perez et al. [6] and the technical report [7], that gave the formal
basis for SPARQLC compositional semantics, addressed several expressiveness
issues, but no systematic study of the expressive power of SPARQL was done.

1 See http://lists.w3.org/Archives/Public/public-rdf-dawg-comments/, especially 
the years 2006 and 2007.

116

R. Angles and C. Gutierrez

2 Preliminaries

2.1 RDF and Datasets

Assume there are pairwise disjoint inﬁnite sets I, B, L (IRIs, Blank nodes, and
RDF literals respectively). We denote by T the union I ∪ B ∪ L (RDF terms).
A tuple (v1, v2, v3) ∈ (I ∪ B) × I × T is called an RDF triple, where v1 is the
subject, v2 the predicate, and v3 the object. An RDF Graph [4] (just graph from
now on) is a set of RDF triples. Given a graph G, term(G) denotes the set of
elements of T occurring in G and blank(G) denotes the set of blank nodes in G.
The union of graphs, G1 ∪ G2, is the set theoretical union of their sets of triples.
An RDF dataset D is a set {G0,(cid:4)u1, G1(cid:5), . . . ,(cid:4)un, Gn(cid:5)} where each Gi is a
graph and each uj is an IRI. G0 is called the default graph of D and it is denoted
dg(D). Each pair (cid:4)ui, Gi(cid:5) is called a named graph; deﬁne name(Gi)D = ui and
gr(ui)D = Gi. We denote by term(D) the set of terms occurring in the graphs of
D. The set of IRIs {u1, . . . , un} is denoted names(D). Every dataset satisﬁes that:
(i) it always contains one default graph (which could be empty); (ii) there may
be no named graphs; (iii) each uj is distinct; and (iv) blank(Gi)∩ blank(Gj) = ∅
for i (cid:8)= j. Finally, the active graph of D is the graph Gi used for querying D.

2.2 SPARQL

A SPARQL query is syntactically represented by a block consisting of a query
form (SELECT, CONSTRUCT or DESCRIBE), zero o more dataset clauses
(FROM and FROM NAMED), a WHERE clause, and possibly solution modiﬁers 
(e.g. DISTINCT). The WHERE clause provides a graph pattern to match
against the RDF dataset constructed from the dataset clauses.

There are two formalizations of SPARQL which will be used throughout
this study: SPARQLWG, the W3C recommendation language SPARQL [9] and
SPARQLC, the formalization of SPARQL given in [6]. We will need some general
deﬁnitions before describe brieﬂy both languages.

Assume the existence of an inﬁnite set V of variables disjoint from T . We
denote by var(α) the set of variables occurring in the structure α. A tuple from
(I ∪ L∪ V )× (I ∪ L∪ V )× (I ∪ V ) is called a triple pattern. A basic graph pattern
is a ﬁnite set of triple patterns.
A ﬁlter constraint is deﬁned recursively as follows: (i) if ?X, ?Y ∈ V and
u ∈ I ∪ L then ?X = u, ?X = ?Y , bound(?X), isIRI(?X), isLiteral(?X), and
isBlank(?X) are atomic ﬁlter constraints2; (ii) if C1 and C2 are ﬁlter constraints
then (¬C1), (C1 ∧ C2), and (C1 ∨ C2) are complex ﬁlter constraints.
A mapping μ is a partial function μ : V → T . The domain of μ, dom(μ), is
the subset of V where μ is deﬁned. The empty mapping μ0 is a mapping such
that dom(μ0) = ∅. Two mappings μ1, μ2 are compatible, denoted μ1 ∼ μ2, when
for all ?X ∈ dom(μ1) ∩ dom(μ2) it satisﬁes that μ1(?X) = μ2(?X), i.e., when
μ1 ∪ μ2 is also a mapping. The expression μ?X→v denote a mapping such that
dom(μ) = {?X} and μ(?X) = v.
2 For a complete list of atomic ﬁlter constraints see [9].

The Expressive Power of SPARQL

117

The evaluation of a ﬁlter constraint C against a mapping μ, denoted μ(C), is
deﬁned in a three value logic with values {true, false, error} as follows:
– If C is an atomic ﬁlter constraint, excluding bound(·), and var(C) (cid:2) dom(μ),
then μ(C) = error; else if C is ?X = u and μ(?X) = u, or if C is ?X = ?Y and
μ(?X) = μ(?Y ), or if C is isIRI(?X) and μ(?X) ∈ I, if C is isLiteral(?X)
and μ(?X) ∈ L, if C is isBlank(?X) and μ(?X) ∈ B, then μ(C) = true;
otherwise μ(C) = false.

μ(C1) = true; and μ(C) = error when μ(C1) = error.

– If C is bound(?X) then μ(C) = true if ?X ∈ dom(μ) else μ(C) = false.3
– If C is (¬C1) then μ(C) = true when μ(C1) = false; μ(C) = false when
– If C is (C1 ∨ C2) then μ(C) = true if either μ(C1) = true or μ(C2) = true;
– If C is (C1 ∧ C2) then μ(C) = true if μ(C1) = true and μ(C2) = true;
μ(C) = false if either μ(C1) = false or μ(C2) = false; otherwise μ(C) = error.
A mapping μ satisﬁes a ﬁlter constraint C, denoted μ |= C, iﬀ μ(C) = true.
Consider the following operations between two sets of mappings Ω1, Ω2:

μ(C) = false if μ(C1) = false and μ(C2) = false; otherwise μ(C) = error.

Ω1 (cid:3)(cid:4) Ω2 = {μ1 ∪ μ2 | μ1 ∈ Ω1, μ2 ∈ Ω2 and μ1 ∼ μ2}
Ω1 ∪ Ω2 = {μ | μ ∈ Ω1 or μ ∈ Ω2}
Ω1 \ Ω2 = {μ1 ∈ Ω1 |
Ω1 \C Ω2 = {μ1 ∈ Ω1 | for all μ2 ∈ Ω2, μ1 and μ2 are not compatible } ∪
{μ1 ∈ Ω1 | for all μ2 ∈ Ω2 such that μ1 ∼ μ2, (μ1 ∪ μ2) (cid:5) C}
Ω1(cid:2)(cid:3)(cid:3)(cid:4) Ω2 = (Ω1 (cid:3)(cid:4) Ω2) ∪ (Ω1 \ Ω2)
Ω1(cid:2)(cid:3)(cid:3)(cid:4) C Ω2 = {μ | μ ∈ (Ω1 (cid:3)(cid:4) Ω2) and μ |= C} ∪ (Ω1 \C Ω2)

for all μ2 ∈ Ω2, μ1 and μ2 are not compatible }

Syntax and Semantics of SPARQLC.
A SPARQLC graph pattern P is deﬁned recursively by the following grammar:
P
GP ::= P "AND" P | P "UNION" P | P "OPT" P | P "FILTER" C |

::= t | "(" GP ")"

n "GRAPH" P

active graph G, denoted (cid:2)P (cid:3)D

where t denotes a triple pattern, C denotes a ﬁlter constraint, and n ∈ I ∪ V .
The evaluation of a SPARQLC graph pattern P over an RDF dataset D having
G = {μ | dom(μ) = var(t) and μ(t) ∈ G}
where μ(t) is the triple obtained by replacing the variables in t according to
mapping μ.

G, is deﬁned recursively as follows:

– if P is a triple pattern t, (cid:2)P (cid:3)D

– if P is a complex graph pattern then (cid:2)P (cid:3)D

G is deﬁned as given in Table 1.

Syntax and Semantics of SPARQLWG.
A SPARQLWG graph pattern GroupGP is deﬁned by the following grammar4:

GroupGP
GPNotTriples

::= "{" TB? ((GPNotTriples | Filter) "."? TB?)* "}"
::= OptionalGP | GroupOrUnionGP | GraphGP

3 Functions invoked with an argument of the wrong type are evaluated to error.
4 http://www.w3.org/TR/rdf-sparql-query/#grammar. We use GP and TB to abbreviate 
GraphPattern and TriplesBlock respectively

118

R. Angles and C. Gutierrez

Table 1. Semantics of SPARQLC graph patterns. P1, P2 are SPARQLC graph patterns,
C is a ﬁlter constraint, u ∈ I and ?X ∈ V .

Graph pattern P

Evaluation (cid:2)P (cid:3)D
G
(cid:3)(cid:4) (cid:2)P2(cid:3)D
(cid:2)P1(cid:3)D
G
G(cid:2)(cid:3)(cid:3)(cid:4) (cid:2)P2(cid:3)D
(cid:2)P1(cid:3)D
∪ (cid:2)P2(cid:3)D
(cid:2)P1(cid:3)D
G
{μ | μ ∈ (cid:2)P1(cid:3)D
(cid:2)P1(cid:3)D

(P1 AND P2)
(P1 OPT P2)
(P1 UNION P2)
(P1 FILTER C)
(u GRAPH P1)
(?X GRAPH P1) (cid:0)v∈names(D)((cid:2)P1(cid:3)D

gr(u)D

gr(v)D

G and μ |= C}

G

G

G

(cid:3)(cid:4) {μ?X→v})

::= "OPTIONAL" GroupGP
OptionalGP
GraphGP
::= "GRAPH" VarOrIRIref GroupGP
GroupOrUnionGP ::= GroupGP ( "UNION" GroupGP )*
Filter
where TB denotes a basic graph pattern (a set of triple patterns), VarOrIRIref
denotes a term in the set I ∪ V and Constraint denotes a ﬁlter constraint. Note
that the operator {A . B} represents the AND but it has not ﬁxed arity.

::= "FILTER" Constraint

The evaluation of a SPARQLWG graph pattern GroupGP is deﬁned by a series
of steps, starting by transforming GroupGP, via a function T , into an intermediate
algebra expression E (with operators BGP, Join, Union, LeftJoin, Graph and
Filter), and ﬁnally evaluating E on an RDF dataset D.
The transformation T (GroupGP) is given by Algorithm 1. The evaluation of
E over an RDF dataset D having active graph G, which we will denote (cid:4)(cid:4)E(cid:5)(cid:5)D
(originally denoted eval(D(G), E) in [9]), is deﬁned recursively as follows:
– if E is BGP(TB), (cid:4)(cid:4)E(cid:5)(cid:5)D
G = {μ | dom(μ) = var(E) and μ(E) ⊆ G} where
μ(E) is the set of triples obtained by replacing the variables in the triple
patterns of TB according to mapping μ.
– if E is a complex expression then (cid:4)(cid:4)P(cid:5)(cid:5)D
Note 1. In the deﬁnition of graph patterns, we avoided blank nodes, because this
restriction does not diminish the generality of our study. In fact, each SPARQL
(cid:4) without blank nodes in its
query Q can be simulated by a SPARQL query Q
pattern. It follows from the deﬁnitions of RDF instance mapping, solution mapping,
 and the order of evaluation of solution modiﬁers (see [9]), that if Q is a
(cid:4) is the same query where each blank node
query with graph pattern P , and Q
(cid:4) give the same
b in P has been replaced by a fresh variable ?Xb then Q and Q
results. (Note that, if Q has the query form SELECT or DESCRIBE, the “∗” parameter 
is –according to the speciﬁcation of SPARQL– an abbreviation for all
(cid:4) should explicit in
variables occurring in the pattern. In this case the query Q
the SELECT clause all variables of the original pattern P .)
Note 2. SPARQLC follows a compositional semantics, whereas SPARQLWG follows 
a mixture of compositional and operational semantics where the meaning
of certain patterns depends on their context, e.g., lines 7 and 8 in algorithm 1.

G is deﬁned as given in Table 2.

G

The Expressive Power of SPARQL

119

(cid:4)) then E ← LeftJoin(E, E

Algorithm 1. Transformation of SPARQLWG patterns into algebra expressions.
1: // Input: a SPARQLWG graph pattern GroupGP
2: // Output: an algebra expression E = T (GroupGP)
3: E ← empty pattern; F S ← ∅
4: for each syntactic form f in GroupGP do
if f is TB then E ← Join(E, BGP(TB))
5:
if f is OPTIONAL GroupGP1 then
6:
if T (GroupGP1) is Filter(F, E
7:
else E ← LeftJoin(E, T (GroupGP1), true)
8:
if f is GroupGP1 UNION ··· UNION GroupGPn then
9:
10:
if n > 1 then
11:
12:
13:
14:
15:
16:
17:
18: end for
19: if F S (cid:7)= ∅ then E ← Filter(F S, E)
20: return E

end if
if f is GRAPH VarOrIRIref GroupGP1 then
E ← join(E, Graph(VarOrIRIref, T (GroupGP1)))
if f is FILTER constraint then F S ← (F S ∧ constraint)

(cid:4) ← Union(··· (Union(T (GroupGP1), T (GroupGP2))··· ), T (GroupGPn))

E
else E
E ← Join(E, E

(cid:4) ← T (GroupGP1)

, F )

(cid:4))

(cid:4)

Table 2. Semantics of SPARQLWG graph patterns. A pattern GroupGP is transformed
into an algebra expression E using algorithm 1. Then E is evaluated as the table shows.
E1 and E2 are algebra expressions, C is a ﬁlter constraint, u ∈ I and ?X ∈ V .

Algebra Expression E

Join(E1, E2)
LeftJoin(E1, E2, C)
Union(E1, E2)
Filter(C, E1)
Graph(u, E1)
Graph(?X, E1)

G

G

Evaluation (cid:8)(cid:8)E(cid:9)(cid:9)D
G (cid:3)(cid:4) (cid:8)(cid:8)E2(cid:9)(cid:9)D
(cid:8)(cid:8)E1(cid:9)(cid:9)D
G(cid:2)(cid:3)(cid:3)(cid:4) C(cid:8)(cid:8)E2(cid:9)(cid:9)D
(cid:8)(cid:8)E1(cid:9)(cid:9)D
(cid:8)(cid:8)E1(cid:9)(cid:9)D
∪ (cid:8)(cid:8)E2(cid:9)(cid:9)D
{ μ | μ ∈ (cid:8)(cid:8)E1(cid:9)(cid:9)D
(cid:8)(cid:8)E1(cid:9)(cid:9)D
(cid:0)v ∈ names(D)((cid:8)(cid:8)E1(cid:9)(cid:9)D

gr(u)D

G

G

G

G and μ |= C}

(cid:3)(cid:4) {μ?X→v})

gr(v)D

Note 3. In this paper we will follow the simpler syntax of SPARQLC, better 
suited to do formal analysis and processing than the syntax presented by
SPARQLWG. There is an easy and intuitive way of translating back and forth
between both syntax formalisms, which we will not detail here.

2.3 Datalog

We will brieﬂy review notions of Datalog (For further details and proofs see [1,5]).
A term is either a variable or a constant. An atom is either a predicate formula
p(x1, ..., xn) where p is a predicate name and each xi is a term, or an equality

120

R. Angles and C. Gutierrez

formula t1 = t2 where t1 and t2 are terms. A literal is either an atom (a positive
literal L) or the negation of an atom (a negative literal ¬L).
A Datalog rule is an expression H ← B where H is a positive literal called
the head 5 of the rule and B is a set of literals called the body. A rule is ground
if it does not have any variables. A ground rule with empty body is called a fact.
A Datalog program Π is a ﬁnite set of Datalog rules. The set of facts occurring 
in Π, denoted facts(Π), is called the initial database of Π. A predicate is
extensional in Π if it occurs only in facts(Π), otherwise it is called intensional.
A Datalog program is non-recursive and safe if it does not contain any predicate 
that is recursive in the program and it can only generate a ﬁnite number
of answers. In what follows, we only consider non-recursive and safe programs.
A substitution θ is a set of assignments {x1/t1, . . . , xn/tn} where each xi is a
variable and each ti is a term. Given a rule r, we denote by θ(r) the rule resulting
of substituting the variable xi for the term ti in each literal of r.

The meaning of a Datalog program Π, denoted facts

(Π), is the database
resulting from adding to the initial database of Π as many new facts of the
form θ(L) as possible, where θ is a substitution that makes a rule r in Π true
and L is the head of r. Then the rules are applied repeatedly and new facts
are added to the database until this iteration stabilizes, i.e., until a ﬁxpoint is
reached.

∗

A Datalog query Q is a pair (Π, L) where Π is a Datalog program and L is
a positive (goal) literal. The answer to Q over database D = facts(Π), denoted
ansd(Q, D) is deﬁned as the set of substitutions {θ | θ(L) ∈ facts

(Π)}.

∗

2.4 Comparing Expressive Power of Languages

By the expressive power of a query language, we understand the set of all queries
expressible in that language [1,5]. In order to determine the expressive power of
(cid:4) and
a query language L, usually one chooses a well-studied query language L
(cid:4) in their expressive power. Two query languages have the
compares L and L
same expressive power if they express exactly the same set of queries.
A given query language is deﬁned as a quadruple (Q,D,S, eval), where Q is a
set of queries, D is a set of databases, S is a set of solutions, and eval : Q×D → S
is the evaluation function. The evaluation of a query Q ∈ Q on a database D ∈ D
is denoted eval(Q, D). Two queries Q1, Q2 ∈ Q are equivalent, denoted Q1 ≡ Q2,
if eval(Q1, D) = eval(Q2, D) for every D ∈ D.
Let L1 = (Q1,D1,S1, eval1) and L2 = (Q2,D2,S2, eval2) be two query languages.
 We say that L1 is contained in L2 if and only if there are bijective
data transformations TD : D1 → D2 and TS : S1 → S2, and query transformation 
TQ : Q1 → Q2, such that for all Q ∈ Q1 and D ∈ D1 it satisﬁes that
TS(eval1(Q, D)) = eval2(TQ(Q),TD(D)). We say that L1 and L2 are equivalent
if and only if L1 is contained in L2 and L2 is contained in L1. (Note that if L1
and L2 are subsets of a language L, then TD, TS and TQ are the identity.)

5 We may assume that all heads of rules have only variables by adding the corresponding 
equality formula to its body.

The Expressive Power of SPARQL

121

3 Expressing Diﬀerence of Patterns in SPARQLWG

The SPARQLWG speciﬁcation indicates that it is possible to test if a graph
pattern does not match a dataset, via a combination of optional patterns and
ﬁlter conditions (like negation as failure in logic programming)([9] Sec. 11.4.1).
In this section we analyze in depth the scope and limitations of this approach.
We will introduce a syntax for the “diﬀerence” of two graph patterns P1 and
P2, denoted (P1 MINUS P2), with the intended informal meaning: “the set of
mappings that match P1 and does not match P2”. Formally:

G

\ (cid:4)(cid:4)P2(cid:5)(cid:5)D
G.

G = (cid:4)(cid:4)P1(cid:5)(cid:5)D

Deﬁnition 1. Let P1, P2 be graph patterns and D be a dataset with active graph
G. Then (cid:4)(cid:4)(P1 MINUS P2)(cid:5)(cid:5)D
A naive implementation of the MINUS operator in terms of the other operators
would be the graph pattern ((P1 OPT P2) FILTER C) where C is the ﬁlter constraint

(¬ bound(?X)) for some variable ?X ∈ var(P2) \ var(P1). This means that for
each mapping μ ∈ (cid:4)(cid:4)(P1 OPT P2)(cid:5)(cid:5)D
G at least one variable ?X occurring in P2,
but not occurring in P1, does not match (i.e., ?X is unbounded). There are two
problems with this solution:

– Variable ?X cannot be an arbitrary variable. For example, P2 could be in
turn an optional pattern (P3 OPT P4) where only variables in P3 are relevant.
– If var(P2) \ var(P1) = ∅ there is no variable ?X to check unboundedness.
The above two problems motivate the introduction of the notions of non-optional
variables and copy patterns.

The set of non-optional variables of a graph pattern P , denoted nov(P ), is a
subset of the variables of P deﬁned recursively as follows: nov(P ) = var(P ) when
P is a basic graph pattern; if P is either (P1 AND P2) or (P1 UNION P2) then
nov(P ) = nov(P1)∪nov(P2); if P is (P1 OPT P2) then nov(P ) = nov(P1); if P is
(n GRAPH P1) then either nov(P ) = nov(P1) when n ∈ I or nov(P ) = nov(P1)∪
{n} when n ∈ V ; and nov(P1 FILTER C) = nov(P1). Intuitively nov(P ) contains
the variables that necessarily must be bounded in any mapping of P .
Let φ : V → V be a variable-renaming function. Given a graph pattern P , a
copy pattern φ(P ) is an isomorphic copy of P whose variables have been renamed
according to φ and satisfying that var(P ) ∩ var(φ(P )) = ∅.

Theorem 1. Let P1 and P2 be graph patterns. Then:

(P1 MINUS P2) ≡ ((P1 OPT((P2 AND φ(P2)) FILTER C1)) FILTER C2)

(1)

where:

– C1 is the ﬁlter constraint (?X1 =?X
– C2 is the ﬁlter constraint (¬ bound(?X

i = φ(?Xi) for 1 ≤ i ≤ n.
(cid:4)

and ?X

1∧··· ∧?Xn =?X
(cid:4)
(cid:4))) for some ?X

n) where ?Xi ∈ var(P2)
(cid:4)

(cid:4) ∈ nov(φ(P2)).

122

R. Angles and C. Gutierrez

Note 4 (Why the copy pattern φ(P ) is necessary?).
Consider the naive implementation of diﬀerence of patterns, that is the graph
pattern ((P1 OPT P2) FILTER C) where C is the ﬁlter constraint (¬ bound(?X))
for some ?X ∈ var(P2)\var(P1). Note that such implementation would fail when
var(P2) \ var(P1) = ∅, because there exist no variables to check unboundedness.
To solve this problem, P2 is replaced by ((P2 AND φ(P2)) FILTER C1) where
φ(P2) is a copy of P2 whose variables have been renamed and whose relations
of equality with the original ones are in condition C1. Then we can use some
variable from φ(P2) to check if the graph pattern P2 does not match. The copy
pattern ensure that there will exist a variable to check unboundedness.

Note 5 (Why non-optional variables?). Consider the graph pattern

P = ((?X, name, ?N) MINUS((?X, knows, ?Y ) OPT(?Y, mail, ?Z))).

The naive implementation of P would be the graph pattern
= ((P1 OPT P2) FILTER(¬ bound(?Z))),

P

(cid:4)

Note that the evaluation of graph pattern P

where P1 = (?X,name, ?N), P2 = ((?X,knows, ?Y ) OPT(?Y,mail, ?Z)) and ?Z
is the variable selected to check unboundedness. (Note that variable ?Y could
also have been selected because ?Y ∈ var(P2) \ var(P1).)
(cid:4) diﬀers from that of pattern P . To
see the problem recall the informal semantics: a mapping μ matches the pattern
P if and only if μ matches P1 and μ does not match P2. This latter condition
means: it is false that every variable in P2 (but not in P1) is bounded. But to say
“every variable” is not correct in this context, because P2 contains the optional
pattern (?Y,mail, ?Z), and its variables could be unbounded for some valid solutions 
of P2. The problem is produced by the expression (¬ bound(?Z)), because
the bounding state of variable ?Z introduces noise when testing if pattern P2
gets matched.

Now, if we ensure the selection of a “non-optional variable” to check unboundedness 
when transforming P , we have that ?Y is the unique non-optional variable
occurring in P2 but not occurring in P1, i.e., variable ?Y works exactly as the
test to check if a mapping matching P1 matches P2 as well. Hence, instead of
(cid:4), the graph pattern
P
(cid:4)(cid:4)

= ((P1 OPT P2) FILTER(¬ bound(?Y )))

P

is the one that expresses faithfully the graph pattern (P1 MINUS P2), and in
fact, the evaluation of P

(cid:4)(cid:4) gives exactly the same set of mappings as P .

4 Avoiding Unsafe Patterns in SPARQLWG

One inﬂuential point in the evaluation of patterns in SPARQLWG is the behavior
of ﬁlters. What is the scope of a ﬁlter? What is the meaning of a ﬁlter having
variables that do not occur in the graph pattern to be ﬁltered?

The Expressive Power of SPARQL

123

It was proposed in [6] that for reasons of simplicity for the user and cleanness
of the semantics, the scope of ﬁlters should be the expression which they ﬁlter,
and free variables should be disallowed in the ﬁlter condition. Formally, a graph
pattern of the form (P FILTER C) is said to be safe if var(C) ⊆ var(P ). In [6]
only safe ﬁlter patterns were allowed in the syntax, and hence the scope of the
ﬁlter C is the pattern P which deﬁnes the ﬁlter condition. This approach is
further supported by the fact that non-safe ﬁlters are rare in practice.

The WG decided to follow a diﬀerent approach, and deﬁned the scope of a

ﬁlter condition C to be a case-by-case and context-dependent feature:

1. The scope of a ﬁlter is deﬁned as follows: a ﬁlter “is a restriction on solutions

over the whole group in which the ﬁlter appears”.

2. There is one exception, though, when ﬁlters combine with optionals. If a ﬁlter
expression C belongs to the group graph pattern of an optional, the scope
of C is local to the group where the optional belongs to. This is reﬂected in
lines 7 and 8 of Algorithm 1.

The complexities that this approach brings were recognized in the discussion
of the WG, and can be witnessed by the reader by following the evaluation of
patterns in SPARQLWG.

Let SPARQLSafe

WG be the subset of queries of SPARQLWG having only ﬁltersafe 
patterns. In what follows, we will show that, in SPARQLWG, non-safe ﬁlters
are superﬂuous, and hence its non-standard and case-by-case semantics can be
avoided. In fact, we will prove that non-safe ﬁlters do not add expressive power
to the language, or in other words, that SPARQLWG and SPARQLSafe
WG have the
same expressive power, that is, for each pattern P there is a ﬁlter-safe pattern
(cid:4) which computes exactly the same mappings as P .
P
The transformation safe(P ) is given by Algorithm 2. This algorithm works
as the identity for most patterns. The key part is the treatment of patterns
which combine ﬁlters and optionals. Line 9 is exactly the codiﬁcation of the
WG evaluation of ﬁlters inside optionals. For non-safe ﬁlters (see lines 15-20), it
(cid:4), where a free variable occurs, by either an
replaces each atomic ﬁlter condition C
(cid:4) is bound(·); or an expression bound(a) otherwise. (note
expression false when C
that bound(a) is evaluated to a logical value of error because a is a constant.)

Note 6 (On Algorithm 2). The expression in line 9 must be reﬁned for bag
semantics to the expression:

(cid:4) ← (((safe((P1 AND P3) FILTER C) UNION (safe(P1) MINUS safe(P3)))

P

UNION (safe(P1) MINUS(safe(P1) MINUS safe(P3))))

MINUS safe((P1 AND P3) FILTER C))

Lemma 1. For every pattern P , the pattern safe(P ) deﬁned by Algorithm 2 is
ﬁlter-safe and it holds (cid:4)(cid:4)P(cid:5)(cid:5) = (cid:4)(cid:4)safe(P )(cid:5)(cid:5).
Thus we proved:

Theorem 2. SPARQLWG and SPARQLSafe

WG have the same expressive power.

124

R. Angles and C. Gutierrez

(cid:4) ← ∅

(cid:4) ← safe(P )

else P

(cid:4) ← (safe(P1) OPT safe(P2))

if P2 is (P3 FILTER C) then

(cid:4) ← (safe(P1) OPT(safe((P1 AND P3) FILTER C)))

P

(cid:4) ← (safe(P1) AND safe(P2))
(cid:4) ← (safe(P1) UNION safe(P2))
(cid:4) ← (n GRAPH safe(P1))

Algorithm 2. Transformation of a general graph pattern into a safe pattern.
1: // Input: a SPARQLWG graph pattern P
2: // Output: a safe graph pattern P
3: P
4: if P is (P1 AND P2) then P
5: if P is (P1 UNION P2) then P
6: if P is (n GRAPH P1) then P
7: if P is (P1 OPT P2) then
8:
9:
10:
11: end if
12: if P is (P1 FILTER C) then
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25: end if
26: return P

if var(C) ⊆ var(safe(P1)) then P
else
for all ?X ∈ var(C) and ?X /∈ var(safe(P1)) do
for all atomic ﬁlter constraint C
if C

(cid:4) is (?X = u) or (?X =?Y ) or isIRI(?X) or isBlank(?X) or isLiteral(?X)
Replace in C the constraint C

(cid:4) by bound(a) //where a is a constant
(cid:4) by false

end for
end for
(cid:4) ← (safe(P1) FILTER C)
P

else if C

(cid:4) is bound(?X) then

Replace in C the constraint C

end if

(cid:4)

(cid:4) ← (safe(P1) FILTER C)

(cid:4) in C

5 Expressive Power of SPARQLWG is Equivalent to

SPARQLC

As we have been showing, the semantics that the WG gave to SPARQL departed
in some aspects from a compositional semantics. We also indicated that there
is an alternative formalization, with a standard compositional semantics, which
was called SPARQLC [6].

The good news is that, albeit apparent diﬀerences, these languages are equivalent 
in expressive power, that is, they compute the same class of queries.

Theorem 3. SPARQLSafe

WG is equivalent to SPARQLC under bag semantics.

The proof of this theorem is an induction on the structure of patterns. The only
non-evident case is the particular evaluation of ﬁlters inside optionals where
WG and SPARQLC diﬀer. Speciﬁcally, given a graph
the semantics of SPARQLSafe
pattern P = (P1 OPT(P2 FILTER C)), we have that SPARQLSafe
WG evaluates the
algebra expression LeftJoin(P1, P2, C), whereas SPARQLC evaluates P to the
expression (cid:2)P1(cid:3)(cid:2)(cid:3)(cid:3)(cid:4) (cid:2)P2 FILTER C(cid:3), which is the same as the SPARQLWG algebra
expression LeftJoin(P1, Filter(C, P2), true).

6 Expressive Power of SPARQLC

The Expressive Power of SPARQL

125

In this section we study the expressive power of SPARQLC by comparing it
against non recursive safe Datalog with negation (just Datalog from now on).

Note that because SPARQLC and Datalog programs have diﬀerent type of
input and output formats, we have to normalize them to be able to do the
comparison. Following deﬁnitions in section 2.4, let Ls = (Qs,Ds,Ss, anss) be
the SPARQLC language, and Ld = (Qd,Dd,Sd, ansd) be the Datalog language.
In this comparison we restrict the notion of SPARQLC Query to a pair (P, D)

where P is a graph pattern and D is an RDF dataset.

6.1 From SPARQLC to Datalog
To prove that Ls is contained in Ld, we deﬁne transformations TQ : Qs → Qd,
TD : Ds → Dd, and TS : Ss → Sd. That is, TQ transforms a SPARQLC query into
a Datalog query, TD transforms an RDF dataset into a set of Datalog facts, and
TS transforms a set of SPARQLC mappings into a set of Datalog substitutions.
RDF datasets as Datalog facts. Given a dataset D, the transformation TD(D)
works as follows: each term t in D is encoded by a fact iri(t), blank(t) or literal(t)
when t is an IRI, a blank node or a literal respectively; the set of terms in D
is deﬁned by the set of rules term(X) ← iri(X), term(X) ← blank(X), and
term(X) ← literal(X); the fact N ull(null) encodes the null value 6; each triple
(v1, v2, v3) in the default graph of D is encoded by a fact triple(g0, v1, v2, v3);
each named graph (cid:4)u, G(cid:5) in D is encoded by a fact graph(u) and each triple in
G is encoded by a fact triple(u, v1, v2, v3).
SPARQLC mappings as Datalog substitutions. Given a graph pattern P , a dataset
D with default graph G, and the set of mappings Ω = (cid:2)P (cid:3)D
G. The transformation
TS(Ω) returns a set of substitutions deﬁned as follows: for each mapping μ ∈ Ω
there exists a substitution θ ∈ TS(Ω) satisfying that, for each x ∈ var(P ) there
exists x/t ∈ θ such that t = μ(x) when μ(x) is bounded and t = null otherwise.
Graph patterns as Datalog rules. Let P be a graph pattern to be evaluated
against an RDF graph identiﬁed by g which occurs in dataset D. We denote by
δ(P, g)D the function which transforms P into a set of Datalog rules. Table 3
shows the transformation rules deﬁned by the function δ(P, g)D. The notion of
compatible mappings is implemented by the rules:
comp(X, X, X) ← term(X), comp(X, null, X) ← term(X),
comp(null, X, X) ← term(X) and comp(X, X, X) ← N ull(X).

Let ?X, ?Y ∈ V and u ∈ I ∪ L. An atomic ﬁlter condition C is encoded by
a literal L as follows: if C is either (?X = u) or (?X=?Y) then L is C; if C is
(isIRI(?X)) then L is iri(?X); if C is (isLiteral(?X)) then L is literal(?X); if C
is (isBlank(?X)) then L is blank(?X); if C is (bound(?X)) then L is ¬N ull(?X).
The transformation follows essentially the intuitive transformation presented
by Polleres [8] with the improvement of the necessary code to support faithful

6 We use the term null to represent an unbounded value.

126

R. Angles and C. Gutierrez

Table 3. Transforming SPARQLC graph patterns into Datalog Rules. D is a dataset
having active graph identiﬁed by g. var(P ) denotes the tuple of variables obtained from
a lexicographical ordering of the variables in the graph pattern P . Each pi is a predicate
identifying the graph pattern Pi. If L is a literal, then νj(L) denotes a copy of L with
its variables renamed according to a variable renaming function νj : V → V . cond is
a literal encoding the ﬁlter condition C. Each P1i is a copy of P1 and ui ∈ names(D).
P3 = (P1 AND P2), P4 = (P1 FILTER C1) and P5 = (P1 FILTER C2).

Pattern P

(x1, x2, x3)
(P1 AND P2)

δ(P, g)D
p(var(P )) ← triple(g, x1, x2, x3)
p(var(P )) ← ν1(p1(var(P1))) ∧ ν2(p2(var(P2)))

(cid:2)x∈var(P1)∩var(P2) comp(ν1(x), ν2(x), x),
δ(P1, g)D , δ(P2, g)D
dom(ν1) = dom(ν2) = var(P1) ∩ var(P2), range(ν1) ∩ range(ν2) = ∅.

(cid:4)
1(var(P1)) (cid:2)x∈var(P2)∧x /∈var(P1) N ull(x),

(P1 OPT P2)

(P1 UNION P2) p(var(P )) ← p1(var(P1)) (cid:2)x∈var(P2)∧x /∈var(P1) N ull(x),
p(var(P )) ← p2(var(P2)) (cid:2)x∈var(P1)∧x /∈var(P2) N ull(x),
δ(P1, g)D , δ(P2, g)D
p(var(P )) ← p1(var(P1)) ∧ ¬p
p(var(P )) ← p3(var(P3)),
1(var(P1)) ← p3(var(P3)),
(cid:4)
p
δ(P1, g)D , δ(P2, g)D , δ(P3, g)D
p(var(P )) ← p1(var(P1)),
δ(P1, u)D

(u GRAPH P1)
and u ∈ I
(?X GRAPH P1) p(var(P )) ← p11(var(P11)) ∧ graph(?X) ∧ ?X = u1,
and ?X ∈ V δ(P11, u1)D,

· ··
p(var(P )) ← p1n(var(P1n)) ∧ graph(?X) ∧ ?X = un,
δ(P1n, un)D

δ(P1, g)D

δ(P1, g)D , δ(P4, g)D

(P1 FILTER C) p(var(P )) ← p1(var(P1)) ∧ cond
C is atomic
(P1 FILTER C) p(var(P )) ← p1(var(P1)) ∧ ¬p4(var(P1)),
C is (¬(C1))
(P1 FILTER C) p(var(P )) ← p1(var(P1)) ∧ ¬p
(cid:4)(var(P1)),
(cid:4)(var(P1)) ← p1(var(P1)) ∧ ¬p
C is (C1 ∧ C2)
(cid:4)(cid:4)(var(P1)),
p
(cid:4)(cid:4)(var(P1)) ← p4(var(P1)) ∧ p5(var(P1)),
p
δ(P4, g)D , δ(P5, g)D
(cid:4)(var(P1)),
(cid:4)(cid:4)(var(P1))

(P1 FILTER C) p(var(P )) ← p1(var(P1)) ∧ ¬p
(cid:4)(var(P1)) ← p1(var(P1)) ∧ ¬p
C is (C1 ∨ C2)
p
(cid:4)(cid:4)(var(P1)) ← p4(var(P1)),
p
(cid:4)(cid:4)(var(P1)) ← p5(var(P1)),
p
δ(P4, g)D , δ(P5, g)D

The Expressive Power of SPARQL

127

translation of bag semantics. Speciﬁcally, we changed the transformations for
complex ﬁlter expressions by simulating them with double negation.
SPARQLC queries as Datalog queries. Given a graph pattern P , a dataset D
with default graph G, and the SPARQLC query Q = (P, D). The function
TQ(Q) returns the Datalog query (Π, p(var(P ))) where Π is the Datalog program 
TD(D) ∪ δ(P, g0)D, g0 identiﬁes the default graph G, and p is the goal
literal related to P .

The following theorem states that the above transformations work well.

Theorem 4. SPARQLC is contained in non-recursive safe Datalog with negation.

6.2 From Datalog to SPARQLC
Q : Qd → Qs,
To prove that Ld is contained in Ls, we deﬁne transformations T (cid:4)
T (cid:4)
S : Sd → Ss. That is, T (cid:4)
D : Dd → Ds, and T (cid:4)
Q transforms a Datalog query into an
SPARQLC query, T (cid:4)
D transforms a set of Datalog facts into an RDF dataset, and
T (cid:4)
S transforms a set of Datalog substitutions into a set of SPARQLC mappings.
Datalog facts as an RDF Dataset. Given a Datalog fact f = p(c1, ..., cn), consider
that desc(f) = { ( :b,predicate,p), ( :b,rdf: 1,c1),. . . ,( :b,rdf: n,cn) }, where :b
is a fresh blank node. Given a set of Datalog facts F , we have that T (cid:4)
D(F ) returns
an RDF dataset with default graph {desc(f) | f ∈ F}, where blank(desc(fi)) ∩
blank(desc(fj)) = ∅ for each fi, fj ∈ F with i (cid:8)= j.
Datalog substitutions as SPARQLC mappings. Given a set of substitutions Θ,
the transformation T (cid:4)
S(Θ) returns a set of mappings deﬁned as follows: for each
substitution θ ∈ Θ there exists a mapping μ ∈ T (cid:4)
S(Θ) satisfying that, if x/t ∈ θ
then x ∈ dom(μ) and μ(x) = t.
Datalog rules as SPARQLC graph patterns. Let Π be a Datalog program, and L
be a literal p(x1, . . . , xn) where p is a predicate in Π and each xi is a variable. We
deﬁne the function gp(L)Π which returns a graph pattern encoding the program
(Π, L), that is, the fragment of the program Π used for evaluating literal L.

The translation works intuitively as follows:

(b) If predicate p is intensional, then for each rule in Π of the form

(a) If predicate p is extensional, then gp(L)Π returns the graph pattern
((?Y, predicate, p) AND(?Y, rdf: 1, x1) AND ··· AND(?Y, rdf n, xn)),
where ?Y is a fresh variable.
L ← p1 ∧ ··· ∧ ps ∧ ¬q1 ∧ ··· ∧ ¬qt ∧ Leq
1 ∧ ··· ∧ Leq
u ,
where Leq
gp(L)Π returns a graph pattern with the structure
(((··· ((gp(p1)Π AND ··· AND gp(ps)Π)

k are literals of the form t1 = t2 or ¬(t1 = t2), we have have that

MINUS gp(q1))··· ) MINUS gp(qt))
FILTER(Leq

1 ∧ ··· ∧ Leq

u )).

(2)

The formal deﬁnition of gp(L)Π is Algorithm 3.

128

R. Angles and C. Gutierrez

(cid:4)
i) = xi
(cid:4)
do

(cid:4) ← gp(q)Π
(cid:4) AND gp(q)Π)

(cid:4) ← (P

if P
else P
end for
for each negative literal ¬q(y1, . . . , ym) in the body of r

Let ?Y be a fresh variable
P ← ((?Y, predicate, p) AND(?Y, rdf: 1, x1) AND·· · AND(?Y, rdf n, xn))
for each rule r ∈ Π with head p(x

(cid:4) ← ∅
P
C ← ∅
(cid:4) = ν(r) where ν is a substitution such that ν(x
Let r
for each positive literal q(y1, . . . , ym) in the body of r
(cid:4) = ∅ then P

Algorithm 3. Transformation of Datalog rules into SPARQLC graph patterns
1: //Input: a literal L = p(x1, . . . , xn) and a Datalog program Π
2: //Output: a SPARQLC graph pattern P = gp(L)Π
3: P ← ∅
4: if predicate p is extensional in Π then
5:
6:
7: else if predicate p is intensional in Π then
(cid:4)
(cid:4)
n) do
8:
1, . . . , x
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:
27:
28:
29:
30:
31: end if
32: return P

end for
(cid:4) ← (P
if C (cid:7)= ∅ then P
(cid:4) FILTER C)
if P = ∅ then P ← P
(cid:4)
else P ← (P UNION P
(cid:4))

end for
for each equality formula t1 = t2 in r

end for
for each negative literal ¬(t1 = t2) in r

if C = ∅ then C ← ¬(t1 = t2)
else C ← C ∧ ¬(t1 = t2)

if C = ∅ then C ← (t1 = t2)
else C ← C ∧ (t1 = t2)

(cid:4) ← (P

P

(cid:4) MINUS gp(q))

end for

(cid:4)

do

(cid:4) do

(cid:4)

do

Datalog queries as SPARQLC queries. Given a Datalog program Π, a literal
L = p(x1, . . . , xn), and the Datalog query Q = (Π, L). The function T (cid:4)
Q(Q)
returns the SPARQLC query (P, D) where P is the graph pattern gp(L)Π and
D is an RDF dataset with default graph T (cid:4)

D(facts(Π)).

The following theorem states that the above transformations work well.

Theorem 5. nr-Datalog¬ is contained in SPARQLC.

7 Conclusions

We have studied the expressive power of SPARQL. Among the most important
ﬁndings are the deﬁnition of negation, the proof that non-safe ﬁlter patterns are
superﬂuous, the proof of the equivalence between SPARQLWG and SPARQLC.

The Expressive Power of SPARQL

129

From these results we can state the most relevant result of the paper:

Theorem 6 (main). SPARQLWG has the same expressive power as Relational
Algebra under bag semantics.
This result follows from the well known fact (for example, see [1] and [5]) that
relational algebra and non-recursive safe Datalog with negation have the same
expressive power, and from theorems 2, 3, 4 and 5.

Relational Algebra is probably one of the most studied query languages, and
has become a favorite by theoreticians because of a proper balance between
expressiveness and complexity. The result that SPARQL is equivalent in its expressive 
power to Relational Algebra, has important implications which are not
discussed in this paper. Some examples are the translation of some results from
Relational Algebra into SPARQL, and the settlement of several open questions
about expressiveness of SPARQL, e.g., the expressive power added by the operator 
bound in combination with optional patterns. Future work includes the
development of the manifold consequences implied by the Main Theorem.

Acknowledgments. R. Angles was supported by Mecesup project No.
UCH0109. R. Angles and C. Gutierrez were supported by FONDECYT project
No. 1070348. The authors wish to thank the reviewers for their comments.

References

1. Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley,

2. Cyganiak, R.: A relational algebra for sparql. Technical Report HPL-2005-170, HP

Reading (1995)

Labs (2005)

3. Furche, T., Linse, B., Bry, F., Plexousakis, D., Gottlob, G.: RDF Querying: Language 
Constructs and Evaluation Methods Compared. In: Barahona, P., Bry, F.,
Franconi, E., Henze, N., Sattler, U. (eds.) Reasoning Web 2006. LNCS, vol. 4126,
pp. 1–52. Springer, Heidelberg (2006)

4. Klyne, G., Carroll, J.: Resource Description Framework (RDF) Concepts and Abstract 
Syntax (February 2004),
http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/

5. Levene, M., Loizou, G.: A Guided Tour of Relational Databases and Beyond.

Springer, Heidelberg (1999)

6. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL. In: Cruz,
I., Decker, S., Allemang, D., Preist, C., Schwabe, D., Mika, P., Uschold, M., Aroyo,
L.M. (eds.) ISWC 2006. LNCS, vol. 4273, pp. 30–43. Springer, Heidelberg (2006)

7. P´erez, J., Arenas, M., Gutierrez, C.: Semantics of SPARQL. Technical Report
TR/DCC-2006-17, Department of Computer Science, Universidad de Chile (2006)
8. Polleres, A.: From SPARQL to rules (and back). In: Proceedings of the 16th International 
World Wide Web Conference (WWW), pp. 787–796. ACM, New York
(2007)

9. Prud’hommeaux, E., Seaborne, A.: SPARQL Query Language for RDF (January

2008), http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/

10. Schenk, S.: A sparql semantics based on datalog. In: Hertzberg, J., Beetz, M., Englert,
 R. (eds.) KI 2007. LNCS (LNAI), vol. 4667, pp. 160–174. Springer, Heidelberg
(2007)

