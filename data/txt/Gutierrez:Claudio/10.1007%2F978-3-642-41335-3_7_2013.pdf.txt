The Logic of Extensional RDFS

Enrico Franconi1, Claudio Gutierrez2, Alessandro Mosca1,

Giuseppe Pirr`o1, and Riccardo Rosati3

1 KRDB, Free University of Bozen-Bolzano, Bolzano, Italy

2 Department of Computer Science, University of Chile, Santiago, Chile

3 University of Rome La Sapienza, Rome, Italy

Abstract. The normative version of RDF Schema (RDFS) gives nonstandard 
(intensional) interpretations to some standard notions such as
classes and properties, thus departing from standard set-based semantics.
In this paper we develop a standard set-based (extensional) semantics
for the RDFS vocabulary while preserving the simplicity and computational 
complexity of deduction of the intensional version. This result can
positively impact current implementations, as reasoning in RDFS can be
implemented following common set-based intuitions and be compatible
with OWL extensions.

1

Introduction

The Resource Description Framework (RDF) [9] is the standard data model
for publishing and interlinking data on the Web. Its associated vocabulary
RDF Schema (RDFS) (classes, properties, hierarchies) gives non-standard (in-
tensional) interpretations to some standard set theoretical notions such as classes
and properties. This brings some diﬃculties to the reasoning systems based on
classical ﬁrst-order logic (FOL). RDF enables the making of statements about
(Web) resources in the form of triples including a subject, a predicate and an
object expressed in manifold vocabularies. Eﬀorts like the Linked Open Data
project [8] give a glimpse of the magnitude of RDF data today available.

In many application scenarios, there is the need to have on top of RDF data
a language to structure knowledge domains. To cope with this aspect, the Web
Consortium developed standard vocabularies such as RDF Schema (RDFS) and
OWL. RDFS was designed with a minimalist philosophy and it includes essentially 
the machinery for expressing subclass, subproperty, type and such. On the
other hand, OWL is a more expressive language that includes a much richer set
of features.

From a standardization point of view the current normative RDFS has two
weaknesses. First, the interpretations of basic notions such as subclass and subproperty 
do not have the usual set-based meaning. For example, in in Fig. 1,
even though :birthCity is a subproperty :birthPlace, one cannot derive the
fact that the range of the property :birthCity must be :Place. Second, the
normative semantics of RDFS and OWL diﬀer for some of their common vocabularies.
 RDFS, for historical reasons, follows an intensional semantics while OWL

H. Alani et al. (Eds.): ISWC 2013, Part I, LNCS 8218, pp. 101–116, 2013.
c(cid:2) Springer-Verlag Berlin Heidelberg 2013

102

E. Franconi et al.

:Person

rdfs:domain

:birthPlace

rdfs:range

:Place

rdfs:subPropertyOf

:birthCity

rdf:type

e

g

n

r d f s :r a
r d f s

Not derivable with 
intensional RDFS 
inference rules

Of
s
s
Cla
b
u
rdfs:s

:Historical

Place

RDFS

rdfs:subClassOf

:Populated

Place

rdfs:subClassOf

:City

:Stanley
Kubrick

:birthCity

Manhattan

RDF

dbp:<http://dbpedia.org/>
dbpo:<http://dbpedia.org/ontology/>
rdf:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
rdfs:<http://www.w3.org/1999/02/22-rdf-syntax-ns#>

Fig. 1. An RDFS graph taken from dbpedia.org showing compatibility problems between 
OWL and RDFS. The dotted arrow is valid in OWL while not in RDFS.

adopts a standard extensional set-based semantics. This intensional semantics
of RDFS brings compatibility problems with OWL. In the example considered
shown in Fig. 1, the dotted rdfs:range property is a valid set-based deduction,
thus valid in OWL, while not derivable in RDFS.

The designers of RDFS were aware of this problem, and added in a “non-
normative” status the standard set-based semantics and some sound inference
rules for it. This so-called “extensional” version of RDFS corresponds exactly
to the standard set-based interpretation of the vocabulary (and thus is fully
compatible with OWL). The rationale for keeping a weaker (intensional) semantics 
for RDFS was eﬃciency: “In some ways the extensional versions provide a
simpler semantics, but they require more complex inference rules. The ’inten-
sional’ semantics [...] provides for most common uses of subclass and subproperty
assertions, and allows for simpler implementations of a complete set of RDFS
entailment rules.” (W3C RDFS Semantics Spec., [7]). According to this speciﬁcation,
 RDFS inference engines develop following the intensional semantics.

Thus, two relevant problems regarding the natural extensional RDFS semantics 
have prevented its usage: i) What is the complexity overload associated to
the extensional semantics for RDFS?; ii) Can normative RDFS inference engines
(based on the computation of a completion in a forward-chaining manner) be
easily extended to support extensional RDFS, and at which cost?

Contributions. This paper answer both question in the positive. First, we provide 
a simple sound and complete proof system for the extensional semantics of
RDFS. Second, we show that a meaningful completion of the graph computed by
using the rules in a forward-chaining manner can still be computed in

The Logic of Extensional RDFS

103

polynomial case (as for intensional RDFS) thus spurring on current system that
use completion. These two results can be seen as founding the ground for the developing 
of the extensional semantics for the RDFS vocabulary while preserving
the simplicity and computational complexity of deduction of the intensional case.
Our results can be considered as an extension of intensional RDFS. Our results
address not only an interesting theoretical open problem, but could impact on
current implementations (for the most part based on the normative intensional
semantics) in a positive sense. Indeed, we show that reasoning in RDFS can
follow common set-based intuitions and be compatible with OWL extensions.
Moreover, we show that the rule system that we present is easily embeddable in
existing libraries such as Jena.

2 Preliminaries

The Resource Description Framework (RDF) [9] and RDF Schema (RDFS) are
the W3C’s standard data model for the publishing and interlinking of data on
the Web. In RDF only simple statements about resources can be expressed via
triples: a resource may be an instance of another resource (representing a class
typing the instance) and/or a property of another resource. RDFS augments
RDF with some minimal vocabulary, allowing to express hierarchies of classes
and properties and to restrict the domain and range of properties. As an example
of an RDFS graph, see Fig. 1. In what follow we will give a simple presentation
abstracted from implementation (e.g., namespace) details.
Let U, L, B three pairwise disjoint sets representing the set of URIs, literals
and blank nodes, respectively. For simplicity, we denote unions of these sets by
simply concatenating their names.

Deﬁnition 1 (RDF triple, graph). An RDF triple t is a tuple of the form
(s, p, o) ∈ (UB)×U×(UBL), where s, p, o are called subject, predicate and object,
respectively. A triple is ground if it does not contain blank nodes. A (ground)
RDF graph G is a set of RDF (ground) triples. The vocabulary of G, denoted
voc(G), is the set of elements in UBL that occurs in its triples.

The ρdf Fragment
In this work we will concentrate on a simple and small fragment of RDFS,
which includes only the special RDFS vocabulary type, property, subClass,
subProperty, domain and range. This fragment is called ρdf and was introduced 
ﬁrst in [11]. It has been shown to capture the essential semantics of the
full fragment, while avoiding to deal with minor idiosyncrasies. In the following,

we will denote its vocabulary as Vρdf = {sc, sp, dom, range, type}. As it has been
shown in [11], ρdf is self-contained as it does not rely on the RDFS vocabulary
beyond this subset. ρdf is endowed with a set of inference rules that preserves
the original RDFS semantics restricted to this vocabulary [10].

The Intensional (Normative) Semantics
The normative semantics of RDFS [7] is built upon the standard logic notions of
model, interpretation and entailment. In the following we rephrase the normative

104

E. Franconi et al.

model theory of RDFS using ﬁrst-order logic (FOL) in the spirit of [4]. The
signature of the language includes a ternary predicate T –to represent RDF
triples – and two unary predicates C and P that will represent the membership of
individuals to “rdfs:Class” and “rdf:Property”, respectively. It can be proved
that, given a ρdf graph {(s1, p1, o1),··· , (sn, pn, on)}, its models according the
the models of the FOL formula ∃b T (s1, p1, o1) ∧ ··· ∧ T (sn, pn, on), where b is

the normative RDFS model theory in the W3C speciﬁcation [4] are the same as

the set of blank node symbols appearing in the graph, under the FOL theory
speciﬁed by the axioms listed below.

The basic axioms primitively deﬁne subClass, subProperty, domain, range

in terms of type in the obvious way –as in set theory1:

∀a, b (a, sc, b) −→ C(a) ∧ C(b) ∧ ∀x (x, type, a) → (x, type, b)
∀a, b (a, sp, b) −→ P (a) ∧ P (b) ∧ ∀x, y (x, a, y) → (x, b, y)
∀a, c (a, dom, c) −→ ∀x, y (x, a, y) → (x, type, c)
∀a, d (a, range, d) −→ ∀x, y (x, a, y) → (y, type, d)

(1)

(2)

(3)
(4)

To cope with reﬂexivity and transitivity of the subclass and subproperty relations
we have also the following axioms:

∀a, b, c (a, sc, b) ∧ (b, sc, c) −→ (a, sc, c)
∀a C(a) −→ (a, sc, a)
∀a, b, c (a, sp, b) ∧ (b, sp, c) −→ (a, sp, c)
∀aP (a) −→ (a, sp, a)

The following typing axioms are also needed in normative RDFS:

∀a, b (a, dom, b) −→ P (a) ∧ C(b)
∀a, b (a, range, b) −→ P (a) ∧ C(b)
∀a, b (a, type, b) −→ C(b)
∀a, b, c (a, b, c) −→ P (b)

P (sc) ∧ P (sp) ∧ P (dom) ∧ P (range) ∧ P (type)

(5)

(6)
(7)

(8)

(9)

(10)
(11)

(12)
(13)

The above axioms deﬁne the semantics for the subClass, subProperty, domain
and range predicates.

It is important to observe that rdfs:subClass, rdfs:subProperty, rdfs:
domain, rdfs:range are deﬁned only by means of necessary properties according
to the above axioms: the semantics of normative RDFS is a quite weak one, since
the RDFS vocabulary does not express fully the corresponding relations in set
theory. As a matter of facts, given the RDFS graph from Fig. 1, according the
normative RDFS semantics the statement (:birthCity, rdfs:range, :Place) is
not entailed. Such an entailment is expected since people do read the properties
in the RDFS vocabulary as the corresponding set-based relations – just like in

1 Note that for simplicity we may omit the T symbol in FOL formulas.

The Logic of Extensional RDFS

105

OWL. The normative RDFS semantics is called intensional, since it is unable to
deﬁne sets in terms of their elements.

The Extensional (Non-normative) Semantics
The W3C speciﬁcation [7] introduces in a “non-normative”status an extensional
version of RDFS, in which subClass, subProperty, domain, range are deﬁned
precisely as having the usual set theoretical meaning. This is achieved by adding
to the previous deﬁnition of the RDFS semantics the missing implication (leftdirection 
arrows) in axioms (1) to (4), thus getting axioms (14) to (17). Thus,
axioms (1) to (17) deﬁne the semantics of the non-normative extensional RDFS
restricted to the ρdf vocabulary. Note that axioms (1) to (8) are redundant, since
they can be derived from axioms (9) to (17). From now on we will refer to the
non-normative version of RDFS restricted to the ρdf vocabulary as ρdf +.

∀a, b (a, sc, b) ←→ C(a) ∧ C(b) ∧ ∀x (x, type, a) → (x, type, b)
∀a, b (a, sp, b) ←→ P (a) ∧ P (b) ∧ ∀x, y (x, a, y) → (x, b, y)
∀a, c (a, dom, c) ←→ ∀x, y (x, a, y) → (x, type, c)
∀a, d (a, range, d) ←→ ∀x, y (x, a, y) → (y, type, d)

(14)

(15)
(16)

(17)

This (extensional) semantics – which follows exactly the obvious extensional
deﬁnitions of the corresponding set-based operators – has been disregarded by
the W3C working group because of some computational problems that were conjectured 
during the deﬁnition of the speciﬁcation. In the non normative section
of the W3C speciﬁcation only a set of incomplete inference rules for extensional
RDFS is provided.

As for the relations with other KR formalisms, and with the family of description 
logics in particular, notice that it is easy to see that ρdf+ without
H
{core,pos,safe}, namely the well known
typing exactly corresponds to the DL-Lite
H
{core} description logic [2,1] without negation and unqualiﬁed existen-
DL-Lite
tial restrictions on the right-hand side of the inclusion axioms. Obviously, DLH

{core,pos,safe} includes the normative RDFS. It is easy to see that the usual
Lite
unqualiﬁed number restrictions of DL-Litecore, once on the left-hand side of the
inclusion axioms, can be used to encode the rdfs:domain and rdfs:range statements,
 while rdfs:subClass and rdfs:subProperty are nothing but usual DL
concept and role inclusion axioms, respectively.

Although the semantics of RDFS dates back to 2004 and despite the large
amount of research around it, there were still some important open problems
concerning extensional RDFS: i) whether a sound and complete system of inference 
rules existed; ii) whether a polynomial algorithm for computing the completion 
according to these extensional rules existed; iii) whether the problem of
entailment checking, crucial for query answering, can still be done in the same
complexity bound as for intensional RDFS. In this paper we tackle these three
problems and provide positive answers to each of them.

106

E. Franconi et al.

3 Reasoning with ρdf+: A Forward-Chaining System

This section presents a set of sound and complete inference rules for ρdf+ that
captures the extensional semantics of RDFS. Our ﬁndings complement the set of
rules in the ρdf fragment with additional rules derived from the analysis of axioms
(14)-(17). The complete set of rules is presented in Table 1. For example, the
missing deduction in Fig. 1 can be done now with rule 4(b) with the instantiations
A =birthCity, B =birthPlace and C =Place.

We will need some deﬁnitions for the discussion that follows. We follow the

notations of [11].

Deﬁnition 2 (Instantiations and maps)

1. An instantiation of a rule is a uniform replacement of the meta variables
occurring in the triples of the rule with elements in UBL, such that all the
triples obtained after the replacement are well-formed RDF triples.
2. A map is a function μ : UBL → UBL preserving URIs and literals i.e., μ(u) =
u for all u ∈ UL. Given a graph G we deﬁne μ(G) = {(μ(s), μ(p), μ(o)) :
(s, p, o) ∈ G}. By abusing notation, we speak of a map μ from a graph G1 to a
graph G2 and write μ : G1 → G2 if μ is such that μ(G1) is a subgraph of G2.

Deﬁnition 3 (Proof ). Let G and H be graphs. We say that G (cid:8)ρdf+ H iﬀ there
exists a sequence of graphs P1, P2, . . . , Pk, with P1 = G and Pk = H, and for
each j (2 ≤ j ≤ k) one of the following cases hold:
– there exists a map μ : Pj → Pj−1 (rule 8),
– there is an instantiation R

R(cid:2) of one of the rules (1)–(7) in Table 1 such that

R ⊆ Pj−1 and Pj = Pj−1 ∪ R(cid:3)

.

The sequence of rules used at each step (plus its instantiation or map), is called
a proof of H from G.

The ρdf+ system of rules extends the ρdf system [11] by the rules 3(b), 3(c),
4(b), 4(c) and (7). The following theorem states the soundness and completeness

of (cid:8)ρdf+.
Theorem 1 (Soundness and completeness). Let |=ρdf+ denote the entailment 
relation for the extensional ρdf+ semantics obtained from the axioms (1)-
(17). Then, the proof system (cid:8)ρdf+ (rules in Table 1) is sound and complete for
this extensional semantics; that is, for G and H graphs in ρdf+, then G (cid:8)ρdf+
H iﬀ G |=ρdf+ H.

Proof. The proof is available in the Appendix.

(cid:12)(cid:13)

Although the natural consequence of Theorem 1 would be that of dropping
the intensional (weaker) semantic conditions in the normative semantics and
replacing them with the extensional (stronger), it is still necessary to investigate 
whether ρdf+ brings in some source of complexity when applied to the

107
Table 1. The (cid:2)ρdf+ rule system for ρdf+. Capital letters A, B, C, X, and Y , stand
for meta-variables to be replaced by actual terms in UBL.

The Logic of Extensional RDFS

1. Subclass:

(a)

(A,sc,B) (X,type,A)

(X,type,B)

(b)

(A,sc,B) (B,sc,C)

(A,sc,C)

2. Subproperty:

(a)

(A,sp,B) (X,A,Y )

(X,B,Y )

(b)

(A,sp,B) (B,sp,C)

(A,sp,C)

3. Domain:

(a)

(A,dom,B) (X,A,Y )

(X,type,B)

(b)

(A,sp,B) (B,dom,C)

(A,dom,C)

(c)

(A,dom,B) (B,sc,C)

(A,dom,C)

4. Range:

(a)

(A,range,B) (X,A,Y )

(Y,type,B)

(b)

(A,sp,B) (B,range,C)

(A,range,C)

(c)

(A,range,B) (B,sc,C)

(A,range,C)

5. Subclass Reﬂexivity:

(a)

(A,sc,B)

(A,sc,A) (B,sc,B)

6. Subproperty Reﬂexivity:

(a)

(b)

(X,A,Y )
(A,sp,A)

(A,sp,B)

(A,sp,A) (B,sp,B)

(b)

(X,p,A)
(A,sc,A)

for p ∈ {dom, range, type}

(c) (p,sp,p)
(A,p,X)
(d)
(A,sp,A)

for p ∈ ρdf
for p ∈ {dom, range}

7. Extensional:

(type,sp,A) (A,dom,B) (X,sc,X)

(X,sc,B)

8. Simple:

G
G(cid:2)

for a map μ : G(cid:2) → G

following important reasoning tasks: i) computation of the closure; ii) checking
of entailment, crucial for query answering.

Computational Properties of ρdf+
The deductive closure of a graph G is the graph obtained by adding to G all
triples that are derivable from G. It can be computed by applying systematically
and recursively the inference rules in Table 1 to all the triples of G. The deductive
closure of a ρdf+ graph is in principle inﬁnite, due to the rule 8, which possibly
introduces new blank nodes. In order to get a ﬁnite but still useful completion of
the graph we can consider the closure of G over the same vocabulary of G, that is,
by adding only triples derivable from G which have elements in voc(G)∪Vρdf. We
will denote this restricted closure by clg(G) be the ground closure (or completion)

108

E. Franconi et al.

Table 1).

of a graph G as the closure via the (cid:8)ρdf+ ground rule system (rules (1)-(7) in
By observing that the number of existing triples with vocabulary in voc(G) ∪
Vρdf is of the order O(|G|3), and that all new triples in the closure of G will be

obtained by a successive applications of the rules of the proof system, we obtain
the following result:

Proposition 1 (Closure complexity). The size of the ground closure of a

ρdf graph clg(G) is at most O(|G|3) and it can be computed in polynomial time.
We will now present a result which states how ρdf+ entailment can be constructively 
reduced to computing (possibly oﬄine) and materialising the ﬁnite
polynomial completion of the data graph and then by querying the completion
with a standard RDF simple entailment query engine. Note that this is the very
same procedure which is used in real systems for the standard normative RDFS
entailment – of course with the reduced set of normative RDFS inference rules.
Proposition 2 (Entailment for ρdf +). Consider two RDFS graphs G (data)
and H (pattern). Then G |=ρdf+ H iﬀ clg(G) |=RDFsimple
Proof. By the completeness theorem, G (cid:8)ρdf+ H, which by deﬁnition of the closure 
is equivalent to clg(G) (cid:8)ρdf+ H, which means that H is in the completion
clg(G), unless there is an application of rule 8. In this case, H is got by using
the RDF simple entailment in the entailment checking –because of the homo-
(cid:12)(cid:13)
morphism checking.

H.

It can be easily seen that the combined complexity of entailment (in the size
of both graphs) is exactly the same as for normative RDFS and the ρdf system,
which is polynomial if H is a ground graph, and NP-hard otherwise [11]. On the
other hand, the data complexity of entailment (that is, only in the size of the
data graph G) is polynomial [4].

Materializing all data by computing the completion may cause a waste of
space if most of it is never really used. Deciding whether applying materialization
or checking entailment on the ﬂy with a speciﬁc algorithm depends on diﬀerent
factors such as: i) size of the graph: some graphs may not ﬁt in the main memory
and then the completion cannot be avoided; ii) updates: removing a triple from
the graph, causes implicit data to still exist if no special care is taken to remove
it. Hence, materialization vs. on the ﬂy checking is a trade-oﬀ between the better
performance of updates, or better performance of look-ups. For this purpose we
have studied a refutation proof system provably sound and complete for ρdf+
based on tableaux calculus, which in addition to ρdf+ deals also with negative
atoms in the data graph. Such a system, which we do not present here, is used
to check entailment on the ﬂy whenever it is not convenient to materialise the
completion (see [5] for further details).

4 Reasoning with Extensional RDFS in Practice

The aim of this section is to illustrate with simple examples the practical impact

of extensional RDFS reasoning. We discuss how the (cid:8)ρdf+ system of rules can

The Logic of Extensional RDFS

109

be embedded into the Apache Jena library and the impact that it has on the
computation of the completion of an RDFS graph.

The Jena Inference Engine
Jena is a comprehensive Semantic Web library providing a set of features for
data management and reasoning in OWL and RDFS. The library features four
predeﬁned reasoning engines: i) transitive reasoner, which just considers transitive 
and reﬂexive properties of RDFS sc and sp; ii) a conﬁgurable RDFS rule
reasoner ; iii) a conﬁgurable OWL reasoner ; iv) a custom reasoner. This latter
reasoner enables to provide a custom set of inference rules; it supports three
reasoning strategies: i) one implementing the RETE algorithm; ii) a forward
reasoner ; iii) a backward reasoner.

The availability of the custom reasoner is at the core of the integration of the
ground ρdf+ rule system; we have not implemented rule 7, since we assume that
data graphs do not redeﬁne rdf:type, that is, they do not have it in subject
nor object position. As an example the rule 3 (c) in Table 1 is speciﬁed in Jena
as: [3c: (?a dom ?b), (?b sc ?c)->(?a dom ?c)]. The speciﬁcation follows the
pattern [label: Ant ->Cons] where label is a name assigned to the rule, Ant
is the antecedent and Cons the consequent. It is also worth mentioning that the
reasoner can be conﬁgured to log derivations so that each triple obtained after
the reasoning task has associated an “explanation”, that is, the reasoning steps
(in terms of rules triggered) that led to the triple. The reader can consult the
Web page https://jena.apache.org/documentation/inference for further
details.

Comparing Inferences at Schema Level
We investigated the impact of ρdf+ on the completion of ﬁve existing ontologies.
This experiment only considers triples at schema level; as discussed previously,
we do not need to analyze derived rdf:type triples, since they would be the
same as the rdf:type triples derived by a normative RDFS reasoner. Table 2
provides some information about the ontologies considered.

Table 2. Statistics about the ontologies considered

Ontology #Classes #Properties #dom #range #sc #sp
DBpedia

1775
51
628
97
66

1505
47
535
97
61

FOAF

359
24
NEPOMUK 399
MusicOnto
70
140
VoxPopuli

1553
46
561
97
78

-
369
15
10
460 258
68
25
-
140

The considered ontologies have diﬀerent sizes; they range from small ontologies
such as FOAF (Friend-of-a-Friend) or MusicOnto (Music Ontology) to relatively
large ontologies like NEPOMUK and DBpedia. None of these (real-life) ontologies 
includes RDF triples redeﬁning the RDFS vocabulary, that is, containing the

110

E. Franconi et al.

Fig. 2. Size of the completions

(cid:3)(cid:8)(cid:11)(cid:5)(cid:8)(cid:10)(cid:6)(cid:9)(cid:8)(cid:4)(cid:7)(cid:1)
(cid:2)(cid:12)(cid:11)(cid:5)(cid:8)(cid:10)(cid:6)(cid:9)(cid:8)(cid:4)(cid:7)(cid:1)

(cid:9)(cid:5)(cid:11)(cid:10)(cid:8)(cid:13)(cid:7)(cid:1) (cid:4)(cid:3)(cid:11)(cid:18)(cid:17)(cid:19)(cid:15)(cid:1) (cid:14)(cid:22)(cid:26)(cid:1)(cid:11)(cid:22)(cid:23)(cid:25)(cid:20)(cid:19)(cid:1) (cid:8)(cid:25)(cid:24)(cid:19)(cid:16)(cid:1)

(cid:6)(cid:10)(cid:2)(cid:6)(cid:1)

(cid:36)(cid:30)(cid:1)

(cid:35)(cid:30)(cid:1)

(cid:34)(cid:30)(cid:1)

(cid:33)(cid:30)(cid:1)

(cid:32)(cid:30)(cid:1)

(cid:31)(cid:30)(cid:1)

(cid:30)(cid:1)

(cid:1)
(cid:28)
(cid:24)

(cid:21)

(cid:27)
(cid:1)
(cid:18)
(cid:21)
(cid:12)

(cid:19)

Fig. 3. Times for computing the completions

ρdf vocabulary in subject or object position. Fig. 2 shows some statistics about
the completion of the ontologies by considering the ρdf (intensional RDFS) and
ground ρdf+ (extensional RDFS) rule systems. The comparison between the
completions in terms of number of triples is also shown . As it can be observed
with ρdf+ we obtain a larger number of triples. This is due to the presence of the
rules 3(b), 3(c), 4(b) and 4(c) in Table 1 that enable to derive new rdfs:domain
and rdfs:range relations. The largest number was obtained when considering
DBpedia (∼4000 rdfs:domain and ∼ 1200 rdfs:range). The extensional completion 
contains an increase of triples of the order of 30% for DBpedia and
NEPOMUK, 60% for VoxPopuli, 20% for FOAF and 5% for MusicOnto. Fig. 3
reports the times (in ms) taken to compute the completion.

In the extensional case more time is needed because of the presence of additional 
inference rules. However, it can be observed that the time remains around
60ms with a large schema like DBpedia.

In order to give a hint on the kind of derivations enabled via ρdf+, Fig. 4 shows
two examples from DBpedia. In Fig. 4 (a) it is shown the new rdfs:range for
the property :beltwayCity obtained by applying rule 4 (c). Fig. 4 (b) shows

The Logic of Extensional RDFS

111

d: <http://dbpedia.org/ontology> rdfs: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

d:Settlement

    d:Athlete

rdfs:subClassOf

rdfs:range

rdfs:subClassOf

rdfs:domain

      d:City

rdfs:range

(a)

d:beltwayCity

    d:IceHockeyPlayer

rdfs:domain

(b)

d:prospectTeam

Fig. 4. Examples of new derivations with ρdf+

the derivation of a new rdfs:domain for the property :prospectTeam obtained
via rule 3(c).

5 Related Work

There is a solid body of research on RDFS. A formalisation of RDF regarding
databases issues was done by Gutierrez et al. [6]. Marin [10] and ter Horst [12]
came up with counterexamples (see Fig. 1) which, though pointing to the incompleteness 
of the W3C RDF Semantics speciﬁcation rules, showed an issue
belonging to the intensional approach to RDFS. The merit of Marin was to
overcome the issue keeping the original rules, and adding two additional ones,
and proved that the new set of rules was sound and complete. ter Horst instead
modiﬁed the rule system by allowing non-legal RDFS triples within the rule
system by using blank nodes in the predicate position. The formalization of the
semantics of RDF in FOL has been studied by de Brujin et al. [4]. Mu˜noz et
al. [11] introduced the ρdf fragment; this paper also discusses the quadratic lower
bound for the size of the completion of a graph G pointing out how such size is
impractical from a database point of view. To cope with this issue, the authors
introduce minimal RDFS, which imposes restrictions on the occurrence of the
RDFS vocabulary (it can only occur in predicate position). The advantage of
minimal RDFS is that there exists an eﬃcient algorithm to check graph entailment 
in the case of ground graphs. They also showed that if triples contain at
most one blank node the bound remains the same.

The common ground of these approaches is that they stick with the normative 
speciﬁcation, that is, intensional RDFS. Other approaches such as RDF-FLogic 
[13] depart from the normative speciﬁcation. Finally, yet other approaches
focus on the interplay between RDFS and other ontology languages such as
OWL (e.g., RDFS(DL) [3]) and the family of description logics DL-Lite [2,1]. In
contrast to the above approaches, our goal in this paper is to provide a bridge
between the normative (intensional) and non normative (extensional) parts of
the RDFS speciﬁcation, and study systematically the latter.

112

E. Franconi et al.

6 Conclusions

In this paper we investigated the extensional semantics for RDFS. Based on the
non-normative speciﬁcation given in the standard W3C RDF semantics speciﬁcation 
[7], we develop proof systems that show that one can get a practical,
eﬃcient and simple system for the extensional version of RDFS.

We answered an open problem since the publishing of the W3C RDF Semantics 
[7], which asked for the existence of a simple and eﬃcient system of rules to
codify extensional RDFS entailment. The results presented in the paper showed
that providing a set of sound and complete inference rules for extensional RDFS
is possible, and the complexity of computing the completion of an RDFS graph
remains the same as in the normative case.

Our results will impact on current reasoning libraries (e.g., Jena) for RDFS
that now can obtain more inferences at no signiﬁcantly additional cost, as emphasized 
by our evaluation. Last, but not least, this extensional version aligns
the semantics of RDFS and OWL, which previously were inconsistent due to the
diﬀerent meanings given by each of them to set-based notions such as subclass
and subproperty.

Acknowledgments. We thank the anonymous referees that provided helpful
suggestions. C. Gutierrez thanks the EMCL program for his stay at FUB. Franconi,
 Pirr`o, Mosca and Gutierrez were supported by Marie Curie action IRSES
- Net2 (Grant No. 24761). Gutierrez was supported by FONDECYT (Grant No.
1110287). R. Rosati was partially supported by the EU by FP7 project Optique
– Scalable End-user Access to Big Data (Grant No. FP7-318338).

References

1. Artale, A., Calvanese, D., Kontchakov, R., Zakharyaschev, M.: The DL-Lite family

and relations. J. Artif. Intell. Res. (JAIR) 36, 1–69 (2009)

2. Calvanese, D., Giacomo, G.D., Lembo, D., Lenzerini, M., Rosati, R.: Tractable
reasoning and eﬃcient query answering in description logics: The DL-Lite family.
Journal of Automated Reasoning 39(3), 385–429 (2007)

3. Cuenca Grau, B.: A possible simpliﬁcation of the semantic web architecture. In:

WWW, pp. 704–713. ACM (2004)

4. De Bruijn, J., Franconi, E., Tessaris, S.: Logical reconstruction of normative RDF.
In: OWL: Experiences and Directions Workshop (OWLED 2005), Galway, Ireland
(2005)

5. Franconi, E., Gutierrez, C., Mosca, A., Pirr`o, G., Rosati, R.: A Refutation System
for Extensional RDFS. Technical report, KRDB, Free University of Bozen-Bolzano
(2013), http://www.inf.unibz.it/krdb/pub/tech-rep.php

6. Gutierrez, C., Hurtado, C.A., Mendelzon, A.O., P´erez, J.: Foundations of semantic

web databases. Journal of Computer and System Sciences 77(3), 520–541 (2011)

The Logic of Extensional RDFS

113

7. Hayes, P., McBride, B.: RDF semantics. W3C Reccomandation (2004),

http://www.w3.org/tr/rdf-mt

8. Heath, T., Bizer, C.: Linked data: Evolving the web into a global data space. Synthesis 
Lectures on the Semantic Web: Theory and Technology 1(1), 1–136 (2011)
9. Klyne, G., Carroll, J.J., McBride, B.: Resource description framework (RDF): Concepts 
and abstract syntax. W3C Recommendation 10 (2004)

10. Marin, D.: A formalization of rdf. Technical report, Technical Report TR/DCC-

2006-8, TR Dept. Computer Science, Universidad de Chile (2006)

11. Mu˜noz, S., P´erez, J., Gutierrez, C.: Simple and eﬃcient minimal RDFS. Journal

of Web Semantics 7(3), 220–234 (2009)

12. ter Horst, H.J.: Completeness, decidability and complexity of entailment for RDF
schema and a semantic extension involving the OWL vocabulary. Web Semantics:
Science, Services and Agents on the World Wide Web 3(2), 79–115 (2005)

13. Yang, G., Kifer, M.: Reasoning about anonymous resources and meta statements
on the semantic web. In: Spaccapietra, S., March, S., Aberer, K. (eds.) Journal on
Data Semantics I. LNCS, vol. 2800, pp. 69–97. Springer, Heidelberg (2003)

Appendix: Proof of Theorem 1

The following provides a sketch of the argument that proves the completeness

of the (cid:8)ρdf+ rule system: For graphs G and H in the ρdf+ vocabulary:

G (cid:8)ρdf+ H iﬀ G |=ρdf+ H.

While the soundness theorem (from left to right) follows straightforwardly from

orem (from right to left) requires more eﬀort to be proved. The proof is heavily

the observation that each rule in (cid:8)ρdf+ preserves validity, the completeness thebased 
in the completeness theorem for the similar (intensional) (cid:8)ρdf system given
in [11]. The notions of |=ρdf and (cid:8)ρdf can be found in that paper. First, we need

some auxiliary notion of extended closure.
Deﬁnition 4. The extended closure of a graph G, denoted (cid:2)cl(G), is the set of
triples entailed from G under ρdf entailment (|=ρdf) plus the axioms (14) - (17).
We now rephrase (cid:2)cl(G) using the (cid:8)ρdf rule system instead of |=ρdf entailment.
Lemma 1. The extended closure of a graph G is the set of triples derived from
G using (cid:8)ρdf plus the axioms (14) - (17).
Proof. Use the known fact (Theorem 8 from [11]) that, if graphs G and H are
in the ρdf vocabulary, G (cid:8)ρdf H iﬀ G |=ρdf H.
(cid:12)(cid:13)

The next lemma is at the key to the proof of the theorem:

Lemma 2 (Main). If graphs G and H are in the ρdf vocabulary, then

(cid:2)cl(G) (cid:8)ρdf H iﬀ G (cid:8)ρdf+ H.

114

E. Franconi et al.

From Lemma 1 above it follows that we only have to show how each triple

derived with the axioms (14) - (17) can be also derived with (cid:8)ρdf+ and vice-versa.

The strategy aims at showing, through an exhaustive combinatoric analysis,
that whatever can be derived by the axioms (14) to (17) can be derived with

the (cid:8)ρdf+ rule system as well. There are two operations working at the syntactic

level: axiom instantiation and pattern matching. By means of these operations
one can start combining together the axioms, until no more new syntactically
well formed sentences are derivable. The proof strategy then is grounded on the
fact that the only signiﬁcant ways the axioms can be combined together give
rise to nothing but the atoms that are present in the (cid:8)ρdf+ system. Note that
we can restrict to the case when H is one atom, because for ground atoms p, q
it holds Σ |= p ∧ q iﬀ Σ |= p and Σ |= q.
Proof. We will introduce for convenience auxiliary extended deductive rules allowing 
“implications” in the antecedent or in the consequent. This allows to
codify formulas (14)-(17) as follows:

14a

15a

16a

17a

(A,sc,B)

∀x−→(x,type,B) 14b (A,sc,A)∧(B,sc,B)∧(x,type,A)

(A,sc,B)

(x,type,A)

∀x−→(x,type,B)

(sc)

(P,sp,Q)

∀xy−→(x,Q,y)

(x,P,y)

(P,dom,A)

∀xy−→(x,type,A)

(x,P,y)

(P,range,A)

∀xy−→(y,type,A)

(x,P,y)

15b (A,sc,A)∧(B,sc,B)∧(x,P,y)

(P,sp,Q)

∀xy−→(x,Q,y)

(sp)

16b (x,P,y)

∀xy−→(x,type,A)

(P,dom,A)

17b (x,P,y)

∀xy−→(y,type,A)

(P,range,A)

(domain)

(range)

The following are a few remarks to be made on the usage of this new system:
1. Rules with an implication in the antecedent (being universally quantiﬁed)
cannot be ﬁred from the graph G because of the presence of the open world
assumption, we cannot know from G if it is valid or not.

2. Two implications can be matched if the meaning of the formulas allow so.

∀x−→ (x, type, B) and (y, type, B)

∀y−→ (y, type, C)

For example, (x, type, A)
would produce another rule:

(x, type, A)

∀x−→ (x, type, B)
(z, type, A)

(y, type, B)
∀z−→ (z, type, C)

∀y−→ (y, type, C)

(18)

3. The only way to use an implication in a combination of rules is, either:

(a) To combine it with another implication to derive a third implication
(e.g., to form rules of the form (18)). Table 4 summarizes the only admissible 
results one can obtain out the combination operation (we use
the notation r1 (cid:2) r2 to indicate that rule r1 is combined with rule r2).
Note that the only possible relevant formula one could get with this procedure 
is a formula of the type ∀x(x, type, A) → (x, type, B), thus, to
deduce a triple of the form (u, sc, v) using rule (14b). Note also that
one cannot use the rules (15b), (16b) or (17b), because they need both
variables universally quantiﬁed.

The Logic of Extensional RDFS

115

Table 3. Inference rules obtained by instantiating and combining rules (14a)-(17a).
Rule 7bis can be obtained in turn from 7 and 6c, thus does not appear in Table 1.

Instantiation/Combination

Rule obtained

Rule in ρdf+ Rule in RDFS

(15a-inst)(cid:2)16a(cid:2)14b

(16a-inst)(cid:2)14b(cid:2)14a

(type,sp,A),(A,dom,B),(X,sc,X)

(type,dom,A),(X,sc,X)

(X,sc,B)

(X,sc,A)

7

7 bis

not available

not available

(b) To instantiate the implication in the consequent, and using the Deduction 
Theorem (p (cid:8) q→r iﬀ p, q (cid:8) r). Consider for instance rule (14a); we
∀x−→ (x, type, B). By using the deduction
have: (A, sc, B) (cid:8) (x, type, A)
theorem, we obtain: (A, sc, B) (x, type, A) (cid:8) (x, type, B). By systematically 
applying this process to rules (14a)-(17a), we obtain the rules in
Table 5.

(c) To use instantiation that make it possible to combine rules. For example
the new rule 7 Extensional follows from rule (15a) instantiated with
P = type, which combined with the rule for domain (16a), gives the
implication ∀x(x, type, y) → (x, type, B), which using rule (14b) gives
(y, sc, B) for y class. Table 3 shows the results of the application of the
instantiation-plus-combination operation.

Table 4. Inference rules obtained by combining rules (14a)-(17a)

Combination Rule obtained Rule in (cid:2)ρdf+ Rule in intensional RDFS

14a(cid:2)14a
15a(cid:2)15a
15a(cid:2)16a
15a(cid:2)17a
16a(cid:2)14a
17a(cid:2)14a

(A,sc,B) (B,sc,C)

(A,sc,C)

(P,sp,Q) (Q,sp,R)

(P,sp,R)

(P,sp,Q) (Q,dom,A)

(P,dom,A)

(P,sp,Q) (Q,range,A)

(P,range,A)

(P,dom,A) (A,sc,B)

(P,dom,B)

(P,range,A) (A,sc,B)

(P,range,B)

1b

2b

3b

4b

3c

4c

rdfs 11

rdfs 5

not available

not available

not available

not available

Table 5. Set of inference rules obtained by instantiating rules (14a)-(17a)

Rule Instantiated Rule obtained Rule in ρdf+ Rule in intensional RDFS

13a

14a

15a

16a

(A,sc,B) (X,type,A)

(X,type,B)

(P,sp,Q) (X,P,Y )

(X,Q,Y )

(P,dom,A) (X,P,Y )

(X,type,A)

(A,range,B) (X,A,Y )

(Y,type,B)

1a

2a

3a

4a

rdfs 9

rdfs 7

rdfs 2

rdfs 3

The presented proof system is the collection of all rules obtained. In particular,
 an exhaustive combinatorics indicates that the only possible cases are those
considered in ρdf+. The idea is as follows:

116

E. Franconi et al.

1. Note that the only possible relevant formula one could get with the introduced 
procedure is a formula of the type ∀x(x, type, A) → (x, type, B),
thus, to deduce a triple of the form (u, sc, v) using rule (14b). Note that one
cannot use the other rules (15b), (16b) or (17b), because they need both
variables universally quantiﬁed.

2. With (1) in mind, one should start looking for the successful combinations.
(a) Those that begin with (x, type, y): could be rules (15a), (16a) or (17a) instantiated 
with P = type. As for Rule (15a), we should instantiate also
y = C, but in this case the rule will give ∀x(x, type, C) → (x, Q, C),
whose consequent cannot be further combined unless Q = type, which
gives nothing. As for rule (16a), it gives our rule 7bis, while rule (17a)
is useless for this argument (notice that in (17a) the y in the implication 
changes its position from third to ﬁrst thus making impossible the
combination with (14b)).

(b) Those that end with (x, type, y): here rule (16a) is relevant once y is
instantiated to a constant; and rules (16a) and (17a) with the restriction
x = y. It is not diﬃcult to note that the ﬁrst case is useful only for
the instantiation P = type. In the second case, the only productive
(cid:12)(cid:13)
combination is to combine it with rule (15a) weakened to x = y.

Now are read to prove the statement of Theorem 1:

Proof. G |=ρdf+ H

only ρdf vocabulary)

iﬀ G |=RDFS+ H (by deﬁnition of |=ρdf+)
iﬀ G ∪ {axioms 14 − 17} |=RDFS H (by deﬁnition of RDFS+)
iﬀ (cid:2)cl(G) |=RDFS H (by Deﬁnition 4)
iﬀ (cid:2)cl(G) |=ρdf H (Theorem 5 from [11]) because left and right hand sides have
iﬀ (cid:2)cl(G) (cid:8)ρdf H (Soundness and completeness of ρdf –Theorem 8 from [11]–
iﬀ G (cid:8)ρdf+ H (by Lemma 2).

because there is only ρdf vocabulary)

(cid:12)(cid:13)

