6
1
0
2

 

n
u
J
 

6

 
 
]

B
D
.
s
c
[
 
 

4
v
3
5
0
6
0

.

3
0
6
1
:
v
i
X
r
a

Negation in SPARQL

Renzo Angles1,3 and Claudio Gutierrez2,3

1 Dept. of Computer Science, Universidad de Talca, Chile
2 Dept. of Computer Science, Universidad de Chile, Chile

3 Center for Semantic Web Research

Abstract. This paper presents a thorough study of negation in SPARQL.
The types of negation supported in SPARQL are identiﬁed and their
main features discussed. Then, we study the expressive power of the corresponding 
negation operators. At this point, we identify a core SPARQL
algebra which could be used instead of the W3C SPARQL algebra. Finally,
 we analyze the negation operators in terms of their compliance
with elementary axioms of set theory.

1

Introduction

The notion of negation has been largely studied in database query languages,
mainly due to their implications in aspects of expressive power and computational 
complexity [7–9, 15, 19]. There have been proposed several and distinct
types of negation, and it seems diﬃcult to get agreement about a standard
one. Such heterogeneity comes from intrinsic properties and semantics of each
language, features that determine its ability to support speciﬁc type(s) of nega-
tion(s). For instance, rule-based query languages (e.g. Datalog) usually implement 
“negation by failure”, algebraic query languages (e.g. the relational alge-
bra) usually include a Boolean-like diﬀerence operator, and SQL-like query languages 
support several versions of negation, and operators that combine negation
with subqueries (e.g. NOT EXISTS).

The case of SPARQL is no exception. SPARQL 1.0 did not have any explicit 
form of negation in its syntax, but could simulate negation by failure.
For the next version, SPARQL 1.1, the incorporation of negation generated a
lot of debate. As result, SPARQL 1.1 provides four types of negation: negation
of ﬁlter constraints, by using the Boolean NOT operator; negation as failure,
implemented as the combination of an optional graph pattern and the bound
operator; diﬀerence of graph patterns, expressed by the MINUS operator; and
existential negation of graph patterns, expressed by the NOT-EXISTS operator.
The main positive and negative aspects of these types of negation are remarked 
in the SPARQL speciﬁcations, and more detailed discussions are available 
in the records of the SPARQL working group4. However, to the best of our
knowledge, there exists no formal study about negation in SPARQL. This is the
goal we tackle throughout this document.

4 https://www.w3.org/2009/sparql/wiki/Design:Negation

In this paper we present a thorough study of negation in SPARQL. First, we
formalize the syntax and semantics of the diﬀerent types of negation supported
in SPARQL, and discuss their main features. Then, we study the relationships
(in terms of expressive power) among the negation operators, ﬁrst at the level of
the SPARQL algebra, and subsequently at the level of SPARQL graph patterns.
Finally, we present a case-by-case analysis of the negation operations with respect
to their compliance with elementary axioms of set theory.

It would be good to have a simple version of negation operators that conform
to a known intuition. This is the other main contribution of this paper. First
we introduce the DIFF operator as another way of expressing the negation of
graph patterns (it is the SPARQL version of the EXCEPT operator of SQL).
The semantics of DIFF is based on a simple diﬀerence operator introduced at
the level of the SPARQL algebra. With this new diﬀerence operator, we show
that one can deﬁne a core algebra (i.e. projection, selection, join, union and
simple diﬀerence) which is able to express the W3C SPARQL algebra. We show
that this algebra is also able to deﬁne the SPARQL operators, thus it can be
considered a sort of “core” SPARQL algebra. Additionally, we show that the
DIFF operator behaves well regarding its compliance with well known axioms
of set theory.

Organization of the paper. The syntax and semantics of SPARQL graph patterns
are presented in Section 2. In Section 3, we discuss the main characteristics of the
types of negation supported by SPARQL. The expressive power of the negation
operators is studied in Section 4. In Section 5, we analyze set-theoretic properties
of two negation operators. Finally, some conclusions are presented in Section 6.

2 SPARQL graph patterns

The following deﬁnition of SPARQL graph patterns is based on the formalism
used in [16], but in agreement with the W3C SPARQL speciﬁcations [17, 10].
Particularly, graph patterns will be studied assuming bag semantics (i.e. allowing
duplicates in solutions).

RDF graphs. Assume two disjoint inﬁnite sets I and L, called IRIs and literals
respectively. An RDF term is an element in the set T = I ∪ L5. An RDF triple
is a tuple (v1, v2, v3) ∈ I × I × T where v1 is the subject, v2 the predicate and
v3 the object. An RDF Graph (just graph from now on) is a set of RDF triples.
The union of graphs, G1 ∪ G2, is the set theoretical union of their sets of triples.
Additionally, assume the existence of an inﬁnite set V of variables disjoint from
T . We will use var(α) to denote the set of variables occurring in the structure α.

5 In addition to I and L, RDF and SPARQL consider a domain of anonymous resources
called blank nodes. The occurrence of blank nodes introduces several issues that are
not discussed in this paper. Based on the results presented in [11], we avoid the
use of blank nodes assuming that their absence does not largely aﬀect the results
presented in this paper.

p

q

true

p ∧ q p ∨ q
true
true
true
true
true
true
false false
true
true error error
false
false
true
false false false false
false error false error
error
true
error false false error
error error error error

true error

p

¬p
false
true
true
false
error error

Table 1. Three-valued logic for evaluating selection formulas.

A solution mapping (or just mapping from now on) is a partial function
µ : V → T where the domain of µ, dom(µ), is the subset of V where µ is deﬁned.
The empty mapping, denoted µ0, is the mapping satisfying that dom(µ0) = ∅.
Given ?X ∈ V and c ∈ T , we use µ(?X) = c to denote the solution mapping
variable ?X to term c. Similarly, µ?X→c denotes a mapping µ satisfying that
dom(µ) = {?X} and µ(?X) = c. Given a ﬁnite set of variables W ⊂ V , the
restriction of a mapping µ to W , denoted µ|W , is a mapping µ′ satisfying that
dom(µ′) = dom(µ) ∩ W and µ′(?X) = µ(?X) for every ?X ∈ dom(µ) ∩ W . Two
mappings µ1, µ2 are compatible, denoted µ1 ∼ µ2, when for all ?X ∈ dom(µ1) ∩
dom(µ2) it satisﬁes that µ1(?X) = µ2(?X), i.e., when µ1 ∪ µ2 is also a mapping.
Note that two mappings with disjoint domains are always compatible, and that
the empty mapping µ0 is compatible with any other mapping.

A selection formula is deﬁned recursively as follows: (i) If ?X, ?Y ∈ V and
c ∈ I ∪ L then (?X = c), (?X =?Y ) and bound(?X) are atomic selection
formulas; (ii) If F and F ′ are selection formulas then (F ∧ F ′), (F ∨ F ′) and
¬(F ) are boolean selection formulas. The evaluation of a selection formula F
under a mapping µ, denoted µ(F ), is deﬁned in a three-valued logic (i.e. with
values true, false, and error) as follows:

– If F is ?X = c and ?X ∈ dom(µ), then µ(F ) = true when µ(?X) = c and

µ(F ) = false otherwise. If ?X /∈ dom(µ) then µ(F ) = error.

– If F is ?X =?Y and ?X, ?Y ∈ dom(µ), then µ(F ) = true when µ(?X) =
µ(?Y ) and µ(F ) = false otherwise. If either ?X /∈ dom(µ) or ?Y /∈ dom(µ)
then µ(F ) = error.

– If F is bound(?X) and ?X ∈ dom(µ) then µ(F ) = true else µ(F ) = false.
– If F is a complex selection formula then it is evaluated following the threevalued 
logic presented in Table 1.

A multiset (or bag) of solution mappings is an unordered collection in which
each solution mapping may appear more than once. A multiset will be represented 
as a set of solution mappings, each one annotated with a positive integer
which deﬁnes its acity (i.e. its cardinality). We use the symbol Ω to denote a multiset 
and card(µ, Ω) to denote the cardinality of the mapping µ in the multiset

Ω. In this sense, it applies that card(µ, Ω) = 0 when µ /∈ Ω. We use Ω0 to denote
the multiset {µ0} such that card(µ0, Ω0) > 0 (Ω0 is called the join identity). The
domain of a solution mapping Ω is deﬁned as dom(Ω) = Sµ∈Ω dom(µ).

W3C SPARQL algebra. Let Ω1, Ω2 be multisets of mappings, W be a set of
variables and F be a selection formula. The SPARQL algebra for multisets of
mappings is composed of the operations of projection, selection, join, diﬀerence,
left-join, union and minus, deﬁned respectively as follows:

– πW (Ω1) = {µ′ | µ ∈ Ω1, µ′ = µ|W }
where card(µ′, πW (Ω1)) = Pµ′=µ|W

– σF (Ω1) = {µ ∈ Ω1 | µ(F ) = true}

card(µ, Ω1)

where card(µ, σF (Ω1)) = card(µ, Ω1)

– Ω1 ⋊⋉ Ω2 = {µ = (µ1 ∪ µ2) | µ1 ∈ Ω1, µ2 ∈ Ω2, µ1 ∼ µ2}

where card(µ, Ω1 ⋊⋉ Ω2) = Pµ=(µ1∪µ2) card(µ1, Ω1) × card(µ2, Ω2)

– Ω1\F Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, (µ1 ≁ µ2)∨(µ1 ∼ µ2∧(µ1∪µ2)(F ) = false)}

where card(µ1, Ω1 \F Ω2) = card(µ1, Ω1)

– Ω1 ∪ Ω2 = {µ | µ ∈ Ω1 ∨ µ ∈ Ω2}

where card(µ, Ω1 ∪ Ω2) = card(µ, Ω1) + card(µ, Ω2)

– Ω1 − Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2 ∨ dom(µ1) ∩ dom(µ2) = ∅}

where card(µ1, Ω1 − Ω2) = card(µ1, Ω1)
– Ω1qy⋊⋉ F Ω2 = σF (Ω1 ⋊⋉ Ω2) ∪ (Ω1 \F Ω2)

where card(µ, Ω1qy⋊⋉ F Ω2) = card(µ, σF (Ω1 ⋊⋉ Ω2)) + card(µ, Ω1 \F Ω2)

Syntax of SPARQL graph patterns. A SPARQL graph pattern is deﬁned recursively 
as follows:

– A tuple from (I ∪ L ∪ V ) × (I ∪ V ) × (I ∪ L ∪ V ) is a graph pattern called a

triple pattern. 6

– If P1 and P2 are graph patterns then (P1 AND P2), (P1 UNION P2),

(P1 OPT P2), (P1 MINUS P2) and (P1 NOT-EXISTS P2) are graph patterns.
– If P1 is a graph pattern and C is a ﬁlter constraint (as deﬁned below) then

(P1 FILTER C) is a graph pattern.

A ﬁlter constraint is deﬁned recursively as follows: (i) If ?X, ?Y ∈ V and
c ∈ I ∪L then (?X = c), (?X =?Y ) and bound(?X) are atomic ﬁlter constraints;
(ii) If C1 and C2 are ﬁlter constraints then (!C1), (C1 || C2) and (C1 && C2)
are complex ﬁlter constraints. Given a ﬁlter constraint C, we denote by f (C) the
selection formula obtained from C. Note that there exists a simple and direct
translation from ﬁlter constraints to selection formulas and viceversa.

Given a triple pattern t and a mapping µ such that var(t) ⊆ dom(µ), we
denote by µ(t) the triple obtained by replacing the variables in t according
to µ. Overloading the above deﬁnition, we denote by µ(P ) the graph pattern
obtained by the recursive substitution of variables in every triple pattern and
ﬁlter constraint occurring in the graph pattern P according to µ.

6 We assume that any triple pattern contains at least one variable.

Semantics of SPARQL graph patterns. The evaluation of a SPARQL graph pattern 
P over an RDF graph G is deﬁned as a function JP KG (or JP K where G
is clear from the context) which returns a multiset of solution mappings. Let
P1, P2, P3 be graph patterns and C be a ﬁlter constraint. The evaluation of a
graph pattern P over a graph G is deﬁned recursively as follows:

1. If P is a triple pattern t, then JP KG = {µ | dom(µ) = var(t) ∧ µ(t) ∈ G}

where each mapping µ has cardinality 1.

2. J(P1 AND P2)KG = JP1KG ⋊⋉ JP2KG
3. If P is (P1 OPT P2) then

(a) if P2 is (P3 FILTER C) then JP KG = JP1KGqy⋊⋉ f (C)JP3KG
(b) else JP KG = JP1KGqy⋊⋉ (true)JP2KG
4. J(P1 MINUS P2)KG = JP1KG − JP2KG
5. J(P1 NOT-EXISTS P2)KG = {µ | µ ∈ JP1KG ∧ Jµ(P2)KG = ∅}
6. J(P1 UNION P2)KG = JP1KG ∪ JP2KG
7. J(P1 FILTER C)KG = σf (C)(JP1KG)

3 Types of negation in SPARQL

We can distinguish four types of negation in SPARQL: negation of ﬁlter constraints,
 negation as failure, negation by MINUS and negation by NOT-EXISTS.
The main features of these types of negation will be discussed in this section.

Negation of ﬁlter constraints. The most basic type of negation in SPARQL
is the one allowed in ﬁlter graph patterns by including constraints of the form
(!C). Following the semantics of SPARQL, a graph pattern (P FILTER(!C)),
returns the mappings µ in JP K such that µ satisﬁes the ﬁlter constraint (!C), i.e.
µ does not satisfy the constraint C.

Considering that the evaluation of a graph pattern could return mappings
with unbound variables (similar to NULL values in SQL), SPARQL uses a threevalued 
logic for evaluating ﬁlter graph patterns, i.e. the evaluation of a ﬁlter
constraint C can result in true, false or error. For instance, given a mapping µ,
the constraint ?X = 1 evaluates to true when µ(?X) = 1, false when µ(?X) 6= 1,
and error when ?X /∈ dom(µ). Note that FILTER eliminates any solutions that
result in false or error. Recalling the semantics deﬁned in Table 1, we have that
(!C) evaluates to true when C is false, false when C is true, and error when C
is error. This type of negation, called strong negation [20], allows to deal with
incomplete information in a similar way to the NOT operator of SQL.

The negation of ﬁlter constraints is a feature well established in SPARQL
and does not deserve major discussion. In the rest of the paper we concentrate
our interest on the negation of graph patterns.

Negation as failure. SPARQL 1.0 does not include an operator to express
the negation of graph patterns. In an intent of patching this issue, the SPARQL
speciﬁcation remarks that the negation of graph patterns can be implemented

as a combination of an optional graph pattern and a ﬁlter constraint containing
the bound operator (see [17], Sec. 11.4.1). This style of negation, called negation 
as failure in logic programming, can be illustrated as a graph pattern P
of the form ((P1 OPT P2) FILTER(! bound(?X))) where ?X is a variable of P2
not occurring in P1. Note that, the evaluation of P returns the mappings of
J(P1 OPT P2)K satisfying that variable ?X is unbounded, i.e. ?X does not match
P2. In other words, P returns “the solution mappings of P1 that are not compatible 
with the solutions mappings of P2”. Unfortunately, this simulation does no
work for the general case [5]. A discussion of the issues and the general solution
for implementing negation by failure is included in Appendix A.

In order to facilitate the study of negation by failure in SPARQL, we introduce 
the operator DIFF as an explicit way of expressing it.

Deﬁnition 1 (DIFF). Let P1 and P2 be graph patterns. The DIFF operator is
deﬁned as J(P1 DIFF P2)K = {µ1 ∈ JP1K | ∀µ2 ∈ JP2K,µ1 ≁ µ2}.

It is very important to note that the DIFF operator is not deﬁned in SPARQL
1.0 nor in SPARQL 1.1. However, it can be directly implemented with the difference 
operator of the algebra of solution mappings.

Negation by MINUS. SPARQL 1.1 introduced the MINUS operator as an explicit 
way of expressing the negation (or diﬀerence) of graph patterns. Note that
DIFF and MINUS have similar deﬁnitions. The diﬀerence is given by the restriction 
about disjoint mappings included by the MINUS operator. Such restriction,
named Antijoin Restriction inside the SPARQL working group7, was introduced
to avoid solutions with vacuously compatible mappings. Such restriction causes
diﬀerent results for DIFF and MINUS. Basically, if P1 and P2 do not have variables 
in common then J(P1 DIFF P2)K = ∅ whereas J(P1 MINUS P2)K = JP1K.

Note that both, DIFF and MINUS resemble the EXCEPT operator of SQL[14],
i.e. given two SQL queries Q1 and Q2, the expression (Q1 EXCEPT Q2) allows
to return all rows that are in the table obtained from Q1 except those that
also appear in the table obtained from Q2. Considering that EXCEPT makes
reference to the diﬀerence of two relations (tables), we can say that DIFF and
MINUS allow to express the diﬀerence of two graph patterns.

Negation by NOT-EXISTS. Another type of negation deﬁned in SPARQL
1.1 is given by the NOT-EXISTS operator. The main feature of this type of
negation is the possible occurrence of correlation. Given a graph pattern P =
(P1 NOT-EXISTS P2), we will say that P1 and P2 are correlated when var(P1) ∩
var(P2) 6= ∅, i.e. there exist variables occurring in both P1 and P2, and such
variables are called correlated variables. In this case, the evaluation of P is attained 
by replacing variables in P2 with the corresponding values given by the
current mapping µ of JP1K, and testing whether the evaluation of the graph

7 http://lists.w3.org/Archives/Public/public-rdf-dawg/2009JulSep/0030.

html

pattern µ(P2) returns no solutions. This way of evaluating correlated queries is
based on the nested iteration method [13] of SQL. The correlation of variables in
NOT-EXISTS introduces several issues that have been studied in the context of
subqueries in SPARQL [3, 4]. Some of these issues are discussed in Section 4.2.
DIFF, MINUS and NOT-EXISTS are three diﬀerent ways of expressing negation 
in SPARQL. DIFF and MINUS represent the diﬀerence of two graph patterns 
whereas NOT-EXISTS tests the presence of a graph pattern.

4 Expressive Power

Let us recall some deﬁnitions related to expressive power. By the expressive
power of a query language, we understand the set of all queries expressible in
that language [1]. We will say that an operator O is expressible in a language L
iﬀ a subset of the operators of L allow to express the same queries as O. Finally,
a language L contains a language L′ iﬀ every operator of L′ is expressible by L.
In this section we study the expressive power of the negation operators deﬁned 
in the above section, i.e. DIFF, MINUS and NOT-EXISTS. First, we introduce 
a “core” SPARQL algebra which contains the W3C SPARQL algebra,
but having the advantage of being smaller and simpler. Such core algebra is the
basis to deﬁne equivalences among graph pattern operators, in particular those
implementing negation.

4.1 The core SPARQL algebra

Let us introduce a “core” algebra for SPARQL which is able to express all
the high-level operators of the W3C SPARQL language. Recall that the W3C
SPARQL algebra, deﬁned in Section 2, is composed by the operators of projection,
 selection, join, union, left-join and minus. Our core algebra is based on a
new operator called “simple diﬀerence”.

Deﬁnition 2 (Simple diﬀerence). The simple diﬀerence between two solution
mappings, Ω1 and Ω2, is deﬁned as Ω1 \ Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2}
where card(µ1, Ω1 \ Ω2) = card(µ1, Ω1).

Deﬁnition 3 (Core SPARQL algebra). The core SPARQL algebra is composed 
by the operations of projection, selection, join, union and simple diﬀerence.

Next, we will show that the core SPARQL algebra contains the W3C SPARQL
algebra. Speciﬁcally, we will show that the operators of diﬀerence, left-join and
minus (of the W3C SPARQL algebra) can be simulated with the simple diﬀerence 
operator (of the core SPARQL algebra).

Lemma 1. The diﬀerence operator (of the W3C SPARQL algebra) is expressible
in the core SPARQL algebra.

Proof. Recall that the diﬀerence operator is deﬁned as
Ω1 \F Ω2 = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, (µ1 ≁ µ2) ∨ (µ1 ∼ µ2 ∧ (µ1 ∪ µ2)(F ) = false)}.
Assume that Ω′
1 is the complement of Ω1 \F Ω2. We
have that µ1 ∈ Ω′
1 iﬀ there exists a mapping µ2 ∈ Ω2 satisfying that µ1 ∼ µ2
and (µ1 ∪ µ2)(F ) evaluates to either true or error. Hence, we will have that

1 = Ω1 \ (Ω1 \F Ω2), i.e. Ω′

Ω1 \F Ω2 = Ω1 \ (σF (Ω1 ⋊⋉ Ω2) ∪ ((Ω1 ⋊⋉ Ω2) \ (σ(F ∨¬F )(Ω1 ⋊⋉ Ω2))))

where σF (Ω1 ⋊⋉ Ω2) corresponds to the mappings evaluating F as true, and
((Ω1 ⋊⋉ Ω2) \ (σ(F ∨¬F )(Ω1 ⋊⋉ Ω2))) corresponds to the mappings evaluating F
as error.

Note that the above equivalence is based on a faithful interpretation as occurs
in the current speciﬁcation. However, the document of errata in SPARQL 1.1
includes a clariﬁcation that diﬀers of our interpretation8: “The deﬁnition of
Diﬀ should more clearly say that expressions that evaluate with an error are
considered to be false.” Under this interpretation, the proof is much simpler9:

Ω1 \F Ω2 = Ω1 \ (σF (Ω1 ⋊⋉ Ω2)).

Lemma 2. The left-join operator (of the W3C SPARQL algebra) is expressible
in the core SPARQL algebra.

Proof. Recall that Ω1qy⋊⋉ F Ω2 = σF (Ω1 ⋊⋉ Ω2) ∪ (Ω1 \F Ω2). Considering that
the diﬀerence expression (Ω1 \F Ω2) can be expressed with simple diﬀerence
(Lemma 1), we have that

Ω1qy⋊⋉ F Ω2 = σF (Ω1 ⋊⋉ Ω2) ∪ (Ω1 \ (σF (Ω1 ⋊⋉ Ω2)))

Lemma 3. The minus operator (of the W3C SPARQL algebra) is expressible
in the core SPARQL algebra.

Proof. Note that the diﬀerence between Ω1 − Ω2 and Ω1 \ Ω2 is given by the
condition dom(µ1) ∩ dom(µ2) = ∅. Intuitively, it applies that (Ω1 − Ω2) = Ω1
when dom(Ω1) ∩ dom(Ω2) = ∅. In the case that dom(Ω1) ∩ dom(Ω2) 6= ∅, the
rewriting is a little more tricky.

Recall that the operation Ω1 − Ω2 is deﬁned by the set

S = {µ1 ∈ Ω1 | ∀µ2 ∈ Ω2, µ1 ≁ µ2 ∨ dom(µ1) ∩ dom(µ2) = ∅}.

8 https://www.w3.org/2013/sparql-errata#errata-query-12
9 In an earlier version of this report, the proof of Lemma 1 was based on the full
deﬁnition of LeftJoin presented in Sec. 18.5 of the current SPARQL 1.1 speciﬁcation,
 a statement that was reported to be wrong in the errata http://www.w3.org/
2013/sparql-errata#errata-query-7a (We thank to R. Kontchakov, who called
to our attention this issue in a personal communication, May 19th, 2016.) The same
bug in the proof of Lemma 1 was included in the article “Negation in SPARQL”
(Alberto Mendelzon International Workshop on Foundations of Data Management,
AMW’2016). Fortunately, the problem was with the proof, not with the statement
of the Lemma which remains untouched and thus does not aﬀect the rest of results
in such article nor in this report.

Note that the complement of S in Ω1 is the set
Sc = {µ1 ∈ Ω1 | ∃µ2 ∈ Ω2, µ1 ∼ µ2 ∧ dom(µ1) ∩ dom(µ2) 6= ∅}.
Assuming that dom(Ω1) ∩ dom(Ω2) = {?X1, . . . , ?Xn}, (Ω1 − Ω2) can be simulated 
with an expression of the form Ω1 \ (σF (Ω1 ⋊⋉ Ω3)) where Ω3 is a copy of
Ω2 where every variable Xi has been replaced with a free variable X ′
i, and F is
a selection formula of the form (. . . (?X1 =?X ′
n).
Note that, the expression σF (Ω1 ⋊⋉ Ω3) returns the set Sc, which is subtracted
from Ω1 to obtain S. It is easy to see that the proposed equivalent expression preserves 
the cardinalities. Hence, we have proved that (Ω1 − Ω2) can be simulated
with (Ω1 \ Ω2).

2) . . . )∧?Xn =?X ′

1∧?X2 =?X ′

Based on Lemmas 1, 2 and 3, we can present our main result about the

expressive power of the core SPARQL algebra.

Theorem 1. The core SPARQL algebra is equivalent with the W3C SPARQL
algebra.

This result implies that the W3C SPARQL algebra could be implemented
by a subset of the original operators (projection, selection, join and union), plus
the simple diﬀerence operator.

4.2 SPARQLDIFF: A core fragment with negation

Let us redeﬁne the DIFF operator by using the simple diﬀerence operator of the
core algebra as follows:

J(P1 DIFF P2)K = JP1K \ JP2K.

Assume that SPARQLDIFF is the language deﬁned (recursively) by graph patterns 
of the form (P AND P ′), (P UNION P ′), (P DIFF P ′) and (P FILTER C).
Next, we will show that SPARQLDIFF can express a fragment of SPARQL whose
NOT-EXISTS graph patterns satisfy a restricted notion of correlated variables.

Expressing OPTIONAL and MINUS with DIFF Here, we show that the
OPT and MINUS operators can be expressed in SPARQLDIFF by using the DIFF
operator.

Lemma 4. The OPT operator is expressible in SPARQLDIFF.

Proof. Recall the semantics of optional graph patterns as presented in Section
2. Given a graph pattern P of the form (P1 OPT P2), we have two cases:
(i) if P2 is (P3 FILTER C) then JP K = JP1Kqy⋊⋉ f (C)JP3K;
(ii) else, JP K = JP1Kqy⋊⋉ (true)JP2K.
Note that this deﬁnition follows an operational semantics in the sense that the
evaluation of (P1 OPT P2) depends on the structure of P2, i.e. when P2 is a ﬁlter
graph pattern applies case (i), otherwise case (ii) . Let us analyze both cases.

Case (i): We have that JP1Kqy⋊⋉ f (C)JP3K = σF (Ω1 ⋊⋉ Ω3) ∪ (Ω1 \F Ω3) where
Ω1 = JP1K, Ω3 = JP3K and F = f (C). If we rewrite the right side in terms of
simple diﬀerence (Lemma 2), we obtain σF (Ω1 ⋊⋉ Ω3) ∪ (Ω1 \ (σF (Ω1 ⋊⋉ Ω3))).
Similarly, the graph pattern (P1 OPT(P3 FILTER C)) can be rewritten as

(((P1 AND P3) FILTER C) UNION(P1 DIFF((P1 AND P3) FILTER C))).

Case (ii): We have that JP1Kqy⋊⋉ (true)JP2K = σ(true)(Ω1 ⋊⋉ Ω2) ∪ (Ω1 \(true) Ω2)
where Ω1 = JP1K and Ω2 = JP2K. If we rewrite the right side in terms of simple
diﬀerence (Lemma 2), we obtain σ(true)(Ω1 ⋊⋉ Ω2) ∪ (Ω1 \ (σ(true)(Ω1 ⋊⋉ Ω2))),
which can be reduced to (Ω1 ⋊⋉ Ω2) ∪ (Ω1 \ (Ω1 ⋊⋉ Ω2)). Similarly, the graph
pattern (P1 OPT P2) can be rewritten as

((P1 AND P2) UNION(P1 DIFF(P1 AND P2))).

Hence, we can use the above transformation to simulate the operational semantics 
of OPT by using DIFF, i.e. OPT is expressible in SPARQLDIFF.

Lemma 5. The MINUS operator is expressible in SPARQLDIFF.

Proof. Given a graph pattern (P1 MINUS P2), we have that:
(i) If var(P1) ∩ var(P2) = ∅ then J(P1 MINUS P2)K = JP1K.
(ii) Else, J(P1 MINUS P2)K = Ω1 − Ω2 where Ω1 = JP1K and Ω2 = JP2K.
Recalling the simulation of (Ω1 − Ω2) with (Ω1 \ Ω2) presented in Lemma 3,
we have that (P1 MINUS P2) can be rewritten to a graph pattern of the form
(P1 DIFF((P1 AND P3) FILTER C)) where P3 and C must be created by following 
a procedure similar to the one described in Lemma 3. Hence, we have proved
that MINUS can be expressed in SPARQLDIFF.

NOT-EXISTS vs DIFF In order to give a basic idea of the expressive power
of NOT-EXISTS, we will analyze its relationship with the DIFF operator. Given
the graph patterns P = (P1 NOT-EXISTS P2) and P ′ = (P1 DIFF P2), the basic
case of equivalence between P and P ′ is given when var(P1) ∩ var(P2) = ∅. Note
that, the non occurrence of correlated variables between P1 and P2 implies that,
both P and P ′ are restricted to test whether P2 returns an empty solution.

Intuitively, one can assume that any graph pattern P = (P1 NOT-EXISTS P2)
can be directly translated into P ′ = (P1 DIFF P2) such that P and P ′ are equivalent.
 This is for example argued by Kaminski et. al [12] (Lemma 3). However,
the translation given there does not work. For instance, consider the graph G =
{(a,p,b),(f,p,b),(c,q,d),(e,r,a)} and the graph patterns
P = ((?X p b) NOT-EXISTS ( (?Z q d) NOT-EXISTS (?W r ?X))) and
P ′ = ((?X p b) DIFF ( (?Z q d) DIFF (?W r ?X))).
In this case, P are P ′ are not equivalent such that JP KG = {µ?X→a} whereas
JP ′KG = {µ?X→a, µ′

?X→f }.

Despite the above negative result, it will be interesting to identify a subset of
NOT-EXISTS graph patterns that can be expressed by using the DIFF operator.
To do this, we will introduce the notion of “safe” and “unsafe” variables. The set

of safe variables in a graph pattern P , denoted svar(P ), is deﬁned recursively as
follows: If P is a triple pattern, then svar(P ) = var(P ); If P is (P1 AND P2)
then svar(P ) = svar(P1) ∪ svar(P2); If P is (P1 UNION P2) or (P1 OPT P2)
then svar(P ) = svar(P1) ∩ svar(P2); If P is (P1 FILTER C), (P1 MINUS P2),
(P1 NOT-EXISTS P2) or (P1 DIFF P2) then svar(P ) = svar(P1). Therefore, a
variable occurring in svar(P ) is called a safe variable, otherwise it is considered
unsafe in P .

Deﬁnition 4 (SPARQLNEX
safe as the fragment of SPARQL
graph patterns satisfying that the occurrence of a subpattern (P NOT-EXISTS P ′)
implies that, for every correlated variable ?X between P and P ′, it holds that
?X ∈ svar(P ′).

safe ). Deﬁne SPARQLNEX

Note that, SPARQLNEX does not allow graph patterns of the form

(P1 NOT-EXISTS(P2 NOT-EXISTS P3)) where P3 contains correlated variables
occurring in P1 but not occurring in P2.

Lemma 6. The NOT-EXISTS graph patterns allowed in SPARQLNEX
pressible in SPARQLDIFF.

safe are exProof.
 Following the deﬁnition of SPARQLNEX
safe , we have that for any graph pattern 
(P1 NOT-EXISTS P2) it satisﬁes that the domain of JP2K contains all the
correlated variables between P1 and P2. Given such condition, it is easy to see
that J(P1 DIFF P2)K returns the same solutions as J(P1 NOT-EXISTS P2)K.

Based on Lemmas 4, 5 and 6, we can present our main result about the

expressive power of the DIFF operator and SPARQLDIFF.

Theorem 2. SPARQLDIFF contains SPARQLNEX
safe .

5 Properties of the SPARQL negation operators

In this section we evaluate the negation operators in terms of elementary equivalences 
found in set theory. Speciﬁcally, we consider the following axioms concerning 
set-theoretic diﬀerences [18]:

(g) A \ (A ∩ B) ≡ A \ B
(h) A ∩ (A \ B) ≡ A \ B
(i) (A \ B) ∪ B ≡ A ∪ B
(j) (A ∪ B) \ B ≡ A \ B
(k) A \ (B ∩ C) ≡ (A \ B) ∪ (A \ C)
(l) A \ (B ∪ C) ≡ (A \ B) ∩ (A \ C)

(a) A \ A ≡ ∅
(b) A \ ∅ ≡ A
(c) ∅ \ A ≡ ∅
(d) A \ (A \ (A \ B)) ≡ A \ B
(e) (A ∩ B) \ B ≡ ∅
(f ) (A \ B) ∩ B ≡ ∅
Our motivation to consider these equivalences is given by the intrinsic nature
of expressing negation in SPARQL, i.e. the diﬀerence of graph patterns. Moreover,
 set-theoretic equivalences are supported by other database languages like
relational algebra and SQL. Recalling that SPARQL works under bag semantics,
we will evaluate the behavior of the negation operators by examining both, set
and bag semantics.

Let us deﬁne the notion of equivalence between graph patterns. Two graph
patterns P1 and P2 are equivalent, denoted by P1 ≡ P2, if it satisﬁes that
JP1KG = JP2KG for every RDF graph G. In order to evaluate the set-based
equivalences in the context of SPARQL, we need to assume two conditions:

(1) As a general rule, a set-based operator requires two “objects” with the
same structure (e.g. two tables with the same schema). Such requirement
is implicitly satisﬁed in SPARQL thanks to the deﬁnition of solution mappings 
as partial functions. Basically, if we ﬁx the set of variables V , then
we have that for every pair of solution mappings Ω1 and Ω2 it satisﬁes that
dom(Ω1) = dom(Ω2), i.e. Ω1 and Ω2 have the same domain of variables (even
when some variables could be unbounded). Hence, set-based operations like
union and diﬀerence can be applied to the algebra of solution mappings.

(2) SPARQL does not provide an explicit operator for intersecting two graph
patterns P1 and P2, i.e. the solution mappings which belong both to JP1K
and JP2K. Note however, that a graph pattern (P1 AND P2) resembles the
intersection operation (under set-semantics) when JP1K and JP2K have the
same domain of variables. Recalling condition (1), we will assume that the
AND operator could be used to play the role of the intersection operator in
the set-theoretic equivalences deﬁned above.

Given the above two conditions, we can apply a direct translation from a
set-theoretic equivalence to a graph pattern equivalence. Speciﬁcally, the setdiﬀerence 
operator will be mapped to a SPARQL negation operator (DIFF, MINUS 
or NOT-EXISTS), the set-intersection operator will be mapped to AND,
and the set-union operator will be replaced by UNION. Considering the speciﬁc 
features of NOT-EXISTS (i.e. correlation of variables), we will restrict our
analysis to DIFF and MINUS.

Let P1, P2, P3, P4 and P5 be graph patterns satisfying that JP1K = ∅,
JP2K = {µ0}, var(P3) = var(P4) and var(P3) ∩ var(P5) = ∅. By combining
the above four graph patterns, we conducted a case-by-case analysis consisting
of twenty ﬁve cases for equivalences (a)-(j) and one hundred twenty ﬁve cases
for equivalences (k) and (l). The diﬀerences between set and bag semantics were
specially considered for equivalences (h), (i), (k) and (l). Next, we present our
ﬁndings.

DIFF satisﬁes most equivalences with exception of (h), (i), (k) and (l). Equivalence 
(h) presents ﬁve cases which are not valid under bag semantics, although
they are valid under set semantics. A similar condition occurs with ten and seven
cases for equivalences (k) and (l) respectively. Additionally, we found ten cases
which are not satisﬁed by equivalence (i).

MINUS does not satisfy equivalences (e) to (l). We found several cases where
equivalences (e), (f), (g), (j) and (k) are not satisﬁed. Similarly, there exist multiple 
cases where equivalences (h), (i) and (l) do not apply under bag semantics,
but works for set semantics. We would like to remark that the “odd results”
presented by the MINUS operator arise because the restriction about disjoint
solution mappings introduced in its deﬁnition.

In summary, we have that each negation operator presents a particular behavior 
for the axioms studied here. Although none of them was able to satisfy
all the axioms, we think that it does not mean that they are badly deﬁned. In
fact, the heterogeneity of the operators is a motivation to study their intrinsic
properties and to try the deﬁnition of a set of desired properties for negation
in SPARQL. The details about our case-by-case analysis are included in the
Appendix.

6 Conclusions

In this paper we presented a systematic analysis of the types of negation supported 
in SPARQL 1.0 and SPARQL 1.1. After introducing the standard relational 
negation (the DIFF operator) we were able to build a core and intuitive
algebra (the same as the standard relational algebra) in SPARQL and prove that
it is able to deﬁne the graph pattern operators.

We think that having a clear understanding of the operators of a language
(in this case, the operators of negation of SPARQL) helps both, developers of
databases, and users of the query language. We also think that the core language
we identiﬁed (which is precisely the well known and intuitive relational algebra)
is a much easier way to express queries for database practitioners, who learn
from the beginning SQL, which now with this new algebra, can be found in the
world of SPARQL.
Acknowledgements. R. Angles and C. Gutierrez are founded by the Millennium 
Nucleus Center for Semantic Web Research under Grant NC120004.

References

1. Abiteboul, S., Hull, R., Vianu, V.: Foundations of Databases. Addison-Wesley

(1995)

2. Angles, R., Gutierrez, C.: The Expressive Power of SPARQL. In: Proceedings of
the 7th International Semantic Web Conference (ISWC). pp. 114–129. No. 5318 in
LNCS (2008)

3. Angles, R., Gutierrez, C.: SQL Nested Queries in SPARQL. In: Proc. of the 4th

Alberto Mendelzon Workshop on Foundations of Data Management (2010)

4. Angles, R., Gutierrez, C.: Subqueries in SPARQL. In: Proc. of the 5th Alberto

Mendelzon Workshop on Foundations of Data Management (2011)

5. Angles, R., Gutierrez, C.: Negation in SPARQL. Talk at 8th Alberto Mendelzon

International Workshop on Foundations of Data Management (AMW) (2014)

6. Arenas, M., P´erez, J.: Querying Semantic Web Data with SPARQL. In: 30th ACM

Symposium on Principles of Database Systems (PODS) (2011)

7. B´ar´any, V., Cate, B., Segouﬁn, L.: Guarded negation. Journal of the ACM 62(3),

22:1–22:26 (2015)

8. Bidoit, N.: Negation in rule-based database languages: A survey. Theoretical Computer 
Science 78(1), 3–83 (1991)

9. Gelfond, M., Lifschitz, V.: Classical Negation in Logic Programs and Disjunctive

Databases. New Generation Computing 9(3), 365–386 (1991)

10. Harris, S., Seaborne, A.: SPARQL 1.1 Query Language - W3C Recommendation.

http://www.w3.org/TR/2013/REC-sparql11-query-20130321/ (March 21 2013)

11. Hogan, A., Arenas, M., Mallea, A., Polleres, A.: Everything you always wanted to

know about blank nodes. Journal of Web Semantics 27(1) (2014)

12. Kaminski, M., Kostylev, E.V., Cuenca Grau, B.: Semantics and Expressive Power
of Subqueries and Aggregates in SPARQL 1.1. In: Proc. of the International Conference 
on World Wide Web. pp. 227–238 (2016)

13. Kim, W.: On optimizing an SQL-like nested query. ACM Transactions on Database

Systems (TODS) 7(3), 443–469 (1982)

14. Melton, J., Simon, A.R.: SQL:1999 Understanding Relational Language Components.
 Morgan Kaufmann (May 2001)

15. Naqvi, S.A.: Negation as failure for ﬁrst-order queries. In: Proc. of the Symposium

on Principles of Database Systems. pp. 114–122. ACM (1986)

16. P´erez, J., Arenas, M., Gutierrez, C.: Semantics and Complexity of SPARQL. ACM

Transactions on Database Systems (TODS) 34(3), 1–45 (2009)

17. Prud’hommeaux, E., Seaborne, A.: SPARQL Query Language for RDF.
W3C Recommendation. http://www.w3.org/TR/2008/REC-115-sparql-query-
20080115/ (January 15 2008)

18. Suppes, P.: Axiomatic Set Theory. The University Series in Undergraduate Mathematics,
 D. Van Nostrand Company, Inc. (1960)

19. Wagner, G.: A database needs two kinds of negation. In: Proc. of the Symposium
on Mathematical Fundamentals of Database and Knowledge Base Systems. pp.
357–371 (1991)

20. Wagner, G.: Web rules need two kinds of negation. In: Proc. of Int. Workshop on
Principles and Practice of Semantic Web Reasoning. pp. 33–50. Springer Berlin
Heidelberg (2003)

A Simulation of Negation as Failure in SPARQL

In order to conduct our discussion about the simulation of negation by failure in
SPARQL, we need to introduce two concepts: RDF Datasets and the GRAPH
operator.

An RDF dataset D is a set {G0, hu1, G1i, . . . , hun, Gni} where each Gi is
a graph and each uj is an IRI. G0 is called the default graph of D and it is
denoted dg(D). Each pair hui, Gii is called a named graph; deﬁne name(Gi)D =
ui and gr(ui)D = Gi. The set of IRIs {u1, . . . , un} is denoted names(D). Every
dataset satisﬁes that: (i) it always contains one default graph (which could be
empty); (ii) there may be no named graphs; (iii) each uj is distinct; and (iv)
blank(Gi) ∩ blank(Gj) = ∅ for i 6= j. Finally, the active graph of D is the graph
Gj used for querying D.

Next, we also extend the graph pattern evaluation function. The evaluation
of a graph pattern P over a dataset D with active graph G will be denoted as
JP KD
G returns
the multiset of mappings that matches the dataset D according to the graph
pattern P .

G (or JP KG where D is clear from the context). Speciﬁcally, JP KD

Let us extend the (recursive) deﬁnition of graph pattern. Given a graph
pattern P and n ∈ I ∪ V , we have that (n GRAPH P ) is also a graph pattern.
The semantics of (n GRAPH P ) is given as follows:

1. If u ∈ I then J(u GRAPH P )KD = JP KD

G where G = gr(u)D

2. If ?X ∈ V then J(?X GRAPH P )KD = Sv∈names(D)(JP KD

gr(v)D

⋊⋉ {µ?X→v})

We are ready to begin our analysis. In Section 3, we argued that the Negation

by Failure, and also (P1 DIFF P2), can be simulated by a pattern of the form

((P1 OPT P2) FILTER(! bound(?X)))

(1)

where ?X is a variable of P2 not occurring in P1. Unfortunately, there are two
issues with this solution:

– Variable ?X cannot be an arbitrary variable. For example, P2 could be in
turn an optional pattern (P3 OPT P4) where only variables in P3 are relevant
to evaluate the condition (! bound(?X)).

– If P1 and P2 do not have variables in common, then there is no variable ?X

to check unboundedness.

Angles and Gutierrez [2] identiﬁed these issues and proposed a solution for

them. The solution was shown to have a small bug.

Perez’s solution. A second approach which ﬁxed the previous bag was presented
in [6], where it was proposed that (P1 DIFF P2) can be simulated by the pattern

((P1 OPT (P2 AND (?X1 ?X2 ?X3))) FILTER ¬ bound(?X1))

(2)

where ?X1, ?X2, ?X3 are fresh variables mentioned neither in P1 nor in P2.

This solution works well when the empty graph pattern is not allowed in the
grammar. In the presence of it, the counter example is given when P1 and P2 are
empty graph patterns and the default graph is the empty graph. In this case, we
have that J(P1 DIFF P2)KD

G0 = ∅ whereas J(2)KD

G0 = {Ω0} .

Polleres’s solution. A third proposal was sketched by Axel Polleres in the mailing
list of the SPARQL W3C Working Group, and discussed with the authors of
this paper during the year 2009. The proposed solution is deﬁned formally in
the following proposition.

Proposition 1. Let P1, P2 be graph patterns. We have that (P1 DIFF P2) is
equivalent to

(((P1 OPT P2) AND(g GRAPH (?X:p :o))) FILTER ¬ bound(?X))

(3)

where g is a named graph containing the single triple (:s :p :o) and ?X is a free
variable.

Proof. In order to prove that the above equivalence holds, we have analyzed
the corner cases for (P1 DIFF P2). In Table 2, we compare the evaluation of the
graph patterns presented in Proposition 1, considering all the possible solutions
for JP1K and JP2K, and including the special case when the default graph is
the empty graph. We showed that the evaluation of both graph patterns are
equivalent for all the cases. Additionally, Table 2 includes the results for the
graph pattern presented in Equation 2, and shows that it fails in the case (5)
when the default graph is the empty graph as described before.

JP1K JP2K J(P1 DIFF P2)K

JP3K

JP4K

JP3K JP4K

G0 6= ∅

G0 = ∅

∅
∅
1
∅ Ω0
2
∅ Ω2
3
∅
4 Ω0
5 Ω0 Ω0
6 Ω0 Ω2
∅
7 Ω1
8 Ω1 Ω0
9 Ω1 Ω1
10 Ω1 Ω2
11 Ω1 Ω3

∅
∅
∅
Ω0
∅
∅
Ω1
∅
∅

∅
∅
∅
Ω0
∅
∅
Ω1
∅
∅

∅
∅
∅
Ω0
∅
∅
Ω1
∅
∅

Ω1 \ Ω2

Ω1 \ Ω2 Ω1 \ Ω2

∅

∅

∅

∅
∅
∅
∅
∅
∅
Ω0 Ω0
∅
Ω0
–
–
–
–
–
–
–
–
–
–
–
–

Table 2. Comparison of two implementations of diﬀerence of SPARQL graph patterns.
Assume that Ω0 = {µ0} (join identity), and Ω1, Ω2, Ω3 are sets of mappings distinct
of Ω0. Additionally, dom(Ω1) ∩ dom(Ω2) 6= ∅ and dom(Ω1) ∩ dom(Ω3) = ∅. P3 and P4
are the graph patterns presented in Equations 2 and 3 respectively. Note that, JP4K is
equivalent to J(P1 DIFF P2)K in all the cases, whereas JP3K fails when G0 = ∅ (i.e. the
default graph G0 is the empty graph).

B Case-by-case analysis

Let P∅, P1, P2 and P3 be graph patterns satisfying that JP∅K = ∅, JP1K 6=
∅, JP2K 6= ∅ and JP3K 6= ∅. Also assume that Ω1, Ω2 and Ω3 are solutions
mappings satisfying that dom(Ω1) ∩ dom(Ω2) 6= ∅, dom(Ω1) ∩ dom(Ω3) = ∅ and
dom(Ω2) ∩ dom(Ω2) = ∅ Finally, recall that Ω0 denotes the multiset consisting
of exactly the empty mapping µ0.

We will show, for each axiom, examples of cases not satisﬁed by the negation
operators. We will use a generic operator NEG to denote any of the operators
used in our analysis, i.e. DIFF and MINUS.

Axiom (a): (P1 NEG P2) ≡ ∅ .

Both, DIFF and MINUS satisfy in all the cases.

Axiom (b): (P1 NEG P∅) ≡ P1

.

Both, DIFF and MINUS satisfy in all the cases.

Axiom (c): (P∅ NEG P1) ≡ ∅ .

Both, DIFF and MINUS satisfy in all the cases.

Axiom (d): (P1 NEG(P1 NEG(P1 NEG P2))) ≡ (P1 NEG P2) .

Both, DIFF and MINUS satisfy in all the cases.

Axiom (e): ((P1 AND P2) NEG P2) ≡ P∅

.

– DIFF satisﬁes in all the cases.
– MINUS fails in four cases. For instance, if JP1K = Ω0 and JP2K = Ω0 then

J((P1 AND P2) MINUS P2)K = Ω0 instead of ∅.

Axiom (f ): ((P1 NEG P2) AND P2) ≡ P∅

.

– DIFF satisﬁes in all the cases.
– MINUS fails in eleven cases. For instance, if JP1K = Ω0 and JP2K = Ω2 then

J((P1 MINUS P2) AND P2)K = Ω2 instead of ∅.

Axiom (g): (P1 NEG(P1 AND P2)) ≡ (P1 NEG P2) .

– DIFF satisﬁes in all the cases.
– MINUS fails in seven cases. For instance, if JP1K = Ω1 and JP2K = Ω0 then

J(P1 MINUS(P1 AND P2))K = Ω0 whereas J(P1 MINUS P2)K = Ω1.

Axiom (h): (P1 AND(P1 NEG P2)) ≡ (P1 NEG P2) .

– Both, DIFF and MINUS fail under bag semantics, in ﬁve and twelve cases

respectively.

– For instance, both operators fail when JP1K = Ω1 and JP2K = ∅ such that

J(P1 AND(P1 NEG P2))K = Ω1 ⋊⋉ Ω1 whereas J(P1 NEG P2)K = Ω1.

Axiom (i): ((P1 NEG P2) UNION P2) ≡ (P1 UNION P2) .

– DIFF generates distinct solutions in ten cases, and fails under bag semantics

in four cases. For instance, if JP1K = Ω0 and JP2K = Ω1 then
((P1 DIFF P2) UNION P2) = Ω1 whereas (P1 UNION P2) = Ω0 ∪ Ω1.

– MINUS fails under bag semantics in three cases. For instance, if JP1K = Ω1

and JP2K = Ω1 then J((P1 MINUS P2) UNION P2)K = Ω1 whereas
J(P1 UNION P2)K = Ω1 ∪ Ω1.

Axiom (j): ((P1 UNION P2) NEG P2) ≡ (P1 NEG P2) .

– DIFF satisﬁes in all the cases.
– MINUS fails in four cases. For instance, if JP1K = Ω1 and JP2K = Ω0 then

J((P1 UNION P2) MINUS P2)K = Ω1 ∪ Ω0 whereas J(P1 MINUS P2)K = Ω1.

Axiom (k): (P1 NEG(P1 AND P 3)) ≡ ((P1 NEG P1) UNION(P1 NEG P3)
.

– DIFF fails in ten cases under bags semantics. For instance, if JP1K = Ω1,
JP2K = Ω0 and JP3K = Ω2 then J(P1 DIFF(P1 AND P 3))K = Ω2 whereas
J((P1 DIFF P1) UNION(P1 DIFF P3)K = (Ω2 \ Ω1) ∪ Ω2.

– MINUS generates distinct solutions in twenty two cases, and fails under bag
semantics in sixty ﬁve cases. For instance, if JP1K = Ω0, JP2K = Ω1 and
JP3K = Ω1 then J(P1 MINUS(P1 AND P 3))K = Ω0 whereas
J((P1 MINUS P1) UNION(P1 MINUS P3)K = Ω1.

Axiom (l): (P1 NEG(P1 UNION P 3)) ≡ ((P1 NEG P1) AND(P1 NEG P3)
.

– Under bag semantics, DIFF and MINUS fail in seven and forty eight cases

respectively.

– For instance, both operators fail when JP1K = Ω0, JP2K = Ω0 and JP3K = Ω1

such that J(P1 NEG(P1 UNION P 3))K = Ω1 and
J((P1 NEG P1) AND(P1 NEG P3)K = Ω1 ⋊⋉ Ω1.

